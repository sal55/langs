;NASM VERSION
    default rel
    extern fmod
    extern sin
    extern cos
    extern tan
    extern asin
    extern acos
    extern atan
    extern log
    extern log10
    extern exp
    extern floor
    extern ceil
    extern pow
    extern exit
    extern __getmainargs
    global main

    global msys.$cmdskip
    extern malloc
    extern realloc
    extern free
    extern memset
    extern memcpy
    extern memmove
    extern clock
    extern ftell
    extern fseek
    extern fread
    extern fwrite
    extern getc
    extern ungetc
    extern fopen
    extern fclose
    extern fgets
    extern remove
    extern rename
    extern getchar
    extern putchar
    extern setbuf
    extern strlen
    extern strcpy
    extern strcmp
    extern strncmp
    extern strncpy
    extern memcmp
    extern strcat
    extern tolower
    extern toupper
    extern isalpha
    extern isupper
    extern islower
    extern isalnum
    extern isspace
    extern strstr
    extern atol
    extern atoi
    extern strtod
    extern _strdup
    extern puts
    extern printf
    extern sprintf
    extern sscanf
    extern scanf
    extern rand
    extern srand
    extern system
    extern fgetc
    extern fputc
    extern fprintf
    extern fputs
    extern feof
    extern getch
    extern _getch
    extern kbhit
    extern _mkdir
    extern mkdir
    extern strchr
    extern _setmode
    extern _exit
    extern exit
    extern pow
    extern sin
    extern cos
    extern tan
    extern asin
    extern acos
    extern atan
    extern log
    extern log10
    extern exp
    extern floor
    extern ceil
    extern qsort
    extern __getmainargs
    extern GetStdHandle
    extern GetConsoleScreenBufferInfo
    extern SetConsoleCtrlHandler
    extern SetConsoleMode
    extern CreateProcessA
    extern GetLastError
    extern WaitForSingleObject
    extern GetExitCodeProcess
    extern CloseHandle
    extern GetNumberOfConsoleInputEvents
    extern FlushConsoleInputBuffer
    extern LoadLibraryA
    extern GetProcAddress
    extern LoadCursorA
    extern RegisterClassExA
    extern DefWindowProcA
    extern ReadConsoleInputA
    extern Sleep
    extern GetModuleFileNameA
    extern ExitProcess
    extern PostQuitMessage
    extern MessageBoxA
    extern QueryPerformanceCounter
    extern QueryPerformanceFrequency
    extern CreateFileA
    extern GetFileTime
    extern GetSystemTime
    extern GetLocalTime
    extern GetTickCount64
    extern PeekMessageA
    extern GetCommandLineA
    extern VirtualAlloc
    extern VirtualProtect
    extern WriteConsoleA
    extern FindFirstFileA
    extern FindNextFileA
    extern FindClose
    extern MessageBeep
    extern Beep
    global mm.main

    segment .bss
    alignb    8
msys.fmtparam:
    resb      8
    alignb    8
msys.$cmdskip:
$cmdskip:
    resb      8
    segment .data
    align     8
msys.needgap:
    dq  0
    align     8
msys.outdev:
    dq  1
    align     8
msys.outchan:
    dq  0
    align     8
msys.fmtstr:
    dq  0
    segment .bss
    alignb    8
msys.outchan_stack:
    resb      80
    alignb    8
msys.outdev_stack:
    resb      80
    alignb    8
msys.fmtstr_stack:
    resb      80
msys.needgap_stack:
    resb      10
    alignb    8
msys.ptr_stack:
    resb      80
    segment .data
    align     8
msys.niostack:
    dq  0
msys.digits:
    dq  0x3736353433323130
    dq  0x4645444342413938
    db        0
;ENDDATA
    align     8
msys.defaultfmt:
    db        0
    db        0
    db        10
    db        0
    db        32
    db        102
    db        0
    db        0
    db        0
    db        82
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    segment .bss
    alignb    8
msys.rd_buffer:
    resb      8
    alignb    8
msys.rd_length:
    resb      8
    alignb    8
msys.rd_pos:
    resb      8
    alignb    8
msys.rd_lastpos:
    resb      8
    alignb    8
msys.termchar:
    resb      8
    alignb    8
msys.itemerror:
    resb      8
msys.printbuffer:
    resb      4096
    alignb    8
msys.printptr:
    resb      8
    alignb    8
msys.printlen:
    resb      8
    alignb    8
msys.nsysparams:
    resb      8
    alignb    8
msys.ncmdparams:
    resb      8
    alignb    8
msys.nenvstrings:
    resb      8
    alignb    8
msys.sysparams:
    resb      1024
    alignb    8
msys.cmdparams:
    resb      8
    alignb    8
msys.envstrings:
    resb      8
msys.start.startupinfo:
    resb      128
    alignb    8
msys.getfmt.fmt:
    resb      16
msys.strint.str:
    resb      100
msys.strword.str:
    resb      100
msys.strreal.str:
    resb      320
    alignb    8
mlib.allocupper:
    resb      2408
    alignb    8
mlib.alloccode:
    resb      8
    alignb    8
mlib.allocbytes:
    resb      8
    segment .data
    align     8
mlib.fdebug:
    dq  0
    segment .bss
    alignb    8
mlib.rfsize:
    resb      8
    alignb    8
mlib.maxmemory:
    resb      8
    alignb    8
mlib.maxalloccode:
    resb      8
    segment .data
mlib.pcm_setup:
    db        0
    align     8
mlib.show:
    dq  0
    align     8
mlib.memtotal:
    dq  0
    align     8
mlib.smallmemtotal:
    dq  0
    align     8
mlib.smallmemobjs:
    dq  0
    align     8
mlib.maxmemtotal:
    dq  0
    segment .bss
    alignb    8
mlib.memalloctable:
    resb      24
    alignb    4
mlib.memallocsize:
    resb      12
    alignb    8
mlib.pcheapstart:
    resb      8
    alignb    8
mlib.pcheapend:
    resb      8
    alignb    8
mlib.pcheapptr:
    resb      8
mlib.sizeindextable:
    resb      2049
    alignb    8
mlib.freelist:
    resb      72
    segment .data
    align     8
mlib.pmnames:
    dq  L10674
    dq  L10675
    dq  L10676
    dq  L10677
    dq  L10678
    dq  L10679
    align     8
mlib.seed:
    dq  0x2989881111111272
    dq  0x1673267373358264
    segment .bss
    alignb    8
mlib.pcm_newblock.totalheapsize:
    resb      8
    segment .data
    align     4
mlib.pcm_round.allocbytes:
    dd        0
    dd        16
    dd        32
    dd        64
    dd        128
    dd        256
    dd        512
    dd        1024
    dd        2048
    segment .bss
mlib.changeext.newfile:
    resb      260
mlib.extractpath.str:
    resb      260
mlib.extractbasefile.str:
    resb      100
    segment .data
    align     8
mlib.nextcmdparamnew.infile:
    dq  0
    align     8
mlib.nextcmdparamnew.filestart:
    dq  0
    align     8
mlib.nextcmdparamnew.fileptr:
    dq  0
mlib.nextcmdparamnew.colonseen:
    db        0
    segment .bss
mlib.nextcmdparamnew.str:
    resb      300
mlib.readnextfileitem.str:
    resb      256
mlib.padstr.str:
    resb      256
mlib.chr.str:
    resb      8
    alignb    8
mwindows.hconsole:
    resb      8
    alignb    8
mwindows.hconsolein:
    resb      8
    alignb    4
mwindows.lastkey:
    resb      20
    alignb    4
mwindows.pendkey:
    resb      20
    alignb    8
mwindows.keypending:
    resb      8
    alignb    8
mwindows.hpfreq:
    resb      8
    segment .data
    align     8
mwindows.wndproc_callbackfn:
    dq  0
    align     8
mwindows.init_flag:
    dq  0
    segment .bss
mwindows.os_gxregisterclass.registered:
    resb      1
    segment .data
    align     8
mwindows.mainwndproc.count:
    dq  0
    segment .bss
mwindows.os_gethostname.name:
    resb      300
    alignb    8
mwindows.os_gethostname.n:
    resb      8
    alignb    8
mwindows.os_peek.lastticks:
    resb      8
    segment .data
pcl.pc_userunpcl:
    db        0
    segment .bss
    alignb    8
pc_api.pclseqno:
    resb      8
    alignb    8
pc_api.stseqno:
    resb      8
    alignb    8
pc_api.pcstart:
    resb      8
    alignb    8
pc_api.pccurr:
    resb      8
    alignb    8
pc_api.pcend:
    resb      8
    alignb    8
pc_api.pcalloc:
    resb      8
pc_api.pcfixed:
    resb      1
    alignb    8
pc_api.pcseqno:
    resb      8
    alignb    8
pc_api.pcneedfntable:
    resb      8
    segment .data
    align     8
pc_api.initpcalloc:
    dq  0x10000
    segment .bss
    alignb    8
pc_api.longstring:
    resb      8
    alignb    8
pc_api.longstringlen:
    resb      8
    alignb    8
pc_api.mlabelno:
    resb      8
pc_api.phighmem:
    resb      1
pc_api.pfullsys:
    resb      1
pc_api.fpshortnames:
    resb      1
    alignb    8
pc_api.idomcl_assem:
    resb      8
    alignb    8
pc_api.icheckasmlabel:
    resb      8
    alignb    8
pc_api.igethostfn:
    resb      8
pc_api.strpmode.str:
    resb      32
pc_api.getfullname.str:
    resb      256
pc_api.addstr.str:
    resb      256
    alignb    8
pc_decls.pinfo:
    resb      8
    alignb    8
pc_decls.bspill:
    resb      8
    alignb    8
pc_decls.bxspill:
    resb      8
pc_decls.r10used:
    resb      1
pc_decls.r11used:
    resb      1
pc_decls.localshadow:
    resb      1
    alignb    8
pc_decls.mmpos:
    resb      8
    alignb    8
pc_decls.psymboltable:
    resb      8
    alignb    8
pc_decls.psymboltablex:
    resb      8
    alignb    8
pc_decls.currprog:
    resb      8
    alignb    8
pc_decls.currfunc:
    resb      8
    alignb    8
pc_decls.blockretname:
    resb      8
    alignb    8
pc_decls.entryproc:
    resb      8
    alignb    8
pc_decls.sbuffer:
    resb      16
    segment .data
    align     8
pc_decls.pdest:
    dq  pc_decls.sbuffer
    segment .bss
    alignb    8
pc_decls.plibfiles:
    resb      400
    alignb    8
pc_decls.plibinst:
    resb      400
    alignb    8
pc_decls.nplibfiles:
    resb      8
    alignb    8
pc_decls.igetmsourceinfo:
    resb      8
pc_decls.pcldone:
    resb      1
pc_decls.mcldone:
    resb      1
pc_decls.ssdone:
    resb      1
pc_decls.objdone:
    resb      1
pc_decls.exedone:
    resb      1
pc_decls.pverbose:
    resb      1
    alignb    8
pc_decls.pcmdskip:
    resb      8
    segment .data
    align     8
pc_decls.assemtype:
    dq  0x4141
    segment .bss
    alignb    8
pc_decls.ppseqno:
    resb      8
    segment .data
pc_decls.fpeephole:
    db        1
pc_decls.fregoptim:
    db        1
    segment .bss
    alignb    8
pc_decls.mcltime:
    resb      8
    alignb    8
pc_decls.sstime:
    resb      8
    alignb    8
pc_decls.objtime:
    resb      8
    alignb    8
pc_decls.exetime:
    resb      8
    alignb    8
pc_decls.$pmodulename:
    resb      8
    alignb    8
pc_decls.pclflags:
    resb      1144
    alignb    8
pc_decls.pstartclock:
    resb      8
    alignb    8
pc_diags.sbuffer:
    resb      16
    segment .data
    align     8
pc_diags.dest:
    dq  pc_diags.sbuffer
    segment .bss
    alignb    8
pc_diags.destlinestart:
    resb      8
pc_diags.stropnd.str:
    resb      512
    alignb    8
pc_diags.stropnd.longstring:
    resb      8
    segment .data
    align     8
pc_run.dotrace:
    dq  0
    align     8
pc_run.dostep:
    dq  1
    segment .bss
    alignb    8
pc_run.go:
    resb      8
    alignb    8
pc_run.seqno:
    resb      8
    alignb    8
pc_run.emptyst:
    resb      128
    alignb    8
pc_run.labeltable:
    resb      8
    segment .data
    align     8
pc_tables.pstdnames:
    dq  L10680
    dq  L10681
    dq  L10682
    dq  L10683
    dq  L10684
    dq  L10685
    dq  L10686
    dq  L10687
    dq  L10688
    dq  L10689
    dq  L10690
    dq  L10691
    dq  L10692
    dq  L10693
pc_tables.psize:
    dq  0x108040201080400
    db        2
    db        4
    db        8
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.psigned:
    dq  0x100000000000000
    db        1
    db        1
    db        1
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pint:
    dq  0x101010101000000
    db        1
    db        1
    db        1
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pfloat:
    dq  0x10100
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pmin:
    dq  0x906050505020100
    db        9
    db        9
    db        10
    db        11
    db        12
    db        0
;ENDDATA
pc_tables.piwrb:
    dq  0xA06060606020100
    db        10
    db        10
    db        10
    db        0
    db        0
    db        0
;ENDDATA
    align     8
pc_tables.opndnames:
    dq  L10694
    dq  L10695
    dq  L10696
    dq  L10697
    dq  L10698
    dq  L10699
    dq  L10700
    dq  L10701
    dq  L10702
    dq  L10703
    dq  L10704
    dq  L10705
    dq  L10706
    dq  L10707
    align     8
pc_tables.pclnames:
    dq  L10708
    dq  L10709
    dq  L10710
    dq  L10711
    dq  L10712
    dq  L10713
    dq  L10714
    dq  L10715
    dq  L10716
    dq  L10717
    dq  L10718
    dq  L10719
    dq  L10720
    dq  L10721
    dq  L10722
    dq  L10723
    dq  L10724
    dq  L10725
    dq  L10726
    dq  L10727
    dq  L10728
    dq  L10729
    dq  L10730
    dq  L10731
    dq  L10732
    dq  L10733
    dq  L10734
    dq  L10735
    dq  L10736
    dq  L10737
    dq  L10738
    dq  L10739
    dq  L10740
    dq  L10741
    dq  L10742
    dq  L10743
    dq  L10744
    dq  L10745
    dq  L10746
    dq  L10747
    dq  L10748
    dq  L10749
    dq  L10750
    dq  L10751
    dq  L10752
    dq  L10753
    dq  L10754
    dq  L10755
    dq  L10756
    dq  L10757
    dq  L10758
    dq  L10759
    dq  L10760
    dq  L10761
    dq  L10762
    dq  L10763
    dq  L10764
    dq  L10765
    dq  L10766
    dq  L10767
    dq  L10768
    dq  L10769
    dq  L10770
    dq  L10771
    dq  L10772
    dq  L10773
    dq  L10774
    dq  L10775
    dq  L10776
    dq  L10777
    dq  L10778
    dq  L10779
    dq  L10780
    dq  L10781
    dq  L10782
    dq  L10783
    dq  L10784
    dq  L10785
    dq  L10786
    dq  L10787
    dq  L10788
    dq  L10789
    dq  L10790
    dq  L10791
    dq  L10792
    dq  L10793
    dq  L10794
    dq  L10795
    dq  L10796
    dq  L10797
    dq  L10798
    dq  L10799
    dq  L10800
    dq  L10801
    dq  L10802
    dq  L10803
    dq  L10804
    dq  L10805
    dq  L10806
    dq  L10807
    dq  L10808
    dq  L10809
    dq  L10810
    dq  L10811
    dq  L10812
    dq  L10813
    dq  L10814
    dq  L10815
    dq  L10816
    dq  L10817
    dq  L10818
    dq  L10819
    dq  L10820
    dq  L10821
    dq  L10822
    dq  L10823
    dq  L10824
    dq  L10825
    dq  L10826
    dq  L10827
    dq  L10828
    dq  L10829
    dq  L10830
    dq  L10831
    dq  L10832
    dq  L10833
    dq  L10834
    dq  L10835
    dq  L10836
    dq  L10837
    dq  L10838
    dq  L10839
    dq  L10840
    dq  L10841
    dq  L10842
    dq  L10843
    dq  L10844
    dq  L10845
    dq  L10846
    dq  L10847
    dq  L10848
    dq  L10849
    dq  L10850
pc_tables.pclhastype:
    dq  0x101010101010100
    dq  0x101010101000000
    dq  0x101010000000101
    dq  0x101010101010100
    dq  0x10101010100
    dq  0x101010101000100
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x101010101010202
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x202010101010101
    dq  0x101000202020202
    dq  0x10101000000
    dq  0
    db        0
    db        1
    db        1
    db        1
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pclextra:
    dq  0x2000002000100
    dq  0x20000
    dq  0x2020002020000
    dq  0x10000
    dq  0x2020001010000
    dq  0
    dq  0
    dq  0x1020200
    dq  0
    dq  0
    dq  0x101010100000000
    dq  0x101
    dq  0x100000000000000
    dq  1
    dq  0
    dq  0
    dq  0x201000000
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pclhasopnd:
    dq  0x100000D00
    dq  0xD00000000
    dq  0x20000020000
    dq  0x3030303030003
    dq  0x303030003030300
    dq  0xD0000
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0x3000D0101000101
    dq  2
    db        0
    db        1
    db        1
    db        0
    db        0
    db        7
    db        1
;ENDDATA
pc_tables.pclargs:
    dq  0
    dq  0x202000000000000
    dq  0x9090009090202
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0x101010100000000
    dq  0x101010101010101
    dq  0x2020201
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
    align     8
pc_tables.ccnames:
    dq  L10851
    dq  L10852
    dq  L10853
    dq  L10854
    dq  L10855
    dq  L10856
    dq  L10857
    align     8
pc_tables.idnames:
    dq  L10858
    dq  L10859
    dq  L10860
    dq  L10861
    dq  L10862
    dq  L10863
    dq  L10864
    dq  L10865
    dq  L10866
    dq  L10867
    segment .bss
    alignb    8
mc_genmcl.debug:
    resb      8
    alignb    8
mc_genmcl.frameoffset:
    resb      8
    alignb    8
mc_genmcl.paramoffset:
    resb      8
    alignb    8
mc_genmcl.framebytes:
    resb      8
    alignb    8
mc_genmcl.px_handlertable:
    resb      1144
    segment .data
mc_genmcl.scondcodes:
    db        4
    db        5
    db        12
    db        14
    db        13
    db        15
;ENDDATA
mc_genmcl.ucondcodes:
    db        4
    db        5
    db        2
    db        6
    db        3
    db        7
;ENDDATA
mc_genmcl.inithandlers.initdone:
    db        0
mc_genmcl.inithandlers.dupltable:
    db        "A@"
;ENDDATA
    db        21
    db        18
;ENDDATA
    db        19
    db        18
;ENDDATA
    db        22
    db        18
;ENDDATA
    db        "wv"
;ENDDATA
    db        "yx"
;ENDDATA
    db        "^/"
;ENDDATA
    db        "_0"
;ENDDATA
    segment .bss
    alignb    8
mc_auxmcl.nnn:
    resb      8
    alignb    8
mc_auxmcl.nauxprocs:
    resb      8
    alignb    8
mc_auxmcl.nauxnoframe:
    resb      8
    alignb    8
mc_auxmcl.mclframesetup:
    resb      8
    alignb    8
mc_libmcl.mclseqno:
    resb      8
    alignb    8
mc_libmcl.nmclopnd:
    resb      8
    alignb    8
mc_libmcl.smallinttable:
    resb      96
    alignb    8
mc_libmcl.nametable:
    resb      160
    alignb    8
mc_libmcl.nnametable:
    resb      8
    alignb    8
mc_libmcl.mgenextname.table:
    resb      160
    alignb    8
mc_libmcl.mgenextname.ntable:
    resb      8
mc_stackmcl.stropndstack.str:
    resb      512
mc_genss.rex:
    resb      1
mc_genss.sizeoverride:
    resb      1
mc_genss.addroverride:
    resb      1
mc_genss.f2override:
    resb      1
mc_genss.f3override:
    resb      1
mc_genss.nowmask:
    resb      1
mc_genss.usesizeb:
    resb      1
    alignb    8
mc_genss.extraparam:
    resb      8
    segment .data
    align     8
mc_genss.currseg:
    dq  0
    segment .bss
    alignb    8
mc_genss.currdata:
    resb      8
    alignb    8
mc_genss.currrelocs:
    resb      8
    alignb    8
mc_genss.nrelocs:
    resb      8
mc_genss.ishighreg:
    resb      16
    alignb    8
mc_genss.currmcl:
    resb      8
    alignb    8
mc_genss.ripentry:
    resb      8
    segment .data
    align     8
mc_genss.genrm.scaletable:
    dq  0
    dq  1
    dq  0
    dq  2
    dq  0
    dq  0
    dq  0
    dq  3
    align     8
mc_decls.valtypenames:
    dq  L10868
    dq  L10869
    dq  L10870
    dq  L10871
    dq  L10872
    dq  L10873
    dq  L10874
    dq  L10875
    dq  L10876
    align     8
mc_decls.mclnames:
    dq  L10877
    dq  L10878
    dq  L10879
    dq  L10880
    dq  L10881
    dq  L10882
    dq  L10883
    dq  L10884
    dq  L10885
    dq  L10886
    dq  L10887
    dq  L10888
    dq  L10889
    dq  L10890
    dq  L10891
    dq  L10892
    dq  L10893
    dq  L10894
    dq  L10895
    dq  L10896
    dq  L10897
    dq  L10898
    dq  L10899
    dq  L10900
    dq  L10901
    dq  L10902
    dq  L10903
    dq  L10904
    dq  L10905
    dq  L10906
    dq  L10907
    dq  L10908
    dq  L10909
    dq  L10910
    dq  L10911
    dq  L10912
    dq  L10913
    dq  L10914
    dq  L10915
    dq  L10916
    dq  L10917
    dq  L10918
    dq  L10919
    dq  L10920
    dq  L10921
    dq  L10922
    dq  L10923
    dq  L10924
    dq  L10925
    dq  L10926
    dq  L10927
    dq  L10928
    dq  L10929
    dq  L10930
    dq  L10931
    dq  L10932
    dq  L10933
    dq  L10934
    dq  L10935
    dq  L10936
    dq  L10937
    dq  L10938
    dq  L10939
    dq  L10940
    dq  L10941
    dq  L10942
    dq  L10943
    dq  L10944
    dq  L10945
    dq  L10946
    dq  L10947
    dq  L10948
    dq  L10949
    dq  L10950
    dq  L10951
    dq  L10952
    dq  L10953
    dq  L10954
    dq  L10955
    dq  L10956
    dq  L10957
    dq  L10958
    dq  L10959
    dq  L10960
    dq  L10961
    dq  L10962
    dq  L10963
    dq  L10964
    dq  L10965
    dq  L10966
    dq  L10967
    dq  L10968
    dq  L10969
    dq  L10970
    dq  L10971
    dq  L10972
    dq  L10973
    dq  L10974
    dq  L10975
    dq  L10976
    dq  L10977
    dq  L10978
    dq  L10979
    dq  L10980
    dq  L10981
    dq  L10982
    dq  L10983
    dq  L10984
    dq  L10985
    dq  L10986
    dq  L10987
    dq  L10988
    dq  L10989
    dq  L10990
    dq  L10991
    dq  L10992
    dq  L10993
    dq  L10994
    dq  L10995
    dq  L10996
    dq  L10997
    dq  L10998
    dq  L10999
    dq  L11000
    dq  L11001
    dq  L11002
    dq  L11003
    dq  L11004
    dq  L11005
    dq  L11006
    dq  L11007
    dq  L11008
    dq  L11009
    dq  L11010
    dq  L11011
    dq  L11012
    dq  L11013
    dq  L11014
    dq  L11015
    dq  L11016
    dq  L11017
    dq  L11018
    dq  L11019
    dq  L11020
    dq  L11021
    dq  L11022
    dq  L11023
    dq  L11024
    dq  L11025
    dq  L11026
    dq  L11027
mc_decls.mclnopnds:
    dq  0
    dq  0x202020101020001
    dq  0x100000102020202
    dq  0x102020202020101
    dq  0x202020101030201
    dq  0x202020202020202
    dq  0x101010102
    dq  0x202020202020100
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x101010303020202
    dq  0x10101
    dq  0x200000000000000
    dq  0x1010101020202
    dq  0x1010101010000
    dq  0x101010101
    dq  0x1020000
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
mc_decls.mclcodes:
    dq  0
    dq  0x9000
    dq  0xC9C3E800000000
    dq  0x5030205000000E9
    dq  0x601040607000004
    dq  0x201000507040700
    dq  0x100020303
    dq  0x5151ACA4BDBC0000
    dq  0x5E5E59595C5C5858
    dq  0xEF545457572E2F00
    dq  0xDB
    dq  0x302006263F36600
    dq  0xFAF9C9E9C1030200
    dq  0x5DE0E1F3F2FBFFFE
    dq  0x5F5D5F
    dq  0xD708040201000000
    dq  0xE3E3E2E1E0
    dq  0xEBE8EE0000003100
    db        233
    db        234
    db        236
    db        237
    db        0
    db        244
    db        244
;ENDDATA
    align     8
mc_decls.regnames:
    dq  L11028
    dq  L11029
    dq  L11030
    dq  L11031
    dq  L11032
    dq  L11033
    dq  L11034
    dq  L11035
    dq  L11036
    dq  L11037
    dq  L11038
    dq  L11039
    dq  L11040
    dq  L11041
    dq  L11042
    dq  L11043
    dq  L11044
    dq  L11045
    dq  L11046
    dq  L11047
    dq  L11048
mc_decls.regcodes:
    dq  0xC0603070B0A0000
    dq  0x5090802010F0E0D
    db        4
    db        4
    db        7
    db        5
    db        6
;ENDDATA
    align     8
mc_decls.condnames:
    dq  L11049
    dq  L11050
    dq  L11051
    dq  L11052
    dq  L11053
    dq  L11054
    dq  L11055
    dq  L11056
    dq  L11057
    dq  L11058
    dq  L11059
    dq  L11060
    dq  L11061
    dq  L11062
    dq  L11063
    dq  L11064
    dq  L11065
    dq  L11066
    dq  L11067
    dq  L11068
    align     8
mc_decls.asmcondnames:
    dq  L11069
    dq  L11070
    dq  L11071
    dq  L11072
    dq  L11073
    dq  L11074
    dq  L11075
    dq  L11076
    dq  L11077
    dq  L11078
    dq  L11079
    dq  L11080
    dq  L11081
    dq  L11082
    dq  L11083
    dq  L11084
    dq  L11085
    dq  L11086
    dq  L11087
    dq  L11088
    align     8
mc_decls.asmrevcond:
    dq  1
    dq  0
    dq  3
    dq  2
    dq  5
    dq  4
    dq  7
    dq  6
    dq  9
    dq  8
    dq  0xB
    dq  0xA
    dq  0xD
    dq  0xC
    dq  0xF
    dq  0xE
    dq  0x11
    dq  0x10
    dq  0x13
    dq  0x12
    align     8
mc_decls.dregnames:
    dq  L11089
    dq  L11090
    dq  L11091
    dq  L11092
    dq  L11093
    dq  L11094
    dq  L11095
    dq  L11096
    dq  L11097
    dq  L11098
    dq  L11099
    dq  L11100
    dq  L11101
    dq  L11102
    dq  L11103
    dq  L11104
    dq  L11105
    dq  L11106
    dq  L11107
    dq  L11108
    dq  L11109
    dq  L11110
    dq  L11111
    dq  L11112
    dq  L11113
    dq  L11114
    dq  L11115
    dq  L11116
    dq  L11117
    dq  L11118
    dq  L11119
    dq  L11120
    dq  L11121
    dq  L11122
    dq  L11123
    dq  L11124
    dq  L11125
    dq  L11126
    dq  L11127
    dq  L11128
    dq  L11129
    dq  L11130
    dq  L11131
    dq  L11132
    dq  L11133
    dq  L11134
    dq  L11135
    dq  L11136
    dq  L11137
    dq  L11138
    dq  L11139
    dq  L11140
    dq  L11141
    dq  L11142
    dq  L11143
    dq  L11144
    dq  L11145
    dq  L11146
    dq  L11147
    dq  L11148
    dq  L11149
    dq  L11150
    dq  L11151
    dq  L11152
    dq  L11153
    dq  L11154
    dq  L11155
    dq  L11156
    dq  L11157
    dq  L11158
    dq  L11159
    dq  L11160
    dq  L11161
    dq  L11162
    dq  L11163
    dq  L11164
    dq  L11165
    dq  L11166
    dq  L11167
    dq  L11168
    dq  L11169
    dq  L11170
    dq  L11171
    dq  L11172
    dq  L11173
    dq  L11174
    dq  L11175
    dq  L11176
    dq  L11177
    dq  L11178
    dq  L11179
    dq  L11180
    dq  L11181
    dq  L11182
    dq  L11183
    dq  L11184
    dq  L11185
    dq  L11186
    dq  L11187
    dq  L11188
    dq  L11189
    dq  L11190
    dq  L11191
    dq  L11192
    dq  L11193
    dq  L11194
    dq  L11195
    dq  L11196
    dq  L11197
    dq  L11198
    dq  L11199
    dq  L11200
    dq  L11201
    dq  L11202
    dq  L11203
    dq  L11204
    dq  L11205
    dq  L11206
    dq  L11207
    dq  L11208
    dq  L11209
    dq  L11210
    dq  L11211
    dq  L11212
    dq  L11213
    dq  L11214
    dq  L11215
    dq  L11216
    dq  L11217
    dq  L11218
    dq  L11219
    dq  L11220
    dq  L11221
    dq  L11222
    dq  L11223
    dq  L11224
    dq  L11225
mc_decls.regsizes:
    dq  0x808080808080808
    dq  0x808080808080808
    dq  0x404040404040404
    dq  0x404040404040404
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x808080001010101
    dq  0x808080808080808
    dq  0x404040808080808
    dq  0x404040404040404
    dq  0x202020404040404
    dq  0x202020202020202
    dq  0x101010202020202
    dq  0x101010101010101
    dq  0x101010101010101
    db        1
;ENDDATA
mc_decls.regindices:
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0xB05010014131211
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0xF0406141312110C
    dq  0x9080703020E0D10
    db        10
;ENDDATA
    align     8
mc_decls.xmmregnames:
    dq  L11226
    dq  L11227
    dq  L11228
    dq  L11229
    dq  L11230
    dq  L11231
    dq  L11232
    dq  L11233
    dq  L11234
    dq  L11235
    dq  L11236
    dq  L11237
    dq  L11238
    dq  L11239
    dq  L11240
    dq  L11241
    align     8
mc_decls.fregnames:
    dq  L11242
    dq  L11243
    dq  L11244
    dq  L11245
    dq  L11246
    dq  L11247
    dq  L11248
    dq  L11249
    align     8
mc_decls.mregnames:
    dq  L11250
    dq  L11251
    dq  L11252
    dq  L11253
    dq  L11254
    dq  L11255
    dq  L11256
    dq  L11257
    align     8
mc_decls.jmpccnames:
    dq  L11258
    dq  L11259
    dq  L11260
    dq  L11261
    dq  L11262
    dq  L11263
    dq  L11264
    dq  L11265
    dq  L11266
    dq  L11267
    dq  L11268
    dq  L11269
    dq  L11270
    dq  L11271
    dq  L11272
    dq  L11273
    dq  L11274
    dq  L11275
mc_decls.jmpcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
    db        2
    db        3
;ENDDATA
    align     8
mc_decls.setccnames:
    dq  L11276
    dq  L11277
    dq  L11278
    dq  L11279
    dq  L11280
    dq  L11281
    dq  L11282
    dq  L11283
    dq  L11284
    dq  L11285
    dq  L11286
    dq  L11287
    dq  L11288
    dq  L11289
    dq  L11290
    dq  L11291
mc_decls.setcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
;ENDDATA
    align     8
mc_decls.cmovccnames:
    dq  L11292
    dq  L11293
    dq  L11294
    dq  L11295
    dq  L11296
    dq  L11297
    dq  L11298
    dq  L11299
    dq  L11300
    dq  L11301
    dq  L11302
    dq  L11303
    dq  L11304
    dq  L11305
    dq  L11306
    dq  L11307
mc_decls.cmovcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
;ENDDATA
    align     8
mc_decls.segmentnames:
    dq  L11308
    dq  L11309
    dq  L11310
    dq  L11311
    dq  L11312
    dq  L11313
    align     8
mc_decls.reftypenames:
    dq  L11314
    dq  L11315
    dq  L11316
    align     8
mc_decls.opndnames_ma:
    dq  L11317
    dq  L11318
    dq  L11319
    dq  L11320
    dq  L11321
    dq  L11322
    segment .bss
    alignb    8
mc_decls.pclopnd:
    resb      160
mc_decls.pclreg:
    resb      20
mc_decls.pclmode:
    resb      20
mc_decls.pclcount:
    resb      20
mc_decls.pclloc:
    resb      20
mc_decls.pcltempflags:
    resb      20
    alignb    8
mc_decls.pcltempopnds:
    resb      160
    alignb    8
mc_decls.noperands:
    resb      8
    alignb    8
mc_decls.mstackdepth:
    resb      8
    segment .data
    align     8
mc_decls.locnames:
    dq  L11323
    dq  L11324
    dq  L11325
    dq  L11326
    segment .bss
mc_decls.workregs:
    resb      16
mc_decls.workxregs:
    resb      16
    alignb    8
mc_decls.nworkregs:
    resb      8
    alignb    8
mc_decls.nworkxregs:
    resb      8
    alignb    8
mc_decls.nregvars:
    resb      8
    alignb    8
mc_decls.nxregvars:
    resb      8
    alignb    8
mc_decls.maxregvars:
    resb      8
    alignb    8
mc_decls.maxxregvars:
    resb      8
    alignb    8
mc_decls.xregmax:
    resb      8
mc_decls.regset:
    resb      16
mc_decls.xregset:
    resb      16
mc_decls.isregvar:
    resb      16
mc_decls.isxregvar:
    resb      16
mc_decls.usedregs:
    resb      16
mc_decls.usedxregs:
    resb      16
mc_decls.noxorclear:
    resb      1
    segment .data
    align     8
mc_decls.xregnames:
    dq  L11327
    dq  L11328
    dq  L11329
    dq  L11330
    dq  L11331
    dq  L11332
    dq  L11333
    dq  L11334
    dq  L11335
    dq  L11336
    dq  L11337
    dq  L11338
    dq  L11339
    dq  L11340
    dq  L11341
    dq  L11342
    dq  L11342
    segment .bss
mc_decls.callalign:
    resb      32
mc_decls.callblockret:
    resb      32
    alignb    4
mc_decls.callblocksize:
    resb      128
    alignb    4
mc_decls.callargsize:
    resb      512
    alignb    8
mc_decls.ncalldepth:
    resb      8
    alignb    8
mc_decls.lababs32:
    resb      8
    alignb    8
mc_decls.lababs64:
    resb      8
    alignb    8
mc_decls.labneg32:
    resb      8
    alignb    8
mc_decls.labneg64:
    resb      8
    alignb    8
mc_decls.labmask63:
    resb      8
    alignb    8
mc_decls.laboffset64:
    resb      8
    alignb    8
mc_decls.labzero:
    resb      8
    segment .data
    align     8
mc_decls.kk0used:
    dq  0
    segment .bss
    alignb    8
mc_decls.mccode:
    resb      8
    alignb    8
mc_decls.mccodex:
    resb      8
    segment .data
    align     8
mc_decls.currsegment:
    dq  0
    segment .bss
    alignb    8
mc_decls.dstackopnd:
    resb      8
    alignb    8
mc_decls.dframeopnd:
    resb      8
    alignb    8
mc_decls.regtable:
    resb      1024
    alignb    8
mc_decls.frameregtable:
    resb      1544
    alignb    8
mc_decls.cstringlist:
    resb      8
    alignb    8
mc_decls.vstringlist:
    resb      8
    alignb    8
mc_decls.creallist:
    resb      8
    alignb    8
mc_decls.cr32list:
    resb      8
    alignb    8
mc_decls.currasmproc:
    resb      8
    alignb    8
mc_decls.lab_funcnametable:
    resb      8
    alignb    8
mc_decls.lab_funcaddrtable:
    resb      8
    alignb    8
mc_decls.lab_funcnprocs:
    resb      8
    alignb    8
mc_decls.ss_zdatalen:
    resb      8
    alignb    8
mc_decls.ss_zdata:
    resb      8
    alignb    8
mc_decls.ss_idata:
    resb      8
    alignb    8
mc_decls.ss_code:
    resb      8
    alignb    8
mc_decls.ss_idatarelocs:
    resb      8
    alignb    8
mc_decls.ss_coderelocs:
    resb      8
    alignb    8
mc_decls.ss_nidatarelocs:
    resb      8
    alignb    8
mc_decls.ss_ncoderelocs:
    resb      8
    alignb    8
mc_decls.ss_symboltable:
    resb      8
    alignb    8
mc_decls.ss_nsymbols:
    resb      8
    alignb    8
mc_decls.ss_symboltablesize:
    resb      8
    alignb    8
mc_decls.labeldeftable:
    resb      8
    alignb    8
mc_decls.aaseqno:
    resb      8
    segment .data
mc_decls.regmodes:
    dq  0x600000005000403
;ENDDATA
    segment .bss
mc_decls.pmode:
    resb      1
    alignb    8
mc_decls.currpcl:
    resb      8
    alignb    8
mc_decls.mclprocentry:
    resb      8
    alignb    8
mc_decls.mce_oldmccodex:
    resb      8
    alignb    8
mc_decls.mce_lastmcl:
    resb      8
    alignb    8
mc_decls.mce_nextmcl:
    resb      8
    alignb    8
mc_decls.mcf_oldmccodex:
    resb      8
    alignb    8
mc_decls.mcf_lastmcl:
    resb      8
    alignb    8
mc_decls.mcf_nextmcl:
    resb      8
mc_decls.fpcheckunusedlocals:
    resb      1
    alignb    8
mc_decls.riplist:
    resb      8
    alignb    8
mc_decls.blockdefs:
    resb      400
    alignb    8
mc_decls.nblocktemps:
    resb      8
    segment .data
    align     8
mc_decls.multregs:
    dq  1
    dq  2
    dq  3
    dq  0xB
    dq  0xC
    dq  0xD
    align     8
mc_decls.multxregs:
    dq  1
    dq  2
    dq  3
    dq  4
    dq  5
    dq  6
    segment .bss
mc_decls.ploadopx:
    resb      14
mc_decls.ploadop:
    resb      14
    segment .data
    align     8
mc_objdecls.relocnames:
    dq  L11343
    dq  L11344
    dq  L11345
    dq  L11346
    dq  L11347
    dq  L11348
    dq  L11349
    segment .bss
    alignb    8
mc_writenasm.nregnames:
    resb      1024
mc_writenasm.currseg:
    resb      1
mc_writenasm.strmcl.str:
    resb      512
mc_writenasm.mstropnd.str:
    resb      512
mc_writenasm.strvalue.str:
    resb      512
mc_writenasm.getxregname.str:
    resb      32
mc_writenasm.getdispname.str:
    resb      256
mc_writenasm.gettempname.str:
    resb      128
    alignb    8
mc_writeexe.libinsttable:
    resb      400
    alignb    8
mc_writeexe.libinstnames:
    resb      400
    alignb    8
mc_writeexe.libnotable:
    resb      400
    alignb    8
mc_writeexe.basereloclist:
    resb      8
    alignb    8
mc_writeexe.nbaserelocs:
    resb      8
    alignb    8
mc_writeexe.maxrelocaddr:
    resb      8
    alignb    8
mc_writeexe.blockbases:
    resb      4000
    alignb    4
mc_writeexe.blockcounts:
    resb      2000
    alignb    4
mc_writeexe.blockbytes:
    resb      2000
mc_writeexe.blockpadding:
    resb      500
    alignb    8
mc_writeexe.nbaseblocks:
    resb      8
    alignb    8
mc_writeexe.basetablesize:
    resb      8
    alignb    8
mc_writeexe.imagebase:
    resb      8
    alignb    8
mc_writeexe.imagesize:
    resb      8
    alignb    8
mc_writeexe.filesize:
    resb      8
    alignb    8
mc_writeexe.thunktable:
    resb      8
    alignb    8
mc_writeexe.fileiatoffset:
    resb      8
    alignb    8
mc_writeexe.fileiatsize:
    resb      8
    alignb    8
mc_writeexe.stentrypoint:
    resb      8
    alignb    8
mc_writeexe.stentrypoint2:
    resb      8
    alignb    8
mc_writeexe.stentrypoint3:
    resb      8
    alignb    8
mc_writeexe.sectiontable:
    resb      720
    alignb    8
mc_writeexe.nsections:
    resb      8
    alignb    8
mc_writeexe.importdir:
    resb      8
    alignb    8
mc_writeexe.importtable:
    resb      144048
    alignb    8
mc_writeexe.nimports:
    resb      8
    alignb    8
mc_writeexe.exporttable:
    resb      16000
    alignb    8
mc_writeexe.nexports:
    resb      8
    alignb    8
mc_writeexe.dllfilename:
    resb      8
    alignb    8
mc_writeexe.isdll:
    resb      8
    alignb    8
mc_writeexe.dlltable:
    resb      2400
    alignb    8
mc_writeexe.ndlls:
    resb      8
    alignb    8
mc_writeexe.datastart:
    resb      8
    alignb    8
mc_writeexe.dataptr:
    resb      8
    alignb    8
mc_writeexe.userentrypoint:
    resb      8
    alignb    8
mc_writeexe.exportdirvirtaddr:
    resb      8
    alignb    8
mc_writeexe.exportdirvirtsize:
    resb      8
    alignb    8
mc_writeexe.exportdiroffset:
    resb      8
    alignb    8
mc_writeexe.blockdirvirtaddr:
    resb      8
    alignb    8
mc_writeexe.blockdirvirtsize:
    resb      8
    alignb    8
mc_writeexe.blockdiroffset:
    resb      8
    segment .data
mc_writeexe.writedosstub.stubdata:
    dq  0x300905A4D
    dq  0xFFFF00000004
    dq  0xB8
    dq  0x40
    dq  0
    dq  0
    dq  0
    dq  0x8000000000
    dq  0xCD09B4000EBA1F0E
    dq  0x685421CD4C01B821
    dq  0x72676F7270207369
    dq  0x6F6E6E6163206D61
    dq  0x6E75722065622074
    dq  0x20534F44206E6920
    dq  0xA0D0D2E65646F6D
    dq  0x24
;ENDDATA
    segment .bss
    alignb    8
mc_writeobj.symtaboffset:
    resb      8
    alignb    8
mc_writeobj.datastart:
    resb      8
    alignb    8
mc_writeobj.dataptr:
    resb      8
    alignb    2
mc_writeobj.symboltable:
    resb      234018
    alignb    8
mc_writeobj.nsymbols:
    resb      8
    segment .data
    align     8
mc_writeobj.stoffset:
    dq  0
    segment .bss
    alignb    8
mc_writeobj.stringtable:
    resb      40000
    alignb    8
mc_writeobj.stringlengths:
    resb      40000
    segment .data
    align     8
mc_writeobj.nextstringoffset:
    dq  0
    align     8
mc_writeobj.nstrings:
    dq  0
    segment .bss
    alignb    2
mc_writeobj.writerelocs.s:
    resb      10
    alignb    2
mc_writeobj.makesymbol.r:
    resb      18
    alignb    2
mc_writeobj.strtoaux.r:
    resb      18
    alignb    2
mc_writeobj.sectiontoaux.r:
    resb      18
    segment .data
    align     8
mx_decls.mcxdirnames:
    dq  L11350
    dq  L11351
    dq  L11352
    dq  L11353
    dq  L11354
    dq  L11355
    dq  L11356
    dq  L11357
    dq  L11358
    dq  L11359
    dq  L11360
    dq  L11361
    dq  L11362
    dq  L11363
    align     8
mx_decls.mcxrelocnames:
    dq  L11364
    dq  L11365
    dq  L11366
    dq  L11367
    dq  L11368
    dq  L11369
    segment .bss
    alignb    8
mx_decls.dllnametable:
    resb      160
    alignb    8
mx_decls.dllinsttable:
    resb      160
    alignb    8
mx_decls.ndlllibs:
    resb      8
    alignb    8
mx_decls.libnametable:
    resb      160
    alignb    8
mx_decls.libtable:
    resb      160
mx_decls.librelocated:
    resb      20
mx_decls.libinitdone:
    resb      20
    alignb    8
mx_decls.nlibs:
    resb      8
    alignb    8
mx_decls.symbolnametable:
    resb      24000
mx_decls.symboldefined:
    resb      3000
    alignb    8
mx_decls.symboladdress:
    resb      24000
    alignb    2
mx_decls.symbollibindex:
    resb      6000
mx_decls.symboldllindex:
    resb      3000
    alignb    8
mx_decls.nsymbols:
    resb      8
    segment .data
    align     8
mx_decls.nsymimports:
    dq  0
    align     8
mx_decls.nsymexports:
    dq  0
    align     8
mx_lib.rsegmentnames:
    dq  L11370
    dq  L11371
    dq  L11372
    dq  L11373
    dq  L11374
    dq  L11375
    segment .bss
    alignb    8
mx_write.dest:
    resb      8
    alignb    8
mx_write.entrypoint:
    resb      8
    segment .data
    align     8
mm_cli.syslibname:
    dq  L11376
    align     8
mm_cli.passnames:
    dq  L11377
    dq  L11378
    dq  L11379
    dq  L11380
    dq  L11381
    dq  L11382
    dq  L11383
    dq  L11384
    dq  L11385
    dq  L11386
    dq  L11387
    align     8
mm_cli.dpassnames:
    dq  L11388
    dq  L11389
    dq  L11390
    dq  L11391
    dq  L11392
    dq  L11393
    dq  L11394
    dq  L11395
    align     8
mm_cli.optionnames:
    dq  L11396
    dq  L11397
    dq  L11398
    dq  L11399
    dq  L11400
    dq  L11401
    dq  L11402
    dq  L11403
    dq  L11404
    dq  L11405
    dq  L11406
    dq  L11407
    dq  L11408
    dq  L11409
    dq  L11410
    dq  L11411
    dq  L11412
    dq  L11413
    dq  L11414
    dq  L11415
    dq  L11416
    dq  L11417
    dq  L11418
    dq  L11419
    dq  L11420
    dq  L11421
    dq  L11422
    dq  L11423
    dq  L11424
    dq  L11425
    dq  L11426
    dq  L11427
    dq  L11428
    dq  L11429
    dq  L11430
    dq  L11431
    dq  L11432
    dq  L11433
    dq  L11434
    dq  L11435
    dq  L11436
    dq  L11437
    dq  L11438
    dq  L11439
    dq  L11440
    dq  L11441
    dq  L11442
    dq  L11443
    dq  L11444
    dq  L11445
    dq  L11446
    dq  L11447
    dq  L11448
    dq  L11449
    dq  L11450
mm_cli.optionvalues:
    dq  0x706060504030201
    dq  0x302010B0A090808
    dq  0x1020807060504
    dq  0
    dq  0
    dq  0x2010003020000
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        2
;ENDDATA
    segment .bss
mm_cli.msfile:
    resb      1
    segment .data
    align     8
mm_cli.outext:
    dq  L11451
    segment .bss
    alignb    8
mm_cli.startclock:
    resb      8
    alignb    8
mm_cli.endclock:
    resb      8
    alignb    8
mm_cli.cmdskip:
    resb      8
    alignb    8
mm_cli.inputfile:
    resb      8
    alignb    8
mm_cli.loadtime:
    resb      8
    alignb    8
mm_cli.parsetime:
    resb      8
    alignb    8
mm_cli.resolvetime:
    resb      8
    alignb    8
mm_cli.typetime:
    resb      8
    alignb    8
mm_cli.ctime:
    resb      8
    alignb    8
mm_cli.pcltime:
    resb      8
    alignb    8
mm_cli.compiletime:
    resb      8
mm_cli.do_option.outused:
    resb      1
mm_cli.do_option.outpathused:
    resb      1
    alignb    8
mm_genpcl.retindex:
    resb      8
    alignb    8
mm_genpcl.initstaticsindex:
    resb      8
    alignb    8
mm_genpcl.pcldoswx:
    resb      8
    alignb    8
mm_genpcl.loopstack:
    resb      1600
    alignb    8
mm_genpcl.loopindex:
    resb      8
mm_genpcl.zero_unit:
    resb      65
    segment .data
    align     8
mm_genpcl.pzero:
    dq  mm_genpcl.zero_unit
    segment .bss
    alignb    8
mm_genpcl.nvarlocals:
    resb      8
    alignb    8
mm_genpcl.nvarparams:
    resb      8
    alignb    8
mm_blockpcl.nnn:
    resb      8
    alignb    8
mm_blockpcl.casestmt:
    resb      160
    alignb    8
mm_blockpcl.caseelse:
    resb      160
    alignb    8
mm_blockpcl.casedepth:
    resb      8
    alignb    8
mm_blockpcl.sw_labeltable:
    resb      8
    alignb    8
mm_blockpcl.sw_valuetable:
    resb      8
    alignb    8
mm_blockpcl.sw_lower:
    resb      8
    alignb    8
mm_blockpcl.sw_ncases:
    resb      8
mm_blockpcl.sw_defaultseen:
    resb      1
    alignb    8
mm_blockpcl.sw_defaultlabel:
    resb      8
    alignb    8
mm_blockpcl.sw_breaklabel:
    resb      8
    segment .data
    align     8
mm_blockpcl.maxreg:
    dq  0
    segment .bss
    alignb    8
mm_blockpcl.pnprocs:
    resb      8
    alignb    8
mm_blockpcl.pprocname:
    resb      8
    alignb    8
mm_blockpcl.pprocaddr:
    resb      8
    segment .data
    align     8
mm_assem.initassemsymbols.regnames:
    dq  L11452
    dq  L11453
    dq  L11454
    dq  L11455
    dq  L11456
    dq  L11457
mm_assem.initassemsymbols.regnos:
    db        15
    db        15
    db        16
    db        16
    db        9
    db        10
;ENDDATA
mm_assem.initassemsymbols.sizes:
    db        4
    db        8
    db        4
    db        8
    db        8
    db        8
;ENDDATA
    segment .bss
    alignb    8
mm_decls.modules:
    resb      2408
mm_decls.moduletosub:
    resb      301
    alignb    8
mm_decls.subprogs:
    resb      248
    alignb    8
mm_decls.sources:
    resb      2408
mm_decls.subproghasstart:
    resb      31
    alignb    8
mm_decls.nmodules:
    resb      8
    alignb    8
mm_decls.nsubprogs:
    resb      8
    alignb    8
mm_decls.nsourcefiles:
    resb      8
    alignb    8
mm_decls.nlibfiles:
    resb      8
    alignb    8
mm_decls.stprogram:
    resb      8
    alignb    8
mm_decls.stmodule:
    resb      8
    alignb    8
mm_decls.currmoduleno:
    resb      8
mm_decls.loadedfromma:
    resb      1
    alignb    8
mm_decls.lx:
    resb      16
    alignb    8
mm_decls.nextlx:
    resb      16
    alignb    8
mm_decls.libfiles:
    resb      408
    alignb    8
mm_decls.mainsubprogno:
    resb      8
    alignb    8
mm_decls.ntypes:
    resb      8
    alignb    8
mm_decls.ttnamedef:
    resb      128008
    alignb    8
mm_decls.ttowner:
    resb      128008
    alignb    4
mm_decls.ttbasetype:
    resb      64004
    alignb    8
mm_decls.ttname:
    resb      128008
    alignb    4
mm_decls.ttsize:
    resb      64004
mm_decls.ttsizeset:
    resb      16001
    alignb    4
mm_decls.ttlower:
    resb      64004
    alignb    4
mm_decls.ttlength:
    resb      64004
    alignb    8
mm_decls.ttmult:
    resb      128008
    alignb    8
mm_decls.ttdimexpr:
    resb      128008
    alignb    4
mm_decls.tttarget:
    resb      64004
mm_decls.ttusercat:
    resb      16001
    alignb    4
mm_decls.ttlineno:
    resb      64004
mm_decls.ttsigned:
    resb      16001
mm_decls.ttisreal:
    resb      16001
mm_decls.ttisinteger:
    resb      16001
mm_decls.ttisshort:
    resb      16001
mm_decls.ttisref:
    resb      16001
mm_decls.ttisblock:
    resb      16001
    alignb    8
mm_decls.typenames:
    resb      1216032
    alignb    4
mm_decls.typenamepos:
    resb      152004
    alignb    8
mm_decls.ntypenames:
    resb      8
mm_decls.typestarterset:
    resb      137
    alignb    8
mm_decls.currproc:
    resb      8
    segment .data
    align     8
mm_decls.assemmode:
    dq  0
    align     8
mm_decls.headermode:
    dq  0
    segment .bss
    alignb    8
mm_decls.proclist:
    resb      8
    alignb    8
mm_decls.proclistx:
    resb      8
    alignb    8
mm_decls.staticlist:
    resb      8
    alignb    8
mm_decls.staticlistx:
    resb      8
    alignb    8
mm_decls.constlist:
    resb      8
    alignb    8
mm_decls.constlistx:
    resb      8
    alignb    8
mm_decls.nullunit:
    resb      8
    alignb    8
mm_decls.ndllproctable:
    resb      8
    alignb    8
mm_decls.dllproctable:
    resb      8000
    segment .data
    align     8
mm_decls.fverbose:
    dq  1
mm_decls.msyslevel:
    db        2
mm_decls.mvarlib:
    db        0
mm_decls.fvarnames:
    db        0
    segment .bss
mm_decls.fshowtiming:
    resb      1
mm_decls.fshowss:
    resb      1
mm_decls.fshowc:
    resb      1
mm_decls.fshowpcl:
    resb      1
mm_decls.fshowasm:
    resb      1
mm_decls.fshowast1:
    resb      1
mm_decls.fshowast2:
    resb      1
mm_decls.fshowast3:
    resb      1
mm_decls.fshowst:
    resb      1
mm_decls.fshowpst:
    resb      1
mm_decls.fshowstflat:
    resb      1
mm_decls.fshowtypes:
    resb      1
mm_decls.fshowmodules:
    resb      1
    segment .data
mm_decls.fcheckunusedlocals:
    db        0
mm_decls.highmem:
    db        1
    segment .bss
mm_decls.clinux:
    resb      1
    segment .data
mm_decls.dointlibs:
    db        1
    align     8
mm_decls.passlevel:
    dq  0
    align     8
mm_decls.dpasslevel:
    dq  0
    align     8
mm_decls.prodmode:
    dq  0
    align     8
mm_decls.debugmode:
    dq  0
    align     8
mm_decls.libmode:
    dq  0
    segment .bss
    alignb    8
mm_decls.fshortnames:
    resb      8
    alignb    8
mm_decls.outfile:
    resb      8
    alignb    8
mm_decls.destfilename:
    resb      8
    alignb    8
mm_decls.destfilepath:
    resb      8
    alignb    8
mm_decls.nunits:
    resb      8
    alignb    8
mm_decls.nunitsmem:
    resb      8
    alignb    8
mm_diags.currlineno:
    resb      8
    alignb    8
mm_diags.currfileno:
    resb      8
    alignb    8
mm_diags.sbuffer:
    resb      16
    segment .data
    align     8
mm_diags.dest:
    dq  mm_diags.sbuffer
    align     8
mm_diags.printunit.cmpchain:
    dq  0
    segment .bss
mm_diags.getprefix.str:
    resb      1024
mm_diags.getlineinfok.str:
    resb      40
    segment .data
    align     8
mm_diags.printmodelist.tab:
    dq  L11458
    align     8
mm_diags.showprojectinfo.tab:
    dq  L11459
    segment .bss
    alignb    8
mm_lex.lxstart_stack:
    resb      160
    alignb    8
mm_lex.lxsource_stack:
    resb      160
    alignb    8
mm_lex.lxsptr_stack:
    resb      160
    alignb    8
mm_lex.lxfileno_stack:
    resb      160
    alignb    8
mm_lex.lxnextlx_stack:
    resb      320
mm_lex.lximport_stack:
    resb      20
    segment .data
    align     8
mm_lex.sourcelevel:
    dq  0
    segment .bss
    alignb    8
mm_lex.lximport:
    resb      8
    alignb    8
mm_lex.lxsource:
    resb      8
    alignb    8
mm_lex.lxstart:
    resb      8
    alignb    8
mm_lex.lxsptr:
    resb      8
    alignb    8
mm_lex.lxifcond:
    resb      8
    alignb    8
mm_lex.lxfileno:
    resb      8
    alignb    8
mm_lex.hashtable:
    resb      524288
mm_lex.namemap:
    resb      256
    segment .data
    align     8
mm_lex.u64maxstr:
    dq  L11460
    align     8
mm_lib.autotypeno:
    dq  0
    align     8
mm_lib.nextavindex:
    dq  0
    align     8
mm_lib.nextsvindex:
    dq  0
    segment .bss
    alignb    8
mm_lib.exprstrvar:
    resb      16
    segment .data
    align     8
mm_lib.exprstr:
    dq  mm_lib.exprstrvar
    align     8
mm_lib.unitheapptr:
    dq  0
    align     8
mm_lib.remainingunits:
    dq  0
    segment .bss
    alignb    8
mm_lib.sbuffer:
    resb      16
    segment .data
    align     8
mm_lib.dest:
    dq  mm_lib.sbuffer
    segment .bss
    alignb    8
mm_lib.jdest:
    resb      8
    alignb    8
mm_lib.framevarname:
    resb      8
mm_lib.nextautotype.str:
    resb      32
mm_lib.getdottedname.str:
    resb      256
mm_lib.strmode.str:
    resb      4096
mm_lib.strmode2.str:
    resb      4096
    segment .data
    align     8
mm_libsources.syslibnames:
    dq  L11461
    dq  L11462
    dq  L11463
    dq  L11464
    dq  L11465
    dq  L11466
    dq  L11467
    dq  L11468
    dq  L11469
    dq  L11470
    dq  L11471
    dq  L11472
    dq  L11473
    align     8
mm_libsources.syslibtext:
    dq  L11474
    dq  L11475
    dq  L11476
    dq  L11477
    dq  L11478
    dq  L11479
    dq  L11480
    dq  L11481
    dq  L11482
    dq  L11483
    dq  L11484
    dq  L11485
    dq  L11486
    align     8
mm_modules.fileext:
    dq  L11487
    segment .bss
mm_modules.getmodulefilename.str:
    resb      300
    alignb    8
mm_name.currstproc:
    resb      8
    segment .data
    align     8
mm_name.allowmodname:
    dq  0
    segment .bss
    alignb    8
mm_name.noexpand:
    resb      8
    alignb    8
mm_name.noassem:
    resb      8
    alignb    8
mm_name.macrolevels:
    resb      8
    alignb    8
mm_name.macroparams:
    resb      400
    alignb    8
mm_name.macroparamsgen:
    resb      400
    alignb    8
mm_name.macroargs:
    resb      400
    alignb    8
mm_name.nmacroparams:
    resb      8
    alignb    8
mm_name.nmacroargs:
    resb      8
    segment .data
    align     8
mm_parse.intabledata:
    dq  0
    align     8
mm_parse.inreadprint:
    dq  0
    align     8
mm_parse.inparamlist:
    dq  0
    align     8
mm_parse.inrecordbody:
    dq  0
    align     8
mm_parse.inimportmodule:
    dq  0
    align     8
mm_parse.labelseen:
    dq  0
    align     8
mm_parse.tabledataname:
    dq  0
    segment .bss
    alignb    8
mm_parse.procstack:
    resb      80
    segment .data
    align     8
mm_parse.nprocstack:
    dq  0
    segment .bss
    alignb    8
mm_parse.unionstring:
    resb      8
    alignb    8
mm_parse.unionpend:
    resb      8
    segment .data
    align     8
mm_parse.unionlastvar:
    dq  0
    segment .bss
    alignb    8
mm_parse.dretvar:
    resb      8
    segment .data
    align     8
mm_parse.varattribs:
    dq  0
    segment .bss
    alignb    8
mm_parse.dollarstack:
    resb      80
    segment .data
    align     8
mm_parse.ndollar:
    dq  0
    align     8
mm_parse.insiderecord:
    dq  0
    align     8
mm_parse.insidedllimport:
    dq  0
    segment .bss
    alignb    8
mm_parse.forindexvars:
    resb      80
    alignb    8
mm_parse.nforloops:
    resb      8
    segment .data
    align     8
mm_parse.readcompilervar.monthnames:
    dq  L11488
    dq  L11489
    dq  L11490
    dq  L11491
    dq  L11492
    dq  L11493
    dq  L11494
    dq  L11495
    dq  L11496
    dq  L11497
    dq  L11498
    dq  L11499
mm_support.bytemasks:
    dq  0x8040201008040201
;ENDDATA
    align     8
mm_tables.stdnames:
    dq  L11500
    dq  L11501
    dq  L11502
    dq  L11503
    dq  L11504
    dq  L11505
    dq  L11506
    dq  L11507
    dq  L11508
    dq  L11509
    dq  L11510
    dq  L11511
    dq  L11512
    dq  L11513
    dq  L11514
    dq  L11515
    dq  L11516
    dq  L11517
    dq  L11518
    dq  L11519
    dq  L11520
    dq  L11521
    dq  L11522
    dq  L11523
    dq  L11524
    dq  L11525
    dq  L11526
    dq  L11527
    dq  L11528
    dq  L11529
    dq  L11530
    dq  L11531
mm_tables.stdsize:
    dq  0x808080808040800
    dq  0x201010110001000
    dq  0x100804020104
    dq  0x8000008080000
;ENDDATA
mm_tables.stdpcl:
    dq  0x60406060A010200
    dq  0x80703030B0B0B0B
    dq  0x606060605040309
    dq  0xB060606060606
;ENDDATA
    segment .bss
    alignb    8
mm_tables.trefproc:
    resb      8
    alignb    8
mm_tables.treflabel:
    resb      8
    segment .data
    align     8
mm_tables.sysfnnames:
    dq  L11532
    dq  L11533
    dq  L11534
    dq  L11535
    dq  L11536
    dq  L11537
    dq  L11538
    dq  L11539
    dq  L11540
    dq  L11541
    dq  L11542
    dq  L11543
    dq  L11544
    dq  L11545
    dq  L11546
    dq  L11547
    dq  L11548
    dq  L11549
    dq  L11550
    dq  L11551
    dq  L11552
    dq  L11553
    dq  L11554
    dq  L11555
    dq  L11556
    dq  L11557
    dq  L11558
    dq  L11559
    dq  L11560
    dq  L11561
    dq  L11562
    dq  L11563
    dq  L11564
mm_tables.sysfnparams:
    dq  0
    dq  0
    dq  0
    dq  0
    db        0
;ENDDATA
mm_tables.sysfnres:
    dq  0
    dq  0
    dq  0
    dq  0x101010100000000
    db        1
;ENDDATA
    segment .bss
    alignb    8
mm_tables.sysfnhandlers:
    resb      264
    segment .data
    align     8
mm_tables.jtagnames:
    dq  L11565
    dq  L11566
    dq  L11567
    dq  L11568
    dq  L11569
    dq  L11570
    dq  L11571
    dq  L11572
    dq  L11573
    dq  L11574
    dq  L11575
    dq  L11576
    dq  L11577
    dq  L11578
    dq  L11579
    dq  L11580
    dq  L11581
    dq  L11582
    dq  L11583
    dq  L11584
    dq  L11585
    dq  L11586
    dq  L11587
    dq  L11588
    dq  L11589
    dq  L11590
    dq  L11591
    dq  L11592
    dq  L11593
    dq  L11594
    dq  L11595
    dq  L11596
    dq  L11597
    dq  L11598
    dq  L11599
    dq  L11600
    dq  L11601
    dq  L11602
    dq  L11603
    dq  L11604
    dq  L11605
    dq  L11606
    dq  L11607
    dq  L11608
    dq  L11609
    dq  L11610
    dq  L11611
    dq  L11612
    dq  L11613
    dq  L11614
    dq  L11615
    dq  L11616
    dq  L11617
    dq  L11618
    dq  L11619
    dq  L11620
    dq  L11621
    dq  L11622
    dq  L11623
    dq  L11624
    dq  L11625
    dq  L11626
    dq  L11627
    dq  L11628
    dq  L11629
    dq  L11630
    dq  L11631
    dq  L11632
    dq  L11633
    dq  L11634
    dq  L11635
    dq  L11636
    dq  L11637
    dq  L11638
    dq  L11639
    dq  L11640
    dq  L11641
    dq  L11642
    dq  L11643
    dq  L11644
    dq  L11645
    dq  L11646
    dq  L11647
    dq  L11648
    dq  L11649
    dq  L11650
    dq  L11651
    dq  L11652
    dq  L11653
    dq  L11654
    dq  L11655
    dq  L11656
    dq  L11657
    dq  L11658
    dq  L11659
    dq  L11660
    dq  L11661
    dq  L11662
    dq  L11663
    dq  L11664
    dq  L11665
    dq  L11666
    dq  L11667
    dq  L11668
    dq  L11669
    dq  L11670
    dq  L11671
    dq  L11672
    dq  L11673
    dq  L11674
    dq  L11675
    dq  L11676
    dq  L11677
    dq  L11678
    dq  L11679
    dq  L11680
    dq  L11681
    dq  L11682
    dq  L11683
    dq  L11684
    dq  L11685
    dq  L11686
    dq  L11687
mm_tables.jsubs:
    dq  0x1000000000000
    dq  0x201010100000003
    dq  0x101020201010102
    dq  0x202020202010002
    dq  0x102020202020202
    dq  0x202000202020201
    dq  0x101010202020202
    dq  0x10101010101
    dq  0x1010100010101
    dq  0
    dq  0x2020000000000
    dq  0x303030303010100
    dq  0x1020303
    dq  0x203030303030301
    dq  0x202030302020103
    db        1
    db        1
    db        1
;ENDDATA
mm_tables.jisexpr:
    dq  0x300030303030300
    dq  0x203030000000000
    dq  0x303030301010102
    dq  0x303030303030303
    dq  0x102010102010203
    dq  0x303030202020203
    dq  0x303030303030303
    dq  0x303030303030303
    dq  0x303030301010103
    dq  0x303030303030303
    dq  0x303000303030303
    dq  0x300030003
    dq  0
    dq  0x3000300
    dq  3
    db        0
    db        3
    db        1
;ENDDATA
mm_tables.jsolo:
    dq  0x1000000000000
    dq  1
    dq  0
    dq  0x101010100000000
    dq  1
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0x100010000
    dq  0x101010001010100
    dq  0x101010101010101
    dq  0x101010101010001
    db        0
    db        1
    db        1
;ENDDATA
    align     8
mm_tables.bitfieldnames:
    dq  L11688
    dq  L11689
    dq  L11690
    dq  L11691
    dq  L11692
    dq  L11693
    dq  L11694
    dq  L11695
    align     8
mm_tables.optypenames:
    dq  L11696
    dq  L11697
    dq  L11698
    dq  L11699
    align     8
mm_tables.symbolnames:
    dq  L11700
    dq  L11701
    dq  L11702
    dq  L11703
    dq  L11704
    dq  L11705
    dq  L11706
    dq  L11707
    dq  L11708
    dq  L11709
    dq  L11710
    dq  L11711
    dq  L11712
    dq  L11713
    dq  L11714
    dq  L11715
    dq  L11716
    dq  L11717
    dq  L11718
    dq  L11719
    dq  L11720
    dq  L11721
    dq  L11722
    dq  L11723
    dq  L11724
    dq  L11725
    dq  L11726
    dq  L11727
    dq  L11728
    dq  L11729
    dq  L11730
    dq  L11731
    dq  L11732
    dq  L11733
    dq  L11734
    dq  L11735
    dq  L11736
    dq  L11737
    dq  L11738
    dq  L11739
    dq  L11740
    dq  L11741
    dq  L11742
    dq  L11743
    dq  L11744
    dq  L11745
    dq  L11746
    dq  L11747
    dq  L11748
    dq  L11749
    dq  L11750
    dq  L11751
    dq  L11752
    dq  L11753
    dq  L11754
    dq  L11755
    dq  L11756
    dq  L11757
    dq  L11758
    dq  L11759
    dq  L11760
    dq  L11761
    dq  L11762
    dq  L11763
    dq  L11764
    dq  L11765
    dq  L11766
    dq  L11767
    dq  L11768
    dq  L11769
    dq  L11770
    dq  L11771
    dq  L11772
    dq  L11773
    dq  L11774
    dq  L11775
    dq  L11776
    dq  L11777
    dq  L11778
    dq  L11779
    dq  L11780
    dq  L11781
    dq  L11782
    dq  L11783
    dq  L11784
    dq  L11785
    dq  L11786
    dq  L11787
    dq  L11788
    dq  L11789
    dq  L11790
    dq  L11791
    dq  L11792
    dq  L11793
    dq  L11794
    dq  L11795
    dq  L11796
    dq  L11797
    dq  L11798
    dq  L11799
    dq  L11800
    dq  L11801
    dq  L11802
    dq  L11803
    dq  L11804
    dq  L11805
    dq  L11806
    dq  L11807
    dq  L11808
    dq  L11809
    dq  L11810
    dq  L11811
    dq  L11812
    dq  L11813
    dq  L11814
    dq  L11815
    dq  L11816
    dq  L11817
    dq  L11818
    dq  L11819
    dq  L11820
    dq  L11821
    dq  L11822
    dq  L11823
    dq  L11824
    dq  L11825
    dq  L11826
    dq  L11827
    dq  L11828
    dq  L11829
    dq  L11830
    dq  L11831
    dq  L11832
    dq  L11833
    dq  L11834
    dq  L11835
mm_tables.symboloptypes:
    dq  0x10000000000
    dq  0
    dq  0x100000100000000
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x202000101010101
    dq  0x30202020202
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
;ENDDATA
mm_tables.symbolgenops:
    dq  0
    dq  0
    dq  0x2B00000000000000
    dq  0x333231302F2E2D2C
    dq  0x3837363534
    dq  0x3F000000520000
    dq  0x4243503D3E
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
;ENDDATA
mm_tables.symbolgentoops:
    dq  0
    dq  0
    dq  0x5A00000000000000
    dq  0x6160005F5E5D5C5B
    dq  0x6665646362
    dq  0x6C000000000000
    dq  0x6A6B
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
;ENDDATA
mm_tables.symbolopprios:
    dq  0x10000000000
    dq  0
    dq  0x400000500000000
    dq  0x404030303030304
    dq  0x808070404030304
    dq  0x606020606
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
;ENDDATA
mm_tables.exprstarter:
    dq  0x100
    dq  0x1000000010001
    dq  0x100000000010000
    dq  1
    dq  0x101000000
    dq  0x101000000000101
    dq  0x101000101010101
    dq  0x101010100000000
    dq  0x100010001
    dq  0x101000000000000
    dq  1
    dq  1
    dq  0
    dq  0
    dq  0x10100000000
    dq  0x100000000000000
    dq  0x100000100000101
;ENDDATA
    align     8
mm_tables.headerdirnames:
    dq  L11836
    dq  L11837
    dq  L11838
    dq  L11839
    align     8
mm_tables.scopenames:
    dq  L11840
    dq  L11841
    dq  L11842
    dq  L11843
    align     8
mm_tables.parammodenames:
    dq  L11844
    dq  L11845
    align     8
mm_tables.namenames:
    dq  L11846
    dq  L11847
    dq  L11848
    dq  L11849
    dq  L11850
    dq  L11851
    dq  L11852
    dq  L11853
    dq  L11854
    dq  L11855
    dq  L11856
    dq  L11857
    dq  L11858
    dq  L11859
    dq  L11860
    dq  L11861
    dq  L11862
    dq  L11863
mm_tables.name2pid:
    dq  0x102000009000000
    dq  0x6000504030000
    db        0
    db        0
;ENDDATA
    align     8
mm_tables.propnames:
    dq  L11864
    dq  L11865
    dq  L11866
    dq  L11867
    dq  L11868
    dq  L11869
    dq  L11870
    dq  L11871
    dq  L11872
    dq  L11873
    align     8
mm_tables.stnames:
    dq  L11874
    dq  L11875
    dq  L11876
    dq  L11877
    dq  L11878
    dq  L11879
    dq  L11880
    dq  L11881
    dq  L11882
    dq  L11883
    dq  L11884
    dq  L11885
    dq  L11886
    dq  L11887
    dq  L11888
    dq  L11889
    dq  L11890
    dq  L11891
    dq  L11892
    dq  L11893
    dq  L11894
    dq  L11895
    dq  L11896
    dq  L11897
    dq  L11898
    dq  L11899
    dq  L11900
    dq  L11901
    dq  L11902
    dq  L11903
    dq  L11904
    dq  L11905
    dq  L11906
    dq  L11907
    dq  L11908
    dq  L11909
    dq  L11910
    dq  L11911
    dq  L11912
    dq  L11913
    dq  L11914
    dq  L11915
    dq  L11916
    dq  L11917
    dq  L11918
    dq  L11919
    dq  L11920
    dq  L11921
    dq  L11922
    dq  L11923
    dq  L11924
    dq  L11925
    dq  L11926
    dq  L11927
    dq  L11928
    dq  L11929
    dq  L11930
    dq  L11931
    dq  L11932
    dq  L11933
    dq  L11934
    dq  L11935
    dq  L11936
    dq  L11937
    dq  L11938
    dq  L11939
    dq  L11940
    dq  L11941
    dq  L11942
    dq  L11943
    dq  L11944
    dq  L11945
    dq  L11946
    dq  L11947
    dq  L11948
    dq  L11949
    dq  L11950
    dq  L11951
    dq  L11952
    dq  L11953
    dq  L11954
    dq  L11955
    dq  L11956
    dq  L11957
    dq  L11958
    dq  L11959
    dq  L11960
    dq  L11961
    dq  L11962
    dq  L11963
    dq  L11964
    dq  L11965
    dq  L11966
    dq  L11967
    dq  L11968
    dq  L11969
    dq  L11970
    dq  L11971
    dq  L11972
    dq  L11973
    dq  L11974
    dq  L11975
    dq  L11976
    dq  L11977
    dq  L11978
    dq  L11979
    dq  L11980
    dq  L11981
    dq  L11982
    dq  L11983
    dq  L11984
    dq  L11985
    dq  L11986
    dq  L11987
    dq  L11988
    dq  L11989
    dq  L11990
    dq  L11991
    dq  L11992
    dq  L11993
    dq  L11994
    dq  L11995
    dq  L11996
    dq  L11997
    dq  L11998
    dq  L11999
    dq  L12000
    dq  L12001
    dq  L12002
    dq  L12003
    dq  L12004
    dq  L12005
    dq  L12006
    dq  L12007
    dq  L12008
    dq  L12009
    dq  L12010
    dq  L12011
    dq  L12012
    dq  L12013
    dq  L12014
    dq  L12015
    dq  L12016
    dq  L12017
    dq  L12018
    dq  L12019
    dq  L12020
    dq  L12021
    dq  L12022
    dq  L12023
    dq  L12024
    dq  L12025
    dq  L12026
    dq  L12027
    dq  L12028
    dq  L12029
    dq  L12030
    dq  L12031
    dq  L12032
    dq  L12033
    dq  L12034
    dq  L12035
    dq  L12036
    dq  L12037
    dq  L12038
    dq  L12039
    dq  L12040
    dq  L12041
    dq  L12042
    dq  L12043
    dq  L12044
    dq  L12045
    dq  L12046
    dq  L12047
mm_tables.stsymbols:
    dq  0x5956555454535251
    dq  0x605F5E5E5D5C5B5A
    dq  0x6666656463626157
    dq  0x8484696969686766
    dq  0x6A6A6A6A6A6A8385
    dq  0x6C6D6C6D6D806B6B
    dq  0x4478777571706F74
    dq  0x7B7F87877A454545
    dq  0x7E7E587372888888
    dq  0x4F50504F4F4F7686
    dq  0x4F4F4F4F4F4F4F4F
    dq  0x4F4F4F4F4F4F4F4F
    dq  0x818181814242794F
    dq  0x8181818181818181
    dq  0x201F282726828181
    dq  0x25241E1D2E2D2C21
    dq  0x373334353230312F
    dq  0x3737373737373737
    dq  0x3636363838373737
    dq  0x3939393636363636
    dq  0x5757573939393939
    db        17
    db        "|}}}}"
;ENDDATA
    align     2
mm_tables.stsubcodes:
    dw        92
    dw        0
    dw        92
    dw        0
    dw        1
    dw        105
    dw        107
    dw        105
    dw        106
    dw        113
    dw        0
    dw        0
    dw        0
    dw        1
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        101
    dw        102
    dw        103
    dw        0
    dw        107
    dw        108
    dw        109
    dw        110
    dw        0
    dw        1
    dw        0
    dw        0
    dw        114
    dw        115
    dw        116
    dw        117
    dw        114
    dw        115
    dw        118
    dw        119
    dw        58
    dw        0
    dw        0
    dw        0
    dw        1
    dw        2
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        66
    dw        83
    dw        83
    dw        0
    dw        1
    dw        0
    dw        0
    dw        0
    dw        29
    dw        30
    dw        31
    dw        0
    dw        0
    dw        0
    dw        1
    dw        3
    dw        0
    dw        0
    dw        3
    dw        4
    dw        1
    dw        12
    dw        0
    dw        14
    dw        15
    dw        16
    dw        3
    dw        2
    dw        1
    dw        17
    dw        17
    dw        18
    dw        19
    dw        4
    dw        12
    dw        12
    dw        5
    dw        6
    dw        6
    dw        13
    dw        25
    dw        11
    dw        1
    dw        2
    dw        71
    dw        72
    dw        74
    dw        73
    dw        75
    dw        76
    dw        77
    dw        78
    dw        79
    dw        80
    dw        81
    dw        83
    dw        84
    dw        82
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        1
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        61
    dw        0
    dw        0
    dw        0
    dw        68
    dw        69
    dw        70
    dw        71
    dw        72
    dw        73
    dw        74
    dw        75
    dw        76
    dw        77
    dw        78
    dw        79
    dw        81
    dw        83
    dw        1
    dw        2
    dw        3
    dw        4
    dw        5
    dw        6
    dw        7
    dw        8
    dw        1
    dw        2
    dw        3
    dw        4
    dw        5
    dw        6
    dw        7
    dw        8
    dw        81
    dw        89
    dw        96
    dw        1
    dw        0
    dw        1
    dw        2
    dw        3
    dw        4
    align     8
mm_tables.convnames:
    dq  L12048
    dq  L12049
    dq  L12050
    dq  L12051
    dq  L12052
    dq  L12053
    dq  L12054
    dq  L12055
    dq  L12056
    dq  L12057
    dq  L12058
    dq  L12059
    dq  L12060
    dq  L12061
mm_tables.convtopcl:
    dq  0x74737271706F00
    db        "@"
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
    align     8
mm_tables.d_typestarterset:
    dq  0x4F
    dq  0xB
    dq  0x75
    dq  0x6F
    dq  0x50
    dq  0x79
    align     2
mm_tables.softconvtable:
    dw        7
    dw        6
    dw        2
    dw        2
    dw        2
    dw        5
    dw        7
    dw        2
    dw        2
    dw        2
    dw        1
    dw        1
    dw        7
    dw        7
    dw        7
    dw        1
    dw        1
    dw        7
    dw        7
    dw        7
    dw        1
    dw        1
    dw        7
    dw        7
    dw        7
    segment .bss
mm_tables.endsexpr:
    resb      136
    segment .data
mm_tables.exprendsymbols:
    dq  0x5760635453520C0A
    db        3
    db        16
    db        4
    db        "^"
;ENDDATA
    segment .bss
mm_tables.isbooltag:
    resb      123
    alignb    8
mm_type.countedfields:
    resb      8
    alignb    8
mm_type.inassem:
    resb      8
    alignb    8
mm_type.inidata:
    resb      8
    alignb    8
mm_type.tpass.depth:
    resb      8
    alignb    8
mm_type.setrecordsize.depth:
    resb      8
    alignb    8
mm_type.tx_assign.nn:
    resb      8
    segment .text
;Proc msys.start
msys.start:
;?>>
    %define msys.start.nargs -8
   %define R.nargs64 rdi
    %define msys.start.args -16
   %define R.res rbx
   %define R.j rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    sub       rsp,	8
    lea       rax,	[msys.start.startupinfo]
    push      rax
    lea       rcx,	[rbp + msys.start.nargs]
    lea       rdx,	[rbp + msys.start.args]
    lea       r8,	[msys.envstrings]
    xor       r9d,	r9d
    sub       rsp,	32
    call      __getmainargs
    add       rsp,	48
    movsxd    r10,	eax
    mov       rbx,	r10
    movsxd    rax,	dword [rbp + msys.start.nargs]
    mov       [msys.nsysparams],	rax
    mov       rax,	[msys.nsysparams]
    cmp       rax,	128
    jle       L3
    lea       rcx,	[L12062]
    call      printf
    mov       rcx,	50
    call      exit
L3:
    movsxd    rax,	dword [rbp + msys.start.nargs]
    mov       rdi,	rax
    mov       r12,	1
    cmp       rdi,	1
    jl        L6
L4:
    mov       rax,	[rbp + msys.start.args]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[msys.sysparams]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    inc       r12
    cmp       r12,	rdi
    jle       L4
L6:
    mov       rax,	[msys.$cmdskip]
    inc       rax
    mov       r10,	[msys.nsysparams]
    sub       r10,	rax
    mov       [msys.ncmdparams],	r10
    lea       rax,	[msys.sysparams]
    mov       r10,	[msys.$cmdskip]
    lea       rax,	[rax + r10*8]
    mov       [msys.cmdparams],	rax
    mov       rsi,	1
    xor       eax,	eax
    mov       [msys.nenvstrings],	rax
    jmp       L8
L7:
    inc       qword [msys.nenvstrings]
    inc       rsi
L8:
    mov       rax,	[msys.envstrings]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L7
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.pushio
msys.pushio:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[msys.niostack]
    cmp       rax,	10
    jl        L12
    lea       rcx,	[L12063]
    call      printf
    mov       rcx,	53
    call      exit
L12:
    inc       qword [msys.niostack]
    mov       rax,	[msys.outchan]
    lea       r10,	[msys.outchan_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[msys.outdev]
    lea       r10,	[msys.outdev_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[msys.fmtstr]
    lea       r10,	[msys.fmtstr_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[msys.needgap]
    lea       r10,	[msys.needgap_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    mov       [msys.needgap],	rax
    xor       eax,	eax
    mov       [msys.fmtstr],	rax
    xor       eax,	eax
    mov       [msys.outchan],	rax
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_startfile
msys.m$print_startfile:
;?>>
   %define R.dev rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.pushio
    mov       [msys.outchan],	rdi
    test      rdi,	rdi
    jz        L15
    mov       rax,	2
    mov       [msys.outdev],	rax
    jmp       L14
L15:
    mov       rax,	1
    mov       [msys.outdev],	rax
L14:
    call      msys.resetprintbuffer
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_startstr
msys.m$print_startstr:
;?>>
   %define R.s rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      msys.pushio
    mov       rax,	rbx
    lea       r10,	[msys.ptr_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[msys.ptr_stack]
    mov       r10,	[msys.niostack]
    lea       rax,	[rax + r10*8-8]
    mov       rdi,	rax
    mov       [msys.outchan],	rdi
    mov       rax,	3
    mov       [msys.outdev],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_startptr
msys.m$print_startptr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.pushio
    mov       [msys.outchan],	rdi
    mov       rax,	3
    mov       [msys.outdev],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_startcon
msys.m$print_startcon:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.pushio
    mov       rax,	1
    mov       [msys.outdev],	rax
    call      msys.resetprintbuffer
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_setfmt
msys.m$print_setfmt:
;?>>
   %define R.format rcx
;?]]
;---------------
    mov       [msys.fmtstr],	rcx
;---------------
    ret       
;End 
;Proc msys.m$print_end
msys.m$print_end:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    mov       rcx,	1
    call      msys.nextfmtchars
    mov       rax,	[msys.niostack]
    cmp       rax,	1
    jnz       L22
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jz        L23
    cmp       rax,	2
    jnz       L22
L23:
    call      msys.dumpprintbuffer
L22:
    mov       rax,	[msys.niostack]
    test      rax,	rax
    jz        L20
L25:
    lea       rax,	[msys.outchan_stack]
    mov       r10,	[msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [msys.outchan],	rax
    lea       rax,	[msys.outdev_stack]
    mov       r10,	[msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [msys.outdev],	rax
    lea       rax,	[msys.fmtstr_stack]
    mov       r10,	[msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [msys.fmtstr],	rax
    lea       rax,	[msys.needgap_stack]
    mov       r10,	[msys.niostack]
    movzx     rax,	byte [rax + r10-1]
    mov       [msys.needgap],	rax
    dec       qword [msys.niostack]
L20:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_ptr
msys.m$print_ptr:
;?>>
   %define R.a rdi
   %define R.fmtstyle rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rbx,	rbx
    jnz       L28
    lea       rax,	[L12064]
    mov       rbx,	rax
L28:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      msys.m$print_u64
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_ptr_nf
msys.m$print_ptr_nf:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_ptr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_i64
msys.m$print_i64:
;?>>
   %define R.a rbx
   %define R.fmtstyle rsi
    %define msys.m$print_i64.s -40
    %define msys.m$print_i64.fmt -56
   %define R.n rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rsi,	rsi
    jnz       L32
    cmp       rbx,	0
    jl        L34
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.m$print_i64.s]
    mov       r8,	10
    xor       r9d,	r9d
    call      msys.u64tostr
    mov       rdi,	rax
    jmp       L33
L34:
    mov       rax,	rbx
    mov       r10,	-9223372036854775808
    cmp       rax,	r10
    jnz       L35
    lea       rax,	[msys.defaultfmt]
    lea       r10,	[rbp + msys.m$print_i64.fmt]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    jmp       L36
L35:
    mov       al,	45
    mov       [rbp + msys.m$print_i64.s],	al
    lea       rax,	[rbp + msys.m$print_i64.s+1]
    mov       r10,	rbx
    neg       r10
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	10
    xor       r9d,	r9d
    call      msys.u64tostr
    inc       rax
    mov       rdi,	rax
L33:
    lea       rcx,	[rbp + msys.m$print_i64.s]
    mov       rdx,	rdi
    call      msys.printstr_n
    jmp       L31
L32:
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_i64.fmt]
    call      msys.strtofmt
    movzx     rax,	byte [rbp + msys.m$print_i64.fmt+14]
    cmp       rax,	86
    jnz       L38
    mov       [msys.fmtparam],	rbx
    xor       eax,	eax
    mov       [msys.needgap],	rax
    jmp       L37
L38:
;msys.m$print_i64.dofmt:
L36:
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.m$print_i64.fmt]
    call      msys.tostr_i64
L37:
L31:
    mov       rax,	1
    mov       [msys.needgap],	rax
;---------------
    add       rsp,	88
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_i64_nf
msys.m$print_i64_nf:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_i64
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_bool
msys.m$print_bool:
;?>>
   %define R.a rdi
   %define R.fmtstyle rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rdi,	rdi
    jz        L42
    lea       rcx,	[L12065]
    mov       rdx,	rbx
    call      msys.m$print_str
    jmp       L41
L42:
    lea       rcx,	[L12066]
    mov       rdx,	rbx
    call      msys.m$print_str
L41:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_u64
msys.m$print_u64:
;?>>
   %define R.a rdi
   %define R.fmtstyle rbx
    %define msys.m$print_u64.s -40
    %define msys.m$print_u64.fmt -56
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rbx,	rbx
    jnz       L45
    lea       rcx,	[rbp + msys.m$print_u64.s]
    lea       rdx,	[L12067]
    mov       r8,	rdi
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_u64.s]
    call      msys.printstr
    jmp       L44
L45:
    mov       rcx,	rbx
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_u64.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    lea       rdx,	[rbp + msys.m$print_u64.fmt]
    call      msys.tostr_u64
L44:
    mov       rax,	1
    mov       [msys.needgap],	rax
;---------------
    add       rsp,	96
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_r64
msys.m$print_r64:
;?>>
   %define R.x XMM15
   %define R.fmtstyle rdi
    %define msys.m$print_r64.s -360
    %define msys.m$print_r64.fmt -376
    push      rdi
    movq      rax,	XMM15
    push      rax
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	416
    movq      XMM15,	XMM0
    mov       rdi,	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L48
    lea       rcx,	[rbp + msys.m$print_r64.s]
    lea       rdx,	[L12068]
    movq      XMM2,	XMM15
    movq      r8,	XMM2
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_r64.s]
    call      msys.printstr
    jmp       L47
L48:
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_r64.fmt]
    call      msys.strtofmt
    movq      XMM0,	XMM15
    lea       rdx,	[rbp + msys.m$print_r64.fmt]
    call      msys.tostr_r64
L47:
    mov       rax,	1
    mov       [msys.needgap],	rax
;---------------
    add       rsp,	416
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_r32
msys.m$print_r32:
;?>>
   %define R.x XMM15
   %define R.fmtstyle rdi
    push      rdi
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	40
    movq      XMM15,	XMM0
    mov       rdi,	rdx
;---------------
    movq      XMM4,	XMM15
    cvtss2sd  XMM4,	XMM4
    movq      XMM0,	XMM4
    mov       rdx,	rdi
    call      msys.m$print_r64
;---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_c8
msys.m$print_c8:
;?>>
    %define msys.m$print_c8.a 40
   %define R.fmtstyle rsi
    %define msys.m$print_c8.s -32
    %define msys.m$print_c8.fmt -48
   %define R.n rdi
   %define R.charmode bl
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       [rbp+40],	rcx
    mov       rsi,	rdx
;---------------
    xor       bl,	bl
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rsi,	rsi
    jz        L52
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_c8.fmt]
    call      msys.strtofmt
    mov       bl,	[rbp + msys.m$print_c8.fmt+12]
L52:
    movzx     rax,	bl
    cmp       rax,	77
    jnz       L54
    lea       rcx,	[rbp + msys.m$print_c8.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.m$print_c8.s]
    lea       r9,	[rbp + msys.m$print_c8.fmt]
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L53
L54:
    mov       rax,	[rbp + msys.m$print_c8.a]
    mov       [rbp + msys.m$print_c8.s],	rax
    xor       eax,	eax
    mov       [rbp + msys.m$print_c8.s+8],	al
    lea       rcx,	[rbp + msys.m$print_c8.s]
    call      msys.getutfsize
    mov       rdi,	rax
L53:
    lea       rcx,	[rbp + msys.m$print_c8.s]
    mov       rdx,	rdi
    call      msys.printstr_n
    mov       rax,	1
    mov       [msys.needgap],	rax
;---------------
    add       rsp,	88
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_str
msys.m$print_str:
;?>>
   %define R.s rdi
   %define R.fmtstyle rbx
    %define msys.m$print_str.fmt -16
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L57
    lea       rcx,	[L12069]
    call      msys.printstr
    jmp       L55
L57:
    test      rbx,	rbx
    jnz       L59
    mov       rcx,	rdi
    call      msys.printstr
    jmp       L58
L59:
    mov       rcx,	rbx
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_str.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_str.fmt]
    call      msys.tostr_str
L58:
    mov       rax,	1
    mov       [msys.needgap],	rax
L55:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_strn
msys.m$print_strn:
;?>>
   %define R.s rdi
   %define R.length rbx
   %define R.fmtstyle rsi
    %define msys.m$print_strn.fmt -16
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L62
    lea       rcx,	[L12069]
    call      msys.printstr
    jmp       L60
L62:
    test      rsi,	rsi
    jnz       L64
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      msys.printstr_n
    jmp       L63
L64:
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_strn.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[rbp + msys.m$print_strn.fmt]
    call      msys.tostr_str
L63:
    mov       rax,	1
    mov       [msys.needgap],	rax
L60:
;---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_str_nf
msys.m$print_str_nf:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_strsl
msys.m$print_strsl:
;?>>
    %define msys.m$print_strsl.s 16
    %define msys.m$print_strsl.fmtstyle 24
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12070]
    call      mlib.abortprogram
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_newline
msys.m$print_newline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    mov       rcx,	1
    call      msys.nextfmtchars
    lea       rcx,	[L12071]
    call      msys.printstr
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_nogap
msys.m$print_nogap:
;?>>
;?]]
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
;---------------
    ret       
;End 
;Proc msys.m$print_space
msys.m$print_space:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    lea       rcx,	[L12072]
    call      msys.printstr
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.printstr
msys.printstr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      strlen
    mov       rcx,	rdi
    mov       rdx,	rax
    call      msys.printstr_n
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.printstr_n
msys.printstr_n:
;?>>
   %define R.s rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      msys.dumpstr
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.printstrn_app
msys.printstrn_app:
;?>>
   %define R.s rdi
   %define R.length rbx
   %define R.f rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    test      rbx,	rbx
    jz        L74
    test      rsi,	rsi
    jnz       L76
    lea       rcx,	[L12073]
    mov       rdx,	rbx
    mov       r8,	rdi
    call      printf
    jmp       L75
L76:
    mov       rcx,	rsi
    lea       rdx,	[L12073]
    mov       r8,	rbx
    mov       r9,	rdi
    call      fprintf
L75:
L74:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.printchar
msys.printchar:
;?>>
   %define R.ch rdi
    %define msys.printchar.str -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    mov       [rbp + msys.printchar.str],	dil
    xor       eax,	eax
    mov       [rbp + msys.printchar.str+1],	al
    lea       rcx,	[rbp + msys.printchar.str]
    mov       rdx,	1
    call      msys.printstr_n
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc msys.nextfmtchars
msys.nextfmtchars:
;?>>
   %define R.lastx r12
   %define R.c dil
   %define R.pstart rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rax,	[msys.fmtstr]
    test      rax,	rax
    jnz       L80
    mov       rax,	[msys.needgap]
    test      rax,	rax
    jz        L82
    mov       rcx,	32
    call      msys.printchar
L82:
    xor       eax,	eax
    mov       [msys.needgap],	rax
    jmp       L78
L80:
    mov       rbx,	[msys.fmtstr]
    xor       rsi,	rsi
L83:
    mov       rax,	[msys.fmtstr]
    mov       dil,	[rax]
    movzx     rax,	dil
    cmp       rax,	35
    jz        L86
    test      rax,	rax
    jz        L87
    cmp       rax,	126
    jz        L88
    jmp       L89
L86:
    test      r12,	r12
    jz        L91
    jmp       L92
L91:
    inc       qword [msys.fmtstr]
    test      rsi,	rsi
    jz        L94
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
L94:
    jmp       L78
L87:
    test      rsi,	rsi
    jz        L96
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
    jmp       L95
L96:
    test      r12,	r12
    jnz       L97
    lea       rcx,	[L12074]
    mov       rdx,	1
    call      msys.printstr_n
L97:
L95:
    jmp       L78
L88:
    test      rsi,	rsi
    jz        L99
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
    xor       rsi,	rsi
L99:
    inc       qword [msys.fmtstr]
    mov       rax,	[msys.fmtstr]
    mov       dil,	[rax]
    test      dil,	dil
    jz        L101
    inc       qword [msys.fmtstr]
    movzx     rax,	dil
    mov       rcx,	rax
    call      msys.printchar
L101:
    mov       rbx,	[msys.fmtstr]
    jmp       L85
L89:
;msys.nextfmtchars.skip:
L92:
    inc       rsi
    inc       qword [msys.fmtstr]
L85:
    jmp       L83
L78:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strtofmt
msys.strtofmt:
;?>>
   %define R.s r13
   %define R.slen r14
   %define R.fmt r15
   %define R.c rdi
   %define R.base rbx
   %define R.wset sil
   %define R.n r12
    %define msys.strtofmt.str -104
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    lea       rax,	[msys.defaultfmt]
    movdqu    XMM4,	[rax]
    movdqu    [r15],	XMM4
    test      r13,	r13
    jnz       L104
    jmp       L102
L104:
    cmp       r14,	-1
    jnz       L106
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L106:
    lea       rcx,	[rbp + msys.strtofmt.str]
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    xor       eax,	eax
    mov       [rbp + r14 + msys.strtofmt.str],	al
    lea       rax,	[rbp + msys.strtofmt.str]
    mov       r13,	rax
    xor       sil,	sil
    jmp       L108
L107:
    movzx     rax,	byte [r13]
    mov       rdi,	rax
    inc       r13
    cmp       rdi,	65
    jnz       L111
    mov       al,	65
    mov       [r15+8],	al
    jmp       L110
L111:
    cmp       rdi,	97
    jnz       L112
    mov       al,	97
    mov       [r15+8],	al
    jmp       L110
L112:
    mov       rcx,	rdi
    call      toupper
    movsxd    r10,	eax
    sub       r10,	66
    cmp       r10,	25
    jae       L115
    lea       rax,	[L114]
    jmp       [rax + r10*8]
    segment .data
L114:
    dq  L116
    dq  L145
    dq  L144
    dq  L141
    dq  L142
    dq  L143
    dq  L117
    dq  L115
    dq  L127
    dq  L115
    dq  L115
    dq  L146
    dq  L149
    dq  L118
    dq  L134
    dq  L126
    dq  L115
    dq  L131
    dq  L137
    dq  L140
    dq  L147
    dq  L115
    dq  L119
    dq  L148
    dq  L130
    segment .text
L116:
    mov       al,	2
    mov       [r15+2],	al
    jmp       L113
L117:
    mov       al,	16
    mov       [r15+2],	al
    jmp       L113
L118:
    mov       al,	8
    mov       [r15+2],	al
    jmp       L113
L119:
    xor       rbx,	rbx
L120:
    movzx     rax,	byte [r13]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	48
    jl        L123
    cmp       rax,	57
    jg        L123
    mov       rax,	rbx
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       rbx,	rax
    inc       r13
    jmp       L122
L123:
    jmp       L121
L122:
    jmp       L120
L121:
    mov       rax,	rbx
    cmp       rax,	2
    jl        L125
    cmp       rax,	16
    jg        L125
    mov       [r15+2],	bl
L125:
    jmp       L113
L126:
    mov       al,	34
    mov       [r15+3],	al
    jmp       L113
L127:
    movzx     rax,	byte [r13]
    mov       rcx,	rax
    call      toupper
    mov       [r15+9],	al
    mov       al,	[r13]
    test      al,	al
    jz        L129
    inc       r13
L129:
    jmp       L113
L130:
    mov       al,	48
    mov       [r15+4],	al
    jmp       L113
L131:
    mov       al,	[r13]
    mov       [r15+7],	al
    mov       al,	[r13]
    test      al,	al
    jz        L133
    inc       r13
L133:
    jmp       L113
L134:
    mov       al,	[r13]
    mov       [r15+4],	al
    mov       al,	[r13]
    test      al,	al
    jz        L136
    inc       r13
L136:
    jmp       L113
L137:
    mov       al,	[r13]
    mov       [r15+10],	al
    mov       al,	[r13]
    test      al,	al
    jz        L139
    inc       r13
L139:
    jmp       L113
L140:
    mov       al,	87
    mov       [r15+11],	al
    jmp       L113
L141:
    mov       al,	101
    mov       [r15+5],	al
    jmp       L113
L142:
    mov       al,	102
    mov       [r15+5],	al
    jmp       L113
L143:
    mov       al,	103
    mov       [r15+5],	al
    jmp       L113
L144:
    mov       al,	68
    mov       [r15+13],	al
    jmp       L113
L145:
    mov       al,	67
    mov       [r15+12],	al
    jmp       L113
L146:
    mov       al,	77
    mov       [r15+12],	al
    jmp       L113
L147:
    mov       al,	86
    mov       [r15+14],	al
    jmp       L113
L148:
    lea       rax,	[r15+15]
    or        byte [rax],	1
    jmp       L113
L149:
    lea       rax,	[r15+15]
    or        byte [rax],	2
    jmp       L113
L115:
    mov       rax,	rdi
    cmp       rax,	46
    jz        L151
    cmp       rax,	44
    jz        L152
    cmp       rax,	95
    jz        L152
    cmp       rax,	43
    jz        L153
    cmp       rax,	126
    jz        L154
    cmp       rax,	42
    jz        L155
    jmp       L156
L151:
    mov       sil,	1
    jmp       L150
L152:
    mov       [r15+7],	dil
    jmp       L150
L153:
    mov       al,	43
    mov       [r15+6],	al
    jmp       L150
L154:
    mov       al,	126
    mov       [r15+3],	al
    jmp       L150
L155:
    mov       r12,	[msys.fmtparam]
    jmp       L157
L156:
    cmp       rdi,	48
    jl        L159
    cmp       rdi,	57
    jg        L159
    lea       rax,	[rdi-48]
    mov       r12,	rax
L160:
    movzx     rax,	byte [r13]
    mov       rdi,	rax
    movzx     rax,	byte [r13]
    test      rax,	rax
    jz        L161
L163:
    cmp       rdi,	48
    jl        L165
    cmp       rdi,	57
    jg        L165
    inc       r13
    mov       rax,	r12
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       r12,	rax
    jmp       L164
L165:
    jmp       L161
L164:
    jmp       L160
L161:
;msys.strtofmt.gotwidth:
L157:
    test      sil,	sil
    jnz       L167
    mov       [r15],	r12b
    mov       sil,	1
    jmp       L166
L167:
    mov       [r15+1],	r12b
L166:
L159:
L150:
L113:
L110:
L108:
    mov       al,	[r13]
    test      al,	al
    jnz       L107
L102:
;---------------
    add       rsp,	136
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.domultichar
msys.domultichar:
;?>>
   %define R.p r12
   %define R.n r13
   %define R.dest r14
    %define msys.domultichar.fmt 88
    %define msys.domultichar.str -24
   %define R.q rdi
   %define R.nchars rbx
   %define R.av_1 rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    lea       rax,	[rbp + msys.domultichar.str]
    mov       rdi,	rax
    mov       rbx,	r13
    mov       rsi,	r13
    cmp       rsi,	0
    jle       L171
L169:
    movzx     rax,	byte [r12]
    test      rax,	rax
    jz        L171
L173:
    mov       al,	[r12]
    mov       [rdi],	al
    inc       rdi
    inc       r12
    dec       rsi
    jnz       L169
L171:
    xor       eax,	eax
    mov       [rdi],	al
    lea       rcx,	[rbp + msys.domultichar.str]
    call      strlen
    lea       rcx,	[rbp + msys.domultichar.str]
    mov       rdx,	r14
    mov       r8,	rax
    mov       r9,	[rbp + msys.domultichar.fmt]
    call      msys.expandstr
L168:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.expandstr
msys.expandstr:
;?>>
   %define R.s r13
   %define R.t r14
    %define msys.expandstr.n 80
    %define msys.expandstr.fmt 88
   %define R.i rdi
   %define R.w rbx
   %define R.m rsi
   %define R.av_1 r12
    %define msys.expandstr.av_2 -8
    %define msys.expandstr.av_3 -16
    %define msys.expandstr.av_4 -24
    %define msys.expandstr.av_5 -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L177
    cmp       rbx,	[rbp + msys.expandstr.n]
    jg        L176
L177:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.n]
    mov       [r14 + r10],	al
    mov       rax,	[rbp + msys.expandstr.n]
    jmp       L174
L176:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte [rax+9]
    cmp       rax,	76
    jnz       L179
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    add       r14,	rax
    mov       rdi,	1
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       r12,	rax
    cmp       r12,	1
    jl        L182
L180:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    inc       rdi
    cmp       rdi,	r12
    jle       L180
L182:
    xor       eax,	eax
    mov       [r14],	al
    jmp       L178
L179:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte [rax+9]
    cmp       rax,	82
    jnz       L183
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte [rax+4]
    cmp       rax,	48
    jnz       L185
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+2]
    test      al,	al
    jz        L185
    movzx     rax,	byte [r13]
    cmp       rax,	45
    jz        L186
    movzx     rax,	byte [r13]
    cmp       rax,	43
    jnz       L185
L186:
    mov       al,	[r13]
    mov       [r14],	al
    inc       r14
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_2],	rax
    mov       rax,	[rbp + msys.expandstr.av_2]
    cmp       rax,	0
    jle       L189
L187:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword [rbp + msys.expandstr.av_2]
    jnz       L187
L189:
    mov       rax,	[rbp + msys.expandstr.n]
    dec       rax
    lea       r10,	[r13+1]
    mov       rcx,	r14
    mov       rdx,	r10
    mov       r8,	rax
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    lea       r10,	[r14 + rax]
    sub       r10,	1
    xor       eax,	eax
    mov       [r10],	al
    jmp       L184
L185:
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_3],	rax
    mov       rax,	[rbp + msys.expandstr.av_3]
    cmp       rax,	0
    jle       L192
L190:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword [rbp + msys.expandstr.av_3]
    jnz       L190
L192:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.n]
    mov       [r14 + r10],	al
L184:
    jmp       L178
L183:
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    inc       rax
    sar       rax,	1
    mov       rsi,	rax
    mov       [rbp + msys.expandstr.av_4],	rsi
    mov       rax,	[rbp + msys.expandstr.av_4]
    cmp       rax,	0
    jle       L195
L193:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword [rbp + msys.expandstr.av_4]
    jnz       L193
L195:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    add       r14,	rax
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    sub       rax,	rsi
    mov       [rbp + msys.expandstr.av_5],	rax
    mov       rax,	[rbp + msys.expandstr.av_5]
    cmp       rax,	0
    jle       L198
L196:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword [rbp + msys.expandstr.av_5]
    jnz       L196
L198:
    xor       eax,	eax
    mov       [r14],	al
L178:
    mov       rax,	rbx
L174:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.u64tostr
msys.u64tostr:
;?>>
   %define R.aa rcx
   %define R.s rdx
   %define R.base r8
   %define R.sep r9
    %define msys.u64tostr.t -360
   %define R.dd rdi
   %define R.i rbx
   %define R.j rsi
   %define R.k r12
   %define R.g r13
   %define R.s0 r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	368
;---------------
    xor       rbx,	rbx
    xor       eax,	eax
    mov       r12,	rax
    cmp       r8,	10
    jnz       L201
    mov       rax,	3
    jmp       L200
L201:
    mov       rax,	4
L200:
    mov       r13,	rax
L202:
    mov       rax,	rcx
    mov       r10,	r8
    push      rdx
    xor       edx,	edx
    div       r10
    xchg      rax,	rdx
    pop       rdx
    mov       rdi,	rax
    mov       rax,	rcx
    mov       r10,	r8
    push      rdx
    xor       edx,	edx
    div       r10
    pop       rdx
    mov       rcx,	rax
    lea       rax,	[msys.digits]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    inc       rbx
    mov       r10,	rbx
    mov       [rbp + r10 + msys.u64tostr.t],	al
    inc       r12
    test      r9,	r9
    jz        L206
    test      rcx,	rcx
    jz        L206
    cmp       r12,	r13
    jnz       L206
    inc       rbx
    mov       rax,	rbx
    mov       r10b,	r9b
    mov       [rbp + rax + msys.u64tostr.t],	r10b
    xor       r12,	r12
L206:
    test      rcx,	rcx
    jnz       L202
    mov       rsi,	rbx
    mov       r14,	rdx
    jmp       L208
L207:
    mov       rax,	rbx
    dec       rbx
    mov       al,	[rbp + rax + msys.u64tostr.t]
    mov       [rdx],	al
    inc       rdx
L208:
    test      rbx,	rbx
    jnz       L207
    xor       eax,	eax
    mov       [rdx],	al
    mov       rax,	rsi
L199:
;---------------
    add       rsp,	368
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.i64tostrfmt
msys.i64tostrfmt:
;?>>
   %define R.aa rsi
   %define R.s r12
   %define R.fmt r13
    %define msys.i64tostrfmt.str -360
   %define R.n rdi
   %define R.usigned rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	392
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    xor       rbx,	rbx
    mov       al,	[r13+11]
    test      al,	al
    jz        L212
    mov       rbx,	1
L212:
    mov       rax,	rsi
    mov       r10,	-9223372036854775808
    cmp       rax,	r10
    jnz       L214
    test      rbx,	rbx
    jnz       L214
    mov       al,	45
    mov       [rbp + msys.i64tostrfmt.str],	al
    movzx     rax,	byte [r13+7]
    movzx     r10,	byte [r13+2]
    lea       r11,	[rbp + msys.i64tostrfmt.str+1]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      msys.i64mintostr
    inc       rax
    mov       rdi,	rax
    jmp       L213
L214:
    test      rbx,	rbx
    jnz       L218
    cmp       rsi,	0
    jl        L217
L218:
    mov       al,	[r13+6]
    test      al,	al
    jz        L216
L217:
    cmp       rsi,	0
    jge       L220
    mov       rax,	rsi
    neg       rax
    mov       rsi,	rax
    mov       al,	45
    mov       [rbp + msys.i64tostrfmt.str],	al
    jmp       L219
L220:
    mov       al,	43
    mov       [rbp + msys.i64tostrfmt.str],	al
L219:
    movzx     rax,	byte [r13+7]
    movzx     r10,	byte [r13+2]
    lea       r11,	[rbp + msys.i64tostrfmt.str+1]
    mov       rcx,	rsi
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    inc       rax
    mov       rdi,	rax
    jmp       L215
L216:
    movzx     rax,	byte [r13+7]
    movzx     r10,	byte [r13+2]
    mov       rcx,	rsi
    lea       rdx,	[rbp + msys.i64tostrfmt.str]
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    mov       rdi,	rax
L215:
L213:
    mov       al,	[r13+10]
    test      al,	al
    jz        L222
    mov       al,	[r13+10]
    mov       [rbp + rdi + msys.i64tostrfmt.str],	al
    inc       rdi
    mov       rax,	rdi
    xor       r10d,	r10d
    mov       [rbp + rax + msys.i64tostrfmt.str],	r10b
L222:
    movzx     rax,	byte [r13+2]
    cmp       rax,	10
    jg        L225
    mov       al,	[r13+10]
    test      al,	al
    jz        L224
L225:
    movzx     rax,	byte [r13+8]
    cmp       rax,	97
    jnz       L224
    lea       rcx,	[rbp + msys.i64tostrfmt.str]
    call      mlib.convlcstring
L224:
    lea       rcx,	[rbp + msys.i64tostrfmt.str]
    mov       rdx,	r12
    mov       r8,	rdi
    mov       r9,	r13
    call      msys.expandstr
L210:
;---------------
    add       rsp,	392
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.u64tostrfmt
msys.u64tostrfmt:
;?>>
   %define R.aa rbx
   %define R.s rsi
   %define R.fmt r12
    %define msys.u64tostrfmt.str -360
   %define R.n rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	byte [r12+7]
    movzx     r10,	byte [r12+2]
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.u64tostrfmt.str]
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    mov       rdi,	rax
    mov       al,	[r12+10]
    test      al,	al
    jz        L228
    mov       al,	[r12+10]
    mov       [rbp + rdi + msys.u64tostrfmt.str],	al
    inc       rdi
    mov       rax,	rdi
    xor       r10d,	r10d
    mov       [rbp + rax + msys.u64tostrfmt.str],	r10b
L228:
    movzx     rax,	byte [r12+2]
    cmp       rax,	10
    jg        L231
    mov       al,	[r12+10]
    test      al,	al
    jz        L230
    movzx     rax,	byte [r12+8]
    cmp       rax,	97
    jnz       L230
L231:
L230:
    lea       rcx,	[rbp + msys.u64tostrfmt.str]
    mov       rdx,	rsi
    mov       r8,	rdi
    mov       r9,	r12
    call      msys.expandstr
L226:
;---------------
    add       rsp,	400
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.i64mintostr
msys.i64mintostr:
;?>>
   %define R.s r13
   %define R.base r14
   %define R.sep r15
    %define msys.i64mintostr.t -360
   %define R.i rdi
   %define R.j rbx
   %define R.k rsi
   %define R.g r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	392
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rax,	r14
    cmp       rax,	10
    jz        L234
    cmp       rax,	16
    jz        L235
    cmp       rax,	2
    jz        L236
    jmp       L237
L234:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[L12075]
    call      strcpy
    mov       rbx,	3
    jmp       L233
L235:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[L12076]
    call      strcpy
    mov       rbx,	1
    jmp       L233
L236:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[L12077]
    call      strcpy
    mov       rbx,	7
    jmp       L233
L237:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[L12078]
    call      strcpy
L233:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    call      strlen
    mov       rdi,	rax
    mov       rax,	rdi
    add       r13,	rax
    test      r15,	r15
    jz        L239
    mov       rax,	rbx
    add       r13,	rax
L239:
    xor       eax,	eax
    mov       [r13],	al
    xor       rsi,	rsi
    mov       rax,	r14
    cmp       rax,	10
    jnz       L241
    mov       rax,	3
    jmp       L240
L241:
    mov       rax,	4
L240:
    mov       r12,	rax
    jmp       L243
L242:
    dec       r13
    mov       rax,	rdi
    dec       rdi
    mov       al,	[rbp + rax + msys.i64mintostr.t-1]
    mov       [r13],	al
    test      r15,	r15
    jz        L246
    test      rdi,	rdi
    jz        L246
    inc       rsi
    cmp       rsi,	r12
    jnz       L246
    dec       r13
    mov       [r13],	r15b
    xor       rsi,	rsi
L246:
L243:
    test      rdi,	rdi
    jnz       L242
    mov       rcx,	r13
    call      strlen
L232:
;---------------
    add       rsp,	392
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strtostrfmt
msys.strtostrfmt:
;?>>
   %define R.s r13
   %define R.t r14
    %define msys.strtostrfmt.n 80
    %define msys.strtostrfmt.fmt 88
   %define R.u rdi
   %define R.v rbx
    %define msys.strtostrfmt.str -256
   %define R.w rsi
   %define R.nheap r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    xor       r12,	r12
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    test      al,	al
    jnz       L250
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+8]
    test      al,	al
    jz        L249
L250:
    mov       rax,	[rbp + msys.strtostrfmt.n]
    cmp       rax,	256
    jge       L252
    lea       rax,	[rbp + msys.strtostrfmt.str]
    mov       rdi,	rax
    jmp       L251
L252:
    mov       rax,	[rbp + msys.strtostrfmt.n]
    add       rax,	3
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       rdi,	rax
L251:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    test      al,	al
    jz        L254
    mov       rbx,	rdi
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    mov       [rbx],	al
    inc       rbx
    mov       rax,	[rbp + msys.strtostrfmt.n]
    test      rax,	rax
    jz        L256
    mov       rcx,	rbx
    mov       rdx,	r13
    call      strcpy
    mov       rax,	[rbp + msys.strtostrfmt.n]
    add       rbx,	rax
L256:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    mov       [rbx],	al
    inc       rbx
    xor       eax,	eax
    mov       [rbx],	al
    mov       rax,	2
    add       [rbp + msys.strtostrfmt.n],	rax
    jmp       L253
L254:
    mov       rcx,	rdi
    mov       rdx,	r13
    mov       r8,	[rbp + msys.strtostrfmt.n]
    call      memcpy
L253:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     rax,	byte [rax+8]
    cmp       rax,	97
    jz        L258
    cmp       rax,	65
    jz        L259
    jmp       L260
L258:
    mov       rcx,	rdi
    call      mlib.convlcstring
    jmp       L257
L259:
    mov       rcx,	rdi
    call      mlib.convucstring
L260:
L257:
    mov       r13,	rdi
L249:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    cmp       rsi,	[rbp + msys.strtostrfmt.n]
    jle       L262
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	[rbp + msys.strtostrfmt.n]
    mov       r9,	[rbp + msys.strtostrfmt.fmt]
    call      msys.expandstr
    mov       [rbp + msys.strtostrfmt.n],	rax
    jmp       L261
L262:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.strtostrfmt.n]
    call      memcpy
L261:
    test      r12,	r12
    jz        L264
    mov       rcx,	rdi
    mov       rdx,	r12
    call      mlib.pcm_free
L264:
    mov       rax,	[rbp + msys.strtostrfmt.n]
L247:
;---------------
    add       rsp,	288
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.tostr_i64
msys.tostr_i64:
;?>>
    %define msys.tostr_i64.a 32
   %define R.fmt rbx
    %define msys.tostr_i64.str -360
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       [rbp+32],	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rbx+12]
    test      rax,	rax
    jz        L267
    cmp       rax,	77
    jz        L268
    jmp       L269
L267:
    mov       rcx,	[rbp + msys.tostr_i64.a]
    lea       rdx,	[rbp + msys.tostr_i64.str]
    mov       r8,	rbx
    call      msys.i64tostrfmt
    mov       rdi,	rax
    jmp       L266
L268:
    lea       rcx,	[rbp + msys.tostr_i64.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.tostr_i64.str]
    mov       r9,	rbx
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L266
L269:
    mov       rcx,	[rbp + msys.tostr_i64.a]
    xor       edx,	edx
    call      msys.m$print_c8
    jmp       L265
L266:
    lea       rcx,	[rbp + msys.tostr_i64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
L265:
;---------------
    add       rsp,	400
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.tostr_u64
msys.tostr_u64:
;?>>
    %define msys.tostr_u64.a 32
   %define R.fmt rbx
    %define msys.tostr_u64.str -360
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       [rbp+32],	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rbx+12]
    cmp       rax,	77
    jz        L272
    cmp       rax,	67
    jz        L273
    jmp       L274
L272:
    lea       rcx,	[rbp + msys.tostr_u64.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.tostr_u64.str]
    mov       r9,	rbx
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L271
L273:
    mov       rcx,	[rbp + msys.tostr_u64.a]
    xor       edx,	edx
    call      msys.m$print_c8
    jmp       L270
L274:
    mov       rcx,	[rbp + msys.tostr_u64.a]
    lea       rdx,	[rbp + msys.tostr_u64.str]
    mov       r8,	rbx
    call      msys.u64tostrfmt
    mov       rdi,	rax
L271:
    lea       rcx,	[rbp + msys.tostr_u64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
L270:
;---------------
    add       rsp,	400
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.tostr_r64
msys.tostr_r64:
;?>>
   %define R.x XMM15
   %define R.fmt rbx
    %define msys.tostr_r64.str -360
    %define msys.tostr_r64.str2 -720
    %define msys.tostr_r64.cfmt -736
   %define R.n rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	776
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    mov       al,	37
    mov       [rbp + msys.tostr_r64.cfmt],	al
    mov       al,	[rbx+1]
    test      al,	al
    jz        L277
    mov       al,	46
    mov       [rbp + msys.tostr_r64.cfmt+1],	al
    mov       al,	42
    mov       [rbp + msys.tostr_r64.cfmt+2],	al
    mov       al,	[rbx+5]
    mov       [rbp + msys.tostr_r64.cfmt+3],	al
    xor       eax,	eax
    mov       [rbp + msys.tostr_r64.cfmt+4],	al
    movsx     rax,	byte [rbx+1]
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.cfmt]
    mov       r8,	rax
    movq      XMM3,	XMM15
    movq      r9,	XMM3
    call      sprintf
    jmp       L276
L277:
    mov       al,	[rbx+5]
    mov       [rbp + msys.tostr_r64.cfmt+1],	al
    xor       eax,	eax
    mov       [rbp + msys.tostr_r64.cfmt+2],	al
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.cfmt]
    movq      XMM2,	XMM15
    movq      r8,	XMM2
    call      sprintf
L276:
    lea       rcx,	[rbp + msys.tostr_r64.str]
    call      strlen
    mov       rdi,	rax
    movzx     rax,	byte [rbx]
    mov       r10,	rdi
    cmp       r10,	rax
    jge       L279
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.str2]
    mov       r8,	rdi
    mov       r9,	rbx
    call      msys.expandstr
    mov       rdi,	rax
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.str2]
    call      strcpy
L279:
    lea       rcx,	[rbp + msys.tostr_r64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
;---------------
    add       rsp,	776
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.tostr_str
msys.tostr_str:
;?>>
   %define R.s r12
   %define R.oldlen r13
   %define R.fmt r14
   %define R.newlen rdi
   %define R.n rbx
   %define R.t rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    cmp       r13,	-1
    jnz       L282
    mov       rcx,	r12
    call      strlen
    mov       r13,	rax
L282:
    mov       rdi,	r13
    mov       al,	[r14+3]
    test      al,	al
    jnz       L285
    movzx     rax,	byte [r14]
    cmp       rax,	rdi
    jg        L285
    mov       al,	[r14+8]
    test      al,	al
    jnz       L285
    mov       al,	[r14+1]
    test      al,	al
    jz        L284
L285:
    mov       al,	[r14+3]
    test      al,	al
    jz        L287
    mov       rax,	2
    add       rdi,	rax
L287:
    movzx     rax,	byte [r14]
    cmp       rax,	rdi
    jle       L289
    movzx     rax,	byte [r14]
    mov       rdi,	rax
L289:
    lea       rax,	[rdi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rcx,	r12
    mov       rdx,	rsi
    mov       r8,	r13
    mov       r9,	r14
    call      msys.strtostrfmt
    mov       rbx,	rax
    mov       al,	[r14+1]
    test      al,	al
    jz        L291
    movsx     rax,	byte [r14+1]
    cmp       rbx,	rax
    jle       L12079
    mov       rbx,	rax
L12079:
L291:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      msys.printstr_n
    lea       rax,	[rdi+1]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mlib.pcm_free
    jmp       L283
L284:
    mov       rcx,	r12
    mov       rdx,	r13
    call      msys.printstr_n
L283:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.getfmt
msys.getfmt:
;?>>
   %define R.fmtstyle rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L294
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[msys.getfmt.fmt]
    call      msys.strtofmt
    lea       rax,	[msys.getfmt.fmt]
    jmp       L293
L294:
    lea       rax,	[msys.defaultfmt]
L293:
L292:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.strint
msys.strint:
;?>>
   %define R.a rbx
   %define R.fmtstyle rsi
   %define R.fmt rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rcx,	[msys.strint.str]
    call      msys.m$print_startstr
    mov       rcx,	rsi
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rbx
    mov       rdx,	rax
    call      msys.tostr_i64
    call      msys.m$print_end
    lea       rcx,	[msys.strint.str]
    mov       rdx,	rdi
    call      msys.getstr
L295:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.getstrint
msys.getstrint:
;?>>
   %define R.a rdi
   %define R.dest rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      msys.m$print_startstr
    xor       ecx,	ecx
    call      msys.getfmt
    mov       rcx,	rdi
    mov       rdx,	rax
    call      msys.tostr_i64
    call      msys.m$print_end
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strword
msys.strword:
;?>>
   %define R.a rbx
   %define R.fmtstyle rsi
   %define R.fmt rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rcx,	[msys.strword.str]
    call      msys.m$print_startstr
    mov       rcx,	rsi
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rbx
    mov       rdx,	rax
    call      msys.tostr_u64
    call      msys.m$print_end
    lea       rcx,	[msys.strword.str]
    mov       rdx,	rdi
    call      msys.getstr
L297:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strreal
msys.strreal:
;?>>
   %define R.a XMM15
   %define R.fmtstyle rbx
   %define R.fmt rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    lea       rcx,	[msys.strreal.str]
    call      msys.m$print_startstr
    mov       rcx,	rbx
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    movq      XMM0,	XMM15
    mov       rdx,	rax
    call      msys.tostr_r64
    call      msys.m$print_end
    lea       rcx,	[msys.strreal.str]
    mov       rdx,	rdi
    call      msys.getstr
L298:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.getstr
msys.getstr:
;?>>
   %define R.s rdi
   %define R.fmt rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	[rbx+13]
    test      al,	al
    jz        L301
    mov       rcx,	rdi
    call      mlib.pcm_copyheapstring
    jmp       L300
L301:
    mov       rax,	rdi
L300:
L299:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.initreadbuffer
msys.initreadbuffer:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[msys.rd_buffer]
    test      rax,	rax
    jnz       L302
L304:
    mov       rcx,	16384
    call      mlib.pcm_alloc
    mov       [msys.rd_buffer],	rax
    xor       eax,	eax
    mov       r10,	[msys.rd_buffer]
    mov       [r10],	al
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_lastpos],	rax
    mov       [msys.rd_pos],	rax
L302:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$read_conline
msys.m$read_conline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.initreadbuffer
    xor       ecx,	ecx
    mov       rdx,	[msys.rd_buffer]
    mov       r8,	16384
    call      mlib.readlinen
    mov       rcx,	[msys.rd_buffer]
    call      strlen
    mov       [msys.rd_length],	rax
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$read_fileline
msys.m$read_fileline:
;?>>
   %define R.f rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.initreadbuffer
    cmp       rdi,	1
    jnz       L308
    lea       rcx,	[L12080]
    call      mlib.abortprogram
    jmp       L306
L308:
    mov       rcx,	rdi
    mov       rdx,	[msys.rd_buffer]
    mov       r8,	16384
    call      mlib.readlinen
    mov       rcx,	[msys.rd_buffer]
    call      strlen
    mov       [msys.rd_length],	rax
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
L306:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$read_strline
msys.m$read_strline:
;?>>
   %define R.s rbx
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      msys.initreadbuffer
    mov       rcx,	rbx
    call      strlen
    mov       rdi,	rax
    cmp       rdi,	16384
    jge       L311
    mov       rcx,	[msys.rd_buffer]
    mov       rdx,	rbx
    call      strcpy
    jmp       L310
L311:
    mov       rcx,	[msys.rd_buffer]
    mov       rdx,	rbx
    mov       r8,	16383
    call      memcpy
    mov       rax,	[msys.rd_buffer]
    lea       rax,	[rax+16384]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
L310:
    mov       [msys.rd_length],	rdi
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.readitem
msys.readitem:
;?>>
   %define R.itemlength r14
   %define R.p rdi
   %define R.s rbx
   %define R.itemstr rsi
   %define R.quotechar r12b
   %define R.c r13b
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       rax,	[msys.rd_buffer]
    test      rax,	rax
    jnz       L314
    call      msys.initreadbuffer
L314:
    mov       rbx,	[msys.rd_pos]
    jmp       L316
L315:
    inc       rbx
L316:
    movzx     rax,	byte [rbx]
    cmp       rax,	32
    jz        L315
    movzx     rax,	byte [rbx]
    cmp       rax,	9
    jz        L315
    mov       rsi,	rbx
    mov       rax,	rbx
    mov       [msys.rd_pos],	rax
    mov       [msys.rd_lastpos],	rax
    movzx     rax,	byte [rbx]
    test      rax,	rax
    jnz       L319
    xor       eax,	eax
    mov       [msys.termchar],	rax
    xor       eax,	eax
    mov       [r14],	rax
    mov       rax,	rbx
    jmp       L312
L319:
    xor       r12b,	r12b
    movzx     rax,	byte [rbx]
    cmp       rax,	34
    jnz       L321
    mov       r12b,	34
    inc       rbx
    jmp       L320
L321:
    movzx     rax,	byte [rbx]
    cmp       rax,	39
    jnz       L322
    mov       r12b,	39
    inc       rbx
L322:
L320:
    mov       rax,	rbx
    mov       rsi,	rax
    mov       rdi,	rax
    jmp       L324
L323:
    mov       rax,	rbx
    inc       rbx
    mov       r13b,	[rax]
    movzx     rax,	r13b
    cmp       rax,	32
    jz        L327
    cmp       rax,	9
    jz        L327
    cmp       rax,	44
    jz        L327
    cmp       rax,	61
    jnz       L328
L327:
    test      r12b,	r12b
    jnz       L331
    cmp       rdi,	rbx
    jnz       L330
L331:
    jmp       L332
L330:
    movzx     rax,	r13b
    mov       [msys.termchar],	rax
    jmp       L325
L328:
;msys.readitem.normalchar:
L332:
    movzx     rax,	r13b
    movzx     r10,	r12b
    cmp       rax,	r10
    jnz       L334
    movzx     rax,	byte [rbx]
    movzx     r10,	r12b
    cmp       rax,	r10
    jnz       L336
    mov       [rdi],	r13b
    inc       rbx
    inc       rdi
    jmp       L335
L336:
    movzx     rax,	byte [rbx]
    mov       [msys.termchar],	rax
    mov       rax,	[msys.termchar]
    cmp       rax,	44
    jz        L339
    cmp       rax,	61
    jnz       L338
L339:
    inc       rbx
    movzx     rax,	byte [rbx]
    mov       [msys.termchar],	rax
L338:
    jmp       L325
L335:
    jmp       L333
L334:
    mov       [rdi],	r13b
    inc       rdi
L333:
L326:
L324:
    mov       al,	[rbx]
    test      al,	al
    jnz       L323
L325:
    movzx     rax,	byte [rbx]
    test      rax,	rax
    jnz       L341
    xor       eax,	eax
    mov       [msys.termchar],	rax
L341:
    mov       rax,	rdi
    sub       rax,	rsi
    mov       [r14],	rax
    mov       [msys.rd_pos],	rbx
    mov       rax,	rsi
L312:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strtoint
msys.strtoint:
;?>>
   %define R.s r13
   %define R.length r14
   %define R.base r15
   %define R.signd dil
   %define R.aa rbx
   %define R.c rsi
   %define R.d r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    cmp       r14,	-1
    jnz       L344
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L344:
    xor       dil,	dil
    mov       rax,	r14
    test      rax,	rax
    jz        L346
    movzx     rax,	byte [r13]
    cmp       rax,	45
    jnz       L346
    mov       dil,	1
    inc       r13
    dec       r14
    jmp       L345
L346:
    test      r14,	r14
    jz        L347
    movzx     rax,	byte [r13]
    cmp       rax,	43
    jnz       L347
    inc       r13
    dec       r14
L347:
L345:
    xor       rbx,	rbx
    jmp       L349
L348:
    mov       rax,	r13
    inc       r13
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    dec       r14
    mov       rax,	rsi
    cmp       rax,	65
    jl        L352
    cmp       rax,	70
    jg        L352
    lea       rax,	[rsi-65]
    add       rax,	10
    mov       r12,	rax
    jmp       L351
L352:
    mov       rax,	rsi
    cmp       rax,	97
    jl        L353
    cmp       rax,	102
    jg        L353
    lea       rax,	[rsi-97]
    add       rax,	10
    mov       r12,	rax
    jmp       L351
L353:
    mov       rax,	rsi
    cmp       rax,	48
    jl        L354
    cmp       rax,	57
    jg        L354
    lea       rax,	[rsi-48]
    mov       r12,	rax
    jmp       L351
L354:
    mov       rax,	rsi
    cmp       rax,	95
    jz        L356
    cmp       rax,	39
    jnz       L355
L356:
    jmp       L349
L355:
    mov       rax,	1
    mov       [msys.itemerror],	rax
    jmp       L350
L351:
    cmp       r12,	r15
    jb        L358
    mov       rax,	1
    mov       [msys.itemerror],	rax
    jmp       L350
L358:
    mov       rax,	rbx
    imul      rax,	r15
    add       rax,	r12
    mov       rbx,	rax
L349:
    test      r14,	r14
    jnz       L348
L350:
    test      dil,	dil
    jz        L360
    mov       rax,	rbx
    neg       rax
    jmp       L359
L360:
    mov       rax,	rbx
L359:
L342:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$read_i64
msys.m$read_i64:
;?>>
   %define R.fmt rbx
   %define R.s rdi
    %define msys.m$read_i64.length -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      toupper
    movsxd    r10,	eax
    mov       rbx,	r10
    mov       rax,	rbx
    cmp       rax,	67
    jz        L363
    cmp       rax,	84
    jz        L364
    cmp       rax,	69
    jz        L365
    jmp       L366
L363:
    mov       rax,	[msys.rd_pos]
    mov       [msys.rd_lastpos],	rax
    mov       rax,	[msys.rd_pos]
    mov       al,	[rax]
    test      al,	al
    jz        L368
    mov       rax,	[msys.rd_pos]
    inc       qword [msys.rd_pos]
    movzx     rax,	byte [rax]
    jmp       L361
L368:
    xor       eax,	eax
    jmp       L361
L367:
    jmp       L362
L364:
    mov       rax,	[msys.termchar]
    jmp       L361
L365:
    mov       rax,	[msys.itemerror]
    jmp       L361
L366:
L362:
    lea       rcx,	[rbp + msys.m$read_i64.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	rbx
    test      rax,	rax
    jz        L370
    cmp       rax,	73
    jz        L370
    cmp       rax,	66
    jz        L371
    cmp       rax,	72
    jz        L372
    jmp       L373
L370:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	10
    call      msys.strtoint
    jmp       L361
L371:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	2
    call      msys.strtoint
    jmp       L361
L372:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	16
    call      msys.strtoint
    jmp       L361
L373:
L369:
    xor       eax,	eax
L361:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$read_r64
msys.m$read_r64:
;?>>
    %define msys.m$read_r64.fmt 24
    %define msys.m$read_r64.str -512
   %define R.s rdi
    %define msys.m$read_r64.length -520
    %define msys.m$read_r64.numlength -528
    %define msys.m$read_r64.x -536
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	568
;---------------
    lea       rcx,	[rbp + msys.m$read_r64.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	[rbp + msys.m$read_r64.length]
    test      rax,	rax
    jz        L377
    mov       rax,	[rbp + msys.m$read_r64.length]
    cmp       rax,	512
    jl        L376
L377:
    movq      XMM0,	[L12081]
    jmp       L374
L376:
    lea       rcx,	[rbp + msys.m$read_r64.str]
    mov       rdx,	rdi
    mov       r8,	[rbp + msys.m$read_r64.length]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.m$read_r64.length]
    mov       [rbp + r10 + msys.m$read_r64.str],	al
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    lea       rcx,	[rbp + msys.m$read_r64.str]
    lea       rdx,	[L12082]
    lea       r8,	[rbp + msys.m$read_r64.x]
    lea       r9,	[rbp + msys.m$read_r64.numlength]
    call      sscanf
    movsxd    r10,	eax
    test      r10,	r10
    jz        L380
    movsxd    rax,	dword [rbp + msys.m$read_r64.numlength]
    cmp       rax,	[rbp + msys.m$read_r64.length]
    jz        L379
L380:
    movq      XMM4,	[L12083]
    movq      [rbp + msys.m$read_r64.x],	XMM4
    mov       rax,	1
    mov       [msys.itemerror],	rax
L379:
    movq      XMM0,	[rbp + msys.m$read_r64.x]
L374:
;---------------
    add       rsp,	568
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc msys.m$read_str
msys.m$read_str:
;?>>
   %define R.dest rbx
   %define R.destlen rsi
   %define R.fmt r12
   %define R.s rdi
    %define msys.m$read_str.length -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    mov       rax,	r12
    cmp       rax,	76
    jz        L384
    cmp       rax,	108
    jnz       L383
L384:
    mov       rdi,	[msys.rd_pos]
    mov       rax,	[msys.rd_buffer]
    mov       r10,	[msys.rd_length]
    lea       rax,	[rax + r10]
    sub       rax,	[msys.rd_pos]
    mov       [rbp + msys.m$read_str.length],	rax
    jmp       L382
L383:
    lea       rcx,	[rbp + msys.m$read_str.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	r12
    cmp       rax,	78
    jz        L387
    cmp       rax,	110
    jnz       L386
L387:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_str.length]
    call      mlib.iconvlcn
L386:
L382:
    cmp       rsi,	0
    jle       L389
    mov       rax,	[rbp + msys.m$read_str.length]
    cmp       rax,	rsi
    jl        L391
    lea       rax,	[rsi-1]
    mov       [rbp + msys.m$read_str.length],	rax
    mov       rax,	1
    mov       [msys.itemerror],	rax
L391:
L389:
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	[rbp + msys.m$read_str.length]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.m$read_str.length]
    mov       [rbx + r10],	al
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.readstr
msys.readstr:
;?>>
   %define R.dest rdi
   %define R.fmt rbx
   %define R.destlen rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	rbx
    call      msys.m$read_str
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.rereadln
msys.rereadln:
;?>>
;?]]
;---------------
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    mov       rax,	[msys.rd_pos]
    mov       [msys.rd_lastpos],	rax
;---------------
    ret       
;End 
;Proc msys.reread
msys.reread:
;?>>
;?]]
;---------------
    mov       rax,	[msys.rd_lastpos]
    mov       [msys.rd_pos],	rax
;---------------
    ret       
;End 
;Proc msys.valint
msys.valint:
;?>>
   %define R.s r12
   %define R.fmt r13
   %define R.old_pos rdi
   %define R.old_lastpos rbx
   %define R.aa rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    call      msys.initreadbuffer
    mov       rdi,	[msys.rd_pos]
    mov       rbx,	[msys.rd_lastpos]
    mov       [msys.rd_pos],	r12
    mov       rcx,	r13
    call      msys.m$read_i64
    mov       rsi,	rax
    mov       [msys.rd_pos],	rdi
    mov       [msys.rd_lastpos],	rbx
    mov       rax,	rsi
L395:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.valreal
msys.valreal:
;?>>
   %define R.s rsi
   %define R.old_pos rdi
   %define R.old_lastpos rbx
   %define R.x XMM15
    push      rdi
    push      rbx
    push      rsi
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
;---------------
    call      msys.initreadbuffer
    mov       rdi,	[msys.rd_pos]
    mov       rbx,	[msys.rd_lastpos]
    mov       [msys.rd_pos],	rsi
    xor       ecx,	ecx
    call      msys.m$read_r64
    movq      XMM15,	XMM0
    mov       [msys.rd_pos],	rdi
    mov       [msys.rd_lastpos],	rbx
    movq      XMM0,	XMM15
L396:
;---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.mclunimpl
msys.mclunimpl:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    lea       rcx,	[L12084]
    mov       rdx,	rdi
    call      printf
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.dumpstr
msys.dumpstr:
;?>>
   %define R.s rbx
   %define R.n rsi
   %define R.fbuffer r12
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rax,	[msys.outdev]
    cmp       rax,	3
    jnz       L400
    mov       rdi,	[msys.outchan]
    test      rsi,	rsi
    jz        L402
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rdi
    mov       r10,	rsi
    add       [rax],	r10
L402:
    mov       rax,	[rdi]
    xor       r10d,	r10d
    mov       [rax],	r10b
    jmp       L398
L400:
    test      rsi,	rsi
    jnz       L404
    jmp       L398
L404:
    test      r12,	r12
    jz        L406
    cmp       rsi,	2
    jl        L406
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jnz       L406
    dec       qword [msys.printptr]
    mov       rax,	[msys.printptr]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L408
    mov       rax,	[msys.printptr]
    sub       rax,	1
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jnz       L410
    mov       rax,	[msys.printptr]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
    jmp       L409
L410:
    xor       eax,	eax
    mov       r10,	[msys.printptr]
    mov       [r10],	al
L409:
    lea       rcx,	[msys.printbuffer]
    call      puts
    jmp       L398
L408:
L406:
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jz        L412
    cmp       rax,	2
    jz        L413
    jmp       L414
L412:
    lea       rcx,	[L12085]
    mov       rdx,	rsi
    mov       r8,	rbx
    call      printf
    jmp       L411
L413:
    mov       rcx,	[msys.outchan]
    lea       rdx,	[L12085]
    mov       r8,	rsi
    mov       r9,	rbx
    call      fprintf
L414:
L411:
L398:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.dumpprintbuffer
msys.dumpprintbuffer:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[msys.printlen]
    test      rax,	rax
    jz        L417
    lea       rcx,	[msys.printbuffer]
    mov       rdx,	[msys.printlen]
    mov       r8,	1
    call      msys.dumpstr
L417:
    call      msys.resetprintbuffer
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.resetprintbuffer
msys.resetprintbuffer:
;?>>
;?]]
;---------------
    lea       rax,	[msys.printbuffer]
    mov       [msys.printptr],	rax
    xor       eax,	eax
    mov       [msys.printlen],	rax
;---------------
    ret       
;End 
;Proc msys.addtobuffer
msys.addtobuffer:
;?>>
   %define R.s rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	[msys.printlen]
    add       rax,	rbx
    cmp       rax,	4088
    jl        L421
    call      msys.dumpprintbuffer
L421:
    cmp       rbx,	4096
    jge       L423
    mov       rcx,	[msys.printptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [msys.printptr],	rax
    mov       rax,	rbx
    add       [msys.printlen],	rax
    jmp       L419
L423:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      msys.dumpstr
L419:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$power_i64
msys.m$power_i64:
;?>>
   %define R.a rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    cmp       rbx,	0
    jge       L426
    xor       eax,	eax
    jmp       L425
L426:
    test      rbx,	rbx
    jnz       L427
    mov       rax,	1
    jmp       L425
L427:
    cmp       rbx,	1
    jnz       L428
    mov       rax,	rdi
    jmp       L425
L428:
    mov       rax,	rbx
    and       rax,	1
    jnz       L429
    mov       rax,	rbx
    sar       rax,	1
    mov       r10,	rdi
    imul      r10,	r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      msys.m$power_i64
    jmp       L425
L429:
    lea       rax,	[rbx-1]
    sar       rax,	1
    mov       r10,	rdi
    imul      r10,	r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      msys.m$power_i64
    imul      rax,	rdi
L425:
L424:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.getutfsize
msys.getutfsize:
;?>>
   %define R.s rcx
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L432
    xor       eax,	eax
    jmp       L431
L432:
    mov       eax,	edi
    shr       eax,	7
    and       eax,	1
    test      rax,	rax
    jnz       L433
    mov       rax,	1
    jmp       L431
L433:
    mov       rax,	rdi
    shr       rax,	5
    and       rax,	7
    cmp       rax,	6
    jnz       L434
    mov       rax,	2
    jmp       L431
L434:
    mov       rax,	rdi
    shr       rax,	4
    and       rax,	15
    cmp       rax,	14
    jnz       L435
    mov       rax,	3
    jmp       L431
L435:
    mov       rax,	rdi
    shr       rax,	3
    and       rax,	31
    cmp       rax,	30
    jnz       L436
    mov       rax,	4
    jmp       L431
L436:
    mov       rax,	1
L431:
L430:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc msys.m$sign_i64
msys.m$sign_i64:
;?>>
   %define R.a rcx
;?]]
;---------------
    cmp       rcx,	0
    jge       L439
    mov       rax,	-1
    jmp       L438
L439:
    cmp       rcx,	0
    jle       L441
    mov       rax,	1
    jmp       L440
L441:
    xor       eax,	eax
L440:
L438:
L437:
;---------------
    ret       
;End 
;Proc msys.m$sign_r64
msys.m$sign_r64:
;?>>
   %define R.x XMM0
;?]]
;---------------
    movq      XMM4,	XMM0
    comisd    XMM4,	[L12086]
    jae       L444
    movq      XMM0,	[L12087]
    jmp       L442
L444:
    movq      XMM4,	XMM0
    comisd    XMM4,	[L12088]
    jbe       L446
    movq      XMM0,	[L12089]
    jmp       L442
L446:
    movq      XMM0,	[L12090]
L442:
;---------------
    ret       
;End 
;Proc mlib.pcm_alloc
mlib.pcm_alloc:
;?>>
   %define R.n rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       al,	[mlib.pcm_setup]
    test      al,	al
    jnz       L449
    call      mlib.pcm_init
L449:
    cmp       rbx,	2048
    jle       L451
    mov       rcx,	rbx
    call      mlib.pcm_getac
    mov       [mlib.alloccode],	rax
    lea       rax,	[mlib.allocupper]
    mov       r10,	[mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       [mlib.allocbytes],	rax
    mov       rcx,	[mlib.allocbytes]
    call      mlib.allocmem
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L453
    lea       rcx,	[L12091]
    call      mlib.abortprogram
L453:
    mov       rax,	rdi
    jmp       L447
L451:
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10]
    mov       [mlib.alloccode],	rax
    lea       rax,	[mlib.allocupper]
    mov       r10,	[mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       [mlib.allocbytes],	rax
    lea       rax,	[mlib.freelist]
    mov       r10,	[mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       rdi,	rax
    test      rax,	rax
    jz        L455
    lea       rax,	[mlib.freelist]
    mov       r10,	[mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    lea       r10,	[mlib.freelist]
    mov       r11,	[mlib.alloccode]
    mov       [r10 + r11*8],	rax
    mov       rax,	rdi
    jmp       L447
L455:
    mov       rdi,	[mlib.pcheapptr]
    mov       rax,	[mlib.allocbytes]
    add       [mlib.pcheapptr],	rax
    mov       rax,	[mlib.pcheapptr]
    cmp       rax,	[mlib.pcheapend]
    jb        L457
    mov       rcx,	[mlib.allocbytes]
    call      mlib.pcm_newblock
    mov       rdi,	rax
    mov       rax,	rdi
    jmp       L447
L457:
    mov       rax,	rdi
L447:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_free
mlib.pcm_free:
;?>>
   %define R.p rbx
   %define R.n rsi
   %define R.acode rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rsi,	rsi
    jz        L461
    test      rbx,	rbx
    jnz       L460
L461:
    jmp       L458
L460:
    cmp       rsi,	2048
    jle       L463
    mov       rcx,	rbx
    call      free
    jmp       L462
L463:
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rdi,	rax
    lea       rax,	[mlib.freelist]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rbx],	rax
    mov       rax,	rbx
    lea       r10,	[mlib.freelist]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
L462:
L458:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_freeac
mlib.pcm_freeac:
;?>>
   %define R.p rdi
   %define R.alloc rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[mlib.allocupper]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.pcm_free
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_clearmem
mlib.pcm_clearmem:
;?>>
   %define R.p rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    call      memset
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_init
mlib.pcm_init:
;?>>
   %define R.j rdi
   %define R.k rbx
   %define R.size rsi
   %define R.av_1 r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    xor       eax,	eax
    mov       [mlib.alloccode],	rax
    mov       al,	[mlib.pcm_setup]
    test      al,	al
    jnz       L466
L468:
    xor       ecx,	ecx
    call      mlib.pcm_newblock
    mov       r13,	1
L469:
    mov       rdi,	1
    mov       rbx,	16
    jmp       L473
L472:
    mov       rax,	rbx
    shl       rax,	1
    mov       rbx,	rax
    inc       rdi
L473:
    cmp       r13,	rbx
    jg        L472
    mov       al,	dil
    lea       r10,	[mlib.sizeindextable]
    mov       r11,	r13
    mov       [r10 + r11],	al
    inc       r13
    cmp       r13,	2048
    jle       L469
    mov       rax,	16
    lea       r10,	[mlib.allocupper]
    mov       [r10+8],	rax
    mov       rsi,	16
    mov       r13,	2
L475:
    mov       rax,	rsi
    shl       rax,	1
    mov       rsi,	rax
    mov       rax,	rsi
    lea       r10,	[mlib.allocupper]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    cmp       rsi,	33554432
    jl        L479
    mov       rbx,	r13
    jmp       L477
L479:
    inc       r13
    cmp       r13,	27
    jle       L475
L477:
    lea       rax,	[rbx+1]
    mov       r13,	rax
    mov       r12,	300
    cmp       r13,	r12
    jg        L482
L480:
    mov       rax,	33554432
    add       rsi,	rax
    mov       rax,	rsi
    mov       r10,	8589934592
    cmp       rax,	r10
    jge       L484
    mov       rax,	rsi
    lea       r10,	[mlib.allocupper]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    mov       [mlib.maxmemory],	rsi
    jmp       L483
L484:
    lea       rax,	[r13-1]
    mov       [mlib.maxalloccode],	rax
    jmp       L482
L483:
    inc       r13
    cmp       r13,	r12
    jle       L480
L482:
    mov       al,	1
    mov       [mlib.pcm_setup],	al
L466:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_getac
mlib.pcm_getac:
;?>>
   %define R.size rcx
;?]]
;---------------
    cmp       rcx,	2048
    jg        L487
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    jmp       L485
L487:
    lea       rax,	[rcx+255]
    sar       rax,	8
    mov       rcx,	rax
    cmp       rcx,	2048
    jg        L489
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    add       rax,	8
    jmp       L485
L489:
    lea       rax,	[rcx+63]
    sar       rax,	6
    mov       rcx,	rax
    cmp       rcx,	2048
    jg        L491
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    add       rax,	14
    jmp       L485
L491:
    lea       rax,	[rcx-2048]
    add       rax,	2047
    sar       rax,	11
    add       rax,	22
    mov       rcx,	rax
    mov       rax,	rcx
L485:
;---------------
    ret       
;End 
;Proc mlib.pcm_newblock
mlib.pcm_newblock:
;?>>
   %define R.itemsize rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	2097152
    add       [mlib.pcm_newblock.totalheapsize],	rax
    xor       eax,	eax
    mov       [mlib.alloccode],	rax
    mov       rcx,	2097152
    call      mlib.allocmem
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L494
    lea       rcx,	[L12092]
    call      mlib.abortprogram
L494:
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	2097152
    call      memset
    mov       [mlib.pcheapptr],	rdi
    lea       rax,	[rdi+2097152]
    mov       [mlib.pcheapend],	rax
    mov       rax,	[mlib.pcheapstart]
    test      rax,	rax
    jnz       L496
    mov       [mlib.pcheapstart],	rdi
L496:
    mov       rax,	rbx
    add       [mlib.pcheapptr],	rax
    mov       rax,	rdi
L492:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_round
mlib.pcm_round:
;?>>
   %define R.n rcx
;?]]
;---------------
    cmp       rcx,	2048
    jle       L499
    mov       rax,	rcx
    jmp       L498
L499:
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    lea       r10,	[mlib.pcm_round.allocbytes]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rax,	r10
L498:
L497:
;---------------
    ret       
;End 
;Proc mlib.pcm_allocz
mlib.pcm_allocz:
;?>>
   %define R.n rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    call      memset
    mov       rax,	rdi
L500:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_copyheapstring
mlib.pcm_copyheapstring:
;?>>
   %define R.s rsi
   %define R.q rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    test      rsi,	rsi
    jnz       L503
    xor       eax,	eax
    jmp       L501
L503:
    mov       rcx,	rsi
    call      strlen
    inc       rax
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rdi
L501:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_copyheapstringn
mlib.pcm_copyheapstringn:
;?>>
   %define R.s rbx
   %define R.n rsi
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rbx,	rbx
    jnz       L506
    xor       eax,	eax
    jmp       L504
L506:
    lea       rax,	[rsi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    xor       eax,	eax
    mov       [rdi + rsi],	al
    mov       rax,	rdi
L504:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_copyheapblock
mlib.pcm_copyheapblock:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rsi,	rsi
    jnz       L509
    xor       eax,	eax
    jmp       L507
L509:
    mov       rcx,	rsi
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rdi
L507:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.allocmem
mlib.allocmem:
;?>>
   %define R.n rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      malloc
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L512
    mov       rax,	rdi
    jmp       L510
L512:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    mov       rcx,	[mlib.memtotal]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12093]
    call      mlib.abortprogram
    xor       eax,	eax
L510:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.reallocmem
mlib.reallocmem:
;?>>
   %define R.p rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      realloc
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L515
    mov       rax,	rdi
    jmp       L513
L515:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12094]
    call      mlib.abortprogram
    xor       eax,	eax
L513:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.abortprogram
mlib.abortprogram:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12095]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	5
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.getfilesize
mlib.getfilesize:
;?>>
   %define R.handlex rsi
   %define R.p edi
   %define R.size ebx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      ftell
    mov       edi,	eax
    mov       rcx,	rsi
    xor       edx,	edx
    mov       r8,	2
    call      fseek
    mov       rcx,	rsi
    call      ftell
    mov       ebx,	eax
    mov       eax,	edi
    mov       rcx,	rsi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      fseek
    mov       eax,	ebx
L517:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.readrandom
mlib.readrandom:
;?>>
   %define R.handlex rbx
   %define R.memx rsi
   %define R.offset r12
   %define R.size r13
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	rbx
    mov       rdx,	r12
    xor       r8d,	r8d
    call      fseek
    mov       rcx,	rsi
    mov       rdx,	1
    mov       r8,	r13
    mov       r9,	rbx
    call      fread
    mov       rdi,	rax
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.writerandom
mlib.writerandom:
;?>>
   %define R.handlex rdi
   %define R.memx rbx
   %define R.offset rsi
   %define R.size r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rcx,	rdi
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      fseek
    mov       rcx,	rbx
    mov       rdx,	1
    mov       r8,	r12
    mov       r9,	rdi
    call      fwrite
L519:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.setfilepos
mlib.setfilepos:
;?>>
   %define R.file rdi
   %define R.offset rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      fseek
    movsxd    r10,	eax
    mov       rax,	r10
L520:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.getfilepos
mlib.getfilepos:
;?>>
   %define R.file rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      ftell
    movsxd    r10,	eax
    mov       rax,	r10
L521:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.readfile
mlib.readfile:
;?>>
   %define R.filename r13
   %define R.f rdi
   %define R.size rbx
   %define R.m rsi
   %define R.p r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    lea       rdx,	[L12096]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L524
    xor       eax,	eax
    jmp       L522
L524:
    mov       rcx,	rdi
    call      mlib.getfilesize
    mov       rbx,	rax
    mov       [mlib.rfsize],	rax
    lea       rax,	[rbx+2]
    mov       rcx,	rax
    call      malloc
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L526
    xor       eax,	eax
    jmp       L522
L526:
    mov       rcx,	rdi
    mov       rdx,	rsi
    xor       r8d,	r8d
    mov       r9,	rbx
    call      mlib.readrandom
    lea       rax,	[rsi + rbx]
    mov       r12,	rax
    xor       eax,	eax
    mov       [r12],	ax
    mov       rcx,	rdi
    call      fclose
    mov       rax,	rsi
L522:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.writefile
mlib.writefile:
;?>>
   %define R.filename rsi
   %define R.data r12
   %define R.size r13
   %define R.f rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	rsi
    lea       rdx,	[L12097]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L529
    xor       eax,	eax
    jmp       L527
L529:
    mov       rcx,	rdi
    mov       rdx,	r12
    xor       r8d,	r8d
    mov       r9,	r13
    call      mlib.writerandom
    mov       rbx,	rax
    mov       rcx,	rdi
    call      fclose
    mov       rax,	rbx
L527:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.checkfile
mlib.checkfile:
;?>>
   %define R.file rbx
   %define R.f rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    lea       rdx,	[L12098]
    call      fopen
    mov       rdi,	rax
    test      rax,	rax
    jz        L532
    mov       rcx,	rdi
    call      fclose
    mov       rax,	1
    jmp       L530
L532:
    xor       eax,	eax
L530:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.readlinen
mlib.readlinen:
;?>>
   %define R.handlex r13
   %define R.buffer r14
   %define R.size r15
   %define R.ch rdi
   %define R.p rbx
   %define R.n rsi
   %define R.crseen r12b
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    test      r13,	r13
    jnz       L535
    call      mwindows.os_getstdin
    mov       r13,	rax
L535:
    test      r13,	r13
    jnz       L537
    xor       rsi,	rsi
    mov       rax,	r14
    mov       rbx,	rax
L538:
    call      getchar
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       rdi,	13
    jz        L542
    cmp       rdi,	10
    jz        L542
    cmp       rdi,	-1
    jnz       L541
L542:
    xor       eax,	eax
    mov       [rbx],	al
    jmp       L533
L541:
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    inc       rsi
    lea       rax,	[r15-2]
    mov       r10,	rsi
    cmp       r10,	rax
    jl        L544
    xor       eax,	eax
    mov       [rbx],	al
    jmp       L533
L544:
    jmp       L538
L537:
    xor       eax,	eax
    mov       [r14],	al
    lea       rax,	[r15-2]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	r13
    call      fgets
    test      rax,	rax
    jz        L533
L546:
    mov       rcx,	r14
    call      strlen
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L548
    jmp       L533
L548:
    lea       rax,	[r14 + rsi]
    sub       rax,	1
    mov       rbx,	rax
    xor       r12b,	r12b
    jmp       L550
L549:
    movzx     rax,	byte [rbx]
    cmp       rax,	13
    jz        L554
    movzx     rax,	byte [rbx]
    cmp       rax,	10
    jnz       L553
L554:
    mov       r12b,	1
L553:
    mov       rax,	rbx
    dec       rbx
    xor       r10d,	r10d
    mov       [rax],	r10b
L550:
    cmp       rbx,	r14
    jb        L555
    movzx     rax,	byte [rbx]
    cmp       rax,	13
    jz        L549
    movzx     rax,	byte [rbx]
    cmp       rax,	10
    jz        L549
L555:
    test      r12b,	r12b
    jnz       L557
    lea       rax,	[rsi+4]
    cmp       rax,	r15
    jle       L557
    call      msys.m$print_startcon
    mov       rcx,	r15
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12099]
    call      mlib.abortprogram
L557:
L533:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.iconvlcn
mlib.iconvlcn:
;?>>
   %define R.s rbx
   %define R.n rsi
   %define R.av_1 rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	rsi
    cmp       rdi,	0
    jle       L561
L559:
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      tolower
    mov       [rbx],	al
    inc       rbx
    dec       rdi
    jnz       L559
L561:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.iconvucn
mlib.iconvucn:
;?>>
   %define R.s rbx
   %define R.n rsi
   %define R.av_1 rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	rsi
    cmp       rdi,	0
    jle       L565
L563:
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      toupper
    mov       [rbx],	al
    inc       rbx
    dec       rdi
    jnz       L563
L565:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.convlcstring
mlib.convlcstring:
;?>>
   %define R.s rbx
   %define R.s0 rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	rbx
    jmp       L568
L567:
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      tolower
    mov       [rbx],	al
    inc       rbx
L568:
    mov       al,	[rbx]
    test      al,	al
    jnz       L567
    mov       rax,	rdi
L566:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.convucstring
mlib.convucstring:
;?>>
   %define R.s rbx
   %define R.s0 rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	rbx
    jmp       L572
L571:
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      toupper
    mov       [rbx],	al
    inc       rbx
L572:
    mov       al,	[rbx]
    test      al,	al
    jnz       L571
    mov       rax,	rdi
L570:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.changeext
mlib.changeext:
;?>>
   %define R.s rsi
   %define R.newext r12
    %define mlib.changeext.newext2 -32
   %define R.sext rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mlib.changeext.newfile]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      strcpy
    movzx     rax,	byte [r12]
    test      rax,	rax
    jz        L576
    cmp       rax,	46
    jz        L577
    jmp       L578
L576:
    xor       eax,	eax
    mov       [rbp + mlib.changeext.newext2],	al
    xor       eax,	eax
    mov       [rbp + mlib.changeext.newext2+1],	al
    jmp       L575
L577:
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    mov       rdx,	r12
    call      strcpy
    jmp       L575
L578:
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    lea       rdx,	[L12100]
    call      strcpy
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    mov       rdx,	r12
    call      strcat
L575:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mlib.extractext
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jz        L580
    cmp       rax,	46
    jz        L581
    jmp       L582
L580:
    lea       rax,	[rbp + mlib.changeext.newext2]
    lea       r10,	[mlib.changeext.newfile]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcat
    jmp       L579
L581:
    lea       rax,	[rbp + mlib.changeext.newext2+1]
    lea       r10,	[mlib.changeext.newfile]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcat
    jmp       L579
L582:
    mov       rax,	rdi
    sub       rax,	rsi
    sub       rax,	2
    mov       rbx,	rax
    lea       rax,	[rbp + mlib.changeext.newext2]
    lea       r10,	[mlib.changeext.newfile]
    mov       r11,	rbx
    lea       r10,	[r10 + r11+1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcpy
L579:
    lea       rax,	[mlib.changeext.newfile]
L574:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.extractext
mlib.extractext:
;?>>
   %define R.s rsi
   %define R.period r12
   %define R.t rdi
   %define R.u rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	rsi
    call      mlib.extractfile
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jnz       L585
    lea       rax,	[L12101]
    jmp       L583
L585:
    mov       rcx,	rdi
    call      strlen
    lea       r10,	[rdi + rax]
    sub       r10,	1
    mov       rbx,	r10
    jmp       L587
L586:
    movzx     rax,	byte [rbx]
    cmp       rax,	46
    jnz       L590
    movzx     rax,	byte [rbx+1]
    test      rax,	rax
    jnz       L592
    test      r12,	r12
    jz        L594
    lea       rax,	[L12102]
    jmp       L593
L594:
    lea       rax,	[L12103]
L593:
    jmp       L583
L592:
    lea       rax,	[rbx+1]
    jmp       L583
L590:
    dec       rbx
L587:
    cmp       rbx,	rdi
    jae       L586
    lea       rax,	[L12103]
L583:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.extractpath
mlib.extractpath:
;?>>
   %define R.s rsi
   %define R.t rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      strlen
    lea       r10,	[rsi + rax]
    sub       r10,	1
    mov       rdi,	r10
    jmp       L597
L596:
    movzx     rax,	byte [rdi]
    cmp       rax,	92
    jz        L600
    cmp       rax,	47
    jz        L600
    cmp       rax,	58
    jnz       L601
L600:
    mov       rax,	rdi
    sub       rax,	rsi
    inc       rax
    mov       rbx,	rax
    lea       rcx,	[mlib.extractpath.str]
    mov       rdx,	rsi
    mov       r8,	rbx
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractpath.str]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    lea       rax,	[mlib.extractpath.str]
    jmp       L595
L601:
L599:
    dec       rdi
L597:
    cmp       rdi,	rsi
    jae       L596
    lea       rax,	[L12103]
L595:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.extractfile
mlib.extractfile:
;?>>
   %define R.s rbx
   %define R.t rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mlib.extractpath
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jnz       L604
    mov       rax,	rbx
    jmp       L602
L604:
    mov       rcx,	rdi
    call      strlen
    lea       r10,	[rbx + rax]
    mov       rax,	r10
L602:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.extractbasefile
mlib.extractbasefile:
;?>>
   %define R.s r13
   %define R.f rdi
   %define R.e rbx
   %define R.n rsi
   %define R.flen r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mlib.extractfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      strlen
    mov       r12,	rax
    test      r12,	r12
    jnz       L607
    lea       rax,	[L12103]
    jmp       L605
L607:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mlib.extractext
    mov       rbx,	rax
    mov       al,	[rbx]
    test      al,	al
    jz        L609
    mov       rcx,	rbx
    call      strlen
    mov       r10,	r12
    sub       r10,	rax
    dec       r10
    mov       rsi,	r10
    lea       rcx,	[mlib.extractbasefile.str]
    mov       rdx,	rdi
    mov       r8,	rsi
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractbasefile.str]
    mov       r11,	rsi
    mov       [r10 + r11],	al
    lea       rax,	[mlib.extractbasefile.str]
    jmp       L605
L609:
    lea       rax,	[rdi + r12]
    sub       rax,	1
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jnz       L611
    lea       rax,	[r12-1]
    lea       rcx,	[mlib.extractbasefile.str]
    mov       rdx,	rdi
    mov       r8,	rax
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractbasefile.str]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    lea       rax,	[mlib.extractbasefile.str]
    jmp       L605
L611:
    mov       rax,	rdi
L605:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.addext
mlib.addext:
;?>>
   %define R.s rbx
   %define R.newext rsi
   %define R.sext rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mlib.extractext
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jnz       L614
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mlib.changeext
    jmp       L612
L614:
    mov       rax,	rbx
L612:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_alloc32
mlib.pcm_alloc32:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	32
    mov       [mlib.allocbytes],	rax
    lea       rax,	[mlib.freelist]
    mov       rax,	[rax+16]
    mov       rdi,	rax
    test      rax,	rax
    jz        L617
    lea       rax,	[mlib.freelist]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    lea       r10,	[mlib.freelist]
    mov       [r10+16],	rax
    mov       rax,	rdi
    jmp       L615
L617:
    mov       rcx,	32
    call      mlib.pcm_alloc
L615:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_free32
mlib.pcm_free32:
;?>>
   %define R.p rcx
;?]]
;---------------
    lea       rax,	[mlib.freelist]
    mov       rax,	[rax+16]
    mov       [rcx],	rax
    mov       rax,	rcx
    lea       r10,	[mlib.freelist]
    mov       [r10+16],	rax
;---------------
    ret       
;End 
;Proc mlib.outbyte
mlib.outbyte:
;?>>
   %define R.f rdi
    %define mlib.outbyte.x 32
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outbyte.x]
    mov       rdx,	1
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mlib.outu16
mlib.outu16:
;?>>
   %define R.f rdi
    %define mlib.outu16.x 32
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outu16.x]
    mov       rdx,	2
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mlib.outu32
mlib.outu32:
;?>>
   %define R.f rdi
    %define mlib.outu32.x 32
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outu32.x]
    mov       rdx,	4
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mlib.outu64
mlib.outu64:
;?>>
   %define R.f rdi
    %define mlib.outu64.x 32
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outu64.x]
    mov       rdx,	8
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mlib.outstring
mlib.outstring:
;?>>
   %define R.f rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      strlen
    inc       rax
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.outblock
mlib.outblock:
;?>>
   %define R.f rdi
   %define R.p rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.myeof
mlib.myeof:
;?>>
   %define R.f rbx
   %define R.c rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      fgetc
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       rdi,	-1
    jnz       L627
    mov       rax,	1
    jmp       L625
L627:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      ungetc
    xor       eax,	eax
L625:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.strbuffer_add
mlib.strbuffer_add:
;?>>
   %define R.dest r12
   %define R.s r13
   %define R.n r14
   %define R.newlen rdi
   %define R.oldlen rbx
   %define R.newptr rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    cmp       r14,	-1
    jnz       L630
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L630:
    movsxd    rax,	dword [r12+8]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L632
    lea       rax,	[r14+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r12],	rax
    mov       eax,	[mlib.allocbytes]
    mov       [r12+12],	eax
    mov       [r12+8],	r14d
    mov       rax,	[r12]
    mov       rcx,	rax
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    mov       rax,	[r12]
    xor       r10d,	r10d
    mov       r11,	r14
    mov       [rax + r11],	r10b
    jmp       L628
L632:
    mov       rax,	rbx
    add       rax,	r14
    mov       rdi,	rax
    lea       rax,	[rdi+1]
    movsxd    r10,	dword [r12+12]
    cmp       rax,	r10
    jle       L634
    lea       rax,	[rdi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    mov       [r12],	rsi
    mov       eax,	[mlib.allocbytes]
    mov       [r12+12],	eax
L634:
    mov       rax,	[r12]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    mov       rax,	[r12]
    xor       r10d,	r10d
    mov       r11,	rdi
    mov       [rax + r11],	r10b
    mov       [r12+8],	edi
L628:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_init
mlib.gs_init:
;?>>
   %define R.dest rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	16
    call      mlib.pcm_clearmem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.gs_free
mlib.gs_free:
;?>>
   %define R.dest rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       eax,	[rdi+12]
    test      eax,	eax
    jz        L638
    movsxd    rax,	dword [rdi+12]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.pcm_free
L638:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.gs_str
mlib.gs_str:
;?>>
   %define R.dest rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_char
mlib.gs_char:
;?>>
   %define R.dest rdi
   %define R.c rbx
    %define mlib.gs_char.s -16
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       [rbp + mlib.gs_char.s],	bl
    xor       eax,	eax
    mov       [rbp + mlib.gs_char.s+1],	al
    mov       rcx,	rdi
    lea       rdx,	[rbp + mlib.gs_char.s]
    mov       r8,	1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strn
mlib.gs_strn:
;?>>
   %define R.dest rdi
   %define R.s rbx
   %define R.length rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mlib.strbuffer_add
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strvar
mlib.gs_strvar:
;?>>
   %define R.dest rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	[rbx]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strint
mlib.gs_strint:
;?>>
   %define R.dest rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strln
mlib.gs_strln:
;?>>
   %define R.dest rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_str
    mov       rcx,	rdi
    call      mlib.gs_line
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strsp
mlib.gs_strsp:
;?>>
   %define R.dest rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12104]
    call      mlib.gs_str
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_line
mlib.gs_line:
;?>>
   %define R.dest rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12105]
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.gs_getcol
mlib.gs_getcol:
;?>>
   %define R.dest rcx
;?]]
;---------------
    movsxd    rax,	dword [rcx+8]
L647:
;---------------
    ret       
;End 
;Proc mlib.gs_leftstr
mlib.gs_leftstr:
;?>>
   %define R.dest r13
   %define R.s r14
    %define mlib.gs_leftstr.w 80
    %define mlib.gs_leftstr.padch 88
   %define R.col rdi
   %define R.i rbx
   %define R.n rsi
   %define R.slen r12
    %define mlib.gs_leftstr.str -2560
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2592
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movsxd    rax,	dword [r13+8]
    mov       rdi,	rax
    lea       rcx,	[rbp + mlib.gs_leftstr.str]
    mov       rdx,	r14
    call      strcpy
    mov       rcx,	r14
    call      strlen
    mov       r12,	rax
    mov       rax,	[rbp + mlib.gs_leftstr.w]
    sub       rax,	r12
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L650
    mov       rbx,	1
    cmp       rsi,	1
    jl        L653
L651:
    mov       rax,	r12
    add       rax,	rbx
    mov       r10b,	[rbp + mlib.gs_leftstr.padch]
    mov       [rbp + rax + mlib.gs_leftstr.str-1],	r10b
    inc       rbx
    cmp       rbx,	rsi
    jle       L651
L653:
    mov       rax,	r12
    add       rax,	rsi
    xor       r10d,	r10d
    mov       [rbp + rax + mlib.gs_leftstr.str],	r10b
L650:
    mov       rcx,	r13
    lea       rdx,	[rbp + mlib.gs_leftstr.str]
    call      mlib.gs_str
;---------------
    add       rsp,	2592
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_leftint
mlib.gs_leftint:
;?>>
   %define R.dest rdi
   %define R.a rbx
   %define R.w rsi
   %define R.padch r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	rsi
    mov       r9,	r12
    call      mlib.gs_leftstr
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_padto
mlib.gs_padto:
;?>>
   %define R.dest rsi
   %define R.col r12
   %define R.ch r13
   %define R.n rdi
    %define mlib.gs_padto.str -2560
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2600
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movsxd    rax,	dword [rsi+8]
    mov       r10,	r12
    sub       r10,	rax
    mov       rdi,	r10
    cmp       rdi,	0
    jle       L655
L657:
    mov       rbx,	1
    cmp       rdi,	1
    jl        L660
L658:
    mov       [rbp + rbx + mlib.gs_padto.str-1],	r13b
    inc       rbx
    cmp       rbx,	rdi
    jle       L658
L660:
    xor       eax,	eax
    mov       [rbp + rdi + mlib.gs_padto.str],	al
    mov       rcx,	rsi
    lea       rdx,	[rbp + mlib.gs_padto.str]
    call      mlib.gs_str
L655:
;---------------
    add       rsp,	2600
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_println
mlib.gs_println:
;?>>
   %define R.dest rdi
   %define R.f rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movsxd    rax,	dword [rdi+8]
    test      rax,	rax
    jz        L661
L663:
    mov       rax,	[rdi]
    movsxd    r10,	dword [rdi+8]
    xor       r11d,	r11d
    mov       [rax + r10],	r11b
    test      rbx,	rbx
    jnz       L665
    call      msys.m$print_startcon
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12106]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L664
L665:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12106]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L664:
L661:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.nextcmdparamnew
mlib.nextcmdparamnew:
;?>>
   %define R.paramno r12
   %define R.name r13
   %define R.value r14
    %define mlib.nextcmdparamnew.defext 88
   %define R.q rdi
    %define mlib.nextcmdparamnew.item -8
   %define R.fileext rbx
   %define R.length rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
;mlib.nextcmdparamnew.reenter:
L667:
    xor       eax,	eax
    mov       [r14],	rax
    xor       eax,	eax
    mov       [r13],	rax
    mov       rax,	[mlib.nextcmdparamnew.infile]
    test      rax,	rax
    jz        L669
    lea       rcx,	[mlib.nextcmdparamnew.fileptr]
    lea       rdx,	[rbp + mlib.nextcmdparamnew.item]
    call      mlib.readnextfileitem
    test      rax,	rax
    jnz       L671
    mov       rcx,	[mlib.nextcmdparamnew.filestart]
    call      free
    xor       eax,	eax
    mov       [mlib.nextcmdparamnew.infile],	rax
    jmp       L667
L671:
    jmp       L668
L669:
    mov       rax,	[r12]
    cmp       rax,	[msys.ncmdparams]
    jle       L673
    xor       eax,	eax
    jmp       L666
L673:
    mov       rax,	[r12]
    mov       r10,	[msys.cmdparams]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mlib.nextcmdparamnew.item],	r10
    mov       rax,	r12
    inc       qword [rax]
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    call      strlen
    mov       rsi,	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte [rax]
    cmp       rax,	64
    jnz       L675
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    lea       rax,	[rax+1]
    mov       rcx,	rax
    call      mlib.readfile
    mov       [mlib.nextcmdparamnew.fileptr],	rax
    mov       [mlib.nextcmdparamnew.filestart],	rax
    mov       rax,	[mlib.nextcmdparamnew.filestart]
    test      rax,	rax
    jnz       L677
    call      msys.m$print_startcon
    lea       rcx,	[L12107]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	7
    call      exit
L677:
    mov       rax,	1
    mov       [mlib.nextcmdparamnew.infile],	rax
    jmp       L667
L675:
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte [rax]
    cmp       rax,	58
    jnz       L679
    mov       al,	1
    mov       [mlib.nextcmdparamnew.colonseen],	al
    mov       rax,	4
    jmp       L666
L679:
L668:
    xor       eax,	eax
    mov       [r14],	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte [rax]
    cmp       rax,	45
    jnz       L681
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L683
    xor       eax,	eax
    jmp       L682
L683:
    mov       rax,	1
L682:
    mov       r10,	[rbp + mlib.nextcmdparamnew.item]
    lea       r10,	[r10 + rax]
    mov       [r13],	r10
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    mov       rdx,	58
    call      strchr
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L685
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    mov       rdx,	61
    call      strchr
    mov       rdi,	rax
L685:
    test      rdi,	rdi
    jz        L687
    lea       rax,	[rdi+1]
    mov       [r14],	rax
    xor       eax,	eax
    mov       [rdi],	al
L687:
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L689
    mov       rax,	5
    jmp       L688
L689:
    mov       rax,	1
L688:
    jmp       L666
L681:
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    xor       edx,	edx
    call      mlib.extractext
    mov       rbx,	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    mov       [r13],	rax
    movzx     rax,	byte [rbx]
    test      rax,	rax
    jnz       L691
    mov       rax,	[r13]
    lea       rcx,	[mlib.nextcmdparamnew.str]
    mov       rdx,	rax
    call      strcpy
    mov       rax,	[rbp + mlib.nextcmdparamnew.defext]
    test      rax,	rax
    jz        L693
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jnz       L693
    lea       rcx,	[mlib.nextcmdparamnew.str]
    mov       rdx,	[rbp + mlib.nextcmdparamnew.defext]
    call      mlib.addext
    mov       [r13],	rax
L693:
    jmp       L690
L691:
    mov       rcx,	rbx
    lea       rdx,	[L12108]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L695
    mov       rcx,	rbx
    lea       rdx,	[L12109]
    call      mlib.eqstring
    test      rax,	rax
    jz        L694
L695:
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L697
    mov       rax,	5
    jmp       L696
L697:
    mov       rax,	3
L696:
    jmp       L666
L694:
L690:
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L699
    mov       rax,	5
    jmp       L698
L699:
    mov       rax,	2
L698:
L666:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.readnextfileitem
mlib.readnextfileitem:
;?>>
   %define R.fileptr r13
   %define R.item r14
   %define R.p rdi
   %define R.pstart rbx
   %define R.pend rsi
   %define R.n r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    mov       rdi,	[r13]
;mlib.readnextfileitem.reenter:
L701:
L702:
    movzx     rax,	byte [rdi]
    cmp       rax,	32
    jz        L705
    cmp       rax,	9
    jz        L705
    cmp       rax,	13
    jz        L705
    cmp       rax,	10
    jz        L705
    cmp       rax,	26
    jz        L706
    test      rax,	rax
    jz        L706
    jmp       L707
L705:
    inc       rdi
    jmp       L704
L706:
    xor       eax,	eax
    jmp       L700
L707:
    jmp       L703
L704:
    jmp       L702
L703:
    movzx     rax,	byte [rdi]
    cmp       rax,	33
    jz        L709
    cmp       rax,	35
    jnz       L710
L709:
    inc       rdi
L711:
    mov       rax,	rdi
    inc       rdi
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L713
    cmp       rax,	26
    jz        L714
    test      rax,	rax
    jz        L714
    jmp       L715
L713:
    jmp       L701
L714:
    lea       rax,	[rdi-1]
    mov       [r13],	rax
    xor       eax,	eax
    jmp       L700
L715:
    jmp       L711
L710:
L708:
    movzx     rax,	byte [rdi]
    cmp       rax,	34
    jnz       L718
L717:
    inc       rdi
    mov       rbx,	rdi
L719:
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jz        L722
    cmp       rax,	26
    jz        L722
    cmp       rax,	34
    jz        L723
    jmp       L724
L722:
    call      msys.m$print_startcon
    lea       rcx,	[L12110]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	8
    call      exit
    jmp       L721
L723:
    mov       rax,	rdi
    inc       rdi
    mov       rsi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	44
    jnz       L726
    inc       rdi
L726:
    jmp       L720
L724:
L721:
    inc       rdi
    jmp       L719
L720:
    jmp       L716
L718:
    mov       rbx,	rdi
L727:
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jz        L730
    cmp       rax,	26
    jz        L730
    cmp       rax,	32
    jz        L731
    cmp       rax,	9
    jz        L731
    cmp       rax,	44
    jz        L731
    cmp       rax,	13
    jz        L731
    cmp       rax,	10
    jz        L731
    jmp       L732
L730:
    mov       rsi,	rdi
    jmp       L728
L731:
    mov       rax,	rdi
    inc       rdi
    mov       rsi,	rax
    jmp       L728
L732:
L729:
    inc       rdi
    jmp       L727
L728:
L716:
    mov       rax,	rsi
    sub       rax,	rbx
    mov       r12,	rax
    cmp       r12,	256
    jl        L734
    call      msys.m$print_startcon
    lea       rcx,	[L12111]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	9
    call      exit
L734:
    lea       rcx,	[mlib.readnextfileitem.str]
    mov       rdx,	rbx
    mov       r8,	r12
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.readnextfileitem.str]
    mov       r11,	r12
    mov       [r10 + r11],	al
    lea       rax,	[mlib.readnextfileitem.str]
    mov       [r14],	rax
    mov       [r13],	rdi
    mov       rax,	1
L700:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.ipadstr
mlib.ipadstr:
;?>>
   %define R.s rsi
   %define R.width r12
   %define R.padchar r13
   %define R.n rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	rsi
    call      strlen
    mov       rdi,	rax
    mov       rax,	r12
    sub       rax,	rdi
    mov       rbx,	rax
    cmp       rbx,	0
    jle       L738
L736:
    mov       rcx,	rsi
    mov       rdx,	r13
    call      strcat
    dec       rbx
    jnz       L736
L738:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.padstr
mlib.padstr:
;?>>
   %define R.s rdi
   %define R.width rbx
   %define R.padchar rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[mlib.padstr.str]
    mov       rdx,	rdi
    call      strcpy
    lea       rcx,	[mlib.padstr.str]
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mlib.ipadstr
    lea       rax,	[mlib.padstr.str]
L739:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.chr
mlib.chr:
;?>>
   %define R.c rcx
;?]]
;---------------
    mov       al,	cl
    lea       r10,	[mlib.chr.str]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[mlib.chr.str]
    mov       [r10+1],	al
    lea       rax,	[mlib.chr.str]
L740:
;---------------
    ret       
;End 
;Proc mlib.cmpstring
mlib.cmpstring:
;?>>
   %define R.s rbx
   %define R.t rsi
   %define R.res rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      strcmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L743
    mov       rax,	-1
    jmp       L742
L743:
    cmp       rdi,	0
    jle       L744
    mov       rax,	1
    jmp       L742
L744:
    xor       eax,	eax
L742:
L741:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.cmpstringn
mlib.cmpstringn:
;?>>
   %define R.s rbx
   %define R.t rsi
   %define R.n r12
   %define R.res rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      strncmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L747
    mov       rax,	-1
    jmp       L746
L747:
    cmp       rdi,	0
    jle       L748
    mov       rax,	1
    jmp       L746
L748:
    xor       eax,	eax
L746:
L745:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.eqstring
mlib.eqstring:
;?>>
   %define R.s rdi
   %define R.t rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      strcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L749:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.cmpbytes
mlib.cmpbytes:
;?>>
   %define R.p rbx
   %define R.q rsi
   %define R.n r12
   %define R.res rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      memcmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L752
    mov       rax,	-1
    jmp       L751
L752:
    cmp       rdi,	0
    jle       L753
    mov       rax,	1
    jmp       L751
L753:
    xor       eax,	eax
L751:
L750:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.eqbytes
mlib.eqbytes:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L754:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.mseed
mlib.mseed:
;?>>
   %define R.a rcx
   %define R.b rdx
;?]]
;---------------
    mov       rax,	rcx
    lea       r10,	[mlib.seed]
    mov       [r10],	rax
    test      rdx,	rdx
    jz        L757
    mov       rax,	rdx
    lea       r10,	[mlib.seed]
    mov       [r10+8],	rax
    jmp       L756
L757:
    lea       rax,	[mlib.seed]
    lea       rax,	[rax+8]
    mov       r10,	rcx
    xor       [rax],	r10
L756:
;---------------
    ret       
;End 
;Proc mlib.mrandom
mlib.mrandom:
;?>>
   %define R.x rdi
   %define R.y rbx
    push      rdi
    push      rbx
;?]]
;---------------
    lea       rax,	[mlib.seed]
    mov       rdi,	[rax]
    lea       rax,	[mlib.seed]
    mov       rbx,	[rax+8]
    mov       rax,	rbx
    lea       r10,	[mlib.seed]
    mov       [r10],	rax
    mov       rax,	rdi
    shl       rax,	23
    xor       rdi,	rax
    mov       rax,	rdi
    xor       rax,	rbx
    mov       r10,	rdi
    sar       r10,	17
    xor       rax,	r10
    mov       r10,	rbx
    sar       r10,	26
    xor       rax,	r10
    lea       r10,	[mlib.seed]
    mov       [r10+8],	rax
    lea       rax,	[mlib.seed]
    mov       rax,	[rax+8]
    add       rax,	rbx
L758:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.mrandomp
mlib.mrandomp:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mlib.mrandom
    mov       r10,	9223372036854775807
    and       rax,	r10
L759:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mlib.mrandomint
mlib.mrandomint:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      mlib.mrandomp
    mov       r10,	rdi
    cqo       
    idiv      r10
    xchg      rax,	rdx
L760:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.mrandomrange
mlib.mrandomrange:
;?>>
   %define R.a rbx
   %define R.b rsi
   %define R.span rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rax,	rsi
    sub       rax,	rbx
    inc       rax
    mov       rdi,	rax
    cmp       rdi,	0
    jg        L763
    xor       eax,	eax
    jmp       L761
L763:
    call      mlib.mrandomp
    mov       r10,	rdi
    cqo       
    idiv      r10
    xchg      rax,	rdx
    add       rax,	rbx
L761:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.mrandomreal
mlib.mrandomreal:
;?>>
   %define R.x XMM15
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
;---------------
L765:
    call      mlib.mrandomp
    cvtsi2sd  XMM4,	rax
    divsd     XMM4,	[L12112]
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    comisd    XMM4,	[L12113]
    jz        L765
    movq      XMM0,	XMM15
L764:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
;End 
;Proc mlib.mrandomreal1
mlib.mrandomreal1:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mlib.mrandomp
    cvtsi2sd  XMM4,	rax
    divsd     XMM4,	[L12114]
    movq      XMM0,	XMM4
L768:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mlib.readline
mlib.readline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$read_conline
    mov       rax,	[msys.rd_buffer]
L769:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mlib.findfunction
mlib.findfunction:
;?>>
   %define R.name rsi
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	1
    mov       rdi,	[$nprocs]
    cmp       rdi,	1
    jl        L773
L771:
    lea       rax,	[$procname]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mlib.eqstring
    test      rax,	rax
    jz        L775
    lea       rax,	[$procaddr]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    jmp       L770
L775:
    inc       rbx
    cmp       rbx,	rdi
    jle       L771
L773:
    xor       eax,	eax
L770:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.roundtoblock
mlib.roundtoblock:
;?>>
   %define R.n rcx
   %define R.align rdx
;?]]
;---------------
    lea       rax,	[rdx-1]
    mov       r10,	rcx
    and       r10,	rax
    test      r10,	r10
    jnz       L778
    mov       rax,	rcx
    jmp       L776
L778:
    lea       rax,	[rdx-1]
    mov       r10,	rcx
    and       r10,	rax
    mov       rax,	rdx
    sub       rax,	r10
    mov       r10,	rcx
    add       r10,	rax
    mov       rax,	r10
L776:
;---------------
    ret       
;End 
;Proc mlib.pcm_allocnfz
mlib.pcm_allocnfz:
;?>>
   %define R.n rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	rbx
    and       rax,	7
    jz        L781
    mov       rax,	rbx
    and       rax,	7
    mov       r10,	8
    sub       r10,	rax
    mov       rax,	rbx
    add       rax,	r10
    mov       rbx,	rax
L781:
    mov       rdi,	[mlib.pcheapptr]
    mov       rax,	rbx
    add       [mlib.pcheapptr],	rax
    mov       rax,	[mlib.pcheapptr]
    cmp       rax,	[mlib.pcheapend]
    jb        L783
    mov       rcx,	rbx
    call      mlib.pcm_newblock
    mov       rdi,	rax
L783:
    mov       rax,	rdi
L779:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_init
mwindows.os_init:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       eax,	4294967285
    mov       eax,	eax
    mov       rcx,	rax
    call      GetStdHandle
    mov       [mwindows.hconsole],	rax
    mov       eax,	4294967286
    mov       eax,	eax
    mov       rcx,	rax
    call      GetStdHandle
    mov       [mwindows.hconsolein],	rax
    xor       eax,	eax
    lea       r10,	[mwindows.lastkey]
    mov       [r10+8],	ax
    xor       eax,	eax
    mov       [mwindows.keypending],	rax
    xor       ecx,	ecx
    mov       rdx,	1
    call      SetConsoleCtrlHandler
    mov       rcx,	[mwindows.hconsole]
    mov       rdx,	3
    call      SetConsoleMode
    mov       rax,	1
    mov       [mwindows.init_flag],	rax
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_execwait
mwindows.os_execwait:
;?>>
   %define R.cmdline rsi
   %define R.newconsole r12
    %define mwindows.os_execwait.workdir 64
    %define mwindows.os_execwait.exitcode -8
   %define R.status rdi
   %define R.cflags rbx
    %define mwindows.os_execwait.si -112
    %define mwindows.os_execwait.xpi -136
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	176
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       rbx,	rbx
    lea       rax,	[rbp + mwindows.os_execwait.si]
    xor       r10d,	r10d
    mov       r11,	13
L12115:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12115
    lea       rax,	[rbp + mwindows.os_execwait.xpi]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       rax,	r12
    test      rax,	rax
    jz        L787
    cmp       rax,	1
    jz        L788
    cmp       rax,	2
    jz        L789
    jmp       L790
L787:
    mov       rbx,	32
    jmp       L786
L788:
    mov       rbx,	48
    jmp       L786
L789:
    mov       rbx,	48
L790:
L786:
    mov       eax,	104
    mov       [rbp + mwindows.os_execwait.si],	eax
    lea       rax,	[rbp + mwindows.os_execwait.xpi]
    push      rax
    lea       rax,	[rbp + mwindows.os_execwait.si]
    push      rax
    push      0
    push      0
    mov       eax,	ebx
    push      rax
    push      1
    xor       ecx,	ecx
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      CreateProcessA
    add       rsp,	80
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L792
    call      GetLastError
    mov       r10d,	eax
    mov       rdi,	r10
    lea       rcx,	[L12116]
    mov       rdx,	rdi
    call      printf
    mov       rax,	-1
    jmp       L785
L792:
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    mov       rdx,	4294967295
    call      WaitForSingleObject
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    lea       rdx,	[rbp + mwindows.os_execwait.exitcode]
    call      GetExitCodeProcess
    mov       rcx,	[rbp + mwindows.os_execwait.xpi]
    call      CloseHandle
    mov       rcx,	[rbp + mwindows.os_execwait.xpi+8]
    call      CloseHandle
    mov       eax,	[rbp + mwindows.os_execwait.exitcode]
L785:
;---------------
    add       rsp,	176
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_execcmd
mwindows.os_execcmd:
;?>>
   %define R.cmdline rdi
   %define R.newconsole rbx
    %define mwindows.os_execcmd.si -104
    %define mwindows.os_execcmd.xpi -128
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[rbp + mwindows.os_execcmd.si]
    xor       r10d,	r10d
    mov       r11,	13
L12117:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12117
    lea       rax,	[rbp + mwindows.os_execcmd.xpi]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       eax,	104
    mov       [rbp + mwindows.os_execcmd.si],	eax
    lea       rax,	[rbp + mwindows.os_execcmd.xpi]
    push      rax
    lea       rax,	[rbp + mwindows.os_execcmd.si]
    push      rax
    push      0
    push      0
    test      rbx,	rbx
    jz        L795
    mov       rax,	16
    jmp       L794
L795:
    xor       eax,	eax
L794:
    mov       r10,	32
    or        r10,	rax
    push      r10
    push      1
    xor       ecx,	ecx
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      CreateProcessA
    add       rsp,	80
    mov       rcx,	[rbp + mwindows.os_execcmd.xpi]
    call      CloseHandle
    mov       rcx,	[rbp + mwindows.os_execcmd.xpi+8]
    call      CloseHandle
    mov       rax,	1
L793:
;---------------
    add       rsp,	160
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_getch
mwindows.os_getch:
;?>>
   %define R.k rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      mwindows.os_getchx
    and       rax,	255
    mov       rdi,	rax
    mov       rax,	rdi
L796:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mwindows.os_kbhit
mwindows.os_kbhit:
;?>>
    %define mwindows.os_kbhit.count -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[mwindows.init_flag]
    test      rax,	rax
    jnz       L799
    call      mwindows.os_init
L799:
    mov       rcx,	[mwindows.hconsolein]
    lea       rdx,	[rbp + mwindows.os_kbhit.count]
    call      GetNumberOfConsoleInputEvents
    mov       eax,	[rbp + mwindows.os_kbhit.count]
    cmp       rax,	1
    setg      al
    movzx     eax,	al
L797:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mwindows.os_getdllinst
mwindows.os_getdllinst:
;?>>
   %define R.name rbx
   %define R.hinst rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      LoadLibraryA
    mov       rdi,	rax
    mov       rax,	rdi
L800:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_getdllprocaddr
mwindows.os_getdllprocaddr:
;?>>
   %define R.hinst rdi
   %define R.name rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      GetProcAddress
L801:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_initwindows
mwindows.os_initwindows:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mwindows.os_init
    lea       rcx,	[L12118]
    call      mwindows.os_gxregisterclass
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_gxregisterclass
mwindows.os_gxregisterclass:
;?>>
   %define R.classname rdi
    %define mwindows.os_gxregisterclass.r -80
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	120
    mov       rdi,	rcx
;---------------
    mov       al,	[mwindows.os_gxregisterclass.registered]
    test      al,	al
    jnz       L803
L805:
    lea       rax,	[rbp + mwindows.os_gxregisterclass.r]
    xor       r10d,	r10d
    mov       r11,	10
L12119:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12119
    mov       eax,	80
    mov       [rbp + mwindows.os_gxregisterclass.r],	eax
    mov       eax,	40
    mov       [rbp + mwindows.os_gxregisterclass.r+4],	eax
    lea       rax,	[mwindows.mainwndproc]
    mov       [rbp + mwindows.os_gxregisterclass.r+8],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+24],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+32],	rax
    xor       ecx,	ecx
    mov       rdx,	32512
    call      LoadCursorA
    mov       [rbp + mwindows.os_gxregisterclass.r+40],	rax
    mov       rax,	16
    mov       [rbp + mwindows.os_gxregisterclass.r+48],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+56],	rax
    mov       [rbp + mwindows.os_gxregisterclass.r+64],	rdi
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+72],	rax
    lea       rcx,	[rbp + mwindows.os_gxregisterclass.r]
    call      RegisterClassExA
    mov       r10d,	eax
    test      r10,	r10
    jnz       L807
    call      GetLastError
    mov       r10d,	eax
    lea       rcx,	[L12120]
    mov       rdx,	rdi
    mov       r8,	r10
    call      printf
    mov       rcx,	1
    call      exit
L807:
    mov       al,	1
    mov       [mwindows.os_gxregisterclass.registered],	al
L803:
;---------------
    add       rsp,	120
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mwindows.mainwndproc
mwindows.mainwndproc:
;?>>
   %define R.hwnd rbx
   %define R.message esi
   %define R.wparam r12
   %define R.lparam r13
    %define mwindows.mainwndproc.m -48
   %define R.result rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       rbx,	rcx
    mov       esi,	edx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       [rbp + mwindows.mainwndproc.m],	rbx
    mov       [rbp + mwindows.mainwndproc.m+8],	esi
    mov       [rbp + mwindows.mainwndproc.m+16],	r12
    mov       [rbp + mwindows.mainwndproc.m+24],	r13
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.m+40],	eax
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.m+44],	eax
    mov       rax,	[mwindows.wndproc_callbackfn]
    test      rax,	rax
    jz        L810
    lea       rcx,	[rbp + mwindows.mainwndproc.m]
    mov       rax,	[mwindows.wndproc_callbackfn]
    call      rax
    mov       rdi,	rax
    jmp       L809
L810:
    xor       rdi,	rdi
L809:
    mov       eax,	[rbp + mwindows.mainwndproc.m+8]
    cmp       rax,	2
    jnz       L812
    xor       eax,	eax
    jmp       L808
L812:
    test      rdi,	rdi
    jnz       L814
    mov       eax,	esi
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    mov       r9,	r13
    call      DefWindowProcA
    jmp       L813
L814:
    xor       eax,	eax
L813:
L808:
;---------------
    add       rsp,	88
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_setmesshandler
mwindows.os_setmesshandler:
;?>>
   %define R.addr rcx
;?]]
;---------------
    mov       [mwindows.wndproc_callbackfn],	rcx
;---------------
    ret       
;End 
;Proc mwindows.os_getchx
mwindows.os_getchx:
;?>>
    %define mwindows.os_getchx.count -8
   %define R.charcode rdi
   %define R.keyshift rbx
   %define R.keycode rsi
   %define R.altdown r12
   %define R.ctrldown r13
    %define mwindows.os_getchx.shiftdown -16
    %define mwindows.os_getchx.capslock -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
;---------------
    mov       rax,	[mwindows.init_flag]
    test      rax,	rax
    jnz       L818
    call      mwindows.os_init
L818:
    mov       rax,	[mwindows.keypending]
    test      rax,	rax
    jz        L820
    lea       rax,	[mwindows.pendkey]
    lea       r10,	[mwindows.lastkey]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11d,	[rax+16]
    mov       [r10+16],	r11d
    xor       eax,	eax
    mov       [mwindows.keypending],	rax
    jmp       L819
L820:
    lea       rax,	[mwindows.lastkey]
    movzx     rax,	word [rax+8]
    test      rax,	rax
    jnz       L822
L823:
    xor       eax,	eax
    mov       [rbp + mwindows.os_getchx.count],	rax
    mov       rcx,	[mwindows.hconsolein]
    lea       rdx,	[mwindows.lastkey]
    mov       r8,	1
    lea       r9,	[rbp + mwindows.os_getchx.count]
    call      ReadConsoleInputA
    lea       rax,	[mwindows.lastkey]
    movzx     rax,	word [rax]
    cmp       rax,	1
    jnz       L823
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+4]
    cmp       rax,	1
    jnz       L823
L822:
L819:
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	3
    jz        L827
    mov       rax,	1
    jmp       L826
L827:
    xor       eax,	eax
L826:
    mov       r12,	rax
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	12
    jz        L829
    mov       rax,	1
    jmp       L828
L829:
    xor       eax,	eax
L828:
    mov       r13,	rax
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	16
    jz        L831
    mov       rax,	1
    jmp       L830
L831:
    xor       eax,	eax
L830:
    mov       [rbp + mwindows.os_getchx.shiftdown],	rax
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	128
    jz        L833
    mov       rax,	1
    jmp       L832
L833:
    xor       eax,	eax
L832:
    mov       [rbp + mwindows.os_getchx.capslock],	rax
    lea       rax,	[mwindows.lastkey]
    lea       rax,	[rax+8]
    dec       word [rax]
    lea       rax,	[mwindows.lastkey]
    movzx     rax,	byte [rax+14]
    mov       rdi,	rax
    lea       rax,	[mwindows.lastkey]
    movzx     rax,	word [rax+10]
    and       rax,	255
    mov       rsi,	rax
    cmp       rdi,	0
    jge       L835
    cmp       rdi,	-128
    jge       L837
    xor       rdi,	rdi
    jmp       L836
L837:
    mov       rax,	256
    add       rdi,	rax
L836:
L835:
    test      r12,	r12
    jz        L839
    test      r13,	r13
    jz        L839
    cmp       rdi,	166
    jnz       L839
    xor       eax,	eax
    mov       r13,	rax
    mov       r12,	rax
    jmp       L838
L839:
    test      r12,	r12
    jnz       L842
    test      r13,	r13
    jz        L841
L842:
    xor       rdi,	rdi
    mov       rax,	rsi
    cmp       rax,	65
    jl        L844
    cmp       rsi,	90
    jg        L844
    lea       rax,	[rsi-64]
    mov       rdi,	rax
L844:
L841:
L838:
    mov       rax,	[rbp + mwindows.os_getchx.capslock]
    shl       rax,	3
    mov       r10,	r12
    shl       r10,	2
    or        rax,	r10
    mov       r10,	r13
    shl       r10,	1
    or        rax,	r10
    or        rax,	[rbp + mwindows.os_getchx.shiftdown]
    mov       rbx,	rax
    mov       rax,	rbx
    shl       rax,	24
    mov       r10,	rsi
    shl       r10,	16
    or        rax,	r10
    or        rax,	rdi
L816:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_getos
mwindows.os_getos:
;?>>
;?]]
;---------------
    lea       rax,	[L12121]
L845:
;---------------
    ret       
;End 
;Proc mwindows.os_gethostsize
mwindows.os_gethostsize:
;?>>
;?]]
;---------------
    mov       rax,	64
L846:
;---------------
    ret       
;End 
;Proc mwindows.os_shellexec
mwindows.os_shellexec:
;?>>
    %define mwindows.os_shellexec.opc 24
   %define R.file rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    call      system
    movsxd    r10,	eax
    mov       rax,	r10
L847:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mwindows.os_sleep
mwindows.os_sleep:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      Sleep
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mwindows.os_getstdin
mwindows.os_getstdin:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12122]
    lea       rdx,	[L12123]
    call      fopen
L849:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_getstdout
mwindows.os_getstdout:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12124]
    lea       rdx,	[L12125]
    call      fopen
L850:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_gethostname
mwindows.os_gethostname:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       ecx,	ecx
    lea       rdx,	[mwindows.os_gethostname.name]
    mov       r8,	300
    call      GetModuleFileNameA
    lea       rax,	[mwindows.os_gethostname.name]
L851:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_getmpath
mwindows.os_getmpath:
;?>>
;?]]
;---------------
    lea       rax,	[L12126]
L852:
;---------------
    ret       
;End 
;Proc mwindows.os_clock
mwindows.os_clock:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mwindows.os_hpcounter
L853:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_ticks
mwindows.os_ticks:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      GetTickCount64
L854:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_iswindows
mwindows.os_iswindows:
;?>>
;?]]
;---------------
    mov       rax,	1
L855:
;---------------
    ret       
;End 
;Proc mwindows.os_getsystime
mwindows.os_getsystime:
;?>>
   %define R.tm rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      GetLocalTime
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mwindows.os_peek
mwindows.os_peek:
;?>>
   %define R.ticks rdi
    %define mwindows.os_peek.m -104
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
;---------------
    call      GetTickCount64
    mov       rdi,	rax
    mov       rax,	rdi
    sub       rax,	[mwindows.os_peek.lastticks]
    cmp       rax,	1000
    jl        L859
    mov       [mwindows.os_peek.lastticks],	rdi
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + mwindows.os_peek.m]
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      PeekMessageA
    add       rsp,	48
L859:
;---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mwindows.os_allocexecmem
mwindows.os_allocexecmem:
;?>>
   %define R.n rsi
   %define R.p rdi
    %define mwindows.os_allocexecmem.oldprot -8
   %define R.status rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
;---------------
    xor       ecx,	ecx
    mov       rdx,	rsi
    mov       r8,	12288
    mov       r9,	1
    call      VirtualAlloc
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L862
    xor       eax,	eax
    jmp       L860
L862:
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	64
    lea       r9,	[rbp + mwindows.os_allocexecmem.oldprot]
    call      VirtualProtect
    mov       r10d,	eax
    mov       rbx,	r10
    test      rbx,	rbx
    jnz       L864
    xor       eax,	eax
    jmp       L860
L864:
    mov       rax,	rdi
L860:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.dirlist
mwindows.dirlist:
;?>>
   %define R.filespec rsi
   %define R.dest r12
   %define R.capacity r13
   %define R.t r14
   %define R.hfind rdi
    %define mwindows.dirlist.file -328
   %define R.nfiles rbx
    %define mwindows.dirlist.path -632
    %define mwindows.dirlist.fullfilename -936
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	976
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    xor       rbx,	rbx
    mov       rcx,	rsi
    call      mlib.extractpath
    lea       rcx,	[rbp + mwindows.dirlist.path]
    mov       rdx,	rax
    call      strcpy
    mov       rcx,	rsi
    lea       rdx,	[rbp + mwindows.dirlist.file]
    call      FindFirstFileA
    mov       rdi,	rax
    cmp       rax,	-1
    jz        L867
L868:
    mov       eax,	[rbp + mwindows.dirlist.file]
    and       rax,	16
    jz        L872
    mov       rax,	r14
    and       rax,	2
    jnz       L874
    jmp       L869
L874:
    jmp       L871
L872:
    mov       rax,	r14
    and       rax,	1
    jnz       L876
    jmp       L869
L876:
L871:
    cmp       rbx,	r13
    jl        L878
    mov       rbx,	-1
    jmp       L870
L878:
    mov       rax,	r14
    and       rax,	4
    jz        L880
    lea       rax,	[rbp + mwindows.dirlist.file+44]
    mov       rcx,	rax
    call      mlib.convlcstring
L880:
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    lea       rdx,	[rbp + mwindows.dirlist.path]
    call      strcpy
    lea       rax,	[rbp + mwindows.dirlist.file+44]
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    call      mlib.pcm_copyheapstring
    inc       rbx
    mov       r10,	rbx
    mov       [r12 + r10*8-8],	rax
L869:
    mov       rcx,	rdi
    lea       rdx,	[rbp + mwindows.dirlist.file]
    call      FindNextFileA
    test      eax,	eax
    jnz       L868
L870:
    mov       rcx,	rdi
    call      FindClose
L867:
    mov       rax,	rbx
L865:
;---------------
    add       rsp,	976
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_hpcounter
mwindows.os_hpcounter:
;?>>
    %define mwindows.os_hpcounter.a -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[mwindows.hpfreq]
    test      rax,	rax
    jnz       L883
    call      mwindows.os_hpfreq
    mov       r10,	1000
    cqo       
    idiv      r10
    mov       [mwindows.hpfreq],	rax
L883:
    lea       rcx,	[rbp + mwindows.os_hpcounter.a]
    call      QueryPerformanceCounter
    mov       rax,	[rbp + mwindows.os_hpcounter.a]
    mov       r10,	[mwindows.hpfreq]
    cqo       
    idiv      r10
L881:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mwindows.os_hpfreq
mwindows.os_hpfreq:
;?>>
    %define mwindows.os_hpfreq.a -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    lea       rcx,	[rbp + mwindows.os_hpfreq.a]
    call      QueryPerformanceFrequency
    mov       rax,	[rbp + mwindows.os_hpfreq.a]
L884:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mwindll.os_calldllfunction
mwindll.os_calldllfunction:
;?>>
    %define mwindll.os_calldllfunction.fnaddr 16
    %define mwindll.os_calldllfunction.retcode 24
    %define mwindll.os_calldllfunction.nargs 32
    %define mwindll.os_calldllfunction.args 40
    %define mwindll.os_calldllfunction.argcodes 48
    %define mwindll.os_calldllfunction.a -8
    %define mwindll.os_calldllfunction.x -16
    %define mwindll.os_calldllfunction.nextra -24
    %define mwindll.os_calldllfunction.pushedbytes -32
    %define mwindll.os_calldllfunction.av_1 -40
    %define mwindll.os_calldllfunction.i -48
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    cmp       rax,	4
    jge       L887
    mov       rax,	4
    sub       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
    jmp       L886
L887:
    mov       eax,	[rbp + mwindll.os_calldllfunction.nargs]
    and       eax,	1
    test      rax,	rax
    jz        L888
    mov       rax,	1
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
L888:
L886:
    mov       rax,	[rbp + mwindll.os_calldllfunction.nextra]
    add       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    shl       rax,	3
    mov       [rbp + mwindll.os_calldllfunction.pushedbytes],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.nextra]
    mov       [rbp + mwindll.os_calldllfunction.av_1],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.av_1]
    cmp       rax,	0
    jle       L891
L889:
    push      0
    dec       qword [rbp + mwindll.os_calldllfunction.av_1]
    jnz       L889
L891:
    mov       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    mov       [rbp + mwindll.os_calldllfunction.i],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.i]
    cmp       rax,	1
    jl        L894
L892:
    mov       rax,	[rbp + mwindll.os_calldllfunction.args]
    mov       r10,	[rbp + mwindll.os_calldllfunction.i]
    mov       rax,	[rax + r10*8-8]
    mov       [rbp + mwindll.os_calldllfunction.a],	rax
    push      qword [rbp + mwindll.os_calldllfunction.a]
    mov       rax,	[rbp + mwindll.os_calldllfunction.i]
    dec       rax
    mov       [rbp + mwindll.os_calldllfunction.i],	rax
    cmp       rax,	1
    jge       L892
L894:
    mov       rcx,	[rsp]
    movq      XMM0,	[rsp]
    mov       rdx,	[rsp+8]
    movq      XMM1,	[rsp+8]
    mov       r8,	[rsp+16]
    movq      XMM2,	[rsp+16]
    mov       r9,	[rsp+24]
    movq      XMM3,	[rsp+24]
    mov       rax,	[rbp + mwindll.os_calldllfunction.retcode]
    cmp       rax,	73
    jnz       L896
    mov       rax,	[rbp + mwindll.os_calldllfunction.fnaddr]
    call      rax
    mov       [rbp + mwindll.os_calldllfunction.a],	rax
    add       rsp,	[rbp + mwindll.os_calldllfunction.pushedbytes]
    mov       rax,	[rbp + mwindll.os_calldllfunction.a]
    jmp       L895
L896:
    mov       rax,	[rbp + mwindll.os_calldllfunction.fnaddr]
    call      rax
    movq      [rbp + mwindll.os_calldllfunction.x],	XMM0
    add       rsp,	[rbp + mwindll.os_calldllfunction.pushedbytes]
    movq      XMM4,	[rbp + mwindll.os_calldllfunction.x]
    movq      rax,	XMM4
L895:
L885:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc pc_api.pcl_start
pc_api.pcl_start:
;?>>
   %define R.name rdi
   %define R.nunits rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	[pc_decls.pcldone]
    test      al,	al
    jz        L899
    lea       rcx,	[L12127]
    call      pc_api.pclerror
L899:
    test      rdi,	rdi
    jz        L901
    mov       rcx,	rdi
    mov       rdx,	9
    call      pc_api.pc_makesymbol
    mov       [pc_decls.currprog],	rax
L901:
    mov       rax,	[pc_api.initpcalloc]
    mov       [pc_api.pcalloc],	rax
    test      rbx,	rbx
    jz        L903
    mov       rax,	rbx
    lea       rax,	[rax + rax*8]
    sar       rax,	3
    mov       rbx,	rax
    jmp       L905
L904:
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	1
    mov       [pc_api.pcalloc],	rax
L905:
    mov       rax,	[pc_api.pcalloc]
    cmp       rax,	rbx
    jl        L904
L903:
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	5
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [pc_api.pcstart],	rax
    mov       rax,	[pc_api.pcstart]
    mov       r10,	[pc_api.pcalloc]
    shl       r10,	5
    lea       rax,	[rax + r10]
    sub       rax,	256
    mov       [pc_api.pcend],	rax
    mov       rax,	[pc_api.pcstart]
    sub       rax,	32
    mov       [pc_api.pccurr],	rax
    xor       eax,	eax
    mov       [pc_api.pcfixed],	al
    xor       eax,	eax
    mov       [pc_api.pcseqno],	rax
    xor       eax,	eax
    mov       [pc_api.pcneedfntable],	rax
    xor       eax,	eax
    mov       [pc_api.mlabelno],	rax
    mov       rax,	[pc_decls.currprog]
L897:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_end
pc_api.pcl_end:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[pc_api.pccurr]
    cmp       rax,	[pc_api.pccurr]
    jb        L909
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax]
    cmp       rax,	136
    jz        L909
    mov       rcx,	136
    xor       edx,	edx
    call      pc_api.pc_gen
L909:
    mov       al,	1
    mov       [pc_decls.pcldone],	al
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pcl_writepcl
pc_api.pcl_writepcl:
;?>>
   %define R.filename rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_diags.writeallpcl
    mov       rdi,	rax
    test      rbx,	rbx
    jz        L912
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L914
    call      msys.m$print_startcon
    lea       rcx,	[L12128]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L914:
    movsxd    rax,	dword [rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
    lea       rax,	[L12129]
    jmp       L911
L912:
    mov       rax,	[rdi]
L911:
L910:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writepst
pc_api.pcl_writepst:
;?>>
   %define R.filename rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_diags.writepst
    mov       rdi,	rax
    test      rbx,	rbx
    jz        L917
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L919
    call      msys.m$print_startcon
    lea       rcx,	[L12130]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L919:
    movsxd    rax,	dword [rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
    lea       rax,	[L12131]
    jmp       L916
L917:
    mov       rax,	[rdi]
L916:
L915:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_genmcl
pc_api.pcl_genmcl:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pcl_genss
pc_api.pcl_genss:
;?>>
   %define R.obj rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	rdi
    call      mc_genss.genss
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writess
pc_api.pcl_writess:
;?>>
   %define R.filename rsi
   %define R.obj r12
   %define R.ssstr rdi
   %define R.f rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	r12
    call      mc_genss.genss
    mov       rax,	r12
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rcx,	rax
    call      mc_writess_dummy.writessdata
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L924
    mov       rcx,	rsi
    lea       rdx,	[L12132]
    call      fopen
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_println
    mov       rcx,	rbx
    call      fclose
    mov       rcx,	rdi
    call      mlib.gs_free
    xor       eax,	eax
    jmp       L923
L924:
    mov       rax,	[rdi]
L923:
L922:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writeasm
pc_api.pcl_writeasm:
;?>>
   %define R.filename rsi
    %define pc_api.pcl_writeasm.atype 48
   %define R.asmstr rdi
   %define R.f rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rax,	[pc_decls.assemtype]
    cmp       rax,	1297301838
    jnz       L927
    mov       al,	2
    mov       [pc_api.phighmem],	al
L927:
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    call      mc_writenasm.getassemstr
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L929
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L931
    call      msys.m$print_startcon
    lea       rcx,	[L12133]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L931:
    mov       rcx,	rsi
    lea       rdx,	[L12134]
    call      fopen
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_println
    mov       rcx,	rbx
    call      fclose
    mov       rcx,	rdi
    call      mlib.gs_free
    xor       eax,	eax
    jmp       L928
L929:
    mov       rax,	[rdi]
L928:
L925:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writeobj
pc_api.pcl_writeobj:
;?>>
   %define R.filename rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	1
    call      mc_genss.genss
    xor       eax,	eax
    mov       [pc_api.phighmem],	al
    call      msys.m$print_startcon
    lea       rcx,	[L12135]
    call      msys.m$print_str_nf
    movzx     rax,	byte [pc_api.phighmem]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mc_writeobj.writecoff
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [pc_decls.objtime],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writedll
pc_api.pcl_writedll:
;?>>
   %define R.filename rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       al,	2
    mov       [pc_api.phighmem],	al
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_writeexe.writeexe
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [pc_decls.exetime],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writeexe
pc_api.pcl_writeexe:
;?>>
   %define R.filename rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_writeexe.writeexe
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [pc_decls.exetime],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writemx
pc_api.pcl_writemx:
;?>>
   %define R.filename rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    mov       rcx,	rdi
    call      mx_write.writemcx
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_exec
pc_api.pcl_exec:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    lea       rcx,	[L12136]
    mov       rdx,	[pc_decls.pcmdskip]
    call      mx_run.runlibfile
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pcl_setflags
pc_api.pcl_setflags:
;?>>
   %define R.highmem rcx
   %define R.verbose rdx
   %define R.shortnames r8
;?]]
;---------------
    cmp       rcx,	0
    jl        L939
    mov       [pc_api.phighmem],	cl
L939:
    cmp       rdx,	0
    jl        L941
    mov       [pc_decls.pverbose],	dl
L941:
    cmp       r8,	0
    jl        L943
    mov       [pc_api.fpshortnames],	r8b
L943:
;---------------
    ret       
;End 
;Proc pc_api.extendpclblock
pc_api.extendpclblock:
;?>>
   %define R.newpcalloc rdi
   %define R.lengthused rbx
   %define R.newpcstart rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	1
    mov       rdi,	rax
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    inc       rax
    mov       rbx,	rax
    mov       rax,	32
    imul      rax,	rdi
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	rbx
    shl       rax,	5
    mov       rcx,	rsi
    mov       rdx,	[pc_api.pcstart]
    mov       r8,	rax
    call      memcpy
    mov       rax,	rdi
    sub       rax,	rbx
    shl       rax,	5
    mov       r10,	rbx
    shl       r10,	5
    lea       r11,	[rsi + r10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mlib.pcm_clearmem
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    shl       rax,	5
    lea       r10,	[rsi + rax]
    mov       [pc_api.pccurr],	r10
    mov       rax,	rdi
    shl       rax,	5
    lea       r10,	[rsi + rax]
    sub       r10,	256
    mov       [pc_api.pcend],	r10
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	5
    mov       rcx,	[pc_api.pcstart]
    mov       rdx,	rax
    call      mlib.pcm_free
    mov       [pc_api.pcstart],	rsi
    mov       [pc_api.pcalloc],	rdi
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.newpcl
pc_api.newpcl:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[pc_api.pccurr]
    cmp       rax,	[pc_api.pcend]
    jb        L947
    call      pc_api.extendpclblock
L947:
    add       qword [pc_api.pccurr],	32
    mov       eax,	[pc_decls.mmpos]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+24],	eax
    inc       qword [pc_api.pclseqno]
    mov       rax,	[pc_api.pclseqno]
    mov       r10,	[pc_api.pccurr]
    lea       r10,	[r10+28]
    mov       r9d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r9d,	r11d
    or        r9d,	eax
    mov       [r10],	r9d
    mov       rax,	[pc_api.pccurr]
L945:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pc_gen
pc_api.pc_gen:
;?>>
   %define R.opcode rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rbx,	rbx
    jnz       L950
    call      pc_api.newpcl
    mov       rbx,	rax
L950:
    mov       [rbx],	dil
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_genix
pc_api.pc_genix:
;?>>
   %define R.opcode rbx
   %define R.scale rsi
   %define R.offset r12
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	esi
    mov       [rdi+20],	r12d
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_genx
pc_api.pc_genx:
;?>>
   %define R.opcode rdi
   %define R.x rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    test      rsi,	rsi
    jnz       L954
    call      pc_api.newpcl
    mov       rsi,	rax
L954:
    mov       [rsi],	dil
    mov       [rsi+16],	ebx
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_genxy
pc_api.pc_genxy:
;?>>
   %define R.opcode rdi
   %define R.x rbx
   %define R.y rsi
   %define R.p r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    test      r12,	r12
    jnz       L957
    call      pc_api.newpcl
    mov       r12,	rax
L957:
    mov       [r12],	dil
    mov       [r12+16],	ebx
    mov       [r12+20],	esi
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_gencond
pc_api.pc_gencond:
;?>>
   %define R.opcode rdi
   %define R.cond rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    test      rsi,	rsi
    jnz       L960
    call      pc_api.newpcl
    mov       rsi,	rax
L960:
    mov       [rsi],	dil
    mov       [rsi+2],	bl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genint
pc_api.genint:
;?>>
   %define R.a rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	4
    mov       [rdi+1],	al
    mov       rax,	rdi
L961:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genreal
pc_api.genreal:
;?>>
   %define R.x XMM15
   %define R.mode rbx
   %define R.p rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    movq      XMM4,	XMM15
    movq      [rdi+8],	XMM4
    cmp       rbx,	2
    jnz       L964
    mov       rax,	5
    jmp       L963
L964:
    mov       rax,	6
L963:
    mov       [rdi+1],	al
    mov       rax,	rdi
L962:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genrealimm
pc_api.genrealimm:
;?>>
   %define R.x XMM15
   %define R.mode rbx
   %define R.p rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    movq      XMM4,	XMM15
    movq      [rdi+8],	XMM4
    cmp       rbx,	2
    jnz       L967
    mov       rax,	10
    jmp       L966
L967:
    mov       rax,	11
L966:
    mov       [rdi+1],	al
    mov       rax,	rdi
L965:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genstring
pc_api.genstring:
;?>>
   %define R.s rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi+8],	rax
    mov       al,	7
    mov       [rdi+1],	al
    mov       rax,	rdi
L968:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genpcstrimm
pc_api.genpcstrimm:
;?>>
   %define R.s rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi+8],	rax
    mov       al,	8
    mov       [rdi+1],	al
    mov       rax,	rdi
L969:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genlabel
pc_api.genlabel:
;?>>
   %define R.a rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	3
    mov       [rdi+1],	al
    mov       rax,	rdi
L970:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genmem
pc_api.genmem:
;?>>
   %define R.d rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	1
    mov       [rdi+1],	al
    mov       rax,	rdi
L971:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genmemaddr
pc_api.genmemaddr:
;?>>
   %define R.d rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	2
    mov       [rdi+1],	al
    mov       rax,	rdi
L972:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.gendata
pc_api.gendata:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	12
    mov       [rdi+1],	al
    mov       al,	11
    mov       [rdi+3],	al
    mov       [rdi+4],	esi
    mov       rax,	rdi
L973:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.gencomment
pc_api.gencomment:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       al,	[pc_decls.fregoptim]
    test      al,	al
    jnz       L977
    mov       al,	[pc_decls.fpeephole]
    test      al,	al
    jz        L976
L977:
    jmp       L974
L976:
    mov       rcx,	rdi
    call      pc_api.genpcstrimm
    mov       rcx,	135
    mov       rdx,	rax
    call      pc_api.pc_gen
L974:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.genname
pc_api.genname:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rcx,	rax
    call      pc_api.genmem
L978:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.gennameaddr
pc_api.gennameaddr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
L979:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.genassem
pc_api.genassem:
;?>>
   %define R.code rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	9
    mov       [rdi+1],	al
    mov       rax,	rdi
L980:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.strpmode
pc_api.strpmode:
;?>>
   %define R.mode rdi
   %define R.size rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rcx,	[pc_api.strpmode.str]
    lea       rdx,	[L12137]
    call      strcpy
    mov       rax,	rdi
    cmp       rax,	11
    jz        L983
    test      rax,	rax
    jz        L984
    jmp       L985
L983:
    lea       rcx,	[pc_api.strpmode.str]
    lea       rdx,	[L12138]
    call      strcpy
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[pc_api.strpmode.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[pc_api.strpmode.str]
    jmp       L982
L984:
    lea       rax,	[L12139]
    jmp       L982
L985:
    lea       rax,	[pc_tables.pstdnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
L982:
L981:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_setmode
pc_api.pc_setmode:
;?>>
   %define R.m rcx
   %define R.size rdx
;?]]
;---------------
    mov       al,	cl
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    test      rdx,	rdx
    jz        L988
    mov       eax,	edx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    jmp       L987
L988:
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax+3]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    mov       rax,	[pc_api.pccurr]
    mov       [rax+4],	r10d
L987:
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax]
    lea       r10,	[pc_tables.pclhastype]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	2
    jnz       L990
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax+3]
    mov       r10,	[pc_api.pccurr]
    lea       r10,	[r10+28]
    mov       r9d,	[r10]
    mov       r11,	-256
    and       r9d,	r11d
    or        r9d,	eax
    mov       [r10],	r9d
L990:
;---------------
    ret       
;End 
;Proc pc_api.pc_setmode2
pc_api.pc_setmode2:
;?>>
   %define R.m rcx
;?]]
;---------------
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+28]
    mov       r10d,	ecx
    mov       r9d,	[rax]
    mov       r11,	-256
    and       r9d,	r11d
    or        r9d,	r10d
    mov       [rax],	r9d
;---------------
    ret       
;End 
;Proc pc_api.pc_setxy
pc_api.pc_setxy:
;?>>
   %define R.x rcx
   %define R.y rdx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	edx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setscaleoff
pc_api.pc_setscaleoff:
;?>>
   %define R.scale rcx
   %define R.offset rdx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	edx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setoffset
pc_api.pc_setoffset:
;?>>
   %define R.offset rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_addoffset
pc_api.pc_addoffset:
;?>>
   %define R.offset rcx
;?]]
;---------------
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+20]
    mov       r10d,	ecx
    add       [rax],	r10d
;---------------
    ret       
;End 
;Proc pc_api.pc_setincr
pc_api.pc_setincr:
;?>>
   %define R.n rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setnargs
pc_api.pc_setnargs:
;?>>
   %define R.n rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setnvariadics
pc_api.pc_setnvariadics:
;?>>
   %define R.n rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setalign
pc_api.pc_setalign:
;?>>
   %define R.n rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
;---------------
    ret       
;End 
;Proc pc_api.perror
pc_api.perror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      pc_api.perror_s
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.perror_s
pc_api.perror_s:
;?>>
   %define R.mess rdi
   %define R.param rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12140]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    test      rbx,	rbx
    jz        L1003
    call      msys.m$print_startcon
    lea       rcx,	[L12141]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
L1003:
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.getbasename
pc_api.getbasename:
;?>>
   %define R.s rbx
   %define R.t rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      strlen
    lea       r10,	[rbx + rax]
    sub       r10,	1
    mov       rdi,	r10
    jmp       L1006
L1005:
    dec       rdi
L1006:
    cmp       rdi,	rbx
    jbe       L1008
    lea       rax,	[rdi-1]
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jnz       L1005
L1008:
    mov       rax,	rdi
L1004:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pclerror
pc_api.pclerror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12142]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_addsymbol
pc_api.pc_addsymbol:
;?>>
   %define R.d rcx
;?]]
;---------------
    mov       rax,	[pc_decls.psymboltable]
    test      rax,	rax
    jnz       L1012
    mov       rax,	rcx
    mov       [pc_decls.psymboltablex],	rax
    mov       [pc_decls.psymboltable],	rax
    jmp       L1011
L1012:
    mov       rax,	rcx
    mov       r10,	[pc_decls.psymboltablex]
    mov       [r10+8],	rax
    mov       [pc_decls.psymboltablex],	rcx
L1011:
;---------------
    ret       
;End 
;Proc pc_api.pc_makesymbol
pc_api.pc_makesymbol:
;?>>
   %define R.s rbx
   %define R.id rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    inc       qword [pc_api.stseqno]
    mov       rax,	[pc_api.stseqno]
    mov       [rdi+120],	eax
    mov       rax,	rsi
    cmp       rax,	1
    jz        L1015
    cmp       rax,	7
    jz        L1016
    jmp       L1017
L1015:
    mov       al,	1
    mov       [rdi+80],	al
    jmp       L1014
L1016:
    mov       al,	1
    mov       [rdi+81],	al
    mov       rsi,	2
L1017:
L1014:
    mov       [rdi+72],	sil
    mov       rax,	rsi
    cmp       rax,	4
    jz        L1020
    cmp       rax,	5
    jnz       L1019
L1020:
    mov       rax,	[pc_decls.currfunc]
    mov       [rdi+32],	rax
    jmp       L1018
L1019:
    test      rsi,	rsi
    jz        L1021
    mov       rcx,	rdi
    call      pc_api.pc_addsymbol
L1021:
L1018:
    mov       rax,	rdi
L1013:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.getfullname
pc_api.getfullname:
;?>>
   %define R.d rsi
   %define R.backtick r12
   %define R.n rdi
   %define R.e rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       rdi,	rdi
    mov       rax,	rsi
    mov       rbx,	rax
    xor       eax,	eax
    lea       r10,	[pc_api.getfullname.str]
    mov       [r10],	al
    test      r12,	r12
    jz        L1024
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[L12143]
    call      strcpy
L1024:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L1026
    test      r12,	r12
    jz        L1028
    mov       rax,	[rsi]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[L12144]
    call      strcat
    jmp       L1027
L1028:
    mov       rax,	[rsi]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
L1027:
    lea       rax,	[pc_api.getfullname.str]
    jmp       L1022
L1026:
    movzx     rax,	byte [rsi+72]
    cmp       rax,	4
    jz        L1031
    cmp       rax,	5
    jnz       L1030
L1031:
    mov       rax,	[rsi+32]
    mov       rax,	[rax]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[L12145]
    call      strcat
    mov       rax,	[rsi]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[pc_api.getfullname.str]
    jmp       L1022
L1030:
    test      r12,	r12
    jz        L1033
    mov       rax,	[rsi]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    jmp       L1032
L1033:
    mov       rax,	[rsi]
L1032:
L1022:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcerrorstop
pc_api.pcerrorstop:
;?>>
   %define R.filename rbx
   %define R.lineno rsi
   %define R.f rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rcx,	[L12146]
    lea       rdx,	[L12147]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      fclose
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_addplib
pc_api.pc_addplib:
;?>>
   %define R.name rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	50
    jl        L1037
    lea       rcx,	[L12148]
    call      pc_api.perror
L1037:
    mov       rcx,	rdi
    lea       rdx,	[L12149]
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    inc       qword [pc_decls.nplibfiles]
    mov       r10,	[pc_decls.nplibfiles]
    lea       r11,	[pc_decls.plibfiles]
    mov       [r11 + r10*8-8],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_defproc
pc_api.pc_defproc:
;?>>
   %define R.d rdi
   %define R.mode rbx
   %define R.isentry rsi
   %define R.threaded r12
    %define pc_api.pc_defproc.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rax,	[pc_decls.currfunc]
    test      rax,	rax
    jz        L1040
    lea       rcx,	[L12150]
    call      pc_api.pclerror
L1040:
    mov       rcx,	rdi
    call      pc_api.genmem
    mov       [rbp + pc_api.pc_defproc.$T1],	rax
    test      r12,	r12
    jz        L1042
    mov       rax,	121
    jmp       L1041
L1042:
    mov       rax,	120
L1041:
    mov       rcx,	rax
    mov       rdx,	[rbp + pc_api.pc_defproc.$T1]
    call      pc_api.pc_gen
    test      rbx,	rbx
    jnz       L1044
    movzx     rax,	byte [rdi+82]
    mov       rbx,	rax
L1044:
    mov       rcx,	rbx
    xor       edx,	edx
    call      pc_api.pc_setmode
    mov       rax,	[rdi+56]
    test      rax,	rax
    jz        L1046
    mov       rax,	[rdi]
    lea       rcx,	[L12151]
    mov       rdx,	rax
    call      pc_api.addstr
    mov       rcx,	rax
    call      pc_api.pclerror
L1046:
    mov       rax,	[pc_api.pccurr]
    mov       [rdi+56],	rax
    mov       rax,	[pc_decls.entryproc]
    test      rax,	rax
    jnz       L1048
    test      rsi,	rsi
    jz        L1048
    mov       [pc_decls.entryproc],	rdi
    mov       al,	1
    mov       [rdi+83],	al
L1048:
    mov       [pc_decls.currfunc],	rdi
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_setimport
pc_api.pc_setimport:
;?>>
   %define R.d rcx
;?]]
;---------------
    mov       [pc_decls.currfunc],	rcx
;---------------
    ret       
;End 
;Proc pc_api.pc_addparam
pc_api.pc_addparam:
;?>>
   %define R.d rsi
   %define R.p rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rdi,	[pc_decls.currfunc]
    test      rdi,	rdi
    jnz       L1052
    lea       rcx,	[L12152]
    call      pc_api.pclerror
L1052:
    mov       rbx,	[rdi+16]
    test      rbx,	rbx
    jnz       L1054
    mov       [rdi+16],	rsi
    jmp       L1053
L1054:
    jmp       L1056
L1055:
    mov       rbx,	[rbx+16]
L1056:
    mov       rax,	[rbx+16]
    test      rax,	rax
    jnz       L1055
    mov       [rbx+16],	rsi
L1053:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jnz       L1059
    mov       rax,	[pc_decls.currfunc]
    mov       [rsi+32],	rax
L1059:
    mov       rax,	[pc_decls.currfunc]
    lea       rax,	[rax+112]
    inc       byte [rax]
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_addlocal
pc_api.pc_addlocal:
;?>>
   %define R.d rsi
   %define R.p rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rdi,	[pc_decls.currfunc]
    test      rdi,	rdi
    jnz       L1062
    lea       rcx,	[L12152]
    call      pc_api.pclerror
L1062:
    mov       rbx,	[rdi+24]
    test      rbx,	rbx
    jnz       L1064
    mov       [rdi+24],	rsi
    jmp       L1063
L1064:
    jmp       L1066
L1065:
    mov       rbx,	[rbx+24]
L1066:
    mov       rax,	[rbx+24]
    test      rax,	rax
    jnz       L1065
    mov       [rbx+24],	rsi
L1063:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jnz       L1069
    mov       rax,	[pc_decls.currfunc]
    mov       [rsi+32],	rax
L1069:
    mov       rax,	[pc_decls.currfunc]
    lea       rax,	[rax+114]
    inc       word [rax]
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_endproc
pc_api.pc_endproc:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[pc_decls.currfunc]
    test      rax,	rax
    jnz       L1072
    lea       rcx,	[L12152]
    call      pc_api.pclerror
L1072:
    mov       rcx,	122
    xor       edx,	edx
    call      pc_api.pc_gen
    xor       eax,	eax
    mov       [pc_decls.currfunc],	rax
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.addstr
pc_api.addstr:
;?>>
   %define R.s rdi
   %define R.t rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rcx,	[pc_api.addstr.str]
    mov       rdx,	rdi
    call      strcpy
    lea       rcx,	[pc_api.addstr.str]
    mov       rdx,	rbx
    call      strcat
    lea       rax,	[pc_api.addstr.str]
L1073:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.merror
pc_api.merror:
;?>>
   %define R.mess rbx
   %define R.param rsi
   %define R.lineno rdi
    %define pc_api.merror.filename -8
    %define pc_api.merror.sourceline -16
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rax,	[pc_decls.igetmsourceinfo]
    test      rax,	rax
    jz        L1076
    mov       rcx,	[pc_decls.mmpos]
    lea       rdx,	[rbp + pc_api.merror.filename]
    lea       r8,	[rbp + pc_api.merror.sourceline]
    mov       rax,	[pc_decls.igetmsourceinfo]
    call      rax
    mov       rdi,	rax
    call      msys.m$print_startcon
    lea       rcx,	[L12153]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12154]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L1075
L1076:
    xor       rdi,	rdi
    lea       rax,	[L12155]
    mov       [rbp + pc_api.merror.filename],	rax
L1075:
    mov       rax,	[pc_decls.currfunc]
    test      rax,	rax
    jz        L1078
    call      msys.m$print_startcon
    lea       rcx,	[L12156]
    call      msys.m$print_str_nf
    mov       rax,	[pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1078:
    call      msys.m$print_startcon
    lea       rcx,	[L12157]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    mov       rcx,	[rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    mov       rcx,	[pc_decls.ppseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_api.merror.filename]
    mov       rdx,	rdi
    call      pc_api.pcerrorstop
;---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_duplpst
pc_api.pc_duplpst:
;?>>
   %define R.d rbx
   %define R.e rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	rbx
    push      rdi
    mov       r11,	16
L12158:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L12158
    pop       rdi
    inc       qword [pc_api.stseqno]
    mov       rax,	[pc_api.stseqno]
    mov       [rdi+120],	eax
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	rdi
L1079:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_cmdskip
pc_api.pcl_cmdskip:
;?>>
   %define R.cmdskip rcx
    %define pc_api.pcl_cmdskip.dcmdskip 24
;?]]
;---------------
    mov       [pc_decls.pcmdskip],	rcx
;---------------
    ret       
;End 
;Proc pc_api.convertstring
pc_api.convertstring:
;?>>
   %define R.s rsi
   %define R.t r12
   %define R.c rdi
   %define R.t0 rbx
    %define pc_api.convertstring.str -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rbx,	r12
    jmp       L1083
L1082:
    mov       rax,	rdi
    cmp       rax,	34
    jz        L1086
    cmp       rax,	10
    jz        L1087
    cmp       rax,	13
    jz        L1088
    cmp       rax,	9
    jz        L1089
    cmp       rax,	92
    jz        L1090
    cmp       rax,	7
    jz        L1091
    cmp       rax,	8
    jz        L1091
    cmp       rax,	26
    jz        L1091
    cmp       rax,	27
    jz        L1091
    jmp       L1092
L1086:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	34
    mov       [rax],	r10b
    jmp       L1085
L1087:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	110
    mov       [rax],	r10b
    jmp       L1085
L1088:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	114
    mov       [rax],	r10b
    jmp       L1085
L1089:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	116
    mov       [rax],	r10b
    jmp       L1085
L1090:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    jmp       L1085
L1091:
    mov       rax,	r12
    inc       r12
    mov       r10b,	60
    mov       [rax],	r10b
    mov       rax,	rdi
    mov       r10,	10
    cqo       
    idiv      r10
    add       rax,	48
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       rax,	rdi
    mov       r10,	10
    cqo       
    idiv      r10
    xchg      rax,	rdx
    add       rax,	48
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       rax,	r12
    inc       r12
    mov       r10b,	62
    mov       [rax],	r10b
    jmp       L1085
L1092:
    mov       rax,	rdi
    cmp       rax,	32
    jl        L1094
    cmp       rax,	126
    jg        L1094
    mov       rax,	r12
    inc       r12
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L1093
L1094:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	120
    mov       [rax],	r10b
    lea       rcx,	[rbp + pc_api.convertstring.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    lea       rdx,	[L12159]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       al,	[rbp + pc_api.convertstring.str]
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       al,	[rbp + pc_api.convertstring.str+1]
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
L1093:
L1085:
L1083:
    mov       rax,	rsi
    inc       rsi
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    test      rax,	rax
    jnz       L1082
    xor       eax,	eax
    mov       [r12],	al
    mov       rax,	r12
    sub       rax,	rbx
L1081:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.strpcl
pc_diags.strpcl:
;?>>
    %define pc_diags.strpcl.p 64
    %define pc_diags.strpcl.str -256
   %define R.opcode rdi
   %define R.n rbx
   %define R.x rsi
   %define R.y r12
   %define R.d r13
   %define R.e r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	127
    jz        L1097
    cmp       rax,	128
    jz        L1098
    cmp       rax,	135
    jz        L1099
    cmp       rax,	120
    jz        L1100
    cmp       rax,	121
    jz        L1100
    cmp       rax,	122
    jz        L1101
    cmp       rax,	136
    jz        L1102
    cmp       rax,	125
    jz        L1103
    cmp       rax,	123
    jz        L1104
    cmp       rax,	124
    jz        L1104
    jmp       L1105
L1097:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	1
    call      pc_diags.strlabel
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       eax,	[rax+16]
    test      eax,	eax
    jz        L1107
    lea       rcx,	[L12160]
    call      pc_diags.psstr
L1107:
    jmp       L1095
L1098:
    lea       rcx,	[L12161]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[L12162]
    call      pc_diags.psstr
    jmp       L1095
L1099:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       al,	[rax]
    test      al,	al
    jz        L1109
    lea       rcx,	[L12163]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rcx,	[rax+8]
    call      pc_diags.psstr
    jmp       L1108
L1109:
    lea       rcx,	[L12164]
    call      pc_diags.psstr
L1108:
    jmp       L1095
L1100:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r13,	[rax+8]
    cmp       rdi,	121
    jnz       L1111
    lea       rcx,	[L12165]
    call      pc_diags.psstr
    jmp       L1110
L1111:
    lea       rcx,	[L12166]
    call      pc_diags.psstr
L1110:
    lea       rcx,	[L12167]
    call      pc_diags.psstr
    mov       rcx,	r13
    call      pc_diags.psname
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       al,	[rax+81]
    test      al,	al
    jz        L1113
    lea       rax,	[L12168]
    jmp       L1112
L1113:
    lea       rax,	[L12169]
L1112:
    mov       rcx,	rax
    call      pc_diags.psstr
    mov       al,	[r13+83]
    test      al,	al
    jz        L1115
    lea       rcx,	[L12169]
    call      pc_diags.psstr
L1115:
    call      pc_diags.psline
    mov       r14,	[r13+16]
    jmp       L1119
L1116:
    lea       rcx,	[L12170]
    call      pc_diags.psstr
    mov       eax,	[r14+84]
    movzx     r10,	byte [r14+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[L12171]
    call      pc_diags.psstr
    mov       rcx,	[r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       r14,	[r14+16]
L1119:
    test      r14,	r14
    jnz       L1116
    mov       r14,	[r13+24]
    jmp       L1123
L1120:
    lea       rcx,	[L12172]
    call      pc_diags.psstr
    mov       eax,	[r14+84]
    movzx     r10,	byte [r14+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[L12173]
    call      pc_diags.psstr
    mov       rcx,	[r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       r14,	[r14+24]
L1123:
    test      r14,	r14
    jnz       L1120
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1125
    lea       rcx,	[L12174]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+3]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    call      pc_diags.psline
L1125:
    mov       al,	[r13+113]
    test      al,	al
    jz        L1127
    lea       rcx,	[L12175]
    call      pc_diags.psstrline
L1127:
    jmp       L1095
L1101:
    lea       rcx,	[L12176]
    call      pc_diags.psstr
    call      pc_diags.psline
    jmp       L1095
L1102:
    lea       rcx,	[L12177]
    call      pc_diags.psstr
    jmp       L1095
L1103:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+3]
    cmp       rax,	11
    jnz       L1129
    mov       rcx,	[rbp + pc_diags.strpcl.p]
    call      pc_diags.psdata
    jmp       L1095
L1129:
    jmp       L1096
L1104:
    jmp       L1130
L1105:
L1096:
    lea       rcx,	[L12178]
    call      pc_diags.psstr
;pc_diags.strpcl.skiptab:
L1130:
    mov       rax,	rdi
    cmp       rax,	26
    jz        L1132
    cmp       rax,	31
    jz        L1133
    jmp       L1134
L1132:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12179]
    call      strcpy
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+2]
    lea       r10,	[pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r10
    call      strcat
    jmp       L1131
L1133:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12180]
    call      strcpy
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+2]
    lea       r10,	[pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r10
    call      strcat
    jmp       L1131
L1134:
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcpy
L1131:
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	9
    mov       r9,	32
    call      mlib.gs_leftstr
    xor       eax,	eax
    mov       [rbp + pc_diags.strpcl.str],	al
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1136
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       eax,	[rax+4]
    mov       r10,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [r10+3]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[pc_tables.pclhastype]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10]
    cmp       rax,	2
    jnz       L1138
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12181]
    call      strcat
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword [rax+28]
    and       rax,	255
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1138:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12182]
    call      strcat
L1136:
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	4
    mov       r9,	32
    call      mlib.gs_leftstr
    xor       eax,	eax
    mov       [rbp + pc_diags.strpcl.str],	al
    lea       rax,	[pc_tables.pclextra]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10]
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L1140
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword [rax+16]
    mov       rsi,	rax
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword [rax+20]
    mov       r12,	rax
    test      rsi,	rsi
    jnz       L1143
    cmp       rbx,	2
    jnz       L1142
L1143:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12183]
    call      strcat
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword [rax+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1142:
    cmp       rbx,	2
    jnz       L1145
    test      r12,	r12
    jz        L1145
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12183]
    call      strcat
    mov       rcx,	r12
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1145:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12184]
    call      strcat
L1140:
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	5
    mov       r9,	32
    call      mlib.gs_leftstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+1]
    test      rax,	rax
    jz        L1147
    lea       rcx,	[L12184]
    call      pc_diags.psstr
    mov       rcx,	[rbp + pc_diags.strpcl.p]
    call      pc_diags.stropnd
    mov       rcx,	rax
    call      pc_diags.psstr
L1147:
    mov       rcx,	40
    call      pc_diags.pstabto
L1095:
;---------------
    add       rsp,	288
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.stropnd
pc_diags.stropnd:
;?>>
   %define R.p rsi
   %define R.length rdi
   %define R.d rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    test      rsi,	rsi
    jnz       L1150
    lea       rax,	[L12185]
    jmp       L1148
L1150:
    xor       eax,	eax
    lea       r10,	[pc_diags.stropnd.str]
    mov       [r10],	al
    movzx     rax,	byte [rsi+1]
    cmp       rax,	4
    jz        L1152
    cmp       rax,	5
    jz        L1153
    cmp       rax,	10
    jz        L1153
    cmp       rax,	11
    jz        L1153
    cmp       rax,	6
    jz        L1153
    cmp       rax,	7
    jz        L1154
    cmp       rax,	1
    jz        L1155
    cmp       rax,	2
    jz        L1156
    cmp       rax,	3
    jz        L1157
    test      rax,	rax
    jz        L1158
    cmp       rax,	9
    jz        L1159
    cmp       rax,	12
    jz        L1160
    jmp       L1161
L1152:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    jmp       L1148
L1153:
    movq      XMM4,	[rsi+8]
    comisd    XMM4,	[L12186]
    jnz       L1163
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12187]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L1162
L1163:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    lea       rdx,	[L12188]
    call      msys.m$print_r64
    call      msys.m$print_end
L1162:
    jmp       L1151
L1154:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      strlen
    mov       rdi,	rax
    cmp       rax,	256
    jge       L1165
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12189]
    call      strcpy
    lea       rax,	[pc_diags.stropnd.str]
    lea       rax,	[rax+1]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.convertstring
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12189]
    call      strcat
    jmp       L1164
L1165:
    mov       rax,	[pc_diags.stropnd.longstring]
    test      rax,	rax
    jz        L1167
    mov       rcx,	[pc_diags.stropnd.longstring]
    mov       rdx,	[pc_api.longstringlen]
    call      mlib.pcm_free
L1167:
    mov       rax,	rdi
    shl       rax,	1
    mov       [pc_api.longstringlen],	rax
    mov       rcx,	[pc_api.longstringlen]
    call      mlib.pcm_alloc
    mov       [pc_diags.stropnd.longstring],	rax
    mov       al,	34
    mov       r10,	[pc_diags.stropnd.longstring]
    mov       [r10],	al
    mov       rax,	[pc_diags.stropnd.longstring]
    lea       rax,	[rax+1]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.convertstring
    mov       rdi,	rax
    mov       al,	34
    mov       r10,	[pc_diags.stropnd.longstring]
    mov       r11,	rdi
    mov       [r10 + r11+1],	al
    xor       eax,	eax
    mov       r10,	[pc_diags.stropnd.longstring]
    mov       r11,	rdi
    mov       [r10 + r11+2],	al
    mov       rax,	[pc_diags.stropnd.longstring]
    jmp       L1148
L1164:
    jmp       L1151
L1155:
    mov       rbx,	[rsi+8]
    mov       rax,	[rsi+8]
    mov       rax,	[rax]
    lea       rcx,	[pc_diags.stropnd.str]
    mov       rdx,	rax
    call      strcat
    movzx     rax,	byte [rsi]
    cmp       rax,	123
    jz        L1170
    cmp       rax,	124
    jnz       L1169
L1170:
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12190]
    call      strcat
    mov       al,	[rbx+81]
    test      al,	al
    jz        L1172
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12190]
    call      strcat
L1172:
L1169:
    jmp       L1151
L1156:
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12191]
    call      strcpy
    jmp       L1155
L1157:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12192]
    call      msys.m$print_setfmt
    lea       rcx,	[L12193]
    call      msys.m$print_str_nf
    mov       rcx,	[rsi+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L1151
L1158:
    lea       rax,	[L12194]
    jmp       L1148
L1159:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    jmp       L1148
L1160:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12195]
    call      msys.m$print_setfmt
    mov       eax,	[rsi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    mov       rcx,	[rsi+8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L1151
L1161:
    call      msys.m$print_startcon
    lea       rcx,	[L12196]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rsi+1]
    lea       r10,	[pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[L12197]
    jmp       L1148
L1151:
    lea       rax,	[pc_diags.stropnd.str]
L1148:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.strpclstr
pc_diags.strpclstr:
;?>>
   %define R.p rdi
   %define R.buffsize rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_free
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_init
    xor       eax,	eax
    mov       [pc_diags.destlinestart],	rax
    mov       rcx,	rdi
    call      pc_diags.strpcl
    mov       rcx,	[pc_diags.dest]
    xor       edx,	edx
    call      mlib.gs_char
    mov       rax,	[pc_diags.dest]
    movsxd    rax,	dword [rax+8]
    cmp       rax,	rbx
    jl        L1175
    lea       rax,	[L12198]
    jmp       L1173
L1175:
    mov       rax,	[pc_diags.dest]
    mov       rax,	[rax]
L1173:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.writepcl
pc_diags.writepcl:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_diags.strpcl
    movzx     rax,	byte [rdi]
    cmp       rax,	120
    jnz       L1179
L1178:
    jmp       L1177
L1179:
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
L1177:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.writeallpcl
pc_diags.writeallpcl:
;?>>
   %define R.p rdi
   %define R.d rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_init
    mov       rax,	[pc_diags.dest]
    movsxd    rax,	dword [rax+8]
    mov       [pc_diags.destlinestart],	rax
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[L12199]
    call      mlib.gs_strln
    mov       rsi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1183
L1181:
    lea       rcx,	[L12200]
    call      pc_diags.psstr
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      pc_diags.psstr
    lea       rcx,	[L12201]
    call      pc_diags.psstr
    call      pc_diags.psline
    inc       rsi
    cmp       rsi,	[pc_decls.nplibfiles]
    jle       L1181
L1183:
    mov       rax,	[pc_decls.nplibfiles]
    test      rax,	rax
    jz        L1185
    call      pc_diags.psline
L1185:
    mov       rbx,	[pc_decls.psymboltable]
    jmp       L1189
L1186:
    movzx     rax,	byte [rbx+72]
    cmp       rax,	1
    jnz       L1191
    lea       rcx,	[L12202]
    call      pc_diags.psstr
    mov       rcx,	[rbx]
    call      pc_diags.psstr
    mov       al,	[rbx+113]
    test      al,	al
    jz        L1193
    lea       rcx,	[L12203]
    call      pc_diags.psstr
L1193:
    call      pc_diags.psline
L1191:
    mov       rbx,	[rbx+8]
L1189:
    test      rbx,	rbx
    jnz       L1186
    mov       rdi,	[pc_api.pcstart]
    jmp       L1195
L1194:
    mov       rcx,	rdi
    call      pc_diags.writepcl
    mov       rax,	[pc_diags.dest]
    movsxd    rax,	dword [rax+8]
    mov       [pc_diags.destlinestart],	rax
    add       rdi,	32
L1195:
    cmp       rdi,	[pc_api.pccurr]
    jbe       L1194
    call      pc_diags.psline
    mov       rax,	[pc_api.longstring]
    test      rax,	rax
    jz        L1198
    mov       rcx,	[pc_api.longstring]
    mov       rdx,	[pc_api.longstringlen]
    call      mlib.pcm_free
L1198:
    mov       rax,	[pc_diags.dest]
L1180:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.psstr
pc_diags.psstr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rdi
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.psstrline
pc_diags.psstrline:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rdi
    call      mlib.gs_str
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.psline
pc_diags.psline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[L12204]
    call      mlib.gs_str
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_diags.psint
pc_diags.psint:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rax
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.psname
pc_diags.psname:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi]
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rax
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.pstabto
pc_diags.pstabto:
;?>>
   %define R.n rbx
   %define R.col rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	[pc_diags.dest]
    movsxd    rax,	dword [rax+8]
    sub       rax,	[pc_diags.destlinestart]
    mov       rdi,	rax
    jmp       L1206
L1205:
    lea       rcx,	[L12205]
    call      pc_diags.psstr
    inc       rdi
L1206:
    cmp       rbx,	rdi
    jg        L1205
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.strlabel
pc_diags.strlabel:
;?>>
   %define R.labelno rdi
   %define R.colon rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rcx,	[L12206]
    call      pc_diags.psstr
    mov       rcx,	rdi
    call      pc_diags.psint
    test      rbx,	rbx
    jz        L1210
    lea       rcx,	[L12207]
    call      pc_diags.psstr
L1210:
    lea       rcx,	[L12208]
    call      pc_diags.psstr
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.psopnd
pc_diags.psopnd:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_diags.stropnd
    mov       rcx,	rax
    call      pc_diags.psstr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.psdata
pc_diags.psdata:
;?>>
   %define R.p r13
   %define R.n rdi
   %define R.m rbx
   %define R.q rsi
   %define R.av_1 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       eax,	[r13+4]
    mov       rdi,	rax
    mov       rsi,	[r13+8]
    test      rdi,	rdi
    jnz       L1214
    jmp       L1212
L1214:
    jmp       L1216
L1215:
    mov       rbx,	rdi
    cmp       rbx,	20
    jl        L1219
    mov       rbx,	20
L1219:
    mov       rax,	rbx
    sub       rdi,	rax
    lea       rcx,	[L12209]
    call      pc_diags.psstr
    mov       rcx,	rbx
    call      pc_diags.psint
    lea       rcx,	[L12210]
    call      pc_diags.psstr
    cmp       rbx,	10
    jge       L1221
    lea       rcx,	[L12211]
    call      pc_diags.psstr
L1221:
    mov       r12,	rbx
    cmp       r12,	0
    jle       L1224
L1222:
    movzx     rax,	byte [rsi]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[L12211]
    call      pc_diags.psstr
    inc       rsi
    dec       r12
    jnz       L1222
L1224:
    test      rdi,	rdi
    jz        L1226
    call      pc_diags.psline
L1226:
L1216:
    cmp       rdi,	0
    jg        L1215
L1212:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.writepst
pc_diags.writepst:
;?>>
   %define R.localfile dil
   %define R.i rbx
   %define R.j rsi
   %define R.d r12
   %define R.e r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    xor       dil,	dil
    xor       eax,	eax
    mov       rbx,	rax
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_init
    lea       rcx,	[L12212]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       r12,	[pc_decls.psymboltable]
    jmp       L1231
L1228:
    mov       rcx,	r12
    lea       rdx,	[L12213]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[L12214]
    call      pc_diags.psstr
    mov       rcx,	r12
    lea       rdx,	[L12215]
    call      pc_diags.writepsymbol
    movzx     rax,	byte [r12+72]
    cmp       rax,	2
    jz        L1234
    cmp       rax,	1
    jnz       L1233
L1234:
    mov       r13,	[r12+16]
    xor       rsi,	rsi
    jmp       L1238
L1235:
    lea       rcx,	[L12216]
    call      pc_diags.psstr
    mov       rcx,	r13
    lea       rdx,	[L12217]
    call      pc_diags.writepsymbol
    mov       r13,	[r13+16]
L1238:
    test      r13,	r13
    jnz       L1235
    mov       r13,	[r12+24]
    xor       rsi,	rsi
    jmp       L1242
L1239:
    lea       rcx,	[L12218]
    call      pc_diags.psstr
    mov       rcx,	r13
    lea       rdx,	[L12219]
    call      pc_diags.writepsymbol
    mov       r13,	[r13+24]
L1242:
    test      r13,	r13
    jnz       L1239
L1233:
    call      pc_diags.psline
    mov       r12,	[r12+8]
L1231:
    test      r12,	r12
    jnz       L1228
    call      pc_diags.psline
    mov       rax,	[pc_diags.dest]
L1227:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.writepsymbol
pc_diags.writepsymbol:
;?>>
   %define R.d rsi
   %define R.fmt r12
   %define R.localfile dil
    %define pc_diags.writepsymbol.str -256
   %define R.av_1 rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       dil,	dil
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       eax,	[rsi+120]
    mov       rcx,	rax
    lea       rdx,	[L12220]
    call      msys.m$print_i64
    movzx     rax,	byte [rsi+72]
    lea       r10,	[pc_tables.idnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    movzx     rax,	byte [rsi+72]
    lea       r10,	[pc_tables.idnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      strlen
    mov       r10,	8
    sub       r10,	rax
    mov       rbx,	r10
    cmp       rbx,	0
    jle       L1246
L1244:
    lea       rcx,	[L12221]
    call      pc_diags.psstr
    dec       rbx
    jnz       L1244
L1246:
    xor       eax,	eax
    mov       [rbp + pc_diags.writepsymbol.str],	al
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       rax,	[rsi]
    mov       rcx,	rax
    mov       rdx,	r12
    call      msys.m$print_str
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    mov       eax,	[rsi+84]
    movzx     r10,	byte [rsi+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    movzx     rax,	byte [rsi+72]
    cmp       rax,	2
    jnz       L1248
    lea       rcx,	[L12222]
    call      pc_diags.psstr
    movzx     rax,	byte [rsi+112]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[L12223]
    call      pc_diags.psstr
    movsx     rax,	word [rsi+114]
    mov       rcx,	rax
    call      pc_diags.psint
L1248:
    mov       al,	[rsi+81]
    test      al,	al
    jz        L1250
    lea       rcx,	[L12224]
    call      pc_diags.psstr
L1250:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L1252
    lea       rcx,	[L12225]
    call      pc_diags.psstr
L1252:
    mov       al,	[rsi+107]
    test      al,	al
    jz        L1254
    lea       rcx,	[L12226]
    call      pc_diags.psstr
    movzx     rax,	byte [rsi+107]
    mov       rcx,	rax
    call      pc_diags.psint
L1254:
    mov       al,	[rsi+108]
    test      al,	al
    jz        L1256
    lea       rcx,	[L12227]
    call      pc_diags.psstr
L1256:
    mov       al,	[rsi+95]
    test      al,	al
    jz        L1258
    lea       rcx,	[L12228]
    call      pc_diags.psstr
L1258:
    mov       al,	[rsi+83]
    test      al,	al
    jz        L1260
    lea       rcx,	[L12229]
    call      pc_diags.psstr
L1260:
    movzx     rax,	byte [rsi+72]
    cmp       rax,	2
    jnz       L1262
    lea       rcx,	[L12230]
    call      pc_diags.psstr
    mov       rax,	[rsi+56]
    mov       rcx,	rax
    lea       rdx,	[L12231]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
L1262:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jz        L1264
    lea       rcx,	[L12232]
    call      pc_diags.psstr
    mov       rax,	[rsi+32]
    mov       eax,	[rax+120]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[L12233]
    call      pc_diags.psstr
    mov       rax,	[rsi+32]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[L12234]
    call      pc_diags.psstr
L1264:
    xor       eax,	eax
    test      ax,	ax
    jz        L1266
    movzx     rax,	byte [rsi+72]
    cmp       rax,	3
    jnz       L1266
    mov       rax,	[rsi+56]
    test      rax,	rax
    jz        L1266
    lea       rcx,	[L12235]
    call      pc_diags.psstr
    mov       rax,	[rsi+56]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[L12236]
    call      pc_diags.psstr
    mov       rax,	[rsi+24]
    mov       rcx,	rax
    lea       rdx,	[L12237]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[L12238]
    call      pc_diags.psstr
L1266:
    xor       eax,	eax
    test      ax,	ax
    jz        L1268
    movzx     rax,	byte [rsi+72]
    cmp       rax,	2
    jnz       L1268
    movzx     rax,	byte [rsi+104]
    shr       eax,	1
    and       eax,	1
    test      rax,	rax
    jz        L1268
    lea       rcx,	[L12239]
    call      pc_diags.psstr
L1268:
    call      pc_diags.psline
;---------------
    add       rsp,	288
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.showprocinfo
pc_diags.showprocinfo:
;?>>
   %define R.d rsi
    %define pc_diags.showprocinfo.str -256
   %define R.p rdi
   %define R.e rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rsi,	rcx
;---------------
    mov       rdi,	[rsi+48]
    test      rdi,	rdi
    jnz       L1271
    jmp       L1269
L1271:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12240]
    call      msys.m$print_setfmt
    mov       rcx,	[rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12241]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+1]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12242]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+2]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12243]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+3]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12244]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12245]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+5]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12246]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+6]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12247]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+7]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       rbx,	[rsi+16]
    jmp       L1275
L1272:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12248]
    call      msys.m$print_setfmt
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+92]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte [rbx+88]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       rbx,	[rbx+16]
L1275:
    test      rbx,	rbx
    jnz       L1272
    mov       rbx,	[rsi+24]
    jmp       L1279
L1276:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12249]
    call      msys.m$print_setfmt
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+92]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte [rbx+88]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       rbx,	[rbx+24]
L1279:
    test      rbx,	rbx
    jnz       L1276
    call      pc_diags.psline
L1269:
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_reduce.pcl_reducetest
pc_reduce.pcl_reducetest:
;?>>
   %define R.nn rdi
   %define R.seqno rbx
   %define R.lab rsi
   %define R.nargs r12
   %define R.pc r13
   %define R.newpc r14
   %define R.pcnext r15
    %define pc_reduce.pcl_reducetest.pcproc -8
    %define pc_reduce.pcl_reducetest.labelmap -16
    %define pc_reduce.pcl_reducetest.pdef -24
    %define pc_reduce.pcl_reducetest.callstack -280
    %define pc_reduce.pcl_reducetest.ncall -288
    %define pc_reduce.pcl_reducetest.nprocs -296
    %define pc_reduce.pcl_reducetest.nleaf -304
    %define pc_reduce.pcl_reducetest.nallparams -312
    %define pc_reduce.pcl_reducetest.nalllocals -320
    %define pc_reduce.pcl_reducetest.av_1 -328
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	360
;---------------
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nprocs],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nleaf],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nallparams],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nalllocals],	rax
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    inc       rax
    mov       rdi,	rax
    mov       r13,	[pc_api.pcstart]
    mov       rax,	[pc_api.mlabelno]
    shl       rax,	1
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [rbp + pc_reduce.pcl_reducetest.labelmap],	rax
    jmp       L1284
L1281:
    movzx     rax,	byte [r13]
    cmp       rax,	127
    jz        L1286
    cmp       rax,	42
    jz        L1287
    jmp       L1288
L1286:
    jmp       L1285
L1287:
    mov       rax,	[pc_api.icheckasmlabel]
    test      rax,	rax
    jz        L1290
    mov       rax,	[r13+8]
    mov       rcx,	rax
    mov       r10,	[pc_api.icheckasmlabel]
    call      r10
    mov       rsi,	rax
    test      rsi,	rsi
    jz        L1292
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       r10,	rsi
    lea       rax,	[rax + r10*2-2]
    inc       word [rax]
L1292:
L1290:
    jmp       L1285
L1288:
    movzx     rax,	byte [r13+1]
    cmp       rax,	3
    jnz       L1294
    mov       rax,	[r13+8]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    lea       r10,	[r10 + rax*2-2]
    inc       word [r10]
L1294:
L1285:
    add       r13,	32
L1284:
    cmp       r13,	[pc_api.pccurr]
    jbe       L1281
;pc_reduce.pcl_reducetest.skip:
    mov       r13,	[pc_api.pcstart]
    mov       rax,	[pc_api.pcstart]
    sub       rax,	32
    mov       r14,	rax
    xor       rbx,	rbx
    mov       rax,	rdi
    mov       [rbp + pc_reduce.pcl_reducetest.av_1],	rax
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.av_1]
    cmp       rax,	0
    jle       L1298
L1296:
    lea       rax,	[r13+32]
    mov       r15,	rax
    movzx     rax,	byte [r13]
    lea       r10,	[pc_tables.pclargs]
    movzx     r10,	byte [r10 + rax]
    mov       r12,	r10
    test      r10,	r10
    jz        L1300
    cmp       r12,	9
    jnz       L1302
    movsxd    rax,	dword [r13+16]
    mov       r12,	rax
L1302:
    mov       rax,	[pc_decls.pinfo]
    movzx     rax,	byte [rax+4]
    mov       r10,	r12
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+4],	al
L1300:
    movzx     rax,	byte [r13+3]
    cmp       rax,	11
    jnz       L1304
    mov       rax,	[pc_decls.pinfo]
    test      rax,	rax
    jz        L1304
    mov       eax,	[r13+4]
    cmp       rax,	16
    jz        L1304
    mov       al,	1
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+7],	al
L1304:
    movzx     rax,	byte [r13]
    cmp       rax,	135
    jz        L1306
    cmp       rax,	127
    jz        L1307
    cmp       rax,	120
    jz        L1308
    cmp       rax,	121
    jz        L1308
    cmp       rax,	18
    jz        L1309
    cmp       rax,	21
    jz        L1309
    cmp       rax,	19
    jz        L1309
    cmp       rax,	22
    jz        L1309
    cmp       rax,	131
    jz        L1310
    cmp       rax,	122
    jz        L1311
    cmp       rax,	42
    jz        L1312
    cmp       rax,	2
    jz        L1313
    cmp       rax,	5
    jz        L1313
    cmp       rax,	114
    jz        L1314
    cmp       rax,	113
    jz        L1315
    cmp       rax,	1
    jz        L1316
    jmp       L1317
L1306:
    jmp       L1305
L1307:
    mov       rax,	[r13+8]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       r10w,	[r10 + rax*2-2]
    test      r10w,	r10w
    jz        L1319
    jmp       L1317
L1319:
    jmp       L1305
L1308:
    inc       qword [rbp + pc_reduce.pcl_reducetest.nprocs]
    mov       rax,	[r13+8]
    mov       [rbp + pc_reduce.pcl_reducetest.pdef],	rax
    lea       rax,	[r14+32]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [r10+56],	rax
    mov       rcx,	8
    call      mlib.pcm_alloc
    mov       [pc_decls.pinfo],	rax
    mov       rax,	[pc_decls.pinfo]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [r10+48],	rax
    mov       al,	1
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+3],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       al,	[rax+112]
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       ax,	[rax+114]
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+2],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    movzx     rax,	byte [rax+112]
    add       [rbp + pc_reduce.pcl_reducetest.nallparams],	rax
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    movsx     rax,	word [rax+114]
    add       [rbp + pc_reduce.pcl_reducetest.nalllocals],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.ncall],	rax
    lea       rax,	[r14+32]
    mov       [rbp + pc_reduce.pcl_reducetest.pcproc],	rax
    jmp       L1317
    jmp       L1305
L1309:
    xor       eax,	eax
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+3],	al
    dec       qword [rbp + pc_reduce.pcl_reducetest.ncall]
    jmp       L1317
    jmp       L1305
L1310:
    add       r14,	32
    mov       rax,	r13
    mov       r10,	[rax]
    mov       [r14],	r10
    mov       r10,	[rax+8]
    mov       [r14+8],	r10
    mov       r10,	[rax+16]
    mov       [r14+16],	r10
    mov       r10,	[rax+24]
    mov       [r14+24],	r10
    inc       rbx
    mov       rax,	rbx
    lea       r10,	[r14+28]
    mov       r8d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r8d,	r11d
    or        r8d,	eax
    mov       [r10],	r8d
    inc       qword [rbp + pc_reduce.pcl_reducetest.ncall]
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.ncall]
    mov       r10,	r14
    mov       [rbp + rax*8 + pc_reduce.pcl_reducetest.callstack-8],	r10
    jmp       L1305
L1311:
    mov       rax,	[pc_decls.pinfo]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1321
    inc       qword [rbp + pc_reduce.pcl_reducetest.nleaf]
L1321:
    xor       eax,	eax
    mov       [pc_decls.pinfo],	rax
    jmp       L1317
    jmp       L1305
L1312:
    mov       al,	1
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+5],	al
    jmp       L1317
    jmp       L1305
L1313:
    movzx     rax,	byte [r14]
    cmp       rax,	57
    jnz       L1323
    movzx     rax,	byte [r13+3]
    cmp       rax,	11
    jz        L1323
    mov       al,	[r13+3]
    mov       [r14+3],	al
    movzx     rax,	byte [r13]
    cmp       rax,	2
    jnz       L1325
    mov       rax,	3
    jmp       L1324
L1325:
    mov       rax,	6
L1324:
    mov       [r14],	al
    jmp       L1322
L1323:
    jmp       L1317
L1322:
    jmp       L1305
L1314:
    movzx     rax,	byte [r15]
    cmp       rax,	113
    jnz       L1327
    movsxd    rax,	dword [r13+28]
    and       rax,	255
    movsxd    r10,	dword [r15+28]
    and       r10,	255
    cmp       rax,	r10
    jnz       L1327
    add       r13,	32
    jmp       L1326
L1327:
    movzx     rax,	byte [r15]
    cmp       rax,	28
    jz        L1329
    cmp       rax,	27
    jnz       L1328
L1329:
    movsxd    rax,	dword [r13+28]
    and       rax,	255
    mov       [r15+3],	al
    jmp       L1326
L1328:
    jmp       L1317
L1326:
    jmp       L1305
L1315:
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jz        L1332
    cmp       rax,	2
    jz        L1332
    cmp       rax,	3
    jnz       L1331
L1332:
    movzx     rax,	byte [r14+3]
    movsxd    r10,	dword [r13+28]
    and       r10,	255
    cmp       rax,	r10
    jz        L1330
L1331:
    jmp       L1317
L1330:
    jmp       L1305
L1316:
    movzx     rax,	byte [r13+1]
    cmp       rax,	4
    jnz       L1334
    movzx     rax,	byte [r15]
    movzx     r10,	byte [r14]
    cmp       r10,	rax
    jnz       L1335
    cmp       r10,	57
    jnz       L1335
    mov       rax,	1
    jmp       L1336
L1335:
    xor       eax,	eax
L1336:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L1334
    mov       rax,	[r13+8]
    movsxd    r10,	dword [r15+16]
    imul      rax,	r10
    movsxd    r10,	dword [r15+20]
    add       rax,	r10
    lea       r10,	[r14+20]
    add       [r10],	eax
    add       r13,	32
    jmp       L1333
L1334:
    movzx     rax,	byte [r15]
    cmp       rax,	11
    jnz       L1337
    add       r13,	32
    jmp       L1333
L1337:
    jmp       L1317
L1333:
    jmp       L1305
L1317:
    add       r14,	32
    mov       rax,	r13
    mov       r10,	[rax]
    mov       [r14],	r10
    mov       r10,	[rax+8]
    mov       [r14+8],	r10
    mov       r10,	[rax+16]
    mov       [r14+16],	r10
    mov       r10,	[rax+24]
    mov       [r14+24],	r10
    inc       rbx
    mov       rax,	rbx
    lea       r10,	[r14+28]
    mov       r8d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r8d,	r11d
    or        r8d,	eax
    mov       [r10],	r8d
    movzx     rax,	byte [r14+1]
    cmp       rax,	2
    jnz       L1339
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jnz       L1342
    mov       eax,	[r14+16]
    test      eax,	eax
    jnz       L1341
L1342:
    mov       rax,	[r14+8]
    mov       r10b,	1
    mov       [rax+88],	r10b
L1341:
L1339:
L1305:
    add       r13,	32
    dec       qword [rbp + pc_reduce.pcl_reducetest.av_1]
    jnz       L1296
L1298:
    mov       [pc_api.pccurr],	r14
    mov       rcx,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       rdx,	[pc_api.mlabelno]
    call      mlib.pcm_free
;---------------
    add       rsp,	360
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_run.dispatch_loop
pc_run.dispatch_loop:
;?>>
    %define pc_run.dispatch_loop.pcentry 72
    %define pc_run.dispatch_loop.cmain 80
   %define R.stack rdi
   %define R.pc rbx
   %define R.sp rsi
   %define R.fp r12
    %define pc_run.dispatch_loop.a -8
   %define R.ptr r13
   %define R.b r14
    %define pc_run.dispatch_loop.ptrb -16
    %define pc_run.dispatch_loop.n -24
    %define pc_run.dispatch_loop.d -32
    %define pc_run.dispatch_loop.callstack -40032
    %define pc_run.dispatch_loop.callstackst -120032
    %define pc_run.dispatch_loop.callsp -120040
    %define pc_run.dispatch_loop.str -120296
    %define pc_run.dispatch_loop.oldsp -120304
    %define pc_run.dispatch_loop.ncmd -120312
    %define pc_run.dispatch_loop.cmd -120320
    %define pc_run.dispatch_loop.lastpos -120328
    %define pc_run.dispatch_loop.count -120336
    %define pc_run.dispatch_loop.av_1 -120344
    %define pc_run.dispatch_loop.av_2 -120352
    %define pc_run.dispatch_loop.$T1 -120360
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	120392
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rbx,	[rbp + pc_run.dispatch_loop.pcentry]
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.callsp],	rax
    mov       rcx,	560000
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.cmain]
    test      rax,	rax
    jz        L1345
    mov       rax,	[msys.ncmdparams]
    mov       [rbp + pc_run.dispatch_loop.ncmd],	rax
    mov       rax,	[msys.cmdparams]
    mov       [rbp + pc_run.dispatch_loop.cmd],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.ncmd]
    sub       rax,	[pc_decls.pcmdskip]
    mov       [rbp + pc_run.dispatch_loop.ncmd],	rax
    mov       rax,	[pc_decls.pcmdskip]
    shl       rax,	3
    mov       r10,	[rbp + pc_run.dispatch_loop.cmd]
    lea       r10,	[r10 + rax]
    mov       [rbp + pc_run.dispatch_loop.cmd],	r10
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.cmd]
    mov       [rdi + rax*8-8],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ncmd]
    inc       rax
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    inc       rsi
    mov       rax,	rsi
    xor       r10d,	r10d
    mov       [rdi + rax*8-8],	r10
L1345:
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.lastpos],	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.count],	rax
    mov       rax,	[pc_run.dotrace]
    test      rax,	rax
    jz        L1347
    lea       rax,	[L12250]
    lea       r10,	[pc_run.emptyst]
    mov       [r10],	rax
L1347:
L1348:
    movzx     rax,	byte [rbx]
    cmp       rax,	137
    jae       L1351
    lea       r10,	[L1350]
    jmp       [r10 + rax*8]
    segment .data
L1350:
    dq  L1352
    dq  L1353
    dq  L1356
    dq  L1357
    dq  L1358
    dq  L1365
    dq  L1366
    dq  L1351
    dq  L1367
    dq  L1367
    dq  L1368
    dq  L1369
    dq  L1370
    dq  L1372
    dq  L1373
    dq  L1374
    dq  L1375
    dq  L1378
    dq  L1379
    dq  L1404
    dq  L1394
    dq  L1379
    dq  L1412
    dq  L1399
    dq  L1417
    dq  L1418
    dq  L1419
    dq  L1427
    dq  L1430
    dq  L1433
    dq  L1434
    dq  L1435
    dq  L1442
    dq  L1443
    dq  L1446
    dq  L1449
    dq  L1452
    dq  L1455
    dq  L1455
    dq  L1458
    dq  L1459
    dq  L1460
    dq  L1461
    dq  L1462
    dq  L1465
    dq  L1468
    dq  L1471
    dq  L1472
    dq  L1475
    dq  L1478
    dq  L1479
    dq  L1480
    dq  L1481
    dq  L1482
    dq  L1483
    dq  L1486
    dq  L1490
    dq  L1494
    dq  L1495
    dq  L1496
    dq  L1497
    dq  L1500
    dq  L1503
    dq  L1504
    dq  L1505
    dq  L1506
    dq  L1507
    dq  L1510
    dq  L1511
    dq  L1512
    dq  L1513
    dq  L1514
    dq  L1515
    dq  L1516
    dq  L1517
    dq  L1518
    dq  L1519
    dq  L1520
    dq  L1521
    dq  L1522
    dq  L1523
    dq  L1524
    dq  L1525
    dq  L1528
    dq  L1529
    dq  L1530
    dq  L1531
    dq  L1532
    dq  L1533
    dq  L1534
    dq  L1535
    dq  L1538
    dq  L1541
    dq  L1544
    dq  L1544
    dq  L1547
    dq  L1548
    dq  L1549
    dq  L1550
    dq  L1551
    dq  L1552
    dq  L1555
    dq  L1559
    dq  L1563
    dq  L1564
    dq  L1565
    dq  L1566
    dq  L1567
    dq  L1568
    dq  L1569
    dq  L1570
    dq  L1571
    dq  L1574
    dq  L1575
    dq  L1576
    dq  L1577
    dq  L1578
    dq  L1579
    dq  L1580
    dq  L1581
    dq  L1582
    dq  L1588
    dq  L1589
    dq  L1590
    dq  L1591
    dq  L1592
    dq  L1603
    dq  L1593
    dq  L1594
    dq  L1595
    dq  L1596
    dq  L1597
    dq  L1598
    dq  L1599
    dq  L1600
    dq  L1601
    dq  L1602
    segment .text
L1352:
    add       rbx,	32
    jmp       L1348
L1353:
    movzx     rax,	byte [rbx+1]
    cmp       rax,	4
    jnz       L1355
    mov       rax,	[rbx+8]
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    jmp       L1354
L1355:
    lea       rax,	[rdi + r12*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
L1354:
    add       rbx,	32
    jmp       L1348
L1356:
    movzx     rax,	byte [rbx+3]
    mov       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1357:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword [rbx+20]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1358:
    movzx     rax,	byte [rbx+1]
    cmp       rax,	1
    jnz       L1361
L1360:
    mov       rax,	[rbx+8]
    mov       [rbp + pc_run.dispatch_loop.d],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     rax,	byte [rax+72]
    cmp       rax,	3
    jnz       L1363
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r13,	[rax+56]
    jmp       L1362
L1363:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	11
    jnz       L1364
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     rax,	byte [rax+72]
    cmp       rax,	5
    jnz       L1364
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movsxd    rax,	dword [rax+76]
    mov       r10,	r12
    add       r10,	rax
    mov       r10,	[rdi + r10*8-8]
    mov       r13,	r10
    jmp       L1362
L1364:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movsxd    rax,	dword [rax+76]
    mov       r10,	r12
    add       r10,	rax
    lea       rax,	[rdi + r10*8-8]
    mov       r13,	rax
L1362:
    mov       eax,	[rbx+4]
    movzx     r10,	byte [rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    jmp       L1359
L1361:
    mov       rcx,	rbx
    call      pc_runaux.pcusopnd
L1359:
    add       rbx,	32
    jmp       L1348
L1365:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       eax,	[rbx+4]
    movzx     r10,	byte [rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1366:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword [rbx+20]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    mov       eax,	[rbx+4]
    movzx     r10,	byte [rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1367:
    mov       rax,	[rdi + rsi*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rax*8-8],	r10
    add       rbx,	32
    jmp       L1348
L1368:
    movsxd    rax,	dword [rbx+16]
    dec       rax
    mov       r10,	rsi
    sub       r10,	rax
    lea       rax,	[rdi + r10*8-8]
    movsxd    r10,	dword [rbx+20]
    dec       r10
    mov       r11,	rsi
    sub       r11,	r10
    lea       r10,	[rdi + r11*8-8]
    mov       r11,	[rax]
    mov       r15,	[r10]
    mov       [r10],	r11
    mov       [rax],	r15
    add       rbx,	32
    jmp       L1348
L1369:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1370:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1372:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1373:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    mov       cl,	r10b
    shr       rax,	cl
    and       eax,	1
    mov       [rdi + rsi*8-16],	rax
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1374:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    mov       r11,	[rdi + rsi*8-24]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.pci_loadbf
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	2
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1375:
    mov       r13,	[rdi + rsi*8-16]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-24]
    test      rax,	rax
    jz        L1377
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	1
    mov       rcx,	rax
    shl       r10,	cl
    or        [rbp + pc_run.dispatch_loop.a],	r10
    jmp       L1376
L1377:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	1
    mov       rcx,	rax
    shl       r10,	cl
    not       r10
    and       [rbp + pc_run.dispatch_loop.a],	r10
L1376:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	3
    sub       rsi,	rax
    add       rbx,	32
    jmp       L1348
L1378:
    mov       r13,	[rdi + rsi*8-24]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-32]
    mov       r10,	[rdi + rsi*8-8]
    mov       r11,	[rdi + rsi*8-16]
    mov       rcx,	[rbp + pc_run.dispatch_loop.a]
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storebf
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	4
    sub       rsi,	rax
    add       rbx,	32
    jmp       L1348
L1379:
    mov       rax,	[rbx+8]
    mov       [rbp + pc_run.dispatch_loop.d],	rax
    mov       rax,	[pc_run.dotrace]
    test      rax,	rax
    jz        L1381
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + pc_run.dispatch_loop.av_1],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.av_1]
    cmp       rax,	0
    jle       L1384
L1382:
    call      msys.m$print_startcon
    lea       rcx,	[L12251]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       qword [rbp + pc_run.dispatch_loop.av_1]
    jnz       L1382
L1384:
    call      msys.m$print_startcon
    lea       rcx,	[L12252]
    call      msys.m$print_setfmt
    inc       qword [pc_run.seqno]
    mov       rcx,	[pc_run.seqno]
    call      msys.m$print_i64_nf
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      pc_run.getlineno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1381:
    cmp       rsi,	69900
    jle       L1386
    mov       rcx,	rbx
    lea       rdx,	[L12253]
    lea       r8,	[L12254]
    call      pc_runaux.pcerrorx
L1386:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       al,	[rax+80]
    test      al,	al
    jz        L1388
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte [rbx+3]
    push      rax
    movsxd    rax,	dword [rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    mov       rcx,	[rbp + pc_run.dispatch_loop.d]
    xor       edx,	edx
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx]
    cmp       rax,	18
    jnz       L1390
    dec       rsi
    jmp       L1389
L1390:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
L1389:
    add       rbx,	32
    jmp       L1387
L1388:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rax,	[rax+56]
    test      rax,	rax
    jnz       L1391
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rax,	[rax]
    mov       rcx,	rbx
    lea       rdx,	[L12255]
    mov       r8,	rax
    call      pc_runaux.pcerrorx
    jmp       L1387
L1391:
    movsxd    rax,	dword [rbx+16]
    mov       r10,	rsi
    sub       r10,	rax
    mov       [rbp + pc_run.dispatch_loop.$T1],	r10
    movzx     rax,	byte [rbx]
    cmp       rax,	21
    jnz       L1393
    mov       rax,	1
    jmp       L1392
L1393:
    xor       eax,	eax
L1392:
    mov       r10,	[rbp + pc_run.dispatch_loop.$T1]
    add       r10,	rax
    inc       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + rax*4 + pc_run.dispatch_loop.callstack-4],	r10d
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r10,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.callstackst-8],	rax
    lea       rax,	[rbx+32]
    movsxd    r10,	dword [rbx+16]
    or        rax,	r10
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rbx,	[rax+56]
L1387:
    jmp       L1348
L1394:
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword [rbx+20]
    sub       rsi,	rax
    mov       rax,	rsi
    dec       rsi
    mov       r12,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	r13
    and       rax,	15
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	1
    jge       L1396
    mov       rcx,	rbx
    lea       rdx,	[L12256]
    lea       r8,	[L12257]
    call      pc_runaux.pcerrorx
L1396:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    dec       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       eax,	[rbp + rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [rbp + pc_run.dispatch_loop.oldsp],	rax
    cmp       rsi,	[rbp + pc_run.dispatch_loop.oldsp]
    jz        L1398
    lea       rcx,	[rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12258]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	rbx
    lea       rdx,	[rbp + pc_run.dispatch_loop.str]
    lea       r8,	[L12259]
    call      pc_runaux.pcerrorx
L1398:
    mov       rax,	r13
    and       rax,	-16
    mov       rbx,	rax
    jmp       L1348
L1399:
    mov       rax,	[rdi + rsi*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword [rbx+20]
    sub       rsi,	rax
    dec       rsi
    mov       rax,	rsi
    mov       r12,	[rdi + rax*8-8]
    dec       rsi
    mov       rax,	rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	r13
    and       rax,	15
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	1
    jge       L1401
    mov       rcx,	rbx
    lea       rdx,	[L12260]
    lea       r8,	[L12261]
    call      pc_runaux.pcerrorx
L1401:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    dec       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       eax,	[rbp + rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [rbp + pc_run.dispatch_loop.oldsp],	rax
    cmp       rsi,	[rbp + pc_run.dispatch_loop.oldsp]
    jz        L1403
    lea       rcx,	[rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12262]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	rbx
    lea       rdx,	[rbp + pc_run.dispatch_loop.str]
    lea       r8,	[L12263]
    call      pc_runaux.pcerrorx
L1403:
    mov       rax,	r13
    and       rax,	-16
    mov       rbx,	rax
    jmp       L1348
L1404:
    mov       r13,	[rdi + rsi*8-8]
    test      r13,	r13
    jnz       L1406
    mov       rcx,	rbx
    lea       rdx,	[L12264]
    lea       r8,	[L12265]
    call      pc_runaux.pcerrorx
L1406:
    cmp       r13,	[pc_api.pcstart]
    jb        L1408
    cmp       r13,	[pc_api.pccurr]
    ja        L1408
;pc_run.dispatch_loop.icallp:
L1409:
    lea       rax,	[rsi-1]
    movsxd    r10,	dword [rbx+16]
    sub       rax,	r10
    mov       [rbp + pc_run.dispatch_loop.$T1],	rax
    movzx     rax,	byte [rbx]
    cmp       rax,	22
    jnz       L1411
    mov       rax,	1
    jmp       L1410
L1411:
    xor       eax,	eax
L1410:
    mov       r10,	[rbp + pc_run.dispatch_loop.$T1]
    add       r10,	rax
    inc       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + rax*4 + pc_run.dispatch_loop.callstack-4],	r10d
    lea       rax,	[pc_run.emptyst]
    mov       r10,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.callstackst-8],	rax
    lea       rax,	[rbx+32]
    movsxd    r10,	dword [rbx+16]
    or        rax,	r10
    mov       [rdi + rsi*8-8],	rax
    mov       rbx,	r13
    jmp       L1407
L1408:
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte [rbx+3]
    push      rax
    movsxd    rax,	dword [rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    xor       ecx,	ecx
    mov       rdx,	r13
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    dec       rsi
    add       rbx,	32
L1407:
    jmp       L1348
L1412:
    mov       r13,	[rdi + rsi*8-8]
    test      r13,	r13
    jnz       L1414
    mov       rcx,	rbx
    lea       rdx,	[L12266]
    lea       r8,	[L12267]
    call      pc_runaux.pcerrorx
L1414:
    cmp       r13,	[pc_api.pcstart]
    jb        L1416
    cmp       r13,	[pc_api.pccurr]
    jbe       L1409
L1416:
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte [rbx+3]
    push      rax
    movsxd    rax,	dword [rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    xor       ecx,	ecx
    mov       rdx,	r13
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
L1415:
    jmp       L1348
L1417:
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1348
L1418:
    mov       rax,	rsi
    dec       rsi
    mov       rbx,	[rdi + rax*8-8]
    jmp       L1348
L1419:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1421
    movq      XMM4,	[rdi + rsi*8-8]
    movq      XMM5,	[rdi + rsi*8-16]
    movzx     rax,	byte [rbx+2]
    mov       rcx,	rax
    movq      XMM1,	XMM5
    movq      XMM2,	XMM4
    call      pc_runaux.cmpreal
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1420
L1421:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1422
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte [rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpint
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1420
L1422:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte [rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpword
    mov       [rbp + pc_run.dispatch_loop.n],	rax
L1420:
    mov       eax,	[rbx+16]
    test      eax,	eax
    jz        L1424
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    test      rax,	rax
    jnz       L1424
    dec       rsi
    jmp       L1423
L1424:
    mov       rax,	2
    sub       rsi,	rax
L1423:
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    test      rax,	rax
    jz        L1426
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1425
L1426:
    add       rbx,	32
L1425:
    jmp       L1348
L1427:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    test      rax,	rax
    jz        L1429
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1428
L1429:
    add       rbx,	32
L1428:
    jmp       L1348
L1430:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    test      rax,	rax
    jnz       L1432
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1431
L1432:
    add       rbx,	32
L1431:
    jmp       L1348
L1433:
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1348
L1434:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1435:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jz        L1437
    cmp       rax,	1
    jz        L1438
    jmp       L1439
L1437:
    mov       rcx,	rbx
    lea       rdx,	[L12268]
    lea       r8,	[L12269]
    call      pc_runaux.pcerrorx
    jmp       L1436
L1438:
    mov       rcx,	rbx
    lea       rdx,	[L12270]
    lea       r8,	[L12271]
    call      pc_runaux.pcerrorx
    jmp       L1436
L1439:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1441
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte [rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpint
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1440
L1441:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte [rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpword
    mov       [rbp + pc_run.dispatch_loop.n],	rax
L1440:
L1436:
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1442:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    jmp       L1343
L1443:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    mov       rax,	r13
    dec       qword [rax]
    mov       rax,	[r13]
    test      rax,	rax
    jz        L1445
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1444
L1445:
    add       rbx,	64
L1444:
    jmp       L1348
L1446:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+64]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword [rbx+16]
    mov       r10,	r13
    add       [r10],	rax
    mov       rax,	[r13]
    cmp       rax,	[rbp + pc_run.dispatch_loop.n]
    jg        L1448
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1447
L1448:
    add       rbx,	96
L1447:
    jmp       L1348
L1449:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+64]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword [rbx+16]
    mov       r10,	r13
    sub       [r10],	rax
    mov       rax,	[r13]
    cmp       rax,	[rbp + pc_run.dispatch_loop.n]
    jl        L1451
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1450
L1451:
    add       rbx,	96
L1450:
    jmp       L1348
L1452:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	11
    jnz       L1454
    mov       rcx,	rbx
    lea       rdx,	[L12272]
    lea       r8,	[L12273]
    call      pc_runaux.pcerrorx
L1454:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.ptrb],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptrb]
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       r14,	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    movzx     rax,	byte [rbx+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptrb]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1455:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movsxd    rax,	dword [rbx+16]
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    cmp       r10,	rax
    jl        L1457
    movsxd    rax,	dword [rbx+20]
    cmp       r10,	rax
    jg        L1457
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+32]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    shl       rax,	5
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword [rbx+16]
    shl       rax,	5
    sub       r10,	rax
    mov       rbx,	r10
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1456
L1457:
    lea       rax,	[rbx+32]
    mov       rax,	[rax+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
L1456:
    jmp       L1348
L1458:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1459:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1460:
    mov       eax,	[rbx+4]
    mov       r10,	rsi
    dec       rsi
    mov       r10,	[rdi + r10*8-8]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	rax
    call      memset
    add       rbx,	32
    jmp       L1348
L1461:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1462:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1464
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    addsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1463
L1464:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    add       [r10],	rax
L1463:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1465:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1467
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    subsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1466
L1467:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    sub       [r10],	rax
L1466:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1468:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1470
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    mulsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1469
L1470:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       r11,	[r10]
    imul      r11,	rax
    mov       [r10],	r11
L1469:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1471:
    movq      XMM4,	[rdi + rsi*8-16]
    movq      XMM5,	[rdi + rsi*8-8]
    divsd     XMM4,	XMM5
    movq      [rdi + rsi*8-16],	XMM4
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1472:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1474
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    cqo       
    idiv      r10
    mov       [rdi + rsi*8-16],	rax
    jmp       L1473
L1474:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    xor       edx,	edx
    div       r10
    mov       [rdi + rsi*8-16],	rax
L1473:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1475:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1477
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rdi + rsi*8-16],	rax
    jmp       L1476
L1477:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    xor       edx,	edx
    div       r10
    xchg      rax,	rdx
    mov       [rdi + rsi*8-16],	rax
L1476:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1478:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1479:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    and       [r10],	rax
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1480:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    or        [r10],	rax
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1481:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    xor       [r10],	rax
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1482:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    shl       qword [r10],	cl
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1483:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1485
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    sar       qword [r10],	cl
    jmp       L1484
L1485:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    shr       qword [r10],	cl
L1484:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1486:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1488
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM0,	[rax]
    comisd    XMM0,	XMM4
    jbe       L12274
    movq      [rax],	XMM4
L12274:
    jmp       L1487
L1488:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1489
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jle       L12275
    mov       [r10],	rax
L12275:
    jmp       L1487
L1489:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jbe       L12276
    mov       [r10],	rax
L12276:
L1487:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1490:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1492
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM0,	[rax]
    comisd    XMM0,	XMM4
    jae       L12277
    movq      [rax],	XMM4
L12277:
    jmp       L1491
L1492:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1493
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jge       L12278
    mov       [r10],	rax
L12278:
    jmp       L1491
L1493:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jae       L12279
    mov       [r10],	rax
L12279:
L1491:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1494:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword [rbx+20]
    lea       rax,	[rax + r10]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1495:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    sub       rax,	r11
    movsxd    r10,	dword [rbx+20]
    lea       rax,	[rax + r10]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1496:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    sub       rax,	r10
    movsxd    r10,	dword [rbx+16]
    cqo       
    idiv      r10
    mov       [rdi + rsi*8-16],	rax
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1497:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1499
    movq      XMM4,	[rdi + rsi*8-8]
    xorpd     XMM4,	[L12280]
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1498
L1499:
    mov       rax,	[rdi + rsi*8-8]
    neg       rax
    mov       [rdi + rsi*8-8],	rax
L1498:
    add       rbx,	32
    jmp       L1348
L1500:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1502
    movq      XMM4,	[rdi + rsi*8-8]
    andpd     XMM4,	[L12281]
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1501
L1502:
    mov       rax,	[rdi + rsi*8-8]
    cmp       rax,	0
    jge       L12282
    neg       rax
L12282:
    mov       [rdi + rsi*8-8],	rax
L1501:
    add       rbx,	32
    jmp       L1348
L1503:
    mov       rax,	[rdi + rsi*8-8]
    not       rax
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1504:
    mov       rax,	[rdi + rsi*8-8]
    xor       rax,	1
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1505:
    mov       rax,	[rdi + rsi*8-8]
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1506:
    mov       rax,	[rdi + rsi*8-8]
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1507:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1509
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-8]
    movq      XMM5,	[rax]
    mulsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1508
L1509:
    mov       rax,	[rdi + rsi*8-8]
    imul      rax,	rax
    mov       [rdi + rsi*8-8],	rax
L1508:
    add       rbx,	32
    jmp       L1348
L1510:
    movq      XMM4,	[rdi + rsi*8-8]
    sqrtsd    XMM4,	XMM4
    movq      [rdi + rsi*8-8],	XMM4
    add       rbx,	32
    jmp       L1348
L1511:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1512:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1513:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1514:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1515:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1516:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1517:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1518:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1519:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1520:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1521:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1522:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1523:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1524:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1525:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1527
    movq      XMM4,	[rdi + rsi*8-16]
    movq      XMM5,	[rdi + rsi*8-8]
    movq      XMM0,	XMM4
    movq      XMM1,	XMM5
    call      pow
    movq      [rdi + rsi*8-16],	XMM0
    jmp       L1526
L1527:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    mov       rcx,	rax
    mov       rdx,	r10
    call      msys.m$power_i64
    mov       [rdi + rsi*8-16],	rax
L1526:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1528:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1529:
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    jmp       L1348
L1530:
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    neg       r10
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    jmp       L1348
L1531:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1532:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    neg       r10
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1533:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    jmp       L1348
L1534:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    neg       r10
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    jmp       L1348
L1535:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1537
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    addsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1536
L1537:
    mov       rax,	r14
    add       [rbp + pc_run.dispatch_loop.a],	rax
L1536:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1538:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1540
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    subsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1539
L1540:
    mov       rax,	r14
    sub       [rbp + pc_run.dispatch_loop.a],	rax
L1539:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1541:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1543
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    mulsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1542
L1543:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    imul      rax,	r14
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L1542:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1544:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1546
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    divsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1545
L1546:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	r14
    cqo       
    idiv      r10
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L1545:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1547:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	r14
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1548:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    and       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1549:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    or        [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1550:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    xor       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1551:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       cl,	r14b
    shl       qword [rbp + pc_run.dispatch_loop.a],	cl
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1552:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1554
    mov       cl,	r14b
    sar       qword [rbp + pc_run.dispatch_loop.a],	cl
    jmp       L1553
L1554:
    mov       cl,	r14b
    shr       qword [rbp + pc_run.dispatch_loop.a],	cl
L1553:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1555:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1557
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    maxss     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1556
L1557:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1558
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jle       L12283
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L12283:
    jmp       L1556
L1558:
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jbe       L12284
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L12284:
L1556:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1559:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1561
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    minsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1560
L1561:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1562
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jge       L12285
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L12285:
    jmp       L1560
L1562:
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jae       L12286
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L12286:
L1560:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    jmp       L1348
L1563:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword [rbx+16]
    imul      rax,	r10
    mov       r10,	r13
    add       [r10],	rax
    add       rbx,	32
    jmp       L1348
L1564:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword [rbx+16]
    imul      rax,	r10
    mov       r10,	r13
    sub       [r10],	rax
    add       rbx,	32
    jmp       L1348
L1565:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1566:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1567:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1568:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1569:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1570:
    add       rbx,	32
    jmp       L1348
L1571:
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1573
    mov       rax,	[rdi + rsi*8-8]
    cvtsi2sd  XMM4,	rax
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1572
L1573:
    mov       rax,	[rdi + rsi*8-8]
    cmp       rax,	0
    jl        L12287
    cvtsi2sd  XMM4,	rax
    jmp       L12288
L12287:
    and       rax,	[L12289]
    cvtsi2sd  XMM4,	rax
    addsd     XMM4,	[L12290]
L12288:
    movq      [rdi + rsi*8-8],	XMM4
L1572:
    add       rbx,	32
    jmp       L1348
L1574:
    movq      XMM4,	[rdi + rsi*8-8]
    cvttsd2si rax,	XMM4
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1575:
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    lea       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1576:
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    lea       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1577:
    add       rbx,	32
    jmp       L1348
L1578:
    add       rbx,	32
    jmp       L1348
L1579:
    add       rbx,	32
    jmp       L1348
L1580:
    add       rbx,	32
    jmp       L1348
L1581:
    add       rbx,	32
    jmp       L1348
L1582:
    inc       rsi
    mov       rax,	rsi
    mov       r10,	r12
    mov       [rdi + rax*8-8],	r10
    mov       r12,	rsi
    movsxd    rax,	dword [rbx+20]
    add       rsi,	rax
    mov       rax,	[pc_run.dotrace]
    test      rax,	rax
    jz        L1584
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + pc_run.dispatch_loop.av_2],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.av_2]
    cmp       rax,	0
    jle       L1587
L1585:
    call      msys.m$print_startcon
    lea       rcx,	[L12291]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       qword [rbp + pc_run.dispatch_loop.av_2]
    jnz       L1585
L1587:
    call      msys.m$print_startcon
    lea       rcx,	[L12292]
    call      msys.m$print_setfmt
    mov       rcx,	[pc_run.seqno]
    call      msys.m$print_i64_nf
    mov       rax,	[rbx+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1584:
    add       rbx,	32
    jmp       L1348
L1588:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1589:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1590:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1591:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1592:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1593:
    add       rbx,	32
    jmp       L1348
L1594:
    add       rbx,	32
    jmp       L1348
L1595:
    mov       r13,	[rdi + rsi*8-8]
    lea       rax,	[rbx+32]
    mov       [r13],	rax
    mov       [r13+8],	rsi
    mov       [r13+16],	r12
    xor       eax,	eax
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    jmp       L1348
L1596:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rbx,	[r13]
    mov       rsi,	[r13+8]
    mov       r12,	[r13+16]
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rax*8-8],	r10
    jmp       L1348
L1597:
    add       rbx,	32
    jmp       L1348
L1598:
    add       rbx,	32
    jmp       L1348
L1599:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1600:
    dec       rsi
    add       rbx,	32
    jmp       L1348
L1601:
    add       rbx,	32
    jmp       L1348
L1602:
    jmp       L1371
    add       rbx,	32
    jmp       L1348
L1603:
    jmp       L1348
L1351:
;pc_run.dispatch_loop.unimpl:
L1371:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12293]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12294]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rbx]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movsxd    rax,	dword [rbx+28]
    shr       rax,	8
    and       rax,	16777215
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
    jmp       L1348
    xor       eax,	eax
L1343:
;---------------
    add       rsp,	120392
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_run.fixuppcl
pc_run.fixuppcl:
;?>>
   %define R.p rdi
   %define R.d rbx
   %define R.e rsi
   %define R.dproc r12
   %define R.pdata r13
   %define R.parambytes r14
   %define R.framebytes r15
    %define pc_run.fixuppcl.paramslots -8
    %define pc_run.fixuppcl.localslots -16
    %define pc_run.fixuppcl.a -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
;---------------
    mov       rax,	[pc_api.mlabelno]
    inc       rax
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [pc_run.labeltable],	rax
    mov       rdi,	[pc_api.pcstart]
    jmp       L1608
L1605:
    movzx     rax,	byte [rdi]
    cmp       rax,	120
    jz        L1610
    cmp       rax,	121
    jnz       L1611
L1610:
    mov       rax,	[rdi+8]
    mov       r10,	rdi
    mov       [rax+56],	r10
L1611:
L1609:
    add       rdi,	32
L1608:
    cmp       rdi,	[pc_api.pccurr]
    jbe       L1605
    mov       rdi,	[pc_api.pcstart]
    jmp       L1615
L1612:
    movzx     rax,	byte [rdi]
    cmp       rax,	123
    jz        L1617
    cmp       rax,	124
    jnz       L1618
L1617:
    mov       rbx,	[rdi+8]
    mov       eax,	[rdi+4]
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [rbx+56],	rax
L1618:
L1616:
    add       rdi,	32
L1615:
    cmp       rdi,	[pc_api.pccurr]
    jbe       L1612
    mov       rdi,	[pc_api.pcstart]
    jmp       L1622
L1619:
    movzx     rax,	byte [rdi]
    cmp       rax,	123
    jz        L1624
    cmp       rax,	124
    jz        L1624
    cmp       rax,	125
    jz        L1625
    cmp       rax,	120
    jz        L1626
    cmp       rax,	127
    jz        L1627
    cmp       rax,	20
    jz        L1628
    cmp       rax,	23
    jz        L1628
    jmp       L1629
L1624:
    mov       rax,	[rdi+8]
    mov       r13,	[rax+56]
    jmp       L1623
L1625:
    movzx     rax,	byte [rdi+3]
    cmp       rax,	11
    jz        L1631
    movzx     rax,	byte [rdi+1]
    cmp       rax,	1
    jz        L1633
    cmp       rax,	2
    jz        L1634
    jmp       L1635
L1633:
    mov       rcx,	rdi
    lea       rdx,	[L12295]
    lea       r8,	[L12296]
    call      pc_runaux.pcerrorx
    jmp       L1632
L1634:
    mov       rbx,	[rdi+8]
    movzx     rax,	byte [rbx+72]
    cmp       rax,	3
    jz        L1637
    cmp       rax,	2
    jz        L1638
    cmp       rax,	1
    jz        L1639
    jmp       L1640
L1637:
    mov       rax,	[rbx+56]
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1636
L1638:
    mov       rax,	[rbx+56]
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1636
L1639:
    mov       rcx,	rbx
    call      pc_runaux.getdllfnptr
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1636
L1640:
    mov       rcx,	rdi
    lea       rdx,	[L12297]
    lea       r8,	[L12298]
    call      pc_runaux.pcerrorx
L1636:
    mov       rax,	[rbp + pc_run.fixuppcl.a]
    test      rax,	rax
    jnz       L1642
    mov       rcx,	rdi
    lea       rdx,	[L12299]
    lea       r8,	[L12300]
    call      pc_runaux.pcerrorx
L1642:
    jmp       L1632
L1635:
    mov       rax,	[rdi+8]
    mov       [rbp + pc_run.fixuppcl.a],	rax
L1632:
    mov       eax,	[rdi+4]
    mov       rcx,	r13
    lea       rdx,	[rbp + pc_run.fixuppcl.a]
    mov       r8,	rax
    call      memcpy
    jmp       L1630
L1631:
    mov       eax,	[rdi+4]
    mov       r10,	[rdi+8]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
L1630:
    mov       eax,	[rdi+4]
    add       r13,	rax
    jmp       L1623
L1626:
    mov       rax,	[rdi+8]
    mov       rbx,	rax
    mov       r12,	rax
    mov       rsi,	[rbx+16]
    xor       r14,	r14
    jmp       L1646
L1643:
    mov       rax,	8
    add       r14,	rax
    mov       rax,	r14
    sar       rax,	3
    inc       rax
    neg       rax
    mov       [rsi+76],	eax
    mov       rsi,	[rsi+16]
L1646:
    test      rsi,	rsi
    jnz       L1643
    mov       rsi,	[rbx+24]
    xor       r15,	r15
    jmp       L1650
L1647:
    mov       rax,	r15
    sar       rax,	3
    inc       rax
    mov       [rsi+76],	eax
    mov       eax,	[rsi+84]
    mov       rcx,	rax
    mov       rdx,	8
    call      mlib.roundtoblock
    add       r15,	rax
    mov       rsi,	[rsi+24]
L1650:
    test      rsi,	rsi
    jnz       L1647
    mov       rax,	r14
    sar       rax,	3
    mov       [rbp + pc_run.fixuppcl.paramslots],	rax
    mov       [rdi+16],	eax
    mov       rax,	r15
    sar       rax,	3
    mov       [rbp + pc_run.fixuppcl.localslots],	rax
    mov       [rdi+20],	eax
    jmp       L1623
L1627:
    mov       rax,	[rdi+8]
    mov       r10,	rdi
    mov       r11,	[pc_run.labeltable]
    mov       [r11 + rax*8-8],	r10
    jmp       L1623
L1628:
    mov       eax,	[rbp + pc_run.fixuppcl.paramslots]
    mov       [rdi+16],	eax
    mov       eax,	[rbp + pc_run.fixuppcl.localslots]
    mov       [rdi+20],	eax
L1629:
L1623:
    add       rdi,	32
L1622:
    cmp       rdi,	[pc_api.pccurr]
    jbe       L1619
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_run.pcl_runpcl
pc_run.pcl_runpcl:
;?>>
   %define R.stopcode rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      pc_runaux.loadlibs
    call      pc_run.fixuppcl
    mov       rax,	[pc_decls.entryproc]
    test      rax,	rax
    jnz       L1653
    mov       rcx,	[pc_api.pcstart]
    lea       rdx,	[L12301]
    lea       r8,	[L12302]
    call      pc_runaux.pcerrorx
L1653:
    call      pc_runaux.docmdskip
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L1655
    call      msys.m$print_startcon
    lea       rcx,	[L12303]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1655:
    mov       rax,	[pc_decls.entryproc]
    movzx     rax,	byte [rax+112]
    cmp       rax,	2
    setz      al
    movzx     eax,	al
    mov       r10,	[pc_decls.entryproc]
    mov       r10,	[r10+56]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_run.dispatch_loop
    mov       rdi,	rax
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L1657
    call      msys.m$print_startcon
    lea       rcx,	[L12304]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L1657:
    mov       rcx,	rdi
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_run.getlineno
pc_run.getlineno:
;?>>
   %define R.pc rdi
    %define pc_run.getlineno.filename -8
    %define pc_run.getlineno.sourceline -16
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
;---------------
    mov       rax,	[pc_decls.igetmsourceinfo]
    test      rax,	rax
    jz        L1660
    mov       eax,	[rdi+24]
    mov       rcx,	rax
    lea       rdx,	[rbp + pc_run.getlineno.filename]
    lea       r8,	[rbp + pc_run.getlineno.sourceline]
    mov       r10,	[pc_decls.igetmsourceinfo]
    call      r10
    jmp       L1659
L1660:
    xor       eax,	eax
L1659:
L1658:
;---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_getopnd
pc_runaux.pci_getopnd:
;?>>
   %define R.p r12
   %define R.locals r13
   %define R.a rdi
   %define R.d rbx
   %define R.ptr rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    movzx     rax,	byte [r12+1]
    cmp       rax,	4
    jz        L1663
    cmp       rax,	1
    jz        L1664
    cmp       rax,	2
    jz        L1665
    cmp       rax,	7
    jz        L1666
    cmp       rax,	5
    jz        L1667
    cmp       rax,	6
    jz        L1667
    cmp       rax,	3
    jz        L1668
    jmp       L1669
L1663:
    mov       rdi,	[r12+8]
    jmp       L1662
L1664:
    mov       rbx,	[r12+8]
    movzx     rax,	byte [rbx+72]
    cmp       rax,	3
    jnz       L1672
L1671:
    mov       rsi,	[rbx+56]
    jmp       L1670
L1672:
    movsxd    rax,	dword [rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rsi,	r10
    movzx     rax,	byte [rbx+82]
    cmp       rax,	11
    jnz       L1674
    movzx     rax,	byte [rbx+72]
    cmp       rax,	5
    jnz       L1674
    mov       rsi,	[rsi]
L1674:
L1670:
    movzx     rax,	byte [r12+3]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       rdi,	rax
    jmp       L1662
L1665:
    mov       rbx,	[r12+8]
    movzx     rax,	byte [rbx+72]
    cmp       rax,	4
    jz        L1676
    cmp       rax,	5
    jz        L1677
    cmp       rax,	1
    jz        L1678
    jmp       L1679
L1676:
    movsxd    rax,	dword [rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rdi,	r10
    jmp       L1675
L1677:
    movsxd    rax,	dword [rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rdi,	r10
    movzx     rax,	byte [rbx+82]
    cmp       rax,	11
    jnz       L1681
    mov       rsi,	rdi
    mov       rdi,	[rsi]
L1681:
    jmp       L1675
L1678:
    mov       rcx,	rbx
    call      pc_runaux.getdllfnptr
    mov       rdi,	rax
    jmp       L1675
L1679:
    mov       rdi,	[rbx+56]
L1675:
    jmp       L1662
L1666:
    mov       rdi,	[r12+8]
    jmp       L1662
L1667:
    movq      XMM4,	[r12+8]
    movq      rax,	XMM4
    mov       rdi,	rax
    jmp       L1662
L1668:
    mov       rax,	[r12+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    jmp       L1662
L1669:
    mov       rcx,	r12
    call      pc_runaux.pcusopnd
L1662:
    mov       rax,	rdi
L1661:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_loadptr
pc_runaux.pci_loadptr:
;?>>
   %define R.p rdi
   %define R.mode rbx
   %define R.x XMM15
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rdi,	rdi
    jnz       L1684
    lea       rcx,	[L12305]
    call      pc_api.pclerror
L1684:
    lea       rax,	[rbx-1]
    cmp       rax,	11
    jae       L1687
    lea       r10,	[L1686]
    jmp       [r10 + rax*8]
    segment .data
L1686:
    dq  L1690
    dq  L1689
    dq  L1698
    dq  L1697
    dq  L1696
    dq  L1695
    dq  L1694
    dq  L1693
    dq  L1692
    dq  L1691
    dq  L1688
    segment .text
L1688:
    mov       rax,	rdi
    jmp       L1685
L1689:
    mov       rax,	[rdi]
    jmp       L1685
L1690:
    movd      XMM4,	[rdi]
    cvtss2sd  XMM4,	XMM4
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    jmp       L1685
L1691:
    mov       rax,	[rdi]
    jmp       L1685
L1692:
    movsxd    rax,	dword [rdi]
    jmp       L1685
L1693:
    movsx     rax,	word [rdi]
    jmp       L1685
L1694:
    movsx     rax,	byte [rdi]
    jmp       L1685
L1695:
    mov       rax,	[rdi]
    jmp       L1685
L1696:
    mov       eax,	[rdi]
    jmp       L1685
L1697:
    movzx     rax,	word [rdi]
    jmp       L1685
L1698:
    movzx     rax,	byte [rdi]
    jmp       L1685
L1687:
    xor       eax,	eax
L1685:
L1682:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_storeptr
pc_runaux.pci_storeptr:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.mode rsi
   %define R.size r12
   %define R.x XMM15
    push      rdi
    push      rbx
    push      rsi
    push      r12
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    test      rdi,	rdi
    jnz       L1701
    lea       rcx,	[L12305]
    call      pc_api.pclerror
L1701:
    mov       rax,	rsi
    cmp       rax,	11
    jz        L1703
    cmp       rax,	1
    jz        L1704
    jmp       L1705
L1703:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r12
    call      memcpy
    jmp       L1702
L1704:
    mov       rax,	rbx
    movq      XMM4,	rax
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    cvtsd2ss  XMM4,	XMM4
    movd      [rdi],	XMM4
    jmp       L1702
L1705:
    lea       rax,	[pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    cmp       rax,	8
    jz        L1707
    cmp       rax,	4
    jz        L1708
    cmp       rax,	2
    jz        L1709
    jmp       L1710
L1707:
    mov       [rdi],	rbx
    jmp       L1706
L1708:
    mov       [rdi],	ebx
    jmp       L1706
L1709:
    mov       [rdi],	bx
    jmp       L1706
L1710:
    mov       [rdi],	bl
L1706:
L1702:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_getopndaddr
pc_runaux.pci_getopndaddr:
;?>>
   %define R.p rbx
   %define R.locals rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [rbx+1]
    cmp       rax,	1
    jz        L1713
    mov       rcx,	rbx
    lea       rdx,	[L12306]
    lea       r8,	[L12307]
    call      pc_runaux.pcerrorx
L1713:
    mov       rdi,	[rbx+8]
    movzx     rax,	byte [rdi+72]
    cmp       rax,	3
    jnz       L1715
    mov       rax,	[rdi+56]
    jmp       L1714
L1715:
    movsxd    rax,	dword [rdi+76]
    lea       r10,	[rsi + rax*8]
    mov       rax,	r10
L1714:
L1711:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pcerrorx
pc_runaux.pcerrorx:
;?>>
   %define R.p rdi
   %define R.mess rbx
   %define R.param rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12308]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    lea       rcx,	[L12309]
    call      msys.m$print_str_nf
    test      rdi,	rdi
    jz        L1718
    movsxd    rax,	dword [rdi+28]
    shr       rax,	8
    and       rax,	16777215
    jmp       L1717
L1718:
    xor       eax,	eax
L1717:
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pcusopnd
pc_runaux.pcusopnd:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12310]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+1]
    lea       r10,	[pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[L12311]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movsxd    rax,	dword [rdi+28]
    shr       rax,	8
    and       rax,	16777215
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_runaux.docalldll
pc_runaux.docalldll:
;?>>
   %define R.d rsi
   %define R.fnaddr r12
   %define R.revargs r13
   %define R.nargs r14
    %define pc_runaux.docalldll.nvars 96
    %define pc_runaux.docalldll.retmode 104
    %define pc_runaux.docalldll.args -800
   %define R.retval rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	832
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    test      r12,	r12
    jnz       L1722
    mov       rcx,	rsi
    call      pc_runaux.getdllfnptr
    mov       r12,	rax
L1722:
    mov       rbx,	r14
    cmp       rbx,	1
    jl        L1725
L1723:
    mov       rax,	[r13 + rbx*8-8]
    mov       r10,	r14
    sub       r10,	rbx
    mov       [rbp + r10*8 + pc_runaux.docalldll.args],	rax
    dec       rbx
    cmp       rbx,	1
    jge       L1723
L1725:
    sub       rsp,	8
    push      0
    mov       rax,	[rbp + pc_runaux.docalldll.retmode]
    cmp       rax,	1
    jz        L1728
    cmp       rax,	2
    jnz       L1727
L1728:
    mov       rax,	82
    jmp       L1726
L1727:
    mov       rax,	73
L1726:
    mov       rcx,	r12
    mov       rdx,	rax
    mov       r8,	r14
    lea       r9,	[rbp + pc_runaux.docalldll.args]
    sub       rsp,	32
    call      mwindll.os_calldllfunction
    add       rsp,	48
    mov       rdi,	rax
    mov       rax,	rdi
L1720:
;---------------
    add       rsp,	832
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.getdllfnptr
pc_runaux.getdllfnptr:
;?>>
   %define R.d r12
   %define R.fnaddr rdi
   %define R.procname rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rdi,	[r12+56]
    test      rdi,	rdi
    jz        L1731
    mov       rax,	rdi
    jmp       L1729
L1731:
    mov       rbx,	[r12]
    mov       rsi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1735
L1732:
    lea       rax,	[pc_decls.plibinst]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mwindows.os_getdllprocaddr
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L1737
    jmp       L1734
L1737:
    inc       rsi
    cmp       rsi,	[pc_decls.nplibfiles]
    jle       L1732
L1735:
    xor       ecx,	ecx
    lea       rdx,	[L12312]
    mov       r8,	rbx
    call      pc_runaux.pcerrorx
L1734:
    mov       [r12+56],	rdi
    mov       rax,	rdi
L1729:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.loadlibs
pc_runaux.loadlibs:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1741
L1739:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mwindows.os_getdllinst
    lea       r10,	[pc_decls.plibinst]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[pc_decls.plibinst]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L1743
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    xor       ecx,	ecx
    lea       rdx,	[L12313]
    mov       r8,	rax
    call      pc_runaux.pcerrorx
L1743:
    inc       rdi
    cmp       rdi,	[pc_decls.nplibfiles]
    jle       L1739
L1741:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_runaux.cmpreal
pc_runaux.cmpreal:
;?>>
   %define R.cond rcx
   %define R.x XMM1
   %define R.y XMM2
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1746
    cmp       rax,	2
    jz        L1747
    cmp       rax,	3
    jz        L1748
    cmp       rax,	4
    jz        L1749
    cmp       rax,	5
    jz        L1750
    jmp       L1751
L1746:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setz      al
    movzx     eax,	al
    jmp       L1745
L1747:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setnz     al
    movzx     eax,	al
    jmp       L1745
L1748:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setb      al
    movzx     eax,	al
    jmp       L1745
L1749:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setbe     al
    movzx     eax,	al
    jmp       L1745
L1750:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setae     al
    movzx     eax,	al
    jmp       L1745
L1751:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    seta      al
    movzx     eax,	al
L1745:
L1744:
;---------------
    ret       
;End 
;Proc pc_runaux.cmpint
pc_runaux.cmpint:
;?>>
   %define R.cond rcx
   %define R.x rdx
   %define R.y r8
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1754
    cmp       rax,	2
    jz        L1755
    cmp       rax,	3
    jz        L1756
    cmp       rax,	4
    jz        L1757
    cmp       rax,	5
    jz        L1758
    jmp       L1759
L1754:
    mov       rax,	rdx
    cmp       rax,	r8
    setz      al
    movzx     eax,	al
    jmp       L1753
L1755:
    mov       rax,	rdx
    cmp       rax,	r8
    setnz     al
    movzx     eax,	al
    jmp       L1753
L1756:
    mov       rax,	rdx
    cmp       rax,	r8
    setl      al
    movzx     eax,	al
    jmp       L1753
L1757:
    mov       rax,	rdx
    cmp       rax,	r8
    setle     al
    movzx     eax,	al
    jmp       L1753
L1758:
    mov       rax,	rdx
    cmp       rax,	r8
    setge     al
    movzx     eax,	al
    jmp       L1753
L1759:
    mov       rax,	rdx
    cmp       rax,	r8
    setg      al
    movzx     eax,	al
L1753:
L1752:
;---------------
    ret       
;End 
;Proc pc_runaux.cmpword
pc_runaux.cmpword:
;?>>
   %define R.cond rcx
   %define R.x rdx
   %define R.y r8
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1762
    cmp       rax,	2
    jz        L1763
    cmp       rax,	3
    jz        L1764
    cmp       rax,	4
    jz        L1765
    cmp       rax,	5
    jz        L1766
    jmp       L1767
L1762:
    mov       rax,	rdx
    cmp       rax,	r8
    setz      al
    movzx     eax,	al
    jmp       L1761
L1763:
    mov       rax,	rdx
    cmp       rax,	r8
    setnz     al
    movzx     eax,	al
    jmp       L1761
L1764:
    mov       rax,	rdx
    cmp       rax,	r8
    setb      al
    movzx     eax,	al
    jmp       L1761
L1765:
    mov       rax,	rdx
    cmp       rax,	r8
    setbe     al
    movzx     eax,	al
    jmp       L1761
L1766:
    mov       rax,	rdx
    cmp       rax,	r8
    setae     al
    movzx     eax,	al
    jmp       L1761
L1767:
    mov       rax,	rdx
    cmp       rax,	r8
    seta      al
    movzx     eax,	al
L1761:
L1760:
;---------------
    ret       
;End 
;Proc pc_runaux.doincr
pc_runaux.doincr:
;?>>
   %define R.pu8 rcx
   %define R.incr rdx
   %define R.mode r8
;?]]
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	r8
    movzx     rax,	byte [rax + r10]
    cmp       rax,	8
    jz        L1770
    cmp       rax,	4
    jz        L1771
    cmp       rax,	2
    jz        L1772
    jmp       L1773
L1770:
    mov       rax,	rcx
    mov       r10,	rdx
    add       [rax],	r10
    jmp       L1769
L1771:
    mov       rax,	rcx
    mov       r10d,	edx
    add       [rax],	r10d
    jmp       L1769
L1772:
    mov       rax,	rcx
    mov       r10w,	dx
    add       [rax],	r10w
    jmp       L1769
L1773:
    mov       rax,	rcx
    mov       r10b,	dl
    add       [rax],	r10b
L1769:
;---------------
    ret       
;End 
;Proc pc_runaux.docmdskip
pc_runaux.docmdskip:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	[pc_decls.psymboltable]
    jmp       L1778
L1775:
    mov       rax,	[rdi]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    lea       rdx,	[L12314]
    call      mlib.eqstring
    test      rax,	rax
    jz        L1780
    mov       rax,	[rdi+56]
    mov       r10b,	[pc_decls.pcmdskip]
    mov       [rax],	r10b
    jmp       L1777
L1780:
    mov       rdi,	[rdi+8]
L1778:
    test      rdi,	rdi
    jnz       L1775
L1777:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_loadbf
pc_runaux.pci_loadbf:
;?>>
   %define R.a rcx
   %define R.i rdx
   %define R.j r8
   %define R.mask rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
;---------------
    cmp       r8,	rdx
    jae       L1783
    mov       rax,	rdx
    mov       r10,	r8
    mov       r8,	rax
    mov       rdx,	r10
L1783:
    mov       rax,	r8
    sub       rax,	rdx
    inc       rax
    mov       rbx,	rax
    mov       rax,	-1
    push      rcx
    mov       cl,	bl
    shl       rax,	cl
    pop       rcx
    not       rax
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    mov       rdi,	rax
    mov       rax,	rcx
    and       rax,	rdi
    push      rcx
    mov       cl,	dl
    shr       rax,	cl
    pop       rcx
L1781:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_storebf
pc_runaux.pci_storebf:
;?>>
   %define R.a rcx
   %define R.i rdx
   %define R.j r8
   %define R.x r9
   %define R.mask rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
;---------------
    cmp       r8,	rdx
    jae       L1786
    mov       rax,	rdx
    mov       r10,	r8
    mov       r8,	rax
    mov       rdx,	r10
L1786:
    mov       rax,	r8
    sub       rax,	rdx
    inc       rax
    mov       rbx,	rax
    mov       rax,	-1
    push      rcx
    mov       cl,	bl
    shl       rax,	cl
    pop       rcx
    not       rax
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    mov       rdi,	rax
    mov       rax,	r9
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    and       rax,	rdi
    mov       r9,	rax
    mov       rax,	rdi
    not       rax
    mov       r10,	rcx
    and       r10,	rax
    or        r10,	r9
    mov       rax,	r10
L1784:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.genmcl
mc_genmcl.genmcl:
;?>>
    %define mc_genmcl.genmcl.dummy 32
   %define R.tt rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       al,	[pc_decls.mcldone]
    test      al,	al
    jnz       L1787
L1789:
    xor       eax,	eax
    test      ax,	ax
    jnz       L1792
    xor       eax,	eax
    test      ax,	ax
    jz        L1791
L1792:
    call      msys.m$print_startcon
    lea       rcx,	[L12315]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1791:
    call      mwindows.os_clock
    mov       rdi,	rax
    call      mc_genmcl.inithandlers
    xor       ecx,	ecx
    call      mc_libmcl.mclinit
    mov       rax,	[pc_api.pcstart]
    mov       [mc_decls.currpcl],	rax
    xor       rbx,	rbx
L1793:
    mov       rcx,	[mc_decls.currpcl]
    call      mc_genmcl.convertpcl
    xor       eax,	eax
    test      ax,	ax
    jz        L1797
    mov       rax,	[mc_decls.currpcl]
    movzx     rax,	byte [rax]
    cmp       rax,	127
    jz        L1797
    cmp       rax,	135
    jz        L1797
    cmp       rax,	120
    jz        L1797
    cmp       rax,	121
    jz        L1797
    cmp       rax,	20
    jz        L1797
    cmp       rax,	122
    jz        L1797
    call      mc_stackmcl.showopndstack
L1797:
    add       qword [mc_decls.currpcl],	32
    mov       rax,	[mc_decls.currpcl]
    cmp       rax,	[pc_api.pccurr]
    ja        L1798
    mov       rax,	[mc_decls.currpcl]
    movzx     rax,	byte [rax]
    cmp       rax,	136
    jnz       L1793
L1798:
    call      mc_auxmcl.genrealtable
    call      mc_auxmcl.genabsneg
    call      mc_auxmcl.genstringtable
    mov       rcx,	8
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	8
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.fpeephole]
    test      al,	al
    jz        L1800
    call      mc_optim.peephole
L1800:
    mov       al,	1
    mov       [pc_decls.mcldone],	al
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [pc_decls.mcltime],	rax
L1787:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.convertpcl
mc_genmcl.convertpcl:
;?>>
   %define R.p rsi
    %define mc_genmcl.convertpcl.oldregset -16
   %define R.reg rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rsi,	rcx
;---------------
    mov       al,	[rsi+3]
    mov       [mc_decls.pmode],	al
    mov       [mc_decls.currpcl],	rsi
    mov       eax,	[rsi+24]
    mov       [pc_decls.mmpos],	rax
    movsxd    rax,	dword [rsi+28]
    shr       rax,	8
    and       rax,	16777215
    mov       [pc_decls.ppseqno],	rax
    movzx     rax,	byte [rsi]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rsi
    call      r10
    lea       rax,	[mc_decls.regset]
    lea       r10,	[rbp + mc_genmcl.convertpcl.oldregset]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    lea       rax,	[mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rbx,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L1804
L1802:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L1806
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L1808
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L1807
L1808:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L1807:
L1806:
    inc       rbx
    cmp       rbx,	[mc_decls.noperands]
    jle       L1802
L1804:
    mov       rax,	[rbp + mc_genmcl.convertpcl.oldregset]
    lea       r10,	[mc_decls.regset]
    mov       r10,	[r10]
    lea       r11,	[mc_decls.isregvar]
    mov       r11,	[r11]
    or        r10,	r11
    mov       r11,	72340172838076673
    xor       r10,	r11
    and       rax,	r10
    mov       r10,	[mc_decls.mccodex]
    lea       r10,	[r10+48]
    or        [r10],	rax
    mov       rax,	[rbp + mc_genmcl.convertpcl.oldregset+8]
    lea       r10,	[mc_decls.regset]
    mov       r10,	[r10+8]
    lea       r11,	[mc_decls.isregvar]
    mov       r11,	[r11+8]
    or        r10,	r11
    mov       r11,	72340172838076673
    xor       r10,	r11
    and       rax,	r10
    mov       r10,	[mc_decls.mccodex]
    lea       r10,	[r10+56]
    or        [r10],	rax
;---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.inithandlers
mc_genmcl.inithandlers:
;?>>
   %define R.name rdi
   %define R.s rbx
   %define R.n rsi
   %define R.av_1 r12
   %define R.av_2 r13
   %define R.av_3 r14
   %define R.i r15
    %define mc_genmcl.inithandlers.k -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    mov       al,	[mc_genmcl.inithandlers.initdone]
    test      al,	al
    jnz       L1809
L1811:
    mov       rsi,	[$nprocs]
    mov       r15,	1
    cmp       rsi,	1
    jl        L1814
L1812:
    lea       rax,	[$procname]
    mov       r10,	r15
    mov       rdi,	[rax + r10*8-8]
    mov       rcx,	rdi
    lea       rdx,	[L12316]
    mov       r8,	3
    call      mlib.eqbytes
    test      rax,	rax
    jz        L1816
    xor       eax,	eax
    mov       [rbp + mc_genmcl.inithandlers.k],	rax
    mov       r12,	142
    cmp       r12,	0
    jl        L1820
L1817:
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	[rbp + mc_genmcl.inithandlers.k]
    mov       rbx,	[rax + r10*8]
    movzx     rax,	byte [rbx]
    cmp       rax,	107
    jnz       L1822
    inc       rbx
L1822:
    lea       rax,	[rdi+3]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L1824
    lea       rax,	[$procaddr]
    mov       r10,	r15
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r11,	[rbp + mc_genmcl.inithandlers.k]
    mov       [r10 + r11*8],	rax
    jmp       L1819
L1824:
    mov       rax,	[rbp + mc_genmcl.inithandlers.k]
    inc       rax
    mov       [rbp + mc_genmcl.inithandlers.k],	rax
    cmp       rax,	r12
    jle       L1817
L1820:
    lea       rcx,	[L12317]
    mov       rdx,	rdi
    call      pc_api.merror
L1819:
L1816:
    inc       r15
    cmp       r15,	rsi
    jle       L1812
L1814:
    mov       r15,	1
    mov       r13,	8
    cmp       r13,	1
    jl        L1827
L1825:
    lea       rax,	[mc_genmcl.inithandlers.dupltable]
    mov       r10,	r15
    lea       rax,	[rax + r10*2-2]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r10,	[r10 + rax*8]
    lea       rax,	[mc_genmcl.inithandlers.dupltable]
    mov       r11,	r15
    lea       rax,	[rax + r11*2-2]
    movzx     rax,	byte [rax]
    lea       r11,	[mc_genmcl.px_handlertable]
    mov       [r11 + rax*8],	r10
    inc       r15
    cmp       r15,	r13
    jle       L1825
L1827:
    xor       r15,	r15
    mov       rax,	142
    mov       r14,	rax
    cmp       r14,	0
    jl        L1830
L1828:
    lea       rax,	[mc_genmcl.px_handlertable]
    mov       r10,	r15
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jnz       L1832
    lea       rax,	[mc_genmcl.unimpl]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r11,	r15
    mov       [r10 + r11*8],	rax
L1832:
    inc       r15
    cmp       r15,	r14
    jle       L1828
L1830:
    mov       al,	1
    mov       [mc_genmcl.inithandlers.initdone],	al
L1809:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.doshowpcl
mc_genmcl.doshowpcl:
;?>>
   %define R.p rdi
    %define mc_genmcl.doshowpcl.str -1256
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1288
    mov       rdi,	rcx
;---------------
    jmp       L1833
    movzx     rax,	byte [rdi]
    cmp       rax,	120
    jz        L1835
    cmp       rax,	121
    jz        L1835
    cmp       rax,	20
    jz        L1835
    cmp       rax,	122
    jz        L1835
    cmp       rax,	123
    jz        L1835
    cmp       rax,	124
    jz        L1835
    cmp       rax,	125
    jnz       L1836
L1835:
    jmp       L1834
L1836:
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    lea       rdx,	[L12318]
    call      strcpy
    mov       rcx,	rdi
    mov       rdx,	1256
    call      pc_diags.strpclstr
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
L1834:
L1833:
;---------------
    add       rsp,	1288
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.unimpl
mc_genmcl.unimpl:
;?>>
   %define R.p rdi
    %define mc_genmcl.unimpl.str -104
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       rdi,	rcx
;---------------
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12319]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
;---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_nop
mc_genmcl.px_nop:
;?>>
    %define mc_genmcl.px_nop.p 16
;?]]
;---------------
;---
;---------------
    ret       
;End 
;Proc mc_genmcl.px_dupl
mc_genmcl.px_dupl:
;?>>
    %define mc_genmcl.px_dupl.p 16
;?]]
    sub       rsp,	40
;---------------
    call      mc_stackmcl.duplpcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_double
mc_genmcl.px_double:
;?>>
    %define mc_genmcl.px_double.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mc_decls.ncalldepth]
    test      rax,	rax
    jz        L1842
    call      mc_stackmcl.duplpcl
    jmp       L1841
L1842:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	[mc_decls.noperands]
    lea       rax,	[rax + r10-1]
    inc       byte [rax]
L1841:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_opnd
mc_genmcl.px_opnd:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_type
mc_genmcl.px_type:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_comment
mc_genmcl.px_comment:
;?>>
    %define mc_genmcl.px_comment.p 16
;?]]
;---------------
;---
;---------------
    ret       
;End 
;Proc mc_genmcl.px_proc
mc_genmcl.px_proc:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+8]
    mov       [pc_decls.currfunc],	rax
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    mov       rcx,	[pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[pc_decls.currfunc]
    call      mc_auxmcl.initproc
    lea       rcx,	[L12320]
    call      mc_libmcl.mgencomment
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_decls.mclprocentry],	rax
    mov       rax,	[pc_decls.currfunc]
    movzx     rax,	byte [rax+112]
    cmp       rax,	2
    jnz       L1848
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+83]
    test      al,	al
    jz        L1848
    call      mc_auxmcl.fixmain
L1848:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_endproc
mc_genmcl.px_endproc:
;?>>
    %define mc_genmcl.px_endproc.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mc_decls.noperands]
    test      rax,	rax
    jz        L1851
    call      msys.m$print_startcon
    lea       rcx,	[L12321]
    call      msys.m$print_str_nf
    mov       rax,	[pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12321]
    call      mc_libmcl.mgencomment
L1851:
    mov       rcx,	2
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_endprog
mc_genmcl.px_endprog:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_istatic
mc_genmcl.px_istatic:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsxd    rax,	dword [rdi+16]
    mov       rcx,	73
    mov       rdx,	rax
    call      mc_libmcl.setsegment
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_zstatic
mc_genmcl.px_zstatic:
;?>>
   %define R.p rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+8]
    movsxd    rax,	dword [rbx+16]
    mov       rcx,	90
    mov       rdx,	rax
    call      mc_libmcl.setsegment
    mov       rcx,	rdi
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       eax,	[rbx+4]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	124
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_data
mc_genmcl.px_data:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.opc rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    cmp       rax,	11
    jnz       L1857
    mov       rcx,	rsi
    call      mc_auxmcl.do_blockdata
    jmp       L1855
L1857:
    movzx     rax,	byte [rsi+1]
    cmp       rax,	4
    jz        L1859
    cmp       rax,	10
    jz        L1860
    cmp       rax,	11
    jz        L1861
    cmp       rax,	6
    jz        L1862
    cmp       rax,	7
    jz        L1863
    cmp       rax,	2
    jz        L1864
    cmp       rax,	3
    jz        L1865
    jmp       L1866
L1859:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rdi,	rax
    jmp       L1858
L1860:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1858
L1861:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1858
L1862:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1858
L1863:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L1858
L1864:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rdi,	rax
    mov       eax,	[rsi+20]
    mov       [rdi+12],	eax
    jmp       L1858
L1865:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L1858
L1866:
    movzx     rax,	byte [rsi+1]
    lea       r10,	[pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12322]
    mov       rdx,	r10
    call      pc_api.merror
L1858:
    mov       eax,	[rsi+4]
    cmp       rax,	1
    jz        L1868
    cmp       rax,	2
    jz        L1869
    cmp       rax,	4
    jz        L1870
    cmp       rax,	8
    jz        L1871
    jmp       L1872
L1868:
    mov       rbx,	116
    jmp       L1867
L1869:
    mov       rbx,	117
    jmp       L1867
L1870:
    mov       rbx,	118
    jmp       L1867
L1871:
    mov       rbx,	119
    jmp       L1867
L1872:
    call      msys.m$print_startcon
    lea       rcx,	[L12323]
    call      msys.m$print_str_nf
    mov       eax,	[rsi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L12324]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rsi+3]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12325]
    lea       rdx,	[L12326]
    call      pc_api.merror
L1867:
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1855:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_label
mc_genmcl.px_label:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_load
mc_genmcl.px_load:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_stackmcl.pushpcl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_store
mc_genmcl.px_store:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [rsi+3]
    cmp       rax,	11
    jz        L1877
    movzx     rax,	byte [rsi+3]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L1876
L1877:
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rbx,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
L1876:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_add
mc_genmcl.px_add:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [rsi+3]
    cmp       rax,	2
    jle       L1880
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1882
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    cmp       rax,	1
    jnz       L1882
    mov       rcx,	52
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1881
L1882:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1881:
    jmp       L1879
L1880:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [rsi+3]
    dec       rax
    mov       r10,	65
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1879:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sub
mc_genmcl.px_sub:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [rsi+3]
    cmp       rax,	2
    jle       L1885
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1887
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    cmp       rax,	1
    jnz       L1887
    mov       rcx,	53
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1886
L1887:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1886:
    jmp       L1884
L1885:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [rsi+3]
    dec       rax
    mov       r10,	67
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1884:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_mul
mc_genmcl.px_mul:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [rsi+3]
    cmp       rax,	2
    jle       L1890
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1892
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    jmp       L1891
L1892:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	34
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1891:
    jmp       L1889
L1890:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [rsi+3]
    dec       rax
    mov       r10,	69
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1889:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_div
mc_genmcl.px_div:
;?>>
    %define mc_genmcl.px_div.p 32
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	71
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_eval
mc_genmcl.px_eval:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [rdi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_widen
mc_genmcl.px_widen:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	6
    jnz       L1897
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    cmp       rax,	5
    jnz       L1897
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	5
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rax,	[mc_decls.mccodex]
    movzx     rax,	byte [rax+33]
    cmp       rax,	11
    jz        L1899
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
L1899:
    jmp       L1896
L1897:
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1901
    mov       rax,	18
    jmp       L1900
L1901:
    mov       rax,	19
L1900:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L1896:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jump
mc_genmcl.px_jump:
;?>>
   %define R.p rsi
   %define R.labno rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rdi,	[rsi+8]
    lea       rax,	[rsi+32]
    mov       rbx,	rax
    jmp       L1904
L1903:
    add       rbx,	32
L1904:
    movzx     rax,	byte [rbx]
    cmp       rax,	135
    jz        L1903
    movzx     rax,	byte [rbx]
    cmp       rax,	127
    jz        L1907
    cmp       rax,	24
    jz        L1908
    jmp       L1909
L1907:
    mov       rax,	[rbx+8]
    cmp       rax,	rdi
    jz        L1902
L1911:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    cmp       rax,	127
    jnz       L1913
    mov       rax,	[rbx+8]
    cmp       rax,	rdi
    jz        L1902
L1913:
    jmp       L1906
L1908:
    xor       eax,	eax
    mov       [rbx],	al
L1909:
L1906:
    mov       rcx,	rdi
    call      mc_libmcl.mgenlabel
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1902:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_ijump
mc_genmcl.px_ijump:
;?>>
    %define mc_genmcl.px_ijump.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_neg
mc_genmcl.px_neg:
;?>>
    %define mc_genmcl.px_neg.p 24
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1917
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1916
L1917:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_negreal
L1916:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_abs
mc_genmcl.px_abs:
;?>>
    %define mc_genmcl.px_abs.p 32
   %define R.ax rdi
   %define R.lx rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1920
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	26
    mov       rdx,	13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1919
L1920:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_absreal
L1919:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitnot
mc_genmcl.px_bitnot:
;?>>
    %define mc_genmcl.px_bitnot.p 24
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	51
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_not
mc_genmcl.px_not:
;?>>
    %define mc_genmcl.px_not.p 24
   %define R.ax rdi
    %define mc_genmcl.px_not.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	1
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_not.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	40
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_not.$T1]
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_toboolt
mc_genmcl.px_toboolt:
;?>>
   %define R.p r13
   %define R.ax rdi
   %define R.bx rbx
   %define R.cx rsi
   %define R.pmode2 r12b
    %define mc_genmcl.px_toboolt.$T2 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
;---------------
    movsxd    rax,	dword [r13+28]
    and       rax,	255
    mov       r12b,	al
    movzx     rax,	r12b
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	r12b
    cmp       rax,	2
    jg        L1925
    movzx     rax,	r12b
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	3
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    movzx     rax,	r12b
    dec       rax
    mov       r10,	76
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	r12b
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [r13]
    cmp       rax,	64
    jnz       L1927
    mov       rax,	5
    jmp       L1926
L1927:
    mov       rax,	4
L1926:
    mov       rcx,	58
    mov       rdx,	rax
    mov       r8,	rsi
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rsi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rsi
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    jmp       L1924
L1925:
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       rbx,	r10
    mov       [rbp + mc_genmcl.px_toboolt.$T2],	rax
    movzx     rax,	byte [r13]
    cmp       rax,	64
    jnz       L1929
    mov       rax,	5
    jmp       L1928
L1929:
    mov       rax,	4
L1928:
    mov       rcx,	58
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_toboolt.$T2]
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[mc_decls.pmode]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-3],	al
L1924:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sqr
mc_genmcl.px_sqr:
;?>>
    %define mc_genmcl.px_sqr.p 24
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1932
    mov       rcx,	34
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L1931
L1932:
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	69
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
L1931:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sqrt
mc_genmcl.px_sqrt:
;?>>
    %define mc_genmcl.px_sqrt.p 24
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	63
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpcc
mc_genmcl.px_jumpcc:
;?>>
   %define R.p r13
   %define R.mcond rdi
   %define R.ax rbx
   %define R.bx rsi
   %define R.lx r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [r13+2]
    lea       r10,	[mc_genmcl.ucondcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rdi,	r10
    mov       rax,	[r13+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r12,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L1936
    lea       rcx,	[L12327]
    lea       rdx,	[L12328]
    call      pc_api.merror
    jmp       L1935
L1936:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1938
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1940
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    test      rax,	rax
    jnz       L1940
    movzx     rax,	byte [r13+2]
    cmp       rax,	1
    jz        L1941
    cmp       rax,	2
    jnz       L1940
L1941:
    mov       rcx,	41
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L1939
L1940:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1943
    movzx     rax,	byte [r13+2]
    lea       r10,	[mc_genmcl.scondcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rdi,	r10
L1943:
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
L1939:
    jmp       L1937
L1938:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
L1937:
    mov       rcx,	26
    mov       rdx,	rdi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
    mov       eax,	[r13+16]
    test      eax,	eax
    jnz       L1945
    call      mc_stackmcl.poppcl
L1945:
L1935:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpt
mc_genmcl.px_jumpt:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	5
    call      mc_auxmcl.do_jumptruefalse
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpf
mc_genmcl.px_jumpf:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_auxmcl.do_jumptruefalse
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitand
mc_genmcl.px_bitand:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	38
    call      mc_auxmcl.do_bitwise
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitor
mc_genmcl.px_bitor:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	39
    call      mc_auxmcl.do_bitwise
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitxor
mc_genmcl.px_bitxor:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	40
    call      mc_auxmcl.do_bitwise
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_shl
mc_genmcl.px_shl:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	43
    call      mc_auxmcl.do_shift
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_shr
mc_genmcl.px_shr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1954
    mov       rax,	44
    jmp       L1953
L1954:
    mov       rax,	45
L1953:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_shift
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_retproc
mc_genmcl.px_retproc:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_decls.mclprocentry]
    cmp       rax,	[mc_decls.mccodex]
    jnz       L1957
    lea       rcx,	[L12329]
    call      mc_libmcl.mgencomment
L1957:
    mov       rcx,	rdi
    call      mc_auxmcl.do_procentry
    call      mc_auxmcl.do_procexit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_retfn
mc_genmcl.px_retfn:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    %define mc_genmcl.px_retfn.$T1 -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L1960
    mov       rcx,	1
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       [r10],	al
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	[pc_decls.blockretname]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    mov       rcx,	[pc_decls.blockretname]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_genmcl.px_retfn.$T1],	rax
    mov       rcx,	1
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_retfn.$T1]
    call      mc_libmcl.genmc
L1960:
    mov       rcx,	rsi
    call      mc_genmcl.px_retproc
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_setcall
mc_genmcl.px_setcall:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_stackmcl.saveopnds
    mov       rax,	[mc_decls.ncalldepth]
    cmp       rax,	32
    jl        L1963
    lea       rcx,	[L12330]
    lea       rdx,	[L12331]
    call      pc_api.merror
L1963:
    inc       qword [mc_decls.ncalldepth]
    movsxd    rax,	dword [rdi+16]
    cmp       rax,	4
    jg        L1965
    mov       eax,	[mc_decls.mstackdepth]
    and       eax,	1
    lea       r10,	[mc_decls.callalign]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
    jmp       L1964
L1965:
    movsxd    rax,	dword [rdi+16]
    and       eax,	1
    mov       r10d,	[mc_decls.mstackdepth]
    and       r10d,	1
    xor       rax,	r10
    lea       r10,	[mc_decls.callalign]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
L1964:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    setz      al
    movzx     eax,	al
    lea       r10,	[mc_decls.callblockret]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
    mov       eax,	[rdi+4]
    lea       r10,	[mc_decls.callblocksize]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11*4-4],	eax
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L1967
    mov       rcx,	1
    call      mc_libmcl.pushslots
L1967:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_setarg
mc_genmcl.px_setarg:
;?>>
   %define R.p rbx
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+16]
    lea       r10,	[mc_decls.callblockret]
    mov       r11,	[mc_decls.ncalldepth]
    movzx     r10,	byte [r10 + r11-1]
    add       rax,	r10
    mov       rdi,	rax
    cmp       rdi,	4
    jle       L1970
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L1972
    mov       eax,	[rbx+4]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_auxmcl.copyblockarg
L1972:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.pushopnd
    jmp       L1969
L1970:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L1973
    mov       eax,	[rbx+4]
    lea       r10,	[mc_decls.callargsize]
    mov       r11,	[mc_decls.ncalldepth]
    shl       r11,	4
    lea       r10,	[r10 + r11-16]
    mov       r11,	rdi
    mov       [r10 + r11*4-4],	eax
L1973:
L1969:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_callp
mc_genmcl.px_callp:
;?>>
    %define mc_genmcl.px_callp.p 72
   %define R.nargs rdi
   %define R.nregargs rbx
   %define R.slots rsi
   %define R.isptr r12
   %define R.shadow r13
   %define R.blockret r14
   %define R.av_1 r15
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
;---------------
    xor       r12,	r12
    xor       eax,	eax
    mov       r13,	rax
    lea       rax,	[mc_decls.callblockret]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movsxd    rax,	dword [rax+16]
    add       rax,	r14
    mov       rdi,	rax
    mov       rax,	rdi
    mov       r10,	4
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movzx     rax,	byte [rax]
    cmp       rax,	19
    jz        L1977
    cmp       rax,	22
    jnz       L1976
L1977:
    mov       r12,	1
L1976:
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movsxd    rax,	dword [rax+20]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_auxmcl.do_pushlowargs
    xor       rsi,	rsi
    mov       rax,	rdi
    cmp       rax,	4
    jg        L1979
    mov       rax,	[mc_decls.mstackdepth]
    test      rax,	rax
    jz        L1981
    mov       rax,	4
    add       rsi,	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     rax,	byte [rax + r10-1]
    add       rsi,	rax
    jmp       L1980
L1981:
    mov       al,	1
    mov       [pc_decls.localshadow],	al
L1980:
    jmp       L1978
L1979:
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     rax,	byte [rax + r10-1]
    mov       r10,	rdi
    add       r10,	rax
    mov       rsi,	r10
    mov       rcx,	4
    call      mc_libmcl.pushslots
L1978:
    test      r12,	r12
    jz        L1983
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1982
L1983:
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1982:
    mov       rax,	rbx
    sub       rax,	r14
    mov       r15,	rax
    cmp       r15,	0
    jle       L1986
L1984:
    call      mc_stackmcl.poppcl
    dec       r15
    jnz       L1984
L1986:
    test      rsi,	rsi
    jz        L1988
    mov       rcx,	rsi
    call      mc_libmcl.popslots
L1988:
    mov       al,	[mc_decls.pmode]
    test      al,	al
    jz        L1990
    mov       rcx,	[rbp + mc_genmcl.px_callp.p]
    call      mc_auxmcl.do_getretvalue
L1990:
    dec       qword [mc_decls.ncalldepth]
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpret
mc_genmcl.px_jumpret:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       al,	[mc_decls.pmode]
    test      al,	al
    jz        L1993
    mov       rax,	[mc_decls.noperands]
    test      rax,	rax
    jz        L1995
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    mov       r8,	1
    call      mc_stackmcl.loadparam
    call      mc_stackmcl.poppcl
L1995:
L1993:
    mov       rcx,	rdi
    call      mc_genmcl.px_jump
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpretm
mc_genmcl.px_jumpretm:
;?>>
   %define R.p r13
   %define R.n rdi
   %define R.reg rbx
   %define R.av_1 rsi
   %define R.av_2 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movsxd    rax,	dword [r13+16]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	rax
    inc       r10
    mov       rdi,	r10
    movsxd    rax,	dword [r13+16]
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L1999
L1997:
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    inc       rdi
    dec       rsi
    jnz       L1997
L1999:
    mov       rbx,	1
    movsxd    rax,	dword [r13+16]
    mov       r12,	rax
    cmp       r12,	0
    jle       L2002
L2000:
    cmp       rbx,	4
    jnz       L2004
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jle       L2004
    mov       rbx,	11
L2004:
    mov       rcx,	rbx
    call      mc_stackmcl.movetoreg
    call      mc_stackmcl.poppcl
    inc       rbx
    dec       r12
    jnz       L2000
L2002:
    mov       rcx,	r13
    call      mc_genmcl.px_jump
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_startmx
mc_genmcl.px_startmx:
;?>>
    %define mc_genmcl.px_startmx.p 16
;?]]
    sub       rsp,	40
;---------------
    xor       ecx,	ecx
    call      mc_stackmcl.saveopnds
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_resetmx
mc_genmcl.px_resetmx:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	1
    call      mc_stackmcl.movetoreg
    movzx     rax,	byte [rdi]
    cmp       rax,	118
    jnz       L2008
    call      mc_stackmcl.poppcl
L2008:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_stop
mc_genmcl.px_stop:
;?>>
    %define mc_genmcl.px_stop.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    mov       r8,	11
    call      mc_stackmcl.loadparam
    lea       rcx,	[L12332]
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [pc_decls.localshadow],	al
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_incrto
mc_genmcl.px_incrto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_incr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_decrto
mc_genmcl.px_decrto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_incr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_incrload
mc_genmcl.px_incrload:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_incrload
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_decrload
mc_genmcl.px_decrload:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_incrload
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_loadincr
mc_genmcl.px_loadincr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_loadincr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_loaddecr
mc_genmcl.px_loaddecr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_loadincr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_forup
mc_genmcl.px_forup:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    mov       r9,	14
    call      mc_auxmcl.do_for
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_fordown
mc_genmcl.px_fordown:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    mov       r9,	13
    call      mc_auxmcl.do_for
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_iload
mc_genmcl.px_iload:
;?>>
    %define mc_genmcl.px_iload.p 40
   %define R.ax rdi
   %define R.px rbx
   %define R.nextpcl rsi
    %define mc_genmcl.px_iload.$T1 -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jz        L2020
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L2022
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     r10,	byte [r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    jmp       L2021
L2022:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
L2021:
    mov       rax,	[mc_decls.currpcl]
    lea       rax,	[rax+32]
    mov       rsi,	rax
    movzx     rax,	byte [rsi]
    cmp       rax,	114
    jnz       L2024
    movzx     rax,	byte [rsi+3]
    mov       [rbp + mc_genmcl.px_iload.$T1],	rax
    movzx     rax,	byte [rsi+3]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    lea       r10,	[mc_decls.ploadop]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [rsi+3]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    mov       [mc_decls.currpcl],	rsi
    jmp       L2023
L2024:
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_iload.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2023:
    jmp       L2019
L2020:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind_simp
    mov       rbx,	rax
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.dolea
L2019:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.getsharereg
mc_genmcl.getsharereg:
;?>>
   %define R.ax rcx
   %define R.mode rdx
   %define R.reg dil
   %define R.regix bl
    push      rdi
    push      rbx
;?]]
;---------------
    mov       dil,	[rcx+10]
    mov       bl,	[rcx+11]
    cmp       rdx,	2
    jg        L2027
    xor       eax,	eax
    jmp       L2025
L2027:
    test      dil,	dil
    jz        L2029
    movzx     rax,	dil
    lea       r10,	[mc_decls.workregs]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L2030
    movzx     rax,	dil
    cmp       rax,	11
    jl        L2029
    cmp       rax,	14
    jg        L2029
L2030:
    movzx     rax,	dil
    jmp       L2025
L2029:
    test      bl,	bl
    jz        L2031
    movzx     rax,	bl
    lea       r10,	[mc_decls.workregs]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L2032
    movzx     rax,	dil
    cmp       rax,	11
    jl        L2031
    cmp       rax,	14
    jg        L2031
L2032:
    movzx     rax,	bl
    jmp       L2025
L2031:
L2028:
    xor       eax,	eax
L2025:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_iloadx
mc_genmcl.px_iloadx:
;?>>
   %define R.p r12
   %define R.nextpcl rdi
   %define R.ax rbx
   %define R.px rsi
    %define mc_genmcl.px_iloadx.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      mc_auxmcl.do_addrmode
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2035
    movzx     rax,	byte [rsi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
    jmp       L2034
L2035:
    mov       rax,	[mc_decls.currpcl]
    lea       rax,	[rax+32]
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	114
    jnz       L2037
    movzx     rax,	byte [rdi+3]
    mov       [rbp + mc_genmcl.px_iloadx.$T1],	rax
    movzx     rax,	byte [rdi+3]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    movsxd    rax,	dword [rdi+28]
    and       rax,	255
    lea       r10,	[mc_decls.ploadop]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [rdi+3]
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    mov       [mc_decls.currpcl],	rdi
    jmp       L2036
L2037:
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_iloadx.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2036:
L2034:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_istore
mc_genmcl.px_istore:
;?>>
   %define R.p rsi
   %define R.bx rdi
   %define R.px rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L2040
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     r10,	byte [r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    jmp       L2039
L2040:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
L2039:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2042
    mov       rcx,	rbx
    call      mc_stackmcl.makesimpleaddr
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2041
L2042:
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2041:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_istorex
mc_genmcl.px_istorex:
;?>>
   %define R.p rsi
   %define R.cx rdi
   %define R.px rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mc_auxmcl.do_addrmode
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2045
    mov       rcx,	rbx
    call      mc_stackmcl.makesimpleaddr
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2044
L2045:
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2044:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_storem
mc_genmcl.px_storem:
;?>>
   %define R.p r12
   %define R.bx rdi
   %define R.px rbx
   %define R.dblock rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       eax,	[r12+4]
    cmp       rax,	16
    jz        L2048
    lea       rcx,	[L12333]
    lea       rdx,	[L12334]
    call      pc_api.merror
L2048:
    mov       rcx,	16
    call      mc_libmcl.newblocktemp
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rbx,	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_addpx
mc_genmcl.px_addpx:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.cx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mc_auxmcl.do_addrmode
    mov       rbx,	rax
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_subpx
mc_genmcl.px_subpx:
;?>>
   %define R.p r14
   %define R.scale rdi
   %define R.extra rbx
   %define R.ax rsi
   %define R.bx r12
   %define R.z r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    movsxd    rax,	dword [r14+16]
    mov       rdi,	rax
    movsxd    rax,	dword [r14+20]
    mov       rbx,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       r13,	rax
    test      rax,	rax
    jz        L2052
    mov       rax,	[r13+8]
    imul      rax,	rdi
    add       rax,	rbx
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2051
L2052:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r12,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_auxmcl.scaleindex
    mov       rdi,	rax
    cmp       rdi,	1
    jle       L2054
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_auxmcl.mulimm
L2054:
    mov       rcx,	29
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    test      rbx,	rbx
    jz        L2056
    call      msys.m$print_startcon
    lea       rcx,	[L12335]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12336]
    lea       rdx,	[L12337]
    call      pc_api.merror
L2056:
L2051:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_to
mc_genmcl.px_to:
;?>>
   %define R.p rsi
   %define R.q rdi
   %define R.ax rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[rsi+32]
    mov       [mc_decls.currpcl],	rax
    mov       rdi,	rax
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rbx,	rax
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_iswap
mc_genmcl.px_iswap:
;?>>
    %define mc_genmcl.px_iswap.p 48
   %define R.ax rdi
   %define R.bx rbx
   %define R.px rsi
   %define R.qx r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       r12,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jz        L2060
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	r12
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L2059
L2060:
    lea       rcx,	[L12338]
    lea       rdx,	[L12339]
    call      pc_api.merror
L2059:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_swapstk
mc_genmcl.px_swapstk:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsxd    rax,	dword [rdi+20]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	rax
    inc       r10
    movsxd    rax,	dword [rdi+16]
    mov       r11,	[mc_decls.noperands]
    sub       r11,	rax
    inc       r11
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_stackmcl.swapopnds
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_labeldef
mc_genmcl.px_labeldef:
;?>>
   %define R.p rdi
    %define mc_genmcl.px_labeldef.str -104
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+8]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    lea       rdx,	[L12340]
    call      strcat
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    call      mc_libmcl.mgencomment
;---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_addto
mc_genmcl.px_addto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	28
    mov       r8,	65
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_subto
mc_genmcl.px_subto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	29
    mov       r8,	67
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_multo
mc_genmcl.px_multo:
;?>>
   %define R.p r13
   %define R.ax rdi
   %define R.bx rbx
   %define R.cx rsi
   %define R.x r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L2067
    mov       rcx,	r13
    mov       rdx,	69
    call      mc_auxmcl.do_binto_float
    jmp       L2065
L2067:
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	1
    jnz       L2069
    lea       rcx,	[L12341]
    lea       rdx,	[L12342]
    call      pc_api.merror
L2069:
    mov       rcx,	10
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r12,	rax
    test      rax,	rax
    jz        L2071
    mov       rax,	[r12+8]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    jmp       L2070
L2071:
    mov       rcx,	34
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2070:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2065:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitandto
mc_genmcl.px_bitandto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	38
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitorto
mc_genmcl.px_bitorto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	39
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitxorto
mc_genmcl.px_bitxorto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	40
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_shlto
mc_genmcl.px_shlto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	43
    call      mc_auxmcl.do_shiftnto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_shrto
mc_genmcl.px_shrto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2078
    mov       rax,	44
    jmp       L2077
L2078:
    mov       rax,	45
L2077:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_shiftnto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_fix
mc_genmcl.px_fix:
;?>>
   %define R.p rsi
   %define R.fx rdi
   %define R.ax rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.pmin]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    dec       rax
    mov       r10,	84
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_float
mc_genmcl.px_float:
;?>>
   %define R.p r14
   %define R.ax rdi
   %define R.fx rbx
   %define R.lab rsi
   %define R.lab2 r12
   %define R.pmode2 r13b
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    movsxd    rax,	dword [r14+28]
    and       rax,	255
    mov       r13b,	al
    movzx     rax,	r13b
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	r13b
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	4
    jge       L2082
    lea       rcx,	[L12343]
    lea       rdx,	[L12344]
    call      pc_api.merror
L2082:
    movzx     rax,	r13b
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2084
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [r14+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	86
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2083
L2084:
    movzx     rax,	r13b
    cmp       rax,	6
    jnz       L2085
    mov       rcx,	2
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    call      mc_libmcl.mcreatefwdlabel
    mov       rsi,	rax
    call      mc_libmcl.mcreatefwdlabel
    mov       r12,	rax
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	12
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	rsi
    call      mc_libmcl.mdefinefwdlabel
    mov       rax,	[mc_decls.labmask63]
    test      rax,	rax
    jnz       L2087
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [mc_decls.labmask63],	rax
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [mc_decls.laboffset64],	rax
L2087:
    mov       rcx,	[mc_decls.labmask63]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	[mc_decls.laboffset64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	66
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mdefinefwdlabel
;mc_genmcl.px_float.reduce:
L2088:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	1
    jnz       L2090
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	88
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L2090:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2083
L2085:
    mov       rcx,	2
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2088
L2083:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_idiv
mc_genmcl.px_idiv:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	1
    call      mc_auxmcl.do_divrem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_irem
mc_genmcl.px_irem:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_auxmcl.do_divrem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_idivrem
mc_genmcl.px_idivrem:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	2
    call      mc_auxmcl.do_divrem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_clear
mc_genmcl.px_clear:
;?>>
   %define R.p rbx
   %define R.ax rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind_simp
    mov       rdi,	rax
    mov       eax,	[rbx+4]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.clearblock
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_subp
mc_genmcl.px_subp:
;?>>
   %define R.p r12
   %define R.ax rdi
   %define R.bx rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movsxd    rax,	dword [r12+16]
    cmp       rax,	1
    jle       L2097
    movsxd    rax,	dword [r12+16]
    mov       rcx,	rax
    call      mc_libmcl.ispoweroftwo
    mov       rsi,	rax
    test      rsi,	rsi
    jz        L2099
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2098
L2099:
    call      msys.m$print_startcon
    movsxd    rax,	dword [r12+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12345]
    lea       rdx,	[L12346]
    call      pc_api.merror
L2098:
L2097:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_switch
mc_genmcl.px_switch:
;?>>
    %define mc_genmcl.px_switch.p 64
   %define R.minlab rdi
   %define R.maxlab rbx
   %define R.jumplab rsi
   %define R.elselab r12
   %define R.reg r13
   %define R.ax r14
    %define mc_genmcl.px_switch.bx -8
    %define mc_genmcl.px_switch.ax2 -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    movsxd    rax,	dword [rax+16]
    mov       rdi,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    movsxd    rax,	dword [rax+20]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    mov       rsi,	[rax+8]
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    lea       rax,	[rax+32]
    mov       [mc_decls.currpcl],	rax
    mov       rax,	[mc_decls.currpcl]
    mov       r12,	[rax+8]
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r14,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    mov       eax,	[rax+4]
    cmp       rax,	8
    jge       L2102
    mov       rcx,	r14
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_switch.ax2],	r10
    mov       rcx,	18
    mov       rdx,	rax
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       r14,	[rbp + mc_genmcl.px_switch.ax2]
L2102:
    test      rdi,	rdi
    jz        L2104
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
L2104:
    mov       rax,	rbx
    sub       rax,	rdi
    inc       rax
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	3
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    movzx     rax,	byte [pc_api.phighmem]
    cmp       rax,	2
    jnz       L2106
    call      mc_stackmcl.getworkireg
    mov       r13,	rax
    mov       rcx,	r13
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_genmcl.px_switch.bx],	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	[rbp + mc_genmcl.px_switch.bx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [r14+10]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	8
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2105
L2106:
    sub       rsp,	8
    push      0
    mov       rax,	rsi
    push      rax
    push      0
    movzx     rax,	byte [r14+10]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	8
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2105:
    call      mc_stackmcl.poppcl
    mov       rcx,	73
    mov       rdx,	1
    call      mc_libmcl.setsegment
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_switchu
mc_genmcl.px_switchu:
;?>>
    %define mc_genmcl.px_switchu.p 64
   %define R.minlab rdi
   %define R.maxlab rbx
   %define R.jumplab rsi
   %define R.reg r12
   %define R.ax r13
   %define R.bx r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    movsxd    rax,	dword [rax+16]
    mov       rdi,	rax
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    movsxd    rax,	dword [rax+20]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    mov       rsi,	[rax+8]
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r13,	rax
    movzx     rax,	byte [pc_api.phighmem]
    cmp       rax,	2
    jnz       L2109
    call      mc_stackmcl.getworkireg
    mov       r12,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	r12
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       r14,	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	rdi
    neg       rax
    shl       rax,	3
    movzx     r10,	byte [r13+10]
    mov       rcx,	r12
    mov       rdx,	r10
    mov       r8,	8
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2108
L2109:
    sub       rsp,	8
    push      0
    mov       rax,	rsi
    push      rax
    push      0
    mov       rax,	rdi
    neg       rax
    shl       rax,	3
    movzx     r10,	byte [r13+10]
    xor       ecx,	ecx
    mov       rdx,	r10
    mov       r8,	8
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2108:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_swlabel
mc_genmcl.px_swlabel:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_endsw
mc_genmcl.px_endsw:
;?>>
    %define mc_genmcl.px_endsw.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_fwiden
mc_genmcl.px_fwiden:
;?>>
   %define R.p rbx
   %define R.fx rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	89
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       al,	2
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_fnarrow
mc_genmcl.px_fnarrow:
;?>>
   %define R.p rbx
   %define R.fx rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	88
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_truncate
mc_genmcl.px_truncate:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.pmode2 bl
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    mov       bl,	al
    movzx     rax,	bl
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    movzx     r10,	bl
    lea       r11,	[pc_tables.psize]
    movzx     r11,	byte [r11 + r10]
    cmp       rax,	r11
    jz        L2116
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_libmcl.changeopndsize
    movzx     r10,	bl
    lea       r11,	[mc_decls.ploadop]
    movzx     r11,	byte [r11 + r10]
    mov       rcx,	r11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2116:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_typepun
mc_genmcl.px_typepun:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movzx     rax,	word [rdi+8]
    and       rax,	31
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_unload
mc_genmcl.px_unload:
;?>>
    %define mc_genmcl.px_unload.p 16
;?]]
    sub       rsp,	40
;---------------
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_loadbit
mc_genmcl.px_loadbit:
;?>>
    %define mc_genmcl.px_loadbit.p 48
   %define R.ax rdi
   %define R.z rbx
   %define R.i rsi
   %define R.m r12
    %define mc_genmcl.px_loadbit.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       rbx,	rax
    test      rax,	rax
    jz        L2121
    mov       rsi,	[rbx+8]
    mov       rax,	rsi
    cmp       rax,	0
    jl        L2123
    cmp       rax,	31
    jg        L2123
    mov       rax,	5
    jmp       L2122
L2123:
    mov       rax,	6
L2122:
    mov       r12,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L2125
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    cmp       rsi,	63
    jz        L2128
L2127:
L2125:
    jmp       L2120
L2121:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2130
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2130:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2132
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2132:
L2120:
    mov       rcx,	1
    mov       rdx,	5
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_loadbit.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	38
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_loadbit.$T1]
    call      mc_libmcl.genmc
;mc_genmcl.px_loadbit.skip:
L2128:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_assem
mc_genmcl.px_assem:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[pc_api.idomcl_assem]
    test      rax,	rax
    jz        L2135
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       r10,	[pc_api.idomcl_assem]
    call      r10
    jmp       L2134
L2135:
    lea       rcx,	[L12347]
    lea       rdx,	[L12348]
    call      pc_api.merror
L2134:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sin
mc_genmcl.px_sin:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12349]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_cos
mc_genmcl.px_cos:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12350]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_tan
mc_genmcl.px_tan:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12351]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_asin
mc_genmcl.px_asin:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12352]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_acos
mc_genmcl.px_acos:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12353]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_atan
mc_genmcl.px_atan:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12354]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_log
mc_genmcl.px_log:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12355]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_log10
mc_genmcl.px_log10:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12356]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_exp
mc_genmcl.px_exp:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12357]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_round
mc_genmcl.px_round:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12358]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_floor
mc_genmcl.px_floor:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12359]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_ceil
mc_genmcl.px_ceil:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12360]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_atan2
mc_genmcl.px_atan2:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rdi
    lea       rdx,	[L12361]
    mov       r8,	2
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_fmod
mc_genmcl.px_fmod:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rdi
    lea       rdx,	[L12362]
    mov       r8,	2
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_setcc
mc_genmcl.px_setcc:
;?>>
   %define R.p r13
   %define R.cond rdi
   %define R.ax rbx
   %define R.bx rsi
   %define R.cx r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte [r13+2]
    lea       r10,	[mc_genmcl.ucondcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rdi,	r10
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2152
    lea       rcx,	[L12363]
    lea       rdx,	[L12364]
    call      pc_api.merror
    jmp       L2151
L2152:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2153
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2155
    movzx     rax,	byte [r13+2]
    lea       r10,	[mc_genmcl.scondcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rdi,	r10
L2155:
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r12,	rax
    jmp       L2151
L2153:
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	3
    call      mc_stackmcl.getworkregm
    mov       r12,	rax
    movzx     rax,	byte [r12+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_stackmcl.setnewzz
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
L2151:
    mov       rcx,	58
    mov       rdx,	rdi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	r12
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_min
mc_genmcl.px_min:
;?>>
    %define mc_genmcl.px_min.p 16
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2158
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2160
    mov       rax,	15
    jmp       L2159
L2160:
    mov       rax,	7
L2159:
    mov       rcx,	rax
    call      mc_auxmcl.do_max_int
    jmp       L2157
L2158:
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	112
    add       r10,	rax
    mov       rcx,	r10
    call      mc_auxmcl.do_max_float
L2157:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_max
mc_genmcl.px_max:
;?>>
    %define mc_genmcl.px_max.p 16
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2163
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2165
    mov       rax,	12
    jmp       L2164
L2165:
    mov       rax,	2
L2164:
    mov       rcx,	rax
    call      mc_auxmcl.do_max_int
    jmp       L2162
L2163:
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	113
    add       r10,	rax
    mov       rcx,	r10
    call      mc_auxmcl.do_max_float
L2162:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_power
mc_genmcl.px_power:
;?>>
   %define R.p rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2168
    mov       rcx,	82
    call      mc_auxmcl.gethostfn
    mov       rdi,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	2
    call      mc_auxmcl.do_host
    jmp       L2167
L2168:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rbx
    lea       rdx,	[L12365]
    mov       r8,	2
    call      mc_auxmcl.do_maths
L2167:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_minto
mc_genmcl.px_minto:
;?>>
    %define mc_genmcl.px_minto.p 16
    %define mc_genmcl.px_minto.$T1 -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2171
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_minto.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2173
    mov       rax,	14
    jmp       L2172
L2173:
    mov       rax,	6
L2172:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_minto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2170
L2171:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	6
    mov       rdx,	rax
    call      mc_auxmcl.do_maxto_real
L2170:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mc_genmcl.px_maxto
mc_genmcl.px_maxto:
;?>>
    %define mc_genmcl.px_maxto.p 16
    %define mc_genmcl.px_maxto.$T1 -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2176
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_maxto.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2178
    mov       rax,	13
    jmp       L2177
L2178:
    mov       rax,	3
L2177:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_maxto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2175
L2176:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	3
    mov       rdx,	rax
    call      mc_auxmcl.do_maxto_real
L2175:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mc_genmcl.px_negto
mc_genmcl.px_negto:
;?>>
    %define mc_genmcl.px_negto.p 32
   %define R.px rdi
   %define R.fx rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2181
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2180
L2181:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.do_negreal
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2180:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_absto
mc_genmcl.px_absto:
;?>>
    %define mc_genmcl.px_absto.p 40
   %define R.px rdi
   %define R.ax rbx
   %define R.lx rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2184
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	26
    mov       rdx,	13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	50
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2183
L2184:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.do_absreal
L2183:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_addpxto
mc_genmcl.px_addpxto:
;?>>
   %define R.p r12
   %define R.ax rdi
   %define R.bx rbx
   %define R.z rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rsi,	rax
    test      rax,	rax
    jz        L2187
    mov       rax,	[rsi+8]
    movsxd    r10,	dword [r12+16]
    imul      rax,	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2186
L2187:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movsxd    rax,	dword [r12+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2186:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_subpxto
mc_genmcl.px_subpxto:
;?>>
   %define R.p r12
   %define R.ax rdi
   %define R.bx rbx
   %define R.z rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rsi,	rax
    test      rax,	rax
    jz        L2190
    mov       rax,	[rsi+8]
    movsxd    r10,	dword [r12+16]
    imul      rax,	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2189
L2190:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movsxd    rax,	dword [r12+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       eax,	[r12+20]
    test      eax,	eax
    jz        L2192
    lea       rcx,	[L12366]
    lea       rdx,	[L12367]
    call      pc_api.merror
L2192:
L2189:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_divto
mc_genmcl.px_divto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	71
    call      mc_auxmcl.do_binto_float
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitnotto
mc_genmcl.px_bitnotto:
;?>>
    %define mc_genmcl.px_bitnotto.p 24
   %define R.px rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	51
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_notto
mc_genmcl.px_notto:
;?>>
    %define mc_genmcl.px_notto.p 24
   %define R.px rdi
    %define mc_genmcl.px_notto.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	1
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_notto.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	40
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_notto.$T1]
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_toboolto
mc_genmcl.px_toboolto:
;?>>
    %define mc_genmcl.px_toboolto.p 40
   %define R.ax rdi
   %define R.bx rbx
   %define R.px rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	58
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sign
mc_genmcl.px_sign:
;?>>
    %define mc_genmcl.px_sign.p 64
   %define R.ax rdi
   %define R.bx rbx
   %define R.lx1 rsi
   %define R.lx2 r12
   %define R.lx3 r13
   %define R.gtop r14b
    %define mc_genmcl.px_sign.ltop -8
    %define mc_genmcl.px_sign.$T1 -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	10
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mc_libmcl.clearreg
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L2199
    mov       r14b,	7
    mov       al,	2
    mov       [rbp + mc_genmcl.px_sign.ltop],	al
    movzx     rax,	byte [mc_decls.pmode]
    movq      XMM0,	[L12368]
    mov       rdx,	rax
    call      mc_libmcl.mgenrealmem
    movzx     r10,	byte [mc_decls.pmode]
    dec       r10
    mov       r11,	73
    add       r11,	r10
    mov       rcx,	r11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2198
L2199:
    mov       r14b,	15
    mov       al,	12
    mov       [rbp + mc_genmcl.px_sign.ltop],	al
    movzx     rax,	byte [mc_decls.pmode]
    xor       ecx,	ecx
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2198:
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    movzx     r10,	r14b
    mov       rcx,	26
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r12,	r10
    movzx     r10,	byte [rbp + mc_genmcl.px_sign.ltop]
    mov       rcx,	26
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r13,	r10
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_sign.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_sign.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	25
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_loadbf
mc_genmcl.px_loadbf:
;?>>
   %define R.p rsi
   %define R.y rdi
   %define R.z rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rdi,	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       rbx,	rax
    test      rdi,	rdi
    jz        L2202
    test      rbx,	rbx
    jz        L2202
    mov       rax,	[rbx+8]
    mov       r10,	[rdi+8]
    mov       rcx,	rsi
    mov       rdx,	r10
    mov       r8,	rax
    call      mc_auxmcl.do_loadbf_const
    jmp       L2201
L2202:
    mov       rcx,	rsi
    call      mc_auxmcl.do_loadbf_var
L2201:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_storebit
mc_genmcl.px_storebit:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_auxmcl.do_storebit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_storebf
mc_genmcl.px_storebf:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_auxmcl.do_storebf
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_loadall
mc_genmcl.px_loadall:
;?>>
    %define mc_genmcl.px_loadall.p 16
;?]]
    sub       rsp,	40
;---------------
    call      mc_stackmcl.checkallloaded
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_setjmp
mc_genmcl.px_setjmp:
;?>>
   %define R.p r12
   %define R.ax rdi
   %define R.bx rbx
   %define R.lab rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    call      mc_libmcl.mcreatefwdlabel
    mov       rsi,	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    mov       rcx,	6
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabel
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	16
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[mc_decls.dframeopnd]
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    mov       rcx,	r12
    call      mc_stackmcl.freeworkregs
    mov       rcx,	1
    call      mc_stackmcl.movetoreg
    mov       rcx,	rsi
    call      mc_libmcl.mdefinefwdlabel
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_longjmp
mc_genmcl.px_longjmp:
;?>>
    %define mc_genmcl.px_longjmp.p 40
   %define R.ax rdi
   %define R.bx rbx
   %define R.cx rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	16
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	[mc_decls.dframeopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	6
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       rcx,	1
    call      mc_stackmcl.swapopndregs
    mov       rcx,	25
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_initdswx
mc_genmcl.px_initdswx:
;?>>
    %define mc_genmcl.px_initdswx.p 16
;?]]
;---------------
;---
;---------------
    ret       
;End 
;Proc mc_auxmcl.allocregvars
mc_auxmcl.allocregvars:
;?>>
   %define R.skipparams rcx
   %define R.isleaf rdx
    %define mc_auxmcl.allocregvars.params -32
    %define mc_auxmcl.allocregvars.xparams -64
    %define mc_auxmcl.allocregvars.leafparams -96
    %define mc_auxmcl.allocregvars.xleafparams -128
    %define mc_auxmcl.allocregvars.leafparamno -136
    %define mc_auxmcl.allocregvars.xleafparamno -144
    %define mc_auxmcl.allocregvars.locals -400
    %define mc_auxmcl.allocregvars.xlocals -656
   %define R.nparams rdi
   %define R.nxparams rbx
   %define R.nleafparams rsi
   %define R.nxleafparams r12
   %define R.nlocals r13
   %define R.nxlocals r14
   %define R.n r15
    %define mc_auxmcl.allocregvars.reg -664
    %define mc_auxmcl.allocregvars.nl -672
    %define mc_auxmcl.allocregvars.np -680
    %define mc_auxmcl.allocregvars.nlx -688
    %define mc_auxmcl.allocregvars.npx -696
    %define mc_auxmcl.allocregvars.d -704
    %define mc_auxmcl.allocregvars.i -712
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	712
;---------------
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rbx,	rax
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    xor       r13,	r13
    xor       eax,	eax
    mov       r14,	rax
    mov       rax,	[mc_decls.maxregvars]
    add       rax,	[mc_decls.maxxregvars]
    test      rax,	rax
    jz        L2209
L2211:
    test      rcx,	rcx
    jnz       L2213
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+16]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    xor       r15,	r15
    jmp       L2217
L2214:
    inc       r15
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+92]
    test      al,	al
    jz        L2219
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+91]
    test      al,	al
    jnz       L2219
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+88]
    test      al,	al
    jnz       L2219
    cmp       r15,	4
    jg        L2219
    test      rdx,	rdx
    jnz       L2221
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2223
    cmp       rdi,	4
    jge       L2225
    inc       rdi
    mov       rax,	rdi
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.params-8],	r10
L2225:
    jmp       L2222
L2223:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2226
    cmp       rbx,	4
    jge       L2228
    inc       rbx
    mov       rax,	rbx
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xparams-8],	r10
L2228:
L2226:
L2222:
    jmp       L2220
L2221:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2230
    cmp       rsi,	4
    jge       L2232
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.leafparams-8],	r10
    mov       [rbp + rsi + mc_auxmcl.allocregvars.leafparamno-1],	r15b
L2232:
    jmp       L2229
L2230:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2233
    cmp       r12,	4
    jge       L2235
    inc       r12
    mov       rax,	r12
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xleafparams-8],	r10
    mov       [rbp + r12 + mc_auxmcl.allocregvars.xleafparamno-1],	r15b
L2235:
L2233:
L2229:
L2220:
L2219:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       rax,	[rax+16]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
L2217:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    test      rax,	rax
    jnz       L2214
L2213:
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+24]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    jmp       L2239
L2236:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+92]
    test      al,	al
    jz        L2241
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+91]
    test      al,	al
    jnz       L2241
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+88]
    test      al,	al
    jnz       L2241
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2243
    cmp       r13,	32
    jge       L2245
    inc       r13
    mov       rax,	r13
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.locals-8],	r10
L2245:
    jmp       L2242
L2243:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2246
    cmp       r14,	32
    jge       L2246
    inc       r14
    mov       rax,	r14
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xlocals-8],	r10
L2246:
L2242:
L2241:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       rax,	[rax+24]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
L2239:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    test      rax,	rax
    jnz       L2236
    test      r13,	r13
    jnz       L2248
    mov       rax,	[mc_decls.maxregvars]
    mov       r10,	rdi
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.np],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.nl],	rax
    jmp       L2247
L2248:
    test      rdi,	rdi
    jnz       L2249
    mov       rax,	[mc_decls.maxregvars]
    mov       r10,	r13
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.nl],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.np],	rax
    jmp       L2247
L2249:
    mov       [rbp + mc_auxmcl.allocregvars.nl],	r13
    mov       [rbp + mc_auxmcl.allocregvars.np],	rdi
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    add       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    sub       rax,	[mc_decls.maxregvars]
    mov       r15,	rax
    cmp       r15,	0
    jle       L2251
    dec       qword [rbp + mc_auxmcl.allocregvars.np]
    dec       r15
    cmp       r15,	0
    jle       L2253
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    cmp       rax,	0
    jle       L2253
    dec       qword [rbp + mc_auxmcl.allocregvars.np]
    dec       r15
L2253:
    cmp       r15,	0
    jle       L2255
    mov       rax,	r15
    sub       [rbp + mc_auxmcl.allocregvars.nl],	rax
L2255:
L2251:
L2247:
    mov       rax,	4
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    cmp       rax,	1
    jl        L2258
L2256:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.locals-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    inc       qword [rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    jle       L2256
L2258:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    cmp       rax,	1
    jl        L2261
L2259:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.params-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    inc       qword [rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.np]
    jle       L2259
L2261:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rsi,	1
    jl        L2264
L2262:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.leafparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    movzx     rax,	byte [rbp + rax + mc_auxmcl.allocregvars.leafparamno-1]
    add       rax,	11
    dec       rax
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.reg]
    cmp       rax,	11
    jnz       L2266
    mov       al,	1
    mov       [pc_decls.r10used],	al
L2266:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.reg]
    cmp       rax,	12
    jnz       L2268
    mov       al,	1
    mov       [pc_decls.r11used],	al
L2268:
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	rsi
    jle       L2262
L2264:
    test      r14,	r14
    jnz       L2270
    mov       rax,	[mc_decls.maxxregvars]
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	rax
    jmp       L2269
L2270:
    test      rbx,	rbx
    jnz       L2271
    mov       rax,	[mc_decls.maxxregvars]
    mov       r10,	r14
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rax
    jmp       L2269
L2271:
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	r14
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rbx
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    add       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    sub       rax,	[mc_decls.maxregvars]
    mov       r15,	rax
    cmp       r15,	0
    jle       L2273
    dec       qword [rbp + mc_auxmcl.allocregvars.npx]
    dec       r15
    cmp       r15,	0
    jle       L2275
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    cmp       rax,	0
    jle       L2275
    dec       qword [rbp + mc_auxmcl.allocregvars.npx]
    dec       r15
L2275:
    cmp       r15,	0
    jle       L2277
    mov       rax,	r15
    sub       [rbp + mc_auxmcl.allocregvars.nlx],	rax
L2277:
L2273:
L2269:
    mov       rax,	16
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    cmp       rax,	1
    jl        L2280
L2278:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xlocals-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    dec       qword [rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    jle       L2278
L2280:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    cmp       rax,	1
    jl        L2283
L2281:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    dec       qword [rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    jle       L2281
L2283:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       r12,	1
    jl        L2286
L2284:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xleafparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    movzx     rax,	byte [rbp + rax + mc_auxmcl.allocregvars.xleafparamno-1]
    inc       rax
    dec       rax
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	r12
    jle       L2284
L2286:
L2209:
;---------------
    add       rsp,	712
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.initproc
mc_auxmcl.initproc:
;?>>
   %define R.d r15
   %define R.e rdi
   %define R.n rbx
   %define R.r rsi
   %define R.npregs r12
   %define R.av_1 r13
   %define R.av_2 r14
    %define mc_auxmcl.initproc.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
;---------------
    lea       rax,	[mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.workregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.workxregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.isregvar]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.isxregvar]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rax,	3
    mov       [mc_decls.nworkregs],	rax
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10+1],	al
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10+2],	al
    mov       rax,	2
    mov       [mc_decls.nworkxregs],	rax
    mov       al,	1
    lea       r10,	[mc_decls.workxregs]
    mov       [r10+4],	al
    mov       al,	1
    lea       r10,	[mc_decls.workxregs]
    mov       [r10+5],	al
    xor       eax,	eax
    mov       [mc_decls.maxxregvars],	rax
    mov       [mc_decls.maxregvars],	rax
    xor       r12,	r12
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       [pc_decls.pinfo],	rax
    mov       rax,	[pc_decls.pinfo]
    test      rax,	rax
    jnz       L2289
    mov       rax,	10
    mov       [mc_decls.nworkregs],	rax
    mov       rax,	12
    mov       [mc_decls.nworkxregs],	rax
    mov       rsi,	4
L2290:
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    inc       rsi
    cmp       rsi,	10
    jle       L2290
    mov       rsi,	7
L2293:
    mov       al,	1
    lea       r10,	[mc_decls.workxregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    inc       rsi
    cmp       rsi,	16
    jle       L2293
    jmp       L2288
L2289:
    mov       rax,	[pc_decls.currfunc]
    movzx     rax,	byte [rax+112]
    mov       r10,	[pc_decls.pinfo]
    movzx     r10,	byte [r10+4]
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r10,	4
    cmp       r10,	rax
    cmovg     r10,	rax
    mov       r12,	r10
    mov       rax,	4
    mov       [mc_decls.nworkregs],	rax
    mov       rax,	[pc_decls.pinfo]
    mov       al,	[rax+7]
    test      al,	al
    jz        L2297
    inc       qword [mc_decls.nworkregs]
L2297:
    mov       rax,	5
    mov       [mc_decls.nworkxregs],	rax
    mov       rax,	[mc_decls.nworkregs]
    sub       rax,	3
    mov       rbx,	rax
    cmp       r12,	3
    jg        L2299
    test      rbx,	rbx
    jz        L2299
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10+13],	al
    dec       rbx
    cmp       r12,	2
    jg        L2301
    test      rbx,	rbx
    jz        L2301
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10+12],	al
    dec       rbx
L2301:
L2299:
    mov       rsi,	10
    mov       r13,	rbx
    cmp       r13,	0
    jle       L2304
L2302:
    mov       rax,	rsi
    dec       rsi
    mov       r10b,	1
    lea       r11,	[mc_decls.workregs]
    mov       [r11 + rax-1],	r10b
    dec       r13
    jnz       L2302
L2304:
    mov       rsi,	7
    mov       rax,	[mc_decls.nworkxregs]
    sub       rax,	2
    mov       r14,	rax
    cmp       r14,	0
    jle       L2307
L2305:
    mov       rax,	rsi
    inc       rsi
    mov       r10b,	1
    lea       r11,	[mc_decls.workxregs]
    mov       [r11 + rax-1],	r10b
    dec       r14
    jnz       L2305
L2307:
L2288:
    mov       rsi,	4
L2308:
    lea       rax,	[mc_decls.workregs]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2312
    inc       qword [mc_decls.maxregvars]
L2312:
    inc       rsi
    cmp       rsi,	10
    jle       L2308
    mov       rsi,	7
L2313:
    lea       rax,	[mc_decls.workxregs]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2317
    inc       qword [mc_decls.maxxregvars]
L2317:
    inc       rsi
    cmp       rsi,	16
    jle       L2313
    lea       rax,	[mc_decls.usedregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.usedxregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.pcltempflags]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    xor       eax,	eax
    mov       [pc_decls.r11used],	al
    mov       [pc_decls.r10used],	al
    xor       eax,	eax
    mov       [mc_decls.mstackdepth],	rax
    xor       eax,	eax
    mov       [mc_decls.noperands],	rax
    xor       eax,	eax
    mov       [mc_genmcl.framebytes],	rax
    mov       [mc_genmcl.paramoffset],	rax
    mov       [mc_genmcl.frameoffset],	rax
    xor       eax,	eax
    mov       [pc_decls.localshadow],	al
    xor       eax,	eax
    mov       [mc_decls.nblocktemps],	rax
    movzx     rax,	byte [r15+82]
    cmp       rax,	11
    jnz       L2319
    lea       rcx,	[L12369]
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       al,	[r15+82]
    mov       [rdi+82],	al
    mov       al,	1
    mov       [rdi+92],	al
    mov       al,	5
    mov       [rdi+72],	al
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+16]
    mov       [rdi+16],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       [rdi+32],	rax
    mov       rax,	rdi
    mov       r10,	[pc_decls.currfunc]
    mov       [r10+16],	rax
    mov       [pc_decls.blockretname],	rdi
L2319:
    mov       al,	[pc_decls.fregoptim]
    test      al,	al
    jz        L2322
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    test      rax,	rax
    jnz       L2321
L2322:
    jmp       L2287
L2321:
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       al,	[rax+5]
    test      al,	al
    jnz       L2287
L2324:
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    movzx     rax,	byte [rax+3]
    mov       [rbp + mc_auxmcl.initproc.$T1],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+110]
    test      al,	al
    jnz       L2325
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+113]
    test      al,	al
    jz        L2326
L2325:
    mov       rax,	1
    jmp       L2327
L2326:
    xor       eax,	eax
L2327:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.initproc.$T1]
    call      mc_auxmcl.allocregvars
L2287:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_procentry
mc_auxmcl.do_procentry:
;?>>
    %define mc_auxmcl.do_procentry.p 72
   %define R.retmode rdi
   %define R.ntemps rbx
   %define R.hasequiv rsi
   %define R.size r12
   %define R.ax r13
   %define R.d r14
   %define R.rr r15
    %define mc_auxmcl.do_procentry.ff -8
    %define mc_auxmcl.do_procentry.r -16
    %define mc_auxmcl.do_procentry.i -24
    %define mc_auxmcl.do_procentry.$T1 -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
;---------------
    mov       rcx,	[mc_decls.mclprocentry]
    call      mc_auxmcl.setmclentry
    xor       eax,	eax
    mov       [pc_decls.bxspill],	rax
    mov       [pc_decls.bspill],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    test      rax,	rax
    jz        L2331
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       al,	[rax+5]
    test      al,	al
    jnz       L2330
L2331:
    mov       rax,	4
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2332:
    lea       rax,	[mc_decls.usedregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2337
    lea       rax,	[mc_decls.isregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2336
L2337:
    inc       qword [pc_decls.bspill]
L2336:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	10
    jle       L2332
    mov       rax,	7
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2338:
    lea       rax,	[mc_decls.usedxregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2343
    lea       rax,	[mc_decls.isxregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2342
L2343:
    inc       qword [pc_decls.bxspill]
L2342:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	16
    jle       L2338
L2330:
    mov       rax,	[pc_decls.currfunc]
    mov       r14,	[rax+16]
    jmp       L2347
L2344:
    mov       al,	[r14+91]
    test      al,	al
    jz        L2349
    lea       rcx,	[L12370]
    lea       rdx,	[L12371]
    call      pc_api.merror
L2349:
    mov       al,	[r14+90]
    test      al,	al
    jnz       L2351
    mov       rax,	[mc_genmcl.paramoffset]
    add       rax,	16
    mov       r10,	[pc_decls.bspill]
    add       r10,	[pc_decls.bxspill]
    shl       r10,	3
    add       rax,	r10
    mov       [r14+76],	eax
    movsxd    rax,	dword [r14+76]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    jmp       L2350
L2351:
    movzx     rax,	byte [r14+90]
    mov       r15,	rax
    lea       rax,	[mc_decls.usedregs]
    movzx     rax,	byte [rax+14]
    mov       [rbp + mc_auxmcl.do_procentry.ff],	rax
    xor       eax,	eax
    mov       [r14+90],	al
    movzx     rax,	byte [r14+82]
    mov       rcx,	r15
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	6
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [r14+90],	r15b
    mov       al,	[rbp + mc_auxmcl.do_procentry.ff]
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
L2350:
    mov       rax,	8
    add       [mc_genmcl.paramoffset],	rax
    mov       r14,	[r14+16]
L2347:
    test      r14,	r14
    jnz       L2344
    mov       rax,	[pc_decls.currfunc]
    movzx     rax,	byte [rax+82]
    mov       rdi,	rax
    mov       rax,	[pc_decls.currfunc]
    mov       r14,	[rax+24]
    jmp       L2355
L2352:
    movzx     rax,	byte [r14+82]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    mov       r12,	r10
    movzx     rax,	byte [r14+82]
    cmp       rax,	11
    jnz       L2357
    mov       eax,	[r14+84]
    mov       r12,	rax
L2357:
    mov       al,	[r14+92]
    test      al,	al
    jz        L2353
L2359:
    mov       al,	[r14+91]
    test      al,	al
    jz        L2361
    mov       rsi,	1
    jmp       L2360
L2361:
    mov       al,	[r14+90]
    test      al,	al
    jz        L2362
    movzx     rax,	byte [r14+90]
    mov       r15,	rax
    lea       rax,	[mc_decls.usedregs]
    movzx     rax,	byte [rax+14]
    mov       [rbp + mc_auxmcl.do_procentry.ff],	rax
    xor       eax,	eax
    mov       [r14+90],	al
    movzx     rax,	byte [r14+82]
    mov       rcx,	r15
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	6
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [r14+90],	r15b
    mov       al,	[rbp + mc_auxmcl.do_procentry.ff]
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
    jmp       L2360
L2362:
    mov       rcx,	r12
    call      mc_libmcl.roundsizetg
    sub       [mc_genmcl.frameoffset],	rax
    mov       eax,	[mc_genmcl.frameoffset]
    mov       [r14+76],	eax
    movsxd    rax,	dword [r14+76]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L2360:
L2353:
    mov       r14,	[r14+24]
L2355:
    test      r14,	r14
    jnz       L2352
    xor       rbx,	rbx
    mov       rax,	1
    mov       [rbp + mc_auxmcl.do_procentry.i],	rax
L2363:
    lea       rax,	[mc_decls.pcltempflags]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.i]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2367
    inc       rbx
    mov       rax,	8
    sub       [mc_genmcl.frameoffset],	rax
    lea       rax,	[mc_decls.pcltempopnds]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.i]
    mov       r13,	[rax + r10*8-8]
    mov       eax,	[mc_genmcl.frameoffset]
    mov       [r13+12],	eax
    movsxd    rax,	dword [r13+12]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	[pc_decls.currfunc]
    mov       rdx,	[rbp + mc_auxmcl.do_procentry.i]
    call      mc_writenasm.gettempname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L2367:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.i]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.i],	rax
    cmp       rax,	20
    jle       L2363
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+108]
    test      al,	al
    jz        L2369
    mov       rax,	[pc_decls.currfunc]
    mov       ax,	[rax+114]
    test      ax,	ax
    jnz       L2372
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2371
L2372:
    lea       rcx,	[L12372]
    lea       rdx,	[L12373]
    call      pc_api.merror
L2371:
    test      rbx,	rbx
    jz        L2374
    lea       rcx,	[L12374]
    lea       rdx,	[L12375]
    call      pc_api.merror
L2374:
    call      mc_auxmcl.resetmclentry
    jmp       L2328
L2369:
    mov       rax,	[mc_genmcl.frameoffset]
    neg       rax
    mov       [mc_genmcl.framebytes],	rax
    mov       rax,	[pc_decls.bspill]
    add       rax,	[pc_decls.bxspill]
    and       eax,	1
    test      rax,	rax
    jz        L2376
    mov       rax,	[mc_genmcl.framebytes]
    and       rax,	8
    jnz       L2378
    mov       rax,	8
    add       [mc_genmcl.framebytes],	rax
L2378:
    jmp       L2375
L2376:
    mov       rax,	[mc_genmcl.framebytes]
    and       rax,	8
    jz        L2380
    mov       rax,	8
    add       [mc_genmcl.framebytes],	rax
L2380:
L2375:
    mov       al,	[pc_decls.localshadow]
    test      al,	al
    jz        L2382
    mov       rax,	32
    add       [mc_genmcl.framebytes],	rax
L2382:
    mov       rax,	[pc_decls.bspill]
    test      rax,	rax
    jz        L2384
    mov       rax,	4
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2385:
    lea       rax,	[mc_decls.usedregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2390
    lea       rax,	[mc_decls.isregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2389
L2390:
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.r]
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2389:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	10
    jle       L2385
L2384:
    mov       rax,	[pc_decls.bxspill]
    test      rax,	rax
    jz        L2392
    mov       rcx,	1
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       r13,	rax
    mov       rax,	7
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2393:
    lea       rax,	[mc_decls.usedxregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2398
    lea       rax,	[mc_decls.isxregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2397
L2398:
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.r]
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	r13
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2397:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	16
    jle       L2393
L2392:
    lea       rcx,	[L12376]
    call      mc_libmcl.mgencomment
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_auxmcl.mclframesetup],	rax
    call      mc_auxmcl.spillparams
    lea       rcx,	[L12377]
    call      mc_libmcl.mgencomment
    call      mc_auxmcl.resetmclentry
L2328:
;---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_procexit
mc_auxmcl.do_procexit:
;?>>
   %define R.ax rdi
   %define R.r rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12377]
    call      mc_libmcl.mgencomment
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+108]
    test      al,	al
    jz        L2401
    mov       rcx,	22
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2399
L2401:
    mov       rcx,	[mc_auxmcl.mclframesetup]
    call      mc_auxmcl.setmclentryf
    mov       rax,	[mc_genmcl.framebytes]
    test      rax,	rax
    jnz       L2404
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2403
L2404:
    lea       rax,	[mc_decls.usedregs]
    mov       al,	[rax+14]
    test      al,	al
    jz        L2406
    mov       rcx,	12
    mov       rdx,	[mc_decls.dframeopnd]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	[mc_decls.dframeopnd]
    mov       r8,	[mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       rcx,	[mc_genmcl.framebytes]
    call      mc_libmcl.pushstack
    jmp       L2405
L2406:
    mov       rax,	[mc_genmcl.framebytes]
    test      rax,	rax
    jz        L2408
    mov       rax,	[mc_genmcl.framebytes]
    add       rax,	8
    mov       rcx,	rax
    call      mc_libmcl.pushstack
L2408:
L2405:
L2403:
    call      mc_auxmcl.resetmclentryf
    mov       rax,	[mc_genmcl.framebytes]
    test      rax,	rax
    jnz       L2411
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2410
L2411:
    lea       rax,	[mc_decls.usedregs]
    mov       al,	[rax+14]
    test      al,	al
    jz        L2413
    mov       rcx,	[mc_genmcl.framebytes]
    call      mc_libmcl.popstack
    mov       rcx,	13
    mov       rdx,	[mc_decls.dframeopnd]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2412
L2413:
    mov       rax,	[mc_genmcl.framebytes]
    test      rax,	rax
    jz        L2415
    mov       rax,	[mc_genmcl.framebytes]
    add       rax,	8
    mov       rcx,	rax
    call      mc_libmcl.popstack
L2415:
L2412:
L2410:
    mov       rax,	[pc_decls.bxspill]
    test      rax,	rax
    jz        L2417
    mov       rcx,	11
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rbx,	16
L2418:
    lea       rax,	[mc_decls.usedxregs]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2422
    mov       rcx,	13
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2422:
    dec       rbx
    cmp       rbx,	7
    jge       L2418
L2417:
    mov       rax,	[pc_decls.bspill]
    test      rax,	rax
    jz        L2424
    mov       rbx,	10
L2425:
    lea       rax,	[mc_decls.usedregs]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2429
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2429:
    dec       rbx
    cmp       rbx,	4
    jge       L2425
L2424:
    mov       rcx,	22
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2399:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.spillparams
mc_auxmcl.spillparams:
;?>>
   %define R.d rdi
   %define R.ax rbx
   %define R.offset rsi
   %define R.regoffset r12
   %define R.firstoffset r13
   %define R.i r14
    %define mc_auxmcl.spillparams.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rsi,	16
    xor       r12,	r12
    xor       eax,	eax
    mov       r12,	rax
    mov       rax,	[pc_decls.currfunc]
    mov       rdi,	[rax+16]
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+113]
    test      al,	al
    jz        L2432
    movsxd    rax,	dword [rdi+76]
    mov       r13,	rax
    mov       rax,	[pc_decls.currfunc]
    movzx     rax,	byte [rax+112]
    mov       r14,	rax
    cmp       r14,	3
    jg        L2435
L2433:
    sub       rsp,	8
    push      0
    push      0
    push      8
    mov       rax,	r14
    shl       rax,	3
    add       rax,	r13
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rbx,	rax
    lea       rax,	[r14+11]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       r14
    cmp       r14,	3
    jle       L2433
L2435:
L2432:
    jmp       L2439
L2436:
    cmp       r12,	3
    jg        L2438
L2441:
    mov       al,	[rdi+92]
    test      al,	al
    jz        L2443
    mov       al,	[rdi+90]
    test      al,	al
    jnz       L2445
    sub       rsp,	8
    push      0
    push      0
    push      8
    movsxd    rax,	dword [rdi+76]
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rbx,	rax
    movzx     rax,	byte [rdi+82]
    cmp       rax,	2
    jz        L2447
    cmp       rax,	1
    jz        L2448
    jmp       L2449
L2447:
    lea       rax,	[r12+1]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2446
L2448:
    lea       rax,	[r12+1]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	16
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L2446
L2449:
    lea       rax,	[r12+11]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2446:
    jmp       L2444
L2445:
    mov       al,	[rdi+90]
    test      al,	al
    jz        L2450
    movzx     rax,	byte [rdi+82]
    cmp       rax,	2
    jg        L2452
    movzx     rax,	byte [rdi+90]
    cmp       rax,	5
    jl        L2454
    movzx     rax,	byte [rdi+82]
    lea       r10,	[r12+1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    movzx     rax,	byte [rdi+90]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2454:
    jmp       L2451
L2452:
    movzx     rax,	byte [rdi+90]
    cmp       rax,	10
    jg        L2455
    movzx     rax,	byte [rdi+82]
    lea       r10,	[r12+11]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    movzx     rax,	byte [rdi+82]
    movzx     r10,	byte [rdi+90]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2455:
L2451:
L2450:
L2444:
L2443:
    mov       rax,	8
    add       rsi,	rax
    inc       r12
    mov       rdi,	[rdi+16]
L2439:
    test      rdi,	rdi
    jnz       L2436
L2438:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_jumptruefalse
mc_auxmcl.do_jumptruefalse:
;?>>
   %define R.p rsi
   %define R.cond r12
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2458
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2457
L2458:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	76
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2457:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	r12
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_bitwise
mc_auxmcl.do_bitwise:
;?>>
    %define mc_auxmcl.do_bitwise.p 40
   %define R.opc rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_shift
mc_auxmcl.do_shift:
;?>>
    %define mc_auxmcl.do_shift.p 48
   %define R.opc r12
   %define R.ax rdi
   %define R.cx rbx
   %define R.y rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L2462
    movzx     rax,	byte [rsi+1]
    cmp       rax,	4
    jnz       L2462
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2461
L2462:
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2464
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2464:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2466
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2466:
L2461:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.setmclentry
mc_auxmcl.setmclentry:
;?>>
   %define R.p rcx
;?]]
;---------------
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_decls.mce_oldmccodex],	rax
    mov       [mc_decls.mccodex],	rcx
    mov       rax,	[rcx]
    mov       [mc_decls.mce_lastmcl],	rax
    mov       rax,	[rcx+8]
    mov       [mc_decls.mce_nextmcl],	rax
;---------------
    ret       
;End 
;Proc mc_auxmcl.resetmclentry
mc_auxmcl.resetmclentry:
;?>>
   %define R.pnew rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	[mc_decls.mce_lastmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10],	rax
    mov       rax,	[mc_decls.mce_nextmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       rdi,	[mc_decls.mccodex]
    mov       rax,	[mc_decls.mce_oldmccodex]
    mov       [mc_decls.mccodex],	rax
    mov       rax,	rdi
L2468:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.setmclentryf
mc_auxmcl.setmclentryf:
;?>>
   %define R.p rcx
;?]]
;---------------
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_decls.mcf_oldmccodex],	rax
    mov       [mc_decls.mccodex],	rcx
    mov       rax,	[rcx]
    mov       [mc_decls.mcf_lastmcl],	rax
    mov       rax,	[rcx+8]
    mov       [mc_decls.mcf_nextmcl],	rax
;---------------
    ret       
;End 
;Proc mc_auxmcl.resetmclentryf
mc_auxmcl.resetmclentryf:
;?>>
   %define R.pnew rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	[mc_decls.mcf_lastmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10],	rax
    mov       rax,	[mc_decls.mcf_nextmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       rdi,	[mc_decls.mccodex]
    mov       rax,	[mc_decls.mcf_oldmccodex]
    mov       [mc_decls.mccodex],	rax
    mov       rax,	rdi
L2470:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_pushlowargs
mc_auxmcl.do_pushlowargs:
;?>>
   %define R.nargs r15
    %define mc_auxmcl.do_pushlowargs.nvariadics 80
    %define mc_auxmcl.do_pushlowargs.isptr 88
   %define R.ax rdi
   %define R.j rbx
   %define R.k rsi
   %define R.nextireg r12
   %define R.nextxreg r13
   %define R.mode r14
    %define mc_auxmcl.do_pushlowargs.imode -8
    %define mc_auxmcl.do_pushlowargs.blockret -16
    %define mc_auxmcl.do_pushlowargs.dblock -24
    %define mc_auxmcl.do_pushlowargs.av_1 -32
    %define mc_auxmcl.do_pushlowargs.i -40
    %define mc_auxmcl.do_pushlowargs.$T1 -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    test      r15,	r15
    jnz       L2473
    jmp       L2471
L2473:
    lea       rax,	[mc_decls.callblockret]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     rax,	byte [rax + r10-1]
    mov       [rbp + mc_auxmcl.do_pushlowargs.blockret],	rax
    mov       r12,	11
    mov       r13,	1
    xor       rsi,	rsi
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_auxmcl.do_pushlowargs.i],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	r15
    inc       rax
    mov       [rbp + mc_auxmcl.do_pushlowargs.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.av_1]
    jl        L2476
L2474:
    inc       rsi
    cmp       rsi,	1
    jnz       L2478
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.blockret]
    test      rax,	rax
    jz        L2478
    lea       rax,	[mc_decls.callblocksize]
    mov       r10,	[mc_decls.ncalldepth]
    mov       eax,	[rax + r10*4-4]
    mov       rcx,	rax
    call      mc_libmcl.newblocktemp
    mov       [rbp + mc_auxmcl.do_pushlowargs.dblock],	rax
    mov       al,	1
    mov       r10,	[rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       [r10+92],	al
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_pushlowargs.$T1],	rax
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
    jmp       L2477
L2478:
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    sub       rax,	[rbp + mc_auxmcl.do_pushlowargs.isptr]
    add       rax,	[rbp + mc_auxmcl.do_pushlowargs.blockret]
    mov       rbx,	rax
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rax,	r14
    cmp       rax,	11
    jz        L2480
    cmp       rax,	2
    jz        L2481
    cmp       rax,	1
    jz        L2481
    jmp       L2482
L2480:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_stackmcl.loadparam
    mov       rdi,	rax
    lea       rax,	[mc_decls.callargsize]
    mov       r10,	[mc_decls.ncalldepth]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	rsi
    mov       eax,	[rax + r10*4-4]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	rsi
    call      mc_auxmcl.copyblockarg
    jmp       L2479
L2481:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r13
    call      mc_stackmcl.loadparam
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    test      rax,	rax
    jz        L2484
    cmp       rsi,	[rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    jl        L2484
    cmp       r14,	1
    jnz       L2486
    mov       rax,	5
    jmp       L2485
L2486:
    mov       rax,	6
L2485:
    mov       [rbp + mc_auxmcl.do_pushlowargs.imode],	rax
    mov       rcx,	r13
    mov       rdx,	r14
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_pushlowargs.$T1],	rax
    mov       rcx,	r12
    mov       rdx,	[rbp + mc_auxmcl.do_pushlowargs.imode]
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
L2484:
    jmp       L2479
L2482:
;mc_auxmcl.do_pushlowargs.doint:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_stackmcl.loadparam
L2479:
L2477:
    inc       r12
    inc       r13
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    dec       rax
    mov       [rbp + mc_auxmcl.do_pushlowargs.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.av_1]
    jge       L2474
L2476:
L2471:
;---------------
    add       rsp,	88
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_getretvalue
mc_auxmcl.do_getretvalue:
;?>>
   %define R.p r12
   %define R.i rdi
   %define R.n rbx
   %define R.m rsi
    %define mc_auxmcl.do_getretvalue.modes -80
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       r12,	rcx
;---------------
    lea       rax,	[r12+32]
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jnz       L2490
    xor       rbx,	rbx
    jmp       L2492
L2491:
    movzx     rax,	byte [r12+3]
    inc       rbx
    mov       r10,	rbx
    mov       [rbp + r10*8 + mc_auxmcl.do_getretvalue.modes-8],	rax
L2492:
    add       r12,	32
    mov       rax,	r12
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jz        L2491
    lea       rax,	[r12-32]
    mov       [mc_decls.currpcl],	rax
    mov       rdi,	rbx
    cmp       rdi,	1
    jl        L2496
L2494:
    mov       rsi,	[rbp + rdi*8 + mc_auxmcl.do_getretvalue.modes-8]
    cmp       rsi,	2
    jg        L2498
    lea       rax,	[mc_decls.multxregs]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L2497
L2498:
    lea       rax,	[mc_decls.multregs]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
L2497:
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_stackmcl.pushpcl_reg
    dec       rdi
    cmp       rdi,	1
    jge       L2494
L2496:
    jmp       L2489
L2490:
    movzx     rax,	byte [r12+3]
    mov       rcx,	rax
    mov       rdx,	1
    call      mc_stackmcl.pushpcl_reg
L2489:
;---------------
    add       rsp,	112
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.ismemaddr
mc_auxmcl.ismemaddr:
;?>>
   %define R.n rcx
;?]]
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L2501
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax+1]
    cmp       rax,	2
    jnz       L2501
    mov       rax,	1
    jmp       L2499
L2501:
    xor       eax,	eax
L2499:
;---------------
    ret       
;End 
;Proc mc_auxmcl.do_incr
mc_auxmcl.do_incr:
;?>>
   %define R.p rbx
   %define R.incrop rsi
   %define R.addop r12
   %define R.mx rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	byte [rbx+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movsxd    rax,	dword [rbx+16]
    cmp       rax,	1
    jnz       L2504
    mov       rcx,	rsi
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2503
L2504:
    movsxd    rax,	dword [rbx+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2503:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_incrload
mc_auxmcl.do_incrload:
;?>>
   %define R.p rsi
   %define R.incrop r12
   %define R.addop r13
   %define R.ax rdi
   %define R.mx rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     r10,	byte [r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    movsxd    rax,	dword [rsi+16]
    cmp       rax,	1
    jnz       L2507
    mov       rcx,	r12
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2506
L2507:
    movsxd    rax,	dword [rsi+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2506:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rdi+10]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    mov       al,	[mc_decls.pmode]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_loadincr
mc_auxmcl.do_loadincr:
;?>>
   %define R.p rsi
   %define R.incrop r12
   %define R.addop r13
   %define R.ax rdi
   %define R.mx rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movsxd    rax,	dword [rsi+16]
    cmp       rax,	1
    jnz       L2510
    mov       rcx,	r12
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2509
L2510:
    movsxd    rax,	dword [rsi+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2509:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_for
mc_auxmcl.do_for:
;?>>
   %define R.p r13
   %define R.incop r14
    %define mc_auxmcl.do_for.addop 80
    %define mc_auxmcl.do_for.cond 88
   %define R.q rdi
   %define R.r rbx
   %define R.ax rsi
   %define R.bx r12
    %define mc_auxmcl.do_for.mx -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    lea       rax,	[r13+32]
    mov       rdi,	rax
    lea       rax,	[rdi+32]
    mov       [mc_decls.currpcl],	rax
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rdi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_for.mx],	rax
    mov       rax,	[rdi+8]
    mov       al,	[rax+90]
    test      al,	al
    jz        L2513
    movsxd    rax,	dword [r13+16]
    cmp       rax,	1
    jnz       L2515
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2514
L2515:
    movsxd    rax,	dword [r13+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_for.addop]
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2514:
    mov       rsi,	[rbp + mc_auxmcl.do_for.mx]
    jmp       L2512
L2513:
    call      mc_stackmcl.getworkireg
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	[rbp + mc_auxmcl.do_for.mx]
    call      mc_libmcl.genmc
    movsxd    rax,	dword [r13+16]
    cmp       rax,	1
    jnz       L2517
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2516
L2517:
    movsxd    rax,	dword [r13+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_for.addop]
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2516:
    mov       rcx,	11
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    mov       r8,	rsi
    call      mc_libmcl.genmc
L2512:
    movzx     rax,	byte [rbx+1]
    cmp       rax,	4
    jnz       L2519
    mov       rax,	[rbx+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       r12,	rax
    jmp       L2518
L2519:
    mov       rax,	[rbx+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       r12,	rax
L2518:
    mov       rcx,	42
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rax,	[r13+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	[rbp + mc_auxmcl.do_for.cond]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.scaleindex
mc_auxmcl.scaleindex:
;?>>
   %define R.ax rdi
   %define R.scale rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	rbx
    cmp       rax,	1
    jz        L2523
    cmp       rax,	2
    jz        L2523
    cmp       rax,	4
    jz        L2523
    cmp       rax,	8
    jnz       L2522
L2523:
    mov       rax,	rbx
    jmp       L2520
L2522:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.mulimm
    mov       rax,	1
L2520:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.mulimm
mc_auxmcl.mulimm:
;?>>
   %define R.ax rsi
   %define R.n r12
   %define R.shifts rdi
   %define R.m rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rax,	r12
    test      rax,	rax
    jz        L2526
    cmp       rax,	1
    jz        L2527
    cmp       rax,	-1
    jz        L2528
    jmp       L2529
L2526:
    mov       rcx,	rsi
    call      mc_libmcl.clearreg
    jmp       L2524
L2527:
    jmp       L2524
L2528:
    mov       rcx,	50
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2524
L2529:
L2525:
    xor       rdi,	rdi
    mov       rax,	r12
    mov       rbx,	rax
    jmp       L2531
L2530:
    sar       rbx,	1
    inc       rdi
L2531:
    mov       eax,	ebx
    and       eax,	1
    test      rax,	rax
    jz        L2530
    test      rdi,	rdi
    jz        L2534
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2534:
    mov       rax,	rbx
    cmp       rax,	1
    jz        L2536
    cmp       rax,	3
    jz        L2537
    cmp       rax,	5
    jz        L2537
    cmp       rax,	9
    jz        L2537
    jmp       L2538
L2536:
    jmp       L2524
L2537:
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[rbx-1]
    movzx     r10,	byte [rsi+10]
    movzx     r11,	byte [rsi+10]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	14
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2535
L2538:
    test      rdi,	rdi
    jz        L2540
    mov       al,	34
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+33],	al
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+24],	rax
    jmp       L2539
L2540:
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	34
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2539:
L2535:
L2524:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_addrmode
mc_auxmcl.do_addrmode:
;?>>
    %define mc_auxmcl.do_addrmode.p 72
   %define R.px rdi
   %define R.ax rbx
   %define R.bx rsi
    %define mc_auxmcl.do_addrmode.scale -8
   %define R.extra r12
   %define R.offset r13
   %define R.reg r14
    %define mc_auxmcl.do_addrmode.regix -16
    %define mc_auxmcl.do_addrmode.d -24
    %define mc_auxmcl.do_addrmode.q -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movsxd    rax,	dword [rax+16]
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movsxd    rax,	dword [rax+20]
    mov       r12,	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_addrmode.q],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2543
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    mov       rax,	[rax+8]
    imul      rax,	[rbp + mc_auxmcl.do_addrmode.scale]
    add       rax,	r12
    mov       r13,	rax
L2543:
    xor       rdi,	rdi
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-2]
    cmp       rax,	2
    jnz       L2545
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L2547
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-2]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2546
L2547:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2548
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-2]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2546
L2548:
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rsi+10]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     r10,	byte [r10 + r11-2]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2546:
    jmp       L2544
L2545:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_auxmcl.ismemaddr
    test      rax,	rax
    jz        L2549
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    mov       rax,	[rax+8]
    mov       [rbp + mc_auxmcl.do_addrmode.d],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte [rax+72]
    cmp       rax,	3
    jnz       L2553
    movzx     rax,	byte [pc_api.phighmem]
    cmp       rax,	2
    jz        L2552
L2553:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte [rax+72]
    cmp       rax,	5
    jnz       L2551
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte [rax+82]
    cmp       rax,	11
    jnz       L2551
L2552:
    jmp       L2554
L2551:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L2556
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      qword [rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       ecx,	ecx
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2555
L2556:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2557
    sub       rsp,	8
    push      qword [rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       ecx,	ecx
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2555
L2557:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      qword [rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    movzx     rax,	byte [rsi+10]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2555:
    jmp       L2544
L2549:
;mc_auxmcl.do_addrmode.skip:
L2554:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L2559
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2558
L2559:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2560
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2558
L2560:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rsi+10]
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2558:
L2544:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movzx     rax,	byte [rax+3]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    lea       rax,	[rdi+8]
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rax,	rdi
L2541:
;---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.scaleregvar
mc_auxmcl.scaleregvar:
;?>>
   %define R.reg rsi
   %define R.scale r12
   %define R.n r13
   %define R.regix rdi
   %define R.ax rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rax,	[r12]
    cmp       rax,	1
    jz        L2564
    cmp       rax,	2
    jz        L2564
    cmp       rax,	4
    jz        L2564
    cmp       rax,	8
    jnz       L2563
L2564:
    mov       rax,	rsi
    jmp       L2561
L2563:
    call      mc_stackmcl.getworkireg
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    mov       rax,	[r12]
    cmp       rax,	16
    jnz       L2566
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rcx,	rsi
    mov       rdx,	rsi
    mov       r8,	1
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	14
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	8
    mov       [r12],	rax
    jmp       L2565
L2566:
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[r12]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rax,	1
    mov       [r12],	rax
L2565:
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    mov       al,	dil
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    mov       al,	10
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    mov       rax,	rdi
L2561:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.dolea
mc_auxmcl.dolea:
;?>>
   %define R.ax rdi
   %define R.px rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rbx+11]
    movzx     r10,	word [rbx+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	rax
    jnz       L2571
    movsxd    rax,	dword [rbx+12]
    cmp       rax,	r10
    jnz       L2571
    test      rax,	rax
    jnz       L2571
    mov       rax,	1
    jmp       L2572
L2571:
    xor       eax,	eax
L2572:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L2570
    movzx     rax,	byte [rbx+10]
    movzx     r10,	byte [rdi+10]
    cmp       rax,	r10
    jz        L2569
L2570:
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2569:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_binto
mc_auxmcl.do_binto:
;?>>
   %define R.p rsi
   %define R.opc r12
   %define R.fopc r13
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L2575
    mov       rcx,	rsi
    mov       rdx,	r13
    call      mc_auxmcl.do_binto_float
    jmp       L2573
L2575:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [rsi+3]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2573:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_binto_float
mc_auxmcl.do_binto_float:
;?>>
    %define mc_auxmcl.do_binto_float.p 48
   %define R.opc r12
   %define R.px rdi
   %define R.bx rbx
   %define R.cx rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	r12
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_shiftnto
mc_auxmcl.do_shiftnto:
;?>>
    %define mc_auxmcl.do_shiftnto.p 40
   %define R.opc rsi
   %define R.px rdi
   %define R.cx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-2]
    test      rax,	rax
    jnz       L2579
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    movzx     rax,	byte [rax+1]
    cmp       rax,	4
    jnz       L2579
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2578
L2579:
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2581
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2581:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2583
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2583:
L2578:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_divrem
mc_auxmcl.do_divrem:
;?>>
   %define R.p r15
    %define mc_auxmcl.do_divrem.issigned 80
    %define mc_auxmcl.do_divrem.isdiv 88
   %define R.ax rdi
   %define R.bx rbx
   %define R.px rsi
   %define R.q r12
   %define R.opc r13
   %define R.n r14
    %define mc_auxmcl.do_divrem.shifts -8
    %define mc_auxmcl.do_divrem.fdivto -16
    %define mc_auxmcl.do_divrem.locyy -24
    %define mc_auxmcl.do_divrem.loczz -32
    %define mc_auxmcl.do_divrem.$T1 -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_divrem.fdivto],	al
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       [rbp + mc_auxmcl.do_divrem.locyy],	rax
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_auxmcl.do_divrem.loczz],	rax
    movzx     rax,	byte [r15]
    cmp       rax,	94
    jz        L2587
    cmp       rax,	95
    jnz       L2586
L2587:
    mov       rax,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       r10,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       [rbp + mc_auxmcl.do_divrem.loczz],	rax
    mov       [rbp + mc_auxmcl.do_divrem.locyy],	r10
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       al,	1
    mov       [rbp + mc_auxmcl.do_divrem.fdivto],	al
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_stackmcl.makeopndind
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    jmp       L2585
L2586:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
L2585:
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.isimmload
    mov       r12,	rax
    test      r12,	r12
    jz        L2589
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	1
    jnz       L2589
    mov       r14,	[r12+8]
    mov       rax,	r14
    test      rax,	rax
    jz        L2591
    cmp       rax,	1
    jz        L2592
    jmp       L2593
L2591:
    lea       rcx,	[L12378]
    lea       rdx,	[L12379]
    call      pc_api.merror
    jmp       L2590
L2592:
    call      mc_stackmcl.poppcl
    jmp       L2584
L2593:
    mov       rcx,	r14
    call      mc_libmcl.ispoweroftwo
    mov       [rbp + mc_auxmcl.do_divrem.shifts],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.shifts]
    test      rax,	rax
    jz        L2595
    mov       al,	[rbp + mc_auxmcl.do_divrem.fdivto]
    test      al,	al
    jnz       L2595
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.shifts]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.issigned]
    test      rax,	rax
    jz        L2597
    mov       rax,	44
    jmp       L2596
L2597:
    mov       rax,	45
L2596:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L2584
L2595:
L2590:
L2589:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    call      mc_auxmcl.saverdx
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_auxmcl.fixdivopnds
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.issigned]
    test      rax,	rax
    jz        L2599
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	8
    jz        L2601
    cmp       r10,	4
    jz        L2602
    cmp       r10,	2
    jz        L2603
    jmp       L2604
L2601:
    mov       rax,	57
    jmp       L2600
L2602:
    mov       rax,	56
    jmp       L2600
L2603:
    mov       rax,	55
    jmp       L2600
L2604:
    lea       rcx,	[L12380]
    lea       rdx,	[L12381]
    call      pc_api.merror
    xor       eax,	eax
L2600:
    mov       r13,	rax
    mov       rcx,	r13
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       r13,	36
    jmp       L2598
L2599:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	rax
    call      mc_libmcl.clearreg
    mov       r13,	37
L2598:
    mov       rcx,	r13
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    test      rax,	rax
    jz        L2606
    cmp       rax,	2
    jz        L2607
    jmp       L2608
L2606:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    jmp       L2605
L2607:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	2
    call      mc_stackmcl.swapopndregs
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.swapopnds
L2608:
L2605:
    call      mc_auxmcl.restorerdx
    mov       al,	[rbp + mc_auxmcl.do_divrem.fdivto]
    test      al,	al
    jz        L2610
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	13
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_stackmcl.makeopndind
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2610:
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	2
    jz        L2612
    call      mc_stackmcl.poppcl
L2612:
L2584:
;---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.fixdivopnds
mc_auxmcl.fixdivopnds:
;?>>
   %define R.locyy r14
   %define R.loczz r15
   %define R.regx rdi
   %define R.regy rbx
   %define R.zop rsi
   %define R.bx r12
   %define R.ax r13
    %define mc_auxmcl.fixdivopnds.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
;---------------
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	r15
    movzx     rax,	byte [rax + r10-1]
    mov       rbx,	rax
    cmp       rdi,	1
    jz        L2613
L2615:
    mov       rcx,	r14
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       r12,	rax
    mov       rcx,	r15
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       r13,	rax
    cmp       rbx,	1
    jnz       L2617
    mov       rcx,	27
    mov       rdx,	r12
    mov       r8,	r13
    call      mc_libmcl.genmc
    mov       rcx,	r14
    mov       rdx,	r15
    call      mc_stackmcl.swapopnds
    jmp       L2613
L2617:
    lea       rax,	[mc_decls.regset]
    movzx     rax,	byte [rax]
    test      rax,	rax
    jnz       L2619
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_libmcl.genmc
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	r14
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       [r10],	al
    jmp       L2613
L2619:
    mov       rsi,	[mc_decls.noperands]
    cmp       rsi,	1
    jl        L2623
L2620:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L2625
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L2622
L2625:
    dec       rsi
    cmp       rsi,	1
    jge       L2620
L2623:
    jmp       L2613
L2622:
    mov       rcx,	r14
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.fixdivopnds.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixdivopnds.$T1]
    call      mc_libmcl.genmc
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	r14
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rsi
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
L2613:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.saverdx
mc_auxmcl.saverdx:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       al,	[pc_decls.r11used]
    test      al,	al
    jz        L2628
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2628:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_auxmcl.restorerdx
mc_auxmcl.restorerdx:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       al,	[pc_decls.r11used]
    test      al,	al
    jz        L2631
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2631:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_auxmcl.clearblock
mc_auxmcl.clearblock:
;?>>
    %define mc_auxmcl.clearblock.ax 64
    %define mc_auxmcl.clearblock.n 72
   %define R.rx rdi
   %define R.rcount rbx
   %define R.nwords rsi
   %define R.lab r12
   %define R.oddbytes r13
   %define R.offset r14
    %define mc_auxmcl.clearblock.countreg -8
    %define mc_auxmcl.clearblock.av_1 -16
    %define mc_auxmcl.clearblock.i -24
    %define mc_auxmcl.clearblock.$T1 -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    mov       r10,	8
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       r13,	rax
    mov       rax,	r13
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    sar       rax,	3
    mov       rsi,	rax
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    xor       r14,	r14
    mov       rax,	rsi
    cmp       rax,	1
    jl        L2634
    cmp       rax,	8
    jg        L2634
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       [rbp + mc_auxmcl.clearblock.av_1],	rsi
    mov       rax,	[rbp + mc_auxmcl.clearblock.av_1]
    cmp       rax,	0
    jle       L2637
L2635:
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       r14,	rax
    dec       qword [rbp + mc_auxmcl.clearblock.av_1]
    jnz       L2635
L2637:
    jmp       L2633
L2634:
    test      rsi,	rsi
    jz        L2638
    mov       rax,	rsi
    and       rax,	3
    jz        L2640
    call      mc_stackmcl.getworkireg
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.clearblock.countreg],	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    inc       qword [pc_api.mlabelno]
    mov       r12,	[pc_api.mlabelno]
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.clearblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.ax]
    movzx     rax,	byte [rax+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       r14,	r14
    jmp       L2639
L2640:
    call      mc_stackmcl.getworkireg
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.clearblock.countreg],	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    inc       qword [pc_api.mlabelno]
    mov       r12,	[pc_api.mlabelno]
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rax,	rsi
    sar       rax,	2
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	1
    mov       [rbp + mc_auxmcl.clearblock.i],	rax
L2641:
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       r14,	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.i]
    inc       rax
    mov       [rbp + mc_auxmcl.clearblock.i],	rax
    cmp       rax,	4
    jle       L2641
    mov       rcx,	32
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.clearblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.ax]
    movzx     rax,	byte [rax+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       r14,	r14
L2639:
L2638:
L2633:
    test      r13,	r13
    jz        L2645
    mov       [rbp + mc_auxmcl.clearblock.n],	r13
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	4
    jl        L2647
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	4
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	4
    add       r14,	rax
L2647:
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	2
    jl        L2649
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	2
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	2
    add       r14,	rax
L2649:
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	1
    jnz       L2651
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2651:
L2645:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_blockdata
mc_auxmcl.do_blockdata:
;?>>
   %define R.p r14
   %define R.d rdi
   %define R.n rbx
   %define R.nwords rsi
   %define R.r r12
   %define R.av_1 r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       eax,	[r14+4]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L2654
    jmp       L2652
L2654:
    mov       rax,	rbx
    sar       rax,	3
    mov       rsi,	rax
    mov       rdi,	[r14+8]
    mov       r13,	rsi
    cmp       r13,	0
    jle       L2657
L2655:
    mov       rax,	rdi
    add       rdi,	8
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    dec       r13
    jnz       L2655
L2657:
    mov       rax,	rsi
    shl       rax,	3
    mov       r10,	rbx
    sub       r10,	rax
    mov       r12,	r10
    test      r12,	r12
    jz        L2659
    mov       rcx,	rdi
    mov       rdx,	r12
    mov       r8,	66
    call      mc_auxmcl.genstring_db
L2659:
    lea       rcx,	[L12382]
    call      mc_libmcl.mgencomment
L2652:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.copyblock
mc_auxmcl.copyblock:
;?>>
   %define R.ax r13
   %define R.bx r14
    %define mc_auxmcl.copyblock.n 88
    %define mc_auxmcl.copyblock.savedest 96
   %define R.rx rdi
   %define R.rcount rbx
   %define R.nwords rsi
   %define R.lab r12
    %define mc_auxmcl.copyblock.oddbytes -8
    %define mc_auxmcl.copyblock.offset -16
    %define mc_auxmcl.copyblock.axreg -24
    %define mc_auxmcl.copyblock.saved -32
    %define mc_auxmcl.copyblock.av_1 -40
    %define mc_auxmcl.copyblock.$T1 -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+88],	r8
    mov       [rbp+96],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.saved],	al
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	16
    jnz       L2662
    mov       rcx,	2
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	91
    mov       rdx,	rdi
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       rcx,	91
    mov       rdx,	r13
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2660
L2662:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    mov       r10,	8
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rbp + mc_auxmcl.copyblock.oddbytes],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    sar       rax,	3
    mov       rsi,	rax
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.offset],	rax
    mov       rax,	rsi
    cmp       rax,	1
    jl        L2664
    cmp       rax,	4
    jg        L2664
    mov       rcx,	r13
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r13,	rax
    mov       rcx,	r14
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r14,	rax
    mov       [rbp + mc_auxmcl.copyblock.av_1],	rsi
    mov       rax,	[rbp + mc_auxmcl.copyblock.av_1]
    cmp       rax,	0
    jle       L2667
L2665:
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
    dec       qword [rbp + mc_auxmcl.copyblock.av_1]
    jnz       L2665
L2667:
    jmp       L2663
L2664:
    test      rsi,	rsi
    jz        L2668
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    inc       qword [pc_api.mlabelno]
    mov       r12,	[pc_api.mlabelno]
    mov       rax,	[rbp + mc_auxmcl.copyblock.savedest]
    test      rax,	rax
    jz        L2670
    movzx     rax,	byte [r13+10]
    mov       [rbp + mc_auxmcl.copyblock.axreg],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblock.axreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rbp + mc_auxmcl.copyblock.saved],	al
L2670:
    mov       rcx,	r13
    call      mc_stackmcl.makesimpleaddr
    mov       r13,	rax
    mov       rcx,	r14
    call      mc_stackmcl.makesimpleaddr
    mov       r14,	rax
    lea       rax,	[r13+8]
    mov       r10w,	8
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	r13
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.copyblock.$T1],	rax
    movzx     rax,	byte [r13+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.copyblock.$T1],	rax
    movzx     rax,	byte [r14+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.offset],	rax
L2668:
L2663:
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    test      rax,	rax
    jz        L2672
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    mov       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	4
    jl        L2674
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	4
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	4
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L2674:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	2
    jl        L2676
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	2
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	2
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L2676:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	1
    jnz       L2678
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2678:
L2672:
    mov       al,	[rbp + mc_auxmcl.copyblock.saved]
    test      al,	al
    jz        L2680
    mov       rcx,	[rbp + mc_auxmcl.copyblock.axreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2680:
L2660:
;---------------
    add       rsp,	88
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.genstringtable
mc_auxmcl.genstringtable:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mc_decls.cstringlist]
    test      rax,	rax
    jz        L2681
L2683:
    lea       rcx,	[L12383]
    call      mc_libmcl.mgencomment
    mov       rcx,	73
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rax,	[mc_decls.kk0used]
    test      rax,	rax
    jz        L2685
    mov       rcx,	[mc_decls.kk0used]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
L2685:
    mov       rdi,	[mc_decls.cstringlist]
    jmp       L2689
L2686:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	-1
    xor       r8d,	r8d
    call      mc_auxmcl.genstring_db
    mov       rdi,	[rdi+8]
L2689:
    test      rdi,	rdi
    jnz       L2686
L2681:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.genstring_db
mc_auxmcl.genstring_db:
;?>>
   %define R.s r13
   %define R.length r14
   %define R.strtype r15
   %define R.c rdi
   %define R.seqlen rbx
   %define R.seq rsi
   %define R.av_1 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    cmp       r14,	-1
    jnz       L2692
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L2692:
    test      r14,	r14
    jnz       L2694
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
    jmp       L2690
L2694:
    xor       rbx,	rbx
    mov       rax,	r14
    mov       r12,	rax
    cmp       r12,	0
    jle       L2697
L2695:
    mov       rax,	r13
    inc       r13
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rdi,	32
    jl        L2700
    cmp       rdi,	127
    jge       L2700
    mov       rax,	rdi
    cmp       rax,	34
    jz        L2701
    cmp       rax,	92
    jnz       L2699
L2701:
L2700:
    test      rbx,	rbx
    jz        L2703
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_auxmcl.gendbstring
    xor       rbx,	rbx
L2703:
    mov       rcx,	rdi
    call      mc_auxmcl.gendb
    jmp       L2698
L2699:
    test      rbx,	rbx
    jnz       L2705
    mov       rbx,	1
    lea       rax,	[r13-1]
    mov       rsi,	rax
    jmp       L2704
L2705:
    inc       rbx
L2704:
L2698:
    dec       r12
    jnz       L2695
L2697:
    test      rbx,	rbx
    jz        L2707
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_auxmcl.gendbstring
L2707:
    test      r15,	r15
    jnz       L2709
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
L2709:
L2690:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.gendb
mc_auxmcl.gendb:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	116
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.gendbstring
mc_auxmcl.gendbstring:
;?>>
   %define R.s rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenstring
    mov       rcx,	116
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.gendq
mc_auxmcl.gendq:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.genrealtable
mc_auxmcl.genrealtable:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mc_decls.creallist]
    test      rax,	rax
    jnz       L2715
    mov       rax,	[mc_decls.cr32list]
    test      rax,	rax
    jz        L2713
L2715:
    lea       rcx,	[L12384]
    call      mc_libmcl.mgencomment
    mov       rcx,	73
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rdi,	[mc_decls.creallist]
    jmp       L2719
L2716:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movq      XMM4,	[rdi]
    comisd    XMM4,	[L12385]
    jnz       L2721
    movq      XMM4,	[rdi]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2720
L2721:
    movq      XMM4,	[rdi]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2720:
    mov       rdi,	[rdi+8]
L2719:
    test      rdi,	rdi
    jnz       L2716
    lea       rcx,	[L12386]
    call      mc_libmcl.mgencomment
    mov       rdi,	[mc_decls.cr32list]
    jmp       L2725
L2722:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movq      XMM4,	[rdi]
    comisd    XMM4,	[L12387]
    jnz       L2727
    movq      XMM4,	[rdi]
    cvtsd2ss  XMM4,	XMM4
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	118
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2726
L2727:
    movq      XMM4,	[rdi]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rcx,	118
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2726:
    mov       rdi,	[rdi+8]
L2725:
    test      rdi,	rdi
    jnz       L2722
L2713:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.genabsneg
mc_auxmcl.genabsneg:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mc_decls.lababs32]
    add       rax,	[mc_decls.lababs64]
    add       rax,	[mc_decls.labneg32]
    add       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jz        L2730
    mov       rcx,	73
    mov       rdx,	16
    call      mc_libmcl.setsegment
L2730:
    mov       rax,	[mc_decls.lababs32]
    test      rax,	rax
    jz        L2732
    lea       rcx,	[L12388]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.lababs32]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372034707292159
    call      mc_auxmcl.gendq
    mov       rcx,	9223372034707292159
    call      mc_auxmcl.gendq
L2732:
    mov       rax,	[mc_decls.lababs64]
    test      rax,	rax
    jz        L2734
    lea       rcx,	[L12389]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.lababs64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
L2734:
    mov       rax,	[mc_decls.labneg32]
    test      rax,	rax
    jz        L2736
    lea       rcx,	[L12390]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labneg32]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
    mov       rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
L2736:
    mov       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jz        L2738
    lea       rcx,	[L12391]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labneg64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
    mov       rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
L2738:
    mov       rax,	[mc_decls.labzero]
    test      rax,	rax
    jz        L2740
    lea       rcx,	[L12392]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labzero]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    xor       ecx,	ecx
    call      mc_auxmcl.gendq
L2740:
    mov       rax,	[mc_decls.labmask63]
    test      rax,	rax
    jz        L2742
    lea       rcx,	[L12393]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labmask63]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       rcx,	[mc_decls.laboffset64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	4890909195324358656
    call      mc_auxmcl.gendq
L2742:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_auxmcl.do_maths
mc_auxmcl.do_maths:
;?>>
   %define R.p rdi
   %define R.opname rbx
   %define R.nargs rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	rsi
    call      mc_auxmcl.do_callrts
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_host
mc_auxmcl.do_host:
;?>>
   %define R.p rdi
   %define R.d rbx
   %define R.nargs rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    mov       r9,	rsi
    call      mc_auxmcl.do_callrts
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_callrts
mc_auxmcl.do_callrts:
;?>>
   %define R.p rsi
   %define R.opname r12
   %define R.d r13
   %define R.nargs r14
   %define R.slots rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    mov       rcx,	r14
    call      mc_stackmcl.saveopnds
    xor       rdi,	rdi
    mov       eax,	[mc_decls.mstackdepth]
    and       eax,	1
    test      rax,	rax
    jz        L2747
    mov       rcx,	1
    call      mc_libmcl.pushslots
    mov       rdi,	1
L2747:
    mov       rcx,	r14
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_auxmcl.do_pushlowargs
    mov       rax,	[mc_decls.mstackdepth]
    test      rax,	rax
    jz        L2749
    mov       rax,	4
    add       rdi,	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
    jmp       L2748
L2749:
    mov       al,	1
    mov       [pc_decls.localshadow],	al
L2748:
    test      r12,	r12
    jz        L2751
    mov       rcx,	r12
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2750
L2751:
    mov       rcx,	r13
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2750:
    mov       rbx,	r14
    cmp       rbx,	0
    jle       L2754
L2752:
    call      mc_stackmcl.poppcl
    dec       rbx
    jnz       L2752
L2754:
    test      rdi,	rdi
    jz        L2756
    mov       rcx,	rdi
    call      mc_libmcl.popslots
L2756:
    mov       rcx,	rsi
    call      mc_auxmcl.do_getretvalue
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_max_int
mc_auxmcl.do_max_int:
;?>>
   %define R.cond rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	15
    mov       rdx,	rsi
    mov       r8,	rdi
    mov       r9,	rbx
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_max_float
mc_auxmcl.do_max_float:
;?>>
   %define R.opc rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_maxto_int
mc_auxmcl.do_maxto_int:
;?>>
   %define R.cond r13
    %define mc_auxmcl.do_maxto_int.mode 64
   %define R.ax rdi
   %define R.bx rbx
   %define R.lx rsi
   %define R.lab r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    inc       qword [pc_api.mlabelno]
    mov       r12,	[pc_api.mlabelno]
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	26
    mov       rdx,	r13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_maxto_real
mc_auxmcl.do_maxto_real:
;?>>
   %define R.cond r14
    %define mc_auxmcl.do_maxto_real.mode 72
   %define R.px rdi
   %define R.ax rbx
   %define R.bx rsi
   %define R.lx r12
   %define R.lab r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r14,	rcx
    mov       [rbp+72],	rdx
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
    mov       rcx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_maxto_real.mode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    inc       qword [pc_api.mlabelno]
    mov       r13,	[pc_api.mlabelno]
    mov       rcx,	r13
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r12,	r10
    mov       rcx,	26
    mov       rdx,	r14
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_negreal
mc_auxmcl.do_negreal:
;?>>
   %define R.ax rdi
    %define mc_auxmcl.do_negreal.mode 32
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    test      rax,	rax
    jz        L2763
    mov       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jnz       L2765
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.labneg64],	rax
L2765:
    mov       rcx,	[mc_decls.labneg64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	77
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2762
L2763:
    mov       rax,	[mc_decls.labneg32]
    test      rax,	rax
    jnz       L2767
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.labneg32],	rax
L2767:
    mov       rcx,	[mc_decls.labneg32]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	76
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2762:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_absreal
mc_auxmcl.do_absreal:
;?>>
   %define R.ax rdi
    %define mc_auxmcl.do_absreal.mode 32
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    test      rax,	rax
    jz        L2770
    mov       rax,	[mc_decls.lababs64]
    test      rax,	rax
    jnz       L2772
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.lababs64],	rax
L2772:
    mov       rcx,	[mc_decls.lababs64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	79
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2769
L2770:
    mov       rax,	[mc_decls.lababs32]
    test      rax,	rax
    jnz       L2774
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.lababs32],	rax
L2774:
    mov       rcx,	[mc_decls.lababs32]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	78
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2769:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_loadbf_const
mc_auxmcl.do_loadbf_const:
;?>>
    %define mc_auxmcl.do_loadbf_const.p 56
   %define R.i r12
   %define R.j r13
   %define R.ax rdi
   %define R.mx rbx
   %define R.mask rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    cmp       r13,	63
    jnz       L2777
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	44
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2776
L2777:
    test      r12,	r12
    jz        L2779
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2779:
    mov       rax,	r13
    sub       rax,	r12
    inc       rax
    mov       r10,	-1
    mov       cl,	al
    shl       r10,	cl
    not       r10
    mov       rsi,	r10
    cmp       rsi,	2147483647
    ja        L2781
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2780
L2781:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2780:
L2776:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_loadbf_var
mc_auxmcl.do_loadbf_var:
;?>>
    %define mc_auxmcl.do_loadbf_var.p 16
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12394]
    lea       rdx,	[L12395]
    call      pc_api.merror
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_auxmcl.do_storebit
mc_auxmcl.do_storebit:
;?>>
    %define mc_auxmcl.do_storebit.p 72
   %define R.px rdi
   %define R.ax rbx
   %define R.cx rsi
   %define R.ix r12
   %define R.q r13
   %define R.r r14
   %define R.i r15
    %define mc_auxmcl.do_storebit.offset -8
    %define mc_auxmcl.do_storebit.mask1s -16
    %define mc_auxmcl.do_storebit.mask0s -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
;---------------
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       r13,	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r14,	rax
    test      r13,	r13
    jz        L2785
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       r15,	[r13+8]
    mov       rax,	r15
    sar       rax,	3
    mov       [rbp + mc_auxmcl.do_storebit.offset],	rax
    mov       rax,	7
    and       r15,	rax
    mov       rcx,	rdi
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rdi,	rax
    mov       rax,	1
    mov       cl,	r15b
    shl       rax,	cl
    mov       [rbp + mc_auxmcl.do_storebit.mask0s],	al
    mov       rax,	1
    mov       cl,	r15b
    shl       rax,	cl
    not       rax
    mov       [rbp + mc_auxmcl.do_storebit.mask1s],	al
    test      r14,	r14
    jz        L2787
    mov       rax,	[r14+8]
    test      rax,	rax
    jnz       L2789
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask1s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2788
L2789:
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask0s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2788:
    jmp       L2786
L2787:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    mov       rdx,	3
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask1s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    test      r15,	r15
    jz        L2791
    mov       rcx,	r15
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2791:
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2786:
    jmp       L2784
L2785:
    test      r14,	r14
    jz        L2792
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    test      r13,	r13
    jnz       L2794
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rsi,	rax
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2796
    mov       rcx,	12
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2796:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       r12,	rax
    mov       rcx,	rsi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	43
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2798
    mov       rcx,	13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2798:
    mov       rax,	[r14+8]
    test      rax,	rax
    jnz       L2800
    mov       rcx,	51
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L2799
L2800:
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2799:
    jmp       L2793
L2794:
    lea       rcx,	[L12396]
    lea       rdx,	[L12397]
    call      pc_api.merror
L2793:
    jmp       L2784
L2792:
    lea       rcx,	[L12398]
    lea       rdx,	[L12399]
    call      pc_api.merror
L2784:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_storebf
mc_auxmcl.do_storebf:
;?>>
    %define mc_auxmcl.do_storebf.p 72
   %define R.ax rdi
   %define R.rx rbx
   %define R.mx rsi
   %define R.dx r12
   %define R.i r13
   %define R.j r14
   %define R.q r15
    %define mc_auxmcl.do_storebf.r -8
    %define mc_auxmcl.do_storebf.mask -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r15,	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_storebf.r],	rax
    mov       rax,	[rbp + mc_auxmcl.do_storebf.r]
    cmp       rax,	r15
    jnz       L2803
    test      rax,	rax
    jnz       L2803
    lea       rcx,	[L12400]
    lea       rdx,	[L12401]
    call      pc_api.merror
L2803:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	3
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r12,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       r13,	[r15+8]
    mov       rax,	[rbp + mc_auxmcl.do_storebf.r]
    mov       r14,	[rax+8]
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	r14
    sub       rax,	r13
    inc       rax
    mov       r10,	-1
    mov       cl,	al
    shl       r10,	cl
    not       r10
    mov       cl,	r13b
    shl       r10,	cl
    not       r10
    mov       [rbp + mc_auxmcl.do_storebf.mask],	r10
    mov       rcx,	[rbp + mc_auxmcl.do_storebf.mask]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    test      r13,	r13
    jz        L2805
    mov       rcx,	r13
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	r12
    mov       r8,	rax
    call      mc_libmcl.genmc
L2805:
    mov       rax,	[rbp + mc_auxmcl.do_storebf.p]
    mov       eax,	[rax+4]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	38
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	39
    mov       rdx,	rbx
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_storebf.p]
    mov       eax,	[rax+4]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.gethostfn
mc_auxmcl.gethostfn:
;?>>
   %define R.opc r13
   %define R.d rdi
   %define R.name rbx
   %define R.namec rsi
   %define R.ps r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rax,	[pc_api.igethostfn]
    test      rax,	rax
    jnz       L2808
    cmp       r13,	82
    jnz       L2811
L2810:
    lea       rax,	[L12402]
    mov       rbx,	rax
    lea       rax,	[L12403]
    mov       rsi,	rax
    jmp       L2809
L2811:
    xor       rbx,	rbx
L2809:
    test      rbx,	rbx
    jz        L2813
    mov       r12,	[pc_decls.psymboltable]
    jmp       L2817
L2814:
    mov       rax,	[r12]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jnz       L2820
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L2819
L2820:
    mov       rax,	r12
    jmp       L2806
L2819:
    mov       r12,	[r12+8]
L2817:
    test      r12,	r12
    jnz       L2814
L2813:
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    lea       rcx,	[L12404]
    mov       rdx,	rax
    call      pc_api.merror
L2808:
    mov       rcx,	r13
    mov       rax,	[pc_api.igethostfn]
    call      rax
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L2822
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    lea       rcx,	[L12405]
    mov       rdx,	rax
    call      pc_api.merror
L2822:
    mov       rax,	rdi
L2806:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.copyblockarg
mc_auxmcl.copyblockarg:
;?>>
   %define R.px r12
   %define R.size r13
    %define mc_auxmcl.copyblockarg.argno 72
   %define R.dblock rdi
   %define R.ax rbx
   %define R.bx rsi
    %define mc_auxmcl.copyblockarg.$T3 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    test      r12,	r12
    jnz       L2825
    call      msys.m$print_startcon
    lea       rcx,	[L12406]
    call      msys.m$print_str_nf
    mov       rax,	[pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12407]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2823
L2825:
    mov       rcx,	r13
    call      mc_libmcl.newblocktemp
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+92],	al
    test      r12,	r12
    jz        L2827
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    jmp       L2826
L2827:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	11
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
L2826:
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [rsi+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       [rbp + mc_auxmcl.copyblockarg.$T3],	rax
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.copyblockarg.$T3]
    mov       r8,	r13
    mov       r9,	1
    call      mc_auxmcl.copyblock
    test      r12,	r12
    jz        L2829
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	r12
    mov       r8,	rax
    call      mc_libmcl.genmc
L2829:
    xor       ecx,	ecx
    call      mc_stackmcl.freeworkregs
L2823:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.fixmain
mc_auxmcl.fixmain:
;?>>
   %define R.d rdi
   %define R.dn rbx
   %define R.dargs rsi
   %define R.denv r12
   %define R.dinfo r13
   %define R.ax r14
    %define mc_auxmcl.fixmain.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rdi,	[pc_decls.currfunc]
    mov       rbx,	[rdi+16]
    mov       rsi,	[rbx+16]
    lea       rcx,	[L12408]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       r12,	rax
    mov       al,	6
    mov       [r12+82],	al
    mov       eax,	8
    mov       [r12+84],	eax
    lea       rcx,	[L12409]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       r13,	rax
    mov       al,	11
    mov       [r13+82],	al
    mov       eax,	128
    mov       [r13+84],	eax
    mov       rcx,	90
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rcx,	r13
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	128
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	124
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	124
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    mov       rcx,	r12
    call      pc_api.pc_addlocal
    mov       rcx,	r13
    call      pc_api.pc_addlocal
    xor       eax,	eax
    mov       [rdi+16],	rax
    mov       [rsi+16],	rax
    mov       [rbx+16],	rax
    xor       eax,	eax
    mov       [rdi+112],	al
    mov       al,	4
    mov       [rbx+72],	al
    mov       al,	1
    mov       [rbx+92],	al
    mov       al,	4
    mov       [rsi+72],	al
    mov       al,	4
    mov       [rsi+92],	al
    mov       rcx,	rsi
    call      pc_api.pc_addlocal
    mov       rcx,	rbx
    call      pc_api.pc_addlocal
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       r10,	rax
    mov       r14,	r10
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [r13+88],	al
    mov       rcx,	12
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	32
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rbx+88],	al
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rsi+88],	al
    mov       rcx,	r12
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	13
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [r12+88],	al
    mov       rcx,	14
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	rax
    call      mc_libmcl.clearreg
    lea       rcx,	[L12410]
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	48
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[pc_decls.pcmdskip]
    test      rax,	rax
    jz        L2832
    mov       rcx,	[pc_decls.pcmdskip]
    mov       rdx,	9
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	29
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       rax,	[pc_decls.pcmdskip]
    shl       rax,	3
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
L2832:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mclinit
mc_libmcl.mclinit:
;?>>
   %define R.bypass r14
   %define R.a rdi
   %define R.r rbx
   %define R.av_1 rsi
   %define R.av_2 r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       rax,	64
    cmp       rax,	64
    jle       L2835
    lea       rcx,	[L12411]
    call      mlib.abortprogram
L2835:
    mov       rbx,	1
L2836:
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10],	rax
    mov       rcx,	rbx
    mov       rdx,	2
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+8],	rax
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+24],	rax
    mov       rcx,	rbx
    mov       rdx,	8
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+56],	rax
    inc       rbx
    cmp       rbx,	16
    jle       L2836
    mov       r13,	-128
    mov       rsi,	64
    cmp       rsi,	-128
    jl        L2841
L2839:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r8w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       al,	15
    mov       [rdi+10],	al
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r8w,	[rax]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       [rdi+12],	r13d
    mov       rax,	rdi
    lea       r10,	[mc_decls.frameregtable]
    mov       r11,	r13
    mov       [r10 + r11*8+1024],	rax
    inc       r13
    cmp       r13,	rsi
    jle       L2839
L2841:
    mov       rcx,	15
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [mc_decls.dframeopnd],	rax
    mov       rcx,	16
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [mc_decls.dstackopnd],	rax
    call      mc_libmcl.initmcdest
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    xor       eax,	eax
    mov       [mc_decls.lab_funcnametable],	rax
    xor       eax,	eax
    mov       [mc_decls.lab_funcaddrtable],	rax
    mov       r13,	-1
    mov       r12,	10
    cmp       r12,	-1
    jl        L2844
L2842:
    mov       rcx,	r13
    mov       rdx,	8
    call      mc_libmcl.mgenint0
    lea       r10,	[mc_libmcl.smallinttable]
    mov       r11,	r13
    mov       [r10 + r11*8+8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L2842
L2844:
    test      r14,	r14
    jz        L2846
    mov       al,	1
    mov       [pc_decls.mcldone],	al
L2846:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.initmcdest
mc_libmcl.initmcdest:
;?>>
;?]]
;---------------
    xor       eax,	eax
    mov       [mc_decls.mccodex],	rax
    mov       [mc_decls.mccode],	rax
;---------------
    ret       
;End 
;Proc mc_libmcl.genmc
mc_libmcl.genmc:
;?>>
   %define R.opcode rsi
   %define R.a r12
   %define R.b r13
   %define R.m rdi
   %define R.labno rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	64
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi+33],	sil
    inc       qword [mc_libmcl.mclseqno]
    mov       rax,	[mc_libmcl.mclseqno]
    mov       [rdi+36],	eax
    mov       eax,	[pc_decls.mmpos]
    mov       [rdi+40],	eax
    mov       [rdi+16],	r12
    mov       [rdi+24],	r13
    mov       rax,	rsi
    cmp       rax,	14
    jz        L2850
    cmp       rax,	9
    jz        L2851
    cmp       rax,	11
    jz        L2852
    jmp       L2853
L2850:
    test      r13,	r13
    jz        L2855
    movzx     rax,	word [r13+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jnz       L2855
    mov       rax,	[r13]
    mov       r10b,	1
    mov       [rax+88],	r10b
L2855:
    jmp       L2849
L2851:
    mov       rbx,	[r12]
    jmp       L2849
L2852:
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L2858
    test      r13,	r13
    jz        L2857
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L2857
L2858:
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L2860
    mov       rax,	17
    jmp       L2859
L2860:
    mov       rax,	16
L2859:
    mov       [rdi+33],	al
L2857:
L2853:
L2849:
    mov       rax,	[mc_decls.mccode]
    test      rax,	rax
    jz        L2862
    mov       rax,	[mc_decls.mccodex]
    mov       [rdi],	rax
    mov       rax,	rdi
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       [mc_decls.mccodex],	rdi
    jmp       L2861
L2862:
    mov       rax,	rdi
    mov       [mc_decls.mccodex],	rax
    mov       [mc_decls.mccode],	rax
L2861:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.genmc_cond
mc_libmcl.genmc_cond:
;?>>
   %define R.opcode rdi
   %define R.cond rbx
   %define R.a rsi
   %define R.b r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       al,	bl
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+34],	al
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.genmc_str
mc_libmcl.genmc_str:
;?>>
   %define R.opcode rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	-1
    call      mc_libmcl.mgenstring
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.newmclopnd
mc_libmcl.newmclopnd:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    inc       qword [mc_libmcl.nmclopnd]
    mov       rax,	rdi
L2865:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.duplopnd
mc_libmcl.duplopnd:
;?>>
   %define R.a rbx
   %define R.b rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	rbx
    movdqu    XMM4,	[rax]
    movdqu    [rdi],	XMM4
    mov       rax,	rdi
L2866:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenindex
mc_libmcl.mgenindex:
;?>>
   %define R.areg rbx
   %define R.ireg rsi
   %define R.scale r12
   %define R.offset r13
    %define mc_libmcl.mgenindex.size 96
    %define mc_libmcl.mgenindex.labno 104
    %define mc_libmcl.mgenindex.def 112
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r15w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       [rdi+10],	bl
    cmp       rbx,	15
    jz        L2870
    cmp       rsi,	15
    jnz       L2869
L2870:
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
L2869:
    mov       [rdi+11],	sil
    lea       rax,	[rdi+8]
    mov       r10w,	r12w
    mov       r15w,	[rax]
    mov       r11,	-481
    shl       r10w,	5
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    lea       rax,	[rdi+8]
    mov       r10w,	[rbp + mc_libmcl.mgenindex.size]
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       [rdi+12],	r13d
    mov       rax,	[rbp + mc_libmcl.mgenindex.labno]
    test      rax,	rax
    jz        L2872
    mov       rax,	[rbp + mc_libmcl.mgenindex.labno]
    mov       [rdi],	rax
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r15w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    jmp       L2871
L2872:
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    test      rax,	rax
    jz        L2873
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    mov       [rdi],	rax
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    lea       rax,	[rax+89]
    inc       byte [rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r15w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    movzx     rax,	byte [rax+72]
    cmp       rax,	4
    jz        L2876
    cmp       rax,	5
    jnz       L2875
L2876:
    mov       al,	15
    mov       [rdi+10],	al
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
L2875:
L2873:
L2871:
    mov       rax,	rdi
L2867:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r15
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgencomment
mc_libmcl.mgencomment:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	3
    mov       rdx,	rdi
    call      mc_libmcl.genmc_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenstring
mc_libmcl.mgenstring:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    cmp       rsi,	0
    jge       L2880
    mov       rcx,	rbx
    call      strlen
    mov       rsi,	rax
L2880:
    lea       rax,	[rsi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rdi],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	[rdi]
    xor       r10d,	r10d
    mov       r11,	rsi
    mov       [rax + r11],	r10b
    lea       rax,	[rdi+8]
    mov       r10w,	4
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2878:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenname
mc_libmcl.mgenname:
;?>>
   %define R.s rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    lea       rax,	[rdi+8]
    mov       r10w,	7
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2881:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.setsegment
mc_libmcl.setsegment:
;?>>
   %define R.seg rsi
   %define R.align r12
   %define R.opc rdi
   %define R.oldalign rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    cmp       rsi,	[mc_decls.currsegment]
    jz        L2884
    mov       rax,	rsi
    cmp       rax,	73
    jz        L2886
    cmp       rax,	90
    jz        L2887
    cmp       rax,	67
    jz        L2888
    cmp       rax,	82
    jz        L2889
    jmp       L2890
L2886:
    mov       rdi,	120
    jmp       L2885
L2887:
    mov       rdi,	121
    jmp       L2885
L2888:
    mov       rdi,	122
    jmp       L2885
L2889:
    lea       rcx,	[L12412]
    lea       rdx,	[L12413]
    call      pc_api.merror
    jmp       L2885
L2890:
    lea       rcx,	[L12414]
    lea       rdx,	[L12415]
    call      pc_api.merror
L2885:
    mov       rax,	[mc_decls.mccodex]
    test      rax,	rax
    jz        L2892
    mov       rax,	[mc_decls.mccodex]
    movzx     rax,	byte [rax+33]
    cmp       rax,	120
    jz        L2893
    cmp       rax,	121
    jz        L2893
    cmp       rax,	122
    jnz       L2892
L2893:
    mov       al,	dil
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+33],	al
    jmp       L2891
L2892:
    mov       rcx,	rdi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2891:
    mov       [mc_decls.currsegment],	rsi
L2884:
    cmp       r12,	1
    jle       L2895
    mov       rax,	[mc_decls.mccodex]
    movzx     rax,	byte [rax+33]
    cmp       rax,	123
    jnz       L2897
    mov       rax,	[mc_decls.mccodex]
    mov       rax,	[rax+16]
    mov       rbx,	[rax]
    cmp       rbx,	r12
    jge       L2882
L2899:
L2897:
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	123
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2895:
L2882:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.changeopndsize
mc_libmcl.changeopndsize:
;?>>
   %define R.a rbx
   %define R.size rsi
   %define R.b rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L2902
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L2904
    movzx     rax,	byte [rbx+10]
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rax
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       rax,	rsi
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    jmp       L2903
L2904:
    mov       rcx,	rbx
    call      mc_libmcl.duplopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r8w,	[rax]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
L2903:
    mov       rax,	rdi
    jmp       L2900
L2902:
    mov       rax,	rbx
L2900:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.applyoffset
mc_libmcl.applyoffset:
;?>>
   %define R.a rbx
   %define R.offset rsi
   %define R.size r12
   %define R.b rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    test      rsi,	rsi
    jnz       L2907
    test      r12,	r12
    jnz       L2907
    mov       rax,	rbx
    jmp       L2905
L2907:
    mov       rcx,	rbx
    call      mc_libmcl.duplopnd
    mov       rdi,	rax
    lea       rax,	[rdi+12]
    mov       r10d,	esi
    add       [rax],	r10d
    test      r12,	r12
    jz        L2909
    lea       rax,	[rdi+8]
    mov       r10w,	r12w
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L2909:
    mov       rax,	rdi
L2905:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenint
mc_libmcl.mgenint:
;?>>
   %define R.x rsi
   %define R.mode r12
   %define R.a rdi
   %define R.size rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    mov       rbx,	rax
    mov       rax,	rsi
    cmp       rax,	-1
    jl        L2912
    cmp       rax,	10
    jg        L2912
    cmp       rbx,	8
    jnz       L2912
    lea       rax,	[mc_libmcl.smallinttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8+8]
    jmp       L2910
L2912:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rsi
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	bx
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2910:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenint0
mc_libmcl.mgenint0:
;?>>
   %define R.x rbx
   %define R.size rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rbx
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2913:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenrealmem
mc_libmcl.mgenrealmem:
;?>>
   %define R.x XMM15
   %define R.mode rbx
   %define R.a rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rbx-1]
    test      rax,	rax
    jz        L2916
    movq      XMM0,	XMM15
    call      mc_libmcl.getrealindex
    mov       [rdi],	rax
    jmp       L2915
L2916:
    movq      XMM0,	XMM15
    call      mc_libmcl.getr32index
    mov       [rdi],	rax
L2915:
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	rdi
L2914:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenrealimm
mc_libmcl.mgenrealimm:
;?>>
   %define R.x XMM15
   %define R.mode rbx
   %define R.a rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    movq      XMM4,	XMM15
    movq      [rdi],	XMM4
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	rdi
L2917:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenlabel
mc_libmcl.mgenlabel:
;?>>
   %define R.x rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rbx,	rbx
    jnz       L2920
    inc       qword [pc_api.mlabelno]
    mov       rbx,	[pc_api.mlabelno]
L2920:
    mov       [rdi],	rbx
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2918:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenlabelmem
mc_libmcl.mgenlabelmem:
;?>>
   %define R.x rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2921:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenmem
mc_libmcl.mgenmem:
;?>>
   %define R.d rsi
   %define R.mode r12
   %define R.a rdi
   %define R.reg rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       al,	[rsi+90]
    test      al,	al
    jz        L2924
    movzx     rax,	byte [rsi+82]
    lea       r10,	[pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2926
    mov       rcx,	rsi
    call      mc_libmcl.mgenxregvar
    jmp       L2922
L2926:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mc_libmcl.mgenregvar
    jmp       L2922
L2925:
L2924:
    xor       rbx,	rbx
    movzx     rax,	byte [rsi+72]
    cmp       rax,	4
    jz        L2929
    cmp       rax,	5
    jnz       L2928
L2929:
    mov       rbx,	15
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
L2928:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    mov       [rdi],	rsi
    lea       rax,	[rsi+89]
    inc       byte [rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      r12,	r12
    jz        L2931
    lea       rax,	[pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    jmp       L2930
L2931:
    mov       eax,	[rsi+84]
    mov       r10,	8
    cmp       rax,	r10
    cmova     rax,	r10
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L2930:
    mov       rax,	rdi
L2922:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenmemaddr
mc_libmcl.mgenmemaddr:
;?>>
   %define R.d rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       al,	1
    mov       [rbx+88],	al
    lea       rax,	[rbx+89]
    inc       byte [rax]
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rbx
    lea       rax,	[rbx+89]
    inc       byte [rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2932:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenreg0
mc_libmcl.mgenreg0:
;?>>
   %define R.reg rbx
   %define R.size rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rsi,	rsi
    jnz       L2935
    lea       rcx,	[L12416]
    lea       rdx,	[L12417]
    call      pc_api.merror
L2935:
    mov       rax,	rdi
L2933:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenxreg
mc_libmcl.mgenxreg:
;?>>
   %define R.xreg rbx
   %define R.size rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rsi,	rsi
    jnz       L2938
    lea       rcx,	[L12418]
    lea       rdx,	[L12419]
    call      pc_api.merror
L2938:
    mov       rax,	rdi
L2936:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenreg
mc_libmcl.mgenreg:
;?>>
   %define R.reg rsi
   %define R.mode r12
   %define R.a rdi
   %define R.size rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    mov       rbx,	rax
    cmp       r12,	2
    jg        L2941
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r8w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       [rdi+10],	sil
    mov       al,	1
    lea       r10,	[mc_decls.usedxregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    lea       rax,	[pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r8w,	[r10]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	ax
    mov       [r10],	r8w
    mov       rax,	rdi
    jmp       L2940
L2941:
    test      rbx,	rbx
    jnz       L2943
    mov       rbx,	8
L2943:
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    mov       rax,	rsi
    cmp       rax,	11
    jl        L2945
    cmp       rax,	14
    jg        L2945
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L2945:
    lea       rax,	[mc_decls.regtable]
    mov       r10,	rsi
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    jmp       L2939
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg0
L2940:
L2939:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenregi
mc_libmcl.mgenregi:
;?>>
   %define R.reg rdi
   %define R.mode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[mc_decls.regtable]
    mov       r10,	rdi
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    lea       r10,	[pc_tables.psize]
    mov       r11,	rbx
    movzx     r10,	byte [r10 + r11]
    mov       rax,	[rax + r10*8-8]
    jmp       L2946
    lea       rax,	[pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_libmcl.mgenreg0
L2946:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenireg
mc_libmcl.mgenireg:
;?>>
   %define R.reg rbx
   %define R.mode rsi
   %define R.offset r12
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       [rdi+12],	r12d
    mov       rax,	rdi
L2947:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgentemp
mc_libmcl.mgentemp:
;?>>
   %define R.n rbx
   %define R.mode rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rax,	[mc_decls.pcltempflags]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2950
    lea       rax,	[pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    lea       r10,	[mc_decls.pcltempopnds]
    mov       r11,	rbx
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    jmp       L2948
L2950:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       al,	15
    mov       [rdi+10],	al
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       [rdi],	rbx
    mov       rax,	rdi
    lea       r10,	[mc_decls.pcltempopnds]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       al,	1
    lea       r10,	[mc_decls.pcltempflags]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
L2948:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.roundsizetg
mc_libmcl.roundsizetg:
;?>>
   %define R.size rcx
;?]]
;---------------
    mov       rax,	rcx
    and       rax,	7
    jnz       L2953
    mov       rax,	rcx
    jmp       L2951
L2953:
    mov       rax,	rcx
    and       rax,	7
    mov       r10,	8
    sub       r10,	rax
    mov       rax,	rcx
    add       rax,	r10
L2951:
;---------------
    ret       
;End 
;Proc mc_libmcl.merroropnd
mc_libmcl.merroropnd:
;?>>
   %define R.mess rdi
   %define R.opndtype rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12420]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rax,	[pc_tables.opndnames]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mcreatefwdlabel
mc_libmcl.mcreatefwdlabel:
;?>>
;?]]
;---------------
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
L2955:
;---------------
    ret       
;End 
;Proc mc_libmcl.mdefinefwdlabel
mc_libmcl.mdefinefwdlabel:
;?>>
   %define R.lab rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenextname
mc_libmcl.mgenextname:
;?>>
   %define R.s rbx
    %define mc_libmcl.mgenextname.str -64
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       rbx,	rcx
;---------------
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    mov       rdx,	rbx
    call      strcpy
    mov       rcx,	rbx
    call      strlen
    xor       r10d,	r10d
    mov       [rbp + rax + mc_libmcl.mgenextname.str-1],	r10b
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    call      mc_libmcl.findnamesym
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L2959
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    mov       al,	1
    mov       [rdi+72],	al
    mov       al,	1
    mov       [rdi+80],	al
    mov       rcx,	rdi
    call      mc_libmcl.addnamesym
L2959:
    mov       rcx,	rdi
    call      mc_libmcl.mgenmemaddr
L2957:
;---------------
    add       rsp,	96
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenregvar
mc_libmcl.mgenregvar:
;?>>
   %define R.d rbx
   %define R.mode rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [rbx+90]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rax,	rdi
L2960:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenxregvar
mc_libmcl.mgenxregvar:
;?>>
   %define R.d rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx+90]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rdi,	rax
    movzx     rax,	byte [rbx+90]
    mov       r10b,	1
    lea       r11,	[mc_decls.isxregvar]
    mov       [r11 + rax-1],	r10b
    mov       rax,	rdi
L2961:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.getprimreg
mc_libmcl.getprimreg:
;?>>
   %define R.ax rcx
;?]]
;---------------
    mov       al,	[rcx+10]
    test      al,	al
    jz        L2964
    movzx     rax,	byte [rcx+10]
    jmp       L2963
L2964:
    movzx     rax,	byte [rcx+11]
L2963:
L2962:
;---------------
    ret       
;End 
;Proc mc_libmcl.pushslots
mc_libmcl.pushslots:
;?>>
   %define R.nslots rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	rdi
    shl       rax,	3
    mov       rcx,	rax
    call      mc_libmcl.pushstack
    mov       rax,	rdi
    add       [mc_decls.mstackdepth],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.popslots
mc_libmcl.popslots:
;?>>
   %define R.nslots rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	rdi
    shl       rax,	3
    mov       rcx,	rax
    call      mc_libmcl.popstack
    mov       rax,	rdi
    sub       [mc_decls.mstackdepth],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.pushstack
mc_libmcl.pushstack:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L2969
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2969:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.popstack
mc_libmcl.popstack:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L2972
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	28
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2972:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.getstringindex
mc_libmcl.getstringindex:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jnz       L2975
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [mc_decls.kk0used],	rax
    mov       rax,	[mc_decls.kk0used]
    jmp       L2973
L2975:
    mov       rax,	[mc_decls.cstringlist]
    test      rax,	rax
    jz        L2977
    mov       rax,	[mc_decls.cstringlist]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mlib.eqstring
    test      rax,	rax
    jz        L2977
    mov       rax,	[mc_decls.cstringlist]
    mov       rax,	[rax+16]
    jmp       L2973
L2977:
    lea       rcx,	[mc_decls.cstringlist]
    mov       rdx,	rdi
    call      mc_libmcl.addconst
L2973:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.addconst
mc_libmcl.addconst:
;?>>
   %define R.clist rbx
   %define R.value rsi
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	24
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi],	rsi
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [rdi+16],	rax
    mov       rax,	[rbx]
    mov       [rdi+8],	rax
    mov       [rbx],	rdi
    mov       rax,	[pc_api.mlabelno]
L2978:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.getrealindex
mc_libmcl.getrealindex:
;?>>
   %define R.x XMM15
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
;---------------
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    lea       rcx,	[mc_decls.creallist]
    mov       rdx,	rax
    call      mc_libmcl.addconst
L2979:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
;End 
;Proc mc_libmcl.getr32index
mc_libmcl.getr32index:
;?>>
   %define R.x XMM15
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
;---------------
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    lea       rcx,	[mc_decls.cr32list]
    mov       rdx,	rax
    call      mc_libmcl.addconst
L2980:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
;End 
;Proc mc_libmcl.ispoweroftwo
mc_libmcl.ispoweroftwo:
;?>>
   %define R.x rcx
   %define R.a rdi
   %define R.n rbx
   %define R.av_1 rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	16
;---------------
    mov       rdi,	1
    xor       rbx,	rbx
    mov       rax,	60
    mov       rsi,	rax
L2982:
    inc       rbx
    mov       rax,	rdi
    shl       rax,	1
    mov       rdi,	rax
    cmp       rdi,	rcx
    jnz       L2986
    mov       rax,	rbx
    jmp       L2981
L2986:
    dec       rsi
    jnz       L2982
    xor       eax,	eax
L2981:
;---------------
    add       rsp,	16
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.axerror
mc_libmcl.axerror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12421]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rcx,	[L12422]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.newblocktemp
mc_libmcl.newblocktemp:
;?>>
   %define R.size rbx
    %define mc_libmcl.newblocktemp.str -16
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    mov       rax,	[mc_decls.nblocktemps]
    cmp       rax,	50
    jle       L2990
    lea       rcx,	[L12423]
    lea       rdx,	[L12424]
    call      pc_api.merror
L2990:
    inc       qword [mc_decls.nblocktemps]
    lea       rcx,	[rbp + mc_libmcl.newblocktemp.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12425]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.nblocktemps]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_libmcl.newblocktemp.str]
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       al,	11
    mov       [rdi+82],	al
    mov       [rdi+84],	ebx
    mov       al,	1
    mov       [rdi+92],	al
    mov       al,	4
    mov       [rdi+72],	al
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+24]
    mov       [rdi+24],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       [rdi+32],	rax
    mov       rax,	rdi
    mov       r10,	[pc_decls.currfunc]
    mov       [r10+24],	rax
    mov       rax,	rdi
    lea       r10,	[mc_decls.blockdefs]
    mov       r11,	[mc_decls.nblocktemps]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	rdi
L2988:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.findnamesym
mc_libmcl.findnamesym:
;?>>
   %define R.s rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mc_libmcl.nnametable]
    cmp       rax,	1
    jl        L2994
L2992:
    lea       rax,	[mc_libmcl.nametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L2996
    lea       rax,	[mc_libmcl.nametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L2991
L2996:
    inc       rdi
    cmp       rdi,	[mc_libmcl.nnametable]
    jle       L2992
L2994:
    xor       eax,	eax
L2991:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.addnamesym
mc_libmcl.addnamesym:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_libmcl.nnametable]
    cmp       rax,	20
    jge       L2999
    inc       qword [mc_libmcl.nnametable]
    mov       rax,	[mc_libmcl.nnametable]
    mov       r10,	rdi
    lea       r11,	[mc_libmcl.nametable]
    mov       [r11 + rax*8-8],	r10
    jmp       L2998
L2999:
    lea       rcx,	[L12426]
    lea       rdx,	[L12427]
    call      pc_api.merror
L2998:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.callproc
mc_libmcl.callproc:
;?>>
    %define mc_libmcl.callproc.cpname 16
    %define mc_libmcl.callproc.name 24
    %define mc_libmcl.callproc.lineno 32
;?]]
;---------------
L3000:
;---------------
    ret       
;End 
;Proc mc_libmcl.mgenstringx
mc_libmcl.mgenstringx:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
L3001:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.clearreg
mc_libmcl.clearreg:
;?>>
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L3004
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
L3004:
    mov       rcx,	40
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getopnd
mc_stackmcl.getopnd:
;?>>
   %define R.n r13
   %define R.mode r14
   %define R.reg r15
   %define R.ax rdi
   %define R.bx rbx
   %define R.a rsi
   %define R.d r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	r13
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L3007
    cmp       rax,	2
    jz        L3007
    cmp       rax,	3
    jz        L3008
    jmp       L3009
L3007:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenreg
    jmp       L3005
L3008:
    mov       rcx,	r13
    mov       rdx,	r14
    call      mc_libmcl.mgentemp
    mov       rbx,	rax
    mov       rax,	rbx
    jmp       L3005
L3009:
L3006:
    movzx     rax,	byte [rsi+1]
    cmp       rax,	1
    jz        L3011
    cmp       rax,	2
    jz        L3012
    cmp       rax,	4
    jz        L3013
    cmp       rax,	5
    jz        L3014
    cmp       rax,	6
    jz        L3014
    cmp       rax,	7
    jz        L3015
    cmp       rax,	3
    jz        L3016
    jmp       L3017
L3011:
    mov       r12,	[rsi+8]
    cmp       r14,	11
    jnz       L3019
    movzx     rax,	byte [r12+72]
    cmp       rax,	5
    jz        L3019
    mov       r14,	6
    jmp       L3012
L3019:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
L3018:
    jmp       L3010
L3012:
    mov       r12,	[rsi+8]
    movzx     rax,	byte [r12+72]
    cmp       rax,	5
    jnz       L3021
    movzx     rax,	byte [r12+82]
    cmp       rax,	11
    jnz       L3021
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    jmp       L3020
L3021:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L3020:
    jmp       L3010
L3013:
    lea       rax,	[pc_tables.psize]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10]
    cmp       rax,	2
    jz        L3023
    cmp       rax,	4
    jz        L3024
    jmp       L3025
L3023:
    lea       rax,	[rsi+8]
    mov       r10,	65535
    and       [rax],	r10
    jmp       L3022
L3024:
    lea       rax,	[rsi+8]
    mov       r10,	4294967295
    and       [rax],	r10
L3025:
L3022:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenint
    mov       rbx,	rax
    mov       rax,	[rsi+8]
    cmp       rax,	-2147483648
    jl        L3027
    cmp       rax,	2147483647
    jg        L3027
    mov       rdi,	rbx
    jmp       L3026
L3027:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3026:
    jmp       L3010
L3014:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	r14
    call      mc_libmcl.mgenrealmem
    mov       rdi,	rax
    jmp       L3010
L3015:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L3010
L3016:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L3010
L3017:
;mc_stackmcl.getopnd.error:
    movzx     rax,	byte [rsi+1]
    lea       r10,	[pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12428]
    mov       rdx,	r10
    call      pc_api.merror
L3010:
    mov       rax,	rdi
L3005:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadopnd
mc_stackmcl.loadopnd:
;?>>
   %define R.n rbx
   %define R.mode rsi
   %define R.reg r12
   %define R.ax rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L3031
    test      r12,	r12
    jnz       L3033
    mov       rcx,	rsi
    call      mc_stackmcl.getworkreg
    mov       r12,	rax
L3033:
L3031:
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.loadtoreg
    mov       rdi,	rax
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       al,	[rdi+10]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
L3029:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadparam
mc_stackmcl.loadparam:
;?>>
   %define R.n rbx
   %define R.mode rsi
   %define R.reg r12
   %define R.ax rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.loadtoreg_m
    mov       rdi,	rax
    mov       rax,	rdi
L3034:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.pushopnd
mc_stackmcl.pushopnd:
;?>>
   %define R.n r12
   %define R.mode r13
   %define R.ax rdi
   %define R.bx rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	r12
    mov       rsi,	[rax + r10*8-8]
    test      r13,	r13
    jnz       L3037
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10-1]
    mov       r13,	rax
L3037:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3039
    movzx     rax,	byte [rsi+1]
    cmp       rax,	1
    jz        L3041
    cmp       rax,	4
    jz        L3042
    cmp       rax,	5
    jz        L3043
    jmp       L3044
L3041:
    lea       rax,	[pc_tables.psize]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10]
    cmp       rax,	8
    jnz       L3046
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    jmp       L3047
L3046:
    jmp       L3040
L3042:
    mov       rax,	[rsi+8]
    cmp       rax,	-2147483648
    jl        L3049
    cmp       rax,	2147483647
    jg        L3049
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rdi,	rax
    jmp       L3047
L3049:
    jmp       L3040
L3043:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealmem
    mov       rdi,	rax
    jmp       L3047
L3044:
L3040:
L3039:
    mov       rcx,	r12
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L3051
    mov       rbx,	rdi
    cmp       r13,	4
    jnz       L3053
    mov       rax,	5
    jmp       L3052
L3053:
    mov       rax,	6
L3052:
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3051:
;mc_stackmcl.pushopnd.pushit:
L3047:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    inc       qword [mc_decls.mstackdepth]
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadtoreg
mc_stackmcl.loadtoreg:
;?>>
   %define R.ax rbx
   %define R.mode rsi
   %define R.reg r12
   %define R.bx rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3057
    cmp       rax,	5
    jnz       L3056
L3057:
    test      r12,	r12
    jz        L3060
    movzx     rax,	byte [rbx+10]
    cmp       rax,	r12
    jnz       L3059
L3060:
    mov       rax,	rbx
    jmp       L3054
L3059:
L3056:
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_stackmcl.loadtoreg_common
    mov       rax,	rdi
L3054:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadtoreg_m
mc_stackmcl.loadtoreg_m:
;?>>
   %define R.ax rbx
   %define R.mode rsi
   %define R.reg r12
   %define R.bx rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3064
    cmp       rax,	5
    jnz       L3063
L3064:
    movzx     rax,	byte [rbx+10]
    cmp       rax,	r12
    jnz       L3066
    mov       rax,	rbx
    jmp       L3061
L3066:
L3063:
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_stackmcl.loadtoreg_common
    mov       rax,	rdi
L3061:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadtoreg_common
mc_stackmcl.loadtoreg_common:
;?>>
   %define R.bx rdi
   %define R.ax rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3069
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L3069
    mov       rax,	[rbx]
    test      rax,	rax
    jnz       L3069
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    jmp       L3068
L3069:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3068:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.pushpcl
mc_stackmcl.pushpcl:
;?>>
   %define R.p rbx
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	20
    jl        L3072
    lea       rcx,	[L12429]
    lea       rdx,	[L12430]
    call      pc_api.merror
L3072:
    inc       qword [mc_decls.noperands]
    mov       rdi,	[mc_decls.noperands]
    xor       eax,	eax
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rbx
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	[rbx+3]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    movzx     rax,	byte [rbx+1]
    cmp       rax,	1
    jnz       L3074
    mov       rax,	[rbx+8]
    mov       al,	[rax+90]
    test      al,	al
    jz        L3074
    mov       rax,	[rbx+8]
    mov       al,	[rax+90]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	2
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3074:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.pushpcl_reg
mc_stackmcl.pushpcl_reg:
;?>>
   %define R.mode rbx
   %define R.reg rsi
   %define R.n rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	20
    jl        L3077
    lea       rcx,	[L12431]
    lea       rdx,	[L12432]
    call      pc_api.merror
L3077:
    test      rsi,	rsi
    jnz       L3079
    mov       rcx,	rbx
    call      mc_stackmcl.getworkreg
    mov       rsi,	rax
L3079:
    inc       qword [mc_decls.noperands]
    mov       rdi,	[mc_decls.noperands]
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    mov       al,	sil
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	bl
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    cmp       rbx,	2
    jg        L3081
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    jmp       L3080
L3081:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L3080:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.poppcl
mc_stackmcl.poppcl:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	[mc_decls.noperands]
    cmp       rdi,	0
    jg        L3084
    lea       rcx,	[L12433]
    lea       rdx,	[L12434]
    call      pc_api.merror
L3084:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jle       L3086
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	rdi
    lea       rax,	[rax + r10-1]
    dec       byte [rax]
    jmp       L3082
L3086:
    dec       qword [mc_decls.noperands]
L3082:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.duplpcl
mc_stackmcl.duplpcl:
;?>>
   %define R.mode rdi
    %define mc_stackmcl.duplpcl.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rcx,	rdi
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_stackmcl.duplpcl.$T1],	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.duplpcl.$T1]
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkireg
mc_stackmcl.getworkireg:
;?>>
   %define R.r rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	10
L3089:
    mov       rdi,	1
L3092:
    lea       rax,	[mc_decls.workregs]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3096
    lea       rax,	[mc_decls.regset]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3096
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
    jmp       L3088
L3096:
    inc       rdi
    cmp       rdi,	14
    jle       L3092
    call      mc_stackmcl.savenextopnd
    dec       rbx
    jnz       L3089
    lea       rcx,	[L12435]
    lea       rdx,	[L12436]
    call      pc_api.merror
    xor       eax,	eax
L3088:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkxreg
mc_stackmcl.getworkxreg:
;?>>
   %define R.r rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	5
L3098:
    lea       rax,	[mc_decls.workxregs]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3102
    lea       rax,	[mc_decls.xregset]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3102
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
    jmp       L3097
L3102:
    inc       rdi
    cmp       rdi,	16
    jle       L3098
    lea       rcx,	[L12437]
    lea       rdx,	[L12438]
    call      pc_api.merror
    xor       eax,	eax
L3097:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkregm
mc_stackmcl.getworkregm:
;?>>
   %define R.mode rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_stackmcl.getworkreg
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mc_libmcl.mgenreg
L3103:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkreg
mc_stackmcl.getworkreg:
;?>>
   %define R.mode rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    cmp       rdi,	2
    jg        L3106
    call      mc_stackmcl.getworkxreg
    jmp       L3105
L3106:
    call      mc_stackmcl.getworkireg
L3105:
L3104:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkreg_rm
mc_stackmcl.getworkreg_rm:
;?>>
   %define R.reg rdi
   %define R.mode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	rdi
    test      rax,	rax
    jz        L3110
    cmp       rax,	15
    jnz       L3109
L3110:
    mov       rcx,	rbx
    call      mc_stackmcl.getworkregm
    jmp       L3107
L3109:
    cmp       rbx,	2
    jle       L3114
    lea       rax,	[mc_decls.isregvar]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L3113
L3114:
    lea       rax,	[mc_decls.isxregvar]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3112
L3113:
    mov       rcx,	rbx
    call      mc_stackmcl.getworkregm
    jmp       L3107
L3112:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
L3107:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.saveopnd
mc_stackmcl.saveopnd:
;?>>
   %define R.n rsi
   %define R.allregs r12
   %define R.reg rdi
   %define R.mode rbx
    %define mc_stackmcl.saveopnd.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L3115
L3117:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    mov       rbx,	rax
    cmp       rbx,	2
    jle       L3119
    test      r12,	r12
    jnz       L3122
    mov       rax,	rdi
    cmp       rax,	4
    jl        L3123
    cmp       rax,	10
    jle       L3121
L3123:
L3122:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.saveopnd.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgentemp
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3121:
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L3118
L3119:
    test      r12,	r12
    jnz       L3126
    mov       rax,	rdi
    cmp       rax,	1
    jl        L3125
    cmp       rax,	6
    jg        L3125
L3126:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_stackmcl.saveopnd.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgentemp
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3125:
    xor       eax,	eax
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3118:
    mov       al,	3
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L3115:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.saveopnds
mc_stackmcl.saveopnds:
;?>>
   %define R.n rsi
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	1
    mov       rax,	[mc_decls.noperands]
    sub       rax,	rsi
    mov       rdi,	rax
    cmp       rdi,	1
    jl        L3130
L3128:
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_stackmcl.saveopnd
    inc       rbx
    cmp       rbx,	rdi
    jle       L3128
L3130:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.savenextopnd
mc_stackmcl.savenextopnd:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3134
L3132:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L3136
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jle       L3136
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3131
L3136:
    inc       rdi
    cmp       rdi,	[mc_decls.noperands]
    jle       L3132
L3134:
L3131:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.savenextxopnd
mc_stackmcl.savenextxopnd:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3140
L3138:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L3142
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L3142
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3137
L3142:
    inc       rdi
    cmp       rdi,	[mc_decls.noperands]
    jle       L3138
L3140:
L3137:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.movetoreg
mc_stackmcl.movetoreg:
;?>>
   %define R.newreg r12
   %define R.oldreg rdi
   %define R.mode rbx
   %define R.i rsi
    %define mc_stackmcl.movetoreg.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rbx,	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
;mc_stackmcl.movetoreg.retry:
L3144:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    cmp       rdi,	r12
    jz        L3143
L3146:
    cmp       rbx,	2
    jg        L3148
    lea       rax,	[mc_decls.xregset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3150
    lea       rcx,	[L12439]
    lea       rdx,	[L12440]
    call      pc_api.merror
L3150:
    jmp       L3147
L3148:
    lea       rax,	[mc_decls.regset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3152
    mov       rsi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3155
L3153:
    cmp       rbx,	2
    jle       L3157
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	r12
    jnz       L3157
    mov       rcx,	rsi
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	r12
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.movetoreg.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    jmp       L3144
L3157:
    inc       rsi
    cmp       rsi,	[mc_decls.noperands]
    jle       L3153
L3155:
L3152:
L3147:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.movetoreg.$T1],	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    mov       al,	r12b
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    cmp       rbx,	2
    jg        L3159
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    jmp       L3158
L3159:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
L3158:
L3143:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getopnd_ind
mc_stackmcl.getopnd_ind:
;?>>
   %define R.n rsi
   %define R.mode r12
   %define R.a rdi
   %define R.d rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3162
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8-8]
    movzx     rax,	byte [rdi+1]
    cmp       rax,	2
    jnz       L3164
    mov       rbx,	[rdi+8]
    movzx     rax,	byte [rbx+72]
    cmp       rax,	5
    jnz       L3167
    movzx     rax,	byte [rbx+82]
    cmp       rax,	11
    jz        L3166
L3167:
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mc_libmcl.mgenmem
    jmp       L3160
L3166:
L3164:
L3162:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L3169
    mov       rcx,	rsi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3169:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3160:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getopnd_ind_simp
mc_stackmcl.getopnd_ind_simp:
;?>>
   %define R.n rdi
   %define R.mode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L3172
    mov       rcx,	rdi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3172:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3170:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.swapopnds
mc_stackmcl.swapopnds:
;?>>
   %define R.m rcx
   %define R.n rdx
;?]]
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rcx
    lea       rax,	[rax + r10*8-8]
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	rdx
    lea       r10,	[r10 + r11*8-8]
    mov       r11,	[rax]
    mov       r9,	[r10]
    mov       [r10],	r11
    mov       [rax],	r9
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
;---------------
    ret       
;End 
;Proc mc_stackmcl.isimmload
mc_stackmcl.isimmload:
;?>>
   %define R.n rcx
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rcx
    mov       rdi,	[rax + r10*8-8]
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3176
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jnz       L3176
    movzx     rax,	byte [rdi+1]
    cmp       rax,	4
    jnz       L3176
    mov       rax,	rdi
    jmp       L3175
L3176:
    xor       eax,	eax
L3175:
L3174:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.setnewzz
mc_stackmcl.setnewzz:
;?>>
   %define R.reg rcx
   %define R.mode rdx
;?]]
;---------------
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11*8-8],	rax
    mov       al,	cl
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    mov       al,	dl
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
;---------------
    ret       
;End 
;Proc mc_stackmcl.freeworkregs
mc_stackmcl.freeworkregs:
;?>>
    %define mc_stackmcl.freeworkregs.p 32
   %define R.reg rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    lea       rax,	[mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rbx,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3181
L3179:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3183
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L3185
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L3184
L3185:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3184:
L3183:
    inc       rbx
    cmp       rbx,	[mc_decls.noperands]
    jle       L3179
L3181:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.swapopndregs
mc_stackmcl.swapopndregs:
;?>>
   %define R.reg2 rsi
   %define R.reg1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L3188
    lea       rcx,	[L12441]
    lea       rdx,	[L12442]
    call      pc_api.merror
L3188:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    cmp       rdi,	rsi
    jz        L3186
L3190:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rbx,	rax
    cmp       rbx,	1
    jl        L3194
L3191:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L3196
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	rsi
    jnz       L3196
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rbx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    jmp       L3186
L3196:
    dec       rbx
    cmp       rbx,	1
    jge       L3191
L3194:
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	sil
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L3186:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.makeopndind
mc_stackmcl.makeopndind:
;?>>
   %define R.a rdi
   %define R.mode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3199
    lea       rcx,	[L12443]
    lea       rdx,	[L12444]
    call      pc_api.merror
L3199:
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3197:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.makesimpleaddr
mc_stackmcl.makesimpleaddr:
;?>>
   %define R.ax r13
   %define R.bx rdi
   %define R.newreg rbx
   %define R.reg rsi
   %define R.regix r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [r13+10]
    mov       rsi,	rax
    movzx     rax,	byte [r13+11]
    mov       r12,	rax
    cmp       rsi,	15
    jnz       L3202
    xor       rsi,	rsi
L3202:
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3204
    lea       rcx,	[L12445]
    lea       rdx,	[L12446]
    call      pc_api.merror
L3204:
    test      rsi,	rsi
    jnz       L3206
    test      r12,	r12
    jnz       L3206
    call      mc_stackmcl.getworkireg
    mov       rbx,	rax
    jmp       L3205
L3206:
    test      rsi,	rsi
    jz        L3207
    mov       rax,	r13
    jmp       L3200
L3207:
    test      r12,	r12
    jz        L3208
    mov       rbx,	r12
    jmp       L3205
L3208:
    mov       rbx,	r12
L3205:
    mov       rcx,	rbx
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	r13
    call      mc_libmcl.genmc
    mov       rax,	rdi
L3200:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.checkallloaded
mc_stackmcl.checkallloaded:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3212
L3210:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3214
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L3214
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax+3]
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3214:
    inc       rdi
    cmp       rdi,	[mc_decls.noperands]
    jle       L3210
L3212:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.stropndstack
mc_stackmcl.stropndstack:
;?>>
   %define R.indent r13
   %define R.s rdi
   %define R.fs rbx
   %define R.i rsi
   %define R.r r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    lea       rax,	[mc_stackmcl.stropndstack.str]
    mov       rdi,	rax
    test      r13,	r13
    jz        L3217
    mov       rcx,	rdi
    call      msys.m$print_startstr
    lea       rcx,	[L12447]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L3216
L3217:
    mov       rcx,	rdi
    call      msys.m$print_startstr
    lea       rcx,	[L12448]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3216:
    mov       rsi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3220
L3218:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	rsi
    inc       rax
    sub       rax,	1
    cmp       rax,	4
    jae       L3223
    lea       r10,	[L3222]
    jmp       [r10 + rax*8]
    segment .data
L3222:
    dq  L3224
    dq  L3225
    dq  L3226
    dq  L3227
    segment .text
L3224:
    lea       rax,	[L12449]
    jmp       L3221
L3225:
    lea       rax,	[L12450]
    jmp       L3221
L3226:
    lea       rax,	[L12451]
    jmp       L3221
L3227:
    lea       rax,	[L12452]
    jmp       L3221
L3223:
    lea       rax,	[L12453]
L3221:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L3229
    cmp       rax,	2
    jz        L3229
    cmp       rax,	3
    jz        L3230
    jmp       L3231
L3229:
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L3233
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.xregnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
    jmp       L3232
L3233:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.regnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
L3232:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L3235
    mov       rcx,	rdi
    lea       rdx,	[L12454]
    call      strcat
L3235:
    jmp       L3228
L3230:
    mov       rcx,	rdi
    lea       rdx,	[L12455]
    call      strcat
    mov       rcx,	rsi
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    jmp       L3228
L3231:
    mov       rcx,	rdi
    lea       rdx,	[L12456]
    call      strcat
    movzx     rax,	byte [pc_api.fpshortnames]
    mov       rbx,	rax
    mov       al,	1
    mov       [pc_api.fpshortnames],	al
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      pc_diags.stropnd
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       [pc_api.fpshortnames],	bl
    mov       rcx,	rdi
    lea       rdx,	[L12457]
    call      strcat
L3228:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jle       L3237
    mov       rcx,	rdi
    lea       rdx,	[L12458]
    call      strcat
L3237:
    mov       rcx,	rdi
    lea       rdx,	[L12459]
    call      strcat
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[pc_tables.pstdnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[L12460]
    call      strcat
    cmp       rsi,	[mc_decls.noperands]
    jge       L3239
    mov       rcx,	rdi
    lea       rdx,	[L12461]
    call      strcat
L3239:
    inc       rsi
    cmp       rsi,	[mc_decls.noperands]
    jle       L3218
L3220:
    mov       rcx,	rdi
    lea       rdx,	[L12462]
    call      strcat
    lea       rcx,	[mc_stackmcl.stropndstack.str]
    mov       rdx,	50
    lea       r8,	[L12463]
    call      mlib.ipadstr
    mov       rcx,	rdi
    lea       rdx,	[L12464]
    call      strcat
    mov       r12,	1
L3240:
    lea       rax,	[mc_decls.regset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3244
    lea       rax,	[L12465]
    jmp       L3243
L3244:
    lea       rax,	[L12466]
L3243:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    inc       r12
    cmp       r12,	10
    jle       L3240
    mov       rcx,	rdi
    lea       rdx,	[L12467]
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[L12468]
    call      strcat
    mov       r12,	1
    mov       rax,	[mc_decls.xregmax]
    cmp       rax,	1
    jl        L3247
L3245:
    lea       rax,	[mc_decls.xregset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3249
    lea       rax,	[L12469]
    jmp       L3248
L3249:
    lea       rax,	[L12470]
L3248:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    inc       r12
    cmp       r12,	[mc_decls.xregmax]
    jle       L3245
L3247:
    mov       rcx,	rdi
    lea       rdx,	[L12471]
    call      strcat
    mov       rcx,	[mc_decls.mstackdepth]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[L12472]
    call      strcat
    mov       rcx,	[mc_decls.noperands]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[L12473]
    call      strcat
    mov       rcx,	[mc_decls.ncalldepth]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rax,	rdi
L3215:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.showopndstack
mc_stackmcl.showopndstack:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	1
    call      mc_stackmcl.stropndstack
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_optim.peephole
mc_optim.peephole:
;?>>
   %define R.m rdi
   %define R.m2 rbx
   %define R.m3 rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       al,	[pc_decls.fpeephole]
    test      al,	al
    jz        L3251
L3253:
    mov       rax,	[mc_decls.mccode]
    mov       rdi,	[rax+8]
    jmp       L3257
L3254:
    mov       rbx,	[rdi+8]
    mov       rsi,	[rbx+8]
    movzx     rax,	byte [rdi+33]
    cmp       rax,	8
    jz        L3259
    cmp       rax,	11
    jz        L3260
    cmp       rax,	38
    jz        L3261
    cmp       rax,	40
    jz        L3262
    cmp       rax,	26
    jz        L3263
    jmp       L3264
L3259:
    jmp       L3256
L3260:
    movzx     rax,	byte [rbx+33]
    cmp       rax,	11
    jz        L3266
    cmp       rax,	41
    jz        L3267
    cmp       rax,	42
    jz        L3268
    cmp       rax,	28
    jz        L3269
    cmp       rax,	29
    jz        L3269
    cmp       rax,	52
    jz        L3270
    cmp       rax,	53
    jz        L3270
    cmp       rax,	25
    jz        L3271
    jmp       L3272
L3266:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3274
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+24]
    cmp       rax,	r10
    jnz       L3274
    mov       rcx,	rbx
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3274
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg10
    test      rax,	rax
    jnz       L3275
L3276:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jnz       L3278
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3277
L3278:
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3277:
L3275:
    jmp       L3273
L3274:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3279
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+24]
    cmp       rax,	r10
    jnz       L3279
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg10
    test      rax,	rax
    jz        L3279
    movzx     rax,	byte [rsi+33]
    cmp       rax,	21
    jnz       L3279
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3279
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3279:
L3273:
    jmp       L3265
L3267:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3281
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       r10,	rax
    jnz       L3282
    mov       rax,	[rbx+24]
    cmp       r10,	rax
    jnz       L3282
    mov       rax,	1
    jmp       L3283
L3282:
    xor       eax,	eax
L3283:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L3281
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3281
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3281
    mov       al,	41
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3281:
    jmp       L3265
L3268:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3285
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3285
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3285
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3285
    mov       al,	42
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    mov       rax,	[rbx+24]
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3285:
    jmp       L3265
L3269:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3287
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3287
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3287
    mov       rax,	[rbx+24]
    mov       rcx,	rax
    call      mc_optim.isconst
    test      rax,	rax
    jz        L3287
    mov       al,	14
    mov       [rdi+33],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rbx+33]
    cmp       rax,	28
    jnz       L3289
    mov       rax,	[rbx+24]
    mov       rax,	[rax]
    jmp       L3288
L3289:
    mov       rax,	[rbx+24]
    mov       rax,	[rax]
    neg       rax
L3288:
    mov       r10,	[rdi+24]
    movzx     r10,	byte [r10+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3287:
    jmp       L3265
L3270:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3291
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3291
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3291
    mov       al,	14
    mov       [rdi+33],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rbx+33]
    cmp       rax,	52
    jnz       L3293
    mov       rax,	1
    jmp       L3292
L3293:
    mov       rax,	-1
L3292:
    mov       r10,	[rdi+24]
    movzx     r10,	byte [r10+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3291:
    jmp       L3265
L3271:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3295
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3295
    mov       al,	25
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    xor       eax,	eax
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3295:
L3272:
L3265:
    jmp       L3258
L3261:
    movzx     rax,	byte [rbx+33]
    cmp       rax,	41
    jnz       L3297
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3299
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       r10,	rax
    jnz       L3300
    mov       rax,	[rbx+24]
    cmp       r10,	rax
    jnz       L3300
    mov       rax,	1
    jmp       L3301
L3300:
    xor       eax,	eax
L3301:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L3299
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3299
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3299:
L3297:
    jmp       L3258
L3262:
    movzx     rax,	byte [rbx+33]
    cmp       rax,	11
    jnz       L3303
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3305
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+24]
    cmp       rax,	r10
    jnz       L3305
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3305
    mov       rax,	[rbx+24]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3305
    mov       rcx,	rbx
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3305
    mov       rax,	[rbx+16]
    mov       [rdi+24],	rax
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3305:
L3303:
    jmp       L3258
L3263:
    movzx     rax,	byte [rbx+33]
    cmp       rax,	25
    jnz       L3307
    movzx     rax,	byte [rsi+33]
    cmp       rax,	9
    jnz       L3307
    mov       rax,	[rdi+16]
    mov       rax,	[rax]
    mov       r10,	[rsi+16]
    mov       r10,	[r10]
    cmp       rax,	r10
    jnz       L3307
    mov       rcx,	rdi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3307
    movzx     rax,	byte [rdi+34]
    lea       r10,	[mc_decls.asmrevcond]
    mov       r10,	[r10 + rax*8]
    mov       [rdi+34],	r10b
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3307:
L3264:
L3258:
    mov       rdi,	[rdi+8]
L3257:
    test      rdi,	rdi
    jnz       L3254
L3256:
L3251:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_optim.isreg
mc_optim.isreg:
;?>>
   %define R.a rcx
;?]]
;---------------
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    setz      al
    movzx     eax,	al
L3308:
;---------------
    ret       
;End 
;Proc mc_optim.isreg0
mc_optim.isreg0:
;?>>
   %define R.a rcx
;?]]
;---------------
    test      rcx,	rcx
    jnz       L3311
    xor       eax,	eax
    jmp       L3309
L3311:
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3313
    movzx     rax,	byte [rcx+10]
    cmp       rax,	1
    jnz       L3313
    mov       rax,	1
    jmp       L3309
L3313:
    xor       eax,	eax
L3309:
;---------------
    ret       
;End 
;Proc mc_optim.isreg10
mc_optim.isreg10:
;?>>
   %define R.a rcx
;?]]
;---------------
    test      rcx,	rcx
    jnz       L3316
    xor       eax,	eax
    jmp       L3314
L3316:
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3318
    movzx     rax,	byte [rcx+10]
    cmp       rax,	11
    jnz       L3318
    mov       rax,	1
    jmp       L3314
L3318:
    xor       eax,	eax
L3314:
;---------------
    ret       
;End 
;Proc mc_optim.isreg00
mc_optim.isreg00:
;?>>
   %define R.m rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3321
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+24]
    cmp       rax,	r10
    jnz       L3321
    mov       rax,	1
    jmp       L3319
L3321:
    xor       eax,	eax
L3319:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_optim.isconst
mc_optim.isconst:
;?>>
   %define R.a rcx
;?]]
;---------------
    test      rcx,	rcx
    jnz       L3324
    xor       eax,	eax
    jmp       L3322
L3324:
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3326
    movzx     rax,	word [rcx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L3326
    mov       rax,	1
    jmp       L3322
L3326:
    xor       eax,	eax
L3322:
;---------------
    ret       
;End 
;Proc mc_optim.sameoperand
mc_optim.sameoperand:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	16
    call      memcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L3327:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_optim.sameregopnd
mc_optim.sameregopnd:
;?>>
   %define R.a rcx
   %define R.b rdx
;?]]
;---------------
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    movzx     r10,	word [rdx+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	rax
    jnz       L3331
    cmp       r10,	1
    jz        L3330
L3331:
    xor       eax,	eax
    jmp       L3328
L3330:
    movzx     rax,	byte [rcx+10]
    movzx     r10,	byte [rdx+10]
    cmp       rax,	r10
    setz      al
    movzx     eax,	al
L3328:
;---------------
    ret       
;End 
;Proc mc_optim.deletemcl
mc_optim.deletemcl:
;?>>
   %define R.p rsi
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rdi,	[rsi]
    mov       rbx,	[rsi+8]
    test      rdi,	rdi
    jz        L3335
    test      rbx,	rbx
    jnz       L3334
L3335:
    lea       rcx,	[L12474]
    lea       rdx,	[L12475]
    call      pc_api.merror
L3334:
    mov       [rdi+8],	rbx
    mov       [rbx],	rdi
    mov       rax,	rbx
L3332:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_optim.endr0
mc_optim.endr0:
;?>>
   %define R.m rcx
;?]]
;---------------
    lea       rax,	[rcx+48]
    movzx     rax,	byte [rax]
L3336:
;---------------
    ret       
;End 
;Proc mc_genss.genss
mc_genss.genss:
;?>>
   %define R.obj r14
   %define R.index rdi
   %define R.m rbx
   %define R.pr rsi
   %define R.codeaddr r12
   %define R.offsetptr r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       al,	[pc_decls.ssdone]
    test      al,	al
    jnz       L3337
L3339:
    call      mwindows.os_clock
    mov       [pc_decls.sstime],	rax
    mov       rcx,	[pc_api.mlabelno]
    call      mc_genss.initlib
    xor       eax,	eax
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_zdata],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_idata],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_code],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_idatarelocs],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_coderelocs],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_nsymbols],	rax
    mov       rcx,	1
    call      mc_genss.switchseg
    mov       rax,	9999
    mov       [mc_decls.aaseqno],	rax
    xor       eax,	eax
    mov       [mc_genss.extraparam],	rax
    mov       rbx,	[mc_decls.mccode]
    xor       rdi,	rdi
    jmp       L3341
L3340:
    inc       rdi
    mov       rax,	rdi
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genss.doinstr
    mov       rbx,	[rbx+8]
L3341:
    test      rbx,	rbx
    jnz       L3340
    xor       ecx,	ecx
    call      mc_genss.switchseg
    mov       rcx,	[mc_decls.ss_zdata]
    call      mc_genss.bufferlength
    test      rax,	rax
    jz        L3344
    lea       rcx,	[L12476]
    call      mc_libmcl.axerror
L3344:
    test      r14,	r14
    jz        L3346
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    mov       rsi,	[mc_decls.riplist]
    jmp       L3350
L3347:
    mov       eax,	[rsi+8]
    lea       r10,	[r12 + rax]
    mov       r13,	r10
    movsxd    rax,	dword [rsi+12]
    mov       r10,	r13
    sub       [r10],	eax
    mov       rsi,	[rsi]
L3350:
    test      rsi,	rsi
    jnz       L3347
L3346:
    mov       al,	1
    mov       [pc_decls.ssdone],	al
    call      mwindows.os_clock
    sub       rax,	[pc_decls.sstime]
    mov       [pc_decls.sstime],	rax
L3337:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.doinstr
mc_genss.doinstr:
;?>>
    %define mc_genss.doinstr.m 64
    %define mc_genss.doinstr.index 72
   %define R.a rdi
   %define R.b rbx
   %define R.d rsi
   %define R.x r12
   %define R.offset r13
   %define R.shortjmp r14
    %define mc_genss.doinstr.n -8
    %define mc_genss.doinstr.av_1 -16
    %define mc_genss.doinstr.av_2 -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[mc_genss.currdata]
    mov       rax,	[rax+16]
    mov       r10,	[mc_genss.currdata]
    mov       r10,	[r10+8]
    sub       rax,	r10
    cmp       rax,	1024
    jge       L3353
    mov       rcx,	[mc_genss.currdata]
    call      mc_genss.bufferexpand
L3353:
    xor       eax,	eax
    mov       [mc_genss.usesizeb],	al
    mov       [mc_genss.nowmask],	al
    mov       [mc_genss.f3override],	al
    mov       [mc_genss.f2override],	al
    mov       [mc_genss.addroverride],	al
    mov       [mc_genss.sizeoverride],	al
    mov       [mc_genss.rex],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rbx,	[rax+24]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       eax,	[rax+36]
    mov       [mc_decls.aaseqno],	rax
    xor       eax,	eax
    mov       [mc_genss.ripentry],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       [mc_genss.currmcl],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    sub       rax,	1
    cmp       rax,	151
    jae       L3356
    lea       r10,	[L3355]
    jmp       [r10 + rax*8]
    segment .data
L3355:
    dq  L3357
    dq  L3358
    dq  L3480
    dq  L3361
    dq  L3359
    dq  L3360
    dq  L3356
    dq  L3480
    dq  L3368
    dq  L3389
    dq  L3403
    dq  L3398
    dq  L3399
    dq  L3404
    dq  L3462
    dq  L3446
    dq  L3447
    dq  L3405
    dq  L3406
    dq  L3407
    dq  L3373
    dq  L3394
    dq  L3356
    dq  L3395
    dq  L3374
    dq  L3375
    dq  L3408
    dq  L3402
    dq  L3402
    dq  L3402
    dq  L3402
    dq  L3401
    dq  L3401
    dq  L3409
    dq  L3356
    dq  L3401
    dq  L3401
    dq  L3402
    dq  L3402
    dq  L3402
    dq  L3440
    dq  L3402
    dq  L3439
    dq  L3439
    dq  L3439
    dq  L3439
    dq  L3439
    dq  L3439
    dq  L3439
    dq  L3401
    dq  L3401
    dq  L3400
    dq  L3400
    dq  L3390
    dq  L3391
    dq  L3392
    dq  L3393
    dq  L3445
    dq  L3476
    dq  L3476
    dq  L3479
    dq  L3479
    dq  L3448
    dq  L3449
    dq  L3448
    dq  L3449
    dq  L3448
    dq  L3449
    dq  L3448
    dq  L3449
    dq  L3448
    dq  L3449
    dq  L3452
    dq  L3453
    dq  L3453
    dq  L3450
    dq  L3451
    dq  L3450
    dq  L3451
    dq  L3451
    dq  L3451
    dq  L3456
    dq  L3457
    dq  L3458
    dq  L3459
    dq  L3460
    dq  L3461
    dq  L3455
    dq  L3454
    dq  L3472
    dq  L3472
    dq  L3356
    dq  L3356
    dq  L3464
    dq  L3464
    dq  L3464
    dq  L3465
    dq  L3465
    dq  L3465
    dq  L3466
    dq  L3466
    dq  L3466
    dq  L3466
    dq  L3463
    dq  L3463
    dq  L3463
    dq  L3463
    dq  L3463
    dq  L3463
    dq  L3463
    dq  L3463
    dq  L3448
    dq  L3448
    dq  L3449
    dq  L3449
    dq  L3382
    dq  L3383
    dq  L3384
    dq  L3385
    dq  L3387
    dq  L3388
    dq  L3386
    dq  L3423
    dq  L3410
    dq  L3410
    dq  L3410
    dq  L3410
    dq  L3444
    dq  L3441
    dq  L3441
    dq  L3441
    dq  L3442
    dq  L3443
    dq  L3467
    dq  L3468
    dq  L3469
    dq  L3470
    dq  L3471
    dq  L3475
    dq  L3478
    dq  L3473
    dq  L3474
    dq  L3474
    dq  L3474
    dq  L3474
    dq  L3474
    dq  L3474
    dq  L3474
    dq  L3477
    dq  L3356
    dq  L3389
    segment .text
L3357:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    mov       [mc_decls.currasmproc],	rax
    jmp       L3354
L3358:
    jmp       L3354
L3359:
    jmp       L3354
L3360:
    jmp       L3354
L3361:
    movzx     rax,	word [rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	4
    jz        L3363
    cmp       rax,	5
    jz        L3364
    jmp       L3365
L3363:
    jmp       L3362
L3364:
    mov       rsi,	[rdi]
    mov       al,	2
    mov       [rsi+93],	al
    mov       al,	[mc_genss.currseg]
    mov       [rsi+94],	al
    mov       rcx,	6
    call      mc_genss.getcurrdatalen
    mov       [rsi+76],	eax
    mov       al,	[rsi+81]
    test      al,	al
    jz        L3367
    mov       rcx,	rsi
    call      mc_genss.getstindex
L3367:
    mov       rcx,	rsi
    call      mc_genss.dofwdrefs
L3365:
L3362:
    jmp       L3354
L3368:
    movzx     rax,	word [rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jnz       L3370
    mov       rsi,	[rdi]
    jmp       L3369
L3370:
    mov       rax,	[rdi]
    mov       r10,	[mc_decls.labeldeftable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
L3369:
    mov       al,	2
    mov       [rsi+93],	al
    mov       al,	[mc_genss.currseg]
    mov       [rsi+94],	al
    mov       rcx,	6
    call      mc_genss.getcurrdatalen
    mov       [rsi+76],	eax
    mov       al,	[rsi+81]
    test      al,	al
    jz        L3372
    mov       rcx,	rsi
    call      mc_genss.getstindex
L3372:
    mov       rcx,	rsi
    call      mc_genss.dofwdrefs
    jmp       L3354
L3373:
    mov       rcx,	rdi
    call      mc_genss.do_call
    jmp       L3354
L3374:
    mov       rcx,	rdi
    mov       rdx,	[rbp + mc_genss.doinstr.m]
    call      mc_genss.do_jmp
    jmp       L3354
L3375:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rsi,	rax
    mov       rcx,	7
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genss.getrel32
    mov       r13,	rax
    cmp       r13,	0
    jge       L3377
    cmp       r13,	-126
    jge       L3379
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       r10,	128
    add       r10,	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    lea       rax,	[r13-4]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3378
L3379:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       r10,	112
    add       r10,	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r13b
L3378:
    jmp       L3376
L3377:
    mov       rcx,	[rbp + mc_genss.doinstr.m]
    mov       rdx,	rsi
    call      mc_genss.checkshortjump
    mov       r14,	rax
    test      r14,	r14
    jnz       L3381
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       r10,	128
    add       r10,	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    mov       rcx,	rdi
    call      mc_genss.genrel32
    jmp       L3380
L3381:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       r10,	112
    add       r10,	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    mov       rcx,	rdi
    call      mc_genss.genrel8
L3380:
L3376:
    jmp       L3354
L3382:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_genss.genopnd
    jmp       L3354
L3383:
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_genss.genopnd
    jmp       L3354
L3384:
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3354
L3385:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_genss.genopnd
    jmp       L3354
L3386:
    mov       rcx,	1
    call      mc_genss.switchseg
    jmp       L3354
L3387:
    mov       rcx,	2
    call      mc_genss.switchseg
    jmp       L3354
L3388:
    mov       rcx,	3
    call      mc_genss.switchseg
    jmp       L3354
L3389:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3354
L3390:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	152
    mov       [r10],	al
    jmp       L3354
L3391:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3354
L3392:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3354
L3393:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3354
L3394:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	195
    mov       [r10],	al
    jmp       L3354
L3395:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jz        L3397
    lea       rcx,	[L12477]
    call      mc_libmcl.axerror
L3397:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	194
    mov       [r10],	al
    mov       rcx,	[rdi]
    call      mc_genss.genword
    jmp       L3354
L3398:
    mov       rcx,	rdi
    call      mc_genss.do_push
    jmp       L3354
L3399:
    mov       rcx,	rdi
    call      mc_genss.do_pop
    jmp       L3354
L3400:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_inc
    jmp       L3354
L3401:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_neg
    jmp       L3354
L3402:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_arith
    jmp       L3354
L3403:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_mov
    jmp       L3354
L3404:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_lea
    jmp       L3354
L3405:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	190
    call      mc_genss.do_movsx
    jmp       L3354
L3406:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	182
    call      mc_genss.do_movsx
    jmp       L3354
L3407:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_movsxd
    jmp       L3354
L3408:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_exch
    jmp       L3354
L3409:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_imul2
    jmp       L3354
L3410:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3412
    mov       rax,	[rdi]
    mov       r10,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [r10+33]
    lea       r11,	[mc_decls.mclcodes]
    movzx     r11,	byte [r11 + r10-1]
    imul      rax,	r11
    mov       [rbp + mc_genss.doinstr.n],	rax
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L3414
    cmp       rax,	2
    jz        L3415
    jmp       L3416
L3414:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    mov       [rbp + mc_genss.doinstr.av_1],	rax
    mov       rax,	[rbp + mc_genss.doinstr.av_1]
    cmp       rax,	0
    jle       L3419
L3417:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	144
    mov       [r10],	al
    dec       qword [rbp + mc_genss.doinstr.av_1]
    jnz       L3417
L3419:
    jmp       L3413
L3415:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    mov       [rbp + mc_genss.doinstr.av_2],	rax
    mov       rax,	[rbp + mc_genss.doinstr.av_2]
    cmp       rax,	0
    jle       L3422
L3420:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    xor       eax,	eax
    mov       [r10],	al
    dec       qword [rbp + mc_genss.doinstr.av_2]
    jnz       L3420
L3422:
    jmp       L3413
L3416:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    add       [mc_decls.ss_zdatalen],	rax
L3413:
    jmp       L3411
L3412:
    lea       rcx,	[L12478]
    call      mc_libmcl.axerror
L3411:
    jmp       L3354
L3423:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3425
    mov       r12,	[rdi]
    cmp       r12,	1
    jl        L3428
    cmp       r12,	16384
    jle       L3427
L3428:
    lea       rcx,	[L12479]
    call      mc_libmcl.axerror
L3427:
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	r12
    call      mc_genss.buffercheck
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	3
    jz        L3430
    jmp       L3432
L3431:
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jnz       L3435
    mov       rax,	144
    jmp       L3434
L3435:
    xor       eax,	eax
L3434:
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3432:
    mov       rcx,	[mc_genss.currdata]
    call      mc_genss.bufferlength
    mov       r10,	r12
    cqo       
    idiv      r10
    xchg      rax,	rdx
    test      rax,	rax
    jnz       L3431
    jmp       L3429
L3430:
    jmp       L3437
L3436:
    inc       qword [mc_decls.ss_zdatalen]
L3437:
    mov       rax,	[mc_decls.ss_zdatalen]
    mov       r10,	r12
    cqo       
    idiv      r10
    xchg      rax,	rdx
    test      rax,	rax
    jnz       L3436
L3429:
    jmp       L3424
L3425:
    lea       rcx,	[L12480]
    call      mc_libmcl.axerror
L3424:
    jmp       L3354
L3439:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_shift
    jmp       L3354
L3440:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_test
    jmp       L3354
L3441:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_loop
    jmp       L3354
L3442:
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_genss.do_jcxz
    jmp       L3354
L3443:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_genss.do_jcxz
    jmp       L3354
L3444:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	215
    mov       [r10],	al
    jmp       L3354
L3445:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mc_genss.do_setcc
    jmp       L3354
L3446:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	4
    call      mc_genss.do_movxmm
    jmp       L3354
L3447:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	8
    call      mc_genss.do_movxmm
    jmp       L3354
L3448:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3354
L3449:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3354
L3450:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    mov       r9,	4
    call      mc_genss.do_logicxmm
    jmp       L3354
L3451:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    mov       r9,	8
    call      mc_genss.do_logicxmm
    jmp       L3354
L3452:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	47
    call      mc_genss.do_arithxmm
    jmp       L3354
L3453:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	102
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3354
L3454:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    call      mc_genss.do_convertfloat
    jmp       L3354
L3455:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    call      mc_genss.do_convertfloat
    jmp       L3354
L3456:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	45
    call      mc_genss.do_fix
    jmp       L3354
L3457:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	45
    call      mc_genss.do_fix
    jmp       L3354
L3458:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	44
    call      mc_genss.do_fix
    jmp       L3354
L3459:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	44
    call      mc_genss.do_fix
    jmp       L3354
L3460:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    call      mc_genss.do_float
    jmp       L3354
L3461:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    call      mc_genss.do_float
    jmp       L3354
L3462:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.do_cmovcc
    jmp       L3354
L3463:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	217
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3354
L3464:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	1
    mov       r8,	r10
    call      mc_genss.do_fmem
    jmp       L3354
L3465:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	r10
    call      mc_genss.do_fmem
    jmp       L3354
L3466:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	222
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3354
L3467:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	166
    mov       [r10],	al
    jmp       L3354
L3468:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3354
L3469:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3354
L3470:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3354
L3471:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3354
L3472:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_movdqx
    jmp       L3354
L3473:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	219
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	227
    mov       [r10],	al
    jmp       L3354
L3474:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	217
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3354
L3475:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_popcnt
    jmp       L3354
L3476:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_bsf
    jmp       L3354
L3477:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	162
    mov       [r10],	al
    jmp       L3354
L3478:
    mov       rcx,	rdi
    call      mc_genss.do_bswap
    jmp       L3354
L3479:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+32]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	r10
    call      mc_genss.do_dshift
    jmp       L3354
L3480:
    jmp       L3354
L3356:
    call      msys.m$print_startcon
    lea       rcx,	[L12481]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[L12482]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    lea       rcx,	[L12483]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L12484]
    call      msys.m$print_str_nf
    mov       rcx,	151
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12485]
    call      mc_libmcl.axerror
L3354:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.start
mc_genss.start:
;?>>
;?]]
;---------------
    mov       al,	64
    lea       r10,	[mc_genss.ishighreg]
    mov       [r10+3],	al
    mov       al,	64
    lea       r10,	[mc_genss.ishighreg]
    mov       [r10+5],	al
    mov       al,	64
    lea       r10,	[mc_genss.ishighreg]
    mov       [r10+14],	al
    mov       al,	64
    lea       r10,	[mc_genss.ishighreg]
    mov       [r10+15],	al
;---------------
    ret       
;End 
;Proc mc_genss.genword
mc_genss.genword:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.addword
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.gendword
mc_genss.gendword:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.adddword
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.genqword
mc_genss.genqword:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.addqword
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.genopnd
mc_genss.genopnd:
;?>>
   %define R.a rsi
   %define R.size r12
   %define R.s rdi
   %define R.length rbx
   %define R.x32 XMM15
    push      rdi
    push      rbx
    push      rsi
    push      r12
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    test      r12,	r12
    jnz       L3487
    movzx     rax,	word [rsi+8]
    and       rax,	31
    mov       r12,	rax
L3487:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	4
    jz        L3489
    cmp       rax,	7
    jz        L3490
    jmp       L3491
L3489:
    mov       rdi,	[rsi]
    mov       rcx,	rdi
    call      strlen
    mov       rbx,	rax
    cmp       rbx,	100
    jle       L3493
    lea       rax,	[rbx+1]
    mov       r10,	1024
    cmp       r10,	rax
    cmovl     r10,	rax
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	r10
    call      mc_genss.buffercheck
L3493:
    jmp       L3495
L3494:
    mov       rax,	rdi
    inc       rdi
    mov       al,	[rax]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3495:
    mov       al,	[rdi]
    test      al,	al
    jnz       L3494
    jmp       L3485
L3490:
    call      msys.m$print_startcon
    lea       rcx,	[L12486]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3491:
L3488:
    mov       rcx,	rsi
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3498
    cmp       r12,	2
    jg        L3498
    lea       rcx,	[L12487]
    call      mc_libmcl.axerror
L3498:
    mov       rax,	r12
    cmp       rax,	1
    jz        L3500
    cmp       rax,	2
    jz        L3501
    cmp       rax,	4
    jz        L3502
    cmp       rax,	8
    jz        L3503
    jmp       L3504
L3500:
    mov       rax,	[rsi]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3499
L3501:
    mov       rcx,	[rsi]
    call      mc_genss.genword
    jmp       L3499
L3502:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jz        L3506
    cmp       rax,	2
    jz        L3507
    cmp       rax,	5
    jz        L3508
    cmp       rax,	6
    jz        L3508
    jmp       L3509
L3506:
    mov       rcx,	[rsi]
    call      mc_genss.gendword
    jmp       L3505
L3507:
    movq      XMM4,	[rsi]
    cvtsd2ss  XMM4,	XMM4
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3505
L3508:
    mov       rcx,	rsi
    call      mc_genss.genabs32
    jmp       L3505
L3509:
    call      msys.m$print_startcon
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12488]
    call      mc_libmcl.axerror
L3505:
    jmp       L3499
L3503:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jz        L3511
    cmp       rax,	2
    jz        L3512
    cmp       rax,	5
    jz        L3513
    cmp       rax,	6
    jz        L3513
    jmp       L3514
L3511:
    mov       rcx,	[rsi]
    call      mc_genss.genqword
    jmp       L3510
L3512:
    movq      XMM4,	[rsi]
    movq      rax,	XMM4
    mov       rcx,	rax
    call      mc_genss.genqword
    jmp       L3510
L3513:
    mov       rcx,	rsi
    call      mc_genss.genabs64
    jmp       L3510
L3514:
    call      msys.m$print_startcon
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12489]
    call      mc_libmcl.axerror
L3510:
L3504:
L3499:
L3485:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.addrelocitem
mc_genss.addrelocitem:
;?>>
   %define R.reloctype r12
   %define R.d r13
   %define R.r rdi
   %define R.stindex rbx
   %define R.adjust rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	r13
    call      mc_genss.getstindex
    mov       rbx,	rax
    mov       rsi,	4
    cmp       r12,	1
    jnz       L3517
    mov       rsi,	8
L3517:
    mov       rcx,	32
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[mc_genss.currrelocs]
    mov       [rdi],	rax
    mov       [rdi+8],	r12
    mov       rcx,	1
    call      mc_genss.getcurrdatalen
    sub       rax,	rsi
    mov       [rdi+16],	rax
    mov       [rdi+24],	rbx
    inc       qword [mc_genss.nrelocs]
    mov       [mc_genss.currrelocs],	rdi
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getstindex
mc_genss.getstindex:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsx     rax,	word [rdi+96]
    test      rax,	rax
    jnz       L3520
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	[mc_decls.ss_symboltablesize]
    jl        L3522
    call      mc_genss.extendsymboltable
L3522:
    inc       qword [mc_decls.ss_nsymbols]
    mov       rax,	[mc_decls.ss_nsymbols]
    mov       [rdi+96],	ax
    movsx     rax,	word [rdi+96]
    mov       r10,	rdi
    mov       r11,	[mc_decls.ss_symboltable]
    mov       [r11 + rax*8-8],	r10
    movzx     rax,	byte [rdi+94]
    test      rax,	rax
    jnz       L3524
    mov       al,	[rdi+80]
    test      al,	al
    jz        L3526
    mov       al,	1
    mov       [rdi+94],	al
L3526:
L3524:
L3520:
    movsx     rax,	word [rdi+96]
L3518:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrel32
mc_genss.genrel32:
;?>>
   %define R.a rbx
   %define R.d rdi
    %define mc_genss.genrel32.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L3529
    mov       rcx,	[rbx]
    call      mc_genss.gendword
    jmp       L3527
L3529:
    movzx     rax,	byte [rdi+93]
    cmp       rax,	2
    jz        L3531
    cmp       rax,	1
    jz        L3532
    jmp       L3533
L3531:
    movzx     rax,	byte [rdi+94]
    cmp       rax,	[mc_genss.currseg]
    jz        L3535
    lea       rcx,	[L12490]
    call      mc_libmcl.axerror
L3535:
    movsxd    rax,	dword [rdi+76]
    mov       [rbp + mc_genss.genrel32.$T1],	rax
    mov       rcx,	2
    call      mc_genss.getcurrdatalen
    add       rax,	4
    mov       r10,	[rbp + mc_genss.genrel32.$T1]
    sub       r10,	rax
    movsxd    rax,	dword [rbx+12]
    add       r10,	rax
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L3530
L3532:
    mov       rcx,	3
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	4
    xor       r9d,	r9d
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3530
L3533:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	4
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3530:
L3527:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getdef
mc_genss.getdef:
;?>>
   %define R.a rbx
   %define R.dneeded rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3539
    cmp       rax,	2
    jnz       L3538
L3539:
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	6
    jz        L3541
    cmp       rax,	5
    jz        L3542
    jmp       L3543
L3541:
    mov       rax,	[rbx]
    mov       r10,	[mc_decls.labeldeftable]
    mov       r10,	[r10 + rax*8-8]
    mov       rax,	r10
    jmp       L3536
L3542:
    mov       rdi,	[rbx]
    movzx     rax,	byte [rdi+93]
    test      rax,	rax
    jnz       L3545
    mov       al,	[rdi+80]
    test      al,	al
    jnz       L3547
    mov       al,	1
    mov       [rdi+93],	al
L3547:
L3545:
    mov       rax,	rdi
    jmp       L3536
L3543:
L3540:
L3538:
    test      rsi,	rsi
    jz        L3549
    call      msys.m$print_startcon
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    lea       r10,	[mc_decls.opndnames_ma]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12491]
    call      mc_libmcl.axerror
L3549:
    xor       eax,	eax
L3536:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genabs32
mc_genss.genabs32:
;?>>
   %define R.a rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte [rdi+93]
    cmp       rax,	2
    jz        L3552
    cmp       rax,	1
    jz        L3553
    jmp       L3554
L3552:
    movsxd    rax,	dword [rdi+76]
    movsxd    r10,	dword [rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
    jmp       L3551
L3553:
    mov       rcx,	4
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	2
    mov       r9,	[mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movzx     rax,	byte [rdi+72]
    cmp       rax,	4
    jz        L3557
    cmp       rax,	5
    jnz       L3556
L3557:
    movsxd    rax,	dword [rdi+76]
    movsxd    r10,	dword [rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3555
L3556:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3555:
    jmp       L3551
L3554:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3551:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genabs64
mc_genss.genabs64:
;?>>
   %define R.a rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte [rdi+93]
    cmp       rax,	2
    jz        L3560
    cmp       rax,	1
    jz        L3561
    jmp       L3562
L3560:
    movsxd    rax,	dword [rdi+76]
    movsxd    r10,	dword [rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
    jmp       L3559
L3561:
    mov       rcx,	5
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	[mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movzx     rax,	byte [rdi+72]
    cmp       rax,	4
    jz        L3565
    cmp       rax,	5
    jnz       L3564
L3565:
    movsxd    rax,	dword [rdi+76]
    movsxd    r10,	dword [rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.genqword
    jmp       L3563
L3564:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3563:
    jmp       L3559
L3562:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3559:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getrel32
mc_genss.getrel32:
;?>>
   %define R.d rdi
   %define R.offset rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rdi+93]
    cmp       rax,	2
    jnz       L3568
    movzx     rax,	byte [rdi+94]
    cmp       rax,	[mc_genss.currseg]
    jz        L3570
    lea       rcx,	[L12492]
    call      mc_libmcl.axerror
L3570:
    movsxd    rax,	dword [rdi+76]
    lea       r10,	[rbx+1]
    sub       rax,	r10
    jmp       L3567
L3568:
    mov       rax,	2147483647
L3567:
L3566:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.dofwdrefs
mc_genss.dofwdrefs:
;?>>
   %define R.d r15
   %define R.f rdi
   %define R.offset rbx
   %define R.p8 rsi
   %define R.p32 r12
   %define R.p64 r13
   %define R.data r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r15,	rcx
;---------------
    mov       rax,	[r15+64]
    test      rax,	rax
    jz        L3571
L3573:
    mov       rdi,	[r15+64]
    jmp       L3575
L3574:
    movsxd    rax,	dword [rdi+8]
    mov       rbx,	rax
    movsx     rax,	word [rdi+12]
    cmp       rax,	4
    jz        L3578
    cmp       rax,	2
    jz        L3579
    cmp       rax,	1
    jz        L3579
    cmp       rax,	6
    jz        L3580
    jmp       L3581
L3578:
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    movsxd    rax,	dword [r15+76]
    sub       rax,	rbx
    sub       rax,	4
    mov       [r12],	eax
    jmp       L3577
L3579:
    movsx     rax,	word [rdi+14]
    cmp       rax,	1
    jz        L3583
    cmp       rax,	3
    jz        L3584
    cmp       rax,	2
    jz        L3585
    jmp       L3586
L3583:
    mov       r14,	[mc_decls.ss_code]
    jmp       L3582
L3584:
    lea       rcx,	[L12493]
    call      mc_libmcl.axerror
    jmp       L3582
L3585:
    mov       r14,	[mc_decls.ss_idata]
L3586:
L3582:
    mov       rcx,	r14
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    movsx     rax,	word [rdi+12]
    cmp       rax,	2
    jnz       L3588
    movsxd    rax,	dword [r12]
    movsxd    r10,	dword [r15+76]
    add       rax,	r10
    mov       [r12],	eax
    jmp       L3587
L3588:
    mov       r13,	r12
    mov       rax,	[r13]
    movsxd    r10,	dword [r15+76]
    add       rax,	r10
    mov       [r13],	rax
L3587:
    jmp       L3577
L3580:
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       rsi,	rax
    movsxd    rax,	dword [r15+76]
    sub       rax,	rbx
    dec       rax
    mov       [rsi],	al
    jmp       L3577
L3581:
    call      msys.m$print_startcon
    movsx     rax,	word [rdi+12]
    lea       r10,	[mc_objdecls.relocnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[r15]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12494]
    call      mc_libmcl.axerror
L3577:
    mov       rdi,	[rdi]
L3575:
    test      rdi,	rdi
    jnz       L3574
L3571:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrex
mc_genss.genrex:
;?>>
;?]]
;---------------
    mov       al,	[mc_genss.f2override]
    test      al,	al
    jz        L3591
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	242
    mov       [r10],	al
L3591:
    mov       al,	[mc_genss.f3override]
    test      al,	al
    jz        L3593
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	243
    mov       [r10],	al
L3593:
    mov       al,	[mc_genss.sizeoverride]
    test      al,	al
    jz        L3595
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
L3595:
    mov       al,	[mc_genss.addroverride]
    test      al,	al
    jz        L3597
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	103
    mov       [r10],	al
L3597:
    mov       al,	[mc_genss.nowmask]
    test      al,	al
    jz        L3599
    and       byte [mc_genss.rex],	247
L3599:
    mov       al,	[mc_genss.rex]
    test      al,	al
    jz        L3601
    movzx     rax,	byte [mc_genss.rex]
    and       rax,	15
    add       rax,	64
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3601:
;---------------
    ret       
;End 
;Proc mc_genss.isbytesized
mc_genss.isbytesized:
;?>>
   %define R.x rcx
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	-128
    jl        L3603
    cmp       rax,	127
    jg        L3603
    mov       rax,	1
    jmp       L3604
L3603:
    xor       eax,	eax
L3604:
L3602:
;---------------
    ret       
;End 
;Proc mc_genss.isdwordsized
mc_genss.isdwordsized:
;?>>
   %define R.x rcx
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	-2147483648
    jl        L3606
    cmp       rax,	2147483647
    jg        L3606
    mov       rax,	1
    jmp       L3607
L3606:
    xor       eax,	eax
L3607:
L3605:
;---------------
    ret       
;End 
;Proc mc_genss.genamode
mc_genss.genamode:
;?>>
   %define R.a rbx
    %define mc_genss.genamode.am 40
   %define R.pr rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rbx,	rcx
    mov       [rbp+40],	rdx
;---------------
    mov       al,	[rbp + mc_genss.genamode.am]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    movsx     rax,	byte [rbp + mc_genss.genamode.am+2]
    cmp       rax,	1
    jnz       L3610
    mov       al,	[rbp + mc_genss.genamode.am+1]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3610:
    movzx     rax,	byte [rbp + mc_genss.genamode.am+3]
    test      rax,	rax
    jz        L3612
    cmp       rax,	1
    jz        L3613
    cmp       rax,	4
    jz        L3614
    jmp       L3615
L3612:
    jmp       L3611
L3613:
    mov       eax,	[rbp + mc_genss.genamode.am+4]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3611
L3614:
    movsx     rax,	byte [rbp + mc_genss.genamode.am+2]
    cmp       rax,	-1
    jnz       L3617
    mov       rcx,	16
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	[mc_decls.riplist]
    mov       [rdi],	rax
    mov       rax,	[mc_genss.currdata]
    mov       rax,	[rax+8]
    mov       r10,	[mc_genss.currdata]
    mov       r10,	[r10]
    sub       rax,	r10
    mov       [rdi+8],	eax
    mov       rax,	rdi
    mov       [mc_decls.riplist],	rax
    mov       [mc_genss.ripentry],	rax
L3617:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3620
L3619:
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L3622
    cmp       rax,	6
    jz        L3622
    test      rax,	rax
    jz        L3623
    cmp       rax,	8
    jz        L3623
    jmp       L3624
L3622:
    mov       rcx,	rbx
    call      mc_genss.genabs32
    jmp       L3621
L3623:
    movsxd    rax,	dword [rbp + mc_genss.genamode.am+4]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3621
L3624:
    lea       rcx,	[L12495]
    call      mc_libmcl.axerror
L3621:
    jmp       L3618
L3620:
    call      msys.m$print_startcon
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    lea       r10,	[mc_decls.opndnames_ma]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12496]
    call      mc_libmcl.axerror
L3618:
    jmp       L3611
L3615:
    lea       rcx,	[L12497]
    call      mc_libmcl.axerror
L3611:
;---------------
    add       rsp,	32
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.setopsize
mc_genss.setopsize:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3627
    cmp       rax,	4
    jz        L3628
    cmp       rax,	1
    jz        L3629
    cmp       rax,	2
    jz        L3630
    jmp       L3631
L3627:
    mov       al,	8
    or        [mc_genss.rex],	al
    jmp       L3626
L3628:
    jmp       L3626
L3629:
    jmp       L3626
L3630:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    jmp       L3626
L3631:
    lea       rcx,	[L12498]
    call      mc_libmcl.axerror
L3626:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.getdispsize
mc_genss.getdispsize:
;?>>
   %define R.a rbx
   %define R.offset rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    mov       eax,	[rbx+12]
    mov       [rsi],	eax
    test      rdi,	rdi
    jz        L3634
    movzx     rax,	byte [rdi+72]
    cmp       rax,	4
    jz        L3637
    cmp       rax,	5
    jnz       L3636
L3637:
    movsxd    rax,	dword [rdi+76]
    mov       r10,	rsi
    add       [r10],	eax
    jmp       L3635
L3636:
    mov       rax,	4
    jmp       L3632
L3635:
L3634:
    mov       eax,	[rsi]
    test      eax,	eax
    jz        L3639
    movsxd    rax,	dword [rsi]
    mov       rcx,	rax
    call      mc_genss.isbytesized
    test      rax,	rax
    jz        L3641
    mov       rax,	1
    jmp       L3640
L3641:
    mov       rax,	4
L3640:
    jmp       L3638
L3639:
    xor       eax,	eax
L3638:
L3632:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.checkhighreg
mc_genss.checkhighreg:
;?>>
   %define R.a rcx
;?]]
;---------------
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3644
    movzx     rax,	byte [rcx+10]
    lea       r10,	[mc_genss.ishighreg]
    movzx     r10,	byte [r10 + rax-1]
    or        [mc_genss.rex],	r10b
L3644:
;---------------
    ret       
;End 
;Proc mc_genss.do_loop
mc_genss.do_loop:
;?>>
   %define R.a rbx
   %define R.opc rsi
   %define R.offset rdi
    %define mc_genss.do_loop.$T1 -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	9
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       [rbp + mc_genss.do_loop.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_loop.$T1]
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3647
    cmp       rdi,	-126
    jge       L3649
    lea       rcx,	[L12499]
    call      mc_libmcl.axerror
L3649:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L3646
L3647:
    lea       rcx,	[L12500]
    call      mc_libmcl.axerror
L3646:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_jcxz
mc_genss.do_jcxz:
;?>>
   %define R.a rbx
   %define R.opsize rsi
   %define R.offset rdi
    %define mc_genss.do_jcxz.$T1 -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	10
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       [rbp + mc_genss.do_jcxz.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_jcxz.$T1]
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3652
    cmp       rdi,	-126
    jge       L3654
    lea       rcx,	[L12501]
    call      mc_libmcl.axerror
L3654:
    cmp       rsi,	4
    jnz       L3656
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	103
    mov       [r10],	al
L3656:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	227
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L3651
L3652:
    lea       rcx,	[L12502]
    call      mc_libmcl.axerror
L3651:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_call
mc_genss.do_call:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3660
L3659:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	232
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.genrel32
    jmp       L3658
L3660:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    test      rax,	rax
    jz        L3662
    cmp       rax,	1
    jz        L3663
    cmp       rax,	2
    jz        L3663
    cmp       rax,	4
    jz        L3663
    jmp       L3664
L3662:
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    jmp       L3661
L3663:
    lea       rcx,	[L12503]
    call      mc_libmcl.axerror
L3664:
L3661:
    mov       rcx,	255
    mov       rdx,	2
    mov       r8,	rdi
    call      mc_genss.genxrm
L3658:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_jmp
mc_genss.do_jmp:
;?>>
   %define R.a r12
   %define R.m r13
   %define R.offset rdi
   %define R.shortjmp rbx
   %define R.d rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	r12
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rsi,	rax
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3668
L3667:
    mov       rcx,	11
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3670
    cmp       rdi,	-126
    jle       L3670
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	235
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L3669
L3670:
    xor       rbx,	rbx
    mov       rax,	rdi
    cmp       rax,	0
    jle       L3672
    mov       rcx,	r13
    mov       rdx,	rsi
    call      mc_genss.checkshortjump
    mov       rbx,	rax
L3672:
    test      rbx,	rbx
    jnz       L3674
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	233
    mov       [r10],	al
    mov       rcx,	r12
    call      mc_genss.genrel32
    jmp       L3673
L3674:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	235
    mov       [r10],	al
    mov       rcx,	r12
    call      mc_genss.genrel8
L3673:
L3669:
    jmp       L3666
L3668:
    movzx     rax,	word [r12+8]
    and       rax,	31
    test      rax,	rax
    jz        L3676
    cmp       rax,	1
    jz        L3677
    cmp       rax,	2
    jz        L3677
    cmp       rax,	4
    jz        L3677
    jmp       L3678
L3676:
    lea       rax,	[r12+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    jmp       L3675
L3677:
    lea       rcx,	[L12504]
    call      mc_libmcl.axerror
L3678:
L3675:
    mov       rcx,	255
    mov       rdx,	4
    mov       r8,	r12
    call      mc_genss.genxrm
L3666:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getcurrdatalen
mc_genss.getcurrdatalen:
;?>>
    %define mc_genss.getcurrdatalen.id 16
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	3
    jnz       L3681
    mov       rax,	[mc_decls.ss_zdatalen]
    jmp       L3679
L3681:
    mov       rcx,	[mc_genss.currdata]
    call      mc_genss.bufferlength
L3679:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genss.do_cmovcc
mc_genss.do_cmovcc:
;?>>
   %define R.cond rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	word [rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3684
    movzx     rax,	word [rsi+8]
    and       rax,	31
    jz        L3684
    lea       rcx,	[L12505]
    call      mc_libmcl.axerror
L3684:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3686
    lea       rcx,	[L12506]
    call      mc_libmcl.axerror
L3686:
    mov       rax,	3904
    add       rax,	rdi
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_fmem
mc_genss.do_fmem:
;?>>
   %define R.a rbx
   %define R.freal rsi
   %define R.code r12
   %define R.mf rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3689
    lea       rcx,	[L12507]
    call      mc_libmcl.axerror
L3689:
    test      rsi,	rsi
    jz        L3691
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jz        L3693
    cmp       rax,	8
    jz        L3694
    cmp       rax,	10
    jz        L3695
    cmp       rax,	16
    jz        L3695
    jmp       L3696
L3693:
    xor       rdi,	rdi
    jmp       L3692
L3694:
    mov       rdi,	2
    jmp       L3692
L3695:
    mov       rdi,	1
    mov       rax,	r12
    test      rax,	rax
    jz        L3698
    cmp       rax,	3
    jz        L3699
    jmp       L3700
L3698:
    mov       r12,	5
    jmp       L3697
L3699:
    mov       r12,	7
    jmp       L3697
L3700:
    lea       rcx,	[L12508]
    call      mc_libmcl.axerror
L3697:
    jmp       L3692
L3696:
    call      msys.m$print_startcon
    lea       rcx,	[L12509]
    call      msys.m$print_str_nf
    movzx     rax,	word [rbx+8]
    and       rax,	31
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12510]
    call      mc_libmcl.axerror
L3692:
    jmp       L3690
L3691:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	2
    jz        L3702
    cmp       rax,	4
    jz        L3703
    cmp       rax,	8
    jz        L3704
    jmp       L3705
L3702:
    mov       rdi,	3
    jmp       L3701
L3703:
    mov       rdi,	1
    jmp       L3701
L3704:
    mov       rdi,	3
    mov       rax,	r12
    test      rax,	rax
    jz        L3707
    cmp       rax,	3
    jz        L3708
    jmp       L3709
L3707:
    mov       r12,	5
    jmp       L3706
L3708:
    mov       r12,	7
    jmp       L3706
L3709:
    lea       rcx,	[L12511]
    call      mc_libmcl.axerror
L3706:
    jmp       L3701
L3705:
    lea       rcx,	[L12512]
    call      mc_libmcl.axerror
L3701:
L3690:
    mov       rax,	rdi
    shl       rax,	1
    mov       r10,	217
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	r12
    mov       r8,	rbx
    call      mc_genss.genxrm
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrel8
mc_genss.genrel8:
;?>>
   %define R.a rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte [rdi+93]
    cmp       rax,	1
    jnz       L3712
    mov       rcx,	3
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	6
    xor       r9d,	r9d
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    xor       eax,	eax
    mov       [r10],	al
    jmp       L3711
L3712:
    lea       rcx,	[L12513]
    call      mc_libmcl.axerror
L3711:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.checkshortjump
mc_genss.checkshortjump:
;?>>
   %define R.m rcx
   %define R.d rdx
   %define R.n rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
;---------------
    xor       rdi,	rdi
    mov       rax,	[rcx+8]
    mov       rcx,	rax
    jmp       L3715
L3714:
    movzx     rax,	byte [rcx+33]
    cmp       rax,	9
    jz        L3718
    cmp       rax,	3
    jz        L3719
    cmp       rax,	8
    jz        L3719
    cmp       rax,	124
    jz        L3720
    jmp       L3721
L3718:
    mov       rbx,	[rcx+16]
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	6
    jz        L3723
    cmp       rax,	5
    jz        L3724
    jmp       L3725
L3723:
    mov       rax,	[rbx]
    movsxd    r10,	dword [rdx+100]
    cmp       rax,	r10
    jnz       L3727
    mov       rax,	1
    jmp       L3713
L3727:
    jmp       L3722
L3724:
    mov       rax,	[rbx]
    cmp       rax,	rdx
    jnz       L3729
    mov       rax,	1
    jmp       L3713
L3729:
L3725:
L3722:
    jmp       L3717
L3719:
    jmp       L3717
L3720:
    xor       eax,	eax
    jmp       L3713
L3721:
    inc       rdi
L3717:
    mov       rax,	[rcx+8]
    mov       rcx,	rax
L3715:
    test      rcx,	rcx
    jz        L3730
    cmp       rdi,	8
    jle       L3714
L3730:
    xor       eax,	eax
L3713:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.addfwdref
mc_genss.addfwdref:
;?>>
   %define R.p rbx
   %define R.offset rsi
   %define R.reltype r12
   %define R.seg r13
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi],	rbx
    mov       [rdi+8],	esi
    mov       [rdi+12],	r12w
    mov       [rdi+14],	r13w
    mov       rax,	rdi
L3731:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.switchseg
mc_genss.switchseg:
;?>>
   %define R.newseg rcx
;?]]
;---------------
    cmp       rcx,	[mc_genss.currseg]
    jz        L3732
L3734:
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L3736
    cmp       rax,	2
    jz        L3737
    jmp       L3738
L3736:
    mov       rax,	[mc_genss.currrelocs]
    mov       [mc_decls.ss_coderelocs],	rax
    mov       rax,	[mc_genss.nrelocs]
    mov       [mc_decls.ss_ncoderelocs],	rax
    jmp       L3735
L3737:
    mov       rax,	[mc_genss.currrelocs]
    mov       [mc_decls.ss_idatarelocs],	rax
    mov       rax,	[mc_genss.nrelocs]
    mov       [mc_decls.ss_nidatarelocs],	rax
L3738:
L3735:
    mov       [mc_genss.currseg],	rcx
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L3740
    cmp       rax,	2
    jz        L3741
    cmp       rax,	3
    jz        L3742
    jmp       L3743
L3740:
    mov       rax,	[mc_decls.ss_code]
    mov       [mc_genss.currdata],	rax
    mov       rax,	[mc_decls.ss_coderelocs]
    mov       [mc_genss.currrelocs],	rax
    mov       rax,	[mc_decls.ss_ncoderelocs]
    mov       [mc_genss.nrelocs],	rax
    jmp       L3739
L3741:
    mov       rax,	[mc_decls.ss_idata]
    mov       [mc_genss.currdata],	rax
    mov       rax,	[mc_decls.ss_idatarelocs]
    mov       [mc_genss.currrelocs],	rax
    mov       rax,	[mc_decls.ss_nidatarelocs]
    mov       [mc_genss.nrelocs],	rax
    jmp       L3739
L3742:
    mov       rax,	[mc_decls.ss_zdata]
    mov       [mc_genss.currdata],	rax
L3743:
L3739:
L3732:
;---------------
    ret       
;End 
;Proc mc_genss.do_popcnt
mc_genss.do_popcnt:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3746
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L3748
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3748:
L3746:
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       rcx,	4024
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_bsf
mc_genss.do_bsf:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.opc rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3751
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L3753
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3753:
L3751:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    movzx     r10,	word [rbx+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3755
    lea       rcx,	[L12514]
    call      mc_libmcl.axerror
L3755:
    mov       rax,	3840
    add       rax,	rsi
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.extendsymboltable
mc_genss.extendsymboltable:
;?>>
   %define R.oldsymboltable rdi
   %define R.oldsymboltablesize rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rbx,	[mc_decls.ss_symboltablesize]
    mov       rdi,	[mc_decls.ss_symboltable]
    mov       rax,	[mc_decls.ss_symboltablesize]
    shl       rax,	1
    mov       [mc_decls.ss_symboltablesize],	rax
    mov       rax,	8
    imul      rax,	[mc_decls.ss_symboltablesize]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [mc_decls.ss_symboltable],	rax
    mov       rsi,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L3759
L3757:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    inc       rsi
    cmp       rsi,	[mc_decls.ss_nsymbols]
    jle       L3757
L3759:
    mov       rax,	8
    imul      rax,	rbx
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.pcm_free
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.initlib
mc_genss.initlib:
;?>>
   %define R.nlabels rsi
    %define mc_genss.initlib.str -256
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rsi,	rcx
;---------------
    mov       rcx,	262144
    call      mlib.pcm_alloc
    mov       [mc_decls.ss_symboltable],	rax
    mov       rax,	32768
    mov       [mc_decls.ss_symboltablesize],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_nsymbols],	rax
    mov       rax,	rsi
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [mc_decls.labeldeftable],	rax
    mov       rbx,	1
    cmp       rsi,	1
    jl        L3763
L3761:
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       r10,	[mc_decls.labeldeftable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       rdi,	rax
    mov       [rdi+100],	ebx
    lea       rcx,	[rbp + mc_genss.initlib.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12515]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_genss.initlib.str]
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    mov       al,	1
    mov       [rdi+93],	al
    inc       rbx
    cmp       rbx,	rsi
    jle       L3761
L3763:
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.buffercreate
mc_genss.buffercreate:
;?>>
   %define R.size rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	32
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       [rdi+24],	rbx
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rdi+8],	rax
    mov       [rdi],	rax
    mov       rax,	[rdi]
    mov       r10,	[rdi+24]
    lea       rax,	[rax + r10]
    mov       [rdi+16],	rax
    mov       rax,	rdi
L3764:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.bufferexpand
mc_genss.bufferexpand:
;?>>
   %define R.a r12
   %define R.newalloc rdi
   %define R.usedbytes rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rax,	[r12+24]
    shl       rax,	1
    mov       rdi,	rax
    mov       rax,	[r12+8]
    mov       r10,	[r12]
    sub       rax,	r10
    mov       rbx,	rax
    mov       rax,	[r12+24]
    mov       r10,	rbx
    cmp       r10,	rax
    jle       L3767
    call      msys.m$print_startcon
    lea       rcx,	[L12516]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
L3767:
    mov       rcx,	rdi
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    mov       [r12],	rsi
    lea       rax,	[rsi + rbx]
    mov       [r12+8],	rax
    mov       [r12+24],	rdi
    lea       rax,	[rsi + rdi]
    mov       [r12+16],	rax
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.buffercheck
mc_genss.buffercheck:
;?>>
   %define R.a rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    jmp       L3770
L3769:
    mov       rcx,	rdi
    call      mc_genss.bufferexpand
L3770:
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+8]
    sub       rax,	r10
    cmp       rax,	rbx
    jl        L3769
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.bufferlength
mc_genss.bufferlength:
;?>>
   %define R.a rcx
;?]]
;---------------
    mov       rax,	[rcx+8]
    mov       r10,	[rcx]
    sub       rax,	r10
L3772:
;---------------
    ret       
;End 
;Proc mc_genss.bufferelemptr
mc_genss.bufferelemptr:
;?>>
   %define R.a rcx
   %define R.offset rdx
;?]]
;---------------
    mov       rax,	[rcx]
    mov       r10,	rdx
    lea       rax,	[rax + r10]
L3773:
;---------------
    ret       
;End 
;Proc mc_genss.addword
mc_genss.addword:
;?>>
   %define R.a rcx
   %define R.x rdx
;?]]
;---------------
    mov       rax,	[rcx+8]
    mov       r10w,	dx
    mov       [rax],	r10w
    lea       rax,	[rcx+8]
    add       qword [rax],	2
;---------------
    ret       
;End 
;Proc mc_genss.adddword
mc_genss.adddword:
;?>>
   %define R.a rcx
   %define R.x rdx
;?]]
;---------------
    mov       rax,	[rcx+8]
    mov       r10d,	edx
    mov       [rax],	r10d
    lea       rax,	[rcx+8]
    add       qword [rax],	4
;---------------
    ret       
;End 
;Proc mc_genss.addqword
mc_genss.addqword:
;?>>
   %define R.a rcx
   %define R.x rdx
;?]]
;---------------
    mov       rax,	[rcx+8]
    mov       r10,	rdx
    mov       [rax],	r10
    lea       rax,	[rcx+8]
    add       qword [rax],	8
;---------------
    ret       
;End 
;Proc mc_genss.genxrm
mc_genss.genxrm:
;?>>
   %define R.opcode rbx
   %define R.code rsi
   %define R.b r12
   %define R.am rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	r12
    call      mc_genss.setopsize
    xor       ecx,	ecx
    mov       rdx,	rsi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_genss.genrm
    mov       rdi,	rax
    mov       rax,	[mc_genss.currmcl]
    movzx     rax,	byte [rax+33]
    cmp       rax,	12
    jz        L3779
    cmp       rax,	13
    jnz       L3780
L3779:
    and       byte [mc_genss.rex],	247
L3780:
L3778:
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	255
    jz        L3782
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	511
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3782:
    call      mc_genss.genrex
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    jz        L3784
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3784:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	bl
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_genss.genamode
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrrm
mc_genss.genrrm:
;?>>
   %define R.opcode rbx
   %define R.a rsi
   %define R.b r12
   %define R.am rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3787
    movzx     rax,	byte [rsi+10]
    lea       r10,	[mc_genss.ishighreg]
    movzx     r10,	byte [r10 + rax-1]
    or        [mc_genss.rex],	r10b
L3787:
    mov       rcx,	rsi
    call      mc_genss.setopsize
    mov       al,	[mc_genss.usesizeb]
    test      al,	al
    jz        L3789
    and       byte [mc_genss.rex],	247
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L3791
    mov       al,	8
    or        [mc_genss.rex],	al
L3791:
L3789:
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    movzx     r10,	byte [rsi+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	r12
    mov       r9,	rax
    call      mc_genss.genrm
    mov       rdi,	rax
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	255
    jz        L3793
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	511
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3793:
    call      mc_genss.genrex
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    jz        L3795
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3795:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	bl
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_genss.genamode
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getregcode
mc_genss.getregcode:
;?>>
   %define R.reg rcx
   %define R.mask rdx
   %define R.isxreg r8
   %define R.regcode rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    test      r8,	r8
    jnz       L3798
    lea       rax,	[mc_decls.regcodes]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    mov       rdi,	rax
    jmp       L3797
L3798:
    lea       rax,	[rcx-1]
    mov       rdi,	rax
L3797:
    cmp       rdi,	8
    jl        L3800
    mov       rax,	8
    sub       rdi,	rax
    mov       al,	dl
    or        [mc_genss.rex],	al
L3800:
    mov       rax,	rdi
L3796:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mc_genss.checkimmrange
mc_genss.checkimmrange:
;?>>
   %define R.value rdi
   %define R.size rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	rbx
    cmp       rax,	1
    jz        L3803
    cmp       rax,	2
    jz        L3804
    jmp       L3805
L3803:
    mov       rax,	rdi
    cmp       rax,	-128
    jl        L3808
    cmp       rax,	255
    jle       L3807
L3808:
    lea       rcx,	[L12517]
    call      mc_libmcl.axerror
L3807:
    jmp       L3802
L3804:
    mov       rax,	rdi
    cmp       rax,	-32768
    jl        L3811
    cmp       rax,	65535
    jle       L3810
L3811:
    lea       rcx,	[L12518]
    call      mc_libmcl.axerror
L3810:
    jmp       L3802
L3805:
    mov       rax,	rdi
    cmp       rax,	-2147483648
    jl        L3814
    mov       r10,	4294967295
    cmp       rax,	r10
    jle       L3813
L3814:
    lea       rcx,	[L12519]
    call      mc_libmcl.axerror
L3813:
L3802:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrm
mc_genss.genrm:
;?>>
   %define R.reg r13
   %define R.opc r14
    %define mc_genss.genrm.b 80
    %define mc_genss.genrm.isxreg 88
   %define R.mode rdi
   %define R.rm rbx
   %define R.scale rsi
   %define R.index r12
    %define mc_genss.genrm.base -8
    %define mc_genss.genrm.regix -16
    %define mc_genss.genrm.ismem -24
    %define mc_genss.genrm.am -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    lea       rax,	[rbp + mc_genss.genrm.am]
    xor       r10d,	r10d
    mov       [rax],	r10
    test      r13,	r13
    jz        L3817
    mov       rcx,	r13
    mov       rdx,	4
    mov       r8,	[rbp + mc_genss.genrm.isxreg]
    call      mc_genss.getregcode
    mov       r14,	rax
L3817:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3819
    cmp       rax,	5
    jz        L3819
    cmp       rax,	3
    jz        L3820
    jmp       L3821
L3819:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    mov       r10,	[rbp + mc_genss.genrm.b]
    movzx     r10,	byte [r10+10]
    mov       rcx,	r10
    mov       rdx,	1
    mov       r8,	rax
    call      mc_genss.getregcode
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte [rax+10]
    lea       r10,	[mc_genss.ishighreg]
    movzx     r10,	byte [r10 + rax-1]
    or        [mc_genss.rex],	r10b
    mov       rax,	r14
    shl       rax,	3
    mov       r10,	192
    add       r10,	rax
    add       r10,	rbx
    mov       [rbp + mc_genss.genrm.am],	r10b
    mov       rax,	[rbp + mc_genss.genrm.am]
    jmp       L3815
L3820:
    mov       rax,	1
    mov       [rbp + mc_genss.genrm.ismem],	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L3823
    cmp       rax,	3
    jz        L3824
    cmp       rax,	6
    jz        L3825
    jmp       L3826
L3823:
    mov       rax,	[rbp + mc_genss.genrm.b]
    mov       rax,	[rax]
    movzx     rax,	byte [rax+72]
    cmp       rax,	3
    jnz       L3828
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
L3828:
    jmp       L3822
L3824:
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
    jmp       L3822
L3825:
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
L3826:
L3822:
    jmp       L3818
L3821:
    lea       rcx,	[L12520]
    call      mc_libmcl.axerror
L3818:
    xor       eax,	eax
    mov       rbx,	rax
    mov       rdi,	rax
    xor       rsi,	rsi
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte [rax+10]
    mov       r13,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte [rax+11]
    mov       [rbp + mc_genss.genrm.regix],	rax
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	r13
    jnz       L3830
    test      rax,	rax
    jnz       L3830
    xor       rdi,	rdi
    mov       rax,	4
    mov       rbx,	rax
    mov       rsi,	1
    mov       r12,	4
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
    jmp       L3829
L3830:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jg        L3831
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jnz       L3831
;mc_genss.genrm.simple:
L3832:
    lea       rax,	[rbp + mc_genss.genrm.am+4]
    mov       rcx,	[rbp + mc_genss.genrm.b]
    mov       rdx,	rax
    call      mc_genss.getdispsize
    mov       [rbp + mc_genss.genrm.am+3],	al
    mov       al,	[rbp + mc_genss.genrm.am+3]
    test      al,	al
    jz        L3834
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	1
    jnz       L3836
    mov       rax,	1
    jmp       L3835
L3836:
    mov       rax,	2
L3835:
    mov       rdi,	rax
L3834:
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       rbx,	rax
    cmp       rbx,	4
    jz        L3838
    cmp       rbx,	5
    jnz       L3840
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    test      rax,	rax
    jnz       L3840
    mov       rdi,	1
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+3],	al
L3840:
    xor       r12,	r12
    jmp       L3837
L3838:
    mov       r12,	4
    mov       rsi,	1
L3837:
    jmp       L3829
L3831:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jz        L3841
    test      r13,	r13
    jnz       L3841
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jg        L3843
    mov       rax,	r13
    mov       r10,	[rbp + mc_genss.genrm.regix]
    mov       [rbp + mc_genss.genrm.regix],	rax
    mov       r13,	r10
    jmp       L3832
L3843:
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
    xor       rdi,	rdi
    mov       rax,	4
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    jz        L3845
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    jmp       L3844
L3845:
    mov       rax,	1
L3844:
    mov       rsi,	rax
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       rcx,	[rbp + mc_genss.genrm.regix]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       r12,	rax
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	16
    jnz       L3847
    lea       rcx,	[L12521]
    call      mc_libmcl.axerror
L3847:
    jmp       L3829
L3841:
    lea       rax,	[rbp + mc_genss.genrm.am+4]
    mov       rcx,	[rbp + mc_genss.genrm.b]
    mov       rdx,	rax
    call      mc_genss.getdispsize
    mov       [rbp + mc_genss.genrm.am+3],	al
    mov       al,	[rbp + mc_genss.genrm.am+3]
    test      al,	al
    jz        L3849
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	1
    jnz       L3851
    mov       rax,	1
    jmp       L3850
L3851:
    mov       rax,	2
L3850:
    mov       rdi,	rax
L3849:
    mov       rbx,	4
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    jz        L3853
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    jmp       L3852
L3853:
    mov       rax,	1
L3852:
    mov       rsi,	rax
    test      r13,	r13
    jnz       L3855
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    jmp       L3854
L3855:
    mov       rax,	r13
    cmp       rax,	15
    jz        L3858
    cmp       rax,	8
    jnz       L3857
L3858:
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    test      rax,	rax
    jnz       L3857
    mov       rdi,	1
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+3],	al
L3857:
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.base],	rax
L3854:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jnz       L3860
    mov       r12,	4
    jmp       L3859
L3860:
    mov       rcx,	[rbp + mc_genss.genrm.regix]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       r12,	rax
    test      r13,	r13
    jnz       L3862
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
L3862:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	16
    jnz       L3864
    cmp       rsi,	1
    jle       L3864
    lea       rcx,	[L12522]
    call      mc_libmcl.axerror
L3864:
L3859:
L3829:
    test      rsi,	rsi
    jz        L3866
    lea       rax,	[mc_genss.genrm.scaletable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    shl       rax,	6
    mov       r10,	r12
    shl       r10,	3
    add       rax,	r10
    add       rax,	[rbp + mc_genss.genrm.base]
    mov       [rbp + mc_genss.genrm.am+1],	al
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+2],	al
L3866:
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	4
    jnz       L3868
    mov       rax,	[rbp + mc_genss.genrm.ismem]
    test      rax,	rax
    jz        L3868
    test      r13,	r13
    jnz       L3871
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jz        L3870
L3871:
    movzx     rax,	byte [pc_api.phighmem]
    cmp       rax,	2
    jnz       L3873
    mov       rax,	[rbp + mc_genss.genrm.ismem]
    cmp       rax,	2
    jnz       L3873
    call      msys.m$print_startcon
    lea       rcx,	[L12523]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    mov       rcx,	[mc_genss.currmcl]
    call      mc_writenasm.strmclstr
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3873:
    jmp       L3869
L3870:
    mov       al,	[pc_api.phighmem]
    test      al,	al
    jz        L3874
    mov       al,	-1
    mov       [rbp + mc_genss.genrm.am+2],	al
    xor       rdi,	rdi
    mov       rax,	5
    mov       rbx,	rax
L3874:
L3869:
L3868:
    mov       rax,	rdi
    shl       rax,	6
    mov       r10,	r14
    shl       r10,	3
    add       rax,	r10
    add       rax,	rbx
    mov       [rbp + mc_genss.genrm.am],	al
    mov       rax,	[rbp + mc_genss.genrm.am]
L3815:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_arith
mc_genss.do_arith:
;?>>
   %define R.a r13
   %define R.b r14
   %define R.code r15
   %define R.d rdi
   %define R.opc rbx
   %define R.dispsize rsi
   %define R.x r12
    %define mc_genss.do_arith.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3877
    cmp       rax,	3
    jz        L3878
    jmp       L3879
L3877:
    movzx     rax,	word [r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3881
    cmp       rax,	3
    jz        L3881
    cmp       rax,	2
    jz        L3882
    jmp       L3883
L3881:
    mov       rax,	r15
    shl       rax,	3
    mov       [rbp + mc_genss.do_arith.$T1],	rax
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3885
    mov       rax,	2
    jmp       L3884
L3885:
    mov       rax,	3
L3884:
    mov       r10,	[rbp + mc_genss.do_arith.$T1]
    or        r10,	rax
    mov       rbx,	r10
    mov       rcx,	rbx
    mov       rdx,	r13
    mov       r8,	r14
    call      mc_genss.genrrm
    jmp       L3880
L3882:
;mc_genss.do_arith.doregimm:
L3886:
    mov       rcx,	r14
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L3888
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	4
    jge       L3890
    lea       rcx,	[L12524]
    call      mc_libmcl.axerror
L3890:
    mov       rcx,	129
    mov       rdx,	r15
    mov       r8,	r13
    call      mc_genss.genxrm
    mov       rcx,	r14
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3875
L3888:
    mov       r12,	[r14]
    mov       rsi,	1
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3892
    mov       rbx,	128
    mov       rcx,	r12
    mov       rdx,	1
    call      mc_genss.checkimmrange
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3895
    cmp       rax,	255
    jle       L3894
L3895:
    lea       rcx,	[L12525]
    call      mc_libmcl.axerror
L3894:
    jmp       L3891
L3892:
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3896
    cmp       rax,	127
    jg        L3896
    mov       rbx,	131
    jmp       L3891
L3896:
    mov       rcx,	r12
    mov       rdx,	4
    call      mc_genss.checkimmrange
    mov       rbx,	129
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	2
    jnz       L3898
    mov       rax,	2
    jmp       L3897
L3898:
    mov       rax,	4
L3897:
    mov       rsi,	rax
L3891:
    mov       rcx,	rbx
    mov       rdx,	r15
    mov       r8,	r13
    call      mc_genss.genxrm
    mov       rax,	rsi
    cmp       rax,	1
    jz        L3900
    cmp       rax,	2
    jz        L3901
    cmp       rax,	4
    jz        L3902
    jmp       L3903
L3900:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r12b
    jmp       L3899
L3901:
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3899
L3902:
    mov       rcx,	r12
    call      mc_genss.gendword
L3903:
L3899:
    mov       rcx,	rsi
    call      mc_genss.fixrip
    jmp       L3880
L3883:
    lea       rcx,	[L12526]
    call      mc_libmcl.axerror
L3880:
    jmp       L3876
L3878:
    movzx     rax,	word [r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3905
    cmp       rax,	2
    jz        L3906
    jmp       L3907
L3905:
    mov       rax,	r15
    shl       rax,	3
    mov       [rbp + mc_genss.do_arith.$T1],	rax
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3909
    xor       eax,	eax
    jmp       L3908
L3909:
    mov       rax,	1
L3908:
    mov       r10,	[rbp + mc_genss.do_arith.$T1]
    or        r10,	rax
    mov       rbx,	r10
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r13
    call      mc_genss.genrrm
    jmp       L3904
L3906:
    jmp       L3886
L3907:
    lea       rcx,	[L12527]
    call      mc_libmcl.axerror
L3904:
    jmp       L3876
L3879:
    call      msys.m$print_startcon
    lea       rax,	[mc_decls.opndnames_ma]
    mov       r10,	r15
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    lea       rcx,	[L12528]
    call      msys.m$print_str_nf
    mov       rcx,	r15
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12529]
    call      mc_libmcl.axerror
L3876:
L3875:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_mov
mc_genss.do_mov:
;?>>
   %define R.a r14
   %define R.b r15
   %define R.regcode rdi
   %define R.opc rbx
   %define R.dispsize rsi
   %define R.value r12
   %define R.d r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r14,	rcx
    mov       r15,	rdx
;---------------
    mov       rcx,	r15
    xor       edx,	edx
    call      mc_genss.getdef
    mov       r13,	rax
    movzx     rax,	word [r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3912
    cmp       rax,	3
    jz        L3913
    jmp       L3914
L3912:
    movzx     rax,	word [r15+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3916
    cmp       rax,	3
    jz        L3916
    cmp       rax,	2
    jz        L3917
    jmp       L3918
L3916:
    movzx     rax,	word [r14+8]
    and       rax,	31
    movzx     r10,	word [r15+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3920
    movzx     rax,	word [r15+8]
    and       rax,	31
    jz        L3920
    lea       rcx,	[L12530]
    call      mc_libmcl.axerror
L3920:
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3922
    mov       rax,	138
    jmp       L3921
L3922:
    mov       rax,	139
L3921:
    mov       rcx,	rax
    mov       rdx,	r14
    mov       r8,	r15
    call      mc_genss.genrrm
    jmp       L3915
L3917:
    mov       r12,	[r15]
    movzx     rax,	byte [r14+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    mov       rcx,	r14
    call      mc_genss.setopsize
    test      r13,	r13
    jz        L3924
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	2
    jg        L3924
    lea       rcx,	[L12531]
    call      mc_libmcl.axerror
L3924:
    mov       rcx,	r14
    call      mc_genss.checkhighreg
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jz        L3926
    cmp       rax,	2
    jz        L3927
    cmp       rax,	4
    jz        L3928
    jmp       L3929
L3926:
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3932
    cmp       rax,	255
    jle       L3931
L3932:
    lea       rcx,	[L12532]
    call      mc_libmcl.axerror
L3931:
    call      mc_genss.genrex
    mov       rax,	176
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r12b
    jmp       L3925
L3927:
    mov       rax,	r12
    cmp       rax,	-32768
    jl        L3935
    cmp       rax,	65535
    jle       L3934
L3935:
    lea       rcx,	[L12533]
    call      mc_libmcl.axerror
L3934:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3925
L3928:
    test      r13,	r13
    jz        L3937
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r15
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3936
L3937:
    mov       rax,	r12
    cmp       rax,	-2147483648
    jl        L3940
    mov       r10d,	4294967295
    mov       r10d,	r10d
    cmp       rax,	r10
    jle       L3939
L3940:
    call      msys.m$print_startcon
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    mov       rcx,	r12
    call      msys.m$print_ptr_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12534]
    call      mc_libmcl.axerror
L3939:
;mc_genss.do_mov.doreg32:
L3941:
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.gendword
L3936:
    jmp       L3925
L3929:
    test      r13,	r13
    jz        L3943
    mov       al,	8
    or        [mc_genss.rex],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r15
    mov       rdx,	8
    call      mc_genss.genopnd
    jmp       L3942
L3943:
    cmp       r12,	0
    jl        L3945
    mov       rax,	r12
    mov       r10,	4294967295
    cmp       rax,	r10
    jg        L3945
    and       byte [mc_genss.rex],	247
    jmp       L3941
L3945:
    mov       al,	8
    or        [mc_genss.rex],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.genqword
L3942:
L3925:
    jmp       L3915
L3918:
    lea       rcx,	[L12535]
    call      mc_libmcl.axerror
L3915:
    jmp       L3911
L3913:
    movzx     rax,	word [r15+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3947
    cmp       rax,	2
    jz        L3948
    jmp       L3949
L3947:
    movzx     rax,	word [r14+8]
    and       rax,	31
    jnz       L3951
    movzx     rax,	word [r15+8]
    and       rax,	31
    lea       r10,	[r14+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L3951:
    movzx     rax,	word [r14+8]
    and       rax,	31
    movzx     r10,	word [r15+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3953
    movzx     rax,	word [r14+8]
    and       rax,	31
    jz        L3953
    lea       rcx,	[L12536]
    call      mc_libmcl.axerror
L3953:
    movzx     rax,	word [r15+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3955
    mov       rax,	136
    jmp       L3954
L3955:
    mov       rax,	137
L3954:
    mov       rcx,	rax
    mov       rdx,	r15
    mov       r8,	r14
    call      mc_genss.genrrm
    jmp       L3946
L3948:
    mov       r12,	[r15]
    movzx     rax,	word [r14+8]
    and       rax,	31
    jnz       L3957
    lea       rax,	[r14+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3957:
    test      r13,	r13
    jz        L3959
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	2
    jg        L3959
    lea       rcx,	[L12537]
    call      mc_libmcl.axerror
L3959:
    mov       rcx,	r14
    call      mc_genss.setopsize
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3961
    mov       rax,	198
    jmp       L3960
L3961:
    mov       rax,	199
L3960:
    mov       rbx,	rax
    test      r13,	r13
    jnz       L3963
    movzx     rax,	word [r14+8]
    and       rax,	31
    mov       rcx,	r12
    mov       rdx,	rax
    call      mc_genss.checkimmrange
L3963:
    mov       rcx,	rbx
    xor       edx,	edx
    mov       r8,	r14
    call      mc_genss.genxrm
    mov       r12,	[r15]
    movzx     rax,	word [r14+8]
    and       rax,	31
    mov       rsi,	rax
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jz        L3965
    cmp       rax,	2
    jz        L3966
    cmp       rax,	4
    jz        L3967
    cmp       rax,	8
    jz        L3967
    jmp       L3968
L3965:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r12b
    jmp       L3964
L3966:
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3964
L3967:
    mov       rcx,	r15
    mov       rdx,	4
    call      mc_genss.genopnd
    mov       rsi,	4
L3968:
L3964:
    mov       rcx,	rsi
    call      mc_genss.fixrip
    jmp       L3946
L3949:
    lea       rcx,	[L12538]
    call      mc_libmcl.axerror
L3946:
    jmp       L3911
L3914:
    lea       rcx,	[L12539]
    call      mc_libmcl.axerror
L3911:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_push
mc_genss.do_push:
;?>>
   %define R.a rbx
   %define R.code rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L3971
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3971:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3973
    cmp       rax,	2
    jz        L3974
    cmp       rax,	3
    jz        L3975
    jmp       L3976
L3973:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3978
    lea       rcx,	[L12540]
    call      mc_libmcl.axerror
L3978:
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    and       byte [mc_genss.rex],	247
    call      mc_genss.genrex
    mov       rax,	80
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3972
L3974:
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3980
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	104
    mov       [r10],	al
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3979
L3980:
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mc_genss.isbytesized
    test      rax,	rax
    jz        L3981
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	106
    mov       [r10],	al
    mov       rax,	[rbx]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3979
L3981:
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mc_genss.isdwordsized
    test      rax,	rax
    jz        L3982
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	104
    mov       [r10],	al
    mov       rcx,	[rbx]
    call      mc_genss.gendword
    jmp       L3979
L3982:
    lea       rcx,	[L12541]
    call      mc_libmcl.axerror
L3979:
    jmp       L3972
L3975:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3984
    lea       rcx,	[L12542]
    call      mc_libmcl.axerror
L3984:
    mov       rcx,	255
    mov       rdx,	6
    mov       r8,	rbx
    call      mc_genss.genxrm
    jmp       L3972
L3976:
    lea       rcx,	[L12543]
    call      mc_libmcl.axerror
L3972:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_pop
mc_genss.do_pop:
;?>>
   %define R.a rbx
   %define R.code rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L3987
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3987:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3989
    cmp       rax,	3
    jz        L3990
    jmp       L3991
L3989:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3993
    lea       rcx,	[L12544]
    call      mc_libmcl.axerror
L3993:
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	88
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3988
L3990:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3995
    lea       rcx,	[L12545]
    call      mc_libmcl.axerror
L3995:
    mov       rcx,	143
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
    jmp       L3988
L3991:
    lea       rcx,	[L12546]
    call      mc_libmcl.axerror
L3988:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_inc
mc_genss.do_inc:
;?>>
   %define R.a rdi
   %define R.code rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3998
    cmp       rax,	3
    jnz       L3999
L3998:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4001
    mov       rax,	254
    jmp       L4000
L4001:
    mov       rax,	255
L4000:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genxrm
    jmp       L3997
L3999:
    lea       rcx,	[L12547]
    call      mc_libmcl.axerror
L3997:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_neg
mc_genss.do_neg:
;?>>
   %define R.a rdi
   %define R.code rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4004
    cmp       rax,	3
    jnz       L4005
L4004:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4007
    mov       rax,	246
    jmp       L4006
L4007:
    mov       rax,	247
L4006:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genxrm
    jmp       L4003
L4005:
    lea       rcx,	[L12548]
    call      mc_libmcl.axerror
L4003:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_lea
mc_genss.do_lea:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4011
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4010
L4011:
    lea       rcx,	[L12549]
    call      mc_libmcl.axerror
L4010:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	4
    jge       L4013
    lea       rcx,	[L12550]
    call      mc_libmcl.axerror
L4013:
    mov       rcx,	141
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_movsx
mc_genss.do_movsx:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.opc rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4016
    lea       rcx,	[L12551]
    call      mc_libmcl.axerror
L4016:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4018
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4018
    cmp       rsi,	190
    jnz       L4020
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_movsxd
    jmp       L4019
L4020:
    movzx     rax,	byte [rdi+10]
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rax
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       r10,	[r10+24]
    mov       rdi,	r10
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_mov
L4019:
    jmp       L4014
L4018:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4023
    movzx     rax,	word [rdi+8]
    and       rax,	31
    movzx     r10,	word [rbx+8]
    and       r10,	31
    cmp       rax,	r10
    ja        L4022
L4023:
    lea       rcx,	[L12552]
    call      mc_libmcl.axerror
L4022:
    cmp       rsi,	182
    jnz       L4025
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4025
    lea       rcx,	[L12553]
    call      mc_libmcl.axerror
L4025:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4027
    cmp       rax,	3
    jz        L4028
    jmp       L4029
L4027:
    jmp       L4026
L4028:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L4031
    lea       rcx,	[L12554]
    call      mc_libmcl.axerror
L4031:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4033
    lea       rcx,	[L12555]
    call      mc_libmcl.axerror
L4033:
    jmp       L4026
L4029:
    lea       rcx,	[L12556]
    call      mc_libmcl.axerror
L4026:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4035
    mov       rax,	rsi
    jmp       L4034
L4035:
    lea       rax,	[rsi+1]
L4034:
    mov       r10,	3840
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4014:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_exch
mc_genss.do_exch:
;?>>
   %define R.a rbx
   %define R.b rsi
   %define R.regcode rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4038
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4038
    movzx     rax,	byte [rbx+10]
    cmp       rax,	1
    jz        L4039
    movzx     rax,	byte [rsi+10]
    cmp       rax,	1
    jnz       L4038
L4039:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4038
    movzx     rax,	byte [rbx+10]
    cmp       rax,	1
    jz        L4041
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
L4041:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	word [rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4043
    lea       rcx,	[L12557]
    call      mc_libmcl.axerror
L4043:
    mov       rcx,	rbx
    call      mc_genss.setopsize
    movzx     rax,	byte [rsi+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	144
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L4036
L4038:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4045
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
L4045:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4048
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4047
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4047
L4048:
    lea       rcx,	[L12558]
    call      mc_libmcl.axerror
L4047:
    movzx     rax,	word [rsi+8]
    and       rax,	31
    jnz       L4050
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4050
    movzx     rax,	word [rbx+8]
    and       rax,	31
    lea       r10,	[rsi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4050:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	word [rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4052
    lea       rcx,	[L12559]
    call      mc_libmcl.axerror
L4052:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4054
    mov       rax,	134
    jmp       L4053
L4054:
    mov       rax,	135
L4053:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
L4036:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_movsxd
mc_genss.do_movsxd:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4057
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L4057
    lea       rax,	[rbx+8]
    mov       r10w,	4
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4057:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4060
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jle       L4059
L4060:
    lea       rcx,	[L12560]
    call      mc_libmcl.axerror
L4059:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4063
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4062
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4062
L4063:
    lea       rcx,	[L12561]
    call      mc_libmcl.axerror
L4062:
    mov       rcx,	99
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_imul2
mc_genss.do_imul2:
;?>>
   %define R.a r12
   %define R.b r13
   %define R.opc rdi
   %define R.dispsize rbx
   %define R.value rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4066
    lea       rcx,	[L12562]
    call      mc_libmcl.axerror
L4066:
    movzx     rax,	word [r13+8]
    and       rax,	31
    jnz       L4068
    movzx     rax,	word [r12+8]
    and       rax,	31
    lea       r10,	[r13+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4068:
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4070
    lea       rcx,	[L12563]
    call      mc_libmcl.axerror
L4070:
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4072
    cmp       rax,	3
    jz        L4072
    cmp       rax,	2
    jz        L4073
    jmp       L4074
L4072:
    movzx     rax,	word [r12+8]
    and       rax,	31
    movzx     r10,	word [r13+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4076
    lea       rcx,	[L12564]
    call      mc_libmcl.axerror
L4076:
    mov       rcx,	4015
    mov       rdx,	r12
    mov       r8,	r13
    call      mc_genss.genrrm
    jmp       L4071
L4073:
    mov       rcx,	r13
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L4078
    lea       rcx,	[L12565]
    call      mc_libmcl.axerror
L4078:
    mov       rsi,	[r13]
    mov       rax,	rsi
    cmp       rax,	-128
    jl        L4080
    cmp       rax,	127
    jg        L4080
    mov       rdi,	107
    jmp       L4079
L4080:
    mov       rdi,	105
L4079:
    mov       rcx,	rdi
    mov       rdx,	r12
    mov       r8,	r12
    call      mc_genss.genrrm
    mov       rax,	rsi
    cmp       rax,	-128
    jl        L4082
    cmp       rax,	127
    jg        L4082
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       rbx,	1
    jmp       L4081
L4082:
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	2
    jnz       L4083
    mov       rcx,	rsi
    call      mc_genss.genword
    mov       rbx,	2
    jmp       L4081
L4083:
    mov       rcx,	rsi
    call      mc_genss.gendword
    mov       rbx,	4
L4081:
    mov       rcx,	rbx
    call      mc_genss.fixrip
    jmp       L4071
L4074:
    lea       rcx,	[L12566]
    call      mc_libmcl.axerror
L4071:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_shift
mc_genss.do_shift:
;?>>
   %define R.a r12
   %define R.b r13
   %define R.code r14
   %define R.w rdi
   %define R.opc rbx
   %define R.needdisp rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4086
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4086
    lea       rcx,	[L12567]
    call      mc_libmcl.axerror
L4086:
    mov       rcx,	r13
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L4088
    lea       rcx,	[L12568]
    call      mc_libmcl.axerror
L4088:
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4090
    xor       eax,	eax
    jmp       L4089
L4090:
    mov       rax,	1
L4089:
    mov       rdi,	rax
    xor       rsi,	rsi
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jz        L4092
    cmp       rax,	1
    jz        L4093
    jmp       L4094
L4092:
    mov       rax,	[r13]
    cmp       rax,	1
    jnz       L4096
    mov       rax,	208
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L4095
L4096:
    mov       rax,	192
    add       rax,	rdi
    mov       rbx,	rax
    mov       rsi,	1
L4095:
    jmp       L4091
L4093:
    movzx     rax,	byte [r13+10]
    cmp       rax,	11
    jnz       L4099
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4098
L4099:
    lea       rcx,	[L12569]
    call      mc_libmcl.axerror
L4098:
    mov       rax,	210
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L4091
L4094:
    lea       rcx,	[L12570]
    call      mc_libmcl.axerror
L4091:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_genss.genxrm
    test      rsi,	rsi
    jz        L4101
    mov       rax,	[r13]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	1
    call      mc_genss.fixrip
L4101:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_test
mc_genss.do_test:
;?>>
   %define R.a rbx
   %define R.b rsi
   %define R.value rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4104
    movzx     rax,	byte [rbx+10]
    cmp       rax,	1
    jnz       L4104
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L4104
    mov       rdi,	[rsi]
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4106
    cmp       rax,	2
    jz        L4107
    cmp       rax,	4
    jz        L4108
    jmp       L4109
L4106:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	168
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L4105
L4107:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.genword
    jmp       L4105
L4108:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.gendword
    jmp       L4105
L4109:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.gendword
L4105:
    jmp       L4103
L4104:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4111
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4110
L4111:
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L4110
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4113
    mov       rax,	246
    jmp       L4112
L4113:
    mov       rax,	247
L4112:
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4115
    cmp       rax,	2
    jz        L4116
    jmp       L4117
L4115:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L4114
L4116:
    mov       rcx,	rdi
    call      mc_genss.genword
    jmp       L4114
L4117:
    mov       rcx,	rdi
    call      mc_genss.gendword
L4114:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    mov       rcx,	rax
    call      mc_genss.fixrip
    jmp       L4103
L4110:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4119
    cmp       rax,	3
    jnz       L4118
L4119:
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4118
;mc_genss.do_test.domemreg:
L4120:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4122
    mov       rax,	132
    jmp       L4121
L4122:
    mov       rax,	133
L4121:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
    jmp       L4103
L4118:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4123
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4123
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
    jmp       L4120
L4123:
    lea       rcx,	[L12571]
    call      mc_libmcl.axerror
L4103:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_setcc
mc_genss.do_setcc:
;?>>
   %define R.cond rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4128
    cmp       rax,	3
    jnz       L4127
L4128:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jle       L4126
L4127:
    lea       rcx,	[L12572]
    call      mc_libmcl.axerror
L4126:
    mov       rax,	3984
    add       rax,	rdi
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.checksize
mc_genss.checksize:
;?>>
   %define R.a rdi
   %define R.size1 rbx
   %define R.size2 rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    and       rax,	31
    jnz       L4131
    lea       rcx,	[L12573]
    call      mc_libmcl.axerror
L4131:
    test      rbx,	rbx
    jz        L4133
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	rbx
    jz        L4133
    cmp       rax,	rsi
    jz        L4133
    call      msys.m$print_startcon
    lea       rcx,	[L12574]
    call      msys.m$print_str_nf
    movzx     rax,	word [rdi+8]
    and       rax,	31
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12575]
    call      mc_libmcl.axerror
L4133:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_arithxmm
mc_genss.do_arithxmm:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
   %define R.opc r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4137
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4136
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4136
L4137:
    lea       rcx,	[L12576]
    call      mc_libmcl.axerror
L4136:
    test      rsi,	rsi
    jz        L4139
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
L4139:
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_logicxmm
mc_genss.do_logicxmm:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.opc rsi
   %define R.size r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4143
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4142
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4142
L4143:
    lea       rcx,	[L12577]
    call      mc_libmcl.axerror
L4142:
    cmp       r12,	8
    jnz       L4145
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
L4145:
    mov       rax,	3840
    add       rax,	rsi
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_convertfloat
mc_genss.do_convertfloat:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4149
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4148
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4148
L4149:
    lea       rcx,	[L12578]
    call      mc_libmcl.axerror
L4148:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3930
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_fix
mc_genss.do_fix:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
   %define R.opc r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r15
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4153
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4152
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4152
L4153:
    lea       rcx,	[L12579]
    call      mc_libmcl.axerror
L4152:
    mov       rcx,	rdi
    mov       rdx,	4
    mov       r8,	8
    call      mc_genss.checksize
    cmp       rsi,	243
    jnz       L4155
    mov       rax,	4
    jmp       L4154
L4155:
    mov       rax,	8
L4154:
    lea       r10,	[rbx+8]
    mov       r15w,	[r10]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	ax
    mov       [r10],	r15w
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       r15
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_float
mc_genss.do_float:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4159
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4158
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4158
L4159:
    lea       rcx,	[L12580]
    call      mc_libmcl.axerror
L4158:
    mov       rcx,	rbx
    mov       rdx,	4
    mov       r8,	8
    call      mc_genss.checksize
    cmp       rsi,	243
    jnz       L4161
    mov       rax,	4
    jmp       L4160
L4161:
    mov       rax,	8
L4160:
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       al,	1
    mov       [mc_genss.usesizeb],	al
    mov       rcx,	3882
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_movxmm
mc_genss.do_movxmm:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.size rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4164
    cmp       rax,	5
    jz        L4165
    cmp       rax,	3
    jz        L4166
    jmp       L4167
L4164:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4170
L4169:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4172
    lea       rcx,	[L12581]
    call      mc_libmcl.axerror
L4172:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    lea       r10,	[rbx+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       rcx,	3966
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4168
L4170:
    lea       rcx,	[L12582]
    call      mc_libmcl.axerror
L4168:
    jmp       L4163
L4165:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4174
    cmp       rax,	5
    jz        L4175
    cmp       rax,	3
    jz        L4176
    jmp       L4177
L4174:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4179
    lea       rcx,	[L12583]
    call      mc_libmcl.axerror
L4179:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       rcx,	3950
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4173
L4175:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       rcx,	3966
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4173
L4176:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L4181
    movzx     rax,	word [rdi+8]
    and       rax,	31
    lea       r10,	[rbx+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4181:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4183
    lea       rcx,	[L12584]
    call      mc_libmcl.axerror
L4183:
    cmp       rsi,	4
    jnz       L4185
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3950
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4184
L4185:
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3966
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4184:
    jmp       L4173
L4177:
    lea       rcx,	[L12585]
    call      mc_libmcl.axerror
L4173:
    jmp       L4163
L4166:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4188
L4187:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    jz        L4190
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4190
    lea       rcx,	[L12586]
    call      mc_libmcl.axerror
L4190:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    cmp       rsi,	4
    jnz       L4192
    mov       rax,	3966
    jmp       L4191
L4192:
    mov       rax,	4054
L4191:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4186
L4188:
    lea       rcx,	[L12587]
    call      mc_libmcl.axerror
L4186:
    jmp       L4163
L4167:
    lea       rcx,	[L12588]
    call      mc_libmcl.axerror
L4163:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.fixrip
mc_genss.fixrip:
;?>>
   %define R.dispsize rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_genss.ripentry]
    test      rax,	rax
    jz        L4193
L4195:
    mov       rax,	rdi
    test      rax,	rax
    jz        L4197
    cmp       rax,	1
    jz        L4198
    cmp       rax,	2
    jz        L4198
    cmp       rax,	4
    jz        L4198
    jmp       L4199
L4197:
    jmp       L4193
L4198:
    jmp       L4196
L4199:
    call      msys.m$print_startcon
    lea       rcx,	[L12589]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12590]
    call      mc_libmcl.axerror
L4196:
    mov       eax,	edi
    mov       r10,	[mc_genss.ripentry]
    mov       [r10+12],	eax
L4193:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_bswap
mc_genss.do_bswap:
;?>>
   %define R.a rbx
   %define R.code rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4203
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jge       L4202
L4203:
    lea       rcx,	[L12591]
    call      mc_libmcl.axerror
L4202:
    mov       rcx,	rbx
    call      mc_genss.setopsize
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	200
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_movdqx
mc_genss.do_movdqx:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rax,	rsi
    shl       rax,	16
    add       rax,	3840
    mov       rsi,	rax
    movzx     rax,	word [rdi+8]
    and       rax,	31
    jnz       L4206
    lea       rax,	[rdi+8]
    mov       r10w,	16
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4206:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L4208
    lea       rax,	[rbx+8]
    mov       r10w,	16
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4208:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4210
    lea       rax,	[rsi+127]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4209
L4210:
    lea       rax,	[rsi+111]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4209:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_dshift
mc_genss.do_dshift:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
   %define R.opc r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r15
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    movzx     rax,	word [rdi+8]
    and       rax,	31
    jnz       L4213
    movzx     rax,	word [rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r15w,	[r10]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	ax
    mov       [r10],	r15w
L4213:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    movzx     r10,	word [rbx+8]
    and       r10,	31
    cmp       rax,	r10
    jnz       L4216
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	1
    jg        L4215
L4216:
    lea       rcx,	[L12592]
    call      mc_libmcl.axerror
L4215:
    xor       eax,	eax
    mov       [mc_genss.sizeoverride],	al
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
;---------------
    add       rsp,	48
    pop       r15
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_decls.start
mc_decls.start:
;?>>
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    xor       rbx,	rbx
    mov       rax,	13
    mov       rdi,	rax
    cmp       rdi,	0
    jl        L4220
L4218:
    mov       al,	10
    lea       r10,	[mc_decls.ploadop]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    inc       rbx
    cmp       rbx,	rdi
    jle       L4218
L4220:
    mov       al,	19
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+5],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+4],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+3],	al
    mov       al,	18
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+9],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+8],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+7],	al
    mov       al,	16
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+1],	al
    mov       al,	17
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+2],	al
    mov       al,	11
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+10],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+6],	al
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.getassemstr
mc_writenasm.getassemstr:
;?>>
   %define R.d rdi
   %define R.m rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_init
    lea       rcx,	[L12593]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12594]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12595]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12596]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12597]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12598]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12599]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12600]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12601]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12602]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12603]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12604]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12605]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12606]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12607]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12608]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12609]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12610]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12611]
    call      mc_writenasm.asmstr
    mov       rdi,	[pc_decls.psymboltable]
    jmp       L4225
L4222:
    mov       al,	[rdi+80]
    test      al,	al
    jz        L4227
    lea       rcx,	[L12612]
    call      mc_writenasm.asmstr
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12613]
    call      mc_writenasm.asmstr
L4227:
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4229
    lea       rcx,	[L12614]
    call      mc_writenasm.asmstr
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12615]
    call      mc_writenasm.asmstr
L4229:
    mov       rdi,	[rdi+8]
L4225:
    test      rdi,	rdi
    jnz       L4222
    lea       rcx,	[L12615]
    call      mc_writenasm.asmstr
    mov       rbx,	[mc_decls.mccode]
    mov       rsi,	1
    jmp       L4231
L4230:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_writenasm.writemcl
    inc       rsi
    mov       rbx,	[rbx+8]
L4231:
    test      rbx,	rbx
    jnz       L4230
    mov       rax,	[pc_decls.pdest]
L4221:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.writemcl
mc_writenasm.writemcl:
;?>>
    %define mc_writenasm.writemcl.index 24
   %define R.mcl rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    call      mc_writenasm.strmcl
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_line
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.start
mc_writenasm.start:
;?>>
   %define R.flag dil
   %define R.av_1 rbx
   %define R.i rsi
   %define R.r r12
   %define R.k r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	1297301838
    mov       [pc_decls.assemtype],	rax
    mov       rsi,	1
L4235:
    mov       rax,	rsi
    cmp       rax,	1
    jz        L4240
    cmp       rax,	2
    jz        L4240
    cmp       rax,	4
    jz        L4240
    cmp       rax,	8
    jnz       L4239
L4240:
    mov       r12,	1
L4241:
    xor       dil,	dil
    mov       rax,	1
    mov       r13,	rax
    mov       rbx,	137
    cmp       rbx,	1
    jl        L4246
L4244:
    test      dil,	dil
    jz        L4248
    lea       rax,	[mc_decls.regsizes]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	rsi
    jnz       L4250
    lea       rax,	[mc_decls.regindices]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	r12
    jnz       L4250
    lea       rax,	[mc_decls.dregnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[mc_writenasm.nregnames]
    mov       r11,	rsi
    shl       r11,	7
    lea       r10,	[r10 + r11-128]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4250:
    jmp       L4247
L4248:
    lea       rax,	[mc_decls.regsizes]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L4251
    mov       dil,	1
L4251:
L4247:
    inc       r13
    cmp       r13,	rbx
    jle       L4244
L4246:
    inc       r12
    cmp       r12,	16
    jle       L4241
L4239:
    inc       rsi
    cmp       rsi,	8
    jle       L4235
;---------------
    add       rsp,	16
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.strmcl
mc_writenasm.strmcl:
;?>>
    %define mc_writenasm.strmcl.mcl 72
    %define mc_writenasm.strmcl.opcname -128
   %define R.a rdi
   %define R.b rbx
   %define R.opcode rsi
   %define R.cond r12
   %define R.sizepref r13
   %define R.comment r14
   %define R.d r15
    %define mc_writenasm.strmcl.$T1 -136
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	168
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     rax,	byte [rax+33]
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     rax,	byte [rax+34]
    mov       r12,	rax
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    mov       rbx,	[rax+24]
    xor       r14,	r14
    mov       rax,	rsi
    cmp       rax,	1
    jz        L4254
    cmp       rax,	2
    jz        L4255
    cmp       rax,	3
    jz        L4256
    cmp       rax,	4
    jz        L4257
    cmp       rax,	9
    jz        L4258
    cmp       rax,	5
    jz        L4259
    cmp       rax,	6
    jz        L4260
    cmp       rax,	122
    jz        L4261
    cmp       rax,	120
    jz        L4262
    cmp       rax,	121
    jz        L4263
    jmp       L4264
L4254:
    lea       rcx,	[L12616]
    call      mc_writenasm.asmstr
    mov       rax,	[rdi]
    mov       rcx,	[rax]
    call      mc_writenasm.asmstr
    mov       rax,	[rdi]
    mov       [mc_decls.currasmproc],	rax
    jmp       L4252
L4255:
    lea       rcx,	[L12617]
    call      mc_writenasm.asmstr
    xor       eax,	eax
    mov       [mc_decls.currasmproc],	rax
    jmp       L4252
L4256:
    mov       rcx,	59
    call      mc_writenasm.asmchar
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    jmp       L4252
L4257:
    mov       r15,	[rdi]
    movzx     rax,	word [rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4266
    cmp       rax,	4
    jz        L4267
    jmp       L4268
L4266:
    mov       rcx,	r15
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    jmp       L4265
L4267:
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    jmp       L4252
L4268:
    lea       rcx,	[L12618]
    lea       rdx,	[L12619]
    call      pc_api.merror
L4265:
    lea       rcx,	[L12620]
    call      mc_writenasm.asmstr
    mov       al,	[r15+81]
    test      al,	al
    jz        L4270
    mov       rax,	[r15]
    mov       [rbp + mc_writenasm.strmcl.$T1],	rax
    mov       rax,	[r15]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writenasm.strmcl.$T1]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4271
L4272:
    lea       rcx,	[L12621]
    call      mc_writenasm.asmstr
    mov       rax,	[r15]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    lea       rcx,	[L12622]
    call      mc_writenasm.asmstr
L4271:
L4270:
    jmp       L4252
L4258:
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12623]
    call      msys.m$print_setfmt
    mov       rcx,	[rdi]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      mc_writenasm.asmstr
    jmp       L4252
L4259:
    lea       rcx,	[L12624]
    call      mc_writenasm.asmstr
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12625]
    call      mc_writenasm.asmstr
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    jmp       L4252
L4260:
    mov       r15,	[rdi]
    lea       rcx,	[L12626]
    call      mc_writenasm.asmstr
    mov       rcx,	r15
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    lea       rcx,	[L12627]
    call      mc_writenasm.asmstr
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4275
L4274:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writenasm.strreg
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    jmp       L4273
L4275:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writenasm.strxreg
    mov       rcx,	rax
    call      mc_writenasm.asmstr
L4273:
    jmp       L4252
    jmp       L4253
L4261:
    lea       rcx,	[L12628]
    call      mc_writenasm.asmstr
    mov       al,	1
    mov       [mc_writenasm.currseg],	al
    jmp       L4252
L4262:
    lea       rcx,	[L12629]
    call      mc_writenasm.asmstr
    mov       al,	2
    mov       [mc_writenasm.currseg],	al
    jmp       L4252
L4263:
    lea       rcx,	[L12630]
    call      mc_writenasm.asmstr
    mov       al,	3
    mov       [mc_writenasm.currseg],	al
    jmp       L4252
L4264:
L4253:
    mov       rax,	rsi
    cmp       rax,	26
    jz        L4277
    cmp       rax,	58
    jz        L4278
    cmp       rax,	15
    jz        L4279
    cmp       rax,	38
    jz        L4280
    cmp       rax,	39
    jz        L4281
    cmp       rax,	40
    jz        L4282
    cmp       rax,	51
    jz        L4283
    cmp       rax,	34
    jz        L4284
    cmp       rax,	19
    jz        L4285
    cmp       rax,	18
    jz        L4286
    cmp       rax,	16
    jz        L4287
    cmp       rax,	123
    jz        L4288
    cmp       rax,	8
    jz        L4289
    jmp       L4290
L4277:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[L12631]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4276
L4278:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[L12632]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4276
L4279:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[L12633]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4276
L4280:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12634]
    call      strcpy
    jmp       L4276
L4281:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12635]
    call      strcpy
    jmp       L4276
L4282:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12636]
    call      strcpy
    jmp       L4276
L4283:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12637]
    call      strcpy
    jmp       L4276
L4284:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12638]
    call      strcpy
    jmp       L4276
L4285:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4292
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4292
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       r10,	[rbp + mc_writenasm.strmcl.mcl]
    mov       [r10+16],	rax
    mov       rsi,	11
L4292:
    jmp       L4290
    jmp       L4276
L4286:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4294
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4294
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12639]
    call      strcpy
    jmp       L4293
L4294:
    jmp       L4290
L4293:
    jmp       L4276
L4287:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4296
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4296
    mov       rsi,	17
L4296:
    jmp       L4290
    jmp       L4276
L4288:
    movzx     rax,	byte [mc_writenasm.currseg]
    cmp       rax,	3
    jnz       L4298
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12640]
    call      strcpy
    jmp       L4297
L4298:
    jmp       L4290
L4297:
    jmp       L4276
L4289:
    jmp       L4252
L4290:
    cmp       rsi,	151
    jle       L4300
    mov       rcx,	rsi
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	rax
    call      strcpy
    jmp       L4299
L4300:
    lea       rax,	[mc_decls.mclnames]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+2]
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	rax
    call      strcpy
L4299:
L4276:
    cmp       rsi,	119
    jnz       L4302
    mov       rax,	4
    jmp       L4301
L4302:
    mov       rax,	10
L4301:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	rax
    lea       r8,	[L12641]
    call      mlib.ipadstr
    lea       rcx,	[mc_writenasm.strmcl.str]
    lea       rdx,	[L12642]
    call      strcpy
    lea       rcx,	[mc_writenasm.strmcl.str]
    mov       rdx,	4
    lea       r8,	[L12643]
    call      mlib.ipadstr
    lea       rcx,	[mc_writenasm.strmcl.str]
    lea       rdx,	[rbp + mc_writenasm.strmcl.opcname]
    call      strcat
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      mc_writenasm.asmstr
    test      rdi,	rdi
    jz        L4304
    test      rbx,	rbx
    jz        L4304
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_writenasm.needsizeprefix
    mov       r13,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    lea       rcx,	[L12644]
    call      mc_writenasm.asmstr
    mov       rcx,	rbx
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    mov       al,	[rax+32]
    test      al,	al
    jz        L4306
    lea       rcx,	[L12645]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     rax,	byte [rax+32]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rax
    call      mc_writenasm.asmstr
L4306:
    jmp       L4303
L4304:
    test      rdi,	rdi
    jz        L4307
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    jz        L4307
    cmp       rsi,	21
    jnz       L4309
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rsi
    call      mc_writenasm.asmopnd
    jmp       L4308
L4309:
    mov       rcx,	rdi
    mov       rdx,	1
    mov       r8,	rsi
    call      mc_writenasm.asmopnd
L4308:
L4307:
L4303:
L4252:
;---------------
    add       rsp,	168
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.strmclstr
mc_writenasm.strmclstr:
;?>>
   %define R.m rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_init
    mov       rcx,	rdi
    call      mc_writenasm.strmcl
    mov       rax,	[pc_decls.pdest]
    mov       rax,	[rax]
L4310:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.mstropnd
mc_writenasm.mstropnd:
;?>>
   %define R.a rsi
   %define R.sizeprefix r12
   %define R.opcode r13
    %define mc_writenasm.mstropnd.str2 -128
   %define R.plus rdi
   %define R.offset rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	168
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    xor       eax,	eax
    lea       r10,	[mc_writenasm.mstropnd.str]
    mov       [r10],	al
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4313
    cmp       rax,	2
    jz        L4314
    cmp       rax,	3
    jz        L4315
    cmp       rax,	5
    jz        L4316
    jmp       L4317
L4313:
    movzx     rax,	word [rsi+8]
    and       rax,	31
    movzx     r10,	byte [rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writenasm.strreg
    jmp       L4311
L4314:
    cmp       r13,	119
    jnz       L4319
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L4319
    mov       rax,	[rsi]
    cmp       rax,	0
    jl        L4321
    cmp       rax,	9
    jg        L4321
    mov       rax,	[rsi]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4320
L4321:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[L12646]
    call      strcat
    mov       rax,	[rsi]
    mov       rcx,	rax
    lea       rdx,	[L12647]
    call      msys.strword
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
L4320:
    jmp       L4318
L4319:
    mov       rcx,	rsi
    call      mc_writenasm.strvalue
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
L4318:
    jmp       L4312
L4315:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jz        L4323
    cmp       rax,	2
    jz        L4324
    cmp       rax,	3
    jz        L4325
    jmp       L4326
L4323:
    mov       rax,	[rsi]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L4322
L4324:
    movq      XMM4,	[rsi]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.strreal
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L4322
L4325:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12648]
    call      msys.m$print_setfmt
    movq      XMM4,	[rsi]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
L4326:
L4322:
    movzx     rax,	word [rsi+8]
    and       rax,	31
    mov       rcx,	rax
    mov       rdx,	r12
    call      mc_writenasm.getsizeprefix
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[L12649]
    call      strcat
    lea       rax,	[L12650]
    mov       rdi,	rax
    mov       al,	[rsi+10]
    test      al,	al
    jz        L4328
    movzx     rax,	byte [rsi+10]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_writenasm.strreg
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[L12651]
    mov       rdi,	rax
L4328:
    mov       al,	[rsi+11]
    test      al,	al
    jz        L4330
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rdi
    call      strcat
    movzx     rax,	byte [rsi+11]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_writenasm.strreg
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[L12651]
    mov       rdi,	rax
    movzx     rax,	word [rsi+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jle       L4332
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[L12652]
    call      strcat
    movzx     rax,	word [rsi+8]
    shr       rax,	5
    and       rax,	15
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
L4332:
L4330:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4335
    cmp       rax,	6
    jz        L4335
    cmp       rax,	8
    jnz       L4334
L4335:
    mov       al,	[rdi]
    test      al,	al
    jz        L4337
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rdi
    call      strcat
L4337:
    mov       rcx,	rsi
    call      mc_writenasm.strvalue
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4333
L4334:
    movsxd    rax,	dword [rsi+12]
    mov       rbx,	rax
    test      rax,	rax
    jz        L4338
    lea       rcx,	[rbp + mc_writenasm.mstropnd.str2]
    call      msys.m$print_startstr
    mov       rcx,	rbx
    lea       rdx,	[L12653]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[rbp + mc_writenasm.mstropnd.str2]
    call      strcat
L4338:
L4333:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[L12654]
    call      strcat
    jmp       L4312
L4316:
    movzx     rax,	word [rsi+8]
    and       rax,	31
    movzx     r10,	byte [rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writenasm.strxreg
    jmp       L4311
L4317:
    call      msys.m$print_startcon
    lea       rcx,	[L12655]
    call      msys.m$print_str_nf
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[L12656]
    jmp       L4311
L4312:
    lea       rax,	[mc_writenasm.mstropnd.str]
L4311:
;---------------
    add       rsp,	168
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.strvalue
mc_writenasm.strvalue:
;?>>
   %define R.a r12
    %define mc_writenasm.strvalue.str2 -128
   %define R.def rdi
   %define R.value rbx
   %define R.offset rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
    mov       r12,	rcx
;---------------
    mov       rdi,	[r12]
    mov       rbx,	[r12]
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12657]
    call      strcpy
    movzx     rax,	word [r12+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4341
    cmp       rax,	1
    jz        L4342
    cmp       rax,	2
    jz        L4343
    cmp       rax,	3
    jz        L4344
    cmp       rax,	4
    jz        L4345
    cmp       rax,	7
    jz        L4346
    cmp       rax,	6
    jz        L4347
    cmp       rax,	8
    jz        L4348
    jmp       L4349
L4341:
    mov       rcx,	rdi
    call      mc_writenasm.getdispname
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
;mc_writenasm.strvalue.addoffset:
L4350:
    movsxd    rax,	dword [r12+12]
    mov       rsi,	rax
    test      rax,	rax
    jz        L4352
    lea       rcx,	[rbp + mc_writenasm.strvalue.str2]
    call      msys.m$print_startstr
    cmp       rsi,	0
    jle       L4354
    lea       rax,	[L12658]
    jmp       L4353
L4354:
    lea       rax,	[L12659]
L4353:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[rbp + mc_writenasm.strvalue.str2]
    call      strcat
L4352:
    jmp       L4340
L4342:
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4340
L4343:
    lea       rcx,	[mc_writenasm.strvalue.str]
    call      msys.m$print_startstr
    movq      XMM4,	[r12]
    movq      XMM0,	XMM4
    lea       rdx,	[L12660]
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L4340
L4344:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12661]
    call      strcat
    movq      XMM4,	[r12]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.strreal
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4340
L4345:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12662]
    call      strcat
    mov       rax,	[r12]
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12662]
    call      strcat
    jmp       L4340
L4346:
    mov       rax,	[r12]
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4340
L4347:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12663]
    call      strcat
    mov       rax,	[r12]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4350
L4348:
    mov       rax,	[r12]
    mov       rcx,	[mc_decls.currasmproc]
    mov       rdx,	rax
    call      mc_writenasm.gettempname
    jmp       L4339
L4349:
    lea       rcx,	[L12664]
    lea       rdx,	[L12665]
    call      pc_api.merror
L4340:
    lea       rax,	[mc_writenasm.strvalue.str]
L4339:
;---------------
    add       rsp,	160
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.asmopnd
mc_writenasm.asmopnd:
;?>>
   %define R.a rdi
   %define R.sizeprefix rbx
   %define R.opcode rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_writenasm.mstropnd
    mov       rcx,	rax
    call      mc_writenasm.asmstr
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.getxregname
mc_writenasm.getxregname:
;?>>
   %define R.reg rdi
    %define mc_writenasm.getxregname.size 32
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jnz       L4358
    lea       rax,	[L12666]
    jmp       L4356
L4358:
    lea       rcx,	[mc_writenasm.getxregname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12667]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[rdi-1]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rax,	[mc_writenasm.getxregname.str]
L4356:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.asmstr
mc_writenasm.asmstr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    mov       rdx,	rdi
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.asmchar
mc_writenasm.asmchar:
;?>>
   %define R.c rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    mov       rdx,	rdi
    call      mlib.gs_char
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.getdispname
mc_writenasm.getdispname:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       al,	[rdi+90]
    test      al,	al
    jz        L4363
    lea       rcx,	[mc_writenasm.getdispname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12668]
    call      msys.m$print_setfmt
    lea       rcx,	[L12669]
    call      msys.m$print_str_nf
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rax,	[mc_writenasm.getdispname.str]
    jmp       L4361
L4363:
    mov       al,	[pc_api.fpshortnames]
    test      al,	al
    jz        L4365
    mov       rax,	[rdi]
    jmp       L4361
L4365:
    mov       rcx,	rdi
    xor       edx,	edx
    call      pc_api.getfullname
L4361:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.gettempname
mc_writenasm.gettempname:
;?>>
   %define R.d rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	[pc_api.fpshortnames]
    test      al,	al
    jz        L4368
    lea       rcx,	[mc_writenasm.gettempname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12670]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L4367
L4368:
    lea       rcx,	[mc_writenasm.gettempname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12671]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L4367:
    lea       rax,	[mc_writenasm.gettempname.str]
L4366:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.strreg
mc_writenasm.strreg:
;?>>
   %define R.reg rcx
   %define R.size rdx
;?]]
;---------------
    lea       rax,	[mc_writenasm.nregnames]
    mov       r10,	rdx
    shl       r10,	7
    lea       rax,	[rax + r10-128]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8-8]
L4369:
;---------------
    ret       
;End 
;Proc mc_writenasm.strxreg
mc_writenasm.strxreg:
;?>>
   %define R.reg rbx
   %define R.size rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_writenasm.checkregvar
    mov       rdi,	rax
    cmp       rsi,	8
    jnz       L4372
    test      rdi,	rdi
    jz        L4372
    mov       rcx,	rdi
    call      mc_writenasm.getdispname
    jmp       L4371
L4372:
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mc_writenasm.getxregname
L4371:
L4370:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.needsizeprefix
mc_writenasm.needsizeprefix:
;?>>
   %define R.opcode rcx
   %define R.a rdx
   %define R.b r8
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	18
    jz        L4375
    cmp       rax,	19
    jz        L4375
    cmp       rax,	86
    jz        L4375
    cmp       rax,	87
    jz        L4375
    cmp       rax,	82
    jz        L4376
    cmp       rax,	83
    jz        L4376
    cmp       rax,	84
    jz        L4376
    cmp       rax,	85
    jz        L4376
    cmp       rax,	43
    jz        L4377
    cmp       rax,	45
    jz        L4377
    cmp       rax,	44
    jz        L4377
    jmp       L4378
L4375:
    mov       rax,	1
    jmp       L4373
L4376:
    mov       rax,	1
    jmp       L4373
L4377:
    movzx     rax,	word [rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4380
    mov       rax,	1
    jmp       L4373
L4380:
    xor       eax,	eax
    jmp       L4373
L4378:
L4374:
    movzx     rax,	word [rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4383
    movzx     rax,	word [rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4383
    movzx     rax,	word [r8+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4383
    movzx     rax,	word [r8+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4382
L4383:
    xor       eax,	eax
    jmp       L4373
L4382:
    mov       rax,	1
L4373:
;---------------
    ret       
;End 
;Proc mc_writenasm.getsizeprefix
mc_writenasm.getsizeprefix:
;?>>
   %define R.size rcx
   %define R.enable rdx
;?]]
;---------------
    test      rdx,	rdx
    jnz       L4386
    lea       rax,	[L12672]
    jmp       L4384
L4386:
    mov       rax,	rcx
    cmp       rax,	1
    jz        L4388
    cmp       rax,	2
    jz        L4389
    cmp       rax,	4
    jz        L4390
    cmp       rax,	8
    jz        L4391
    jmp       L4392
L4388:
    lea       rax,	[L12673]
    jmp       L4384
L4389:
    lea       rax,	[L12674]
    jmp       L4384
L4390:
    lea       rax,	[L12675]
    jmp       L4384
L4391:
    lea       rax,	[L12676]
    jmp       L4384
L4392:
L4387:
    lea       rax,	[L12677]
L4384:
;---------------
    ret       
;End 
;Proc mc_writenasm.checkregvar
mc_writenasm.checkregvar:
;?>>
    %define mc_writenasm.checkregvar.reg 16
    %define mc_writenasm.checkregvar.ispfloat 24
;?]]
;---------------
    xor       eax,	eax
L4393:
;---------------
    ret       
;End 
;Proc mc_writeexe.writeexe
mc_writeexe.writeexe:
;?>>
   %define R.outfile rdi
   %define R.dodll rbx
   %define R.entrypoint rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       al,	[pc_decls.exedone]
    test      al,	al
    jnz       L4394
L4396:
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_writeexe.genexe1
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_writeexe.genexe2
    mov       al,	1
    mov       [pc_decls.exedone],	al
L4394:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.genexe1
mc_writeexe.genexe1:
;?>>
   %define R.entrypoint r13
   %define R.outfile r14
    %define mc_writeexe.genexe1.dodll 80
   %define R.offset rdi
   %define R.codeaddr rbx
   %define R.offsetptr rsi
   %define R.pr r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
;---------------
    call      mc_writeexe.initsectiontable
    mov       rcx,	r14
    call      mlib.extractfile
    mov       [mc_writeexe.dllfilename],	rax
    mov       rax,	[rbp + mc_writeexe.genexe1.dodll]
    mov       [mc_writeexe.isdll],	rax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4399
    mov       rax,	268435456
    jmp       L4398
L4399:
    mov       rax,	4194304
L4398:
    mov       [mc_writeexe.imagebase],	rax
    mov       [mc_writeexe.userentrypoint],	r13
    call      mc_writeexe.loadlibs
    call      mc_writeexe.scanst
    call      mc_writeexe.getoffsets
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rcx,	rax
    call      mc_writeexe.relocdata
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rcx,	rax
    call      mc_writeexe.relocdata
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rbx,	rax
    mov       al,	[pc_api.phighmem]
    test      al,	al
    jz        L4401
    mov       r12,	[mc_decls.riplist]
    jmp       L4405
L4402:
    mov       eax,	[r12+8]
    lea       r10,	[rbx + rax]
    mov       rsi,	r10
    movsxd    rax,	dword [r12+12]
    mov       r10d,	[rsi]
    sub       r10,	[mc_writeexe.imagebase]
    mov       r11d,	[r12+8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      mc_writeexe.getripoffset
    mov       rdi,	rax
    mov       [rsi],	edi
    mov       r12,	[r12]
L4405:
    test      r12,	r12
    jnz       L4402
L4401:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.genexe2
mc_writeexe.genexe2:
;?>>
   %define R.outfile rbx
   %define R.dodll rsi
   %define R.i rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    call      mlib.extractfile
    mov       [mc_writeexe.dllfilename],	rax
    mov       [mc_writeexe.isdll],	rsi
    mov       rcx,	[mc_writeexe.filesize]
    call      mlib.pcm_allocz
    mov       [mc_writeexe.dataptr],	rax
    mov       [mc_writeexe.datastart],	rax
    call      mc_writeexe.writedosstub
    call      mc_writeexe.writepesig
    call      mc_writeexe.writefileheader
    call      mc_writeexe.writeoptheader
    mov       rdi,	1
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4409
L4407:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rdi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rcx,	rax
    call      mc_writeexe.writesectionheader
    inc       rdi
    cmp       rdi,	[mc_writeexe.nsections]
    jle       L4407
L4409:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rcx,	[rax+32]
    call      mc_writeexe.writepadding
    mov       rdi,	1
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4412
L4410:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rdi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rcx,	rax
    call      mc_writeexe.writesectiondata
    inc       rdi
    cmp       rdi,	[mc_writeexe.nsections]
    jle       L4410
L4412:
    movzx     rax,	byte [pc_decls.pverbose]
    cmp       rax,	2
    jnz       L4414
    call      msys.m$print_startcon
    lea       rcx,	[L12678]
    call      msys.m$print_str_nf
    mov       rax,	[mc_writeexe.dataptr]
    sub       rax,	[mc_writeexe.datastart]
    mov       rcx,	rax
    lea       rdx,	[L12679]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L4414:
    mov       rax,	[mc_writeexe.dataptr]
    sub       rax,	[mc_writeexe.datastart]
    mov       rcx,	rbx
    mov       rdx,	[mc_writeexe.datastart]
    mov       r8,	rax
    call      mlib.writefile
    test      rax,	rax
    jnz       L4416
    call      msys.m$print_startcon
    lea       rcx,	[L12680]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4416:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.loadlibs
mc_writeexe.loadlibs:
;?>>
   %define R.i rdi
   %define R.hinst rbx
    %define mc_writeexe.loadlibs.filename -304
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
;---------------
    mov       rdi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4420
L4418:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L4422
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      mwindows.os_getdllinst
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4424
    call      msys.m$print_startcon
    lea       rcx,	[L12681]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12682]
    call      mc_libmcl.axerror
L4424:
    mov       rax,	rbx
    lea       r10,	[mc_writeexe.libinsttable]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      mlib.pcm_copyheapstring
    lea       r10,	[mc_writeexe.libinstnames]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
L4422:
    inc       rdi
    cmp       rdi,	[pc_decls.nplibfiles]
    jle       L4418
L4420:
;---------------
    add       rsp,	336
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.initsectiontable
mc_writeexe.initsectiontable:
;?>>
    %define mc_writeexe.initsectiontable.$T2 -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    lea       rax,	[mc_writeexe.sectiontable]
    lea       r10,	[L12683]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	1
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_code]
    mov       [rax],	r10
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+40],	rax
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L4427
    call      msys.m$print_startcon
    lea       rcx,	[L12684]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       rcx,	rax
    lea       rdx,	[L12685]
    call      msys.m$print_i64
    lea       rcx,	[L12686]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    movzx     rax,	byte [pc_decls.pverbose]
    cmp       rax,	2
    jnz       L4429
    call      msys.m$print_startcon
    lea       rcx,	[L12687]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       rcx,	rax
    lea       rdx,	[L12688]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12689]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeexe.initsectiontable.$T2],	rax
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       r10,	[rbp + mc_writeexe.initsectiontable.$T2]
    add       r10,	rax
    mov       rcx,	r10
    lea       rdx,	[L12690]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12691]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_zdatalen]
    lea       rdx,	[L12692]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
L4429:
L4427:
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    test      rax,	rax
    jnz       L4431
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.addqword
L4431:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    lea       r10,	[L12693]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	2
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_idata]
    mov       [rax],	r10
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    lea       r10,	[mc_writeexe.sectiontable]
    lea       r10,	[r10+72]
    mov       [r10+40],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    lea       r10,	[r10+72]
    mov       [r10+24],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_nidatarelocs]
    mov       [rax+64],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_idatarelocs]
    mov       [rax+56],	r10
    mov       rax,	[mc_decls.ss_zdatalen]
    test      rax,	rax
    jnz       L4433
    mov       rax,	16
    mov       [mc_decls.ss_zdatalen],	rax
L4433:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    lea       r10,	[L12694]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	3
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	[mc_decls.ss_zdatalen]
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+24],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_ncoderelocs]
    mov       [rax+64],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_coderelocs]
    mov       [rax+56],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    lea       r10,	[L12695]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       r10,	5
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    xor       r10d,	r10d
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    xor       r10d,	r10d
    mov       [rax+24],	r10
    mov       rax,	4
    mov       [mc_writeexe.nsections],	rax
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mc_writeexe.extractlibname
mc_writeexe.extractlibname:
;?>>
   %define R.name r13
   %define R.libno r14
    %define mc_writeexe.extractlibname.moduleno 88
   %define R.s rdi
   %define R.name2 rbx
    %define mc_writeexe.extractlibname.str -256
   %define R.i rsi
   %define R.n r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    xor       rbx,	rbx
;mc_writeexe.extractlibname.reenter:
    mov       rdi,	r13
    xor       eax,	eax
    mov       [r14],	rax
    jmp       L4437
L4436:
    movzx     rax,	byte [rdi]
    cmp       rax,	46
    jnz       L4440
    mov       rax,	rdi
    sub       rax,	r13
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	r13
    mov       r8,	rax
    call      memcpy
    mov       rax,	rdi
    sub       rax,	r13
    xor       r10d,	r10d
    mov       [rbp + rax + mc_writeexe.extractlibname.str],	r10b
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    lea       rdx,	[L12696]
    call      strcat
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4443
L4441:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4445
    mov       [r14],	rsi
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-40]
    inc       qword [r10]
    test      rbx,	rbx
    jz        L4447
    mov       rax,	rbx
    jmp       L4446
L4447:
    lea       rax,	[rdi+1]
L4446:
    jmp       L4434
L4445:
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4441
L4443:
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	50
    jl        L4449
    lea       rcx,	[L12697]
    call      mc_libmcl.axerror
L4449:
    inc       qword [mc_writeexe.ndlls]
    mov       rax,	[mc_writeexe.ndlls]
    mov       [r14],	rax
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[r14]
    lea       r11,	[mc_writeexe.dlltable]
    mov       r15,	r10
    shl       r15,	4
    lea       r15,	[r15 + r15*2]
    lea       r11,	[r11 + r15-48]
    mov       [r11],	rax
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-48]
    mov       rax,	1
    mov       [r10+8],	rax
    test      rbx,	rbx
    jz        L4451
    mov       rax,	rbx
    jmp       L4450
L4451:
    lea       rax,	[rdi+1]
L4450:
    jmp       L4434
L4440:
    inc       rdi
L4437:
    mov       al,	[rdi]
    test      al,	al
    jnz       L4436
    mov       rsi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4455
L4452:
    lea       rax,	[mc_writeexe.libinsttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jz        L4457
    lea       rax,	[mc_writeexe.libinsttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	r13
    call      mwindows.os_getdllprocaddr
    test      rax,	rax
    jz        L4459
    mov       r12,	rsi
    jmp       L4454
L4459:
L4457:
    inc       rsi
    cmp       rsi,	[pc_decls.nplibfiles]
    jle       L4452
L4455:
    call      msys.m$print_startcon
    mov       rcx,	r13
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12698]
    call      mc_libmcl.axerror
L4454:
    lea       rax,	[mc_writeexe.libnotable]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       [r14],	rax
    test      rax,	rax
    jz        L4461
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-40]
    inc       qword [r10]
    mov       rax,	r13
    jmp       L4434
L4461:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    lea       rdx,	[L12699]
    call      strcat
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	50
    jl        L4463
    lea       rcx,	[L12700]
    call      mc_libmcl.axerror
L4463:
    inc       qword [mc_writeexe.ndlls]
    mov       rax,	[mc_writeexe.ndlls]
    mov       [r14],	rax
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[r14]
    lea       r11,	[mc_writeexe.dlltable]
    mov       r15,	r10
    shl       r15,	4
    lea       r15,	[r15 + r15*2]
    lea       r11,	[r11 + r15-48]
    mov       [r11],	rax
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-48]
    mov       rax,	1
    mov       [r10+8],	rax
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.libnotable]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    mov       rax,	r13
L4434:
;---------------
    add       rsp,	296
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.scanst
mc_writeexe.scanst:
;?>>
   %define R.i rdi
    %define mc_writeexe.scanst.libno -8
   %define R.d rbx
   %define R.name rsi
   %define R.basename r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4467
L4465:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rdi
    mov       rbx,	[rax + r10*8-8]
    mov       al,	[rbx+80]
    test      al,	al
    jz        L4469
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	3000
    jl        L4471
    lea       rcx,	[L12701]
    call      mc_libmcl.axerror
L4471:
    inc       qword [mc_writeexe.nimports]
    mov       rax,	[rbx]
    mov       rcx,	rax
    lea       rdx,	[rbp + mc_writeexe.scanst.libno]
    mov       r8,	1
    call      mc_writeexe.extractlibname
    mov       rsi,	rax
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.scanst.libno]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	rsi
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	rbx
    mov       [rax],	r10
    mov       ax,	[mc_writeexe.nimports]
    mov       [rbx+98],	ax
    jmp       L4468
L4469:
    mov       al,	[rbx+81]
    test      al,	al
    jz        L4472
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       r12,	rax
    mov       rax,	[mc_writeexe.userentrypoint]
    test      rax,	rax
    jz        L4474
    mov       rcx,	r12
    mov       rdx,	[mc_writeexe.userentrypoint]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4476
    mov       [mc_writeexe.stentrypoint],	rbx
L4476:
    jmp       L4473
L4474:
    mov       al,	[rbx+83]
    test      al,	al
    jz        L4478
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jnz       L4478
    mov       [mc_writeexe.stentrypoint],	rbx
L4478:
L4473:
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1000
    jl        L4480
    lea       rcx,	[L12702]
    call      mc_libmcl.axerror
L4480:
    inc       qword [mc_writeexe.nexports]
    lea       rax,	[mc_writeexe.exporttable]
    mov       r10,	[mc_writeexe.nexports]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	rbx
    mov       [rax],	r10
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    lea       r10,	[mc_writeexe.exporttable]
    mov       r11,	[mc_writeexe.nexports]
    shl       r11,	4
    lea       r10,	[r10 + r11-16]
    mov       [r10+8],	rax
L4472:
L4468:
    inc       rdi
    cmp       rdi,	[mc_decls.ss_nsymbols]
    jle       L4465
L4467:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.relocdata
mc_writeexe.relocdata:
;?>>
    %define mc_writeexe.relocdata.s 72
   %define R.u rdi
   %define R.r rbx
   %define R.p rsi
   %define R.p32 r12
   %define R.p64 r13
   %define R.d r14
   %define R.index r15
    %define mc_writeexe.relocdata.thunkoffset -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mc_writeexe.relocdata.s]
    mov       rax,	[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writeexe.relocdata.s]
    mov       rbx,	[rax+56]
    jmp       L4483
L4482:
    mov       rax,	[rbx+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       r14,	r10
    movsx     rax,	word [r14+98]
    mov       r15,	rax
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	r15
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+40]
    mov       [rbp + mc_writeexe.relocdata.thunkoffset],	rax
    mov       rax,	[rbx+8]
    cmp       rax,	4
    jz        L4486
    cmp       rax,	2
    jz        L4487
    cmp       rax,	1
    jz        L4487
    jmp       L4488
L4486:
    mov       al,	[r14+80]
    test      al,	al
    jnz       L4490
    lea       rcx,	[L12703]
    call      mc_libmcl.axerror
L4490:
    mov       rax,	[rbx+16]
    mov       r10,	[rbp + mc_writeexe.relocdata.thunkoffset]
    sub       r10,	rax
    sub       r10,	4
    mov       rax,	[rbx+16]
    mov       [rsi + rax],	r10d
    jmp       L4485
L4487:
    mov       al,	[r14+80]
    test      al,	al
    jz        L4492
    mov       rax,	[mc_writeexe.imagebase]
    add       rax,	[rbp + mc_writeexe.relocdata.thunkoffset]
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r10,	[r10+48]
    add       rax,	r10
    mov       r10,	[rbx+16]
    mov       [rsi + r10],	eax
    jmp       L4491
L4492:
    xor       rdi,	rdi
    movzx     rax,	byte [r14+94]
    cmp       rax,	3
    jz        L4494
    cmp       rax,	2
    jz        L4495
    cmp       rax,	1
    jz        L4496
    jmp       L4497
L4494:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       rdi,	rax
    jmp       L4493
L4495:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rdi,	rax
    jmp       L4493
L4496:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rdi,	rax
    jmp       L4493
L4497:
    call      msys.m$print_startcon
    mov       rcx,	[r14]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r14+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12704]
    call      mc_libmcl.axerror
L4493:
    mov       rax,	[rbx+16]
    lea       r10,	[rsi + rax]
    mov       r12,	r10
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jnz       L4499
    mov       eax,	[r12]
    mov       r10,	[rdi+48]
    add       rax,	r10
    add       rax,	[mc_writeexe.imagebase]
    mov       [r12],	eax
    jmp       L4498
L4499:
    mov       r13,	r12
    mov       rax,	[r13]
    mov       r10,	[rdi+48]
    add       rax,	r10
    add       rax,	[mc_writeexe.imagebase]
    mov       [r13],	rax
L4498:
L4491:
    jmp       L4485
L4488:
    call      msys.m$print_startcon
    mov       rax,	[rbx+8]
    lea       r10,	[mc_objdecls.relocnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12705]
    call      mc_libmcl.axerror
L4485:
    mov       rbx,	[rbx]
L4483:
    test      rbx,	rbx
    jnz       L4482
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getbaserelocs
mc_writeexe.getbaserelocs:
;?>>
   %define R.s r12
   %define R.r rdi
   %define R.p rbx
   %define R.d rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rax,	[r12]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rbx,	rax
    mov       rdi,	[r12+56]
    jmp       L4502
L4501:
    mov       rax,	[rdi+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jz        L4505
    cmp       rax,	1
    jnz       L4506
L4505:
    mov       al,	[rsi+80]
    test      al,	al
    jnz       L4507
L4508:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jz        L4509
L4510:
    mov       rax,	[rdi+8]
    mov       r10,	[r12+48]
    mov       r11,	[rdi+16]
    add       r10,	r11
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writeexe.newbasereloc
L4509:
L4507:
L4506:
L4504:
    mov       rdi,	[rdi]
L4502:
    test      rdi,	rdi
    jnz       L4501
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writerecordx
mc_writeexe.writerecordx:
;?>>
   %define R.r rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[mc_writeexe.dataptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [mc_writeexe.dataptr],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writedosstub
mc_writeexe.writedosstub:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[mc_writeexe.writedosstub.stubdata]
    mov       rdx,	128
    call      mc_writeexe.writerecordx
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_writeexe.writepesig
mc_writeexe.writepesig:
;?>>
;?]]
;---------------
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    mov       r10b,	80
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    mov       r10b,	69
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    xor       r10d,	r10d
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    xor       r10d,	r10d
    mov       [rax],	r10b
;---------------
    ret       
;End 
;Proc mc_writeexe.writepadding
mc_writeexe.writepadding:
;?>>
   %define R.offset rcx
;?]]
;---------------
    mov       rax,	[mc_writeexe.datastart]
    mov       r10,	rcx
    lea       rax,	[rax + r10]
    mov       [mc_writeexe.dataptr],	rax
;---------------
    ret       
;End 
;Proc mc_writeexe.writefileheader
mc_writeexe.writefileheader:
;?>>
    %define mc_writeexe.writefileheader.header -24
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    lea       rax,	[rbp + mc_writeexe.writefileheader.header]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    mov       ax,	34404
    mov       [rbp + mc_writeexe.writefileheader.header],	ax
    mov       ax,	[mc_writeexe.nsections]
    mov       [rbp + mc_writeexe.writefileheader.header+2],	ax
    mov       ax,	240
    mov       [rbp + mc_writeexe.writefileheader.header+16],	ax
    mov       ax,	559
    mov       [rbp + mc_writeexe.writefileheader.header+18],	ax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4517
    mov       ax,	8750
    mov       [rbp + mc_writeexe.writefileheader.header+18],	ax
L4517:
    lea       rcx,	[rbp + mc_writeexe.writefileheader.header]
    mov       rdx,	20
    call      mc_writeexe.writerecordx
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc mc_writeexe.writeoptheader
mc_writeexe.writeoptheader:
;?>>
    %define mc_writeexe.writeoptheader.header -240
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	272
;---------------
    lea       rax,	[rbp + mc_writeexe.writeoptheader.header]
    xor       r10d,	r10d
    mov       r11,	30
L12706:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12706
    mov       ax,	523
    mov       [rbp + mc_writeexe.writeoptheader.header],	ax
    mov       al,	1
    mov       [rbp + mc_writeexe.writeoptheader.header+2],	al
    xor       eax,	eax
    mov       [rbp + mc_writeexe.writeoptheader.header+3],	al
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+24]
    mov       [rbp + mc_writeexe.writeoptheader.header+4],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rax,	[rax+24]
    lea       r10,	[mc_writeexe.sectiontable]
    lea       r10,	[r10+216]
    mov       r10,	[r10+24]
    add       rax,	r10
    mov       [rbp + mc_writeexe.writeoptheader.header+8],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [rbp + mc_writeexe.writeoptheader.header+12],	eax
    mov       rax,	[mc_writeexe.stentrypoint]
    test      rax,	rax
    jnz       L4520
    mov       rax,	[mc_writeexe.stentrypoint2]
    mov       [mc_writeexe.stentrypoint],	rax
L4520:
    mov       rax,	[mc_writeexe.stentrypoint]
    test      rax,	rax
    jnz       L4522
    mov       rax,	[mc_writeexe.userentrypoint]
    test      rax,	rax
    jz        L4524
    call      msys.m$print_startcon
    mov       rcx,	[mc_writeexe.userentrypoint]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12707]
    call      mc_libmcl.axerror
    jmp       L4523
L4524:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jnz       L4526
    lea       rcx,	[L12708]
    call      mc_libmcl.axerror
L4526:
L4523:
    jmp       L4521
L4522:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+48]
    mov       r10,	[mc_writeexe.stentrypoint]
    movsxd    r10,	dword [r10+76]
    add       rax,	r10
    mov       [rbp + mc_writeexe.writeoptheader.header+16],	eax
L4521:
    mov       eax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+20],	eax
    mov       rax,	[mc_writeexe.imagebase]
    mov       [rbp + mc_writeexe.writeoptheader.header+24],	rax
    mov       eax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+32],	eax
    mov       eax,	512
    mov       [rbp + mc_writeexe.writeoptheader.header+36],	eax
    mov       ax,	4
    mov       [rbp + mc_writeexe.writeoptheader.header+40],	ax
    xor       eax,	eax
    mov       [rbp + mc_writeexe.writeoptheader.header+42],	ax
    mov       ax,	5
    mov       [rbp + mc_writeexe.writeoptheader.header+48],	ax
    mov       ax,	2
    mov       [rbp + mc_writeexe.writeoptheader.header+50],	ax
    mov       eax,	[mc_writeexe.imagesize]
    mov       [rbp + mc_writeexe.writeoptheader.header+56],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+32]
    mov       [rbp + mc_writeexe.writeoptheader.header+60],	eax
    mov       ax,	3
    mov       [rbp + mc_writeexe.writeoptheader.header+68],	ax
    mov       rax,	4194304
    mov       [rbp + mc_writeexe.writeoptheader.header+72],	rax
    mov       rax,	2097152
    mov       [rbp + mc_writeexe.writeoptheader.header+80],	rax
    mov       rax,	1048576
    mov       [rbp + mc_writeexe.writeoptheader.header+88],	rax
    mov       rax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+96],	rax
    mov       eax,	16
    mov       [rbp + mc_writeexe.writeoptheader.header+108],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+48]
    mov       [rbp + mc_writeexe.writeoptheader.header+120],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+40]
    sub       rax,	[mc_writeexe.exportdirvirtsize]
    sub       rax,	[mc_writeexe.blockdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+124],	eax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4528
    mov       ax,	64
    mov       [rbp + mc_writeexe.writeoptheader.header+70],	ax
    mov       eax,	[mc_writeexe.exportdirvirtaddr]
    mov       [rbp + mc_writeexe.writeoptheader.header+112],	eax
    mov       eax,	[mc_writeexe.exportdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+116],	eax
    mov       eax,	[mc_writeexe.blockdirvirtaddr]
    mov       [rbp + mc_writeexe.writeoptheader.header+152],	eax
    mov       eax,	[mc_writeexe.blockdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+156],	eax
L4528:
    mov       eax,	[mc_writeexe.fileiatoffset]
    mov       [rbp + mc_writeexe.writeoptheader.header+208],	eax
    mov       eax,	[mc_writeexe.fileiatsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+212],	eax
    lea       rcx,	[rbp + mc_writeexe.writeoptheader.header]
    mov       rdx,	240
    call      mc_writeexe.writerecordx
;---------------
    add       rsp,	272
    pop       rbp
    ret       
;End 
;Proc mc_writeexe.writesectionheader
mc_writeexe.writesectionheader:
;?>>
   %define R.s rbx
    %define mc_writeexe.writesectionheader.sheader -40
   %define R.aa rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       rbx,	rcx
;---------------
    lea       rax,	[rbp + mc_writeexe.writesectionheader.sheader]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       rax,	[rbx+8]
    lea       r10,	[rbp + mc_writeexe.writesectionheader.sheader]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcpy
    mov       rax,	[rbx+40]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+8],	eax
    mov       rax,	[rbx+48]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+12],	eax
    mov       rax,	[rbx+32]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+20],	eax
    mov       rax,	[rbx+24]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+16],	eax
    mov       rax,	[rbx+16]
    cmp       rax,	3
    jz        L4531
    cmp       rax,	2
    jz        L4532
    cmp       rax,	1
    jz        L4533
    cmp       rax,	5
    jz        L4534
    jmp       L4535
L4531:
    mov       rdi,	3226468480
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4530
L4532:
    mov       rdi,	3226468416
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4530
L4533:
    mov       rdi,	1615855648
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4530
L4534:
    mov       rdi,	3224371264
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
L4535:
L4530:
    lea       rcx,	[rbp + mc_writeexe.writesectionheader.sheader]
    mov       rdx,	40
    call      mc_writeexe.writerecordx
;---------------
    add       rsp,	80
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writesectiondata
mc_writeexe.writesectiondata:
;?>>
   %define R.s rdi
    %define mc_writeexe.writesectiondata.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+16]
    cmp       rax,	5
    jz        L4538
    cmp       rax,	3
    jz        L4539
    jmp       L4540
L4538:
    mov       rax,	[rdi+40]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writeexe.writerecordx
    mov       rax,	[rdi+24]
    mov       r10,	[rdi+40]
    cmp       rax,	r10
    jle       L4542
    mov       rax,	[rdi+24]
    mov       r10,	[rdi+40]
    sub       rax,	r10
    add       [mc_writeexe.dataptr],	rax
L4542:
    jmp       L4537
L4539:
    jmp       L4537
L4540:
    mov       rax,	[rdi+24]
    mov       [rbp + mc_writeexe.writesectiondata.$T1],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeexe.writesectiondata.$T1]
    call      mc_writeexe.writerecordx
L4537:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writeexporttable
mc_writeexe.writeexporttable:
;?>>
    %define mc_writeexe.writeexporttable.pstart 72
    %define mc_writeexe.writeexporttable.sortindex -16000
   %define R.phdr rdi
   %define R.paddrtable rbx
   %define R.pnametable rsi
   %define R.pordtable r12
   %define R.pdllname r13
   %define R.pnames r14
   %define R.addrtableoffset r15
    %define mc_writeexe.writeexporttable.nametableoffset -16008
    %define mc_writeexe.writeexporttable.ordtableoffset -16016
    %define mc_writeexe.writeexporttable.dllnameoffset -16024
    %define mc_writeexe.writeexporttable.namesoffset -16032
    %define mc_writeexe.writeexporttable.virtoffset -16040
    %define mc_writeexe.writeexporttable.sectionno -16048
    %define mc_writeexe.writeexporttable.d -16056
    %define mc_writeexe.writeexporttable.basename -16064
    %define mc_writeexe.writeexporttable.i -16072
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16104
    mov       [rbp+72],	rcx
;---------------
    mov       rdi,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       eax,	1602876664
    mov       [rdi+4],	eax
    mov       eax,	1
    mov       [rdi+16],	eax
    mov       eax,	[mc_writeexe.nexports]
    mov       [rdi+20],	eax
    mov       eax,	[mc_writeexe.nexports]
    mov       [rdi+24],	eax
    mov       r15,	40
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	2
    mov       r10,	r15
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.nametableoffset],	r10
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	2
    mov       r10,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.ordtableoffset],	r10
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	1
    mov       r10,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.dllnameoffset],	r10
    mov       rcx,	[mc_writeexe.dllfilename]
    call      strlen
    mov       r10,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       r10,	rax
    inc       r10
    mov       [rbp + mc_writeexe.writeexporttable.namesoffset],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+48]
    add       rax,	[mc_writeexe.exportdiroffset]
    mov       [rbp + mc_writeexe.writeexporttable.virtoffset],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	r15
    lea       rax,	[rax + r10]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    lea       rax,	[rax + r10]
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.namesoffset]
    lea       rax,	[rax + r10]
    mov       r14,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+12],	eax
    mov       rax,	r15
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+28],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+32],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+36],	eax
    mov       rcx,	r13
    mov       rdx,	[mc_writeexe.dllfilename]
    call      strcpy
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	2000
    jle       L4545
    lea       rcx,	[L12709]
    call      mc_libmcl.axerror
L4545:
    lea       rcx,	[rbp + mc_writeexe.writeexporttable.sortindex]
    call      mc_writeexe.sortexports
    mov       rax,	1
    mov       [rbp + mc_writeexe.writeexporttable.i],	rax
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4548
L4546:
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    mov       rax,	[rbp + rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       r10,	[mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       [rbp + mc_writeexe.writeexporttable.d],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    mov       rax,	[rbp + rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       r10,	[mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10+8]
    mov       [rbp + mc_writeexe.writeexporttable.basename],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.d]
    movzx     rax,	byte [rax+94]
    mov       rcx,	rax
    call      mc_writeexe.getsectionno
    mov       [rbp + mc_writeexe.writeexporttable.sectionno],	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strcpy
    mov       rax,	[rbp + mc_writeexe.writeexporttable.namesoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rsi],	eax
    add       rsi,	4
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    inc       rax
    add       [rbp + mc_writeexe.writeexporttable.namesoffset],	rax
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    inc       rax
    add       r14,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.d]
    movsxd    rax,	dword [rax+76]
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	[rbp + mc_writeexe.writeexporttable.sectionno]
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       r10,	[r10+48]
    add       rax,	r10
    mov       [rbx],	eax
    add       rbx,	4
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    dec       rax
    mov       [r12],	ax
    add       r12,	2
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    inc       rax
    mov       [rbp + mc_writeexe.writeexporttable.i],	rax
    cmp       rax,	[mc_writeexe.nexports]
    jle       L4546
L4548:
;---------------
    add       rsp,	16104
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getexporttablesize
mc_writeexe.getexporttablesize:
;?>>
   %define R.size rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rdi,	40
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	2
    add       rdi,	rax
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	2
    add       rdi,	rax
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	1
    add       rdi,	rax
    mov       rcx,	[mc_writeexe.dllfilename]
    call      strlen
    inc       rax
    add       rdi,	rax
    mov       rbx,	1
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4552
L4550:
    lea       rax,	[mc_writeexe.exporttable]
    mov       r10,	rbx
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       rax,	[rax]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      strlen
    inc       rax
    add       rdi,	rax
    inc       rbx
    cmp       rbx,	[mc_writeexe.nexports]
    jle       L4550
L4552:
    mov       rax,	rdi
L4549:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.newbasereloc
mc_writeexe.newbasereloc:
;?>>
   %define R.addr rbx
   %define R.reltype rsi
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi+8],	ebx
    mov       [rdi+12],	esi
    mov       rax,	[mc_writeexe.basereloclist]
    mov       [rdi],	rax
    mov       [mc_writeexe.basereloclist],	rdi
    inc       qword [mc_writeexe.nbaserelocs]
    mov       rax,	rbx
    cmp       [mc_writeexe.maxrelocaddr],	rax
    jge       L12710
    mov       [mc_writeexe.maxrelocaddr],	rax
L12710:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.scanbaserelocs
mc_writeexe.scanbaserelocs:
;?>>
   %define R.baseaddr rdi
   %define R.addr rbx
   %define R.nextblock rsi
   %define R.p r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	4096
    xor       eax,	eax
    mov       [mc_writeexe.nbaseblocks],	rax
L4555:
    lea       rax,	[rdi+4096]
    mov       rsi,	rax
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	500
    jl        L4559
    lea       rcx,	[L12711]
    call      mc_libmcl.axerror
L4559:
    inc       qword [mc_writeexe.nbaseblocks]
    mov       rax,	rdi
    lea       r10,	[mc_writeexe.blockbases]
    mov       r11,	[mc_writeexe.nbaseblocks]
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    lea       r10,	[mc_writeexe.blockcounts]
    mov       r11,	[mc_writeexe.nbaseblocks]
    mov       [r10 + r11*4-4],	eax
    mov       r12,	[mc_writeexe.basereloclist]
    jmp       L4561
L4560:
    mov       eax,	[r12+8]
    mov       rbx,	rax
    cmp       rbx,	rdi
    jl        L4564
    cmp       rbx,	rsi
    jge       L4564
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	[mc_writeexe.nbaseblocks]
    lea       rax,	[rax + r10*4-4]
    inc       dword [rax]
L4564:
    mov       r12,	[r12]
L4561:
    test      r12,	r12
    jnz       L4560
    mov       rdi,	rsi
    cmp       rdi,	[mc_writeexe.maxrelocaddr]
    jle       L4555
    mov       r13,	1
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	1
    jl        L4567
L4565:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r13
    mov       eax,	[rax + r10*4-4]
    test      eax,	eax
    jz        L4569
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4-4]
    and       eax,	1
    test      rax,	rax
    jz        L4571
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r13
    lea       rax,	[rax + r10*4-4]
    inc       dword [rax]
    lea       rax,	[mc_writeexe.blockpadding]
    mov       r10,	r13
    lea       rax,	[rax + r10-1]
    inc       byte [rax]
L4571:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4-4]
    shl       rax,	1
    add       rax,	8
    lea       r10,	[mc_writeexe.blockbytes]
    mov       r11,	r13
    mov       [r10 + r11*4-4],	eax
    lea       rax,	[mc_writeexe.blockbytes]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4-4]
    add       [mc_writeexe.basetablesize],	rax
L4569:
    inc       r13
    cmp       r13,	[mc_writeexe.nbaseblocks]
    jle       L4565
L4567:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writebasereloctable
mc_writeexe.writebasereloctable:
;?>>
   %define R.pstart rcx
   %define R.p32 rdi
   %define R.p16 rbx
   %define R.baseaddr rsi
   %define R.addr r12
   %define R.nextblock r13
   %define R.q r14
   %define R.i r15
    %define mc_writeexe.writebasereloctable.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8
;---------------
    mov       rdi,	rcx
    mov       r15,	1
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	1
    jl        L4575
L4573:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r15
    mov       eax,	[rax + r10*4-4]
    test      eax,	eax
    jz        L4577
    lea       rax,	[mc_writeexe.blockbases]
    mov       r10,	r15
    mov       rax,	[rax + r10*8-8]
    mov       [rdi],	eax
    add       rdi,	4
    lea       rax,	[mc_writeexe.blockbytes]
    mov       r10,	r15
    mov       eax,	[rax + r10*4-4]
    mov       [rdi],	eax
    add       rdi,	4
    mov       rbx,	rdi
    mov       r14,	[mc_writeexe.basereloclist]
    lea       rax,	[mc_writeexe.blockbases]
    mov       r10,	r15
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[rsi+4096]
    mov       r13,	rax
    jmp       L4579
L4578:
    mov       eax,	[r14+8]
    mov       r12,	rax
    cmp       r12,	rsi
    jl        L4582
    cmp       r12,	r13
    jge       L4582
    mov       rax,	r12
    sub       rax,	rsi
    mov       [rbp + mc_writeexe.writebasereloctable.$T1],	rax
    movsxd    rax,	dword [r14+12]
    cmp       rax,	2
    jnz       L4584
    mov       rax,	3
    jmp       L4583
L4584:
    mov       rax,	10
L4583:
    shl       rax,	12
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.$T1]
    add       r10,	rax
    mov       [rbx],	r10w
    add       rbx,	2
L4582:
    mov       r14,	[r14]
L4579:
    test      r14,	r14
    jnz       L4578
    lea       rax,	[mc_writeexe.blockpadding]
    mov       r10,	r15
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L4586
    mov       rax,	rbx
    add       rbx,	2
    xor       r10d,	r10d
    mov       [rax],	r10w
L4586:
    mov       rdi,	rbx
L4577:
    inc       r15
    cmp       r15,	[mc_writeexe.nbaseblocks]
    jle       L4573
L4575:
;---------------
    add       rsp,	8
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.sortexports
mc_writeexe.sortexports:
;?>>
   %define R.sortindex r14
   %define R.d rdi
   %define R.e rbx
   %define R.swapped rsi
   %define R.av_1 r12
   %define R.i r13
    %define mc_writeexe.sortexports.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
;---------------
    mov       r13,	1
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4590
L4588:
    mov       [r14 + r13*8-8],	r13
    inc       r13
    cmp       r13,	[mc_writeexe.nexports]
    jle       L4588
L4590:
L4591:
    xor       rsi,	rsi
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mc_writeexe.nexports]
    dec       rax
    mov       r12,	rax
    cmp       r12,	1
    jl        L4596
L4594:
    mov       rax,	[r14 + r13*8-8]
    lea       r10,	[mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       rdi,	r10
    mov       rax,	[r14 + r13*8]
    lea       r10,	[mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       rbx,	r10
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       [rbp + mc_writeexe.sortexports.$T1],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeexe.sortexports.$T1]
    call      strcmp
    movsxd    r10,	eax
    cmp       r10,	0
    jle       L4598
    mov       rsi,	1
    lea       rax,	[r14 + r13*8-8]
    lea       r10,	[r14 + r13*8]
    mov       r11,	[rax]
    mov       r9,	[r10]
    mov       [r10],	r11
    mov       [rax],	r9
L4598:
    inc       r13
    cmp       r13,	r12
    jle       L4594
L4596:
    test      rsi,	rsi
    jnz       L4591
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getsectionno
mc_writeexe.getsectionno:
;?>>
   %define R.segment rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	rdi
    cmp       rax,	3
    jz        L4601
    cmp       rax,	2
    jz        L4602
    cmp       rax,	1
    jz        L4603
    jmp       L4604
L4601:
    mov       rax,	3
    jmp       L4600
L4602:
    mov       rax,	2
    jmp       L4600
L4603:
    mov       rax,	1
    jmp       L4600
L4604:
    lea       rcx,	[L12712]
    call      mc_libmcl.axerror
    xor       eax,	eax
L4600:
L4599:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getoffsets
mc_writeexe.getoffsets:
;?>>
   %define R.fileoffset rdi
   %define R.imageoffset rbx
   %define R.i rsi
   %define R.diroffset r12
   %define R.impdirno r13
   %define R.hinttableoffset r14
    %define mc_writeexe.getoffsets.j -8
    %define mc_writeexe.getoffsets.codesize -16
    %define mc_writeexe.getoffsets.length -24
    %define mc_writeexe.getoffsets.thunkoffset -32
    %define mc_writeexe.getoffsets.offset -40
    %define mc_writeexe.getoffsets.dirstartoffset -48
    %define mc_writeexe.getoffsets.pcode -56
    %define mc_writeexe.getoffsets.pimpdir -64
    %define mc_writeexe.getoffsets.pdir -72
    %define mc_writeexe.getoffsets.paddr -80
    %define mc_writeexe.getoffsets.pname -88
    %define mc_writeexe.getoffsets.iatoffset -96
    %define mc_writeexe.getoffsets.phint -104
    %define mc_writeexe.getoffsets.pextra -112
    %define mc_writeexe.getoffsets.xxx -120
    %define mc_writeexe.getoffsets.av_1 -128
    %define mc_writeexe.getoffsets.thunkptr -136
    %define mc_writeexe.getoffsets.codebase -144
    %define mc_writeexe.getoffsets.thunkaddr -152
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
;---------------
    mov       rdi,	392
    mov       rax,	40
    imul      rax,	[mc_writeexe.nsections]
    add       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       rdi,	rax
    mov       rbx,	4096
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+40]
    mov       [rbp + mc_writeexe.getoffsets.codesize],	rax
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[rbp + mc_writeexe.getoffsets.codesize]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.pcode],	rax
    jmp       L4607
L4606:
    mov       rax,	[rbp + mc_writeexe.getoffsets.pcode]
    inc       qword [rbp + mc_writeexe.getoffsets.pcode]
    mov       r10b,	144
    mov       [rax],	r10b
    inc       qword [rbp + mc_writeexe.getoffsets.codesize]
L4607:
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    and       rax,	7
    jnz       L4606
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       [rbp + mc_writeexe.getoffsets.thunkoffset],	rax
    mov       rax,	[mc_writeexe.nimports]
    shl       rax,	3
    add       [rbp + mc_writeexe.getoffsets.codesize],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       [rax+40],	r10
    mov       rcx,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+24],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    sub       rax,	[rbp + mc_writeexe.getoffsets.thunkoffset]
    add       rax,	16
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	rax
    call      mc_genss.buffercheck
    mov       rsi,	1
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4611
L4609:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	3
    jz        L4613
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	rdi
    mov       [rax+32],	r10
L4613:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	3
    jz        L4615
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+40]
    mov       r10,	rdi
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       rdi,	rax
L4615:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	rbx
    mov       [rax+48],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	5
    jnz       L4617
    mov       r12,	rbx
    mov       r13,	rsi
L4617:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+40]
    mov       r10,	rbx
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	4096
    call      mlib.roundtoblock
    mov       rbx,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.nsections]
    jle       L4609
L4611:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4619
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rcx,	rax
    call      mc_writeexe.getbaserelocs
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rcx,	rax
    call      mc_writeexe.getbaserelocs
L4619:
    mov       rax,	[mc_writeexe.ndlls]
    inc       rax
    shl       rax,	2
    lea       rax,	[rax + rax*4]
    add       r12,	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4622
L4620:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    inc       rax
    shl       rax,	3
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4620
L4622:
    mov       [mc_writeexe.fileiatoffset],	r12
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4625
L4623:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+24],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    inc       rax
    shl       rax,	3
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4623
L4625:
    mov       rax,	r12
    sub       rax,	[mc_writeexe.fileiatoffset]
    mov       [mc_writeexe.fileiatsize],	rax
    mov       r14,	r12
    mov       rsi,	1
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4628
L4626:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    call      strlen
    add       rax,	3
    mov       [rbp + mc_writeexe.getoffsets.length],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    and       rax,	1
    jz        L4630
    inc       qword [rbp + mc_writeexe.getoffsets.length]
L4630:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	r12
    mov       [rax+24],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.nimports]
    jle       L4626
L4628:
    mov       rcx,	r12
    mov       rdx,	4
    call      mlib.roundtoblock
    mov       r12,	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4633
L4631:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      strlen
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.length],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    and       rax,	1
    jz        L4635
    inc       qword [rbp + mc_writeexe.getoffsets.length]
L4635:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    shl       rax,	2
    add       r12,	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+32],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4631
L4633:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	r13
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+48]
    mov       [rbp + mc_writeexe.getoffsets.dirstartoffset],	rax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4637
    mov       [mc_writeexe.exportdirvirtaddr],	r12
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [mc_writeexe.exportdiroffset],	rax
    call      mc_writeexe.getexporttablesize
    mov       [mc_writeexe.exportdirvirtsize],	rax
    mov       rax,	[mc_writeexe.exportdirvirtsize]
    add       r12,	rax
    call      mc_writeexe.scanbaserelocs
    mov       [mc_writeexe.blockdirvirtaddr],	r12
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [mc_writeexe.blockdiroffset],	rax
    mov       rax,	[mc_writeexe.basetablesize]
    mov       [mc_writeexe.blockdirvirtsize],	rax
    mov       rax,	[mc_writeexe.blockdirvirtsize]
    add       r12,	rax
L4637:
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rbp + mc_writeexe.getoffsets.offset],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	r13
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rbp + mc_writeexe.getoffsets.offset]
    mov       [rax+40],	r10
    mov       rcx,	[rbp + mc_writeexe.getoffsets.offset]
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	r13
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       [r10+24],	rax
    mov       rax,	rdi
    add       rax,	[rbp + mc_writeexe.getoffsets.offset]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [mc_writeexe.filesize],	rax
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       r10,	rbx
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	4096
    call      mlib.roundtoblock
    mov       [mc_writeexe.imagesize],	rax
    mov       rcx,	[rbp + mc_writeexe.getoffsets.offset]
    call      mlib.pcm_allocz
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	r13
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       [r10],	rax
    mov       [rbp + mc_writeexe.getoffsets.pimpdir],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       [rbp + mc_writeexe.getoffsets.pdir],	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4640
L4638:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+16]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10],	eax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10+16],	eax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+32]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10+12],	eax
    add       qword [rbp + mc_writeexe.getoffsets.pdir],	20
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+24]
    mov       [rbp + mc_writeexe.getoffsets.iatoffset],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[rbp + mc_writeexe.getoffsets.iatoffset]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.paddr],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+16]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.pname],	r10
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4643
L4641:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+8]
    cmp       rax,	rsi
    jnz       L4645
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.paddr]
    mov       [r10],	rax
    mov       r10,	[rbp + mc_writeexe.getoffsets.pname]
    mov       [r10],	rax
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.iatoffset]
    mov       [rax+32],	r10
    mov       rax,	8
    add       [rbp + mc_writeexe.getoffsets.iatoffset],	rax
    add       qword [rbp + mc_writeexe.getoffsets.pname],	8
    add       qword [rbp + mc_writeexe.getoffsets.paddr],	8
L4645:
    mov       rax,	[rbp + mc_writeexe.getoffsets.j]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    cmp       rax,	[mc_writeexe.nimports]
    jle       L4641
L4643:
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4638
L4640:
    mov       rsi,	1
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4648
L4646:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.phint],	r10
    add       qword [rbp + mc_writeexe.getoffsets.phint],	2
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+16]
    mov       rcx,	[rbp + mc_writeexe.getoffsets.phint]
    mov       rdx,	rax
    call      strcpy
    inc       rsi
    cmp       rsi,	[mc_writeexe.nimports]
    jle       L4646
L4648:
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rbp + mc_writeexe.getoffsets.xxx],	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4651
L4649:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+40]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.pextra],	r10
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    mov       [rbp + mc_writeexe.getoffsets.av_1],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.av_1]
    cmp       rax,	1
    jl        L4654
L4652:
    mov       eax,	[rbp + mc_writeexe.getoffsets.xxx]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pextra]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.pextra],	4
    mov       rax,	[rbp + mc_writeexe.getoffsets.j]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    cmp       rax,	[rbp + mc_writeexe.getoffsets.av_1]
    jle       L4652
L4654:
    mov       rax,	20
    add       [rbp + mc_writeexe.getoffsets.xxx],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+32]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.phint],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mc_writeexe.getoffsets.phint]
    mov       rdx,	rax
    call      strcpy
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4649
L4651:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4656
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[mc_writeexe.exportdiroffset]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    call      mc_writeexe.writeexporttable
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[mc_writeexe.blockdiroffset]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    call      mc_writeexe.writebasereloctable
L4656:
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[rbp + mc_writeexe.getoffsets.thunkoffset]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.thunkptr],	rax
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.codebase],	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4659
L4657:
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    sub       rax,	[rbp + mc_writeexe.getoffsets.codebase]
    lea       r10,	[mc_writeexe.importtable]
    mov       r11,	rsi
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11]
    mov       [r10+40],	rax
    movzx     rax,	byte [pc_api.phighmem]
    test      rax,	rax
    jnz       L4661
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	36
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	37
    mov       [rax],	r10b
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+32]
    mov       r10,	[mc_writeexe.imagebase]
    add       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.thunkaddr],	r10
    mov       eax,	[rbp + mc_writeexe.getoffsets.thunkaddr]
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.thunkptr],	4
    jmp       L4660
L4661:
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	37
    mov       [rax],	r10b
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+32]
    mov       r10,	[mc_writeexe.imagebase]
    add       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.thunkaddr],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkaddr]
    sub       rax,	[mc_writeexe.imagebase]
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    sub       r10,	[rbp + mc_writeexe.getoffsets.codebase]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_writeexe.getripoffset
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.thunkptr],	4
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	144
    mov       [rax],	r10b
L4660:
    inc       rsi
    cmp       rsi,	[mc_writeexe.nimports]
    jle       L4657
L4659:
;---------------
    add       rsp,	192
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getripoffset
mc_writeexe.getripoffset:
;?>>
   %define R.addr rcx
   %define R.dest rdx
   %define R.extra r8
;?]]
;---------------
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+48]
    add       rcx,	rax
    lea       rax,	[rcx+4]
    mov       r10,	rdx
    sub       r10,	rax
    sub       r10,	r8
    mov       rax,	r10
L4662:
;---------------
    ret       
;End 
;Proc mc_writeobj.writecoff
mc_writeobj.writecoff:
;?>>
   %define R.outfile rbx
    %define mc_writeobj.writecoff.header -24
    %define mc_writeobj.writecoff.zsection -64
    %define mc_writeobj.writecoff.isection -104
    %define mc_writeobj.writecoff.csection -144
   %define R.offset rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	176
    mov       rbx,	rcx
;---------------
    mov       al,	[pc_decls.objdone]
    test      al,	al
    jnz       L4663
L4665:
    lea       rax,	[rbp + mc_writeobj.writecoff.header]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    lea       rax,	[rbp + mc_writeobj.writecoff.zsection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    lea       rax,	[rbp + mc_writeobj.writecoff.isection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    lea       rax,	[rbp + mc_writeobj.writecoff.csection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       ax,	34404
    mov       [rbp + mc_writeobj.writecoff.header],	ax
    mov       ax,	3
    mov       [rbp + mc_writeobj.writecoff.header+2],	ax
    lea       rax,	[rbp + mc_writeobj.writecoff.zsection]
    mov       rcx,	rax
    lea       rdx,	[L12713]
    call      strcpy
    mov       eax,	[mc_decls.ss_zdatalen]
    mov       [rbp + mc_writeobj.writecoff.zsection+16],	eax
    mov       eax,	3225419904
    mov       [rbp + mc_writeobj.writecoff.zsection+36],	eax
    mov       rax,	[mc_decls.ss_nidatarelocs]
    cmp       rax,	65536
    jge       L4668
    mov       rax,	[mc_decls.ss_ncoderelocs]
    cmp       rax,	65536
    jl        L4667
L4668:
    lea       rcx,	[L12714]
    call      mc_libmcl.axerror
L4667:
    lea       rax,	[rbp + mc_writeobj.writecoff.isection]
    mov       rcx,	rax
    lea       rdx,	[L12715]
    call      strcpy
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writecoff.isection+16],	eax
    mov       ax,	[mc_decls.ss_nidatarelocs]
    mov       [rbp + mc_writeobj.writecoff.isection+32],	ax
    mov       eax,	3226468416
    mov       [rbp + mc_writeobj.writecoff.isection+36],	eax
    lea       rax,	[rbp + mc_writeobj.writecoff.csection]
    mov       rcx,	rax
    lea       rdx,	[L12716]
    call      strcpy
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writecoff.csection+16],	eax
    mov       ax,	[mc_decls.ss_ncoderelocs]
    mov       [rbp + mc_writeobj.writecoff.csection+32],	ax
    mov       eax,	1615855648
    mov       [rbp + mc_writeobj.writecoff.csection+36],	eax
    mov       rcx,	rbx
    call      mc_writeobj.initsymboltable
    call      mc_writeobj.convertsymboltable
    mov       rdi,	20
    mov       rax,	120
    add       rdi,	rax
    mov       ax,	[rbp + mc_writeobj.writecoff.isection+32]
    test      ax,	ax
    jz        L4670
    mov       [rbp + mc_writeobj.writecoff.isection+24],	edi
    movzx     rax,	word [rbp + mc_writeobj.writecoff.isection+32]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rdi,	rax
L4670:
    mov       ax,	[rbp + mc_writeobj.writecoff.csection+32]
    test      ax,	ax
    jz        L4672
    mov       [rbp + mc_writeobj.writecoff.csection+24],	edi
    movzx     rax,	word [rbp + mc_writeobj.writecoff.csection+32]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rdi,	rax
L4672:
    mov       [rbp + mc_writeobj.writecoff.isection+20],	edi
    mov       eax,	[rbp + mc_writeobj.writecoff.isection+16]
    add       rdi,	rax
    mov       [rbp + mc_writeobj.writecoff.csection+20],	edi
    mov       eax,	[rbp + mc_writeobj.writecoff.csection+16]
    add       rdi,	rax
    mov       [rbp + mc_writeobj.writecoff.header+8],	edi
    mov       rax,	[mc_writeobj.nsymbols]
    shl       rax,	1
    lea       rax,	[rax + rax*8]
    add       rdi,	rax
    mov       eax,	[mc_writeobj.nsymbols]
    mov       [rbp + mc_writeobj.writecoff.header+12],	eax
    mov       rax,	[mc_writeobj.nextstringoffset]
    add       rdi,	rax
    mov       rcx,	rdi
    call      malloc
    mov       [mc_writeobj.dataptr],	rax
    mov       [mc_writeobj.datastart],	rax
    lea       rcx,	[rbp + mc_writeobj.writecoff.header]
    mov       rdx,	20
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.zsection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.isection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.csection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    mov       rcx,	[mc_decls.ss_idatarelocs]
    mov       rdx,	[mc_decls.ss_nidatarelocs]
    call      mc_writeobj.writerelocs
    mov       rcx,	[mc_decls.ss_coderelocs]
    mov       rdx,	[mc_decls.ss_ncoderelocs]
    call      mc_writeobj.writerelocs
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_writeobj.writedata
    mov       rcx,	[mc_decls.ss_code]
    call      mc_writeobj.writedata
    call      mc_writeobj.writesymboltable
    call      mc_writeobj.writestringtable
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L4674
    call      msys.m$print_startcon
    lea       rcx,	[L12717]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4674:
    mov       rax,	[mc_writeobj.dataptr]
    sub       rax,	[mc_writeobj.datastart]
    mov       rcx,	rbx
    mov       rdx,	[mc_writeobj.datastart]
    mov       r8,	rax
    call      mlib.writefile
    mov       al,	1
    mov       [pc_decls.objdone],	al
L4663:
;---------------
    add       rsp,	176
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writerecord
mc_writeobj.writerecord:
;?>>
   %define R.r rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [mc_writeobj.dataptr],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writerelocs
mc_writeobj.writerelocs:
;?>>
   %define R.r rbx
   %define R.nrelocs rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rsi,	rsi
    jnz       L4678
    jmp       L4676
L4678:
    jmp       L4680
L4679:
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jz        L4683
    cmp       rax,	1
    jnz       L4684
L4683:
    mov       rax,	[rbx+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    movzx     rax,	byte [rdi+94]
    cmp       rax,	3
    jz        L4686
    cmp       rax,	2
    jz        L4687
    cmp       rax,	1
    jz        L4688
    test      rax,	rax
    jz        L4689
    jmp       L4690
L4686:
    mov       eax,	2
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4685
L4687:
    mov       eax,	4
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4685
L4688:
    mov       eax,	6
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4685
L4689:
    mov       rax,	[rbx+24]
    add       rax,	[mc_writeobj.stoffset]
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4685
L4690:
    lea       rcx,	[L12718]
    call      mc_libmcl.axerror
L4685:
    jmp       L4682
L4684:
    mov       rax,	[rbx+24]
    add       rax,	[mc_writeobj.stoffset]
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
L4682:
    mov       rax,	[rbx+8]
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+8],	ax
    movzx     rax,	byte [pc_api.phighmem]
    test      rax,	rax
    jz        L4692
    cmp       rax,	2
    jz        L4693
    jmp       L4694
L4692:
    jmp       L4691
L4693:
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jnz       L4696
    mov       ax,	4
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+8],	ax
    mov       rax,	4
    mov       [rbx+8],	rax
L4696:
    jmp       L4691
L4694:
    lea       rcx,	[L12719]
    call      mc_libmcl.axerror
L4691:
    mov       rax,	[rbx+16]
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10],	eax
    mov       rcx,	[mc_writeobj.dataptr]
    lea       rdx,	[mc_writeobj.writerelocs.s]
    mov       r8,	10
    call      memcpy
    add       qword [mc_writeobj.dataptr],	10
    mov       rbx,	[rbx]
L4680:
    test      rbx,	rbx
    jnz       L4679
L4676:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writedata
mc_writeobj.writedata:
;?>>
   %define R.data rdi
    %define mc_writeobj.writedata.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writedata.$T1],	rax
    mov       rcx,	rdi
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	rax
    mov       r8,	[rbp + mc_writeobj.writedata.$T1]
    call      memcpy
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    add       [mc_writeobj.dataptr],	rax
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writesymboltable
mc_writeobj.writesymboltable:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_writeobj.nsymbols]
    cmp       rax,	1
    jl        L4701
L4699:
    lea       rax,	[mc_writeobj.symboltable]
    mov       r10,	rdi
    shl       r10,	1
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	18
    call      mc_writeobj.writerecord
    inc       rdi
    cmp       rdi,	[mc_writeobj.nsymbols]
    jle       L4699
L4701:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writestringtable
mc_writeobj.writestringtable:
;?>>
   %define R.p rdi
   %define R.i rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	[mc_writeobj.dataptr]
    mov       eax,	[mc_writeobj.nextstringoffset]
    mov       [rdi],	eax
    add       qword [mc_writeobj.dataptr],	4
    mov       rbx,	1
    mov       rax,	[mc_writeobj.nstrings]
    cmp       rax,	1
    jl        L4705
L4703:
    lea       rax,	[mc_writeobj.stringlengths]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    inc       rax
    mov       rsi,	rax
    lea       rax,	[mc_writeobj.stringtable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	rax
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rsi
    add       [mc_writeobj.dataptr],	rax
    inc       rbx
    cmp       rbx,	[mc_writeobj.nstrings]
    jle       L4703
L4705:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.makesymbol
mc_writeobj.makesymbol:
;?>>
   %define R.name rbx
   %define R.value rsi
   %define R.sectionno r12
   %define R.symtype r13
    %define mc_writeobj.makesymbol.storage 88
    %define mc_writeobj.makesymbol.naux 96
   %define R.namelen rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	rbx
    call      strlen
    mov       rdi,	rax
    cmp       rdi,	8
    jge       L4708
    lea       rax,	[mc_writeobj.makesymbol.r]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      strcpy
    jmp       L4707
L4708:
    cmp       rdi,	8
    jnz       L4709
    lea       rax,	[mc_writeobj.makesymbol.r]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      memcpy
    jmp       L4707
L4709:
    xor       eax,	eax
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10],	eax
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mc_writeobj.addstringentry
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+4],	eax
L4707:
    mov       eax,	esi
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+8],	eax
    mov       ax,	r12w
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+12],	ax
    mov       ax,	r13w
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+14],	ax
    mov       al,	[rbp + mc_writeobj.makesymbol.storage]
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+16],	al
    mov       al,	[rbp + mc_writeobj.makesymbol.naux]
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+17],	al
    lea       rax,	[mc_writeobj.makesymbol.r]
L4706:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.addsymbol
mc_writeobj.addsymbol:
;?>>
   %define R.r rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_writeobj.nsymbols]
    cmp       rax,	13000
    jl        L4712
    lea       rcx,	[L12720]
    call      mc_libmcl.axerror
L4712:
    inc       qword [mc_writeobj.nsymbols]
    mov       rax,	[mc_writeobj.nsymbols]
    lea       r10,	[mc_writeobj.symboltable]
    mov       r11,	rax
    shl       r11,	1
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	18
    call      memcpy
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.initsymboltable
mc_writeobj.initsymboltable:
;?>>
   %define R.filename rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    xor       eax,	eax
    mov       [mc_writeobj.nsymbols],	rax
    push      1
    push      103
    lea       rcx,	[L12721]
    xor       edx,	edx
    mov       r8,	-2
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	rdi
    call      mc_writeobj.strtoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[L12722]
    xor       edx,	edx
    mov       r8,	1
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    xor       ecx,	ecx
    xor       edx,	edx
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[L12723]
    xor       edx,	edx
    mov       r8,	2
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	[mc_decls.ss_nidatarelocs]
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[L12724]
    xor       edx,	edx
    mov       r8,	3
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[mc_decls.ss_ncoderelocs]
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.strtoaux
mc_writeobj.strtoaux:
;?>>
   %define R.s rsi
   %define R.p rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[mc_writeobj.strtoaux.r]
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	18
    call      memset
    xor       rbx,	rbx
    jmp       L4716
L4715:
    mov       rax,	rsi
    inc       rsi
    mov       al,	[rax]
    mov       r10,	rdi
    inc       rdi
    mov       [r10],	al
    inc       rbx
L4716:
    movzx     rax,	byte [rsi]
    test      rax,	rax
    jz        L4718
    cmp       rbx,	18
    jl        L4715
L4718:
    lea       rax,	[mc_writeobj.strtoaux.r]
L4714:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.sectiontoaux
mc_writeobj.sectiontoaux:
;?>>
   %define R.data rdi
   %define R.nrelocs rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[mc_writeobj.sectiontoaux.r]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10w
    test      rdi,	rdi
    jnz       L4721
    mov       eax,	[mc_decls.ss_zdatalen]
    lea       r10,	[mc_writeobj.sectiontoaux.r]
    mov       [r10],	eax
    jmp       L4720
L4721:
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    lea       r10,	[mc_writeobj.sectiontoaux.r]
    mov       [r10],	eax
L4720:
    mov       ax,	bx
    lea       r10,	[mc_writeobj.sectiontoaux.r]
    mov       [r10+4],	ax
    lea       rax,	[mc_writeobj.sectiontoaux.r]
L4719:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.addstringentry
mc_writeobj.addstringentry:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.offset rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	[mc_writeobj.nextstringoffset]
    mov       rax,	[mc_writeobj.nstrings]
    cmp       rax,	5000
    jle       L4724
    lea       rcx,	[L12725]
    call      mc_libmcl.axerror
L4724:
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    inc       qword [mc_writeobj.nstrings]
    mov       r10,	[mc_writeobj.nstrings]
    lea       r11,	[mc_writeobj.stringtable]
    mov       [r11 + r10*8-8],	rax
    mov       rax,	rsi
    lea       r10,	[mc_writeobj.stringlengths]
    mov       r11,	[mc_writeobj.nstrings]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[rsi+1]
    add       [mc_writeobj.nextstringoffset],	rax
    mov       rax,	rdi
L4722:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.convertsymboltable
mc_writeobj.convertsymboltable:
;?>>
   %define R.s rdi
   %define R.name rbx
   %define R.i rsi
   %define R.sect r12
   %define R.scope r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mc_writeobj.nsymbols]
    dec       rax
    mov       [mc_writeobj.stoffset],	rax
    xor       eax,	eax
    mov       [mc_writeobj.nstrings],	rax
    mov       rax,	4
    mov       [mc_writeobj.nextstringoffset],	rax
    mov       rsi,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4728
L4726:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8-8]
    mov       rbx,	[rdi]
    movzx     rax,	byte [rdi+94]
    cmp       rax,	3
    jz        L4730
    cmp       rax,	2
    jz        L4731
    cmp       rax,	1
    jz        L4732
    jmp       L4733
L4730:
    mov       r12,	1
    jmp       L4729
L4731:
    mov       r12,	2
    jmp       L4729
L4732:
    mov       r12,	3
    jmp       L4729
L4733:
    xor       r12,	r12
L4729:
    mov       al,	[rdi+80]
    test      al,	al
    jz        L4735
    xor       r12,	r12
L4735:
    xor       r13,	r13
    mov       al,	[rdi+80]
    test      al,	al
    jnz       L4738
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4737
L4738:
    mov       r13,	2
    jmp       L4736
L4737:
    mov       r13,	3
L4736:
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4740
    mov       rcx,	rbx
    call      pc_api.getbasename
    mov       rbx,	rax
L4740:
    push      0
    mov       rax,	r13
    push      rax
    movsxd    rax,	dword [rdi+76]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    inc       rsi
    cmp       rsi,	[mc_decls.ss_nsymbols]
    jle       L4726
L4728:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writess_dummy.writessdata
mc_writess_dummy.writessdata:
;?>>
    %define mc_writess_dummy.writessdata.fexe 16
;?]]
;---------------
    xor       eax,	eax
L4741:
;---------------
    ret       
;End 
;Proc mx_run.writememlib
mx_run.writememlib:
;?>>
   %define R.filename r14
   %define R.plib rdi
   %define R.k rbx
    %define mx_run.writememlib.lib -216
   %define R.ndlls rsi
   %define R.nlibs r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	256
    mov       r14,	rcx
;---------------
    lea       rax,	[rbp + mx_run.writememlib.lib]
    xor       r10d,	r10d
    mov       r11,	27
L12726:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12726
    mov       rcx,	[mc_decls.ss_zdatalen]
    mov       rdx,	8
    call      mlib.roundtoblock
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	8
    mov       r8,	144
    call      mx_run.roundsegment
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mx_run.roundsegment
    lea       rax,	[L12727]
    mov       [rbp + mx_run.writememlib.lib],	rax
    mov       [rbp + mx_run.writememlib.lib+184],	r14
    mov       rcx,	r14
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_run.writememlib.lib+192],	rax
    mov       rax,	1
    mov       [rbp + mx_run.writememlib.lib+208],	rax
    call      mx_run.countsymbols
    lea       rcx,	[rbp + mx_run.writememlib.lib]
    call      mx_run.writerelocs
    mov       rax,	[mc_decls.ss_zdatalen]
    mov       [rbp + mx_run.writememlib.lib+24],	rax
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.writememlib.lib+8],	rax
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.writememlib.lib+16],	rax
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mx_run.writememlib.lib+72],	rax
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mx_run.writememlib.lib+80],	rax
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    mov       r13,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4745
L4743:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L4747
    inc       rsi
L4747:
    inc       r13
    cmp       r13,	[pc_decls.nplibfiles]
    jle       L4743
L4745:
    mov       [rbp + mx_run.writememlib.lib+40],	rsi
    mov       [rbp + mx_run.writememlib.lib+48],	r12
    mov       rax,	8
    imul      rax,	rsi
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_run.writememlib.lib+96],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_run.writememlib.lib+104],	rax
    xor       rbx,	rbx
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4750
L4748:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L4752
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    mov       r10,	[rbp + mx_run.writememlib.lib+96]
    inc       rbx
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
L4752:
    inc       r13
    cmp       r13,	[pc_decls.nplibfiles]
    jle       L4748
L4750:
    lea       rcx,	[rbp + mx_run.writememlib.lib]
    call      mx_run.addsymbols
    mov       rcx,	216
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rdi
    lea       rdx,	[rbp + mx_run.writememlib.lib]
    mov       r8,	216
    call      memcpy
    mov       rax,	rdi
L4742:
;---------------
    add       rsp,	256
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.roundsegment
mx_run.roundsegment:
;?>>
   %define R.p r12
   %define R.align r13
   %define R.value r14
   %define R.length rdi
   %define R.newlength rbx
   %define R.av_1 rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    mov       rcx,	r12
    call      mc_genss.bufferlength
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    call      mlib.roundtoblock
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mc_genss.buffercheck
    mov       rax,	rbx
    sub       rax,	rdi
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L4756
L4754:
    lea       rax,	[r12+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r14b
    dec       rsi
    jnz       L4754
L4756:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.writerelocs
mx_run.writerelocs:
;?>>
   %define R.lib r14
   %define R.oldr rdi
    %define mx_run.writerelocs.newr -8
   %define R.k rbx
   %define R.d rsi
   %define R.baseptr64 r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
;---------------
    mov       rax,	[mc_decls.ss_nidatarelocs]
    add       rax,	[mc_decls.ss_ncoderelocs]
    mov       [r14+32],	rax
    mov       rax,	[r14+32]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+88],	rax
    xor       rbx,	rbx
    mov       rax,	1
    mov       r13,	rax
L4758:
    cmp       r13,	1
    jnz       L4762
    mov       rax,	[mc_decls.ss_idatarelocs]
    jmp       L4761
L4762:
    mov       rax,	[mc_decls.ss_coderelocs]
L4761:
    mov       rdi,	rax
    jmp       L4766
L4763:
    lea       rax,	[rbp + mx_run.writerelocs.newr]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       rax,	[rdi+16]
    mov       [rbp + mx_run.writerelocs.newr],	eax
    cmp       r13,	1
    jnz       L4768
    mov       rax,	2
    jmp       L4767
L4768:
    mov       rax,	1
L4767:
    mov       [rbp + mx_run.writerelocs.newr+6],	al
    mov       rax,	[rdi+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	4
    jz        L4770
    cmp       rax,	2
    jz        L4771
    cmp       rax,	1
    jz        L4771
    jmp       L4772
L4770:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L4774
    mov       ax,	[rsi+116]
    mov       [rbp + mx_run.writerelocs.newr+4],	ax
    mov       al,	5
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    jmp       L4773
L4774:
    lea       rcx,	[L12728]
    call      mc_libmcl.axerror
L4773:
    jmp       L4769
L4771:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L4776
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L4778
    mov       rax,	3
    jmp       L4777
L4778:
    mov       rax,	4
L4777:
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    mov       ax,	[rsi+116]
    mov       [rbp + mx_run.writerelocs.newr+4],	ax
    jmp       L4775
L4776:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L4780
    mov       al,	1
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    jmp       L4779
L4780:
    mov       al,	2
    mov       [rbp + mx_run.writerelocs.newr+7],	al
L4779:
    mov       al,	[rsi+94]
    mov       [rbp + mx_run.writerelocs.newr+4],	al
L4775:
    jmp       L4769
L4772:
    lea       rcx,	[L12729]
    call      mc_libmcl.axerror
L4769:
    mov       rax,	[r14+88]
    inc       rbx
    mov       r10,	rbx
    mov       r11,	[rbp + mx_run.writerelocs.newr]
    mov       [rax + r10*8-8],	r11
    mov       rdi,	[rdi]
L4766:
    test      rdi,	rdi
    jnz       L4763
    inc       r13
    cmp       r13,	2
    jle       L4758
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.addsymbols
mx_run.addsymbols:
;?>>
   %define R.lib r14
   %define R.d rdi
   %define R.stentry rbx
   %define R.epoffset rsi
   %define R.k r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    xor       rbx,	rbx
    mov       rax,	-1
    mov       rsi,	rax
    mov       rax,	[mx_decls.nsymimports]
    mov       [r14+56],	rax
    mov       rax,	[mx_decls.nsymexports]
    mov       [r14+64],	rax
    mov       rax,	[mx_decls.nsymimports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+112],	rax
    mov       rax,	[mx_decls.nsymexports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+120],	rax
    mov       rcx,	[mx_decls.nsymexports]
    call      mlib.pcm_alloc
    mov       [r14+128],	rax
    mov       rax,	[mx_decls.nsymexports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+136],	rax
    xor       r12,	r12
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4784
L4782:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    mov       ax,	[rax+116]
    test      ax,	ax
    jz        L4786
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rdi,	[rax + r10*8-8]
    mov       rax,	[rdi]
    mov       r10,	[r14+112]
    inc       r12
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4786:
    inc       r13
    cmp       r13,	[mc_decls.ss_nsymbols]
    jle       L4782
L4784:
    xor       r12,	r12
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4789
L4787:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L4791
    mov       al,	[rdi+83]
    test      al,	al
    jz        L4793
    mov       rbx,	rdi
L4793:
    mov       rax,	[rdi]
    mov       r10,	[r14+120]
    inc       r12
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rdi+94]
    mov       r10,	[r14+128]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    movsxd    rax,	dword [rdi+76]
    mov       r10,	[r14+136]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4791:
    inc       r13
    cmp       r13,	[mc_decls.ss_nsymbols]
    jle       L4787
L4789:
    test      rbx,	rbx
    jz        L4795
    movsxd    rax,	dword [rbx+76]
    mov       [r14+144],	rax
    jmp       L4794
L4795:
    call      msys.m$print_startcon
    lea       rcx,	[L12730]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	-1
    mov       [r14+144],	rax
L4794:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.countsymbols
mx_run.countsymbols:
;?>>
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4799
L4797:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4801
    inc       qword [mx_decls.nsymexports]
    mov       rax,	[mx_decls.nsymexports]
    mov       [rdi+118],	ax
L4801:
    mov       al,	[rdi+80]
    test      al,	al
    jz        L4803
    inc       qword [mx_decls.nsymimports]
    mov       rax,	[mx_decls.nsymimports]
    mov       [rdi+116],	ax
L4803:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L4797
L4799:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.runlibfile
mx_run.runlibfile:
;?>>
   %define R.filename rbx
   %define R.cmdskip rsi
   %define R.plib rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    call      mx_run.writememlib
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadmemmcu
    mov       rcx,	rdi
    call      mx_lib.fixuplib
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mx_lib.runprogram
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.readlibfile
mx_lib.readlibfile:
;?>>
   %define R.filespec r14
    %define mx_lib.readlibfile.p 72
   %define R.plib rdi
    %define mx_lib.readlibfile.lib -216
   %define R.sig rbx
   %define R.dir rsi
   %define R.n r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	256
    mov       r14,	rcx
    mov       [rbp+72],	rdx
;---------------
    lea       rax,	[rbp + mx_lib.readlibfile.lib]
    xor       r10d,	r10d
    mov       r11,	27
L12731:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12731
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       rbx,	rax
    cmp       rbx,	441992013
    jz        L4807
    call      msys.m$print_startcon
    lea       rcx,	[L12732]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4807:
    mov       rcx,	r14
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readlibfile.lib+184],	rax
    mov       rcx,	r14
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readlibfile.lib+192],	rax
L4808:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       rsi,	rax
    cmp       rax,	14
    jae       L4811
    lea       r10,	[L4810]
    jmp       [r10 + rax*8]
    segment .data
L4810:
    dq  L4843
    dq  L4812
    dq  L4815
    dq  L4814
    dq  L4813
    dq  L4840
    dq  L4816
    dq  L4820
    dq  L4824
    dq  L4828
    dq  L4832
    dq  L4836
    dq  L4841
    dq  L4842
    segment .text
L4812:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       [rbp + mx_lib.readlibfile.lib],	rax
    jmp       L4808
L4813:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.lib+24],	rax
    jmp       L4808
L4814:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+16],	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+80],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+80]
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.readlibfile.p]
    mov       r8,	r12
    call      memcpy
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4808
L4815:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+8],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.p]
    mov       [rbp + mx_lib.readlibfile.lib+72],	rax
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4808
L4816:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+40],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+96],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4819
L4817:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+96]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4817
L4819:
    jmp       L4808
L4820:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+48],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+104],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4823
L4821:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+104]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4821
L4823:
    jmp       L4808
L4824:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+56],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+112],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4827
L4825:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+112]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4825
L4827:
    jmp       L4808
L4828:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+64],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+120],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4831
L4829:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+120]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4829
L4831:
    jmp       L4808
L4832:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+128],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4835
L4833:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       r10,	[rbp + mx_lib.readlibfile.lib+128]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    inc       r13
    cmp       r13,	r12
    jle       L4833
L4835:
    jmp       L4808
L4836:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+136],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4839
L4837:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r10,	[rbp + mx_lib.readlibfile.lib+136]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4837
L4839:
    jmp       L4808
L4840:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+32],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+32]
    shl       rax,	3
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+88],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+88]
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.readlibfile.p]
    mov       r8,	r12
    call      memcpy
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4808
L4841:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.lib+144],	rax
    jmp       L4808
L4842:
    jmp       L4809
L4843:
    jmp       L4808
L4811:
    call      msys.m$print_startcon
    lea       rcx,	[L12733]
    call      msys.m$print_str_nf
    lea       rax,	[mx_decls.mcxdirnames]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
    jmp       L4808
L4809:
    mov       rcx,	216
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rdi
    lea       rdx,	[rbp + mx_lib.readlibfile.lib]
    mov       r8,	216
    call      memcpy
    mov       rax,	rdi
L4805:
;---------------
    add       rsp,	256
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.readbyte
mx_lib.readbyte:
;?>>
   %define R.p rcx
;?]]
;---------------
    mov       rax,	rcx
    mov       r10,	[rax]
    inc       qword [rax]
    movzx     r10,	byte [r10]
    mov       rax,	r10
L4844:
;---------------
    ret       
;End 
;Proc mx_lib.readu32
mx_lib.readu32:
;?>>
   %define R.p rcx
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	[rcx]
    mov       eax,	[rax]
    mov       rdi,	rax
    mov       rax,	rcx
    add       qword [rax],	4
    mov       rax,	rdi
L4845:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mx_lib.readstring
mx_lib.readstring:
;?>>
   %define R.p rbx
   %define R.s rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
L4847:
L4848:
    mov       rax,	rbx
    inc       qword [rax]
    mov       rax,	[rax]
    mov       al,	[rax]
    test      al,	al
    jnz       L4847
    mov       rax,	rbx
    inc       qword [rax]
    mov       rax,	rdi
L4846:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.alloclibdata
mx_lib.alloclibdata:
;?>>
   %define R.lib r12
   %define R.tablesize rdi
   %define R.n rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rax,	[r12+24]
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [r12+152],	rax
    mov       rax,	[r12+56]
    shl       rax,	4
    mov       rdi,	rax
    mov       rbx,	[r12+8]
    mov       rax,	rbx
    add       rax,	rdi
    mov       rcx,	rax
    call      mwindows.os_allocexecmem
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L4852
    lea       rcx,	[L12734]
    lea       rdx,	[L12735]
    call      mx_lib.error
L4852:
    mov       rax,	[r12+72]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    lea       rax,	[rsi + rbx]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rdi
    call      memset
    mov       [r12+72],	rsi
    mov       [r12+160],	rdi
    mov       rax,	[r12+64]
    mov       r10,	8
    imul      r10,	rax
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       [r12+168],	rax
    mov       rax,	[r12+56]
    mov       r10,	2
    imul      r10,	rax
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       [r12+176],	rax
    mov       rax,	[r12+144]
    mov       r10,	4294967295
    cmp       rax,	r10
    jz        L4854
    mov       rax,	[r12+72]
    mov       r10,	[r12+144]
    lea       rax,	[rax + r10]
    mov       [r12+200],	rax
L4854:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.error
mx_lib.error:
;?>>
   %define R.mess rdi
   %define R.param rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	[rbx]
    test      al,	al
    jz        L4857
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4856
L4857:
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4856:
    call      msys.m$print_startcon
    lea       rcx,	[L12736]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadmemmcu
mx_lib.loadmemmcu:
;?>>
   %define R.lib rsi
   %define R.newlib rdi
   %define R.name rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	[rsi+192]
    mov       rax,	[rsi+184]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mx_lib.checknew
    mov       rcx,	rbx
    call      mx_lib.mxaddlib
    mov       rdi,	rax
    mov       rax,	rsi
    lea       r10,	[mx_decls.libtable]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	rsi
    call      mx_lib.loadimports
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.checknew
mx_lib.checknew:
;?>>
   %define R.name rdi
   %define R.filename rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    call      mx_lib.findlib
    test      rax,	rax
    jz        L4861
    lea       rcx,	[L12737]
    mov       rdx,	rbx
    call      mx_lib.error
L4861:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.findlib
mx_lib.findlib:
;?>>
   %define R.name rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4865
L4863:
    lea       rax,	[mx_decls.libnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4867
    mov       rax,	rdi
    jmp       L4862
L4867:
    inc       rdi
    cmp       rdi,	[mx_decls.nlibs]
    jle       L4863
L4865:
    xor       eax,	eax
L4862:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.mxaddlib
mx_lib.mxaddlib:
;?>>
   %define R.name rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	20
    jl        L4870
    lea       rcx,	[L12738]
    lea       rdx,	[L12739]
    call      mx_lib.error
L4870:
    inc       qword [mx_decls.nlibs]
    mov       rax,	[mx_decls.nlibs]
    mov       r10,	rdi
    lea       r11,	[mx_decls.libnametable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[mx_decls.nlibs]
L4868:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_lib.fixuplib
mx_lib.fixuplib:
;?>>
    %define mx_lib.fixuplib.lib 16
;?]]
    sub       rsp,	40
;---------------
    call      mx_lib.loaddlls
    call      mx_lib.checksymbols
    call      mx_lib.dorelocations
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mx_lib.loaddlls
mx_lib.loaddlls:
;?>>
   %define R.inst rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	1
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4875
L4873:
    lea       rax,	[mx_decls.dllinsttable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L4877
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mwindows.os_getdllinst
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L4879
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[L12740]
    mov       rdx,	rax
    call      mx_lib.error
L4879:
    mov       rax,	rdi
    lea       r10,	[mx_decls.dllinsttable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
L4877:
    inc       rbx
    cmp       rbx,	[mx_decls.ndlllibs]
    jle       L4873
L4875:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.finddllsymbol
mx_lib.finddllsymbol:
;?>>
   %define R.name rsi
   %define R.dllindex r12
   %define R.p rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       eax,	eax
    mov       [r12],	rax
    mov       rbx,	1
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4883
L4881:
    lea       rax,	[mx_decls.dllinsttable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mwindows.os_getdllprocaddr
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L4885
    mov       [r12],	rbx
    mov       rax,	rdi
    jmp       L4880
L4885:
    inc       rbx
    cmp       rbx,	[mx_decls.ndlllibs]
    jle       L4881
L4883:
    xor       eax,	eax
L4880:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.checksymbols
mx_lib.checksymbols:
;?>>
    %define mx_lib.checksymbols.dllindex -8
   %define R.undef rdi
   %define R.p rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    xor       rdi,	rdi
    mov       rax,	1
    mov       rsi,	rax
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4889
L4887:
    lea       rax,	[mx_decls.symboldefined]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4891
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[rbp + mx_lib.checksymbols.dllindex]
    call      mx_lib.finddllsymbol
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L4893
    mov       rax,	rbx
    lea       r10,	[mx_decls.symboladdress]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rbp + mx_lib.checksymbols.dllindex]
    lea       r10,	[mx_decls.symboldllindex]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mx_decls.symboldefined]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    jmp       L4892
L4893:
    call      msys.m$print_startcon
    lea       rcx,	[L12741]
    call      msys.m$print_str_nf
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rdi
L4892:
L4891:
    inc       rsi
    cmp       rsi,	[mx_decls.nsymbols]
    jle       L4887
L4889:
    test      rdi,	rdi
    jz        L4895
L4895:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.dorelocations
mx_lib.dorelocations:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4899
L4897:
    lea       rax,	[mx_decls.librelocated]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4901
    lea       rax,	[mx_decls.libtable]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.reloclib
L4901:
    inc       rdi
    cmp       rdi,	[mx_decls.nlibs]
    jle       L4897
L4899:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_lib.reloclib
mx_lib.reloclib:
;?>>
    %define mx_lib.reloclib.lib 72
   %define R.index rdi
   %define R.targetoffset rbx
   %define R.name rsi
   %define R.p r12
   %define R.q r13
   %define R.qaddr r14
    %define mx_lib.reloclib.r -8
   %define R.av_1 r15
    %define mx_lib.reloclib.av_2 -16
    %define mx_lib.reloclib.i -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[r10+8]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+56]
    shl       rax,	3
    lea       r10,	[r12 + rax]
    mov       r14,	r10
    mov       rax,	1
    mov       [rbp + mx_lib.reloclib.i],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r15,	[rax+56]
    cmp       r15,	1
    jl        L4905
L4903:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+112]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    mov       rsi,	[rax + r10*8-8]
    mov       rax,	r12
    inc       r12
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	36
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	37
    mov       [rax],	r10b
    mov       [r12],	r14d
    add       r12,	4
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    movsx     rax,	word [rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r14
    add       r14,	8
    mov       [r10],	rax
    mov       rax,	[rbp + mx_lib.reloclib.i]
    inc       rax
    mov       [rbp + mx_lib.reloclib.i],	rax
    cmp       rax,	r15
    jle       L4903
L4905:
    mov       rax,	1
    mov       [rbp + mx_lib.reloclib.i],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+32]
    mov       [rbp + mx_lib.reloclib.av_2],	rax
    mov       rax,	[rbp + mx_lib.reloclib.av_2]
    cmp       rax,	1
    jl        L4908
L4906:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+88]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    mov       rax,	[rax + r10*8-8]
    mov       [rbp + mx_lib.reloclib.r],	rax
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+6]
    cmp       rax,	1
    jz        L4910
    cmp       rax,	2
    jz        L4911
    cmp       rax,	3
    jz        L4912
    jmp       L4913
L4910:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    jmp       L4909
L4911:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    jmp       L4909
L4912:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
L4913:
L4909:
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+7]
    cmp       rax,	1
    jz        L4915
    cmp       rax,	2
    jz        L4916
    cmp       rax,	4
    jz        L4917
    cmp       rax,	3
    jz        L4918
    cmp       rax,	5
    jz        L4919
    jmp       L4920
L4915:
    mov       eax,	[r12]
    mov       rbx,	rax
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+4]
    cmp       rax,	1
    jz        L4922
    cmp       rax,	2
    jz        L4923
    cmp       rax,	3
    jz        L4924
    jmp       L4925
L4922:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
    jmp       L4921
L4923:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
    jmp       L4921
L4924:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
L4925:
L4921:
    jmp       L4914
L4916:
    mov       eax,	[r12]
    mov       rbx,	rax
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+4]
    cmp       rax,	1
    jz        L4927
    cmp       rax,	2
    jz        L4928
    cmp       rax,	3
    jz        L4929
    jmp       L4930
L4927:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
    jmp       L4926
L4928:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
    jmp       L4926
L4929:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
L4930:
L4926:
    jmp       L4914
L4917:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    movzx     r10,	word [rbp + mx_lib.reloclib.r+4]
    movsx     rax,	word [rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r12
    add       [r10],	rax
    jmp       L4914
L4918:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    movzx     r10,	word [rbp + mx_lib.reloclib.r+4]
    movsx     rax,	word [rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r12
    add       [r10],	eax
    jmp       L4914
L4919:
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+6]
    cmp       rax,	1
    jz        L4932
    lea       rcx,	[L12742]
    lea       rdx,	[L12743]
    call      mx_lib.error
L4932:
    movzx     rax,	word [rbp + mx_lib.reloclib.r+4]
    mov       rdi,	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[r10+8]
    lea       rax,	[rax + r10]
    lea       r10,	[rdi-1]
    shl       r10,	3
    lea       rax,	[rax + r10]
    mov       r13,	rax
    lea       rax,	[r12+4]
    mov       r10,	r13
    sub       r10,	rax
    mov       [r12],	r10d
L4920:
L4914:
    mov       rax,	[rbp + mx_lib.reloclib.i]
    inc       rax
    mov       [rbp + mx_lib.reloclib.i],	rax
    cmp       rax,	[rbp + mx_lib.reloclib.av_2]
    jle       L4906
L4908:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+208]
    mov       r10b,	1
    lea       r11,	[mx_decls.librelocated]
    mov       [r11 + rax-1],	r10b
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadimports
mx_lib.loadimports:
;?>>
   %define R.plib rsi
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	1
    mov       rdi,	[rsi+48]
    cmp       rdi,	1
    jl        L4936
L4934:
    mov       rax,	[rsi+104]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.dosublib
    inc       rbx
    cmp       rbx,	rdi
    jle       L4934
L4936:
    mov       rcx,	rsi
    call      mx_lib.alloclibdata
    mov       rcx,	rsi
    call      mx_lib.dosymbols
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.dosublib
mx_lib.dosublib:
;?>>
   %define R.name rsi
   %define R.qlib rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mx_lib.findlib
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4939
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    call      msys.m$print_startcon
    lea       rcx,	[L12744]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rsi
    lea       rdx,	[L12745]
    call      mlib.addext
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mx_lib.loadlibfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
L4939:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadlibfile
mx_lib.loadlibfile:
;?>>
   %define R.filename rsi
   %define R.libno r12
   %define R.plib rdi
   %define R.p rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	rsi
    call      mx_lib.readmxfile
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4942
    lea       rcx,	[L12746]
    mov       rdx,	rsi
    call      mx_lib.error
L4942:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mx_lib.readlibfile
    mov       rdi,	rax
    mov       [rdi+208],	r12
    mov       rax,	rdi
    lea       r10,	[mx_decls.libtable]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4940:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.dosymbols
mx_lib.dosymbols:
;?>>
   %define R.lib r15
   %define R.ix rdi
   %define R.baseaddr rbx
   %define R.av_1 rsi
   %define R.av_2 r12
   %define R.av_3 r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r15,	rcx
;---------------
    mov       r14,	1
    mov       rsi,	[r15+40]
    cmp       rsi,	1
    jl        L4946
L4944:
    mov       rax,	[r15+96]
    mov       r10,	r14
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.adddll
    inc       r14
    cmp       r14,	rsi
    jle       L4944
L4946:
    mov       r14,	1
    mov       r12,	[r15+56]
    cmp       r12,	1
    jl        L4949
L4947:
    mov       rax,	[r15+112]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mx_lib.addsymbol
    mov       rdi,	rax
    mov       rax,	[r15+176]
    mov       r10w,	di
    mov       r11,	r14
    mov       [rax + r11*2-2],	r10w
    inc       r14
    cmp       r14,	r12
    jle       L4947
L4949:
    mov       r14,	1
    mov       r13,	[r15+64]
    cmp       r13,	1
    jl        L4952
L4950:
    mov       rax,	[r15+120]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mx_lib.addsymbol
    mov       rdi,	rax
    lea       rax,	[mx_decls.symboldefined]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L4954
    call      msys.m$print_startcon
    lea       rcx,	[L12747]
    call      msys.m$print_str_nf
    mov       rax,	[r15+120]
    mov       r10,	r14
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4951
L4954:
    mov       al,	1
    lea       r10,	[mx_decls.symboldefined]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	[r15+128]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L4956
    cmp       rax,	2
    jz        L4957
    cmp       rax,	3
    jz        L4958
    jmp       L4959
L4956:
    mov       rbx,	[r15+72]
    jmp       L4955
L4957:
    mov       rbx,	[r15+80]
    jmp       L4955
L4958:
    mov       rbx,	[r15+152]
    jmp       L4955
L4959:
    xor       rbx,	rbx
L4955:
    mov       rax,	[r15+136]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[rbx + rax]
    lea       rax,	[mx_decls.symboladdress]
    mov       r11,	rdi
    mov       [rax + r11*8-8],	r10
    mov       rax,	[r15+208]
    lea       r10,	[mx_decls.symbollibindex]
    mov       r11,	rdi
    mov       [r10 + r11*2-2],	ax
L4951:
    inc       r14
    cmp       r14,	r13
    jle       L4950
L4952:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.readmxfile
mx_lib.readmxfile:
;?>>
   %define R.filename rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mlib.readfile
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L4962
    xor       eax,	eax
    jmp       L4960
L4962:
    mov       al,	13
    mov       r10,	[mlib.rfsize]
    mov       [rdi + r10],	al
    mov       rax,	rdi
L4960:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.adddll
mx_lib.adddll:
;?>>
   %define R.name rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4966
L4964:
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4963
L4968:
    inc       rdi
    cmp       rdi,	[mx_decls.ndlllibs]
    jle       L4964
L4966:
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	20
    jl        L4970
    lea       rcx,	[L12748]
    lea       rdx,	[L12749]
    call      mx_lib.error
L4970:
    inc       qword [mx_decls.ndlllibs]
    mov       rax,	[mx_decls.ndlllibs]
    mov       r10,	rbx
    lea       r11,	[mx_decls.dllnametable]
    mov       [r11 + rax*8-8],	r10
L4963:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.addsymbol
mx_lib.addsymbol:
;?>>
   %define R.name rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4974
L4972:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4976
    mov       rax,	rdi
    jmp       L4971
L4976:
    inc       rdi
    cmp       rdi,	[mx_decls.nsymbols]
    jle       L4972
L4974:
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	3000
    jl        L4978
    lea       rcx,	[L12750]
    lea       rdx,	[L12751]
    call      mx_lib.error
L4978:
    inc       qword [mx_decls.nsymbols]
    mov       rax,	[mx_decls.nsymbols]
    mov       r10,	rbx
    lea       r11,	[mx_decls.symbolnametable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[mx_decls.nsymbols]
L4971:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.setspecialglobals
mx_lib.setspecialglobals:
;?>>
   %define R.cmdskip rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4982
L4980:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[L12752]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4985
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[L12753]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4984
L4985:
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10b,	bl
    mov       [rax],	r10b
L4984:
    inc       rdi
    cmp       rdi,	[mx_decls.nsymbols]
    jle       L4980
L4982:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.runprogram
mx_lib.runprogram:
;?>>
   %define R.lib r12
   %define R.cmdskip r13
   %define R.fnptr rdi
   %define R.libno rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rbx,	[r12+208]
    mov       rsi,	1
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4989
L4987:
    cmp       rsi,	rbx
    jz        L4991
    lea       rax,	[mx_decls.libinitdone]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4991
    lea       rax,	[mx_decls.libtable]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.calllibinit
L4991:
    inc       rsi
    cmp       rsi,	[mx_decls.nlibs]
    jle       L4987
L4989:
    mov       rax,	[r12+200]
    test      rax,	rax
    jnz       L4993
    lea       rcx,	[L12754]
    lea       rdx,	[L12755]
    call      mx_lib.error
L4993:
    mov       rcx,	r13
    call      mx_lib.setspecialglobals
    mov       rdi,	[r12+200]
    mov       rax,	rdi
    call      rax
    mov       al,	1
    lea       r10,	[mx_decls.libinitdone]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.calllibinit
mx_lib.calllibinit:
;?>>
   %define R.lib rsi
   %define R.fnptr rdi
   %define R.libno rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	[rsi+208]
    mov       rax,	[rsi+200]
    test      rax,	rax
    jz        L4996
    mov       rdi,	[rsi+200]
    mov       rax,	rdi
    call      rax
L4996:
    mov       rax,	[rsi+208]
    mov       r10b,	1
    lea       r11,	[mx_decls.libinitdone]
    mov       [r11 + rax-1],	r10b
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.findsymbol
mx_lib.findsymbol:
;?>>
   %define R.name rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L5000
L4998:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mlib.eqstring
    test      rax,	rax
    jz        L5002
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L4997
L5002:
    inc       rdi
    cmp       rdi,	[mx_decls.nsymbols]
    jle       L4998
L5000:
    xor       eax,	eax
L4997:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadmx
mx_lib.loadmx:
;?>>
   %define R.filename r12
   %define R.plib rdi
   %define R.newlib rbx
   %define R.name rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.convlcstring
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mx_lib.checknew
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mx_lib.loadlibfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
    mov       rax,	rdi
L5003:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadmemmcb
mx_lib.loadmemmcb:
;?>>
   %define R.filename r12
   %define R.p r13
   %define R.plib rdi
   %define R.newlib rbx
   %define R.name rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	r12
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.convlcstring
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mx_lib.checknew
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mx_lib.readlibfile
    mov       rdi,	rax
    mov       [rdi+208],	rbx
    mov       rax,	rdi
    lea       r10,	[mx_decls.libtable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
    mov       rax,	rdi
L5004:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.writemcx
mx_write.writemcx:
;?>>
   %define R.filename r13
   %define R.n rdi
   %define R.ndlls rbx
   %define R.nlibs rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	[mc_decls.ss_zdatalen]
    mov       rdx,	8
    call      mlib.roundtoblock
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	8
    mov       r8,	144
    call      mx_write.roundsegment
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mx_write.roundsegment
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mx_write.dest],	rax
    mov       rcx,	441992013
    call      mx_write.genu32
    mov       rcx,	1
    call      mx_write.genbyte
    lea       rcx,	[L12756]
    call      mx_write.genstring
    call      mx_run.countsymbols
    call      mx_write.writerelocs
    mov       rcx,	4
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_zdatalen]
    call      mx_write.genu32
    mov       rcx,	2
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mx_write.genblock
    mov       rcx,	3
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mx_write.genblock
    xor       rbx,	rbx
    xor       eax,	eax
    mov       rsi,	rax
    mov       r12,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L5008
L5006:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L5010
    inc       rbx
L5010:
    inc       r12
    cmp       r12,	[pc_decls.nplibfiles]
    jle       L5006
L5008:
    mov       rcx,	6
    call      mx_write.genbyte
    mov       rcx,	rbx
    call      mx_write.genu32
    mov       r12,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L5013
L5011:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L5015
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8-8]
    call      mx_write.genstring
L5015:
    inc       r12
    cmp       r12,	[pc_decls.nplibfiles]
    jle       L5011
L5013:
    call      mx_write.writesymbols
    mov       rcx,	13
    call      mx_write.genbyte
    mov       rax,	[mx_write.dest]
    mov       rax,	[rax+8]
    mov       r10,	[mx_write.dest]
    mov       r10,	[r10]
    sub       rax,	r10
    mov       r10,	[mx_write.dest]
    mov       r10,	[r10]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.writerelocs
mx_write.writerelocs:
;?>>
   %define R.oldr rdi
    %define mx_write.writerelocs.newr -8
   %define R.n rbx
   %define R.count rsi
   %define R.d r12
   %define R.baseptr64 r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rcx,	5
    call      mx_write.genbyte
    mov       rax,	[mc_decls.ss_nidatarelocs]
    add       rax,	[mc_decls.ss_ncoderelocs]
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    xor       rsi,	rsi
    mov       rax,	1
    mov       r14,	rax
L5017:
    cmp       r14,	1
    jnz       L5021
    mov       rax,	[mc_decls.ss_idatarelocs]
    jmp       L5020
L5021:
    mov       rax,	[mc_decls.ss_coderelocs]
L5020:
    mov       rdi,	rax
    jmp       L5025
L5022:
    inc       rsi
    lea       rax,	[rbp + mx_write.writerelocs.newr]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       rax,	[rdi+16]
    mov       [rbp + mx_write.writerelocs.newr],	eax
    cmp       r14,	1
    jnz       L5027
    mov       rax,	2
    jmp       L5026
L5027:
    mov       rax,	1
L5026:
    mov       [rbp + mx_write.writerelocs.newr+6],	al
    mov       rax,	[rdi+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       r12,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	4
    jz        L5029
    cmp       rax,	2
    jz        L5030
    cmp       rax,	1
    jz        L5030
    jmp       L5031
L5029:
    mov       al,	[r12+80]
    test      al,	al
    jz        L5033
    mov       ax,	[r12+116]
    mov       [rbp + mx_write.writerelocs.newr+4],	ax
    mov       al,	5
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    jmp       L5032
L5033:
    lea       rcx,	[L12757]
    call      mc_libmcl.axerror
L5032:
    jmp       L5028
L5030:
    mov       al,	[r12+80]
    test      al,	al
    jz        L5035
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L5037
    mov       rax,	3
    jmp       L5036
L5037:
    mov       rax,	4
L5036:
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    mov       ax,	[r12+116]
    mov       [rbp + mx_write.writerelocs.newr+4],	ax
    jmp       L5034
L5035:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L5039
    mov       al,	1
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    jmp       L5038
L5039:
    mov       al,	2
    mov       [rbp + mx_write.writerelocs.newr+7],	al
L5038:
    mov       al,	[r12+94]
    mov       [rbp + mx_write.writerelocs.newr+4],	al
L5034:
    jmp       L5028
L5031:
    lea       rcx,	[L12758]
    call      mc_libmcl.axerror
L5028:
    lea       rcx,	[rbp + mx_write.writerelocs.newr]
    mov       rdx,	8
    call      mx_write.genblock
    mov       rdi,	[rdi]
L5025:
    test      rdi,	rdi
    jnz       L5022
    inc       r14
    cmp       r14,	2
    jle       L5017
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.writesymbols
mx_write.writesymbols:
;?>>
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	8
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymimports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5043
L5041:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       ax,	[rax+116]
    test      ax,	ax
    jz        L5045
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       rcx,	[rdi]
    call      mx_write.genstring
L5045:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L5041
L5043:
    mov       rcx,	9
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5048
L5046:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5050
    mov       al,	[rdi+83]
    test      al,	al
    jz        L5052
    mov       [mx_write.entrypoint],	rdi
L5052:
    mov       rcx,	[rdi]
    call      mx_write.genstring
L5050:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L5046
L5048:
    mov       rcx,	10
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5055
L5053:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5057
    movzx     rax,	byte [rdi+94]
    mov       rcx,	rax
    call      mx_write.genbyte
L5057:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L5053
L5055:
    mov       rcx,	11
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5060
L5058:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5062
    movsxd    rax,	dword [rdi+76]
    mov       rcx,	rax
    call      mx_write.genu32
L5062:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L5058
L5060:
    mov       rcx,	12
    call      mx_write.genbyte
    mov       rax,	[mx_write.entrypoint]
    test      rax,	rax
    jz        L5064
    mov       rax,	[mx_write.entrypoint]
    movsxd    rax,	dword [rax+76]
    mov       rcx,	rax
    call      mx_write.genu32
    jmp       L5063
L5064:
    mov       rcx,	4294967295
    call      mx_write.genu32
L5063:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.roundsegment
mx_write.roundsegment:
;?>>
   %define R.p r12
   %define R.align r13
   %define R.value r14
   %define R.length rdi
   %define R.newlength rbx
   %define R.av_1 rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    mov       rcx,	r12
    call      mc_genss.bufferlength
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    call      mlib.roundtoblock
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mc_genss.buffercheck
    mov       rax,	rbx
    sub       rax,	rdi
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L5068
L5066:
    lea       rax,	[r12+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r14b
    dec       rsi
    jnz       L5066
L5068:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.genbyte
mx_write.genbyte:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	1
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_write.genu32
mx_write.genu32:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	4
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    add       qword [rax],	4
    mov       [r10],	edi
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_write.genstring
mx_write.genstring:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      strlen
    inc       rax
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mx_write.genblock
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_write.genblock
mx_write.genblock:
;?>>
   %define R.p rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	rbx
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	rbx
    add       [rax],	r10
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm.main
mm.main:
main:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msyswin.start
    call      pcl.start
    call      mm.start
    call      mm_cli.main2
    xor       ecx,	ecx
    call      exit
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.main2
mm_cli.main2:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mwindows.os_clock
    mov       [mm_cli.startclock],	rax
    mov       rax,	[mm_cli.startclock]
    mov       [pc_decls.pstartclock],	rax
    call      mm_cli.initdata
    call      mm_cli.getinputoptions
    mov       rax,	[mm_decls.prodmode]
    test      rax,	rax
    jz        L5076
    call      mm_cli.production_compiler
    jmp       L5075
L5076:
    call      mm_cli.debug_compiler
L5075:
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	3
    jnz       L5078
    call      msys.m$print_startcon
    lea       rcx,	[L12759]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5078:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.debug_compiler
mm_cli.debug_compiler:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	[mm_cli.inputfile]
    call      mm_modules.loadproject
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	6
    jnz       L5081
    mov       rax,	4
    mov       [mm_decls.passlevel],	rax
    jmp       L5080
L5081:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	7
    jnz       L5082
    mov       rax,	6
    mov       [mm_decls.passlevel],	rax
L5082:
L5080:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	2
    jl        L5084
    movzx     rax,	byte [mm_decls.fshowast1]
    mov       rcx,	rax
    call      mm_cli.do_parse
L5084:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	4
    jl        L5086
    movzx     rax,	byte [mm_decls.fshowast2]
    mov       rcx,	rax
    call      mm_cli.do_name
L5086:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	5
    jl        L5088
    movzx     rax,	byte [mm_decls.fshowast3]
    mov       rcx,	rax
    call      mm_cli.do_type
L5088:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	6
    jl        L5090
    mov       al,	[mm_decls.fshowpcl]
    test      al,	al
    jnz       L5091
    mov       al,	[mm_decls.fshowpst]
    test      al,	al
    jz        L5092
L5091:
    mov       rax,	1
    jmp       L5093
L5092:
    xor       eax,	eax
L5093:
    mov       rcx,	rax
    call      mm_cli.do_genpcl
L5090:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	7
    jl        L5095
    mov       al,	[mm_decls.fshowasm]
    test      al,	al
    jnz       L5096
    xor       eax,	eax
    test      ax,	ax
    jz        L5097
L5096:
    mov       rax,	1
    jmp       L5098
L5097:
    xor       eax,	eax
L5098:
    mov       rcx,	rax
    call      mm_cli.do_genmcl
L5095:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	8
    jl        L5100
    xor       ecx,	ecx
    call      pc_api.pcl_genss
L5100:
    mov       al,	[mm_decls.fshowtiming]
    test      al,	al
    jz        L5102
    call      mm_diags.showtimings
L5102:
    call      mm_diags.showlogfile
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.production_compiler
mm_cli.production_compiler:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_cli.showcompilemess
    mov       rcx,	[mm_cli.inputfile]
    call      mm_modules.loadproject
    xor       ecx,	ecx
    call      mm_cli.do_parse
    xor       ecx,	ecx
    call      mm_cli.do_name
    xor       ecx,	ecx
    call      mm_cli.do_type
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	1
    jnz       L5105
    mov       rcx,	[mm_cli.inputfile]
    call      mm_support.do_writema
L5105:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	2
    jz        L5108
    cmp       rax,	3
    jnz       L5107
L5108:
    mov       rcx,	[mm_cli.inputfile]
    call      mm_support.do_getinfo
L5107:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	8
    jnz       L5110
    call      mm_cli.do_writeexports
L5110:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    setz      al
    movzx     eax,	al
    mov       rcx,	rax
    call      mm_cli.do_genpcl
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	5
    jnz       L5112
    call      pc_run.pcl_runpcl
L5112:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	6
    jl        L5114
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	6
    jz        L5115
    xor       eax,	eax
    test      ax,	ax
    jz        L5116
L5115:
    mov       rax,	1
    jmp       L5117
L5116:
    xor       eax,	eax
L5117:
    mov       rcx,	rax
    call      mm_cli.do_genmcl
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	7
    jz        L5119
    cmp       rax,	9
    jz        L5120
    cmp       rax,	8
    jz        L5121
    cmp       rax,	10
    jz        L5122
    cmp       rax,	11
    jz        L5123
    jmp       L5124
L5119:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12760]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writeobj
    jmp       L5118
L5120:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12761]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writeexe
    jmp       L5118
L5121:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12762]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writedll
    jmp       L5118
L5122:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12763]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writemx
    jmp       L5118
L5123:
    call      pc_api.pcl_exec
L5124:
L5118:
L5114:
    mov       al,	[mm_decls.fshowtiming]
    test      al,	al
    jz        L5126
    call      mm_diags.showtimings
L5126:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.showcompilemess
mm_cli.showcompilemess:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	1
    jl        L5129
    mov       al,	[mm_cli.msfile]
    test      al,	al
    jnz       L5129
    call      msys.m$print_startcon
    lea       rcx,	[L12764]
    call      msys.m$print_setfmt
    mov       rcx,	[mm_cli.inputfile]
    call      msys.m$print_str_nf
    lea       rax,	[mm_cli.passnames]
    mov       r10,	[mm_decls.passlevel]
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[mm_decls.outfile]
    mov       rdx,	rax
    call      mlib.changeext
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5129:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.do_parse
mm_cli.do_parse:
;?>>
   %define R.flog rsi
   %define R.tt rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    mov       rbx,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5133
L5131:
    lea       rax,	[mm_decls.modules]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8]
    call      mm_parse.parsemodule
    inc       rbx
    cmp       rbx,	[mm_decls.nmodules]
    jle       L5131
L5133:
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.parsetime],	r10
    mov       rax,	[mm_decls.prodmode]
    test      rax,	rax
    jnz       L5136
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	3
    jl        L5135
L5136:
    call      mm_name.fixusertypes
L5135:
    call      mm_cli.fixstartprocs
    test      rsi,	rsi
    jz        L5138
    lea       rcx,	[L12765]
    call      mm_diags.showast
L5138:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_name
mm_cli.do_name:
;?>>
   %define R.flog rsi
   %define R.tt rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    call      mm_name.rx_typetable
    mov       rbx,	2
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	2
    jl        L5142
L5140:
    mov       rcx,	rbx
    call      mm_name.rx_module
    inc       rbx
    cmp       rbx,	[mm_decls.nmodules]
    jle       L5140
L5142:
    mov       rcx,	1
    call      mm_name.rx_module
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.resolvetime],	r10
    test      rsi,	rsi
    jz        L5144
    lea       rcx,	[L12766]
    call      mm_diags.showast
L5144:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_type
mm_cli.do_type:
;?>>
   %define R.flog rsi
   %define R.tt rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    call      mm_type.tx_typetable
    mov       rbx,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5148
L5146:
    mov       rcx,	rbx
    call      mm_type.tx_module
    inc       rbx
    cmp       rbx,	[mm_decls.nmodules]
    jle       L5146
L5148:
    call      mm_type.tx_allprocs
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.typetime],	r10
    test      rsi,	rsi
    jz        L5150
    lea       rcx,	[L12767]
    call      mm_diags.showast
L5150:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_genpcl
mm_cli.do_genpcl:
;?>>
   %define R.flog rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    xor       ecx,	ecx
    call      mm_genpcl.codegen_il
    mov       al,	[pc_decls.fregoptim]
    test      al,	al
    jnz       L5154
    mov       al,	[pc_decls.fpeephole]
    test      al,	al
    jz        L5153
L5154:
    call      pc_reduce.pcl_reducetest
L5153:
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.pcltime],	r10
    test      rbx,	rbx
    jz        L5156
    mov       al,	[mm_decls.fshowpcl]
    test      al,	al
    jnz       L5159
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    jnz       L5158
L5159:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12768]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writepcl
L5158:
    mov       al,	[mm_decls.fshowpst]
    test      al,	al
    jz        L5161
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    jnz       L5161
    lea       rcx,	[L12769]
    call      pc_api.pcl_writepst
L5161:
L5156:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_genmcl
mm_cli.do_genmcl:
;?>>
   %define R.flog rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    call      pc_api.pcl_genmcl
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [pc_decls.mcltime],	r10
    test      rbx,	rbx
    jz        L5164
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12770]
    call      mlib.changeext
    mov       rcx,	rax
    mov       rdx,	16705
    call      pc_api.pcl_writeasm
L5164:
    mov       al,	[mm_decls.fshowpst]
    test      al,	al
    jz        L5166
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    jle       L5166
    lea       rcx,	[L12771]
    call      pc_api.pcl_writepst
L5166:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.initdata
mm_cli.initdata:
;?>>
   %define R.pm rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      mlib.pcm_init
    call      mm_lex.lexsetup
    call      mm_assem.initassemsymbols
    call      mm_support.init_tt_tables
    call      mm_support.initbblib
    mov       rcx,	64
    call      mlib.pcm_allocz
    mov       rdi,	rax
    lea       rax,	[L12772]
    mov       [rdi],	rax
    lea       rcx,	[L12773]
    call      mm_lex.addnamestr
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	1
    call      mm_lib.createdupldef
    mov       [mm_decls.stprogram],	rax
    mov       rax,	[mm_decls.stprogram]
    mov       [rdi+24],	rax
    mov       rax,	rdi
    lea       r10,	[mm_decls.modules]
    mov       [r10],	rax
    lea       rax,	[mm_support.mgetsourceinfo]
    mov       [pc_decls.igetmsourceinfo],	rax
    lea       rax,	[mm_assemaux.domcl_assem]
    mov       [pc_api.idomcl_assem],	rax
    lea       rax,	[mm_genpcl.findhostfn]
    mov       [pc_api.igethostfn],	rax
    lea       rax,	[mm_assemaux.checkasmlabel]
    mov       [pc_api.icheckasmlabel],	rax
    lea       rcx,	[L12774]
    call      remove
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_cli.getinputoptions
mm_cli.getinputoptions:
;?>>
    %define mm_cli.getinputoptions.paramno -8
   %define R.pmtype rdi
   %define R.sw rbx
   %define R.extlen rsi
    %define mm_cli.getinputoptions.name -16
    %define mm_cli.getinputoptions.value -24
   %define R.ext r12
    %define mm_cli.getinputoptions.filespec -328
   %define R.av_1 r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	360
;---------------
    mov       al,	[pcl.pc_userunpcl]
    test      al,	al
    jz        L5170
    mov       rax,	5
    mov       [mm_decls.passlevel],	rax
    mov       rax,	1
    mov       [mm_decls.prodmode],	rax
    xor       eax,	eax
    mov       [mm_decls.fverbose],	rax
L5170:
    mov       rax,	1
    mov       [rbp + mm_cli.getinputoptions.paramno],	rax
    call      mwindows.os_gethostname
    mov       rcx,	rax
    call      mlib.extractfile
    mov       rcx,	rax
    lea       rdx,	[L12775]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5172
    mov       al,	1
    mov       [mm_cli.msfile],	al
    xor       eax,	eax
    mov       [mm_decls.fverbose],	rax
    mov       rcx,	13
    lea       rdx,	[L12776]
    xor       r8d,	r8d
    call      mm_cli.do_option
L5172:
    jmp       L5174
L5173:
    mov       rax,	rdi
    cmp       rax,	1
    jz        L5177
    cmp       rax,	2
    jz        L5178
    cmp       rax,	3
    jz        L5179
    jmp       L5180
L5177:
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       rbx,	1
    mov       r13,	55
    cmp       r13,	1
    jl        L5184
L5181:
    lea       rax,	[mm_cli.optionnames]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L5186
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_cli.getinputoptions.value]
    mov       r8,	[rbp + mm_cli.getinputoptions.paramno]
    call      mm_cli.do_option
    jmp       L5183
L5186:
    inc       rbx
    cmp       rbx,	r13
    jle       L5181
L5184:
    call      msys.m$print_startcon
    lea       rcx,	[L12777]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	99
    call      exit
L5183:
    jmp       L5176
L5178:
    mov       rax,	[mm_cli.inputfile]
    test      rax,	rax
    jz        L5188
    lea       rcx,	[L12778]
    lea       rdx,	[L12779]
    lea       r8,	[L12779]
    call      mm_support.loaderror
L5188:
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    mov       [mm_cli.inputfile],	rax
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	11
    jz        L5191
    cmp       rax,	5
    jnz       L5190
L5191:
    mov       rax,	[rbp + mm_cli.getinputoptions.paramno]
    dec       rax
    add       rax,	[msys.$cmdskip]
    mov       [mm_cli.cmdskip],	rax
    jmp       L5175
L5190:
    jmp       L5176
L5179:
    lea       rcx,	[L12780]
    lea       rdx,	[L12781]
    lea       r8,	[L12781]
    call      mm_support.loaderror
    jmp       L5176
L5180:
    lea       rcx,	[L12782]
    lea       rdx,	[L12783]
    lea       r8,	[L12783]
    call      mm_support.loaderror
L5176:
L5174:
    lea       rcx,	[rbp + mm_cli.getinputoptions.paramno]
    lea       rdx,	[rbp + mm_cli.getinputoptions.name]
    lea       r8,	[rbp + mm_cli.getinputoptions.value]
    lea       r9,	[L12784]
    call      mlib.nextcmdparamnew
    mov       rdi,	rax
    test      rax,	rax
    jnz       L5173
L5175:
    mov       rax,	[mm_decls.debugmode]
    cmp       rax,	[mm_decls.prodmode]
    jnz       L5193
    test      rax,	rax
    jnz       L5193
    mov       rax,	9
    mov       [mm_decls.passlevel],	rax
    lea       rax,	[L12785]
    mov       [mm_cli.outext],	rax
    mov       rax,	1
    mov       [mm_decls.prodmode],	rax
L5193:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	7
    jz        L5195
    cmp       rax,	8
    jz        L5195
    cmp       rax,	6
    jz        L5196
    cmp       rax,	10
    jz        L5197
    cmp       rax,	11
    jz        L5197
    jmp       L5198
L5195:
    mov       al,	2
    mov       [mm_decls.highmem],	al
    jmp       L5194
L5196:
    mov       rax,	[pc_decls.assemtype]
    cmp       rax,	1297301838
    jnz       L5200
    mov       al,	2
    mov       [mm_decls.highmem],	al
L5200:
    jmp       L5194
L5197:
    xor       eax,	eax
    mov       [mm_decls.highmem],	al
L5198:
L5194:
    mov       rax,	[mm_cli.inputfile]
    test      rax,	rax
    jnz       L5202
    call      mm_cli.showcaption
    call      msys.m$print_startcon
    lea       rcx,	[L12786]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12787]
    call      msys.m$print_str_nf
    mov       rax,	[msys.cmdparams]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L12788]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12789]
    call      msys.m$print_str_nf
    mov       rax,	[msys.cmdparams]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L12790]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
    jmp       L5201
L5202:
    mov       rcx,	[mm_cli.inputfile]
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.outfile],	rax
    mov       rax,	[mm_decls.destfilename]
    test      rax,	rax
    jz        L5204
    mov       rax,	[mm_decls.destfilename]
    mov       [mm_decls.outfile],	rax
L5204:
    mov       rax,	[mm_decls.destfilepath]
    test      rax,	rax
    jz        L5206
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    mov       rdx,	[mm_decls.destfilepath]
    call      strcpy
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      mlib.extractfile
    mov       rcx,	rax
    mov       rdx,	[mm_decls.outfile]
    call      strcat
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.outfile],	rax
L5206:
L5201:
    mov       rcx,	[mm_cli.inputfile]
    xor       edx,	edx
    call      mlib.extractext
    mov       r12,	rax
    mov       rcx,	r12
    call      strlen
    mov       rsi,	rax
    mov       rax,	[msys.cmdparams]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mlib.changeext
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      mlib.convlcstring
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    mov       rdx,	[mm_cli.inputfile]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5208
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	9
    jnz       L5208
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      strlen
    lea       r10,	[rbp + rax + mm_cli.getinputoptions.filespec]
    mov       rax,	rsi
    sub       r10,	rax
    sub       r10,	1
    mov       rcx,	r10
    lea       rdx,	[L12791]
    call      strcpy
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.outfile],	rax
    call      msys.m$print_startcon
    lea       rcx,	[L12792]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.outfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5208:
    movzx     rax,	byte [mm_decls.highmem]
    mov       rcx,	rax
    mov       rdx,	-1
    mov       r8,	[mm_decls.fshortnames]
    call      pc_api.pcl_setflags
    mov       rcx,	[mm_cli.cmdskip]
    xor       edx,	edx
    call      pc_api.pcl_cmdskip
    movzx     rax,	byte [mm_decls.msyslevel]
    cmp       rax,	2
    jnz       L5210
    mov       al,	1
    mov       [pc_api.pfullsys],	al
L5210:
;---------------
    add       rsp,	360
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_option
mm_cli.do_option:
;?>>
   %define R.sw rdi
   %define R.value rbx
   %define R.paramno rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rax,	rdi
    cmp       rax,	1
    jl        L5213
    cmp       rax,	13
    jg        L5213
    mov       rax,	[mm_decls.prodmode]
    test      rax,	rax
    jz        L5215
    lea       rax,	[mm_cli.optionnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[L12793]
    mov       rdx,	rax
    lea       r8,	[L12794]
    call      mm_support.loaderror
L5215:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    mov       [mm_decls.passlevel],	rax
    mov       rax,	1
    mov       [mm_decls.prodmode],	rax
    lea       rax,	[mm_cli.passnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       [mm_cli.outext],	rax
    cmp       rdi,	5
    jnz       L5218
L5217:
    lea       rax,	[rsi-1]
    add       rax,	[msys.$cmdskip]
    mov       [mm_cli.cmdskip],	rax
L5218:
L5216:
    jmp       L5211
L5213:
    mov       rax,	rdi
    cmp       rax,	14
    jl        L5219
    cmp       rax,	21
    jg        L5219
    mov       rax,	[mm_decls.debugmode]
    test      rax,	rax
    jz        L5221
    lea       rcx,	[L12795]
    lea       rdx,	[L12796]
    lea       r8,	[L12796]
    call      mm_support.loaderror
L5221:
    lea       rax,	[rdi-14]
    inc       rax
    mov       [mm_decls.dpasslevel],	rax
    mov       rax,	1
    mov       [mm_decls.debugmode],	rax
    jmp       L5211
L5219:
L5212:
    mov       rax,	rdi
    cmp       rax,	29
    jz        L5223
    cmp       rax,	30
    jz        L5224
    cmp       rax,	31
    jz        L5225
    cmp       rax,	33
    jz        L5226
    cmp       rax,	32
    jz        L5227
    cmp       rax,	34
    jz        L5228
    cmp       rax,	35
    jz        L5229
    cmp       rax,	36
    jz        L5230
    cmp       rax,	41
    jz        L5231
    cmp       rax,	37
    jz        L5232
    cmp       rax,	38
    jz        L5233
    cmp       rax,	39
    jz        L5234
    cmp       rax,	25
    jz        L5235
    cmp       rax,	22
    jz        L5236
    cmp       rax,	23
    jz        L5236
    cmp       rax,	24
    jz        L5236
    cmp       rax,	26
    jz        L5237
    cmp       rax,	27
    jz        L5238
    cmp       rax,	28
    jz        L5239
    cmp       rax,	42
    jz        L5240
    cmp       rax,	43
    jz        L5241
    cmp       rax,	44
    jz        L5241
    cmp       rax,	45
    jz        L5241
    cmp       rax,	46
    jz        L5242
    cmp       rax,	47
    jz        L5242
    cmp       rax,	48
    jz        L5243
    cmp       rax,	49
    jz        L5243
    cmp       rax,	50
    jz        L5244
    cmp       rax,	51
    jz        L5245
    cmp       rax,	52
    jz        L5246
    cmp       rax,	53
    jz        L5247
    cmp       rax,	40
    jz        L5248
    cmp       rax,	54
    jz        L5249
    cmp       rax,	55
    jz        L5249
    jmp       L5250
L5223:
    mov       al,	1
    mov       [mm_decls.fshowast1],	al
    jmp       L5222
L5224:
    mov       al,	1
    mov       [mm_decls.fshowast2],	al
    jmp       L5222
L5225:
    mov       al,	1
    mov       [mm_decls.fshowast3],	al
    jmp       L5222
L5226:
    mov       al,	1
    mov       [mm_decls.fshowpcl],	al
    jmp       L5222
L5227:
    mov       al,	1
    mov       [mm_decls.fshowc],	al
    jmp       L5222
L5228:
    mov       al,	1
    mov       [mm_decls.fshowasm],	al
    jmp       L5222
L5229:
    mov       al,	1
    mov       [mm_decls.fshowst],	al
    jmp       L5222
L5230:
    mov       al,	1
    mov       [mm_decls.fshowstflat],	al
    jmp       L5222
L5231:
    mov       al,	1
    mov       [mm_decls.fshowpst],	al
    jmp       L5222
L5232:
    mov       al,	1
    mov       [mm_decls.fshowtypes],	al
    jmp       L5222
L5233:
    mov       al,	1
    mov       [mm_decls.fshowss],	al
    jmp       L5222
L5234:
    mov       al,	1
    mov       [mm_decls.fshowmodules],	al
    jmp       L5222
L5235:
    mov       al,	1
    mov       [mm_decls.clinux],	al
    jmp       L5222
L5236:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    mov       [mm_decls.msyslevel],	al
    jmp       L5222
L5237:
    xor       eax,	eax
    mov       [pc_decls.fregoptim],	al
    mov       [pc_decls.fpeephole],	al
    jmp       L5222
L5238:
    xor       eax,	eax
    mov       [pc_decls.fpeephole],	al
    jmp       L5222
L5239:
    xor       eax,	eax
    mov       [pc_decls.fregoptim],	al
    jmp       L5222
L5240:
    mov       al,	1
    mov       [mm_decls.fshowtiming],	al
    jmp       L5222
L5241:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    mov       [mm_decls.fverbose],	rax
    jmp       L5222
L5242:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    mov       [pc_decls.pverbose],	al
    jmp       L5222
L5243:
    call      mm_cli.showhelp
    xor       ecx,	ecx
    call      exit
    jmp       L5222
L5244:
    xor       eax,	eax
    mov       [mm_decls.dointlibs],	al
    jmp       L5222
L5245:
    mov       al,	[mm_cli.do_option.outpathused]
    test      al,	al
    jz        L5252
    lea       rcx,	[L12797]
    lea       rdx,	[L12798]
    lea       r8,	[L12798]
    call      mm_support.loaderror
L5252:
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.destfilename],	rax
    mov       al,	1
    mov       [mm_cli.do_option.outused],	al
    jmp       L5222
L5246:
    mov       al,	[mm_cli.do_option.outused]
    test      al,	al
    jz        L5254
    lea       rcx,	[L12799]
    lea       rdx,	[L12800]
    lea       r8,	[L12800]
    call      mm_support.loaderror
L5254:
    mov       rcx,	rbx
    call      strlen
    lea       r10,	[rbx + rax]
    sub       r10,	1
    movzx     r10,	byte [r10]
    cmp       r10,	92
    jz        L5256
    cmp       r10,	47
    jz        L5256
    lea       rcx,	[L12801]
    lea       rdx,	[L12802]
    lea       r8,	[L12802]
    call      mm_support.loaderror
L5256:
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.destfilepath],	rax
    mov       al,	1
    mov       [mm_cli.do_option.outpathused],	al
    jmp       L5222
L5247:
    mov       al,	1
    mov       [mm_decls.fcheckunusedlocals],	al
    jmp       L5222
L5248:
    mov       rax,	1
    mov       [mm_decls.fshortnames],	rax
    jmp       L5222
L5249:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    mov       [mm_decls.highmem],	al
L5250:
L5222:
L5211:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.showcaption
mm_cli.showcaption:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12803]
    call      msys.m$print_str_nf
    lea       rcx,	[L12804]
    call      msys.m$print_str_nf
    lea       rcx,	[L12805]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.showhelp
mm_cli.showhelp:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12806]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.do_writeexports
mm_cli.do_writeexports:
;?>>
    %define mm_cli.do_writeexports.str -304
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
;---------------
    mov       rcx,	[mm_decls.outfile]
    call      mlib.extractbasefile
    lea       rcx,	[rbp + mm_cli.do_writeexports.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mm_cli.do_writeexports.str]
    lea       rdx,	[L12807]
    call      mlib.changeext
    mov       rcx,	[mm_decls.outfile]
    mov       rdx,	rax
    call      mm_export_dummy.writeexports
;---------------
    add       rsp,	336
    pop       rbp
    ret       
;End 
;Proc mm_cli.getoutfilename
mm_cli.getoutfilename:
;?>>
   %define R.file rdi
   %define R.ext rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
L5260:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.fixstartprocs
mm_cli.fixstartprocs:
;?>>
   %define R.ms rdi
   %define R.ps rbx
   %define R.s rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    mov       r12,	1
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L5264
L5262:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	r12
    mov       rbx,	[rax + r10*8]
    movsx     rax,	word [rbx+10]
    test      rax,	rax
    jnz       L5266
    mov       ax,	[rbx+8]
    mov       [rbx+10],	ax
L5266:
    inc       r12
    cmp       r12,	[mm_decls.nsubprogs]
    jle       L5262
L5264:
    mov       r12,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5269
L5267:
    lea       rax,	[mm_decls.modules]
    mov       r10,	r12
    mov       rdi,	[rax + r10*8]
    mov       rax,	[rdi+48]
    test      rax,	rax
    jz        L5271
    movsx     rax,	word [rdi+18]
    mov       r10b,	1
    lea       r11,	[mm_decls.subproghasstart]
    mov       [r11 + rax],	r10b
L5271:
    inc       r12
    cmp       r12,	[mm_decls.nmodules]
    jle       L5267
L5269:
    mov       r12,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5274
L5272:
    lea       rax,	[mm_decls.modules]
    mov       r10,	r12
    mov       rdi,	[rax + r10*8]
    mov       rax,	[rdi+48]
    test      rax,	rax
    jnz       L5276
    movsx     rax,	word [rdi+18]
    mov       rsi,	rax
    lea       rax,	[mm_decls.subproghasstart]
    mov       r10,	rsi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5278
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    movsx     rax,	word [rax+10]
    cmp       rax,	r12
    jnz       L5278
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    lea       rdx,	[L12808]
    mov       r8,	2
    mov       r9,	r12
    call      mm_cli.addstartproc
    mov       [rdi+48],	rax
L5278:
L5276:
    inc       r12
    cmp       r12,	[mm_decls.nmodules]
    jle       L5272
L5274:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.addstartproc
mm_cli.addstartproc:
;?>>
   %define R.owner rbx
   %define R.name rsi
   %define R.scope r12
   %define R.moduleno r13
   %define R.stproc rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	rsi
    call      mm_lex.addnamestr
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	6
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       [rdi+170],	r12b
    mov       [rdi+94],	r13b
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	r13
    mov       al,	[rax + r10]
    mov       [rdi+95],	al
    xor       ecx,	ecx
    call      mm_parse.makeblock
    mov       [rdi+64],	rax
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_lib.adddef
    mov       rcx,	rdi
    call      mm_lib.addtoproclist
    mov       rax,	rdi
L5279:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.codegen_il
mm_genpcl.codegen_il:
;?>>
    %define mm_genpcl.codegen_il.dummy 40
   %define R.d rdi
   %define R.pp rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    xor       ecx,	ecx
    mov       rdx,	[mm_decls.nunits]
    call      pc_api.pcl_start
    call      mm_genpcl.dolibs
    mov       rbx,	[mm_decls.staticlist]
    jmp       L5282
L5281:
    mov       rdi,	[rbx]
    mov       rcx,	rdi
    call      mm_genpcl.dostaticvar
    mov       rbx,	[rbx+8]
L5282:
    test      rbx,	rbx
    jnz       L5281
    lea       rcx,	[L12809]
    call      pc_api.gencomment
    mov       rsi,	1
    mov       rax,	[mm_decls.ndllproctable]
    cmp       rax,	1
    jl        L5286
L5284:
    lea       rax,	[mm_decls.dllproctable]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      mm_genpcl.gendllproc
    inc       rsi
    cmp       rsi,	[mm_decls.ndllproctable]
    jle       L5284
L5286:
    mov       rbx,	[mm_decls.proclist]
    jmp       L5288
L5287:
    mov       rdi,	[rbx]
    mov       rax,	rdi
    mov       r10,	rax
    mov       [mm_decls.currproc],	r10
    mov       rcx,	rax
    call      mm_genpcl.genprocdef
    mov       rbx,	[rbx+8]
L5288:
    test      rbx,	rbx
    jnz       L5287
    call      mm_genpcl.scanprocs
    call      pc_api.pcl_end
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genprocdef
mm_genpcl.genprocdef:
;?>>
   %define R.p rbx
   %define R.ms rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx+94]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       rdi,	r10
    xor       eax,	eax
    mov       [mm_genpcl.pcldoswx],	rax
    mov       rax,	[rdi+56]
    mov       r10,	rbx
    cmp       r10,	rax
    jnz       L5292
    movzx     rax,	byte [rbx+94]
    lea       r10,	[mm_decls.moduletosub]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	[mm_decls.mainsubprogno]
    jnz       L5292
    mov       rcx,	rbx
    call      mm_genpcl.genmaindef
    jmp       L5290
L5292:
    mov       rax,	[rdi+48]
    mov       r10,	rbx
    cmp       r10,	rax
    jnz       L5293
    mov       rcx,	rbx
    call      mm_genpcl.genstartdef
    jmp       L5290
L5293:
L5291:
    mov       eax,	[rbx+88]
    mov       [pc_decls.mmpos],	rax
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_genpcl.doprocdef
    call      mm_genpcl.createfwdlabel
    mov       [mm_genpcl.retindex],	rax
    lea       rcx,	[L12810]
    call      pc_api.gencomment
    movzx     rax,	word [rbx+92]
    shr       eax,	1
    and       eax,	1
    test      rax,	rax
    jz        L5295
    mov       rcx,	126
    xor       edx,	edx
    call      pc_api.pc_gen
    xor       ecx,	ecx
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[pc_api.pccurr]
    mov       [mm_genpcl.pcldoswx],	rax
    xor       ecx,	ecx
    xor       edx,	edx
    call      pc_api.pc_gen
L5295:
    mov       rcx,	[rbx+64]
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12810]
    call      pc_api.gencomment
    mov       rcx,	[mm_genpcl.retindex]
    call      mm_genpcl.definefwdlabel
    call      mm_genpcl.genreturn
    call      pc_api.pc_endproc
L5290:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.gendllproc
mm_genpcl.gendllproc:
;?>>
   %define R.p rbx
   %define R.e rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_setimport
    mov       rdi,	[rbx+16]
    jmp       L5300
L5297:
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_addparam
    mov       rdi,	[rdi+32]
L5300:
    test      rdi,	rdi
    jnz       L5297
    xor       ecx,	ecx
    call      pc_api.pc_setimport
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.dolibs
mm_genpcl.dolibs:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	1
    jl        L5304
L5302:
    lea       rax,	[mm_decls.libfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L5306
    lea       rax,	[mm_decls.libfiles]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      pc_api.pc_addplib
L5306:
    inc       rdi
    cmp       rdi,	[mm_decls.nlibfiles]
    jle       L5302
L5304:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.dostaticvar
mm_genpcl.dostaticvar:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	word [rdi+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jnz       L5307
L5309:
    movzx     rax,	byte [rdi+170]
    cmp       rax,	2
    jnz       L5311
    mov       rax,	[rdi]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jnz       L5311
    mov       rax,	[rdi]
    mov       rcx,	rax
    lea       rdx,	[L12811]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5313
    mov       al,	3
    mov       [rdi+170],	al
L5313:
L5311:
    movzx     rax,	word [rdi+92]
    shr       eax,	8
    and       eax,	1
    cmp       rax,	1
    jz        L5307
L5315:
    mov       rax,	[rdi+64]
    test      rax,	rax
    jz        L5316
    mov       rcx,	rdi
    call      mm_genpcl.genmem_d
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_lib.getalignment
    mov       rcx,	rax
    call      pc_api.pc_setalign
    mov       rax,	[rdi+64]
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	65
    xor       r9d,	r9d
    call      mm_genpcl.genidata
    jmp       L5314
L5316:
;mm_genpcl.dostaticvar.dozstatic:
    mov       rcx,	rdi
    call      mm_genpcl.genmem_d
    mov       rcx,	124
    mov       rdx,	rax
    call      pc_api.pc_gen
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_lib.getalignment
    mov       rcx,	rax
    call      pc_api.pc_setalign
L5314:
L5307:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genidata
mm_genpcl.genidata:
;?>>
   %define R.p r14
    %define mm_genpcl.genidata.doterm 72
    %define mm_genpcl.genidata.am 80
    %define mm_genpcl.genidata.offset 88
    %define mm_genpcl.genidata.data -2000
   %define R.t rdi
   %define R.tbase rbx
   %define R.allbytes sil
   %define R.nbytes r12b
   %define R.q r13
    %define mm_genpcl.genidata.d -2008
    %define mm_genpcl.genidata.$T1 -2016
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2048
    mov       r14,	rcx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movsxd    rax,	dword [r14+49]
    mov       rdi,	rax
    mov       eax,	[r14+4]
    mov       [pc_decls.mmpos],	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jz        L5320
    cmp       rax,	20
    jz        L5321
    cmp       rax,	4
    jz        L5322
    cmp       rax,	58
    jz        L5323
    cmp       rax,	59
    jz        L5324
    cmp       rax,	55
    jz        L5325
    cmp       rax,	56
    jz        L5325
    jmp       L5326
L5320:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5328
    cmp       rdi,	20
    jnz       L5330
    mov       rax,	[r14+16]
    test      rax,	rax
    jz        L5332
    movzx     rax,	byte [r14+45]
    cmp       rax,	66
    jnz       L5334
    lea       rcx,	[L12812]
    xor       edx,	edx
    call      mm_support.gerror
L5334:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      pc_api.genstring
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5331
L5332:
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
L5331:
    jmp       L5329
L5330:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
L5329:
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5327
L5328:
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5335
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    movq      XMM4,	[r14+16]
    movq      XMM0,	XMM4
    mov       rdx,	rax
    call      pc_api.genrealimm
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode
    jmp       L5327
L5335:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jnz       L5336
    movzx     rax,	byte [r14+45]
    test      rax,	rax
    jnz       L5338
    lea       rcx,	[L12813]
    xor       edx,	edx
    call      mm_support.gerror
L5338:
    mov       eax,	[r14+40]
    mov       r10,	[r14+16]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.gendata
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5327
L5336:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
L5327:
    jmp       L5319
L5321:
    mov       r13,	[r14+16]
    mov       sil,	1
    xor       r12b,	r12b
    jmp       L5342
L5339:
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jnz       L5344
    movsxd    rax,	dword [r13+49]
    cmp       rax,	17
    jnz       L5344
    movzx     rax,	r12b
    cmp       rax,	2000
    jge       L5344
    mov       rax,	[r13+16]
    inc       r12b
    mov       r10b,	r12b
    movzx     r11,	r10b
    mov       [rbp + r11 + mm_genpcl.genidata.data-1],	al
    jmp       L5343
L5344:
    xor       sil,	sil
    jmp       L5341
L5343:
    mov       r13,	[r13+8]
L5342:
    test      r13,	r13
    jnz       L5339
L5341:
    test      sil,	sil
    jz        L5346
    test      r12b,	r12b
    jz        L5346
    movzx     rax,	r12b
    mov       [rbp + mm_genpcl.genidata.$T1],	rax
    movzx     rax,	r12b
    lea       rcx,	[rbp + mm_genpcl.genidata.data]
    mov       rdx,	rax
    call      mlib.pcm_copyheapstringn
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_genpcl.genidata.$T1]
    call      pc_api.gendata
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5345
L5346:
    mov       r13,	[r14+16]
    jmp       L5350
L5347:
    mov       rcx,	r13
    mov       rdx,	1
    mov       r8,	65
    xor       r9d,	r9d
    call      mm_genpcl.genidata
    mov       r13,	[r13+8]
L5350:
    test      r13,	r13
    jnz       L5347
L5345:
    jmp       L5319
L5322:
    mov       rax,	[r14+16]
    mov       [rbp + mm_genpcl.genidata.d],	rax
    mov       rax,	[rbp + mm_genpcl.genidata.d]
    movzx     rax,	byte [rax+78]
    cmp       rax,	10
    jz        L5352
    cmp       rax,	6
    jz        L5352
    cmp       rax,	7
    jz        L5352
    cmp       rax,	14
    jz        L5353
    jmp       L5354
L5352:
    mov       rcx,	[rbp + mm_genpcl.genidata.d]
    call      mm_genpcl.genmemaddr_d
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_genpcl.genidata.offset]
    test      rax,	rax
    jz        L5356
    mov       rcx,	1
    mov       rdx,	[rbp + mm_genpcl.genidata.offset]
    call      pc_api.pc_setscaleoff
L5356:
    mov       rax,	[rbp + mm_genpcl.genidata.am]
    cmp       rax,	80
    jnz       L5358
    mov       rcx,	4
    call      mm_libpcl.setmode
    jmp       L5357
L5358:
    mov       rcx,	rdi
    call      mm_libpcl.setmode
L5357:
    jmp       L5351
L5353:
    mov       rax,	[rbp + mm_genpcl.genidata.d]
    movsxd    rax,	dword [rax+80]
    test      rax,	rax
    jnz       L5360
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       r10,	[rbp + mm_genpcl.genidata.d]
    mov       [r10+80],	eax
L5360:
    mov       rax,	[rbp + mm_genpcl.genidata.d]
    movsxd    rax,	dword [rax+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5351
L5354:
    lea       rcx,	[L12814]
    xor       edx,	edx
    call      mm_support.gerror
L5351:
    jmp       L5318
L5323:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	65
    xor       r9d,	r9d
    call      mm_genpcl.genidata
    jmp       L5319
L5324:
    mov       rax,	[r14+16]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode
    jmp       L5319
L5325:
    mov       rax,	[r14+24]
    test      rax,	rax
    jz        L5362
    mov       rax,	[r14+24]
    mov       rax,	[rax+16]
    jmp       L5361
L5362:
    xor       eax,	eax
L5361:
    mov       r10,	[r14+16]
    mov       rcx,	r10
    mov       rdx,	1
    mov       r8,	80
    mov       r9,	rax
    call      mm_genpcl.genidata
    jmp       L5319
L5326:
    movzx     rax,	byte [r14]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12815]
    mov       rdx,	r10
    mov       r8,	r14
    call      mm_support.gerror_s
L5319:
L5318:
;---------------
    add       rsp,	2048
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genmem_u
mm_genpcl.genmem_u:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmem
L5363:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genmem_d
mm_genpcl.genmem_d:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmem
L5364:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushmem_d
mm_genpcl.genpushmem_d:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmem
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genmemaddr_d
mm_genpcl.genmemaddr_d:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
L5366:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushmemaddr_d
mm_genpcl.genpushmemaddr_d:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.definelabel
mm_genpcl.definelabel:
;?>>
;?]]
    sub       rsp,	40
;---------------
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[pc_api.mlabelno]
L5368:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_genpcl.createfwdlabel
mm_genpcl.createfwdlabel:
;?>>
;?]]
;---------------
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
L5369:
;---------------
    ret       
;End 
;Proc mm_genpcl.definefwdlabel
mm_genpcl.definefwdlabel:
;?>>
   %define R.lab rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genreturn
mm_genpcl.genreturn:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+122]
    test      rax,	rax
    jz        L5373
    cmp       rax,	1
    jz        L5374
    jmp       L5375
L5373:
    mov       rcx,	20
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L5372
L5374:
    mov       rcx,	23
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    jmp       L5372
L5375:
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+122]
    mov       rcx,	23
    mov       rdx,	rax
    xor       r8d,	r8d
    call      pc_api.pc_genx
L5372:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_genpcl.reversecond
mm_genpcl.reversecond:
;?>>
   %define R.cc rcx
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L5378
    cmp       rax,	2
    jz        L5379
    cmp       rax,	3
    jz        L5380
    cmp       rax,	4
    jz        L5381
    cmp       rax,	5
    jz        L5382
    cmp       rax,	6
    jz        L5383
    jmp       L5384
L5378:
    mov       rax,	2
    mov       rcx,	rax
    jmp       L5377
L5379:
    mov       rax,	1
    mov       rcx,	rax
    jmp       L5377
L5380:
    mov       rax,	5
    mov       rcx,	rax
    jmp       L5377
L5381:
    mov       rax,	6
    mov       rcx,	rax
    jmp       L5377
L5382:
    mov       rax,	3
    mov       rcx,	rax
    jmp       L5377
L5383:
    mov       rax,	4
    mov       rcx,	rax
L5384:
L5377:
    mov       rax,	rcx
L5376:
;---------------
    ret       
;End 
;Proc mm_genpcl.reversecond_order
mm_genpcl.reversecond_order:
;?>>
   %define R.cc rcx
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L5387
    cmp       rax,	2
    jz        L5388
    cmp       rax,	3
    jz        L5389
    cmp       rax,	4
    jz        L5390
    cmp       rax,	5
    jz        L5391
    cmp       rax,	6
    jz        L5392
    jmp       L5393
L5387:
    mov       rax,	1
    mov       rcx,	rax
    jmp       L5386
L5388:
    mov       rax,	2
    mov       rcx,	rax
    jmp       L5386
L5389:
    mov       rax,	6
    mov       rcx,	rax
    jmp       L5386
L5390:
    mov       rax,	5
    mov       rcx,	rax
    jmp       L5386
L5391:
    mov       rax,	4
    mov       rcx,	rax
    jmp       L5386
L5392:
    mov       rax,	3
    mov       rcx,	rax
L5393:
L5386:
    mov       rax,	rcx
L5385:
;---------------
    ret       
;End 
;Proc mm_genpcl.stacklooplabels
mm_genpcl.stacklooplabels:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    inc       qword [mm_genpcl.loopindex]
    mov       rax,	[mm_genpcl.loopindex]
    cmp       rax,	50
    jle       L5396
    lea       rcx,	[L12816]
    xor       edx,	edx
    call      mm_support.gerror
L5396:
    lea       rax,	[mm_genpcl.loopstack]
    mov       r10,	[mm_genpcl.loopindex]
    shl       r10,	5
    lea       rax,	[rax + r10-32]
    mov       r10,	rdi
    mov       [rax],	r10
    lea       rax,	[mm_genpcl.loopstack]
    mov       r10,	[mm_genpcl.loopindex]
    shl       r10,	5
    lea       rax,	[rax + r10-32]
    mov       r10,	rbx
    mov       [rax+8],	r10
    lea       rax,	[mm_genpcl.loopstack]
    mov       r10,	[mm_genpcl.loopindex]
    shl       r10,	5
    lea       rax,	[rax + r10-32]
    mov       r10,	rsi
    mov       [rax+16],	r10
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.findlooplabel
mm_genpcl.findlooplabel:
;?>>
   %define R.k rbx
   %define R.n rsi
   %define R.i rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rax,	[rsi-1]
    mov       r10,	[mm_genpcl.loopindex]
    sub       r10,	rax
    mov       rdi,	r10
    cmp       rdi,	1
    jl        L5400
    cmp       rdi,	[mm_genpcl.loopindex]
    jle       L5399
L5400:
    lea       rcx,	[L12817]
    xor       edx,	edx
    call      mm_support.gerror
L5399:
    lea       rax,	[mm_genpcl.loopstack]
    mov       r10,	rdi
    shl       r10,	5
    lea       rax,	[rax + r10-32]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
L5397:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpc_sysfn
mm_genpcl.genpc_sysfn:
;?>>
   %define R.fnindex rdi
   %define R.a rbx
   %define R.b rsi
   %define R.c r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    sub       rsp,	8
    push      1
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
;---------------
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpc_sysproc
mm_genpcl.genpc_sysproc:
;?>>
   %define R.fnindex r12
   %define R.a r13
   %define R.b r14
    %define mm_genpcl.genpc_sysproc.c 88
    %define mm_genpcl.genpc_sysproc.asfunc 96
    %define mm_genpcl.genpc_sysproc.nargs -8
   %define R.opc rdi
   %define R.d rbx
   %define R.p rsi
    %define mm_genpcl.genpc_sysproc.$T1 -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mm_genpcl.genpc_sysproc.nargs],	rax
    xor       rdi,	rdi
    mov       rcx,	131
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rsi,	[pc_api.pccurr]
    mov       rcx,	[rbp + mm_genpcl.genpc_sysproc.c]
    mov       rdx,	3
    lea       r8,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    call      mm_genpcl.pushsysarg
    mov       rcx,	r14
    mov       rdx,	2
    lea       r8,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    call      mm_genpcl.pushsysarg
    mov       rcx,	r13
    mov       rdx,	1
    lea       r8,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    call      mm_genpcl.pushsysarg
    mov       eax,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    mov       [rsi+16],	eax
    mov       rcx,	r12
    call      mm_genpcl.getsysfnhandler
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L5404
    mov       rcx,	rbx
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
    mov       [rbp + mm_genpcl.genpc_sysproc.$T1],	rax
    mov       rax,	[rbp + mm_genpcl.genpc_sysproc.asfunc]
    test      rax,	rax
    jz        L5406
    mov       rax,	21
    jmp       L5405
L5406:
    mov       rax,	18
L5405:
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_genpcl.genpc_sysproc.$T1]
    call      pc_api.pc_gen
    mov       rcx,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    call      pc_api.pc_setnargs
    jmp       L5403
L5404:
    lea       rax,	[mm_tables.sysfnnames]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+3]
    mov       rcx,	rax
    call      pc_api.gennameaddr
    mov       [rbp + mm_genpcl.genpc_sysproc.$T1],	rax
    mov       rax,	[rbp + mm_genpcl.genpc_sysproc.asfunc]
    test      rax,	rax
    jz        L5408
    mov       rax,	21
    jmp       L5407
L5408:
    mov       rax,	18
L5407:
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_genpcl.genpc_sysproc.$T1]
    call      pc_api.pc_gen
L5403:
    mov       eax,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.pushsysarg
mm_genpcl.pushsysarg:
;?>>
   %define R.p rdi
   %define R.n rbx
   %define R.nargs rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    test      rdi,	rdi
    jz        L5411
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	132
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       eax,	ebx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	ebx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
    mov       rax,	rsi
    inc       qword [rax]
L5411:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.start
mm_genpcl.start:
;?>>
;?]]
;---------------
    mov       al,	1
    lea       r10,	[mm_genpcl.zero_unit]
    mov       [r10],	al
    mov       eax,	3
    lea       r10,	[mm_genpcl.zero_unit]
    mov       [r10+49],	eax
    xor       eax,	eax
    lea       r10,	[mm_genpcl.zero_unit]
    mov       [r10+16],	rax
    mov       al,	1
    lea       r10,	[mm_genpcl.zero_unit]
    mov       [r10+61],	al
;---------------
    ret       
;End 
;Proc mm_genpcl.getsysfnhandler
mm_genpcl.getsysfnhandler:
;?>>
   %define R.fn r12
   %define R.p rdi
    %define mm_genpcl.getsysfnhandler.str -304
   %define R.report rbx
   %define R.pp rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
    mov       r12,	rcx
;---------------
    lea       rax,	[mm_tables.sysfnhandlers]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jz        L5415
    lea       rax,	[mm_tables.sysfnhandlers]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    jmp       L5413
L5415:
    lea       rcx,	[rbp + mm_genpcl.getsysfnhandler.str]
    lea       rdx,	[L12818]
    call      strcpy
    lea       rax,	[mm_tables.sysfnnames]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+3]
    lea       rcx,	[rbp + mm_genpcl.getsysfnhandler.str]
    mov       rdx,	rax
    call      strcat
    mov       rsi,	[mm_decls.proclist]
    jmp       L5419
L5416:
    mov       rax,	[rsi]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_genpcl.getsysfnhandler.str]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5421
    mov       rax,	[rsi]
    lea       r10,	[mm_tables.sysfnhandlers]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rsi]
    jmp       L5413
L5421:
    mov       rsi,	[rsi+8]
L5419:
    test      rsi,	rsi
    jnz       L5416
    mov       rbx,	1
    xor       rbx,	rbx
    mov       rax,	rbx
    test      rax,	rax
    jz        L5423
    call      msys.m$print_startcon
    lea       rcx,	[L12819]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mm_genpcl.getsysfnhandler.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5423:
    cmp       r12,	33
    jz        L5425
    mov       rcx,	33
    call      mm_genpcl.getsysfnhandler
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L5427
    test      rbx,	rbx
    jz        L5427
    lea       rcx,	[L12820]
    xor       edx,	edx
    call      mm_support.gerror
L5427:
    mov       rax,	rdi
    jmp       L5413
L5425:
    xor       eax,	eax
L5413:
;---------------
    add       rsp,	336
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.findhostfn
mm_genpcl.findhostfn:
;?>>
   %define R.opc rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    cmp       rdi,	82
    jnz       L5431
L5430:
    mov       rcx,	32
    call      mm_genpcl.getsysfnhandler
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    jmp       L5429
L5431:
    xor       eax,	eax
L5429:
L5428:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushint
mm_genpcl.genpushint:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushreal
mm_genpcl.genpushreal:
;?>>
   %define R.x XMM15
   %define R.mode rdi
    push      rdi
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	40
    movq      XMM15,	XMM0
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    movq      XMM0,	XMM15
    mov       rdx,	rax
    call      pc_api.genreal
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushstring
mm_genpcl.genpushstring:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_api.genstring
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genmaindef
mm_genpcl.genmaindef:
;?>>
   %define R.p rsi
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       eax,	[rsi+88]
    mov       [pc_decls.mmpos],	rax
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_genpcl.doprocdef
    call      mm_genpcl.createfwdlabel
    mov       [mm_genpcl.retindex],	rax
    mov       rbx,	1
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L5438
L5436:
    cmp       rbx,	[mm_decls.mainsubprogno]
    jz        L5440
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    movsx     rax,	word [rax+10]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+48]
    mov       rdi,	r10
    mov       rcx,	rdi
    call      mm_genpcl.docallproc
L5440:
    inc       rbx
    cmp       rbx,	[mm_decls.nsubprogs]
    jle       L5436
L5438:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	[mm_decls.mainsubprogno]
    mov       rax,	[rax + r10*8]
    movsx     rax,	word [rax+10]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+48]
    mov       rdi,	r10
    mov       rcx,	rdi
    call      mm_genpcl.docallproc
    lea       rcx,	[L12821]
    call      pc_api.gencomment
    mov       rcx,	[rsi+64]
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12821]
    call      pc_api.gencomment
    mov       rcx,	[mm_genpcl.retindex]
    call      mm_genpcl.definefwdlabel
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	32
    xor       edx,	edx
    call      pc_api.pc_gen
    call      mm_genpcl.genreturn
    call      pc_api.pc_endproc
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genstartdef
mm_genpcl.genstartdef:
;?>>
   %define R.p r14
   %define R.d rdi
   %define R.lead rbx
   %define R.m rsi
   %define R.s r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    xor       rbx,	rbx
    movzx     rax,	byte [r14+94]
    mov       rsi,	rax
    movzx     rax,	byte [r14+95]
    mov       r12,	rax
    cmp       r12,	[mm_decls.mainsubprogno]
    jnz       L5443
    movzx     rax,	byte [r14+94]
    lea       r10,	[mm_decls.subprogs]
    mov       r11,	r12
    mov       r10,	[r10 + r11*8]
    movsx     r10,	word [r10+10]
    cmp       rax,	r10
    jnz       L5443
    mov       rbx,	1
    jmp       L5442
L5443:
    movzx     rax,	byte [r14+94]
    lea       r10,	[mm_decls.subprogs]
    mov       r11,	r12
    mov       r10,	[r10 + r11*8]
    movsx     r10,	word [r10+8]
    cmp       rax,	r10
    jnz       L5444
    mov       rbx,	2
L5444:
L5442:
    mov       eax,	[r14+88]
    mov       [pc_decls.mmpos],	rax
    mov       rcx,	r14
    xor       edx,	edx
    call      mm_genpcl.doprocdef
    call      mm_genpcl.createfwdlabel
    mov       [mm_genpcl.retindex],	rax
    test      rbx,	rbx
    jz        L5446
    mov       r13,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5449
L5447:
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10]
    cmp       rax,	r12
    jnz       L5451
    cmp       r13,	rsi
    jz        L5451
    lea       rax,	[mm_decls.modules]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    mov       rdi,	[rax+48]
    mov       rcx,	rdi
    call      mm_genpcl.docallproc
L5451:
    inc       r13
    cmp       r13,	[mm_decls.nmodules]
    jle       L5447
L5449:
L5446:
    lea       rcx,	[L12821]
    call      pc_api.gencomment
    mov       rcx,	[r14+64]
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12821]
    call      pc_api.gencomment
    mov       rcx,	[mm_genpcl.retindex]
    call      mm_genpcl.definefwdlabel
    call      mm_genpcl.genreturn
    call      pc_api.pc_endproc
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.initstaticvar
mm_genpcl.initstaticvar:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+64]
    test      rax,	rax
    jz        L5454
    mov       rcx,	[rdi+64]
    call      mm_blockpcl.evalunit
L5454:
    mov       rcx,	rdi
    call      mm_genpcl.genmem_d
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.docallproc
mm_genpcl.docallproc:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jnz       L5457
    jmp       L5455
L5457:
    mov       rcx,	131
    xor       edx,	edx
    call      pc_api.pc_gen
    xor       ecx,	ecx
    call      pc_api.pc_setnargs
    mov       rcx,	rdi
    call      mm_genpcl.genmemaddr_d
    mov       rcx,	18
    mov       rdx,	rax
    call      pc_api.pc_gen
L5455:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.doprocdef
mm_genpcl.doprocdef:
;?>>
   %define R.d rsi
   %define R.ismain r12
   %define R.p rdi
   %define R.e rbx
    %define mm_genpcl.doprocdef.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [rsi+124]
    mov       [rbp + mm_genpcl.doprocdef.$T1],	rax
    mov       rcx,	rsi
    call      mm_libpcl.getpsymbol
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r12
    mov       r9,	[rbp + mm_genpcl.doprocdef.$T1]
    call      pc_api.pc_defproc
    mov       rbx,	[rsi+16]
    jmp       L5462
L5459:
    movzx     rax,	byte [rbx+78]
    cmp       rax,	12
    jz        L5464
    cmp       rax,	11
    jz        L5465
    jmp       L5466
L5464:
    mov       rcx,	rbx
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_addparam
    jmp       L5463
L5465:
    movzx     rax,	word [rbx+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L5469
    mov       rax,	[rbx+96]
    test      rax,	rax
    jnz       L5468
L5469:
    mov       rcx,	rbx
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_addlocal
L5468:
L5466:
L5463:
    mov       rbx,	[rbx+32]
L5462:
    test      rbx,	rbx
    jnz       L5459
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.scanprocs
mm_genpcl.scanprocs:
;?>>
    %define mm_genpcl.scanprocs.proctable -8000
   %define R.currpcl rdi
   %define R.nprocs rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8040
;---------------
    xor       rbx,	rbx
    mov       rax,	[pc_api.pcstart]
    mov       rdi,	rax
L5471:
    movzx     rax,	byte [rdi]
    cmp       rax,	120
    jz        L5476
    cmp       rax,	121
    jnz       L5475
L5476:
    mov       rax,	[rdi+8]
    mov       al,	[rax+109]
    test      al,	al
    jz        L5475
    cmp       rbx,	1000
    jl        L5478
    lea       rcx,	[L12822]
    xor       edx,	edx
    call      mm_support.gerror
L5478:
    mov       rax,	[rdi+8]
    inc       rbx
    mov       r10,	rbx
    mov       [rbp + r10*8 + mm_genpcl.scanprocs.proctable-8],	rax
L5475:
    add       rdi,	32
    cmp       rdi,	[pc_api.pccurr]
    jbe       L5471
    test      rbx,	rbx
    jnz       L5480
    mov       rax,	[mm_blockpcl.pnprocs]
    test      rax,	rax
    jnz       L5480
    lea       rcx,	[L12823]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       [mm_blockpcl.pnprocs],	rax
    mov       al,	10
    mov       r10,	[mm_blockpcl.pnprocs]
    mov       [r10+82],	al
    jmp       L5481
L5480:
    call      mm_genpcl.setfunctab
    mov       rcx,	[mm_blockpcl.pprocaddr]
    call      pc_api.genmem
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       al,	11
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    mov       rax,	rbx
    shl       rax,	3
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    mov       al,	11
    mov       r10,	[mm_blockpcl.pprocaddr]
    mov       [r10+82],	al
    mov       rax,	[pc_api.pccurr]
    mov       eax,	[rax+4]
    mov       r10,	[mm_blockpcl.pprocaddr]
    mov       [r10+84],	eax
    mov       rsi,	1
    cmp       rbx,	1
    jl        L5484
L5482:
    mov       rax,	[rbp + rsi*8 + mm_genpcl.scanprocs.proctable-8]
    mov       rcx,	rax
    call      pc_api.genmemaddr
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    inc       rsi
    cmp       rsi,	rbx
    jle       L5482
L5484:
    mov       rcx,	[mm_blockpcl.pprocname]
    call      pc_api.genmem
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       al,	11
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    mov       rax,	rbx
    shl       rax,	3
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    mov       al,	11
    mov       r10,	[mm_blockpcl.pprocname]
    mov       [r10+82],	al
    mov       rax,	[pc_api.pccurr]
    mov       eax,	[rax+4]
    mov       r10,	[mm_blockpcl.pprocname]
    mov       [r10+84],	eax
    mov       rsi,	1
    cmp       rbx,	1
    jl        L5487
L5485:
    mov       rax,	[rbp + rsi*8 + mm_genpcl.scanprocs.proctable-8]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    call      pc_api.genstring
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    inc       rsi
    cmp       rsi,	rbx
    jle       L5485
L5487:
;mm_genpcl.scanprocs.finish:
L5481:
    mov       rcx,	[mm_blockpcl.pnprocs]
    call      pc_api.genmem
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	8040
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.setfunctab
mm_genpcl.setfunctab:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mm_blockpcl.pnprocs]
    test      rax,	rax
    jnz       L5490
    lea       rcx,	[L12823]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       [mm_blockpcl.pnprocs],	rax
    mov       al,	10
    mov       r10,	[mm_blockpcl.pnprocs]
    mov       [r10+82],	al
    lea       rcx,	[L12824]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       [mm_blockpcl.pprocname],	rax
    lea       rcx,	[L12825]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       [mm_blockpcl.pprocaddr],	rax
L5490:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_libpcl.getpsymbol
mm_libpcl.getpsymbol:
;?>>
   %define R.d r13
   %define R.p rdi
   %define R.e rbx
    %define mm_libpcl.getpsymbol.str -256
    %define mm_libpcl.getpsymbol.chain -384
   %define R.n rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	424
    mov       r13,	rcx
;---------------
    test      r13,	r13
    jnz       L5493
    xor       eax,	eax
    jmp       L5491
L5493:
    mov       rax,	[r13+56]
    test      rax,	rax
    jz        L5495
    mov       rax,	[r13+56]
    jmp       L5491
L5495:
    movzx     rax,	word [r13+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L5497
    mov       rax,	[r13+96]
    test      rax,	rax
    jz        L5497
    mov       rcx,	r13
    call      mm_libpcl.getequivdef
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rax,	[rbx+56]
    mov       [r13+56],	rax
    mov       rax,	[rbx+56]
    jmp       L5491
L5497:
    movzx     rax,	byte [r13+78]
    cmp       rax,	11
    jz        L5500
    cmp       rax,	12
    jz        L5500
    movzx     rax,	word [r13+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L5499
L5500:
    mov       rax,	[r13+104]
    test      rax,	rax
    jz        L5502
    mov       rax,	[r13+104]
    jmp       L5501
L5502:
    mov       rax,	[r13]
L5501:
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L5498
L5499:
    mov       rbx,	r13
    xor       rsi,	rsi
L5503:
    inc       rsi
    mov       rax,	rsi
    mov       r10,	rbx
    mov       [rbp + rax*8 + mm_libpcl.getpsymbol.chain-8],	r10
    mov       rbx,	[rbx+8]
    test      rbx,	rbx
    jz        L5506
    movzx     rax,	byte [rbx+78]
    cmp       rax,	1
    jnz       L5503
L5506:
    mov       rax,	[rbp + rsi*8 + mm_libpcl.getpsymbol.chain-8]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcpy
    lea       rax,	[rsi-1]
    mov       r12,	rax
    cmp       r12,	1
    jl        L5509
L5507:
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    lea       rdx,	[L12826]
    call      strcat
    mov       rax,	[rbp + r12*8 + mm_libpcl.getpsymbol.chain-8]
    mov       rax,	[rax+104]
    test      rax,	rax
    jz        L5511
    mov       rax,	[rbp + r12*8 + mm_libpcl.getpsymbol.chain-8]
    mov       rax,	[rax+104]
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcat
    jmp       L5510
L5511:
    mov       rax,	[rbp + r12*8 + mm_libpcl.getpsymbol.chain-8]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcat
L5510:
    dec       r12
    cmp       r12,	1
    jge       L5507
L5509:
L5498:
    movzx     rax,	byte [r13+78]
    lea       r10,	[mm_tables.name2pid]
    movzx     r10,	byte [r10 + rax]
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	r10
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       [r13+56],	rax
    movsxd    rax,	dword [r13+72]
    mov       rcx,	rax
    call      mm_lib.getpclmode
    mov       [rdi+82],	al
    movsxd    rax,	dword [r13+72]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       [rdi+84],	r10d
    mov       rax,	[r13+8]
    test      rax,	rax
    jz        L5513
    mov       rax,	[r13+8]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L5513
    mov       rax,	[r13+8]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       [rdi+32],	rax
L5513:
    movzx     rax,	byte [r13+170]
    cmp       rax,	3
    jnz       L5515
    mov       al,	1
    mov       [rdi+81],	al
L5515:
    movzx     rax,	byte [r13+78]
    cmp       rax,	7
    jz        L5518
    cmp       rax,	8
    jnz       L5517
L5518:
    mov       al,	1
    mov       [rdi+80],	al
L5517:
    mov       ax,	[r13+168]
    mov       [rdi+92],	al
    mov       eax,	[r13+80]
    mov       [rdi+100],	eax
    movzx     rax,	word [r13+92]
    shr       eax,	6
    and       eax,	1
    mov       [rdi+109],	al
    mov       al,	[r13+124]
    mov       [rdi+108],	al
    mov       al,	[r13+123]
    mov       [rdi+107],	al
    mov       rbx,	[r13+8]
    xor       eax,	eax
    test      ax,	ax
    jz        L5520
    movzx     rax,	byte [r13+78]
    cmp       rax,	10
    jnz       L5520
    test      rbx,	rbx
    jz        L5520
    movzx     rax,	byte [rbx+78]
    cmp       rax,	6
    jnz       L5520
    mov       rax,	[r13+64]
    test      rax,	rax
    jz        L5520
    mov       rax,	[rbx+56]
    mov       [rdi+56],	rax
    mov       rax,	[rbx+56]
    lea       rax,	[rax+104]
    or        byte [rax],	2
L5520:
    mov       rax,	rdi
L5491:
;---------------
    add       rsp,	424
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_libpcl.setmode
mm_libpcl.setmode:
;?>>
   %define R.mode rdi
    %define mm_libpcl.setmode.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    mov       [rbp + mm_libpcl.setmode.$T1],	rax
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_libpcl.setmode.$T1]
    call      pc_api.pc_setmode
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_libpcl.setmode2
mm_libpcl.setmode2:
;?>>
   %define R.mode rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    mov       rcx,	rax
    call      pc_api.pc_setmode2
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_libpcl.setmode_u
mm_libpcl.setmode_u:
;?>>
   %define R.p rbx
   %define R.mode rdi
    %define mm_libpcl.setmode_u.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    mov       [rbp + mm_libpcl.setmode_u.$T1],	rax
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_libpcl.setmode_u.$T1]
    call      pc_api.pc_setmode
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_libpcl.getequivdef
mm_libpcl.getequivdef:
;?>>
   %define R.d rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+96]
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jz        L5526
    cmp       rax,	58
    jz        L5527
    jmp       L5528
L5526:
    mov       rax,	[rdi+16]
    jmp       L5525
L5527:
    mov       rax,	[rdi+16]
    mov       rax,	[rax+16]
    jmp       L5525
L5528:
    lea       rcx,	[L12827]
    xor       edx,	edx
    call      mm_support.gerror
    xor       eax,	eax
L5525:
L5524:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.evalunit
mm_blockpcl.evalunit:
;?>>
   %define R.p r12
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    test      r12,	r12
    jnz       L5531
    jmp       L5529
L5531:
    mov       eax,	[r12+4]
    mov       [pc_decls.mmpos],	rax
    mov       rdi,	[r12+16]
    mov       rbx,	[r12+24]
    mov       rsi,	[r12+32]
    movzx     rax,	byte [r12]
    sub       rax,	1
    cmp       rax,	122
    jae       L5534
    lea       r10,	[L5533]
    jmp       [r10 + rax*8]
    segment .data
L5533:
    dq  L5535
    dq  L5536
    dq  L5534
    dq  L5537
    dq  L5534
    dq  L5538
    dq  L5534
    dq  L5599
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5601
    dq  L5572
    dq  L5573
    dq  L5589
    dq  L5590
    dq  L5591
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5541
    dq  L5534
    dq  L5534
    dq  L5542
    dq  L5544
    dq  L5543
    dq  L5545
    dq  L5539
    dq  L5574
    dq  L5575
    dq  L5576
    dq  L5588
    dq  L5534
    dq  L5596
    dq  L5597
    dq  L5592
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5577
    dq  L5534
    dq  L5602
    dq  L5580
    dq  L5534
    dq  L5578
    dq  L5579
    dq  L5581
    dq  L5534
    dq  L5582
    dq  L5583
    dq  L5534
    dq  L5584
    dq  L5586
    dq  L5534
    dq  L5585
    dq  L5587
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5534
    dq  L5540
    dq  L5598
    dq  L5546
    dq  L5547
    dq  L5548
    dq  L5549
    dq  L5550
    dq  L5551
    dq  L5552
    dq  L5553
    dq  L5554
    dq  L5555
    dq  L5556
    dq  L5557
    dq  L5558
    dq  L5559
    dq  L5560
    dq  L5561
    dq  L5562
    dq  L5562
    dq  L5562
    dq  L5562
    dq  L5564
    dq  L5565
    dq  L5563
    dq  L5566
    dq  L5566
    dq  L5567
    dq  L5567
    dq  L5568
    dq  L5569
    dq  L5570
    dq  L5571
    dq  L5600
    segment .text
L5535:
    mov       rcx,	r12
    call      mm_blockpcl.do_const
    jmp       L5532
L5536:
    jmp       L5532
L5537:
    mov       rcx,	r12
    call      mm_blockpcl.do_name
    jmp       L5532
L5538:
    mov       rcx,	r12
    call      mm_blockpcl.do_block
    jmp       L5532
L5539:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_callproc
    jmp       L5532
L5540:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_return
    jmp       L5532
L5541:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_returnmult
    jmp       L5532
L5542:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_assign
    jmp       L5532
L5543:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignms
    jmp       L5532
L5544:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignmm
    jmp       L5532
L5545:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignmdrem
    jmp       L5532
L5546:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_to
    jmp       L5532
L5547:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_if
    add       rsp,	48
    jmp       L5532
L5548:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_for
    add       rsp,	48
    jmp       L5532
L5549:
    sub       rsp,	8
    push      1
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_for
    add       rsp,	48
    jmp       L5532
L5550:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_forall
    add       rsp,	48
    jmp       L5532
L5551:
    sub       rsp,	8
    push      1
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_forall
    add       rsp,	48
    jmp       L5532
L5552:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    call      mm_blockpcl.do_while
    jmp       L5532
L5553:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_repeat
    jmp       L5532
L5554:
    mov       rcx,	rdi
    call      mm_blockpcl.do_goto
    jmp       L5532
L5555:
    mov       rcx,	r12
    call      mm_blockpcl.do_labeldef
    jmp       L5532
L5556:
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_blockpcl.do_exit
    jmp       L5532
L5557:
    mov       rcx,	r12
    mov       rdx,	2
    call      mm_blockpcl.do_exit
    jmp       L5532
L5558:
    mov       rcx,	r12
    mov       rdx,	3
    call      mm_blockpcl.do_exit
    jmp       L5532
L5559:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_do
    jmp       L5532
L5560:
    push      0
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_case
    add       rsp,	48
    jmp       L5532
L5561:
    push      0
    push      1
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_case
    add       rsp,	48
    jmp       L5532
L5562:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_switch
    add       rsp,	48
    jmp       L5532
L5563:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_recase
    jmp       L5532
L5564:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_swap
    jmp       L5532
L5565:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_select
    add       rsp,	48
    jmp       L5532
L5566:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_print
    jmp       L5532
L5567:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_print
    jmp       L5532
L5568:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_read
    jmp       L5532
L5569:
    mov       rcx,	rdi
    call      mm_blockpcl.do_readln
    jmp       L5532
L5570:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_stop
    jmp       L5532
L5571:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	134
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    jmp       L5532
L5572:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_andl
    jmp       L5532
L5573:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_orl
    jmp       L5532
L5574:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_setcc
    jmp       L5532
L5575:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_setccchain
    jmp       L5532
L5576:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_bin
    jmp       L5532
L5577:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_index
    jmp       L5532
L5578:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_dotindex
    jmp       L5532
L5579:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_dotslice
    jmp       L5532
L5580:
    mov       rcx,	r12
    call      mm_blockpcl.do_dot
    jmp       L5532
L5581:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_ptr
    jmp       L5532
L5582:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.evalref
    jmp       L5532
L5583:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L5532
L5584:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_convert
    jmp       L5532
L5585:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_typepun
    jmp       L5532
L5586:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_shorten
    jmp       L5532
L5587:
    mov       rcx,	r12
    call      mm_blockpcl.do_typeconst
    jmp       L5532
L5588:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_unary
    jmp       L5532
L5589:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_notl
    jmp       L5532
L5590:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_istruel
    jmp       L5532
L5591:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_isfalsel
    jmp       L5532
L5592:
    movzx     rax,	byte [r12+62]
    cmp       rax,	84
    jz        L5595
    cmp       rax,	85
    jnz       L5594
L5595:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_incr
    jmp       L5593
L5594:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_incrload
L5593:
    jmp       L5532
L5596:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_binto
    jmp       L5532
L5597:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_unaryto
    jmp       L5532
L5598:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_syscall
    jmp       L5532
L5599:
    mov       rcx,	r12
    call      pc_api.genassem
    mov       rcx,	42
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
    jmp       L5532
L5600:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_empty
    jmp       L5532
L5601:
    lea       rcx,	[L12828]
    call      pc_api.gencomment
    mov       rax,	[r12+16]
    mov       rcx,	[rax+16]
    call      pc_api.gencomment
    jmp       L5532
L5602:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_slice
    jmp       L5532
L5534:
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12829]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mm_support.gerror_s
    jmp       L5529
L5532:
    movsxd    rax,	dword [r12+49]
    test      rax,	rax
    jz        L5604
    mov       al,	[r12+61]
    test      al,	al
    jnz       L5604
    movzx     rax,	byte [r12]
    cmp       rax,	28
    jz        L5606
    cmp       rax,	32
    jz        L5606
    cmp       rax,	90
    jnz       L5607
L5606:
    jmp       L5605
L5607:
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jsolo]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L5609
    mov       rcx,	r12
    xor       edx,	edx
    lea       r8,	[L12830]
    xor       r9d,	r9d
    call      mm_diags.printunit
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12831]
    mov       rdx,	r10
    call      pc_api.addstr
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_support.gerror
L5609:
    mov       rcx,	11
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
L5605:
L5604:
L5529:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.evalref
mm_blockpcl.evalref:
;?>>
   %define R.p r12
   %define R.q r13
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rdi,	[r12+16]
    mov       rbx,	[r12+24]
    mov       rsi,	[r12+32]
    mov       eax,	[r12+4]
    mov       [pc_decls.mmpos],	rax
    movzx     rax,	byte [r12]
    cmp       rax,	4
    jz        L5612
    cmp       rax,	46
    jz        L5613
    cmp       rax,	49
    jz        L5614
    cmp       rax,	53
    jz        L5615
    jmp       L5616
L5612:
    mov       rcx,	[r12+16]
    call      mm_genpcl.genpushmemaddr_d
    mov       rcx,	4
    call      mm_libpcl.setmode
    test      r13,	r13
    jz        L5618
    mov       rcx,	[r13+16]
    call      mm_genpcl.genpushint
    mov       rcx,	57
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	17
    call      mm_libpcl.setmode
L5618:
    jmp       L5611
L5613:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_indexref
    jmp       L5611
L5614:
    mov       rcx,	r12
    call      mm_blockpcl.do_dotref
    jmp       L5611
L5615:
    mov       rcx,	[r12+16]
    call      mm_blockpcl.evalunit
    jmp       L5611
L5616:
    movzx     rax,	byte [r12]
    cmp       rax,	92
    jnz       L5621
L5620:
    sub       rsp,	8
    push      1
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_if
    add       rsp,	48
    jmp       L5619
L5621:
    mov       rcx,	r12
    xor       edx,	edx
    lea       r8,	[L12832]
    xor       r9d,	r9d
    call      mm_diags.printunit
    lea       rcx,	[L12833]
    xor       edx,	edx
    call      mm_support.gerror
L5619:
L5611:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.evalarray
mm_blockpcl.evalarray:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	11
    jz        L5624
    jmp       L5625
L5624:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	2
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    jmp       L5623
L5625:
    movsxd    rax,	dword [rdi+49]
    cmp       rax,	20
    jnz       L5627
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    jmp       L5626
L5627:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
L5626:
L5623:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_block
mm_blockpcl.do_block:
;?>>
   %define R.p rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+16]
    jmp       L5630
L5629:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rdi,	[rdi+8]
L5630:
    test      rdi,	rdi
    jnz       L5629
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.genjumpcond
mm_blockpcl.genjumpcond:
;?>>
   %define R.opc r14
    %define mm_blockpcl.genjumpcond.p 72
    %define mm_blockpcl.genjumpcond.lab 80
   %define R.q rdi
   %define R.r rbx
   %define R.s rsi
   %define R.lab2 r12
   %define R.i r13
    %define mm_blockpcl.genjumpcond.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    mov       rbx,	[rax+24]
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    movzx     rax,	byte [rax]
    cmp       rax,	15
    jz        L5634
    cmp       rax,	16
    jz        L5635
    cmp       rax,	17
    jz        L5636
    cmp       rax,	19
    jz        L5636
    cmp       rax,	18
    jz        L5637
    cmp       rax,	6
    jz        L5638
    cmp       rax,	33
    jz        L5639
    cmp       rax,	43
    jz        L5640
    cmp       rax,	44
    jz        L5641
    cmp       rax,	34
    jz        L5642
    jmp       L5643
L5634:
    mov       rax,	r14
    cmp       rax,	28
    jz        L5645
    cmp       rax,	27
    jz        L5646
    jmp       L5647
L5645:
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    jmp       L5644
L5646:
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	r12
    call      mm_blockpcl.genjumpcond
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
L5647:
L5644:
    jmp       L5633
L5635:
    mov       rax,	r14
    cmp       rax,	28
    jz        L5649
    cmp       rax,	27
    jz        L5650
    jmp       L5651
L5649:
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	r12
    call      mm_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    jmp       L5648
L5650:
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
L5651:
L5648:
    jmp       L5633
L5636:
    mov       rax,	r14
    cmp       rax,	28
    jz        L5653
    cmp       rax,	27
    jz        L5654
    jmp       L5655
L5653:
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    jmp       L5652
L5654:
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
L5655:
L5652:
    jmp       L5633
L5637:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    jmp       L5633
L5638:
    jmp       L5657
L5656:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rdi,	[rdi+8]
L5657:
    test      rdi,	rdi
    jz        L5659
    mov       rax,	[rdi+8]
    test      rax,	rax
    jnz       L5656
L5659:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    jmp       L5633
L5639:
    sub       rsp,	8
    push      qword [rbp + mm_blockpcl.genjumpcond.lab]
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    movzx     rax,	byte [rax+64]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	rdi
    mov       r9,	rbx
    sub       rsp,	32
    call      mm_blockpcl.gcomparejump
    add       rsp,	48
    jmp       L5633
L5640:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    cmp       r14,	27
    jnz       L5661
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	r12
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	3
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	4
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    jmp       L5660
L5661:
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	3
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	6
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
L5660:
    jmp       L5633
L5641:
    mov       rsi,	[rbx+16]
    test      rsi,	rsi
    jnz       L5663
    lea       rcx,	[L12834]
    xor       edx,	edx
    call      mm_support.gerror
L5663:
    cmp       r14,	28
    jnz       L5665
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    jmp       L5667
L5666:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rsi,	[rsi+8]
    test      rsi,	rsi
    jz        L5670
    mov       rcx,	r12
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	1
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    jmp       L5669
L5670:
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	2
    mov       r8,	rax
    call      pc_api.pc_gencond
L5669:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
L5667:
    test      rsi,	rsi
    jnz       L5666
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    jmp       L5664
L5665:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    jmp       L5674
L5671:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	1
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       rax,	[rsi+8]
    test      rax,	rax
    jz        L5676
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L5676:
    mov       rsi,	[rsi+8]
L5674:
    test      rsi,	rsi
    jnz       L5671
L5664:
    jmp       L5633
L5642:
    mov       rbx,	[rdi+8]
    mov       r13,	1
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    cmp       r14,	28
    jnz       L5678
    jmp       L5680
L5679:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rax,	[rbx+8]
    test      rax,	rax
    jz        L5683
    mov       rcx,	10
    mov       rdx,	1
    mov       r8,	2
    xor       r9d,	r9d
    call      pc_api.pc_genxy
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.genjumpcond.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    lea       rax,	[rax+40]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    call      mm_genpcl.reversecond
    mov       rcx,	rax
    call      mm_genpcl.reversecond_order
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.$T1]
    call      pc_api.pc_gencond
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    jmp       L5682
L5683:
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.genjumpcond.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    lea       rax,	[rax+40]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    call      mm_genpcl.reversecond
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.$T1]
    call      pc_api.pc_gencond
L5682:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    inc       r13
    mov       rdi,	rbx
    mov       rbx,	[rbx+8]
L5680:
    test      rbx,	rbx
    jnz       L5679
    jmp       L5677
L5678:
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    jmp       L5685
L5684:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rax,	[rbx+8]
    test      rax,	rax
    jz        L5688
    mov       rcx,	10
    mov       rdx,	1
    mov       r8,	2
    xor       r9d,	r9d
    call      pc_api.pc_genxy
    mov       rcx,	r12
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.genjumpcond.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    lea       rax,	[rax+40]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    call      mm_genpcl.reversecond
    mov       rcx,	rax
    call      mm_genpcl.reversecond_order
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.$T1]
    call      pc_api.pc_gencond
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    jmp       L5687
L5688:
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       r10,	[rbp + mm_blockpcl.genjumpcond.p]
    lea       r10,	[r10+40]
    mov       r11,	r13
    movzx     r10,	byte [r10 + r11-1]
    mov       rcx,	26
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_api.pc_gencond
L5687:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    inc       r13
    mov       rdi,	rbx
    mov       rbx,	[rbx+8]
L5685:
    test      rbx,	rbx
    jnz       L5684
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
L5677:
    jmp       L5633
L5643:
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.p]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	r14
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttisblock]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L5690
    lea       rcx,	[L12835]
    xor       edx,	edx
    call      mm_support.gerror
L5690:
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rax
    call      mm_libpcl.setmode
L5633:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.gcomparejump
mm_blockpcl.gcomparejump:
;?>>
   %define R.jumpopc rdi
   %define R.cond rbx
   %define R.lhs rsi
   %define R.rhs r12
    %define mm_blockpcl.gcomparejump.lab 80
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    cmp       rdi,	28
    jnz       L5693
    mov       rcx,	rbx
    call      mm_genpcl.reversecond
    mov       rbx,	rax
L5693:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	r12
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.gcomparejump.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	rbx
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rsi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	32
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.genjumpl
mm_blockpcl.genjumpl:
;?>>
   %define R.lab rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.unimpl
mm_blockpcl.unimpl:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    lea       rcx,	[L12836]
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_support.gerror_s
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_const
mm_blockpcl.do_const:
;?>>
   %define R.p rbx
   %define R.mode rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L5699
    cmp       rdi,	6
    jnz       L5698
L5699:
    mov       rcx,	[rbx+16]
    call      mm_genpcl.genpushint
    jmp       L5697
L5698:
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5700
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    movq      XMM4,	[rbx+16]
    movq      XMM0,	XMM4
    mov       rdx,	rax
    call      mm_genpcl.genpushreal
    jmp       L5697
L5700:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5701
    mov       al,	[rbx+44]
    test      al,	al
    jz        L5703
    movzx     rax,	byte [rbx+45]
    cmp       rax,	66
    jnz       L5705
    lea       rcx,	[L12837]
    xor       edx,	edx
    call      mm_support.gerror
L5705:
    mov       rcx,	[rbx+16]
    call      mm_genpcl.genpushstring
    jmp       L5702
L5703:
    mov       rcx,	[rbx+16]
    call      mm_genpcl.genpushint
L5702:
    jmp       L5697
L5701:
    lea       rcx,	[L12838]
    xor       edx,	edx
    call      mm_support.gerror
L5697:
    mov       rcx,	rdi
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_name
mm_blockpcl.do_name:
;?>>
   %define R.p rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+16]
    movzx     rax,	byte [rdi+78]
    cmp       rax,	6
    jz        L5708
    cmp       rax,	7
    jz        L5708
    cmp       rax,	14
    jz        L5709
    cmp       rax,	13
    jz        L5710
    jmp       L5711
L5708:
    mov       rcx,	rdi
    call      mm_genpcl.genpushmemaddr_d
    mov       rcx,	4
    call      mm_libpcl.setmode
    jmp       L5707
L5709:
    movsxd    rax,	dword [rdi+80]
    test      rax,	rax
    jnz       L5713
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [rdi+80],	eax
L5713:
    mov       al,	[rbx+61]
    test      al,	al
    jz        L5715
    movsxd    rax,	dword [rdi+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    jmp       L5714
L5715:
    movsxd    rax,	dword [rdi+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
    xor       eax,	eax
    mov       [rbx+49],	eax
    xor       eax,	eax
    mov       [rbx+61],	al
L5714:
    jmp       L5707
L5710:
    movsxd    rax,	dword [rdi+84]
    mov       rcx,	rax
    call      mm_genpcl.genpushint
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5707
L5711:
    mov       rcx,	rdi
    call      mm_genpcl.genpushmem_d
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_libpcl.setmode
L5707:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_stop
mm_blockpcl.do_stop:
;?>>
    %define mm_blockpcl.do_stop.p 24
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    test      rdi,	rdi
    jz        L5718
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    jmp       L5717
L5718:
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
L5717:
    mov       rcx,	32
    xor       edx,	edx
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_andl
mm_blockpcl.do_andl:
;?>>
    %define mm_blockpcl.do_andl.p 48
   %define R.a rsi
   %define R.b r12
   %define R.labfalse rdi
   %define R.labend rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    mov       rcx,	28
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mm_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	r12
    mov       r8,	rdi
    call      mm_blockpcl.genjumpcond
    mov       rcx,	1
    call      mm_genpcl.genpushint
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_blockpcl.genjumpl
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
    xor       ecx,	ecx
    call      mm_genpcl.genpushint
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_orl
mm_blockpcl.do_orl:
;?>>
    %define mm_blockpcl.do_orl.p 56
   %define R.a r12
   %define R.b r13
   %define R.labtrue rdi
   %define R.labfalse rbx
   %define R.labend rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	27
    mov       rdx,	r12
    mov       r8,	rdi
    call      mm_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	r13
    mov       r8,	rbx
    call      mm_blockpcl.genjumpcond
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
    mov       rcx,	1
    call      mm_genpcl.genpushint
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rsi
    call      mm_blockpcl.genjumpl
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    xor       ecx,	ecx
    call      mm_genpcl.genpushint
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_notl
mm_blockpcl.do_notl:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_istruel
mm_blockpcl.do_istruel:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	64
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_libpcl.setmode2
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_isfalsel
mm_blockpcl.do_isfalsel:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	65
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_libpcl.setmode2
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_typepun
mm_blockpcl.do_typepun:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L5726
    mov       rax,	[rbx+16]
    lea       rax,	[rax+92]
    or        byte [rax],	32
L5726:
    movsxd    rax,	dword [rbx+49]
    movsxd    r10,	dword [rdi+49]
    cmp       rax,	r10
    jz        L5724
L5728:
    mov       rcx,	110
    xor       edx,	edx
    call      pc_api.pc_gen
    movsxd    rax,	dword [rdi+53]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_libpcl.setmode2
L5724:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_shorten
mm_blockpcl.do_shorten:
;?>>
    %define mm_blockpcl.do_shorten.p 24
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assign
mm_blockpcl.do_assign:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L5732
    mov       rax,	[rbx+16]
    mov       ax,	[rax+168]
    test      ax,	ax
    jz        L5730
L5732:
    movzx     rax,	byte [rsi]
    cmp       rax,	20
    jnz       L5735
L5734:
    mov       al,	[rdi+61]
    test      al,	al
    jnz       L5737
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_blockpcl.do_assignblock
    jmp       L5730
L5737:
L5735:
L5733:
    movzx     rax,	byte [rbx]
    cmp       rax,	46
    jz        L5739
    cmp       rax,	48
    jz        L5740
    cmp       rax,	49
    jz        L5741
    jmp       L5742
L5739:
    mov       rax,	[rbx+24]
    mov       r10,	[rbx+16]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	rsi
    call      mm_blockpcl.do_storeindex
    jmp       L5730
L5740:
    lea       rcx,	[L12839]
    xor       edx,	edx
    call      mm_support.gerror
    jmp       L5738
L5741:
    mov       rax,	[rbx+24]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	rsi
    call      mm_blockpcl.do_storedot
    jmp       L5730
L5742:
L5738:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       al,	[rdi+61]
    test      al,	al
    jz        L5744
    mov       rcx,	9
    xor       edx,	edx
    call      pc_api.pc_gen
L5744:
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jz        L5746
    cmp       rax,	53
    jz        L5747
    cmp       rax,	51
    jz        L5748
    cmp       rax,	52
    jz        L5749
    cmp       rax,	92
    jz        L5750
    jmp       L5751
L5746:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	6
    jz        L5754
    cmp       rax,	7
    jz        L5754
    cmp       rax,	14
    jnz       L5753
L5754:
    lea       rcx,	[L12840]
    xor       edx,	edx
    call      mm_support.gerror
L5753:
    mov       rcx,	rbx
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5745
L5747:
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    jmp       L5745
L5748:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	16
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbx+16]
    call      mm_libpcl.setmode_u
    jmp       L5730
L5749:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rax,	[rbx+24]
    mov       rcx,	[rax+16]
    call      mm_blockpcl.evalunit
    mov       rax,	[rbx+24]
    mov       rcx,	[rax+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	17
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbx+16]
    call      mm_libpcl.setmode_u
    jmp       L5730
L5750:
    sub       rsp,	8
    push      1
    mov       rax,	[rbx+32]
    mov       r10,	[rbx+24]
    mov       r11,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    sub       rsp,	32
    call      mm_blockpcl.do_if
    add       rsp,	48
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    jmp       L5745
L5751:
    call      msys.m$print_startcon
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12841]
    xor       edx,	edx
    call      mm_support.gerror
L5745:
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
L5730:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_bin
mm_blockpcl.do_bin:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rdi+62]
    cmp       rax,	57
    jz        L5758
    cmp       rax,	58
    jnz       L5757
L5758:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    movzx     r10,	byte [rdi+62]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      pc_api.pc_genix
    jmp       L5756
L5757:
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    movzx     rax,	byte [rdi+62]
    cmp       rax,	59
    jnz       L5760
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
L5760:
L5756:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_setcc
mm_blockpcl.do_setcc:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rdi+64]
    mov       rcx,	31
    mov       rdx,	rax
    xor       r8d,	r8d
    call      pc_api.pc_gencond
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_setccchain
mm_blockpcl.do_setccchain:
;?>>
   %define R.p r14
    %define mm_blockpcl.do_setccchain.q 72
   %define R.lab1 rdi
   %define R.lab2 rbx
   %define R.i rsi
   %define R.cond r12
   %define R.r r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r14,	rcx
    mov       [rbp+72],	rdx
;---------------
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    mov       rax,	[rbp + mm_blockpcl.do_setccchain.q]
    mov       r13,	[rax+8]
    mov       rsi,	1
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbp + mm_blockpcl.do_setccchain.q]
    call      mm_blockpcl.evalunit
    jmp       L5764
L5763:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    lea       rax,	[r14+40]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    call      mm_genpcl.reversecond
    mov       r12,	rax
    mov       rax,	[r13+8]
    test      rax,	rax
    jz        L5767
    mov       rcx,	10
    mov       rdx,	1
    mov       r8,	2
    xor       r9d,	r9d
    call      pc_api.pc_genxy
    mov       rcx,	r12
    call      mm_genpcl.reversecond_order
    mov       r12,	rax
L5767:
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	r12
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rax,	[r13+8]
    test      rax,	rax
    jz        L5769
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L5769:
    mov       rcx,	[rbp + mm_blockpcl.do_setccchain.q]
    call      mm_libpcl.setmode_u
    inc       rsi
    mov       [rbp + mm_blockpcl.do_setccchain.q],	r13
    mov       r13,	[r13+8]
L5764:
    test      r13,	r13
    jnz       L5763
    mov       rcx,	1
    call      mm_genpcl.genpushint
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
    xor       ecx,	ecx
    call      mm_genpcl.genpushint
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_binto
mm_blockpcl.do_binto:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L5772
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L5772
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
L5772:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_unary
mm_blockpcl.do_unary:
;?>>
   %define R.p rbx
   %define R.a rsi
   %define R.adj rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	11
    jnz       L5775
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    movzx     rax,	byte [rbx+62]
    cmp       rax,	2
    jz        L5777
    cmp       rax,	4
    jz        L5777
    cmp       rax,	1
    jz        L5778
    jmp       L5779
L5777:
    mov       rcx,	8
    call      mm_genpcl.genpushint
    mov       rcx,	3
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	3
    call      mm_libpcl.setmode
    movzx     rax,	byte [rbx+62]
    cmp       rax,	4
    jnz       L5781
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    dec       r10
    mov       rdi,	r10
    test      rdi,	rdi
    jz        L5783
    mov       rcx,	rdi
    call      mm_genpcl.genpushint
    mov       rcx,	43
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
L5783:
L5781:
    jmp       L5776
L5778:
    mov       rcx,	2
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
L5779:
L5776:
    jmp       L5773
L5775:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rbx+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rsi
    call      mm_libpcl.setmode_u
L5773:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_unaryto
mm_blockpcl.do_unaryto:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_ptr
mm_blockpcl.do_ptr:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	2
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_labeldef
mm_blockpcl.do_labeldef:
;?>>
   %define R.p rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+16]
    movsxd    rax,	dword [rdi+80]
    test      rax,	rax
    jnz       L5788
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [rdi+80],	eax
L5788:
    mov       rcx,	rdi
    call      mm_genpcl.genmemaddr_d
    mov       rcx,	128
    mov       rdx,	rax
    call      pc_api.pc_gen
    movsxd    rax,	dword [rdi+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_goto
mm_blockpcl.do_goto:
;?>>
   %define R.a rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L5791
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	14
    jnz       L5791
    mov       rdi,	[rbx+16]
    movsxd    rax,	dword [rdi+80]
    test      rax,	rax
    jnz       L5793
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [rdi+80],	eax
L5793:
    movsxd    rax,	dword [rdi+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5790
L5791:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	25
    xor       edx,	edx
    call      pc_api.pc_gen
L5790:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_do
mm_blockpcl.do_do:
;?>>
    %define mm_blockpcl.do_do.p 40
   %define R.a rsi
    %define mm_blockpcl.do_do.b 56
   %define R.lab_abc rdi
   %define R.lab_d rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rdx
;---------------
    call      mm_genpcl.definelabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_genpcl.stacklooplabels
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	rdi
    call      mm_blockpcl.genjumpl
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_to
mm_blockpcl.do_to:
;?>>
   %define R.p r14
   %define R.a r15
    %define mm_blockpcl.do_to.b 88
   %define R.cvar rdi
   %define R.lab_b rbx
   %define R.lab_c rsi
   %define R.lab_d r12
   %define R.count r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rdi,	[r14+32]
    mov       eax,	3
    mov       [r15+49],	eax
    mov       rcx,	r15
    call      mm_blockpcl.evalunit
    mov       rcx,	rdi
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_genpcl.stacklooplabels
    movzx     rax,	byte [r15]
    cmp       rax,	1
    jz        L5797
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[mm_genpcl.pzero]
    call      mm_blockpcl.evalunit
    mov       rcx,	r12
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	4
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5796
L5797:
    mov       r13,	[r15+16]
    cmp       r13,	0
    jg        L5799
    mov       rcx,	r12
    call      mm_blockpcl.genjumpl
L5799:
L5796:
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    mov       rcx,	[rbp + mm_blockpcl.do_to.b]
    call      mm_blockpcl.evalunit
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
    mov       rcx,	rbx
    call      pc_api.genlabel
    mov       rcx,	33
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rdi
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_while
mm_blockpcl.do_while:
;?>>
    %define mm_blockpcl.do_while.p 64
   %define R.pcond r13
   %define R.pbody r14
    %define mm_blockpcl.do_while.pincr 88
   %define R.lab_b rdi
   %define R.lab_c rbx
   %define R.lab_d rsi
   %define R.lab_incr r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_while.pincr]
    test      rax,	rax
    jz        L5802
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    jmp       L5801
L5802:
    mov       r12,	rbx
L5801:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_genpcl.stacklooplabels
    mov       rcx,	r12
    call      mm_blockpcl.genjumpl
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_while.pincr]
    test      rax,	rax
    jz        L5804
    mov       rcx,	[rbp + mm_blockpcl.do_while.pincr]
    call      mm_blockpcl.evalunit
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
L5804:
    mov       rcx,	27
    mov       rdx,	r13
    mov       r8,	rdi
    call      mm_blockpcl.docond
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_repeat
mm_blockpcl.do_repeat:
;?>>
    %define mm_blockpcl.do_repeat.p 56
   %define R.a r12
   %define R.b r13
   %define R.lab_ab rdi
   %define R.lab_c rbx
   %define R.lab_d rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    call      mm_genpcl.definelabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_genpcl.stacklooplabels
    mov       rcx,	r12
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jnz       L5808
    mov       rax,	[r13+16]
    test      rax,	rax
    jz        L5807
L5808:
    mov       rcx,	28
    mov       rdx,	r13
    mov       r8,	rdi
    call      mm_blockpcl.docond
L5807:
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_exit
mm_blockpcl.do_exit:
;?>>
   %define R.p rsi
   %define R.k r12
   %define R.n rdi
   %define R.index rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movsxd    rax,	dword [rsi+40]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L5811
    mov       rbx,	[mm_genpcl.loopindex]
L5811:
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mm_genpcl.findlooplabel
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L5813
    lea       rcx,	[L12842]
    mov       rdx,	rsi
    call      mm_support.gerror
    jmp       L5812
L5813:
    mov       rcx,	rdi
    call      mm_blockpcl.genjumpl
L5812:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_if
mm_blockpcl.do_if:
;?>>
   %define R.p r13
   %define R.pcond r14
    %define mm_blockpcl.do_if.plist 80
    %define mm_blockpcl.do_if.pelse 88
    %define mm_blockpcl.do_if.isref 96
   %define R.labend rdi
   %define R.i rbx
   %define R.lab2 rsi
   %define R.ismult r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    movsxd    rax,	dword [r13+49]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       r12,	rax
    xor       rbx,	rbx
    mov       rax,	r12
    test      rax,	rax
    jz        L5816
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L5816:
    jmp       L5820
L5817:
    inc       rbx
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	28
    mov       rdx,	r14
    mov       r8,	rsi
    call      mm_blockpcl.docond
    mov       rax,	[rbp + mm_blockpcl.do_if.isref]
    test      rax,	rax
    jz        L5822
    mov       rcx,	[rbp + mm_blockpcl.do_if.plist]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L5821
L5822:
    mov       rcx,	[rbp + mm_blockpcl.do_if.plist]
    call      mm_blockpcl.evalunit
L5821:
    test      r12,	r12
    jz        L5824
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L5824:
    mov       rax,	[r14+8]
    test      rax,	rax
    jnz       L5827
    mov       rax,	[rbp + mm_blockpcl.do_if.pelse]
    test      rax,	rax
    jz        L5826
L5827:
    mov       rcx,	rdi
    call      mm_blockpcl.genjumpl
L5826:
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
    mov       r14,	[r14+8]
    mov       rax,	[rbp + mm_blockpcl.do_if.plist]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_if.plist],	rax
L5820:
    test      r14,	r14
    jnz       L5817
    mov       rax,	[rbp + mm_blockpcl.do_if.pelse]
    test      rax,	rax
    jz        L5829
    mov       rax,	[rbp + mm_blockpcl.do_if.isref]
    test      rax,	rax
    jz        L5831
    mov       rcx,	[rbp + mm_blockpcl.do_if.pelse]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L5830
L5831:
    mov       rcx,	[rbp + mm_blockpcl.do_if.pelse]
    call      mm_blockpcl.evalunit
L5830:
    test      r12,	r12
    jz        L5833
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L5833:
L5829:
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_return
mm_blockpcl.do_return:
;?>>
    %define mm_blockpcl.do_return.p 24
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    test      rdi,	rdi
    jz        L5836
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[mm_genpcl.retindex]
    call      pc_api.genlabel
    mov       rcx,	29
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    jmp       L5835
L5836:
    mov       rcx,	[mm_genpcl.retindex]
    call      mm_blockpcl.genjumpl
L5835:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_returnmult
mm_blockpcl.do_returnmult:
;?>>
   %define R.p r12
   %define R.a r13
    %define mm_blockpcl.do_returnmult.params -800
   %define R.q rdi
   %define R.nparams rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	840
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rdi,	r13
    xor       rbx,	rbx
    jmp       L5839
L5838:
    cmp       rbx,	100
    jl        L5842
    lea       rcx,	[L12843]
    xor       edx,	edx
    call      mm_support.gerror
L5842:
    inc       rbx
    mov       rax,	rbx
    mov       r10,	rdi
    mov       [rbp + rax*8 + mm_blockpcl.do_returnmult.params-8],	r10
    mov       rdi,	[rdi+8]
L5839:
    test      rdi,	rdi
    jnz       L5838
    mov       rsi,	rbx
    cmp       rsi,	1
    jl        L5845
L5843:
    mov       rcx,	[rbp + rsi*8 + mm_blockpcl.do_returnmult.params-8]
    call      mm_blockpcl.evalunit
    dec       rsi
    cmp       rsi,	1
    jge       L5843
L5845:
    mov       rcx,	[mm_genpcl.retindex]
    call      pc_api.genlabel
    mov       rcx,	30
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      pc_api.pc_setnargs
    mov       al,	1
    mov       [r12+61],	al
;---------------
    add       rsp,	840
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_callproc
mm_blockpcl.do_callproc:
;?>>
   %define R.p r15
    %define mm_blockpcl.do_callproc.a 80
    %define mm_blockpcl.do_callproc.b 88
    %define mm_blockpcl.do_callproc.paramlist -800
    %define mm_blockpcl.do_callproc.argattr -904
   %define R.nparams rdi
   %define R.isptr rbx
   %define R.nvariadics rsi
   %define R.nret r12
   %define R.isfn r13
   %define R.iparams r14
    %define mm_blockpcl.do_callproc.fparams -912
    %define mm_blockpcl.do_callproc.nfixedparams -920
    %define mm_blockpcl.do_callproc.d -928
    %define mm_blockpcl.do_callproc.e -936
    %define mm_blockpcl.do_callproc.pmult -944
    %define mm_blockpcl.do_callproc.q -952
    %define mm_blockpcl.do_callproc.i -960
    %define mm_blockpcl.do_callproc.$T1 -968
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1000
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    xor       rbx,	rbx
    mov       rax,	[rbp + mm_blockpcl.do_callproc.a]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L5848
    cmp       rax,	53
    jz        L5849
    jmp       L5850
L5848:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.a]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_callproc.d],	rax
    jmp       L5847
L5849:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.a]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttnamedef]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mm_blockpcl.do_callproc.d],	r10
    mov       rbx,	1
    jmp       L5847
L5850:
    lea       rcx,	[L12844]
    xor       edx,	edx
    call      mm_support.gerror
L5847:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       r13,	rax
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rsi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.b]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_callproc.nfixedparams],	rax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_callproc.e],	rax
    jmp       L5854
L5851:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.e]
    movzx     rax,	byte [rax+78]
    cmp       rax,	12
    jnz       L5856
    inc       qword [rbp + mm_blockpcl.do_callproc.nfixedparams]
L5856:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_blockpcl.do_callproc.e],	rax
L5854:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.e]
    test      rax,	rax
    jnz       L5851
    mov       rax,	[rbp + mm_blockpcl.do_callproc.b]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
    jmp       L5860
L5857:
    cmp       rdi,	100
    jl        L5862
    lea       rcx,	[L12845]
    xor       edx,	edx
    call      mm_support.gerror
L5862:
    inc       rdi
    mov       rax,	rdi
    mov       r10,	[rbp + mm_blockpcl.do_callproc.q]
    mov       [rbp + rax*8 + mm_blockpcl.do_callproc.paramlist-8],	r10
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    mov       al,	[rax+123]
    test      al,	al
    jz        L5864
    cmp       rdi,	[rbp + mm_blockpcl.do_callproc.nfixedparams]
    jl        L5864
    cmp       rdi,	4
    jg        L5864
    test      rsi,	rsi
    jnz       L5864
    mov       rsi,	rdi
L5864:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
L5860:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.q]
    test      rax,	rax
    jnz       L5857
    mov       rcx,	131
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r15
    call      mm_libpcl.setmode_u
    mov       eax,	edi
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_callproc.fparams],	rax
    mov       r14,	rax
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       rdi,	1
    jl        L5867
L5865:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    mov       rax,	[rbp + rax*8 + mm_blockpcl.do_callproc.paramlist-8]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
    xor       eax,	eax
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    mov       [rbp + r10 + mm_blockpcl.do_callproc.argattr-1],	al
    mov       rax,	[rbp + mm_blockpcl.do_callproc.q]
    movsxd    rax,	dword [rax+49]
    cmp       rax,	2
    jz        L5870
    cmp       rax,	1
    jnz       L5869
L5870:
    inc       qword [rbp + mm_blockpcl.do_callproc.fparams]
    mov       rax,	[rbp + mm_blockpcl.do_callproc.fparams]
    cmp       rax,	8
    jle       L5872
    mov       al,	2
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    mov       [rbp + r10 + mm_blockpcl.do_callproc.argattr-1],	al
L5872:
    jmp       L5868
L5869:
    inc       r14
    cmp       r14,	8
    jle       L5874
    mov       al,	2
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    mov       [rbp + r10 + mm_blockpcl.do_callproc.argattr-1],	al
L5874:
L5868:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       rax,	rdi
    jle       L5865
L5867:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.fparams]
    cmp       rax,	8
    jle       L5876
    cmp       r14,	8
    jle       L5876
    lea       rcx,	[L12846]
    xor       edx,	edx
    call      mm_support.gerror
L5876:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.fparams]
    mov       r10,	r14
    cmp       rax,	r10
    cmovl     rax,	r10
    sub       rax,	8
    mov       r14,	rax
    mov       [rbp + mm_blockpcl.do_callproc.i],	rdi
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    cmp       rax,	1
    jl        L5879
L5877:
    mov       eax,	r14d
    and       eax,	1
    test      rax,	rax
    jz        L5881
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    mov       al,	[rbp + rax + mm_blockpcl.do_callproc.argattr-1]
    test      al,	al
    jz        L5881
    mov       al,	1
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    mov       [rbp + r10 + mm_blockpcl.do_callproc.argattr-1],	al
    xor       r14,	r14
L5881:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    mov       rax,	[rbp + rax*8 + mm_blockpcl.do_callproc.paramlist-8]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_callproc.q]
    call      mm_blockpcl.evalunit
    test      rsi,	rsi
    jz        L5883
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    cmp       rax,	rsi
    jl        L5883
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax+3]
    cmp       rax,	1
    jnz       L5883
    mov       rcx,	115
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       eax,	8
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    mov       al,	2
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+28]
    mov       r10d,	1
    mov       r9d,	[rax]
    mov       r11,	-256
    and       r9d,	r11d
    or        r9d,	r10d
    mov       [rax],	r9d
    mov       rcx,	132
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	1
    call      mm_libpcl.setmode
    jmp       L5882
L5883:
    mov       rcx,	132
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbp + mm_blockpcl.do_callproc.q]
    call      mm_libpcl.setmode_u
L5882:
    mov       eax,	[rbp + mm_blockpcl.do_callproc.i]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    movsx     rax,	byte [rbp + rax + mm_blockpcl.do_callproc.argattr-1]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    dec       rax
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       rax,	1
    jge       L5877
L5879:
    test      rbx,	rbx
    jnz       L5885
    mov       rcx,	[rbp + mm_blockpcl.do_callproc.d]
    call      mm_genpcl.genmemaddr_d
    mov       [rbp + mm_blockpcl.do_callproc.$T1],	rax
    test      r13,	r13
    jz        L5887
    mov       rax,	21
    jmp       L5886
L5887:
    mov       rax,	18
L5886:
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_blockpcl.do_callproc.$T1]
    call      pc_api.pc_gen
    jmp       L5884
L5885:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.a]
    mov       rcx,	[rax+16]
    call      mm_blockpcl.evalunit
    test      r13,	r13
    jz        L5889
    mov       rax,	22
    jmp       L5888
L5889:
    mov       rax,	19
L5888:
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
L5884:
    mov       eax,	edi
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	esi
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
    test      r13,	r13
    jz        L5891
    mov       rcx,	r15
    call      mm_libpcl.setmode_u
L5891:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    movzx     rax,	byte [rax+122]
    cmp       rax,	1
    jle       L5893
    test      r13,	r13
    jz        L5893
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    movzx     rax,	byte [rax+122]
    mov       r12,	rax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttmult]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mm_blockpcl.do_callproc.pmult],	r10
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       r12,	1
    jl        L5896
L5894:
    mov       rcx,	13
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_blockpcl.do_callproc.pmult]
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    movsxd    rax,	dword [rax + r10*4-4]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       rax,	r12
    jle       L5894
L5896:
L5893:
    test      r13,	r13
    jz        L5898
    mov       al,	[r15+61]
    test      al,	al
    jnz       L5898
    mov       rcx,	11
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r15
    call      mm_libpcl.setmode_u
L5898:
;---------------
    add       rsp,	1000
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_print
mm_blockpcl.do_print:
;?>>
   %define R.p r14
    %define mm_blockpcl.do_print.a 72
    %define mm_blockpcl.do_print.b 80
   %define R.q rdi
   %define R.r rbx
   %define R.fmt rsi
   %define R.m r12
   %define R.fn r13
    %define mm_blockpcl.do_print.needprintend -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    mov       rax,	[rbp + mm_blockpcl.do_print.a]
    test      rax,	rax
    jz        L5901
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_print.needprintend],	rax
    mov       rax,	[rbp + mm_blockpcl.do_print.a]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L5903
    lea       rcx,	[L12847]
    xor       edx,	edx
    call      mm_support.gerror
L5903:
    mov       rax,	[rbp + mm_blockpcl.do_print.a]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttbasetype]
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jz        L5905
    cmp       rax,	12
    jz        L5906
    cmp       rax,	7
    jz        L5907
    jmp       L5908
L5905:
    sub       rsp,	8
    push      0
    mov       rcx,	2
    mov       rdx,	[rbp + mm_blockpcl.do_print.a]
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L5904
L5906:
    sub       rsp,	8
    push      0
    mov       rcx,	3
    mov       rdx,	[rbp + mm_blockpcl.do_print.a]
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L5904
L5907:
    sub       rsp,	8
    push      0
    mov       rcx,	4
    mov       rdx,	[rbp + mm_blockpcl.do_print.a]
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L5904
L5908:
    lea       rcx,	[L12848]
    xor       edx,	edx
    call      mm_support.gerror
L5904:
    jmp       L5900
L5901:
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_print.needprintend],	rax
    sub       rsp,	8
    push      0
    mov       rcx,	5
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L5900:
    mov       rdi,	[rbp + mm_blockpcl.do_print.b]
    movzx     rax,	byte [r14]
    cmp       rax,	116
    jz        L5910
    cmp       rax,	117
    jnz       L5911
L5910:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jnz       L5914
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttbasetype]
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jz        L5913
L5914:
    lea       rcx,	[L12849]
    xor       edx,	edx
    call      mm_support.gerror
L5913:
    sub       rsp,	8
    push      0
    mov       rcx,	6
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    mov       rdi,	[r14+32]
L5911:
L5909:
    jmp       L5916
L5915:
    movzx     rax,	byte [rdi]
    cmp       rax,	86
    jz        L5919
    cmp       rax,	87
    jz        L5920
    cmp       rax,	88
    jz        L5921
    jmp       L5922
L5919:
    mov       rsi,	[rdi+24]
    mov       rbx,	[rdi+16]
    movsxd    rax,	dword [rbx+49]
    mov       r12,	rax
    jmp       L5918
L5920:
    sub       rsp,	8
    push      0
    mov       rcx,	7
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    mov       rdi,	[rdi+8]
    jmp       L5916
L5921:
    sub       rsp,	8
    push      0
    mov       rcx,	8
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    mov       rdi,	[rdi+8]
    jmp       L5916
L5922:
    xor       rsi,	rsi
    mov       rax,	rdi
    mov       rbx,	rax
    movsxd    rax,	dword [rdi+49]
    mov       r12,	rax
L5918:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	3
    jz        L5924
    cmp       rax,	4
    jz        L5925
    cmp       rax,	2
    jz        L5926
    cmp       rax,	1
    jz        L5927
    cmp       rax,	7
    jz        L5928
    cmp       rax,	6
    jz        L5929
    cmp       rax,	10
    jz        L5930
    cmp       rax,	8
    jz        L5931
    cmp       rax,	11
    jz        L5932
    cmp       rax,	5
    jz        L5933
    jmp       L5934
L5924:
    mov       r13,	9
    test      rsi,	rsi
    jnz       L5936
    mov       r13,	10
L5936:
    jmp       L5923
L5925:
    mov       r13,	11
    jmp       L5923
L5926:
    mov       r13,	13
    jmp       L5923
L5927:
    mov       r13,	12
    jmp       L5923
L5928:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jz        L5939
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jnz       L5938
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	12
    jnz       L5938
L5939:
    mov       r13,	14
    test      rsi,	rsi
    jnz       L5941
    mov       r13,	15
L5941:
    jmp       L5937
L5938:
    mov       r13,	17
    test      rsi,	rsi
    jnz       L5943
    mov       r13,	18
L5943:
L5937:
    jmp       L5923
L5929:
    mov       r13,	20
    jmp       L5923
L5930:
    lea       rcx,	[L12850]
    xor       edx,	edx
    call      mm_support.gerror
    mov       rdi,	[rdi+8]
    jmp       L5923
L5931:
    lea       rcx,	[L12851]
    xor       edx,	edx
    call      mm_support.gerror
    jmp       L5923
L5932:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jnz       L5945
    mov       r13,	16
    jmp       L5944
L5945:
    lea       rcx,	[L12852]
    xor       edx,	edx
    call      mm_support.gerror
L5944:
    jmp       L5923
L5933:
    mov       r13,	19
    jmp       L5923
L5934:
    call      msys.m$print_startcon
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L12853]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.gerror_s
L5923:
    mov       rax,	r13
    cmp       rax,	10
    jz        L5947
    cmp       rax,	15
    jz        L5947
    cmp       rax,	18
    jnz       L5948
L5947:
    sub       rsp,	8
    push      0
    mov       rcx,	r13
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L5946
L5948:
    sub       rsp,	8
    push      0
    test      rsi,	rsi
    jz        L5950
    mov       rax,	rsi
    jmp       L5949
L5950:
    mov       rax,	[mm_genpcl.pzero]
L5949:
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	rax
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L5946:
    mov       rdi,	[rdi+8]
L5916:
    test      rdi,	rdi
    jnz       L5915
    movzx     rax,	byte [r14]
    cmp       rax,	115
    jz        L5952
    cmp       rax,	117
    jnz       L5953
L5952:
    sub       rsp,	8
    push      0
    mov       rcx,	21
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L5953:
L5951:
    mov       rax,	[rbp + mm_blockpcl.do_print.needprintend]
    test      rax,	rax
    jz        L5955
    sub       rsp,	8
    push      0
    mov       rcx,	22
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L5955:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_incr
mm_blockpcl.do_incr:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_blockpcl.setincrstep
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.setincrstep
mm_blockpcl.setincrstep:
;?>>
   %define R.m rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	1
    call      pc_api.pc_setincr
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5959
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       rcx,	r10
    call      pc_api.pc_setincr
L5959:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_incrload
mm_blockpcl.do_incrload:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_blockpcl.setincrstep
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_for
mm_blockpcl.do_for:
;?>>
    %define mm_blockpcl.do_for.p 64
   %define R.pindex r14
    %define mm_blockpcl.do_for.pfrom 80
    %define mm_blockpcl.do_for.pbody 88
    %define mm_blockpcl.do_for.down 96
   %define R.pto rdi
   %define R.pstep rbx
   %define R.pelse rsi
   %define R.px r12
   %define R.ptoinit r13
    %define mm_blockpcl.do_for.lab_b -8
    %define mm_blockpcl.do_for.lab_c -16
    %define mm_blockpcl.do_for.lab_d -24
    %define mm_blockpcl.do_for.lab_e -32
    %define mm_blockpcl.do_for.a -40
    %define mm_blockpcl.do_for.b -48
    %define mm_blockpcl.do_for.stepx -56
    %define mm_blockpcl.do_for.d -64
    %define mm_blockpcl.do_for.$T1 -72
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rax,	[rbp + mm_blockpcl.do_for.pfrom]
    mov       rdi,	[rax+8]
    mov       rbx,	[rdi+8]
    mov       rax,	[rbp + mm_blockpcl.do_for.pbody]
    mov       rsi,	[rax+8]
    mov       r13,	[r14+8]
    movzx     rax,	byte [rdi]
    cmp       rax,	53
    jnz       L5963
    mov       r12,	[rdi+16]
    movzx     rax,	byte [r12]
    cmp       rax,	4
    jnz       L5965
    mov       rax,	[r12+16]
    mov       [rbp + mm_blockpcl.do_for.d],	rax
    movzx     rax,	byte [rax+78]
    cmp       rax,	12
    jnz       L5965
    mov       rax,	[rbp + mm_blockpcl.do_for.d]
    movzx     rax,	byte [rax+160]
    cmp       rax,	1
    jnz       L5965
    lea       rcx,	[L12854]
    xor       edx,	edx
    call      mm_support.gerror
L5965:
L5963:
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_for.lab_b],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_for.lab_c],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_for.lab_d],	rax
    test      rsi,	rsi
    jz        L5967
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_for.lab_e],	rax
    jmp       L5966
L5967:
    mov       rax,	[rbp + mm_blockpcl.do_for.lab_d]
    mov       [rbp + mm_blockpcl.do_for.lab_e],	rax
L5966:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_b]
    mov       rdx,	[rbp + mm_blockpcl.do_for.lab_c]
    mov       r8,	[rbp + mm_blockpcl.do_for.lab_d]
    call      mm_genpcl.stacklooplabels
    mov       rcx,	[rbp + mm_blockpcl.do_for.pfrom]
    call      mm_blockpcl.evalunit
    mov       rcx,	r14
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
    test      r13,	r13
    jz        L5969
    xor       eax,	eax
    mov       [r13+61],	al
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
L5969:
    mov       rax,	[rbp + mm_blockpcl.do_for.pfrom]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L5971
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jnz       L5971
    mov       rax,	[rbp + mm_blockpcl.do_for.pfrom]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_for.a],	rax
    mov       rax,	[rdi+16]
    mov       [rbp + mm_blockpcl.do_for.b],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5975
    mov       rax,	[rbp + mm_blockpcl.do_for.a]
    cmp       rax,	[rbp + mm_blockpcl.do_for.b]
    jge       L5974
L5975:
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jnz       L5973
    mov       rax,	[rbp + mm_blockpcl.do_for.a]
    cmp       rax,	[rbp + mm_blockpcl.do_for.b]
    jg        L5973
L5974:
    jmp       L5972
L5973:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_e]
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
L5972:
    jmp       L5970
L5971:
    mov       rax,	[rbp + mm_blockpcl.do_for.pfrom]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L5977
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_for.pfrom]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_e]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_for.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5979
    mov       rax,	6
    jmp       L5978
L5979:
    mov       rax,	3
L5978:
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.do_for.$T1]
    call      pc_api.pc_gencond
    jmp       L5976
L5977:
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_e]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_for.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5981
    mov       rax,	3
    jmp       L5980
L5981:
    mov       rax,	6
L5980:
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.do_for.$T1]
    call      pc_api.pc_gencond
L5976:
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
L5970:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_b]
    call      mm_genpcl.definefwdlabel
    mov       rcx,	[rbp + mm_blockpcl.do_for.pbody]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_c]
    call      mm_genpcl.definefwdlabel
    test      rbx,	rbx
    jz        L5983
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jz        L5985
    lea       rcx,	[L12855]
    xor       edx,	edx
    call      mm_support.gerror
L5985:
    mov       rax,	[rbx+16]
    mov       [rbp + mm_blockpcl.do_for.stepx],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.stepx]
    cmp       rax,	0
    jg        L5987
    lea       rcx,	[L12856]
    xor       edx,	edx
    call      mm_support.gerror
L5987:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_b]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_for.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5989
    mov       rax,	35
    jmp       L5988
L5989:
    mov       rax,	34
L5988:
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_blockpcl.do_for.stepx]
    mov       r8,	[rbp + mm_blockpcl.do_for.$T1]
    call      pc_api.pc_genx
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
    jmp       L5982
L5983:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_b]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_for.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5991
    mov       rax,	35
    jmp       L5990
L5991:
    mov       rax,	34
L5990:
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	[rbp + mm_blockpcl.do_for.$T1]
    call      pc_api.pc_genx
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
L5982:
    mov       rcx,	r14
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jz        L5993
    cmp       rax,	4
    jz        L5994
    jmp       L5995
L5993:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5992
L5994:
    mov       rcx,	rdi
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
L5995:
L5992:
    test      rsi,	rsi
    jz        L5997
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_e]
    call      mm_genpcl.definefwdlabel
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
L5997:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_d]
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_forall
mm_blockpcl.do_forall:
;?>>
    %define mm_blockpcl.do_forall.p 64
   %define R.pindex r14
    %define mm_blockpcl.do_forall.plist 80
    %define mm_blockpcl.do_forall.pbody 88
    %define mm_blockpcl.do_forall.down 96
   %define R.plocal rdi
   %define R.pfrom rbx
   %define R.pto rsi
   %define R.pelse r12
   %define R.passign r13
    %define mm_blockpcl.do_forall.lab_b -8
    %define mm_blockpcl.do_forall.lab_c -16
    %define mm_blockpcl.do_forall.lab_d -24
    %define mm_blockpcl.do_forall.lab_e -32
    %define mm_blockpcl.do_forall.a -40
    %define mm_blockpcl.do_forall.b -48
    %define mm_blockpcl.do_forall.dto -56
    %define mm_blockpcl.do_forall.$T1 -64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rdi,	[r14+8]
    mov       rbx,	[rdi+8]
    mov       rsi,	[rbx+8]
    mov       rax,	[rbp + mm_blockpcl.do_forall.plist]
    mov       r13,	[rax+8]
    mov       rax,	[rbp + mm_blockpcl.do_forall.pbody]
    mov       r12,	[rax+8]
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_forall.lab_b],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_forall.lab_c],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_forall.lab_d],	rax
    test      r12,	r12
    jz        L6000
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_forall.lab_e],	rax
    jmp       L5999
L6000:
    mov       rax,	[rbp + mm_blockpcl.do_forall.lab_d]
    mov       [rbp + mm_blockpcl.do_forall.lab_e],	rax
L5999:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_b]
    mov       rdx,	[rbp + mm_blockpcl.do_forall.lab_c]
    mov       r8,	[rbp + mm_blockpcl.do_forall.lab_d]
    call      mm_genpcl.stacklooplabels
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	r14
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
    movzx     rax,	byte [rsi]
    cmp       rax,	1
    jz        L6002
    cmp       rax,	4
    jz        L6002
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	11
    call      mm_lib.getavname
    mov       [rbp + mm_blockpcl.do_forall.dto],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_forall.dto]
    call      mm_genpcl.genmem_d
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	[rbp + mm_blockpcl.do_forall.dto]
    call      mm_lib.createname
    mov       rsi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.dto]
    mov       eax,	[rax+72]
    mov       [rsi+49],	eax
    mov       al,	1
    mov       [rsi+61],	al
L6002:
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jnz       L6004
    movzx     rax,	byte [rsi]
    cmp       rax,	1
    jnz       L6004
    mov       rax,	[rbx+16]
    mov       [rbp + mm_blockpcl.do_forall.a],	rax
    mov       rax,	[rsi+16]
    mov       [rbp + mm_blockpcl.do_forall.b],	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jz        L6008
    mov       rax,	[rbp + mm_blockpcl.do_forall.a]
    cmp       rax,	[rbp + mm_blockpcl.do_forall.b]
    jge       L6007
L6008:
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jnz       L6006
    mov       rax,	[rbp + mm_blockpcl.do_forall.a]
    cmp       rax,	[rbp + mm_blockpcl.do_forall.b]
    jg        L6006
L6007:
    jmp       L6005
L6006:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_e]
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
L6005:
    jmp       L6003
L6004:
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jnz       L6010
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_e]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_forall.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jz        L6012
    mov       rax,	6
    jmp       L6011
L6012:
    mov       rax,	3
L6011:
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.do_forall.$T1]
    call      pc_api.pc_gencond
    jmp       L6009
L6010:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_e]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_forall.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jz        L6014
    mov       rax,	3
    jmp       L6013
L6014:
    mov       rax,	6
L6013:
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.do_forall.$T1]
    call      pc_api.pc_gencond
L6009:
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
L6003:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_b]
    call      mm_genpcl.definefwdlabel
    xor       eax,	eax
    mov       [r13+61],	al
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_forall.pbody]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_c]
    call      mm_genpcl.definefwdlabel
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_b]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_forall.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jz        L6016
    mov       rax,	35
    jmp       L6015
L6016:
    mov       rax,	34
L6015:
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	[rbp + mm_blockpcl.do_forall.$T1]
    call      pc_api.pc_genx
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
    mov       rcx,	r14
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    movzx     rax,	byte [rsi]
    cmp       rax,	1
    jz        L6018
    cmp       rax,	4
    jz        L6019
    jmp       L6020
L6018:
    mov       rax,	[rsi+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L6017
L6019:
    mov       rcx,	rsi
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L6017
L6020:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.dto]
    call      mm_genpcl.genmem_d
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
L6017:
    mov       rcx,	3
    call      mm_libpcl.setmode
    test      r12,	r12
    jz        L6022
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_e]
    call      mm_genpcl.definefwdlabel
    mov       rcx,	r12
    call      mm_blockpcl.evalunit
L6022:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_d]
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	96
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_convert
mm_blockpcl.do_convert:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rdi+62]
    cmp       rax,	7
    jz        L6025
    test      rax,	rax
    jz        L6026
    jmp       L6027
L6025:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    jmp       L6023
L6026:
    lea       rcx,	[L12857]
    xor       edx,	edx
    call      mm_support.gerror
    jmp       L6024
L6027:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rdi+62]
    lea       r10,	[mm_tables.convtopcl]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      pc_api.pc_gen
L6024:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rdi+53]
    mov       rcx,	rax
    call      mm_libpcl.setmode2
L6023:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_swap
mm_blockpcl.do_swap:
;?>>
    %define mm_blockpcl.do_swap.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    mov       rcx,	36
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.checkdotchain
mm_blockpcl.checkdotchain:
;?>>
   %define R.p rbx
   %define R.pname rsi
   %define R.offset rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	49
    jnz       L6032
L6031:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mm_blockpcl.checkdotchain
    mov       rdi,	rax
    mov       eax,	[rbx+40]
    add       rax,	rdi
    jmp       L6029
L6032:
    mov       [rsi],	rbx
    xor       eax,	eax
    jmp       L6029
L6030:
    xor       eax,	eax
L6029:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_dotref
mm_blockpcl.do_dotref:
;?>>
   %define R.pdot r12
   %define R.imode rdi
   %define R.offset rbx
   %define R.a rsi
    %define mm_blockpcl.do_dotref.pname -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
;---------------
    movsxd    rax,	dword [r12+49]
    xor       ecx,	ecx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       rdi,	rax
    mov       rsi,	[r12+16]
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_dotref.pname],	rax
    mov       rcx,	rsi
    lea       rdx,	[rbp + mm_blockpcl.do_dotref.pname]
    call      mm_blockpcl.checkdotchain
    mov       rbx,	rax
    mov       eax,	[r12+40]
    add       rbx,	rax
    mov       rsi,	[rbp + mm_blockpcl.do_dotref.pname]
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    test      rbx,	rbx
    jz        L6035
    mov       rcx,	rbx
    call      mm_genpcl.genpushint
    mov       rcx,	57
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
L6035:
    mov       rcx,	rdi
    call      mm_libpcl.setmode
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_dot
mm_blockpcl.do_dot:
;?>>
   %define R.pdot rsi
   %define R.offset rdi
   %define R.a rbx
    %define mm_blockpcl.do_dot.pname -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
;---------------
    mov       rbx,	[rsi+16]
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_dot.pname],	rax
    mov       rcx,	rbx
    lea       rdx,	[rbp + mm_blockpcl.do_dot.pname]
    call      mm_blockpcl.checkdotchain
    mov       rdi,	rax
    mov       eax,	[rsi+40]
    add       rdi,	rax
    mov       rbx,	[rbp + mm_blockpcl.do_dot.pname]
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	rdi
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	3
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rsi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_storedot
mm_blockpcl.do_storedot:
;?>>
   %define R.pdot rsi
    %define mm_blockpcl.do_storedot.pfield 56
   %define R.rhs r12
   %define R.offset rdi
   %define R.a rbx
    %define mm_blockpcl.do_storedot.pname -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	r8
;---------------
    mov       rcx,	r12
    call      mm_blockpcl.evalunit
    mov       al,	[rsi+61]
    test      al,	al
    jz        L6039
    mov       rcx,	9
    xor       edx,	edx
    call      pc_api.pc_gen
L6039:
    mov       rbx,	[rsi+16]
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_storedot.pname],	rax
    mov       rcx,	rbx
    lea       rdx,	[rbp + mm_blockpcl.do_storedot.pname]
    call      mm_blockpcl.checkdotchain
    mov       rdi,	rax
    mov       eax,	[rsi+40]
    add       rdi,	rax
    mov       rbx,	[rbp + mm_blockpcl.do_storedot.pname]
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	rdi
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	6
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rsi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_index
mm_blockpcl.do_index:
;?>>
   %define R.p r12
   %define R.parray r13
    %define mm_blockpcl.do_index.pindex 72
   %define R.addoffset rdi
   %define R.scale rbx
   %define R.offset rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       [rbp+72],	r8
;---------------
    mov       rcx,	r13
    lea       rdx,	[rbp + mm_blockpcl.do_index.pindex]
    call      mm_blockpcl.getindexoffset
    mov       rdi,	rax
    mov       rcx,	r13
    call      mm_blockpcl.evalarray
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rbx,	rax
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    neg       r10
    imul      r10,	rbx
    mov       rax,	rdi
    imul      rax,	rbx
    add       r10,	rax
    mov       rsi,	r10
    mov       rcx,	[rbp + mm_blockpcl.do_index.pindex]
    call      mm_blockpcl.evalunit
    mov       rcx,	3
    mov       rdx,	rbx
    mov       r8,	rsi
    call      pc_api.pc_genix
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_storeindex
mm_blockpcl.do_storeindex:
;?>>
   %define R.p rsi
   %define R.parray r12
    %define mm_blockpcl.do_storeindex.pindex 72
   %define R.rhs r13
   %define R.addoffset rdi
   %define R.scale rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       [rbp+72],	r8
    mov       r13,	r9
;---------------
    mov       rcx,	r12
    lea       rdx,	[rbp + mm_blockpcl.do_storeindex.pindex]
    call      mm_blockpcl.getindexoffset
    mov       rdi,	rax
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    mov       al,	[rsi+61]
    test      al,	al
    jz        L6043
    mov       rcx,	9
    xor       edx,	edx
    call      pc_api.pc_gen
L6043:
    mov       rcx,	r12
    call      mm_blockpcl.evalarray
    mov       rcx,	[rbp + mm_blockpcl.do_storeindex.pindex]
    call      mm_blockpcl.evalunit
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rbx,	rax
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    neg       r10
    imul      r10,	rbx
    mov       rax,	rdi
    imul      rax,	rbx
    add       r10,	rax
    mov       rcx,	6
    mov       rdx,	rbx
    mov       r8,	r10
    call      pc_api.pc_genix
    mov       rcx,	[rsi+16]
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_indexref
mm_blockpcl.do_indexref:
;?>>
   %define R.parray rsi
    %define mm_blockpcl.do_indexref.pindex 48
   %define R.addoffset rdi
   %define R.scale rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
    mov       [rbp+48],	rdx
;---------------
    mov       rcx,	rsi
    lea       rdx,	[rbp + mm_blockpcl.do_indexref.pindex]
    call      mm_blockpcl.getindexoffset
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mm_blockpcl.evalarray
    mov       rcx,	[rbp + mm_blockpcl.do_indexref.pindex]
    call      mm_blockpcl.evalunit
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rbx,	rax
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    neg       r10
    imul      r10,	rbx
    mov       rax,	rdi
    imul      rax,	rbx
    add       r10,	rax
    mov       rcx,	57
    mov       rdx,	rbx
    mov       r8,	r10
    call      pc_api.pc_genix
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rcx,	r10
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.getindexoffset
mm_blockpcl.getindexoffset:
;?>>
    %define mm_blockpcl.getindexoffset.parray 24
   %define R.pindex rdx
   %define R.addoffset rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    xor       rdi,	rdi
    mov       rax,	[rdx]
    movzx     rax,	byte [rax]
    cmp       rax,	35
    jnz       L6047
    mov       rax,	[rdx]
    movzx     rax,	byte [rax+62]
    cmp       rax,	43
    jz        L6048
    cmp       rax,	44
    jnz       L6047
L6048:
    mov       rax,	[rdx]
    mov       rax,	[rax+24]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L6050
    mov       rax,	[rdx]
    movzx     rax,	byte [rax+62]
    cmp       rax,	43
    jnz       L6052
    mov       rax,	[rdx]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    jmp       L6051
L6052:
    mov       rax,	[rdx]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    neg       rax
L6051:
    mov       rdi,	rax
    mov       rax,	[rdx]
    mov       rax,	[rax+16]
    mov       [rdx],	rax
L6050:
L6047:
    mov       rax,	rdi
L6045:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_switch
mm_blockpcl.do_switch:
;?>>
   %define R.p r12
   %define R.pindex r13
    %define mm_blockpcl.do_switch.pwhenthen 72
    %define mm_blockpcl.do_switch.pelse 80
    %define mm_blockpcl.do_switch.isref 88
   %define R.minlab rdi
   %define R.maxlab rbx
   %define R.n rsi
    %define mm_blockpcl.do_switch.iscomplex -8
    %define mm_blockpcl.do_switch.i -16
    %define mm_blockpcl.do_switch.lab_a -24
    %define mm_blockpcl.do_switch.lab_d -32
    %define mm_blockpcl.do_switch.labjump -40
    %define mm_blockpcl.do_switch.elselab -48
    %define mm_blockpcl.do_switch.labstmt -56
    %define mm_blockpcl.do_switch.ax -64
    %define mm_blockpcl.do_switch.bx -72
    %define mm_blockpcl.do_switch.ismult -80
    %define mm_blockpcl.do_switch.looptype -88
    %define mm_blockpcl.do_switch.opc -96
    %define mm_blockpcl.do_switch.labels -8104
    %define mm_blockpcl.do_switch.w -8112
    %define mm_blockpcl.do_switch.wt -8120
    %define mm_blockpcl.do_switch.pjump -8128
    %define mm_blockpcl.do_switch.psetup -8136
    %define mm_blockpcl.do_switch.djump -8144
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8184
    mov       r12,	rcx
    mov       r13,	rdx
    mov       [rbp+72],	r8
    mov       [rbp+80],	r9
;---------------
    movzx     rax,	byte [r12]
    cmp       rax,	107
    jz        L6055
    cmp       rax,	108
    jz        L6056
    cmp       rax,	109
    jz        L6057
    jmp       L6058
L6055:
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_switch.looptype],	al
    mov       al,	37
    mov       [rbp + mm_blockpcl.do_switch.opc],	al
    jmp       L6054
L6056:
;mm_blockpcl.do_switch.dodosw:
    mov       al,	1
    mov       [rbp + mm_blockpcl.do_switch.looptype],	al
    mov       al,	37
    mov       [rbp + mm_blockpcl.do_switch.opc],	al
    jmp       L6054
L6057:
    mov       al,	2
    mov       [rbp + mm_blockpcl.do_switch.looptype],	al
    mov       al,	38
    mov       [rbp + mm_blockpcl.do_switch.opc],	al
    jmp       L6054
L6058:
    mov       al,	3
    mov       [rbp + mm_blockpcl.do_switch.looptype],	al
L6054:
    movsxd    rax,	dword [r12+49]
    test      rax,	rax
    jz        L6060
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    test      rax,	rax
    jnz       L6060
    mov       rax,	1
    jmp       L6061
L6060:
    xor       eax,	eax
L6061:
    mov       [rbp + mm_blockpcl.do_switch.ismult],	rax
    mov       rdi,	1000000
    mov       rbx,	-1000000
    xor       rsi,	rsi
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_switch.iscomplex],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.pwhenthen]
    mov       [rbp + mm_blockpcl.do_switch.wt],	rax
    jmp       L6063
L6062:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.w],	rax
    jmp       L6066
L6065:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jz        L6069
    cmp       rax,	1
    jz        L6070
    jmp       L6071
L6069:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+16]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.ax],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.bx],	rax
;mm_blockpcl.do_switch.dorange:
L6072:
    mov       rax,	[rbp + mm_blockpcl.do_switch.ax]
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    cmp       rax,	[rbp + mm_blockpcl.do_switch.bx]
    jg        L6075
L6073:
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    mov       r10,	rdi
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rdi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    mov       r10,	rbx
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       rbx,	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    cmp       rax,	[rbp + mm_blockpcl.do_switch.bx]
    jle       L6073
L6075:
    jmp       L6068
L6070:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.bx],	rax
    mov       [rbp + mm_blockpcl.do_switch.ax],	rax
    jmp       L6072
L6071:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.w]
    call      mm_lib.strexpr
    mov       rax,	[rax]
    lea       rcx,	[L12858]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.gerror_s
L6068:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_switch.w],	rax
L6066:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    test      rax,	rax
    jnz       L6065
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_switch.wt],	rax
L6063:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    test      rax,	rax
    jnz       L6062
    mov       rax,	rbx
    sub       rax,	rdi
    inc       rax
    mov       rsi,	rax
    cmp       rsi,	1000
    jle       L6077
    lea       rcx,	[L12859]
    xor       edx,	edx
    call      mm_support.gerror
L6077:
    mov       al,	[rbp + mm_blockpcl.do_switch.looptype]
    test      al,	al
    jz        L6079
    call      mm_genpcl.definelabel
    mov       [rbp + mm_blockpcl.do_switch.lab_a],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_switch.lab_d],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_a]
    mov       rdx,	[rbp + mm_blockpcl.do_switch.lab_a]
    mov       r8,	[rbp + mm_blockpcl.do_switch.lab_d]
    call      mm_genpcl.stacklooplabels
    jmp       L6078
L6079:
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_switch.lab_d],	rax
L6078:
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_switch.labjump],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_switch.elselab],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.ismult]
    test      rax,	rax
    jz        L6081
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L6081:
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    cmp       rax,	3
    jnz       L6083
    mov       rax,	[r13+8]
    mov       [rbp + mm_blockpcl.do_switch.pjump],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.pjump]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6085
    lea       rcx,	[L12860]
    xor       edx,	edx
    call      mm_support.gerror
L6085:
    mov       rax,	[rbp + mm_blockpcl.do_switch.pjump]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.djump],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.djump]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L6087
    lea       rcx,	[L12861]
    xor       edx,	edx
    call      mm_support.gerror
L6087:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      pc_api.genlabel
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    mov       rax,	[pc_api.pccurr]
    mov       [rbp + mm_blockpcl.do_switch.psetup],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_switch.pjump]
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    mov       rax,	[mm_genpcl.pcldoswx]
    test      rax,	rax
    jnz       L6089
    lea       rcx,	[L12862]
    xor       edx,	edx
    call      mm_support.gerror
L6089:
    mov       rax,	[rbp + mm_blockpcl.do_switch.psetup]
    mov       r10,	[mm_genpcl.pcldoswx]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    mov       rax,	[rbp + mm_blockpcl.do_switch.psetup]
    lea       rax,	[rax+32]
    mov       r10,	[mm_genpcl.pcldoswx]
    lea       r10,	[r10+32]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    sub       qword [pc_api.pccurr],	64
L6083:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    cmp       rax,	3
    jz        L6091
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      pc_api.genlabel
    movzx     r10,	byte [rbp + mm_blockpcl.do_switch.opc]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rax
    call      pc_api.pc_genxy
    mov       rcx,	3
    call      mm_libpcl.setmode
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    cmp       rax,	2
    jge       L6093
    mov       rcx,	[rbp + mm_blockpcl.do_switch.elselab]
    call      pc_api.genlabel
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
L6093:
    jmp       L6090
L6091:
    lea       rcx,	[L12863]
    call      pc_api.gencomment
    mov       rcx,	25
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
L6090:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      mm_genpcl.definefwdlabel
    mov       [rbp + mm_blockpcl.do_switch.i],	rdi
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    cmp       rax,	rbx
    jg        L6096
L6094:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.elselab]
    call      pc_api.genlabel
    mov       rcx,	39
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[pc_api.pccurr]
    mov       r10,	[rbp + mm_blockpcl.do_switch.i]
    mov       [rbp + r10*8 + mm_blockpcl.do_switch.labels],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    cmp       rax,	rbx
    jle       L6094
L6096:
    mov       rcx,	40
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_blockpcl.do_switch.pwhenthen]
    mov       [rbp + mm_blockpcl.do_switch.wt],	rax
    jmp       L6098
L6097:
    call      mm_genpcl.definelabel
    mov       [rbp + mm_blockpcl.do_switch.labstmt],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.w],	rax
    jmp       L6101
L6100:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jz        L6104
    cmp       rax,	1
    jz        L6105
    jmp       L6106
L6104:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+16]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.ax],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.bx],	rax
    jmp       L6103
L6105:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.bx],	rax
    mov       [rbp + mm_blockpcl.do_switch.ax],	rax
L6106:
L6103:
    mov       rax,	[rbp + mm_blockpcl.do_switch.ax]
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    cmp       rax,	[rbp + mm_blockpcl.do_switch.bx]
    jg        L6109
L6107:
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    mov       rax,	[rbp + rax*8 + mm_blockpcl.do_switch.labels]
    mov       r10,	[rbp + mm_blockpcl.do_switch.labstmt]
    mov       [rax+8],	r10
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    cmp       rax,	[rbp + mm_blockpcl.do_switch.bx]
    jle       L6107
L6109:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_switch.w],	rax
L6101:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    test      rax,	rax
    jnz       L6100
    mov       rax,	[rbp + mm_blockpcl.do_switch.isref]
    test      rax,	rax
    jz        L6111
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+24]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6110
L6111:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rcx,	[rax+24]
    call      mm_blockpcl.evalunit
L6110:
    mov       rax,	[rbp + mm_blockpcl.do_switch.ismult]
    test      rax,	rax
    jz        L6113
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
L6113:
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    test      rax,	rax
    jz        L6115
    cmp       rax,	1
    jz        L6116
    cmp       rax,	2
    jz        L6117
    jmp       L6118
L6115:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_d]
    call      mm_blockpcl.genjumpl
    jmp       L6114
L6116:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_a]
    call      mm_blockpcl.genjumpl
    jmp       L6114
L6117:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      pc_api.genlabel
    movzx     r10,	byte [rbp + mm_blockpcl.do_switch.opc]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rax
    call      pc_api.pc_genxy
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L6114
L6118:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12864]
    call      pc_api.gencomment
    mov       rcx,	25
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
L6114:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_switch.wt],	rax
L6098:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    test      rax,	rax
    jnz       L6097
    mov       rcx,	[rbp + mm_blockpcl.do_switch.elselab]
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_switch.pelse]
    test      rax,	rax
    jz        L6120
    mov       rax,	[rbp + mm_blockpcl.do_switch.isref]
    test      rax,	rax
    jz        L6122
    mov       rcx,	[rbp + mm_blockpcl.do_switch.pelse]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6121
L6122:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.pelse]
    call      mm_blockpcl.evalunit
L6121:
    mov       rax,	[rbp + mm_blockpcl.do_switch.ismult]
    test      rax,	rax
    jz        L6124
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
L6124:
L6120:
    mov       al,	[rbp + mm_blockpcl.do_switch.looptype]
    test      al,	al
    jz        L6126
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    cmp       rax,	1
    jz        L6128
    cmp       rax,	2
    jz        L6129
    jmp       L6130
L6128:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_a]
    call      mm_blockpcl.genjumpl
    jmp       L6127
L6129:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      pc_api.genlabel
    movzx     r10,	byte [rbp + mm_blockpcl.do_switch.opc]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rax
    call      pc_api.pc_genxy
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L6127
L6130:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12865]
    call      pc_api.gencomment
    mov       rcx,	25
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
L6127:
    dec       qword [mm_genpcl.loopindex]
L6126:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_d]
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	8184
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_select
mm_blockpcl.do_select:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_blockpcl.do_select.b 80
    %define mm_blockpcl.do_select.c 88
    %define mm_blockpcl.do_select.isref 96
    %define mm_blockpcl.do_select.labels -2048
   %define R.labend rdi
   %define R.labjump rbx
   %define R.n rsi
   %define R.i r12
    %define mm_blockpcl.do_select.elselab -2056
    %define mm_blockpcl.do_select.labstmt -2064
    %define mm_blockpcl.do_select.ismult -2072
    %define mm_blockpcl.do_select.q -2080
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2112
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movsxd    rax,	dword [r13+49]
    test      rax,	rax
    jz        L6132
    mov       al,	[r13+61]
    test      al,	al
    jz        L6132
    mov       rax,	1
    jmp       L6133
L6132:
    xor       eax,	eax
L6133:
    mov       [rbp + mm_blockpcl.do_select.ismult],	rax
    mov       rax,	[rbp + mm_blockpcl.do_select.b]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
    xor       rsi,	rsi
    jmp       L6135
L6134:
    cmp       rsi,	256
    jl        L6138
    lea       rcx,	[L12866]
    xor       edx,	edx
    call      mm_support.gerror
L6138:
    inc       rsi
    mov       rax,	[rbp + mm_blockpcl.do_select.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
L6135:
    mov       rax,	[rbp + mm_blockpcl.do_select.q]
    test      rax,	rax
    jnz       L6134
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_select.elselab],	rax
    mov       rax,	[rbp + mm_blockpcl.do_select.ismult]
    test      rax,	rax
    jz        L6140
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L6140:
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      pc_api.genlabel
    mov       rcx,	37
    mov       rdx,	1
    mov       r8,	rsi
    mov       r9,	rax
    call      pc_api.pc_genxy
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	[rbp + mm_blockpcl.do_select.elselab]
    call      pc_api.genlabel
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_select.b]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
    xor       r12,	r12
    mov       rax,	1
    mov       r12,	rax
    cmp       rsi,	1
    jl        L6143
L6141:
    mov       rcx,	[rbp + mm_blockpcl.do_select.elselab]
    call      pc_api.genlabel
    mov       rcx,	39
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[pc_api.pccurr]
    mov       [rbp + r12*8 + mm_blockpcl.do_select.labels-8],	rax
    inc       r12
    cmp       r12,	rsi
    jle       L6141
L6143:
    mov       rcx,	40
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_blockpcl.do_select.b]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
    xor       r12,	r12
    jmp       L6145
L6144:
    call      mm_genpcl.definelabel
    mov       [rbp + mm_blockpcl.do_select.labstmt],	rax
    inc       r12
    mov       rax,	[rbp + r12*8 + mm_blockpcl.do_select.labels-8]
    mov       r10,	[rbp + mm_blockpcl.do_select.labstmt]
    mov       [rax+8],	r10
    mov       rax,	[rbp + mm_blockpcl.do_select.isref]
    test      rax,	rax
    jz        L6148
    mov       rcx,	[rbp + mm_blockpcl.do_select.q]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6147
L6148:
    mov       rcx,	[rbp + mm_blockpcl.do_select.q]
    call      mm_blockpcl.evalunit
L6147:
    mov       rax,	[rbp + mm_blockpcl.do_select.ismult]
    test      rax,	rax
    jz        L6150
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L6150:
    mov       rcx,	rdi
    call      mm_blockpcl.genjumpl
    mov       rax,	[rbp + mm_blockpcl.do_select.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
L6145:
    mov       rax,	[rbp + mm_blockpcl.do_select.q]
    test      rax,	rax
    jnz       L6144
    mov       rcx,	[rbp + mm_blockpcl.do_select.elselab]
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_select.isref]
    test      rax,	rax
    jz        L6152
    mov       rcx,	[rbp + mm_blockpcl.do_select.c]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6151
L6152:
    mov       rcx,	[rbp + mm_blockpcl.do_select.c]
    call      mm_blockpcl.evalunit
L6151:
    mov       rax,	[rbp + mm_blockpcl.do_select.ismult]
    test      rax,	rax
    jz        L6154
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L6154:
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	2112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_case
mm_blockpcl.do_case:
;?>>
   %define R.p r13
   %define R.pindex r14
    %define mm_blockpcl.do_case.pwhenthen 80
    %define mm_blockpcl.do_case.pelse 88
    %define mm_blockpcl.do_case.loopsw 96
    %define mm_blockpcl.do_case.isref 104
    %define mm_blockpcl.do_case.labtable -4000
    %define mm_blockpcl.do_case.unittable -8000
   %define R.ncases rdi
   %define R.ismult rbx
   %define R.lab_abc rsi
   %define R.lab_d r12
    %define mm_blockpcl.do_case.labelse -8008
    %define mm_blockpcl.do_case.w -8016
    %define mm_blockpcl.do_case.wt -8024
    %define mm_blockpcl.do_case.i -8032
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8064
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movzx     rax,	byte [r13]
    cmp       rax,	106
    setz      al
    movzx     eax,	al
    mov       [rbp + mm_blockpcl.do_case.loopsw],	rax
    test      r14,	r14
    jnz       L6157
    lea       rcx,	[L12867]
    xor       edx,	edx
    call      mm_support.gerror
L6157:
    movsxd    rax,	dword [r13+49]
    test      rax,	rax
    jz        L6158
    mov       rax,	[rbp + mm_blockpcl.do_case.loopsw]
    test      rax,	rax
    jnz       L6158
    mov       rax,	1
    jmp       L6159
L6158:
    xor       eax,	eax
L6159:
    mov       rbx,	rax
    mov       rax,	[rbp + mm_blockpcl.do_case.loopsw]
    test      rax,	rax
    jz        L6161
    call      mm_genpcl.definelabel
    mov       rsi,	rax
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	rsi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_genpcl.stacklooplabels
    jmp       L6160
L6161:
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
L6160:
    test      rbx,	rbx
    jz        L6163
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L6163:
    xor       rdi,	rdi
    mov       rax,	[mm_blockpcl.casedepth]
    cmp       rax,	20
    jl        L6165
    lea       rcx,	[L12868]
    xor       edx,	edx
    call      mm_support.gerror
L6165:
    inc       qword [mm_blockpcl.casedepth]
    mov       rax,	[mm_blockpcl.casedepth]
    mov       r10,	r13
    lea       r11,	[mm_blockpcl.casestmt]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[rbp + mm_blockpcl.do_case.pwhenthen]
    test      rax,	rax
    jnz       L6167
    test      rbx,	rbx
    jz        L6169
    lea       rcx,	[L12869]
    xor       edx,	edx
    call      mm_support.gerror
L6169:
    jmp       L6170
L6167:
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rax,	[rbp + mm_blockpcl.do_case.pwhenthen]
    mov       [rbp + mm_blockpcl.do_case.wt],	rax
    jmp       L6172
L6171:
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_case.w],	rax
    cmp       rdi,	500
    jl        L6175
    lea       rcx,	[L12870]
    xor       edx,	edx
    call      mm_support.gerror
L6175:
    call      mm_genpcl.createfwdlabel
    inc       rdi
    mov       r10,	rdi
    mov       [rbp + r10*8 + mm_blockpcl.do_case.labtable-8],	rax
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    mov       rax,	[rax+24]
    mov       [rbp + rdi*8 + mm_blockpcl.do_case.unittable-8],	rax
    jmp       L6177
L6176:
    mov       rcx,	[rbp + mm_blockpcl.do_case.w]
    call      mm_blockpcl.evalunit
    mov       rax,	[rbp + rdi*8 + mm_blockpcl.do_case.labtable-8]
    mov       r10,	rax
    mov       r11,	[rbp + mm_blockpcl.do_case.w]
    mov       [r11+40],	r10d
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	1
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rax,	[rbp + mm_blockpcl.do_case.w]
    mov       rax,	[rax+8]
    test      rax,	rax
    jnz       L6181
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L6180
L6181:
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L6180:
    mov       rcx,	[rbp + mm_blockpcl.do_case.w]
    call      mm_libpcl.setmode_u
    mov       rax,	[rbp + mm_blockpcl.do_case.w]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_case.w],	rax
L6177:
    mov       rax,	[rbp + mm_blockpcl.do_case.w]
    test      rax,	rax
    jnz       L6176
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_case.wt],	rax
L6172:
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    test      rax,	rax
    jnz       L6171
;mm_blockpcl.do_case.skip:
L6170:
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_case.labelse],	rax
    mov       rax,	[rbp + mm_blockpcl.do_case.labelse]
    lea       r10,	[mm_blockpcl.caseelse]
    mov       r11,	[mm_blockpcl.casedepth]
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_case.labelse]
    call      mm_blockpcl.genjumpl
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_case.i],	rax
    cmp       rdi,	1
    jl        L6184
L6182:
    mov       rax,	[rbp + mm_blockpcl.do_case.i]
    mov       rcx,	[rbp + rax*8 + mm_blockpcl.do_case.labtable-8]
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_case.isref]
    test      rax,	rax
    jz        L6186
    mov       rax,	[rbp + mm_blockpcl.do_case.i]
    mov       rax,	[rbp + rax*8 + mm_blockpcl.do_case.unittable-8]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6185
L6186:
    mov       rax,	[rbp + mm_blockpcl.do_case.i]
    mov       rcx,	[rbp + rax*8 + mm_blockpcl.do_case.unittable-8]
    call      mm_blockpcl.evalunit
L6185:
    test      rbx,	rbx
    jz        L6188
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L6188:
    mov       rax,	[rbp + mm_blockpcl.do_case.loopsw]
    test      rax,	rax
    jz        L6190
    mov       rcx,	rsi
    call      mm_blockpcl.genjumpl
    jmp       L6189
L6190:
    mov       rcx,	r12
    call      mm_blockpcl.genjumpl
L6189:
    mov       rax,	[rbp + mm_blockpcl.do_case.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_case.i],	rax
    cmp       rax,	rdi
    jle       L6182
L6184:
    mov       rcx,	[rbp + mm_blockpcl.do_case.labelse]
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_case.pelse]
    test      rax,	rax
    jz        L6192
    mov       rax,	[rbp + mm_blockpcl.do_case.isref]
    test      rax,	rax
    jz        L6194
    mov       rcx,	[rbp + mm_blockpcl.do_case.pelse]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6193
L6194:
    mov       rcx,	[rbp + mm_blockpcl.do_case.pelse]
    call      mm_blockpcl.evalunit
L6193:
    test      rbx,	rbx
    jz        L6196
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L6196:
L6192:
    mov       rax,	[rbp + mm_blockpcl.do_case.loopsw]
    test      rax,	rax
    jz        L6198
    mov       rcx,	rsi
    call      mm_blockpcl.genjumpl
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
    jmp       L6197
L6198:
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
L6197:
    dec       qword [mm_blockpcl.casedepth]
;---------------
    add       rsp,	8064
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_dotindex
mm_blockpcl.do_dotindex:
;?>>
    %define mm_blockpcl.do_dotindex.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	14
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_dotslice
mm_blockpcl.do_dotslice:
;?>>
    %define mm_blockpcl.do_dotslice.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	15
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_read
mm_blockpcl.do_read:
;?>>
   %define R.p rbx
   %define R.a rsi
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    test      rsi,	rsi
    jnz       L6203
    mov       rsi,	[mm_genpcl.pzero]
L6203:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L6205
    mov       rcx,	23
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_genpcl.genpc_sysfn
    jmp       L6204
L6205:
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L6206
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    cmp       rax,	8
    jnz       L6206
    mov       rcx,	24
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_genpcl.genpc_sysfn
    jmp       L6204
L6206:
    cmp       rdi,	20
    jnz       L6207
    mov       rcx,	25
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_genpcl.genpc_sysfn
    jmp       L6204
L6207:
    call      msys.m$print_startcon
    lea       rcx,	[L12871]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12872]
    xor       edx,	edx
    call      mm_support.gerror
L6204:
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_readln
mm_blockpcl.do_readln:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L6210
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L6212
    lea       rcx,	[L12873]
    xor       edx,	edx
    call      mm_support.gerror
L6212:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttbasetype]
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jz        L6214
    cmp       rax,	17
    jz        L6215
    cmp       rax,	12
    jz        L6215
    jmp       L6216
L6214:
    sub       rsp,	8
    push      0
    mov       rcx,	26
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L6213
L6215:
    sub       rsp,	8
    push      0
    mov       rcx,	27
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L6213
L6216:
    lea       rcx,	[L12874]
    xor       edx,	edx
    call      mm_support.gerror
L6213:
    jmp       L6209
L6210:
    sub       rsp,	8
    push      0
    mov       rcx,	28
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L6209:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.docond
mm_blockpcl.docond:
;?>>
   %define R.opc rdi
   %define R.p rbx
   %define R.lab rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_blockpcl.genjumpcond
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_syscall
mm_blockpcl.do_syscall:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    call      mm_genpcl.setfunctab
    movsx     rax,	word [rdi+40]
    cmp       rax,	29
    jz        L6220
    cmp       rax,	30
    jz        L6221
    cmp       rax,	31
    jz        L6222
    jmp       L6223
L6220:
    mov       rcx,	[mm_blockpcl.pnprocs]
    call      pc_api.genmem
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L6219
L6221:
    mov       rcx,	[mm_blockpcl.pprocname]
    call      pc_api.genmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	3
    mov       rdx,	8
    mov       r8,	-8
    call      pc_api.pc_genix
    jmp       L6219
L6222:
    mov       rcx,	[mm_blockpcl.pprocaddr]
    call      pc_api.genmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	3
    mov       rdx,	8
    mov       r8,	-8
    call      pc_api.pc_genix
    jmp       L6219
L6223:
    lea       rcx,	[L12875]
    call      pc_api.gencomment
L6219:
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_slice
mm_blockpcl.do_slice:
;?>>
    %define mm_blockpcl.do_slice.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    test      rbx,	rbx
    jnz       L6226
    mov       rcx,	rdi
    call      mm_blockpcl.evalarray
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jnz       L6228
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      strlen
    mov       rcx,	rax
    call      mm_genpcl.genpushint
    jmp       L6227
L6228:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttlength]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rcx,	r10
    call      mm_genpcl.genpushint
L6227:
    jmp       L6225
L6226:
    mov       rax,	[rbx+16]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_blockpcl.do_indexref
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax]
    mov       r10,	[rbx+24]
    movzx     r10,	byte [r10]
    cmp       r10,	rax
    jnz       L6230
    cmp       r10,	1
    jnz       L6230
    mov       rax,	[rbx+24]
    mov       rax,	[rax+16]
    mov       r10,	[rbx+16]
    mov       r10,	[r10+16]
    sub       rax,	r10
    inc       rax
    mov       rcx,	rax
    call      mm_genpcl.genpushint
    jmp       L6229
L6230:
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	44
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	1
    call      mm_genpcl.genpushint
    mov       rcx,	43
    xor       edx,	edx
    call      pc_api.pc_gen
L6229:
    mov       rcx,	3
    call      mm_libpcl.setmode
L6225:
    mov       rcx,	7
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	11
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignblock
mm_blockpcl.do_assignblock:
;?>>
    %define mm_blockpcl.do_assignblock.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	20
    jnz       L6233
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	10
    jnz       L6235
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignarray
    jmp       L6234
L6235:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignrecord
L6234:
    jmp       L6232
L6233:
    lea       rcx,	[L12876]
    xor       edx,	edx
    call      mm_support.gerror
L6232:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignarray
mm_blockpcl.do_assignarray:
;?>>
   %define R.a r14
   %define R.b r15
   %define R.passign rdi
   %define R.pindex rbx
   %define R.pconst rsi
   %define R.q r12
   %define R.index r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r14,	rcx
    mov       r15,	rdx
;---------------
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttbasetype]
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jnz       L6238
    lea       rcx,	[L12877]
    xor       edx,	edx
    call      mm_support.gerror
L6238:
    mov       rcx,	1
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rsi,	rax
    mov       rcx,	46
    mov       rdx,	r14
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rbx,	rax
    mov       rax,	[r15+16]
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       [rbx+49],	r10d
    mov       [rdi+49],	r10d
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    mov       r13,	r10
    mov       r12,	[r15+16]
    jmp       L6240
L6239:
    mov       [rsi+16],	r13
    mov       al,	1
    mov       [rsi+61],	al
    mov       [rdi+24],	r12
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    inc       r13
    mov       r12,	[r12+8]
L6240:
    test      r12,	r12
    jnz       L6239
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignrecord
mm_blockpcl.do_assignrecord:
;?>>
    %define mm_blockpcl.do_assignrecord.a 72
    %define mm_blockpcl.do_assignrecord.b 80
   %define R.passign rdi
   %define R.pdot rbx
   %define R.pfield rsi
   %define R.q r12
   %define R.m r13
   %define R.fieldtype r14
   %define R.d r15
    %define mm_blockpcl.do_assignrecord.e -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rcx,	4
    call      mm_lib.createunit0
    mov       rsi,	rax
    mov       rcx,	49
    mov       rdx,	[rbp + mm_blockpcl.do_assignrecord.a]
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rbx,	rax
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.b]
    mov       rax,	[rax+16]
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.a]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       [rbx+49],	r10d
    mov       [rdi+49],	r10d
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.a]
    movsxd    rax,	dword [rax+49]
    mov       r13,	rax
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r13
    mov       r15,	[rax + r10*8]
    mov       rax,	[r15+16]
    mov       [rbp + mm_blockpcl.do_assignrecord.e],	rax
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.b]
    mov       r12,	[rax+16]
    jmp       L6244
L6243:
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jnz       L6247
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jz        L6247
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    movsxd    rax,	dword [rax+72]
    mov       r14,	rax
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    mov       [rsi+16],	rax
    mov       eax,	r14d
    mov       [rbx+49],	eax
    mov       [rsi+49],	eax
    mov       [rdi+49],	eax
    mov       [rdi+24],	r12
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    mov       eax,	[rax+84]
    mov       [rbx+40],	eax
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       r12,	[r12+8]
L6247:
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_blockpcl.do_assignrecord.e],	rax
L6244:
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    test      rax,	rax
    jnz       L6243
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.pushrhs
mm_blockpcl.pushrhs:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jnz       L6250
    jmp       L6248
L6250:
    mov       rcx,	[rdi+8]
    call      mm_blockpcl.pushrhs
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
L6248:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignms
mm_blockpcl.do_assignms:
;?>>
   %define R.a r13
   %define R.b r14
   %define R.nlhs rdi
   %define R.nrhs rbx
   %define R.d rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    mov       eax,	[r13+40]
    mov       rdi,	rax
    movzx     rax,	byte [r14]
    cmp       rax,	32
    jnz       L6254
L6253:
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rax,	[r14+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6256
    lea       rcx,	[L12878]
    xor       edx,	edx
    call      mm_support.gerror
L6256:
    mov       rax,	[r14+16]
    mov       rsi,	[rax+16]
    movzx     rax,	byte [rsi+122]
    mov       rbx,	rax
    mov       r13,	[r13+16]
    jmp       L6252
L6254:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	11
    jnz       L6258
    lea       rcx,	[L12879]
    xor       edx,	edx
    call      mm_support.gerror
    jmp       L6257
L6258:
    lea       rcx,	[L12880]
    xor       edx,	edx
    call      mm_support.gerror
L6257:
L6252:
    mov       rcx,	r13
    call      mm_blockpcl.poptomult
    cmp       rbx,	rdi
    jle       L6260
    mov       rcx,	r14
    call      mm_lib.getprocretmodes
    mov       rsi,	rax
    lea       rax,	[rdi+1]
    mov       r12,	rax
    cmp       r12,	rbx
    jg        L6263
L6261:
    mov       rcx,	11
    xor       edx,	edx
    call      pc_api.pc_gen
    movsxd    rax,	dword [rsi+72]
    lea       r10,	[mm_decls.ttmult]
    mov       r10,	[r10 + rax*8]
    mov       rax,	r12
    movsxd    r10,	dword [r10 + rax*4-4]
    mov       rcx,	r10
    call      mm_libpcl.setmode
    inc       r12
    cmp       r12,	rbx
    jle       L6261
L6263:
L6260:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignmm
mm_blockpcl.do_assignmm:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.pushrhs
    mov       rcx,	133
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rdi+16]
    call      mm_blockpcl.poptomult
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignmdrem
mm_blockpcl.do_assignmdrem:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	[rdi+16]
    call      mm_blockpcl.poptomult
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.poptomult
mm_blockpcl.poptomult:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
L6267:
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jz        L6271
    cmp       rax,	46
    jz        L6272
    cmp       rax,	48
    jz        L6272
    cmp       rax,	49
    jz        L6272
    cmp       rax,	53
    jz        L6273
    cmp       rax,	92
    jz        L6274
    cmp       rax,	105
    jz        L6274
    cmp       rax,	107
    jz        L6274
    cmp       rax,	112
    jz        L6274
    cmp       rax,	51
    jz        L6275
    jmp       L6276
L6271:
    mov       rcx,	rdi
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L6270
L6272:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L6270
L6273:
    mov       rcx,	[rdi+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L6270
L6274:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L6270
L6275:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	[rdi+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	16
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L6270
L6276:
    call      msys.m$print_startcon
    movzx     rax,	byte [rdi]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12881]
    xor       edx,	edx
    call      mm_support.gerror
L6270:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       rdi,	[rdi+8]
    test      rdi,	rdi
    jnz       L6267
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_recase
mm_blockpcl.do_recase:
;?>>
    %define mm_blockpcl.do_recase.p 64
   %define R.a r14
   %define R.q rdi
   %define R.wt rbx
   %define R.w rsi
   %define R.destlab r12
   %define R.casevalue r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rdx
;---------------
    mov       rax,	[mm_blockpcl.casedepth]
    test      rax,	rax
    jnz       L6279
    lea       rcx,	[L12882]
    xor       edx,	edx
    call      mm_support.gerror
L6279:
    test      r14,	r14
    jz        L6281
    mov       r13,	[r14+16]
    jmp       L6280
L6281:
    lea       rax,	[mm_blockpcl.caseelse]
    mov       r10,	[mm_blockpcl.casedepth]
    mov       rcx,	[rax + r10*8-8]
    call      mm_blockpcl.genjumpl
L6280:
    lea       rax,	[mm_blockpcl.casestmt]
    mov       r10,	[mm_blockpcl.casedepth]
    mov       rdi,	[rax + r10*8-8]
    xor       r12,	r12
    mov       rax,	[rdi+24]
    mov       rbx,	rax
    jmp       L6283
L6282:
    mov       rsi,	[rbx+16]
    jmp       L6286
L6285:
    movzx     rax,	byte [rsi]
    cmp       rax,	1
    jnz       L6289
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L6289
    mov       rax,	[rsi+16]
    cmp       rax,	r13
    jnz       L6289
    movsxd    rax,	dword [rsi+40]
    mov       r12,	rax
    jmp       L6284
L6289:
    mov       rsi,	[rsi+8]
L6286:
    test      rsi,	rsi
    jnz       L6285
    mov       rbx,	[rbx+8]
L6283:
    test      rbx,	rbx
    jnz       L6282
L6284:
    test      r12,	r12
    jnz       L6291
    lea       rax,	[mm_blockpcl.caseelse]
    mov       r10,	[mm_blockpcl.casedepth]
    mov       rcx,	[rax + r10*8-8]
    call      mm_blockpcl.genjumpl
    jmp       L6290
L6291:
    mov       rcx,	r12
    call      mm_blockpcl.genjumpl
L6290:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_empty
mm_blockpcl.do_empty:
;?>>
    %define mm_blockpcl.do_empty.p 24
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	41
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_typeconst
mm_blockpcl.do_typeconst:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[rdi+16]
    call      mm_genpcl.genpushint
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_setinplace
mm_blockpcl.do_setinplace:
;?>>
;?]]
;---------------
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L6296
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax+1]
    cmp       rax,	2
    jnz       L6296
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L6296:
;---------------
    ret       
;End 
;Proc mm_assem.readassemline
mm_assem.readassemline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.lex
    mov       rcx,	1
    call      mm_assem.assembleline
L6297:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_assem.readassemblock
mm_assem.readassemblock:
;?>>
    %define mm_assem.readassemblock.ulist -8
    %define mm_assem.readassemblock.ulistx -16
   %define R.u rdi
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
;---------------
    xor       eax,	eax
    mov       [rbp + mm_assem.readassemblock.ulistx],	rax
    mov       [rbp + mm_assem.readassemblock.ulist],	rax
L6299:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	59
    jz        L6302
    cmp       rax,	87
    jz        L6303
    cmp       rax,	4
    jz        L6304
    jmp       L6305
L6302:
    lea       rcx,	[L12883]
    call      mm_support.serror
    jmp       L6301
L6303:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rcx,	rax
    mov       rdx,	135
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    jmp       L6300
L6304:
    jmp       L6301
L6305:
    xor       ecx,	ecx
    call      mm_assem.assembleline
    mov       rdi,	rax
    lea       rcx,	[rbp + mm_assem.readassemblock.ulist]
    lea       rdx,	[rbp + mm_assem.readassemblock.ulistx]
    mov       r8,	rdi
    call      mm_lib.addlistunit
L6301:
    jmp       L6299
L6300:
    mov       rcx,	[rbp + mm_assem.readassemblock.ulist]
    call      mm_parse.makeblock
L6298:
;---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_assem.assembleline
mm_assem.assembleline:
;?>>
   %define R.oneline r15
    %define mm_assem.assembleline.dlist -8
    %define mm_assem.assembleline.dlistx -16
   %define R.p rdi
   %define R.pname rbx
   %define R.q rsi
   %define R.opc r12
   %define R.noperands r13
   %define R.stname r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r15,	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + mm_assem.assembleline.dlistx],	rax
    mov       [rbp + mm_assem.assembleline.dlist],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6308
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L6308
    mov       rcx,	100
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rax
    mov       r8,	14
    call      mm_lib.getduplnameptr
    mov       r14,	rax
    mov       [rdi+16],	r14
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	r14
    call      mm_lib.adddef
    call      mm_lex.lex
    test      r15,	r15
    jz        L6310
    call      mm_lex.lex
L6310:
    mov       rax,	rdi
    jmp       L6306
L6308:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	26
    jnz       L6311
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rbx+4],	eax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6313
L6314:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_assem.assembleline.dlist]
    lea       rdx,	[rbp + mm_assem.assembleline.dlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L6318
    call      mm_lex.lex
L6318:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6319
    cmp       rax,	59
    jnz       L6314
L6319:
L6313:
    mov       rcx,	9
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_assem.assembleline.dlist]
    call      mm_lib.createunit2
    jmp       L6306
L6311:
L6307:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	38
    jz        L6321
    cmp       rax,	39
    jz        L6322
    cmp       rax,	40
    jz        L6323
    cmp       rax,	47
    jz        L6324
    cmp       rax,	108
    jz        L6325
    jmp       L6326
L6321:
    mov       r12,	38
;mm_assem.assembleline.doop:
L6327:
    mov       rcx,	8
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       [rdi+40],	r12w
    call      mm_lex.lex
    jmp       L6320
L6322:
    mov       r12,	39
    jmp       L6327
L6323:
    mov       r12,	40
    jmp       L6327
L6324:
    mov       r12,	51
    jmp       L6327
L6325:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L6329
    mov       r12,	29
    jmp       L6327
L6329:
    jmp       L6330
L6326:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6332
    mov       rcx,	8
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	78
    jz        L6334
    cmp       rax,	74
    jz        L6335
    cmp       rax,	75
    jz        L6336
    cmp       rax,	76
    jz        L6337
    jmp       L6338
L6334:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+40],	ax
    jmp       L6333
L6335:
    mov       ax,	26
    mov       [rdi+40],	ax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+45],	al
    jmp       L6333
L6336:
    mov       ax,	58
    mov       [rdi+40],	ax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+45],	al
    jmp       L6333
L6337:
    mov       ax,	15
    mov       [rdi+40],	ax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+45],	al
    jmp       L6333
L6338:
    lea       rcx,	[L12884]
    call      mm_lex.ps
    lea       rcx,	[L12885]
    call      mm_support.serror
L6333:
    call      mm_lex.lex
    jmp       L6331
L6332:
;mm_assem.assembleline.$else:
L6330:
    lea       rcx,	[L12886]
    call      mm_lex.ps
    lea       rcx,	[L12887]
    call      mm_support.serror
L6331:
L6320:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6340
    cmp       rax,	59
    jz        L6340
    xor       r13,	r13
L6341:
    call      mm_assem.readassemopnd
    mov       rsi,	rax
    inc       r13
    cmp       r13,	3
    jg        L6344
    lea       rax,	[rdi+16]
    mov       r10,	rsi
    mov       r11,	r13
    mov       [rax + r11*8-8],	r10
    jmp       L6343
L6344:
    lea       rcx,	[L12888]
    call      mm_support.serror
L6343:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L6342
L6346:
    call      mm_lex.lex
L6345:
    jmp       L6341
L6342:
L6340:
    mov       rcx,	4
    call      mm_parse.checksymbol
    mov       rax,	rdi
L6306:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_assem.readassemopnd
mm_assem.readassemopnd:
;?>>
   %define R.p rdi
   %define R.reg rbx
   %define R.regix rsi
   %define R.scale r12
   %define R.prefixmode r13
   %define R.pcode r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jz        L6349
    cmp       rax,	63
    jz        L6349
    cmp       rax,	67
    jz        L6350
    cmp       rax,	24
    jz        L6351
    cmp       rax,	25
    jz        L6351
    cmp       rax,	79
    jz        L6352
    cmp       rax,	11
    jz        L6353
    jmp       L6354
L6349:
    call      mm_parse.readunit
    jmp       L6347
L6350:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+79]
    cmp       rax,	70
    jz        L6356
    cmp       rax,	71
    jz        L6357
    jmp       L6358
L6356:
    mov       rcx,	10
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+40],	eax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       ax,	[rax+164]
    mov       [rdi+44],	al
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L6347
L6357:
    mov       rcx,	11
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+40],	eax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L6347
L6358:
L6355:
    call      mm_parse.readunit
    jmp       L6347
L6351:
    call      mm_parse.readunit
    jmp       L6347
L6352:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	17
    jz        L6360
    cmp       rax,	18
    jz        L6360
    cmp       rax,	19
    jz        L6360
    cmp       rax,	4
    jnz       L6361
L6360:
    jmp       L6359
L6361:
    lea       rcx,	[L12889]
    call      mm_support.serror
L6359:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r13,	rax
    mov       rcx,	11
    call      mm_parse.lexchecksymbol
    jmp       L6362
L6353:
    xor       r13,	r13
;mm_assem.readassemopnd.gotprefix:
L6362:
    xor       eax,	eax
    mov       rsi,	rax
    mov       rbx,	rax
    xor       r14,	r14
    mov       rax,	1
    mov       r12,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6364
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+79]
    cmp       rax,	70
    jnz       L6364
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movsxd    rax,	dword [rax+80]
    mov       rbx,	rax
    call      mm_lex.lex
L6364:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	24
    jnz       L6366
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6366
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+79]
    cmp       rax,	70
    jnz       L6366
    call      mm_lex.lex
L6366:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6368
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+79]
    cmp       rax,	70
    jnz       L6368
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movsxd    rax,	dword [rax+80]
    mov       rsi,	rax
    call      mm_lex.lex
L6368:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	26
    jnz       L6370
    mov       rcx,	62
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r12,	rax
    cmp       rax,	1
    jz        L6372
    cmp       rax,	2
    jz        L6372
    cmp       rax,	4
    jz        L6372
    cmp       rax,	8
    jnz       L6373
L6372:
    jmp       L6371
L6373:
    lea       rcx,	[L12890]
    call      mm_support.serror
L6371:
    call      mm_lex.lex
L6370:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	24
    jz        L6375
    cmp       rax,	25
    jz        L6375
    cmp       rax,	62
    jz        L6375
    cmp       rax,	67
    jz        L6375
    cmp       rax,	9
    jz        L6375
    cmp       rax,	136
    jnz       L6376
L6375:
    call      mm_parse.readunit
    mov       r14,	rax
L6376:
L6374:
    mov       rcx,	12
    call      mm_parse.checksymbol
    call      mm_lex.lex
    mov       rcx,	12
    mov       rdx,	r14
    call      mm_lib.createunit1
    mov       rdi,	rax
    test      rsi,	rsi
    jnz       L6378
    cmp       r12,	1
    jle       L6378
    mov       rsi,	rbx
    xor       rbx,	rbx
L6378:
    test      r14,	r14
    jnz       L6380
    mov       rax,	rbx
    add       rax,	rsi
    test      rax,	rax
    jnz       L6380
    lea       rcx,	[L12891]
    call      mm_support.serror
L6380:
    mov       [rdi+40],	bl
    mov       [rdi+41],	sil
    mov       [rdi+42],	r12b
    mov       [rdi+43],	r13b
    mov       rax,	rdi
    jmp       L6347
L6354:
    lea       rcx,	[L12892]
    call      mm_lex.ps
    lea       rcx,	[L12893]
    call      mm_support.serror
L6348:
    xor       eax,	eax
L6347:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_assem.initassemsymbols
mm_assem.initassemsymbols:
;?>>
    %define mm_assem.initassemsymbols.str -32
   %define R.i rdi
   %define R.av_1 rbx
   %define R.av_2 rsi
   %define R.av_3 r12
   %define R.av_4 r13
   %define R.av_5 r14
    %define mm_assem.initassemsymbols.av_6 -40
    %define mm_assem.initassemsymbols.av_7 -48
    %define mm_assem.initassemsymbols.av_8 -56
    %define mm_assem.initassemsymbols.av_9 -64
    %define mm_assem.initassemsymbols.av_10 -72
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	104
;---------------
    mov       rdi,	1
    mov       rbx,	151
    cmp       rbx,	1
    jl        L6384
L6382:
    lea       rax,	[mc_decls.mclnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+2]
    mov       rcx,	rax
    mov       rdx,	78
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	rbx
    jle       L6382
L6384:
    mov       rdi,	1
    mov       rsi,	137
    cmp       rsi,	1
    jl        L6387
L6385:
    lea       rax,	[mc_decls.regsizes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.regindices]
    mov       r11,	rdi
    movzx     r10,	byte [r10 + r11-1]
    lea       r11,	[mc_decls.dregnames]
    mov       r15,	rdi
    mov       r11,	[r11 + r15*8-8]
    mov       rcx,	r11
    mov       rdx,	70
    mov       r8,	r10
    mov       r9,	rax
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	rsi
    jle       L6385
L6387:
    mov       rdi,	1
    mov       r12,	16
    cmp       r12,	1
    jl        L6390
L6388:
    lea       rax,	[mc_decls.xmmregnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	71
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	r12
    jle       L6388
L6390:
    mov       rdi,	1
    mov       r13,	8
    cmp       r13,	1
    jl        L6393
L6391:
    lea       rax,	[mc_decls.fregnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	72
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	r13
    jle       L6391
L6393:
    mov       rdi,	1
    mov       r14,	8
    cmp       r14,	1
    jl        L6396
L6394:
    lea       rax,	[mc_decls.mregnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	73
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	r14
    jle       L6394
L6396:
    mov       rdi,	1
    mov       rax,	18
    mov       [rbp + mm_assem.initassemsymbols.av_6],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_6]
    cmp       rax,	1
    jl        L6399
L6397:
    lea       rax,	[mc_decls.jmpcccodes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.jmpccnames]
    mov       r11,	rdi
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	74
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_6]
    jle       L6397
L6399:
    mov       rdi,	1
    mov       rax,	16
    mov       [rbp + mm_assem.initassemsymbols.av_7],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_7]
    cmp       rax,	1
    jl        L6402
L6400:
    lea       rax,	[mc_decls.setcccodes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.setccnames]
    mov       r11,	rdi
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	75
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_7]
    jle       L6400
L6402:
    mov       rdi,	1
    mov       rax,	16
    mov       [rbp + mm_assem.initassemsymbols.av_8],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_8]
    cmp       rax,	1
    jl        L6405
L6403:
    lea       rax,	[mc_decls.cmovcccodes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.cmovccnames]
    mov       r11,	rdi
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	76
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_8]
    jle       L6403
L6405:
    mov       rdi,	1
    mov       rax,	5
    mov       [rbp + mm_assem.initassemsymbols.av_9],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_9]
    cmp       rax,	1
    jl        L6408
L6406:
    lea       rax,	[mc_decls.segmentnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rbp + mm_assem.initassemsymbols.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mm_assem.initassemsymbols.str]
    call      strlen
    xor       r10d,	r10d
    mov       [rbp + rax + mm_assem.initassemsymbols.str-4],	r10b
    lea       rcx,	[rbp + mm_assem.initassemsymbols.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    mov       rdx,	77
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_9]
    jle       L6406
L6408:
    mov       rdi,	1
    mov       rax,	6
    mov       [rbp + mm_assem.initassemsymbols.av_10],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_10]
    cmp       rax,	1
    jl        L6411
L6409:
    lea       rax,	[mm_assem.initassemsymbols.sizes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mm_assem.initassemsymbols.regnos]
    mov       r11,	rdi
    movzx     r10,	byte [r10 + r11-1]
    lea       r11,	[mm_assem.initassemsymbols.regnames]
    mov       r15,	rdi
    mov       r11,	[r11 + r15*8-8]
    mov       rcx,	r11
    mov       rdx,	70
    mov       r8,	r10
    mov       r9,	rax
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_10]
    jle       L6409
L6411:
;---------------
    add       rsp,	104
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_assemaux.domcl_assem
mm_assemaux.domcl_assem:
;?>>
   %define R.pcode rdi
    %define mm_assemaux.domcl_assem.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L6415
    movzx     rax,	byte [rdi]
    cmp       rax,	8
    jz        L6414
L6415:
    jmp       L6412
L6414:
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mm_assemaux.genasmopnd
    mov       [rbp + mm_assemaux.domcl_assem.$T1],	rax
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mm_assemaux.genasmopnd
    movsx     r10,	word [rdi+40]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mm_assemaux.domcl_assem.$T1]
    call      mc_libmcl.genmc
    mov       al,	[rdi+45]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+34],	al
    movsx     rax,	word [rdi+40]
    cmp       rax,	92
    jz        L6417
    cmp       rax,	93
    jz        L6417
    cmp       rax,	61
    jz        L6417
    cmp       rax,	62
    jnz       L6418
L6417:
    mov       rax,	[rdi+32]
    test      rax,	rax
    jz        L6421
    mov       rax,	[rdi+32]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L6420
L6421:
    lea       rcx,	[L12894]
    xor       edx,	edx
    call      mm_support.gerror
L6420:
    mov       rax,	[rdi+32]
    mov       rax,	[rax+16]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+32],	al
L6418:
L6416:
L6412:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_assemaux.genasmopnd
mm_assemaux.genasmopnd:
;?>>
    %define mm_assemaux.genasmopnd.p 64
   %define R.ax rdi
   %define R.d rbx
   %define R.offset rsi
   %define R.labno r12
   %define R.a r13
   %define R.x r14
    %define mm_assemaux.genasmopnd.y -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    test      rax,	rax
    jnz       L6424
    xor       eax,	eax
    jmp       L6422
L6424:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L6426
    cmp       rax,	1
    jz        L6427
    cmp       rax,	12
    jz        L6428
    cmp       rax,	4
    jz        L6429
    cmp       rax,	11
    jz        L6430
    cmp       rax,	35
    jz        L6431
    jmp       L6432
L6426:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+44]
    lea       r10,	[mc_decls.regmodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+40]
    mov       rcx,	rax
    mov       rdx,	r10
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    jmp       L6425
L6427:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rdi,	rax
    jmp       L6425
L6428:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       r13,	[rax+16]
    xor       rbx,	rbx
    xor       eax,	eax
    mov       r12,	rax
    mov       rsi,	rax
    test      r13,	r13
    jz        L6434
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jz        L6436
    cmp       rax,	4
    jz        L6437
    cmp       rax,	35
    jz        L6438
    cmp       rax,	36
    jz        L6439
    cmp       rax,	90
    jz        L6440
    jmp       L6441
L6436:
    mov       rsi,	[r13+16]
    jmp       L6435
L6437:
    mov       rax,	[r13+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rbx,	rax
    movzx     rax,	byte [rbx+72]
    cmp       rax,	6
    jnz       L6443
    mov       rcx,	rbx
    call      mm_assemaux.fixasmlabel
    mov       r12,	rax
    xor       rbx,	rbx
L6443:
    jmp       L6435
L6438:
    mov       r14,	[r13+16]
    mov       rax,	[r13+24]
    mov       [rbp + mm_assemaux.genasmopnd.y],	rax
    movzx     rax,	byte [r14]
    cmp       rax,	4
    jnz       L6445
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L6445
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rbx,	rax
    movzx     rax,	byte [rbx+72]
    cmp       rax,	6
    jnz       L6447
    mov       rcx,	rbx
    call      mm_assemaux.fixasmlabel
    mov       r12,	rax
    xor       rbx,	rbx
L6447:
    jmp       L6444
L6445:
    jmp       L6448
L6444:
    movzx     rax,	byte [r13+62]
    cmp       rax,	43
    jz        L6451
    cmp       rax,	57
    jnz       L6450
L6451:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    mov       rax,	[rax+16]
    jmp       L6449
L6450:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    mov       rax,	[rax+16]
    neg       rax
L6449:
    mov       rsi,	rax
    jmp       L6435
L6439:
    movzx     rax,	byte [r13+62]
    cmp       rax,	60
    jz        L6453
    lea       rcx,	[L12895]
    lea       rdx,	[L12896]
    call      pc_api.merror
L6453:
    mov       rax,	[r13+16]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L6455
    lea       rcx,	[L12897]
    xor       edx,	edx
    call      mm_support.gerror
L6455:
    mov       rax,	[r13+16]
    mov       rax,	[rax+16]
    neg       rax
    mov       rsi,	rax
    jmp       L6435
L6440:
    lea       rcx,	[L12898]
    lea       rdx,	[L12899]
    call      pc_api.merror
    jmp       L6435
L6441:
;mm_assemaux.genasmopnd.error:
L6448:
    call      msys.m$print_startcon
    movzx     rax,	byte [r13]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12900]
    xor       edx,	edx
    call      mm_support.gerror
L6435:
L6434:
    sub       rsp,	8
    mov       rax,	rbx
    push      rax
    mov       rax,	r12
    push      rax
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+43]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    push      r10
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+42]
    mov       r10,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     r10,	byte [r10+41]
    mov       r11,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     r11,	byte [r11+40]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	rsi
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L6425
L6429:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rbx,	rax
    movzx     rax,	byte [rbx+72]
    cmp       rax,	6
    jnz       L6457
    mov       rcx,	rbx
    call      mm_assemaux.fixasmlabel
    mov       r12,	rax
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L6456
L6457:
    mov       rcx,	rbx
    call      mc_libmcl.mgenmemaddr
    mov       rdi,	rax
L6456:
    jmp       L6425
L6430:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+40]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rdi,	rax
    jmp       L6425
L6431:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       r14,	[rax+16]
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       rax,	[rax+24]
    mov       [rbp + mm_assemaux.genasmopnd.y],	rax
    movzx     rax,	byte [r14]
    cmp       rax,	4
    jnz       L6459
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L6459
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rbx,	rax
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+62]
    cmp       rax,	43
    jz        L6462
    cmp       rax,	57
    jnz       L6461
L6462:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    mov       rax,	[rax+16]
    jmp       L6460
L6461:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    mov       rax,	[rax+16]
    neg       rax
L6460:
    mov       rsi,	rax
    movzx     rax,	byte [rbx+72]
    cmp       rax,	6
    jnz       L6464
    mov       rcx,	rbx
    call      mm_assemaux.fixasmlabel
    mov       r12,	rax
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L6463
L6464:
    mov       rcx,	rbx
    call      mc_libmcl.mgenmemaddr
    mov       rdi,	rax
L6463:
    mov       [rdi+12],	esi
    jmp       L6458
L6459:
    lea       rcx,	[L12901]
    xor       edx,	edx
    call      mm_support.gerror
L6458:
    jmp       L6425
L6432:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12902]
    xor       edx,	edx
    call      mm_support.gerror
L6425:
    mov       rax,	rdi
L6422:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_assemaux.fixasmlabel
mm_assemaux.fixasmlabel:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsxd    rax,	dword [rdi+100]
    test      rax,	rax
    jnz       L6467
    lea       rcx,	[L12903]
    xor       edx,	edx
    call      mm_support.gerror
L6467:
    movsxd    rax,	dword [rdi+100]
L6465:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_assemaux.checkasmlabel
mm_assemaux.checkasmlabel:
;?>>
   %define R.p rcx
   %define R.q rdi
   %define R.d rbx
    push      rdi
    push      rbx
;?]]
;---------------
    mov       rdi,	[rcx+16]
    test      rdi,	rdi
    jz        L6470
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jnz       L6470
    mov       rbx,	[rdi+16]
    movzx     rax,	byte [rbx+78]
    cmp       rax,	14
    jnz       L6472
    movsxd    rax,	dword [rbx+80]
    jmp       L6468
L6472:
L6470:
    xor       eax,	eax
L6468:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printst
mm_diags.printst:
;?>>
   %define R.f rbx
   %define R.p rsi
   %define R.level r12
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_diags.printstrec
    mov       rdi,	[rsi+16]
    jmp       L6475
L6474:
    lea       rax,	[r12+1]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_diags.printst
    mov       rdi,	[rdi+32]
L6475:
    test      rdi,	rdi
    jnz       L6474
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printstrec
mm_diags.printstrec:
;?>>
   %define R.f r13
    %define mm_diags.printstrec.p 72
    %define mm_diags.printstrec.level 80
    %define mm_diags.printstrec.dd -176
    %define mm_diags.printstrec.v -192
   %define R.d rdi
   %define R.col rbx
   %define R.offset rsi
    %define mm_diags.printstrec.str -448
   %define R.av_1 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	480
    mov       r13,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    lea       rax,	[rbp + mm_diags.printstrec.v]
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mlib.gs_init
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    mov       rcx,	[rbp + mm_diags.printstrec.p]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_diags.printstrec.str]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12904]
    call      mlib.gs_str
    xor       rsi,	rsi
    mov       rax,	[rbp + mm_diags.printstrec.level]
    mov       r12,	rax
    cmp       r12,	0
    jle       L6480
L6478:
    mov       rcx,	rdi
    lea       rdx,	[L12905]
    call      mlib.gs_str
    mov       rax,	4
    add       rsi,	rax
    dec       r12
    jnz       L6478
L6480:
    mov       rcx,	rdi
    lea       rdx,	[L12906]
    call      mlib.gs_str
    mov       rax,	28
    sub       rax,	rsi
    mov       r10,	[rbp + mm_diags.printstrec.p]
    mov       r10,	[r10]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	45
    call      mlib.gs_leftstr
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	12
    mov       r9,	46
    call      mlib.gs_leftstr
    mov       rcx,	rdi
    call      mlib.gs_getcol
    mov       rbx,	rax
    mov       rax,	[rbp + mm_diags.printstrec.p]
    lea       r10,	[rbp + mm_diags.printstrec.dd]
    push      r10
    mov       r14,	22
L12907:
    mov       r11,	[rax]
    mov       [r10],	r11
    add       r10,	8
    add       rax,	8
    dec       r14
    jnz       L12907
    pop       r10
    mov       rcx,	rdi
    lea       rdx,	[L12908]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	word [rax+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L6482
    mov       rcx,	rdi
    lea       rdx,	[L12909]
    call      mlib.gs_str
    jmp       L6481
L6482:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+170]
    lea       r10,	[mm_tables.scopenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12910]
    call      mlib.gs_str
L6481:
    movzx     rax,	word [rbp + mm_diags.printstrec.dd+92]
    and       eax,	1
    test      rax,	rax
    jz        L6484
    mov       rcx,	rdi
    lea       rdx,	[L12911]
    call      mlib.gs_str
L6484:
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+78]
    cmp       rax,	12
    jnz       L6486
    mov       al,	[rbp + mm_diags.printstrec.dd+160]
    test      al,	al
    jz        L6486
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+160]
    lea       r10,	[mm_tables.parammodenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mlib.gs_str
L6486:
    mov       al,	[rbp + mm_diags.printstrec.dd+149]
    test      al,	al
    jz        L6488
    mov       rcx,	rdi
    lea       rdx,	[L12912]
    call      mlib.gs_str
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+149]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12913]
    call      mlib.gs_str
    movsx     rax,	word [rbp + mm_diags.printstrec.dd+166]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12914]
    call      mlib.gs_str
L6488:
    mov       al,	[rbp + mm_diags.printstrec.dd+161]
    test      al,	al
    jz        L6490
    mov       rcx,	rdi
    lea       rdx,	[L12915]
    call      mlib.gs_str
L6490:
    mov       al,	[rbp + mm_diags.printstrec.dd+123]
    test      al,	al
    jz        L6492
    mov       rcx,	rdi
    lea       rdx,	[L12916]
    call      mlib.gs_str
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+123]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12917]
    call      mlib.gs_str
L6492:
    mov       al,	[rbp + mm_diags.printstrec.dd+94]
    test      al,	al
    jz        L6494
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+78]
    cmp       rax,	2
    jz        L6496
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12918]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6495
L6496:
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12919]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+95]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6495:
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_diags.printstrec.str]
    call      mlib.gs_str
L6494:
    mov       ax,	[rbp + mm_diags.printstrec.dd+168]
    test      ax,	ax
    jz        L6498
    mov       rcx,	rdi
    lea       rdx,	[L12920]
    call      mlib.gs_str
L6498:
    mov       al,	[rbp + mm_diags.printstrec.dd+124]
    test      al,	al
    jz        L6500
    mov       rcx,	rdi
    lea       rdx,	[L12921]
    call      mlib.gs_str
L6500:
    mov       rcx,	rdi
    lea       rdx,	[L12922]
    call      mlib.gs_str
    lea       rax,	[rbx+10]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	61
    call      mlib.gs_padto
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L6502
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12923]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_diags.printstrec.str]
    mov       r8,	18
    mov       r9,	45
    call      mlib.gs_leftstr
    jmp       L6501
L6502:
    mov       rcx,	rdi
    lea       rdx,	[L12924]
    mov       r8,	18
    mov       r9,	45
    call      mlib.gs_leftstr
L6501:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+72]
    test      rax,	rax
    jnz       L6505
L6504:
    mov       rcx,	rdi
    lea       rdx,	[L12925]
    call      mlib.gs_str
    jmp       L6503
L6505:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+72]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12926]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+72]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12927]
    call      mlib.gs_str
L6503:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jz        L6507
    cmp       rax,	12
    jz        L6507
    cmp       rax,	6
    jz        L6508
    cmp       rax,	7
    jz        L6509
    cmp       rax,	10
    jz        L6510
    cmp       rax,	11
    jz        L6511
    cmp       rax,	9
    jz        L6512
    cmp       rax,	5
    jz        L6513
    jmp       L6514
L6507:
    mov       rcx,	rdi
    lea       rdx,	[L12928]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+84]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jnz       L6516
    mov       rcx,	rdi
    lea       rdx,	[L12929]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+150]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12930]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+148]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
L6516:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    lea       rax,	[rax+136]
    mov       r10,	[rbp + mm_diags.printstrec.p]
    movzx     r10,	byte [r10+143]
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    lea       rdx,	[L12931]
    mov       r8,	r10
    mov       r9,	rax
    call      sprintf
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+143]
    mov       rcx,	rax
    lea       rdx,	[L12932]
    call      msys.m$print_i64
    mov       rax,	[rbp + mm_diags.printstrec.p]
    lea       rax,	[rax+136]
    mov       rcx,	rax
    lea       rdx,	[L12933]
    call      msys.m$print_str
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[L12934]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_diags.printstrec.str]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12935]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+143]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    test      rax,	rax
    jz        L6518
    mov       rcx,	rdi
    lea       rdx,	[L12936]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L6518:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+78]
    cmp       rax,	12
    jnz       L6520
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       al,	[rax+162]
    test      al,	al
    jz        L6520
    mov       rcx,	rdi
    lea       rdx,	[L12937]
    call      mlib.gs_str
L6520:
    jmp       L6506
L6508:
    mov       rcx,	rdi
    lea       rdx,	[L12938]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+80]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12939]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+122]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    jmp       L6506
L6509:
    mov       rcx,	rdi
    lea       rdx,	[L12940]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+80]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+104]
    test      rax,	rax
    jz        L6522
    mov       rcx,	rdi
    lea       rdx,	[L12941]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+104]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_str
L6522:
    jmp       L6506
L6510:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    test      rax,	rax
    jz        L6524
    mov       rcx,	rdi
    lea       rdx,	[L12942]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L6524:
    jmp       L6506
L6511:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    test      rax,	rax
    jz        L6526
    mov       rcx,	rdi
    lea       rdx,	[L12943]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L6526:
    jmp       L6506
L6512:
    mov       rcx,	rdi
    lea       rdx,	[L12944]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
    jmp       L6506
L6513:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       eax,	[rax+144]
    test      eax,	eax
    jz        L6528
    mov       rcx,	rdi
    lea       rdx,	[L12945]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12946]
    call      mlib.gs_str
L6528:
L6514:
L6506:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	word [rax+92]
    shr       eax,	7
    and       eax,	1
    test      rax,	rax
    jz        L6530
    mov       rcx,	rdi
    lea       rdx,	[L12947]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+128]
    mov       rax,	[rax]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12948]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+151]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
L6530:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	word [rax+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L6532
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+96]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L6532:
    mov       rcx,	rdi
    lea       rdx,	[L12949]
    call      mlib.gs_str
    mov       rcx,	rdi
    mov       rdx,	r13
    call      mlib.gs_println
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+78]
    cmp       rax,	9
    jz        L6534
    cmp       rax,	11
    jz        L6534
    cmp       rax,	10
    jz        L6534
    cmp       rax,	15
    jnz       L6535
L6534:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    test      rax,	rax
    jz        L6537
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    xor       edx,	edx
    lea       r8,	[L12950]
    mov       r9,	r13
    call      mm_diags.printunit
L6537:
L6535:
L6533:
;---------------
    add       rsp,	480
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printstflat
mm_diags.printstflat:
;?>>
   %define R.f r12
   %define R.p rdi
   %define R.av_1 rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[L12951]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       rsi,	rsi
    mov       rax,	65534
    mov       rbx,	rax
    cmp       rbx,	0
    jl        L6541
L6539:
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8]
    test      rdi,	rdi
    jnz       L6543
    jmp       L6540
L6543:
    movzx     rax,	byte [rdi+77]
    cmp       rax,	67
    jnz       L6546
L6545:
    mov       rcx,	r12
    call      msys.m$print_startfile
    mov       rcx,	rsi
    lea       rdx,	[L12952]
    call      msys.m$print_i64
    mov       rcx,	rdi
    call      msys.m$print_ptr_nf
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+77]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12953]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	byte [rdi+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[rdi+40]
    jmp       L6548
L6547:
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[L12954]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_ptr_nf
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+77]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12955]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	byte [rdi+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rdi+8]
    test      rax,	rax
    jz        L6551
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[L12956]
    call      msys.m$print_setfmt
    mov       rax,	[rdi+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+8]
    movzx     rax,	byte [rax+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6551:
    mov       rcx,	r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[rdi+40]
L6548:
    test      rdi,	rdi
    jnz       L6547
L6546:
L6544:
L6540:
    inc       rsi
    cmp       rsi,	rbx
    jle       L6539
L6541:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printcode
mm_diags.printcode:
;?>>
   %define R.f rsi
    %define mm_diags.printcode.caption 48
   %define R.p rdi
   %define R.pp rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	[mm_decls.proclist]
    jmp       L6554
L6553:
    mov       rdi,	[rbx]
    mov       rcx,	rsi
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12957]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+170]
    sub       rax,	1
    cmp       rax,	3
    jae       L6558
    lea       r10,	[L6557]
    jmp       [r10 + rax*8]
    segment .data
L6557:
    dq  L6559
    dq  L6560
    dq  L6561
    segment .text
L6559:
    lea       rax,	[L12958]
    jmp       L6556
L6560:
    lea       rax,	[L12959]
    jmp       L6556
L6561:
    lea       rax,	[L12960]
    jmp       L6556
L6558:
    lea       rax,	[L12961]
L6556:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rdi+8]
    movzx     rax,	byte [rax+78]
    cmp       rax,	5
    jnz       L6563
    mov       rcx,	rsi
    call      msys.m$print_startfile
    lea       rcx,	[L12962]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6563:
    mov       rcx,	rsi
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rdi+64]
    mov       rcx,	rax
    xor       edx,	edx
    lea       r8,	[L12963]
    mov       r9,	rsi
    call      mm_diags.printunit
    mov       rcx,	rsi
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rbx,	[rbx+8]
L6554:
    test      rbx,	rbx
    jnz       L6553
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printunit
mm_diags.printunit:
;?>>
   %define R.p r13
   %define R.level r14
    %define mm_diags.printunit.prefix 88
    %define mm_diags.printunit.dev 96
   %define R.d rdi
   %define R.t rbx
   %define R.idname rsi
   %define R.a r12
    %define mm_diags.printunit.av_1 -8
    %define mm_diags.printunit.av_2 -16
    %define mm_diags.printunit.i -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+88],	r8
    mov       [rbp+96],	r9
;---------------
    test      r13,	r13
    jnz       L6566
    jmp       L6564
L6566:
    mov       eax,	[r13+4]
    test      eax,	eax
    jz        L6568
    mov       eax,	[r13+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       [mm_diags.currlineno],	rax
    mov       eax,	[r13+4]
    shr       rax,	24
    and       rax,	255
    mov       [mm_diags.currfileno],	rax
L6568:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r13
    call      msys.m$print_ptr_nf
    lea       rcx,	[L12964]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_diags.printunit.prefix]
    mov       r8,	r13
    call      mm_diags.getprefix
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movzx     rax,	byte [r13]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rsi,	r10
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12965]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movzx     rax,	byte [r13]
    cmp       rax,	4
    jz        L6570
    cmp       rax,	100
    jz        L6571
    cmp       rax,	1
    jz        L6572
    cmp       rax,	7
    jz        L6573
    cmp       rax,	62
    jz        L6574
    cmp       rax,	68
    jz        L6575
    cmp       rax,	58
    jz        L6576
    cmp       rax,	61
    jz        L6576
    cmp       rax,	20
    jz        L6577
    cmp       rax,	49
    jz        L6578
    cmp       rax,	46
    jz        L6579
    cmp       rax,	53
    jz        L6579
    cmp       rax,	103
    jz        L6580
    cmp       rax,	101
    jz        L6580
    cmp       rax,	102
    jz        L6580
    cmp       rax,	90
    jz        L6581
    cmp       rax,	8
    jz        L6582
    cmp       rax,	10
    jz        L6583
    cmp       rax,	11
    jz        L6584
    cmp       rax,	12
    jz        L6585
    cmp       rax,	22
    jz        L6586
    cmp       rax,	34
    jz        L6587
    jmp       L6588
L6570:
    mov       rdi,	[r13+16]
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rdi+64]
    test      rax,	rax
    jz        L6590
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12966]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rdi+64]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12967]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6590:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12968]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rdi
    call      mm_lib.getdottedname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       al,	[r13+40]
    test      al,	al
    jz        L6592
    lea       rax,	[L12969]
    jmp       L6591
L6592:
    lea       rax,	[L12970]
L6591:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[r13+32]
    test      rax,	rax
    jz        L6594
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12971]
    call      msys.m$print_str_nf
    mov       rcx,	[r13+32]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6594:
    mov       al,	[r13+40]
    test      al,	al
    jz        L6596
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12972]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6596:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12973]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r13+57]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       al,	[r13+41]
    test      al,	al
    jz        L6598
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12974]
    call      msys.m$print_str_nf
    mov       al,	[r13+41]
    mov       cl,	al
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
L6598:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12975]
    call      msys.m$print_str_nf
    movsxd    rax,	dword [r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6569
L6571:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rax,	[r13+16]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L6569
L6572:
    movsxd    rax,	dword [r13+49]
    mov       rbx,	rax
    mov       r12,	[r13+16]
    cmp       rbx,	20
    jnz       L6600
    mov       eax,	[r13+40]
    cmp       rax,	256
    jle       L6602
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12976]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12977]
    call      msys.m$print_str_nf
    lea       rcx,	[L12978]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6601
L6602:
    mov       eax,	[r13+40]
    test      eax,	eax
    jz        L6603
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12979]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	[r13+16]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12980]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6601
L6603:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12981]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6601:
    jmp       L6599
L6600:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	3
    jz        L6605
    cmp       rax,	16
    jz        L6605
    cmp       rax,	15
    jz        L6605
    cmp       rax,	14
    jz        L6605
    cmp       rax,	4
    jz        L6606
    cmp       rax,	19
    jz        L6606
    cmp       rax,	18
    jz        L6606
    cmp       rax,	17
    jz        L6606
    cmp       rax,	5
    jz        L6607
    cmp       rax,	12
    jz        L6607
    cmp       rax,	2
    jz        L6608
    cmp       rax,	1
    jz        L6608
    cmp       rax,	7
    jz        L6609
    cmp       rax,	6
    jz        L6610
    cmp       rax,	10
    jz        L6611
    jmp       L6612
L6605:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6604
L6606:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r12
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_end
    jmp       L6604
L6607:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r12
    call      mlib.chr
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6604
L6608:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    movq      XMM4,	[r13+16]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L6604
L6609:
    mov       rax,	[r13+16]
    test      rax,	rax
    jz        L6614
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12982]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	[r13+16]
    call      msys.m$print_i64_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6613
L6614:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12983]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6613:
    jmp       L6604
L6610:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rax,	[r13+16]
    test      rax,	rax
    jz        L6616
    lea       rax,	[L12984]
    jmp       L6615
L6616:
    lea       rax,	[L12985]
L6615:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6604
L6611:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12986]
    call      msys.m$print_str_nf
    lea       rcx,	[L12987]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r13+45]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_c8
    lea       rcx,	[L12988]
    call      msys.m$print_str_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6604
L6612:
    call      msys.m$print_startcon
    lea       rcx,	[L12989]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12990]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6604:
L6599:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12991]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rbx
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       al,	[r13+44]
    test      al,	al
    jz        L6618
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12992]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+45]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
L6618:
    mov       eax,	[r13+40]
    test      eax,	eax
    jz        L6620
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12993]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    rax,	dword [r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6620:
    jmp       L6569
L6573:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	[r13+16]
    call      msys.m$print_str_nf
    lea       rcx,	[L12994]
    call      msys.m$print_str_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6569
L6574:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    movsxd    rax,	dword [r13+49]
    mov       rcx,	rax
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    mov       rax,	[r13+16]
    mov       rcx,	rax
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6569
L6575:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    movsx     rax,	word [r13+40]
    lea       r10,	[mm_tables.bitfieldnames]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+3]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6569
L6576:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12995]
    call      msys.m$print_str_nf
    movsxd    rax,	dword [r13+53]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6569
L6577:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12996]
    call      msys.m$print_str_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L12997]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6569
L6578:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12998]
    call      msys.m$print_str_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6569
L6579:
    jmp       L6569
L6580:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12999]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    rax,	dword [r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6569
L6581:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    movsx     rax,	word [r13+40]
    lea       r10,	[mm_tables.sysfnnames]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+3]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6569
L6582:
    jmp       L6569
L6583:
    jmp       L6569
L6584:
    jmp       L6569
L6585:
    jmp       L6569
L6586:
    jmp       L6569
L6587:
    mov       rax,	1
    mov       [rbp + mm_diags.printunit.i],	rax
    mov       rax,	4
    mov       [rbp + mm_diags.printunit.av_1],	rax
    mov       rax,	[rbp + mm_diags.printunit.av_1]
    cmp       rax,	1
    jl        L6623
L6621:
    lea       rax,	[r13+40]
    mov       r10,	[rbp + mm_diags.printunit.i]
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jz        L6623
L6625:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rax,	[r13+40]
    mov       r10,	[rbp + mm_diags.printunit.i]
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13000]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.printunit.i]
    inc       rax
    mov       [rbp + mm_diags.printunit.i],	rax
    cmp       rax,	[rbp + mm_diags.printunit.av_1]
    jle       L6621
L6623:
L6588:
L6569:
    mov       al,	[r13+60]
    test      al,	al
    jz        L6627
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13001]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6626
L6627:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13002]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6626:
    movzx     rax,	byte [r13]
    cmp       rax,	35
    jz        L6629
    cmp       rax,	38
    jz        L6629
    cmp       rax,	36
    jz        L6629
    cmp       rax,	39
    jz        L6629
    cmp       rax,	40
    jz        L6629
    cmp       rax,	15
    jz        L6629
    cmp       rax,	16
    jz        L6629
    cmp       rax,	17
    jz        L6629
    cmp       rax,	18
    jz        L6629
    cmp       rax,	37
    jz        L6630
    cmp       rax,	58
    jz        L6631
    cmp       rax,	33
    jz        L6632
    jmp       L6633
L6629:
    mov       al,	[r13+62]
    test      al,	al
    jz        L6635
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13003]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6634
L6635:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13004]
    call      msys.m$print_setfmt
    call      msys.m$print_end
L6634:
    jmp       L6628
L6630:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13005]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+62]
    lea       r10,	[mm_tables.propnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6628
L6631:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13006]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+62]
    lea       r10,	[mm_tables.convnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6628
L6632:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13007]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+64]
    lea       r10,	[pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6633:
L6628:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.printunit.i],	rax
    movzx     rax,	byte [r13]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       [rbp + mm_diags.printunit.av_2],	r10
    mov       rax,	[rbp + mm_diags.printunit.av_2]
    cmp       rax,	1
    jl        L6638
L6636:
    mov       rcx,	[rbp + mm_diags.printunit.i]
    xor       edx,	edx
    call      msys.strint
    lea       r10,	[r14+1]
    lea       r11,	[r13+16]
    mov       r15,	[rbp + mm_diags.printunit.i]
    mov       r11,	[r11 + r15*8-8]
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      mm_diags.printunitlist
    mov       rax,	[rbp + mm_diags.printunit.i]
    inc       rax
    mov       [rbp + mm_diags.printunit.i],	rax
    cmp       rax,	[rbp + mm_diags.printunit.av_2]
    jle       L6636
L6638:
L6564:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printunitlist
mm_diags.printunitlist:
;?>>
   %define R.dev rdi
   %define R.p rbx
   %define R.level rsi
   %define R.prefix r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    test      rbx,	rbx
    jnz       L6641
    jmp       L6639
L6641:
    jmp       L6643
L6642:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    mov       r9,	rdi
    call      mm_diags.printunit
    mov       rbx,	[rbx+8]
L6643:
    test      rbx,	rbx
    jnz       L6642
L6639:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.getprefix
mm_diags.getprefix:
;?>>
   %define R.level rsi
   %define R.prefix r12
   %define R.p r13
    %define mm_diags.getprefix.indentstr -1024
    %define mm_diags.getprefix.modestr -17408
   %define R.isexpr rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	17448
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    xor       eax,	eax
    mov       [rbp + mm_diags.getprefix.indentstr],	al
    cmp       rsi,	10
    jle       L6647
    mov       rsi,	10
L6647:
    mov       rbx,	rsi
    cmp       rbx,	0
    jle       L6650
L6648:
    lea       rcx,	[rbp + mm_diags.getprefix.indentstr]
    lea       rdx,	[L13008]
    call      strcat
    dec       rbx
    jnz       L6648
L6650:
    lea       rax,	[L13009]
    mov       rdi,	rax
    movzx     rax,	byte [r13]
    lea       r10,	[mm_tables.jisexpr]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L6652
    lea       rax,	[L13010]
    mov       rdi,	rax
L6652:
    movzx     rax,	byte [r13]
    cmp       rax,	92
    jz        L6654
    cmp       rax,	107
    jz        L6654
    cmp       rax,	105
    jz        L6654
    cmp       rax,	112
    jnz       L6655
L6654:
    movsxd    rax,	dword [r13+49]
    test      rax,	rax
    jnz       L6657
    lea       rax,	[L13011]
    mov       rdi,	rax
L6657:
L6655:
L6653:
    lea       rcx,	[rbp + mm_diags.getprefix.modestr]
    call      msys.m$print_startstr
    lea       rcx,	[L13012]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    mov       al,	[r13+61]
    test      al,	al
    jz        L6659
    lea       rax,	[L13013]
    jmp       L6658
L6659:
    lea       rax,	[L13014]
L6658:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    movsxd    rax,	dword [r13+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    xor       eax,	eax
    mov       [rbp + mm_diags.getprefix.modestr+255],	al
    lea       rcx,	[rbp + mm_diags.getprefix.modestr]
    lea       rdx,	[L13015]
    call      strcat
    mov       al,	32
    mov       [rbp + mm_diags.getprefix.modestr+16],	al
    xor       eax,	eax
    mov       [rbp + mm_diags.getprefix.modestr+17],	al
    call      mm_diags.getlineinfok
    lea       rcx,	[mm_diags.getprefix.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[mm_diags.getprefix.str]
    lea       rdx,	[rbp + mm_diags.getprefix.modestr]
    call      strcat
    lea       rcx,	[mm_diags.getprefix.str]
    lea       rdx,	[rbp + mm_diags.getprefix.indentstr]
    call      strcat
    lea       rcx,	[mm_diags.getprefix.str]
    mov       rdx,	r12
    call      strcat
    mov       al,	[r12]
    test      al,	al
    jz        L6661
    lea       rcx,	[mm_diags.getprefix.str]
    lea       rdx,	[L13016]
    call      strcat
L6661:
    lea       rax,	[mm_diags.getprefix.str]
L6645:
;---------------
    add       rsp,	17448
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.getlineinfok
mm_diags.getlineinfok:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[mm_diags.getlineinfok.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13017]
    call      msys.m$print_setfmt
    mov       rcx,	[mm_diags.currfileno]
    lea       rdx,	[L13018]
    call      msys.m$print_i64
    mov       rcx,	[mm_diags.currlineno]
    lea       rdx,	[L13019]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       rax,	[mm_diags.getlineinfok.str]
L6662:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_diags.printmodelist
mm_diags.printmodelist:
;?>>
   %define R.f r13
   %define R.mbase rdi
   %define R.av_1 rbx
   %define R.m rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13020]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.ntypes]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       rsi,	rsi
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	0
    jl        L6666
L6664:
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	rsi
    lea       rdx,	[L13021]
    call      msys.m$print_i64
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rdi,	rax
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13022]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13023]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttname]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13024]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_ptr_nf
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L6668
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    jmp       L6667
L6668:
    lea       rax,	[L13025]
L6667:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13026]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13027]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rsi
    mov       eax,	[rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L13028]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttsizeset]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13029]
    call      msys.m$print_setfmt
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rsi
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    cmp       rdi,	28
    jnz       L6670
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13030]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       r12,	1
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    cmp       rbx,	1
    jl        L6673
L6671:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rax,	[mm_decls.ttmult]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4-4]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13031]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    inc       r12
    cmp       r12,	rbx
    jle       L6671
L6673:
    mov       rcx,	r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6670:
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13032]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttsigned]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13033]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13034]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13035]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13036]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13037]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisblock]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rsi
    cmp       rsi,	[mm_decls.ntypes]
    jle       L6664
L6666:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showprojectinfo
mm_diags.showprojectinfo:
;?>>
    %define mm_diags.showprojectinfo.dev 72
   %define R.pm rdi
   %define R.ps rbx
   %define R.s rsi
   %define R.isfirst r12b
   %define R.ismain r13b
   %define R.av_1 r14
   %define R.pf r15
    %define mm_diags.showprojectinfo.i -8
    %define mm_diags.showprojectinfo.j -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13038]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13039]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13040]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.nmodules]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L6677
L6675:
    lea       rax,	[mm_decls.modules]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    mov       rdi,	[rax + r10*8]
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    cmp       rax,	1
    jle       L6679
    movsx     rax,	word [rdi+18]
    lea       r10,	[mm_decls.modules]
    mov       r11,	[rbp + mm_diags.showprojectinfo.i]
    mov       r10,	[r10 + r11*8-8]
    movsx     r10,	word [r10+18]
    cmp       rax,	r10
    jz        L6679
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6679:
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    movzx     rax,	byte [rax + r10]
    lea       r10,	[mm_decls.subprogs]
    mov       r10,	[r10 + rax*8]
    mov       rbx,	r10
    movsx     rax,	word [rbx+8]
    cmp       rax,	[rbp + mm_diags.showprojectinfo.i]
    setz      al
    movzx     eax,	al
    mov       r12b,	al
    movsx     rax,	word [rbx+10]
    cmp       rax,	[rbp + mm_diags.showprojectinfo.i]
    setz      al
    movzx     eax,	al
    mov       r13b,	al
    test      r12b,	r12b
    jz        L6681
    test      r13b,	r13b
    jz        L6681
    lea       rax,	[L13041]
    mov       rsi,	rax
    jmp       L6680
L6681:
    test      r12b,	r12b
    jz        L6682
    lea       rax,	[L13042]
    mov       rsi,	rax
    jmp       L6680
L6682:
    test      r13b,	r13b
    jz        L6683
    lea       rax,	[L13043]
    mov       rsi,	rax
    jmp       L6680
L6683:
    lea       rax,	[L13044]
    mov       rsi,	rax
L6680:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_diags.showprojectinfo.i]
    lea       rdx,	[L13045]
    call      msys.m$print_i64
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    mov       rax,	[rdi]
    mov       rcx,	rax
    lea       rdx,	[L13046]
    call      msys.m$print_str
    lea       rcx,	[L13047]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+22]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L13048]
    call      msys.m$print_str_nf
    movsx     rax,	word [rdi+18]
    lea       r10,	[mm_decls.subprogs]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[L13049]
    call      msys.m$print_str_nf
    movsx     rax,	word [rdi+20]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rax,	[rdi+40]
    test      rax,	rax
    jz        L6685
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13050]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+40]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6685:
    mov       rax,	[rdi+56]
    test      rax,	rax
    jz        L6687
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_space
    mov       rax,	[rdi+56]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L13051]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+56]
    movzx     rax,	byte [rax+170]
    lea       r10,	[mm_tables.scopenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[rdi+56]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6687:
    mov       rax,	[rdi+48]
    test      rax,	rax
    jz        L6689
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_space
    mov       rax,	[rdi+48]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L13051]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+48]
    movzx     rax,	byte [rax+170]
    lea       r10,	[mm_tables.scopenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[rdi+48]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6689:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    cmp       rax,	[mm_decls.nmodules]
    jle       L6675
L6677:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13052]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.nsubprogs]
    call      msys.m$print_i64_nf
    lea       rcx,	[L13053]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.mainsubprogno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L6692
L6690:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    mov       rbx,	[rax + r10*8]
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_diags.showprojectinfo.i]
    call      msys.m$print_i64_nf
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    lea       rcx,	[L13054]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+14]
    shr       eax,	1
    and       eax,	1
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       ax,	[rbx+8]
    test      ax,	ax
    jz        L6694
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsx     rax,	word [rbx+8]
    mov       [rbp + mm_diags.showprojectinfo.j],	rax
    movsx     rax,	word [rbx+12]
    mov       r14,	rax
    mov       rax,	[rbp + mm_diags.showprojectinfo.j]
    cmp       rax,	r14
    jg        L6697
L6695:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_space
    lea       rax,	[mm_decls.modules]
    mov       r10,	[rbp + mm_diags.showprojectinfo.j]
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L13055]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.modules]
    mov       r10,	[rbp + mm_diags.showprojectinfo.j]
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax+32]
    call      msys.m$print_ptr_nf
    lea       rcx,	[L13056]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.showprojectinfo.j]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.j],	rax
    cmp       rax,	r14
    jle       L6695
L6697:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6694:
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    cmp       rax,	[mm_decls.nsubprogs]
    jle       L6690
L6692:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13057]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L6700
L6698:
    lea       rax,	[mm_decls.sources]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    mov       r15,	[rax + r10*8]
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13058]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mm_diags.showprojectinfo.i]
    lea       rdx,	[L13059]
    call      msys.m$print_i64
    mov       rax,	[r15]
    mov       rcx,	rax
    lea       rdx,	[L13060]
    call      msys.m$print_str
    mov       rax,	[r15+8]
    mov       rcx,	rax
    lea       rdx,	[L13061]
    call      msys.m$print_str
    mov       rax,	[r15+16]
    mov       rcx,	rax
    lea       rdx,	[L13062]
    call      msys.m$print_str
    mov       rax,	[r15+24]
    mov       rcx,	rax
    lea       rdx,	[L13063]
    call      msys.m$print_str
    mov       rax,	[r15+48]
    mov       rcx,	rax
    lea       rdx,	[L13064]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    cmp       rax,	[mm_decls.nsourcefiles]
    jle       L6698
L6700:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13065]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.nlibfiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	1
    jl        L6703
L6701:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.libfiles]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    lea       rdx,	[L13066]
    call      msys.m$print_str
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    cmp       rax,	[mm_decls.nlibfiles]
    jle       L6701
L6703:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showlogfile
mm_diags.showlogfile:
;?>>
    %define mm_diags.showlogfile.str -256
   %define R.logdev rdi
   %define R.size rbx
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
;---------------
    mov       rax,	[mm_decls.debugmode]
    test      rax,	rax
    jz        L6704
L6706:
    lea       rcx,	[L13067]
    lea       rdx,	[L13068]
    call      fopen
    mov       rdi,	rax
    mov       al,	[mm_decls.fshowmodules]
    test      al,	al
    jz        L6708
    mov       rcx,	rdi
    call      mm_diags.showprojectinfo
L6708:
    mov       al,	[mm_decls.fshowasm]
    test      al,	al
    jz        L6710
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	7
    jl        L6710
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13069]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L13070]
    call      mlib.changeext
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6710:
    mov       al,	[mm_decls.fshowpcl]
    test      al,	al
    jz        L6712
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	6
    jl        L6712
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L13071]
    call      mlib.changeext
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6712:
    mov       al,	[mm_decls.fshowpst]
    test      al,	al
    jz        L6714
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	6
    jl        L6714
    lea       rcx,	[L13072]
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6714:
    mov       al,	[mm_decls.fshowast3]
    test      al,	al
    jz        L6716
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	5
    jl        L6716
    lea       rcx,	[L13073]
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6716:
    mov       al,	[mm_decls.fshowast2]
    test      al,	al
    jz        L6718
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	4
    jl        L6718
    lea       rcx,	[L13074]
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6718:
    mov       al,	[mm_decls.fshowast1]
    test      al,	al
    jz        L6720
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	2
    jl        L6720
    lea       rcx,	[L13075]
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6720:
    mov       al,	[mm_decls.fshowst]
    test      al,	al
    jz        L6722
    lea       rcx,	[L13076]
    mov       rdx,	rdi
    call      mm_diags.showsttree
L6722:
    mov       al,	[mm_decls.fshowstflat]
    test      al,	al
    jz        L6724
    lea       rcx,	[L13077]
    mov       rdx,	rdi
    call      mm_diags.showstflat
L6724:
    mov       al,	[mm_decls.fshowtypes]
    test      al,	al
    jz        L6726
    mov       rcx,	rdi
    call      mm_diags.printmodelist
L6726:
    mov       rcx,	rdi
    call      mlib.getfilesize
    mov       rbx,	rax
    mov       rcx,	rdi
    call      fclose
    test      rbx,	rbx
    jz        L6728
    call      msys.m$print_startcon
    lea       rcx,	[L13078]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_getch
    cmp       rax,	27
    jnz       L6730
    xor       ecx,	ecx
    call      exit
L6730:
    lea       rcx,	[rbp + mm_diags.showlogfile.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13079]
    call      msys.m$print_str_nf
    lea       rcx,	[L13080]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[L13081]
    call      mlib.checkfile
    test      rax,	rax
    jz        L6732
    lea       rcx,	[rbp + mm_diags.showlogfile.str]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mwindows.os_execwait
    jmp       L6731
L6732:
    call      msys.m$print_startcon
    lea       rcx,	[L13082]
    call      msys.m$print_str_nf
    lea       rcx,	[L13083]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6731:
L6728:
L6704:
;---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showstflat
mm_diags.showstflat:
;?>>
   %define R.caption rdi
   %define R.f rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      msys.m$print_startfile
    lea       rcx,	[L13084]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    call      mm_diags.printstflat
    mov       rcx,	rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showsttree
mm_diags.showsttree:
;?>>
   %define R.caption r12
   %define R.f r13
   %define R.pp rdi
   %define R.d rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13084]
    call      msys.m$print_str_nf
    mov       rcx,	r12
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    mov       rdx,	[mm_decls.stprogram]
    xor       r8d,	r8d
    call      mm_diags.printst
    mov       rcx,	r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13085]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[mm_decls.proclist]
    jmp       L6736
L6735:
    mov       rbx,	[rdi]
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13086]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_ptr_nf
    mov       rax,	[rbx+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rax,	[rbx]
    mov       rcx,	rax
    lea       rdx,	[L13087]
    call      msys.m$print_str
    movzx     rax,	byte [rbx+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[rdi+8]
L6736:
    test      rdi,	rdi
    jnz       L6735
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13088]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13089]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rsi,	1
    mov       rax,	[mm_decls.ndllproctable]
    cmp       rax,	1
    jl        L6740
L6738:
    lea       rax,	[mm_decls.dllproctable]
    mov       r10,	rsi
    mov       rbx,	[rax + r10*8-8]
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13090]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_ptr_nf
    mov       rax,	[rbx+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rax,	[rbx]
    mov       rcx,	rax
    lea       rdx,	[L13091]
    call      msys.m$print_str
    movzx     rax,	byte [rbx+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rsi
    cmp       rsi,	[mm_decls.ndllproctable]
    jle       L6738
L6740:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13092]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showast
mm_diags.showast:
;?>>
   %define R.filename rbx
   %define R.f rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    lea       rdx,	[L13093]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L6743
    jmp       L6741
L6743:
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13094]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[L13095]
    call      mm_diags.printcode
    mov       rcx,	rdi
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      fclose
L6741:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printsymbol
mm_diags.printsymbol:
;?>>
   %define R.lp rdi
    %define mm_diags.printsymbol.l -16
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
;---------------
    mov       rax,	rdi
    lea       r10,	[rbp + mm_diags.printsymbol.l]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    lea       rcx,	[L13096]
    mov       rdx,	r10
    call      printf
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l]
    sub       rax,	6
    cmp       rax,	62
    jae       L6747
    lea       r10,	[L6746]
    jmp       [r10 + rax*8]
    segment .data
L6746:
    dq  L6759
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6759
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6759
    dq  L6747
    dq  L6759
    dq  L6747
    dq  L6747
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6747
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6747
    dq  L6759
    dq  L6759
    dq  L6759
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6747
    dq  L6751
    dq  L6756
    dq  L6758
    dq  L6757
    dq  L6747
    dq  L6748
    segment .text
L6748:
    mov       rax,	[rbp + mm_diags.printsymbol.l+8]
    movzx     rax,	byte [rax+76]
    mov       r10,	[rbp + mm_diags.printsymbol.l+8]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lex.printstrn
    mov       al,	[rbp + mm_diags.printsymbol.l+1]
    test      al,	al
    jz        L6750
    call      msys.m$print_startcon
    lea       rcx,	[L13097]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l+1]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6750:
    jmp       L6745
L6751:
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l+1]
    cmp       rax,	3
    jz        L6753
    cmp       rax,	4
    jz        L6754
    jmp       L6755
L6753:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mm_diags.printsymbol.l+8]
    call      msys.m$print_i64_nf
    lea       rcx,	[L13098]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6752
L6754:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mm_diags.printsymbol.l+8]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    lea       rcx,	[L13099]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6752
L6755:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mm_diags.printsymbol.l+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6752:
    jmp       L6745
L6756:
    call      msys.m$print_startcon
    movq      XMM4,	[rbp + mm_diags.printsymbol.l+8]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L6745
L6757:
    call      msys.m$print_startcon
    lea       rcx,	[L13100]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printsymbol.l+8]
    call      msys.printstr
    call      msys.m$print_startcon
    lea       rcx,	[L13100]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mm_diags.printsymbol.l+8]
    mov       rcx,	rax
    call      strlen
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6745
L6758:
    call      msys.m$print_startcon
    lea       rcx,	[L13101]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printsymbol.l+8]
    call      msys.printstr
    call      msys.m$print_startcon
    lea       rcx,	[L13101]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6745
L6759:
    call      msys.m$print_startcon
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6745
L6747:
    mov       al,	[rbp + mm_diags.printsymbol.l+1]
    test      al,	al
    jz        L6761
    call      msys.m$print_startcon
    lea       rcx,	[L13102]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l+1]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6761:
L6745:
    call      msys.m$print_startcon
    call      msys.m$print_space
    lea       rcx,	[L13103]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    shr       rax,	24
    and       rax,	255
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_diags.showtime
mm_diags.showtime:
;?>>
   %define R.caption rdi
   %define R.t rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13104]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    lea       rdx,	[L13105]
    call      msys.m$print_str
    mov       rcx,	rbx
    lea       rdx,	[L13106]
    call      msys.m$print_i64
    mov       rax,	rbx
    cvtsi2sd  XMM4,	rax
    mulsd     XMM4,	[L13107]
    mov       rax,	[mm_cli.compiletime]
    cvtsi2sd  XMM5,	rax
    divsd     XMM4,	XMM5
    movq      XMM0,	XMM4
    lea       rdx,	[L13108]
    call      msys.m$print_r64
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showtimings
mm_diags.showtimings:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mwindows.os_clock
    mov       [mm_cli.endclock],	rax
    mov       rax,	[mm_cli.endclock]
    sub       rax,	[mm_cli.startclock]
    mov       [mm_cli.compiletime],	rax
    lea       rcx,	[L13109]
    mov       rdx,	[mm_cli.loadtime]
    call      mm_diags.showtime
    lea       rcx,	[L13110]
    mov       rdx,	[mm_cli.parsetime]
    call      mm_diags.showtime
    lea       rcx,	[L13111]
    mov       rdx,	[mm_cli.resolvetime]
    call      mm_diags.showtime
    lea       rcx,	[L13112]
    mov       rdx,	[mm_cli.typetime]
    call      mm_diags.showtime
    lea       rcx,	[L13113]
    mov       rdx,	[mm_cli.pcltime]
    call      mm_diags.showtime
    lea       rcx,	[L13114]
    mov       rdx,	[pc_decls.mcltime]
    call      mm_diags.showtime
    lea       rcx,	[L13115]
    mov       rdx,	[pc_decls.sstime]
    call      mm_diags.showtime
    lea       rcx,	[L13116]
    mov       rdx,	[pc_decls.exetime]
    call      mm_diags.showtime
    call      msys.m$print_startcon
    lea       rcx,	[L13117]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13118]
    mov       rdx,	[mm_cli.compiletime]
    call      mm_diags.showtime
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_export_dummy.writeexports
mm_export_dummy.writeexports:
;?>>
    %define mm_export_dummy.writeexports.basefile 16
    %define mm_export_dummy.writeexports.modulename 24
;?]]
;---------------
;---
;---------------
    ret       
;End 
;Proc mm_lex.lex
mm_lex.lex:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.nextlx]
    lea       r10,	[mm_decls.lx]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    mov       rax,	[mm_lex.lxstart]
    sub       rax,	[mm_lex.lxsource]
    lea       r10,	[mm_decls.lx]
    lea       r10,	[r10+4]
    mov       r9d,	[r10]
    mov       r11,	-16777216
    and       r9d,	r11d
    or        r9d,	eax
    mov       [r10],	r9d
L6766:
    call      mm_lex.lexreadtoken
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	58
    jz        L6768
    cmp       rax,	68
    jz        L6769
    cmp       rax,	67
    jz        L6770
    cmp       rax,	60
    jz        L6771
    cmp       rax,	44
    jz        L6772
    jmp       L6773
L6768:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L6776
    cmp       rax,	11
    jz        L6776
    cmp       rax,	9
    jz        L6776
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symboloptypes]
    movzx     r10,	byte [r10 + rax-1]
    cmp       r10,	1
    jnz       L6775
    mov       rax,	[mm_decls.assemmode]
    test      rax,	rax
    jnz       L6775
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	37
    jz        L6775
    cmp       rax,	36
    jz        L6775
L6776:
    jmp       L6774
L6775:
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6767
L6774:
    jmp       L6766
L6769:
    call      mm_lex.doinclude
    jmp       L6766
L6770:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	66
    jnz       L6779
L6778:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jz        L6781
    cmp       rax,	63
    jz        L6782
    jmp       L6783
L6781:
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    movsxd    rax,	dword [rax+80]
    cmp       rax,	1
    jz        L6785
    cmp       rax,	2
    jz        L6786
    jmp       L6787
L6785:
    lea       rax,	[mm_decls.lx]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    imul      r10,	1000000
    mov       [rax],	r10
    jmp       L6784
L6786:
    lea       rax,	[mm_decls.lx]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    imul      r10,	1000000000
    mov       [rax],	r10
    jmp       L6784
L6787:
    lea       rcx,	[L13119]
    call      mm_support.lxerror
L6784:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.lx]
    mov       [r10+1],	al
    jmp       L6780
L6782:
    lea       rcx,	[L13120]
    call      mm_support.lxerror
    jmp       L6780
L6783:
    mov       al,	67
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6767
L6780:
    jmp       L6777
L6779:
    mov       al,	67
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6767
L6777:
    jmp       L6766
L6771:
    mov       al,	67
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6767
L6772:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	47
    jnz       L6789
    mov       al,	45
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mm_decls.lx]
    mov       [r10+1],	al
    jmp       L6788
L6789:
    jmp       L6767
L6788:
    jmp       L6766
L6773:
    jmp       L6767
L6767:
    lea       rax,	[mm_decls.nextlx]
    lea       rax,	[rax+4]
    mov       r10d,	[mm_lex.lxfileno]
    mov       r9d,	[rax]
    mov       r11,	-4278190081
    shl       r10d,	24
    and       r9d,	r11d
    or        r9d,	r10d
    mov       [rax],	r9d
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lex.lexreadtoken
mm_lex.lexreadtoken:
;?>>
   %define R.c rdi
   %define R.hsum rbx
   %define R.sptr rsi
   %define R.lxsvalue r12
   %define R.commentseen r13
   %define R.p r14
   %define R.q r15
    %define mm_lex.lexreadtoken.str -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
;---------------
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6791:
    mov       rax,	[mm_lex.lxsptr]
    mov       [mm_lex.lxstart],	rax
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	127
    jae       L6794
    lea       r10,	[L6793]
    jmp       [r10 + rax*8]
    segment .data
L6793:
    dq  L6914
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6911
    dq  L6913
    dq  L6794
    dq  L6794
    dq  L6912
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6794
    dq  L6911
    dq  L6820
    dq  L6909
    dq  L6828
    dq  L6795
    dq  L6887
    dq  L6903
    dq  L6908
    dq  L6862
    dq  L6863
    dq  L6883
    dq  L6875
    dq  L6856
    dq  L6878
    dq  L6848
    dq  L6886
    dq  L6811
    dq  L6811
    dq  L6811
    dq  L6811
    dq  L6811
    dq  L6811
    dq  L6811
    dq  L6811
    dq  L6811
    dq  L6811
    dq  L6858
    dq  L6857
    dq  L6892
    dq  L6888
    dq  L6898
    dq  L6869
    dq  L6868
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6810
    dq  L6864
    dq  L6829
    dq  L6865
    dq  L6867
    dq  L6795
    dq  L6910
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6795
    dq  L6846
    dq  L6866
    dq  L6847
    dq  L6874
    segment .text
L6795:
    mov       rax,	[mm_lex.lxsptr]
    sub       rax,	1
    mov       r12,	rax
;mm_lex.lexreadtoken.doname:
L6796:
    movzx     rax,	byte [r12]
    mov       rbx,	rax
    mov       rsi,	[mm_lex.lxsptr]
L6797:
    mov       rax,	rsi
    inc       rsi
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    lea       r10,	[mm_lex.namemap]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	1
    jz        L6799
    cmp       r10,	2
    jz        L6800
    jmp       L6801
L6799:
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L6797
L6800:
    lea       rax,	[rdi+32]
    lea       r10,	[rsi-1]
    mov       [r10],	al
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    add       rax,	32
    mov       rbx,	rax
    jmp       L6797
L6801:
    lea       rax,	[rsi-1]
    mov       [mm_lex.lxsptr],	rax
    jmp       L6798
L6798:
    cmp       rdi,	34
    jnz       L6803
    lea       rax,	[r12+1]
    cmp       rax,	[mm_lex.lxsptr]
    jnz       L6805
    movzx     rax,	byte [r12]
    mov       rcx,	rax
    call      toupper
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	70
    jz        L6807
    cmp       r10,	82
    jz        L6807
    cmp       r10,	83
    jz        L6808
    cmp       r10,	66
    jz        L6808
    cmp       r10,	65
    jz        L6808
    jmp       L6809
L6807:
    call      mm_lex.readrawstring
    jmp       L6790
L6808:
    mov       rcx,	rdi
    call      mm_lex.readarraystring
    jmp       L6790
L6809:
L6806:
L6805:
L6803:
    mov       rax,	[mm_lex.lxsptr]
    sub       rax,	r12
    mov       rcx,	r12
    mov       rdx,	rax
    mov       r8,	rbx
    call      mm_lex.lookup
    jmp       L6790
L6810:
    mov       rax,	[mm_lex.lxsptr]
    sub       rax,	1
    mov       r12,	rax
    mov       rax,	r12
    mov       r10b,	32
    add       [rax],	r10b
    jmp       L6796
L6811:
    mov       rax,	[mm_lex.lxsptr]
    sub       rax,	1
    mov       [mm_lex.lxstart],	rax
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L6813
    cmp       rax,	13
    jz        L6813
    cmp       rax,	44
    jz        L6813
    cmp       rax,	32
    jz        L6813
    cmp       rax,	120
    jz        L6814
    cmp       rax,	88
    jz        L6814
    jmp       L6815
L6813:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	3
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	[mm_lex.lxstart]
    movzx     rax,	byte [rax]
    sub       rax,	48
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    jmp       L6812
L6814:
    mov       rax,	[mm_lex.lxstart]
    movzx     rax,	byte [rax]
    cmp       rax,	48
    jz        L6817
    cmp       rax,	50
    jz        L6818
    jmp       L6819
L6817:
    inc       qword [mm_lex.lxsptr]
    call      mm_lex.readhex
    jmp       L6816
L6818:
    inc       qword [mm_lex.lxsptr]
    call      mm_lex.readbin
    jmp       L6816
L6819:
    lea       rcx,	[L13121]
    call      mm_support.lxerror
L6816:
    jmp       L6812
L6815:
    dec       qword [mm_lex.lxsptr]
    call      mm_lex.readdec
L6812:
    jmp       L6790
L6820:
;mm_lex.lexreadtoken.docomment:
L6822:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	13
    jz        L6824
    cmp       rax,	10
    jz        L6825
    test      rax,	rax
    jz        L6826
    jmp       L6827
L6824:
    inc       qword [mm_lex.lxsptr]
    jmp       L6823
L6825:
    jmp       L6823
L6826:
    dec       qword [mm_lex.lxsptr]
    jmp       L6823
L6827:
    jmp       L6822
L6823:
    mov       al,	58
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6828:
    mov       al,	23
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6829:
    xor       r13,	r13
L6830:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jz        L6832
    cmp       rax,	10
    jz        L6833
    test      rax,	rax
    jz        L6834
    cmp       rax,	32
    jz        L6835
    cmp       rax,	9
    jz        L6835
    cmp       rax,	33
    jz        L6836
    jmp       L6837
L6832:
    inc       qword [mm_lex.lxsptr]
    jmp       L6831
L6833:
    jmp       L6831
L6834:
    mov       al,	59
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    dec       qword [mm_lex.lxsptr]
    jmp       L6790
L6835:
    jmp       L6830
L6836:
    mov       r13,	1
    jmp       L6830
L6837:
    test      r13,	r13
    jnz       L6839
    lea       rcx,	[L13122]
    call      mm_support.lxerror
L6839:
    jmp       L6830
L6831:
L6840:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jz        L6842
    cmp       rax,	10
    jz        L6843
    cmp       rax,	32
    jz        L6844
    cmp       rax,	9
    jz        L6844
    jmp       L6845
L6842:
    inc       qword [mm_lex.lxsptr]
    jmp       L6840
L6843:
    jmp       L6840
L6844:
    jmp       L6840
L6845:
    dec       qword [mm_lex.lxsptr]
    jmp       L6841
L6841:
    jmp       L6791
L6846:
    mov       al,	13
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6847:
    mov       al,	14
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6848:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jnz       L6851
L6850:
    inc       qword [mm_lex.lxsptr]
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jnz       L6853
    inc       qword [mm_lex.lxsptr]
    mov       al,	22
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6852
L6853:
    mov       al,	21
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	21
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6852:
    jmp       L6790
L6851:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	48
    jl        L6855
    cmp       rax,	57
    jg        L6855
    dec       qword [mm_lex.lxsptr]
    lea       rcx,	[L13123]
    call      mm_support.lxerror
    jmp       L6790
L6855:
    mov       al,	1
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6854:
L6849:
    jmp       L6791
L6856:
    mov       al,	3
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6857:
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6858:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	61
    jnz       L6861
L6860:
    inc       qword [mm_lex.lxsptr]
    mov       al,	6
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	28
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6859
L6861:
    mov       al,	5
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
L6859:
    jmp       L6790
L6862:
    mov       al,	9
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6863:
    mov       al,	10
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6864:
    mov       al,	11
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6865:
    mov       al,	12
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6866:
    mov       al,	16
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6867:
    mov       al,	15
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6868:
    mov       al,	17
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6869:
    lea       rax,	[rbp + mm_lex.lexreadtoken.str]
    mov       r14,	rax
    mov       rax,	[mm_lex.lxsptr]
    lea       rax,	[rax+1]
    mov       r15,	rax
    jmp       L6871
L6870:
    mov       rax,	r15
    inc       r15
    mov       al,	[rax]
    mov       r10,	r14
    inc       r14
    mov       [r10],	al
L6871:
    movzx     rax,	byte [r15]
    cmp       rax,	13
    jz        L6873
    cmp       rax,	10
    jz        L6873
    test      rax,	rax
    jnz       L6870
L6873:
    xor       eax,	eax
    mov       [r14],	al
    lea       rcx,	[rbp + mm_lex.lexreadtoken.str]
    call      mlib.pcm_copyheapstring
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       al,	18
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6874:
    jmp       L6791
L6875:
    mov       al,	24
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	43
    jnz       L6877
    inc       qword [mm_lex.lxsptr]
    mov       al,	61
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	84
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6790
L6877:
    jmp       L6790
L6878:
    mov       al,	25
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	45
    jz        L6880
    cmp       rax,	62
    jz        L6881
    jmp       L6882
L6880:
    inc       qword [mm_lex.lxsptr]
    mov       al,	61
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	85
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6790
L6881:
    inc       qword [mm_lex.lxsptr]
    mov       al,	8
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6882:
L6879:
    jmp       L6790
L6883:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	42
    jnz       L6885
    inc       qword [mm_lex.lxsptr]
    mov       al,	43
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6884
L6885:
    mov       al,	26
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
L6884:
    jmp       L6790
L6886:
    mov       al,	27
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6887:
    mov       al,	28
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6888:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L6891
L6890:
    mov       al,	7
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    inc       qword [mm_lex.lxsptr]
    jmp       L6889
L6891:
    mov       al,	41
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6889:
    jmp       L6790
L6892:
    mov       al,	42
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	61
    jz        L6894
    cmp       rax,	62
    jz        L6895
    cmp       rax,	60
    jz        L6896
    jmp       L6897
L6894:
    inc       qword [mm_lex.lxsptr]
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6893
L6895:
    inc       qword [mm_lex.lxsptr]
    mov       al,	2
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6893
L6896:
    inc       qword [mm_lex.lxsptr]
    mov       al,	34
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6893
L6897:
    mov       al,	3
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6893:
    jmp       L6790
L6898:
    mov       al,	42
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	61
    jz        L6900
    cmp       rax,	62
    jz        L6901
    jmp       L6902
L6900:
    inc       qword [mm_lex.lxsptr]
    mov       al,	42
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	5
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6899
L6901:
    inc       qword [mm_lex.lxsptr]
    mov       al,	35
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6899
L6902:
    mov       al,	42
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	6
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6899:
    jmp       L6790
L6903:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	38
    jz        L6905
    cmp       rax,	46
    jz        L6906
    jmp       L6907
L6905:
    inc       qword [mm_lex.lxsptr]
    mov       al,	20
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	57
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6904
L6906:
    inc       qword [mm_lex.lxsptr]
    mov       al,	2
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6904
L6907:
    mov       al,	19
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	55
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6904:
    jmp       L6790
L6908:
    mov       rcx,	39
    call      mm_lex.lxreadstring
    jmp       L6790
L6909:
    mov       rcx,	34
    call      mm_lex.lxreadstring
    jmp       L6790
L6910:
    call      mm_lex.readrawxname
    jmp       L6790
L6911:
    jmp       L6791
L6912:
    inc       qword [mm_lex.lxsptr]
    mov       al,	58
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6913:
    mov       al,	58
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6790
L6914:
    mov       rax,	[mm_lex.sourcelevel]
    test      rax,	rax
    jz        L6916
    call      mm_lex.unstacksource
    jmp       L6790
L6916:
    mov       al,	59
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    dec       qword [mm_lex.lxsptr]
    jmp       L6790
L6915:
    jmp       L6791
L6794:
    lea       rcx,	[L13124]
    call      mm_support.lxerror
    jmp       L6790
L6790:
;---------------
    add       rsp,	296
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.lexsetup
mm_lex.lexsetup:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.inithashtable
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lex.printstrn
mm_lex.printstrn:
;?>>
   %define R.s rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rbx,	rbx
    jz        L6920
    call      msys.m$print_startcon
    mov       rcx,	rbx
    lea       rdx,	[L13125]
    call      msys.m$print_i64
    mov       rcx,	rdi
    lea       rdx,	[L13126]
    call      msys.m$print_str
    call      msys.m$print_end
L6920:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readrawstring
mm_lex.readrawstring:
;?>>
   %define R.dest rdi
   %define R.c rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       al,	65
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    inc       qword [mm_lex.lxsptr]
    mov       rax,	[mm_lex.lxsptr]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       rdi,	[mm_lex.lxsptr]
L6922:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    cmp       rax,	34
    jz        L6924
    cmp       rax,	13
    jz        L6925
    cmp       rax,	10
    jz        L6925
    test      rax,	rax
    jz        L6925
    jmp       L6926
L6924:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	34
    jnz       L6928
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	34
    mov       [rax],	r10b
    inc       qword [mm_lex.lxsptr]
    jmp       L6927
L6928:
    jmp       L6923
L6927:
    jmp       L6922
L6925:
    lea       rcx,	[L13127]
    call      mm_support.lxerror
    dec       qword [mm_lex.lxsptr]
    jmp       L6923
L6926:
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	bl
    mov       [rax],	r10b
    jmp       L6922
L6923:
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    mov       r10,	[mm_lex.lxsptr]
    sub       r10,	rax
    lea       rax,	[mm_decls.nextlx]
    mov       [rax+2],	r10w
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	word [rax+2]
    lea       r10,	[mm_decls.nextlx]
    mov       r10,	[r10+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.pcm_copyheapstringn
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.lookup
mm_lex.lookup:
;?>>
   %define R.name r12
   %define R.length r13
   %define R.hashindex r14
   %define R.wrapped rdi
   %define R.j rbx
   %define R.d rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    mov       rax,	r14
    and       rax,	65535
    mov       rbx,	rax
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rbx
    mov       rsi,	[rax + r10*8]
    xor       rdi,	rdi
L6930:
    test      rsi,	rsi
    jnz       L6933
    jmp       L6931
L6933:
    movzx     rax,	byte [rsi+76]
    cmp       rax,	r13
    jnz       L6935
    mov       rax,	[rsi]
    mov       rcx,	rax
    mov       rdx,	r12
    mov       r8,	r13
    call      memcmp
    movsxd    r10,	eax
    test      r10,	r10
    jnz       L6935
    mov       rax,	rsi
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       al,	[rsi+77]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	[rsi+79]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6929
L6935:
    inc       rbx
    cmp       rbx,	65536
    jl        L6937
    test      rdi,	rdi
    jz        L6939
    lea       rcx,	[L13128]
    call      mlib.abortprogram
L6939:
    mov       rdi,	1
    xor       rbx,	rbx
L6937:
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rbx
    mov       rsi,	[rax + r10*8]
    jmp       L6930
L6931:
    mov       rcx,	176
    call      mlib.pcm_allocnfz
    mov       rsi,	rax
    mov       rax,	rsi
    lea       r10,	[mm_lex.hashtable]
    mov       r11,	rbx
    mov       [r10 + r11*8],	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mlib.pcm_copyheapstringn
    mov       [rsi],	rax
    mov       [rsi+76],	r13b
    mov       al,	67
    mov       [rsi+77],	al
    mov       rax,	rsi
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       al,	[rsi+77]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
L6929:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.lookupsys
mm_lex.lookupsys:
;?>>
   %define R.name rsi
   %define R.j rdi
   %define R.wrapped rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_lex.gethashvaluez
    and       rax,	65535
    mov       rdi,	rax
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[mm_decls.lx]
    mov       [r10+8],	rax
    xor       rbx,	rbx
L6941:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L6942
L6944:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mlib.eqstring
    test      rax,	rax
    jz        L6945
    call      msys.m$print_startcon
    lea       rcx,	[L13129]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L6945:
L6943:
    inc       rdi
    cmp       rdi,	65536
    jl        L6947
    test      rbx,	rbx
    jz        L6949
    lea       rcx,	[L13130]
    call      mlib.abortprogram
L6949:
    mov       rbx,	1
    xor       rdi,	rdi
L6947:
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[mm_decls.lx]
    mov       [r10+8],	rax
    jmp       L6941
L6942:
    mov       rcx,	176
    call      mlib.pcm_allocnfz
    lea       r10,	[mm_decls.lx]
    mov       [r10+8],	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    lea       r10,	[mm_lex.hashtable]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10,	rsi
    mov       [rax],	r10
    mov       rcx,	rsi
    call      strlen
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+76],	al
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10b,	67
    mov       [rax+77],	r10b
    xor       eax,	eax
L6940:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.gethashvaluez
mm_lex.gethashvaluez:
;?>>
   %define R.s rcx
   %define R.c rdi
   %define R.hsum rbx
    push      rdi
    push      rbx
;?]]
;---------------
    movzx     rax,	byte [rcx]
    test      rax,	rax
    jnz       L6952
    xor       eax,	eax
    jmp       L6950
L6952:
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte [rax]
    mov       rbx,	rax
L6953:
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L6956
    jmp       L6954
L6956:
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L6953
L6954:
    mov       rax,	rbx
L6950:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.inithashtable
mm_lex.inithashtable:
;?>>
   %define R.i rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[mm_lex.hashtable]
    xor       edx,	edx
    mov       r8,	524288
    call      memset
    mov       rdi,	1
    mov       rbx,	174
    cmp       rbx,	1
    jl        L6960
L6958:
    lea       rax,	[mm_tables.stnames]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      mm_lex.lookupsys
    lea       rax,	[mm_tables.stsymbols]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+77],	al
    lea       rax,	[mm_tables.stsymbols]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	66
    jnz       L6963
L6962:
    lea       rax,	[mm_tables.stsubcodes]
    mov       r10,	rdi
    movsx     rax,	word [rax + r10*2-2]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+80],	eax
    lea       rax,	[mm_tables.stsymbols]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+79],	al
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10b,	67
    mov       [rax+77],	r10b
    jmp       L6961
L6963:
    lea       rax,	[mm_tables.stsubcodes]
    mov       r10,	rdi
    mov       ax,	[rax + r10*2-2]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+79],	al
L6961:
    inc       rdi
    cmp       rdi,	rbx
    jle       L6958
L6960:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.printhashtable
mm_lex.printhashtable:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13131]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lex.addreservedword
mm_lex.addreservedword:
;?>>
   %define R.name rdi
   %define R.symbol rbx
   %define R.subcode rsi
   %define R.regsize r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rcx,	rdi
    call      mm_lex.lookupsys
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10b,	67
    mov       [rax+77],	r10b
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10b,	bl
    mov       [rax+79],	r10b
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10d,	esi
    mov       [rax+80],	r10d
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10w,	r12w
    mov       [rax+164],	r10w
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.doinclude
mm_lex.doinclude:
;?>>
   %define R.file rdi
   %define R.pf rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.lexreadtoken
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	65
    jz        L6968
    lea       rcx,	[L13132]
    call      mm_support.lxerror
L6968:
    lea       rax,	[mm_decls.nextlx]
    mov       rdi,	[rax+8]
    mov       rcx,	rdi
    call      mlib.convlcstring
    mov       rcx,	rdi
    lea       rdx,	[L13133]
    call      mlib.addext
    mov       rdi,	rax
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_lex.lxfileno]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+16]
    mov       rcx,	rdi
    lea       rdx,	[L13134]
    mov       r8,	rax
    call      mm_support.getsupportfile
    mov       rbx,	rax
    call      mm_lex.lexreadtoken
    movsx     rax,	word [rbx+64]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_lex.stacksource
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.startlex
mm_lex.startlex:
;?>>
   %define R.file rcx
;?]]
;---------------
    mov       rax,	[rcx+32]
    mov       [mm_lex.lxsptr],	rax
    mov       [mm_lex.lxsource],	rax
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+4],	eax
    movsx     rax,	word [rcx+64]
    mov       [mm_lex.lxfileno],	rax
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
;---------------
    ret       
;End 
;Proc mm_lex.addnamestr
mm_lex.addnamestr:
;?>>
   %define R.name rbx
    %define mm_lex.addnamestr.oldlx -16
   %define R.symptr rdi
    %define mm_lex.addnamestr.$T1 -24
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       rbx,	rcx
;---------------
    lea       rax,	[mm_decls.nextlx]
    lea       r10,	[rbp + mm_lex.addnamestr.oldlx]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    mov       rcx,	rbx
    call      mm_lex.gethashvaluez
    mov       [rbp + mm_lex.addnamestr.$T1],	rax
    mov       rcx,	rbx
    call      strlen
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	[rbp + mm_lex.addnamestr.$T1]
    call      mm_lex.lookup
    lea       rax,	[mm_decls.nextlx]
    mov       rdi,	[rax+8]
    lea       rax,	[rbp + mm_lex.addnamestr.oldlx]
    lea       r10,	[mm_decls.nextlx]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    mov       rax,	rdi
L6970:
;---------------
    add       rsp,	64
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.ps
mm_lex.ps:
;?>>
   %define R.caption rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13135]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13136]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[mm_decls.lx]
    call      mm_diags.printsymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.psnext
mm_lex.psnext:
;?>>
   %define R.caption rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13136]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[mm_decls.nextlx]
    call      mm_diags.printsymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.psx
mm_lex.psx:
;?>>
   %define R.caption rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13136]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[mm_decls.lx]
    call      mm_diags.printsymbol
    call      msys.m$print_startcon
    lea       rcx,	[L13137]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[mm_decls.nextlx]
    call      mm_diags.printsymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.stacksource
mm_lex.stacksource:
;?>>
   %define R.fileno rdi
   %define R.isimport rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	[mm_lex.sourcelevel]
    cmp       rax,	20
    jl        L6976
    lea       rcx,	[L13138]
    call      mm_support.lxerror
L6976:
    inc       qword [mm_lex.sourcelevel]
    mov       rax,	[mm_lex.lxstart]
    lea       r10,	[mm_lex.lxstart_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[mm_lex.lxsource]
    lea       r10,	[mm_lex.lxsource_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[mm_lex.lxsptr]
    lea       r10,	[mm_lex.lxsptr_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[mm_lex.lxfileno]
    lea       r10,	[mm_lex.lxfileno_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[mm_decls.nextlx]
    lea       r10,	[mm_lex.lxnextlx_stack]
    mov       r11,	[mm_lex.sourcelevel]
    shl       r11,	4
    movdqu    XMM4,	[rax]
    movdqu    [r10 + r11-16],	XMM4
    mov       al,	[mm_lex.lximport]
    lea       r10,	[mm_lex.lximport_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11-1],	al
    mov       [mm_lex.lximport],	rbx
    lea       rax,	[mm_decls.sources]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+32]
    mov       [mm_lex.lxsptr],	rax
    mov       [mm_lex.lxsource],	rax
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+4],	eax
    mov       [mm_lex.lxfileno],	rdi
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.unstacksource
mm_lex.unstacksource:
;?>>
;?]]
;---------------
    mov       rax,	[mm_lex.sourcelevel]
    cmp       rax,	0
    jle       L6979
    lea       rax,	[mm_lex.lxstart_stack]
    mov       r10,	[mm_lex.sourcelevel]
    mov       rax,	[rax + r10*8-8]
    mov       [mm_lex.lxstart],	rax
    lea       rax,	[mm_lex.lxsource_stack]
    mov       r10,	[mm_lex.sourcelevel]
    mov       rax,	[rax + r10*8-8]
    mov       [mm_lex.lxsource],	rax
    lea       rax,	[mm_lex.lxsptr_stack]
    mov       r10,	[mm_lex.sourcelevel]
    mov       rax,	[rax + r10*8-8]
    mov       [mm_lex.lxsptr],	rax
    lea       rax,	[mm_lex.lxnextlx_stack]
    mov       r10,	[mm_lex.sourcelevel]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    lea       r10,	[mm_decls.nextlx]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    lea       rax,	[mm_lex.lxfileno_stack]
    mov       r10,	[mm_lex.sourcelevel]
    mov       rax,	[rax + r10*8-8]
    mov       [mm_lex.lxfileno],	rax
    lea       rax,	[mm_lex.lximport_stack]
    mov       r10,	[mm_lex.sourcelevel]
    movzx     rax,	byte [rax + r10-1]
    mov       [mm_lex.lximport],	rax
    dec       qword [mm_lex.sourcelevel]
L6979:
;---------------
    ret       
;End 
;Proc mm_lex.readarraystring
mm_lex.readarraystring:
;?>>
   %define R.prefix rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    inc       qword [mm_lex.lxsptr]
    mov       rcx,	34
    call      mm_lex.lxreadstring
    cmp       rdi,	83
    jnz       L6982
    mov       al,	83
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6981
L6982:
    lea       rax,	[mm_decls.nextlx]
    lea       rax,	[rax+2]
    dec       word [rax]
    mov       al,	66
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6981:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.setinttype
mm_lex.setinttype:
;?>>
   %define R.a rcx
;?]]
;---------------
    mov       rax,	rcx
    mov       r10,	9223372036854775807
    cmp       rax,	r10
    ja        L6985
    mov       rax,	3
    jmp       L6984
L6985:
    mov       rax,	4
L6984:
L6983:
;---------------
    ret       
;End 
;Proc mm_lex.readrawxname
mm_lex.readrawxname:
;?>>
   %define R.c rdi
   %define R.hsum rbx
   %define R.length rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mm_lex.lxsptr]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    xor       rbx,	rbx
    jmp       L6988
L6987:
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    mov       rbx,	rax
L6988:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    lea       r10,	[mm_lex.namemap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L6987
    dec       qword [mm_lex.lxsptr]
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    mov       r10,	[mm_lex.lxsptr]
    sub       r10,	rax
    mov       rsi,	r10
    test      rsi,	rsi
    jnz       L6991
    lea       rcx,	[L13139]
    call      mm_support.lxerror
L6991:
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mm_lex.lookup
    mov       al,	60
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
L6986:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.lxerror_s
mm_lex.lxerror_s:
;?>>
   %define R.mess rdi
    %define mm_lex.lxerror_s.s 32
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.lxerror
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.lxreadstring
mm_lex.lxreadstring:
;?>>
   %define R.termchar r14
    %define mm_lex.lxreadstring.s -8
   %define R.t rdi
   %define R.c rbx
   %define R.length rsi
   %define R.hasescape r12
    %define mm_lex.lxreadstring.str -16
   %define R.pass r13
    %define mm_lex.lxreadstring.$T1 -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r14,	rcx
;---------------
    cmp       r14,	34
    jnz       L6995
    mov       al,	65
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6994
L6995:
    mov       al,	64
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	3
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6994:
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    xor       rdi,	rdi
    mov       rax,	1
    mov       r13,	rax
L6996:
    mov       rax,	[mm_lex.lxsptr]
    mov       [rbp + mm_lex.lxreadstring.s],	rax
L6999:
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    inc       qword [rbp + mm_lex.lxreadstring.s]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    cmp       rax,	92
    jz        L7002
    cmp       rax,	34
    jz        L7003
    cmp       rax,	39
    jz        L7003
    cmp       rax,	13
    jz        L7004
    cmp       rax,	10
    jz        L7004
    test      rax,	rax
    jz        L7004
    jmp       L7005
L7002:
    mov       r12,	1
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    cmp       rbx,	65
    jl        L7007
    cmp       rbx,	90
    jg        L7007
    mov       rax,	32
    add       rbx,	rax
L7007:
    inc       qword [rbp + mm_lex.lxreadstring.s]
    mov       rax,	rbx
    cmp       rax,	97
    jz        L7009
    cmp       rax,	98
    jz        L7010
    cmp       rax,	99
    jz        L7011
    cmp       rax,	114
    jz        L7011
    cmp       rax,	101
    jz        L7012
    cmp       rax,	102
    jz        L7013
    cmp       rax,	104
    jz        L7014
    cmp       rax,	108
    jz        L7015
    cmp       rax,	110
    jz        L7015
    cmp       rax,	116
    jz        L7016
    cmp       rax,	117
    jz        L7017
    cmp       rax,	118
    jz        L7017
    cmp       rax,	119
    jz        L7018
    cmp       rax,	120
    jz        L7019
    cmp       rax,	121
    jz        L7020
    cmp       rax,	122
    jz        L7021
    jmp       L7022
L7009:
    mov       rbx,	7
    jmp       L7008
L7010:
    mov       rbx,	8
    jmp       L7008
L7011:
    mov       rbx,	13
    jmp       L7008
L7012:
    mov       rbx,	27
    jmp       L7008
L7013:
    mov       rbx,	12
    jmp       L7008
L7014:
    jmp       L7024
L7023:
    lea       rcx,	[rbp + mm_lex.lxreadstring.s]
    mov       rdx,	2
    mov       r8,	1
    call      mm_lex.readhexcode
    mov       rbx,	rax
    cmp       r13,	2
    jnz       L7027
    mov       [rdi],	bl
L7027:
    inc       rdi
L7024:
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jnz       L7023
    inc       qword [rbp + mm_lex.lxreadstring.s]
    dec       rdi
    jmp       L7008
L7015:
    mov       rbx,	10
    jmp       L7008
L7016:
    mov       rbx,	9
    jmp       L7008
L7017:
    cmp       r13,	2
    jnz       L7029
    mov       rax,	rdi
    jmp       L7028
L7029:
    xor       eax,	eax
L7028:
    mov       [rbp + mm_lex.lxreadstring.$T1],	rax
    cmp       rbx,	117
    jnz       L7031
    mov       rax,	4
    jmp       L7030
L7031:
    mov       rax,	6
L7030:
    lea       rcx,	[rbp + mm_lex.lxreadstring.s]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lex.readhexcode
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_lex.lxreadstring.$T1]
    call      mm_lex.getutf8
    add       rdi,	rax
    jmp       L6999
L7018:
    cmp       r13,	2
    jnz       L7033
    mov       al,	13
    mov       [rdi],	al
L7033:
    inc       rdi
    mov       rbx,	10
    jmp       L7008
L7019:
    lea       rcx,	[rbp + mm_lex.lxreadstring.s]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mm_lex.readhexcode
    mov       rbx,	rax
    jmp       L7008
L7020:
    mov       rbx,	16
    jmp       L7008
L7021:
    xor       rbx,	rbx
    jmp       L7008
L7022:
    mov       rax,	rbx
    cmp       rax,	34
    jz        L7035
    cmp       rax,	92
    jz        L7036
    cmp       rax,	39
    jz        L7037
    cmp       rax,	48
    jz        L7038
    jmp       L7039
L7035:
    mov       rbx,	34
    jmp       L7034
L7036:
    mov       rbx,	92
    jmp       L7034
L7037:
    mov       rbx,	39
    jmp       L7034
L7038:
    xor       rbx,	rbx
    jmp       L7034
L7039:
    mov       [rbp + mm_lex.lxreadstring.str],	bl
    xor       eax,	eax
    mov       [rbp + mm_lex.lxreadstring.str+1],	al
    lea       rcx,	[L13140]
    lea       rdx,	[rbp + mm_lex.lxreadstring.str]
    call      mm_lex.lxerror_s
L7034:
L7008:
    jmp       L7001
L7003:
    cmp       rbx,	r14
    jnz       L7041
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    movzx     rax,	byte [rax]
    cmp       rax,	rbx
    jnz       L7043
    inc       qword [rbp + mm_lex.lxreadstring.s]
    jmp       L7042
L7043:
    jmp       L7000
L7042:
L7041:
    mov       r12,	1
    jmp       L7001
L7004:
    lea       rcx,	[L13141]
    call      mm_support.lxerror
L7005:
L7001:
    cmp       r13,	2
    jnz       L7045
    mov       [rdi],	bl
L7045:
    inc       rdi
    jmp       L6999
L7000:
    cmp       r13,	1
    jnz       L7047
    mov       rsi,	rdi
    lea       rax,	[rsi+1]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+2],	ax
    test      r12,	r12
    jz        L7049
    lea       rax,	[rsi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rdi,	rax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    jmp       L7048
L7049:
    test      rsi,	rsi
    jnz       L7050
    lea       rax,	[L13142]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    mov       [mm_lex.lxsptr],	rax
    jmp       L6993
L7050:
    mov       rcx,	[mm_lex.lxsptr]
    mov       rdx,	rsi
    call      mlib.pcm_copyheapstringn
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    mov       [mm_lex.lxsptr],	rax
    jmp       L6993
L7048:
    jmp       L7046
L7047:
    xor       eax,	eax
    mov       [rdi],	al
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    mov       [mm_lex.lxsptr],	rax
L7046:
    inc       r13
    cmp       r13,	2
    jle       L6996
L6993:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readhexcode
mm_lex.readhexcode:
;?>>
   %define R.s r12
   %define R.n r13
   %define R.sp r14
   %define R.a rdi
   %define R.c rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    xor       rdi,	rdi
    mov       rax,	1
    mov       rsi,	rax
    cmp       r13,	1
    jl        L7054
L7052:
    test      r14,	r14
    jz        L7056
    mov       eax,	esi
    and       eax,	1
    test      rax,	rax
    jz        L7056
L7057:
    mov       rax,	r12
    mov       r10,	[rax]
    inc       qword [rax]
    movzx     r10,	byte [r10]
    mov       rbx,	r10
    cmp       rbx,	32
    jz        L7057
    jmp       L7055
L7056:
    mov       rax,	r12
    mov       r10,	[rax]
    inc       qword [rax]
    movzx     r10,	byte [r10]
    mov       rbx,	r10
L7055:
    mov       rax,	rbx
    cmp       rax,	65
    jl        L7061
    cmp       rax,	70
    jg        L7061
    mov       rax,	rdi
    shl       rax,	4
    add       rax,	rbx
    sub       rax,	65
    add       rax,	10
    mov       rdi,	rax
    jmp       L7060
L7061:
    mov       rax,	rbx
    cmp       rax,	97
    jl        L7062
    cmp       rax,	102
    jg        L7062
    mov       rax,	rdi
    shl       rax,	4
    add       rax,	rbx
    sub       rax,	97
    add       rax,	10
    mov       rdi,	rax
    jmp       L7060
L7062:
    mov       rax,	rbx
    cmp       rax,	48
    jl        L7063
    cmp       rax,	57
    jg        L7063
    mov       rax,	rdi
    shl       rax,	4
    add       rax,	rbx
    sub       rax,	48
    mov       rdi,	rax
    jmp       L7060
L7063:
    lea       rcx,	[L13143]
    call      mm_support.lxerror
L7060:
    inc       rsi
    cmp       rsi,	r13
    jle       L7052
L7054:
    mov       rax,	rdi
L7051:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.getutf8
mm_lex.getutf8:
;?>>
   %define R.c rcx
   %define R.s rdx
   %define R.n rdi
    %define mm_lex.getutf8.str -16
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	24
;---------------
    test      rdx,	rdx
    jnz       L7066
    lea       rax,	[rbp + mm_lex.getutf8.str]
    mov       rdx,	rax
L7066:
    cmp       rcx,	127
    jg        L7068
    mov       rdi,	1
    mov       rax,	rdx
    inc       rdx
    mov       r10b,	cl
    mov       [rax],	r10b
    jmp       L7067
L7068:
    cmp       rcx,	2047
    jg        L7069
    mov       rdi,	2
    mov       rax,	rcx
    shr       rax,	6
    and       rax,	31
    mov       r10,	192
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    jmp       L7067
L7069:
    cmp       rcx,	65535
    jg        L7070
    mov       rdi,	3
    mov       rax,	rcx
    shr       rax,	12
    and       rax,	15
    mov       r10,	224
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    shr       rax,	6
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    jmp       L7067
L7070:
    cmp       rcx,	1114111
    jg        L7071
    mov       rdi,	4
    mov       rax,	rcx
    shr       rax,	18
    and       rax,	7
    mov       r10,	240
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    shr       rax,	12
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    shr       rax,	6
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    jmp       L7067
L7071:
    xor       rdi,	rdi
L7067:
    xor       eax,	eax
    mov       [rdx],	al
    mov       rax,	rdi
L7064:
;---------------
    add       rsp,	24
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_lex.readdec
mm_lex.readdec:
;?>>
   %define R.c rdi
   %define R.dest rbx
   %define R.destend rsi
   %define R.pstart r12
   %define R.islong r13
   %define R.length r14
    %define mm_lex.readdec.str -1024
   %define R.a r15
    %define mm_lex.readdec.av_1 -1032
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1064
;---------------
    xor       r13,	r13
    mov       rax,	[mm_lex.lxsptr]
    mov       r12,	rax
    lea       rax,	[rbp + mm_lex.readdec.str]
    mov       rbx,	rax
    lea       rax,	[rbx+1024]
    sub       rax,	10
    mov       rsi,	rax
    xor       r15,	r15
L7073:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jl        L7076
    cmp       rax,	57
    jg        L7076
    mov       rax,	r15
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       r15,	rax
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7075
L7076:
    mov       rax,	rdi
    cmp       rax,	101
    jz        L7078
    cmp       rax,	69
    jz        L7078
    cmp       rax,	46
    jz        L7079
    cmp       rax,	95
    jz        L7080
    cmp       rax,	39
    jz        L7080
    cmp       rax,	108
    jz        L7081
    cmp       rax,	76
    jz        L7081
    cmp       rax,	98
    jz        L7082
    cmp       rax,	66
    jz        L7082
    jmp       L7083
L7078:
    mov       [mm_lex.lxsptr],	r12
    call      mm_lex.readreal
    jmp       L7072
L7079:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jz        L7085
    mov       [mm_lex.lxsptr],	r12
    call      mm_lex.readreal
    jmp       L7072
L7085:
    dec       qword [mm_lex.lxsptr]
    jmp       L7074
L7080:
    jmp       L7077
L7081:
    call      mm_lex.nodecimal
    jmp       L7077
L7082:
    mov       rax,	rbx
    lea       r10,	[rbp + mm_lex.readdec.str]
    sub       rax,	r10
    mov       r14,	rax
    cmp       r14,	64
    jle       L7087
    lea       rcx,	[L13144]
    call      mm_support.lxerror
L7087:
    lea       rax,	[rbp + mm_lex.readdec.str]
    mov       rbx,	rax
    xor       r15,	r15
    mov       rax,	r14
    mov       [rbp + mm_lex.readdec.av_1],	rax
    mov       rax,	[rbp + mm_lex.readdec.av_1]
    cmp       rax,	0
    jle       L7090
L7088:
    movzx     rax,	byte [rbx]
    cmp       rax,	50
    jb        L7092
    lea       rcx,	[L13145]
    call      mm_support.lxerror
L7092:
    mov       rax,	r15
    shl       rax,	1
    mov       r10,	rbx
    inc       rbx
    movzx     r10,	byte [r10]
    add       rax,	r10
    sub       rax,	48
    mov       r15,	rax
    dec       qword [rbp + mm_lex.readdec.av_1]
    jnz       L7088
L7090:
    jmp       L7093
L7083:
    dec       qword [mm_lex.lxsptr]
    jmp       L7074
L7077:
L7075:
    cmp       rbx,	rsi
    jb        L7095
    lea       rcx,	[L13146]
    call      mm_support.lxerror
L7095:
    jmp       L7073
L7074:
    mov       rax,	rbx
    lea       r10,	[rbp + mm_lex.readdec.str]
    sub       rax,	r10
    mov       r14,	rax
    cmp       r14,	20
    jg        L7098
    cmp       r14,	20
    jnz       L7097
    lea       rcx,	[rbp + mm_lex.readdec.str]
    mov       rdx,	[mm_lex.u64maxstr]
    mov       r8,	20
    call      strncmp
    movsxd    r10,	eax
    cmp       r10,	0
    jle       L7097
L7098:
    call      mm_lex.nodecimal
L7097:
;mm_lex.readdec.finish:
L7093:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rcx,	r15
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	r15
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
L7072:
;---------------
    add       rsp,	1064
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readhex
mm_lex.readhex:
;?>>
   %define R.c rdi
   %define R.dest rbx
   %define R.destend rsi
   %define R.pstart r12
   %define R.length r13
    %define mm_lex.readhex.str -1024
   %define R.a r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1056
;---------------
    mov       r12,	[mm_lex.lxsptr]
    lea       rax,	[rbp + mm_lex.readhex.str]
    mov       rbx,	rax
    lea       rax,	[rbx+1024]
    sub       rax,	10
    mov       rsi,	rax
    xor       r14,	r14
L7100:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jl        L7103
    cmp       rax,	57
    jg        L7103
    mov       rax,	r14
    shl       rax,	4
    add       rax,	rdi
    sub       rax,	48
    mov       r14,	rax
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7102
L7103:
    mov       rax,	rdi
    cmp       rax,	65
    jl        L7104
    cmp       rax,	70
    jg        L7104
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    mov       rax,	r14
    shl       rax,	4
    add       rax,	rdi
    sub       rax,	65
    add       rax,	10
    mov       r14,	rax
    jmp       L7102
L7104:
    mov       rax,	rdi
    cmp       rax,	97
    jl        L7105
    cmp       rax,	102
    jg        L7105
    lea       rax,	[rdi-32]
    mov       r10,	rbx
    inc       rbx
    mov       [r10],	al
    mov       rax,	r14
    shl       rax,	4
    add       rax,	rdi
    sub       rax,	97
    add       rax,	10
    mov       r14,	rax
    jmp       L7102
L7105:
    mov       rax,	rdi
    cmp       rax,	95
    jz        L7107
    cmp       rax,	39
    jz        L7107
    cmp       rax,	108
    jz        L7108
    cmp       rax,	76
    jz        L7108
    cmp       rax,	46
    jz        L7109
    jmp       L7110
L7107:
    jmp       L7106
L7108:
    call      mm_lex.nodecimal
    jmp       L7106
L7109:
    dec       qword [mm_lex.lxsptr]
    jmp       L7101
L7110:
    dec       qword [mm_lex.lxsptr]
    jmp       L7101
L7106:
L7102:
    cmp       rbx,	rsi
    jb        L7112
    lea       rcx,	[L13146]
    call      mm_support.lxerror
L7112:
    jmp       L7100
L7101:
    mov       rax,	rbx
    lea       r10,	[rbp + mm_lex.readhex.str]
    sub       rax,	r10
    mov       r13,	rax
    cmp       r13,	16
    jle       L7114
    lea       rcx,	[L13147]
    call      mm_support.lxerror
    jmp       L7099
L7114:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rcx,	r14
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	r14
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
L7099:
;---------------
    add       rsp,	1056
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readbin
mm_lex.readbin:
;?>>
   %define R.c rdi
   %define R.dest rbx
   %define R.destend rsi
   %define R.pstart r12
   %define R.length r13
    %define mm_lex.readbin.str -1024
   %define R.a r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1056
;---------------
    mov       r12,	[mm_lex.lxsptr]
    lea       rax,	[rbp + mm_lex.readbin.str]
    mov       rbx,	rax
    lea       rax,	[rbx+1024]
    sub       rax,	10
    mov       rsi,	rax
    xor       r14,	r14
L7116:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jz        L7119
    cmp       rax,	49
    jz        L7119
    cmp       rax,	95
    jz        L7120
    cmp       rax,	39
    jz        L7120
    cmp       rax,	108
    jz        L7121
    cmp       rax,	76
    jz        L7121
    cmp       rax,	46
    jz        L7122
    jmp       L7123
L7119:
    mov       rax,	r14
    shl       rax,	1
    add       rax,	rdi
    sub       rax,	48
    mov       r14,	rax
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7118
L7120:
    jmp       L7118
L7121:
    call      mm_lex.nodecimal
    jmp       L7118
L7122:
    dec       qword [mm_lex.lxsptr]
    jmp       L7117
L7123:
    mov       rax,	rdi
    cmp       rax,	50
    jl        L7125
    cmp       rax,	57
    jg        L7125
    lea       rcx,	[L13148]
    call      mm_support.lxerror
    jmp       L7124
L7125:
    dec       qword [mm_lex.lxsptr]
    jmp       L7117
L7124:
L7118:
    cmp       rbx,	rsi
    jb        L7127
    lea       rcx,	[L13149]
    call      mm_support.lxerror
L7127:
    jmp       L7116
L7117:
    mov       rax,	rbx
    lea       r10,	[rbp + mm_lex.readbin.str]
    sub       rax,	r10
    mov       r13,	rax
    cmp       r13,	64
    jle       L7129
    call      mm_lex.nodecimal
L7129:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rcx,	r14
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	r14
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
;---------------
    add       rsp,	1056
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readreal
mm_lex.readreal:
;?>>
   %define R.c rdi
   %define R.negexpon rbx
   %define R.dotseen rsi
   %define R.length r12
   %define R.fractlen r13
   %define R.expon r14
   %define R.expseen r15
   %define R.x XMM15
    %define mm_lex.readreal.str -1024
    %define mm_lex.readreal.dest -1032
    %define mm_lex.readreal.destend -1040
    %define mm_lex.readreal.a -1048
    %define mm_lex.readreal.av_1 -1056
    %define mm_lex.readreal.av_2 -1064
    %define mm_lex.readreal.av_3 -1072
    %define mm_lex.readreal.av_4 -1080
    %define mm_lex.readreal.i -1088
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
    movq      rax,	XMM15
    push      rax
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1120
;---------------
    lea       rax,	[rbp + mm_lex.readreal.str]
    mov       [rbp + mm_lex.readreal.dest],	rax
    mov       rax,	[rbp + mm_lex.readreal.dest]
    lea       rax,	[rax+1024]
    sub       rax,	100
    mov       [rbp + mm_lex.readreal.destend],	rax
    xor       eax,	eax
    mov       r13,	rax
    mov       r14,	rax
    mov       r15,	rax
    mov       rsi,	rax
    mov       rbx,	rax
    mov       r12,	rax
L7131:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jl        L7134
    cmp       rax,	57
    jg        L7134
    mov       rax,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       r10b,	dil
    mov       [rax],	r10b
    inc       r12
    test      rsi,	rsi
    jz        L7136
    inc       r13
L7136:
    jmp       L7133
L7134:
    mov       rax,	rdi
    cmp       rax,	46
    jz        L7138
    cmp       rax,	101
    jz        L7139
    cmp       rax,	69
    jz        L7139
    cmp       rax,	95
    jz        L7140
    cmp       rax,	39
    jz        L7140
    cmp       rax,	108
    jz        L7141
    cmp       rax,	76
    jz        L7141
    jmp       L7142
L7138:
    test      rsi,	rsi
    jz        L7144
    dec       qword [mm_lex.lxsptr]
    jmp       L7132
L7144:
    mov       rsi,	1
    mov       rax,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7137
L7139:
    test      r15,	r15
    jz        L7146
    lea       rcx,	[L13150]
    call      mm_support.lxerror
L7146:
    mov       r15,	1
    mov       rax,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7148
L7147:
    inc       qword [mm_lex.lxsptr]
L7148:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	32
    jz        L7147
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	43
    jz        L7152
    cmp       rax,	45
    jnz       L7151
L7152:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	45
    jnz       L7154
    mov       rbx,	1
L7154:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    mov       al,	[rax]
    mov       r10,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       [r10],	al
L7151:
    xor       r14,	r14
L7155:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jl        L7158
    cmp       rax,	57
    jg        L7158
    mov       rax,	r14
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       r14,	rax
    mov       rax,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       r10b,	dil
    mov       [rax],	r10b
    mov       rax,	[rbp + mm_lex.readreal.dest]
    cmp       rax,	[rbp + mm_lex.readreal.destend]
    jb        L7160
    lea       rcx,	[L13151]
    call      mm_support.lxerror
L7160:
    jmp       L7157
L7158:
    mov       rax,	rdi
    cmp       rax,	95
    jz        L7162
    cmp       rax,	39
    jz        L7162
    cmp       rax,	108
    jz        L7163
    cmp       rax,	76
    jz        L7163
    jmp       L7164
L7162:
    jmp       L7161
L7163:
    xor       eax,	eax
    mov       r10,	[rbp + mm_lex.readreal.dest]
    mov       [r10],	al
    call      mm_lex.nodecimal
    jmp       L7130
L7164:
    dec       qword [mm_lex.lxsptr]
    jmp       L7132
L7161:
L7157:
    jmp       L7155
L7140:
    jmp       L7137
L7141:
    call      mm_lex.nodecimal
    jmp       L7130
L7142:
    dec       qword [mm_lex.lxsptr]
    jmp       L7132
L7137:
L7133:
    mov       rax,	[rbp + mm_lex.readreal.dest]
    cmp       rax,	[rbp + mm_lex.readreal.destend]
    jb        L7166
    lea       rcx,	[L13152]
    call      mm_support.lxerror
L7166:
    jmp       L7131
L7132:
    xor       eax,	eax
    mov       r10,	[rbp + mm_lex.readreal.dest]
    mov       [r10],	al
    test      r15,	r15
    jz        L7168
    cmp       r14,	0
    jl        L7168
    test      rsi,	rsi
    jnz       L7168
    xor       eax,	eax
    mov       [rbp + mm_lex.readreal.a],	rax
    mov       rax,	1
    mov       [rbp + mm_lex.readreal.i],	rax
    cmp       r12,	1
    jl        L7171
L7169:
    mov       rax,	[rbp + mm_lex.readreal.a]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    mov       r10,	[rbp + mm_lex.readreal.i]
    movzx     r10,	byte [rbp + r10 + mm_lex.readreal.str-1]
    add       rax,	r10
    sub       rax,	48
    mov       [rbp + mm_lex.readreal.a],	rax
    mov       rax,	[rbp + mm_lex.readreal.i]
    inc       rax
    mov       [rbp + mm_lex.readreal.i],	rax
    cmp       rax,	r12
    jle       L7169
L7171:
    mov       [rbp + mm_lex.readreal.av_1],	r14
    mov       rax,	[rbp + mm_lex.readreal.av_1]
    cmp       rax,	0
    jle       L7174
L7172:
    mov       rax,	[rbp + mm_lex.readreal.a]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    mov       [rbp + mm_lex.readreal.a],	rax
    dec       qword [rbp + mm_lex.readreal.av_1]
    jnz       L7172
L7174:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rcx,	[rbp + mm_lex.readreal.a]
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	[rbp + mm_lex.readreal.a]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    jmp       L7130
L7168:
    test      rbx,	rbx
    jz        L7176
    mov       rax,	r14
    neg       rax
    mov       r14,	rax
L7176:
    mov       rax,	r13
    sub       r14,	rax
    movq      XMM4,	[L13153]
    movq      XMM15,	XMM4
    mov       rax,	1
    mov       [rbp + mm_lex.readreal.i],	rax
    mov       rax,	r12
    add       rax,	rsi
    mov       [rbp + mm_lex.readreal.av_2],	rax
    mov       rax,	[rbp + mm_lex.readreal.av_2]
    cmp       rax,	1
    jl        L7179
L7177:
    mov       rax,	[rbp + mm_lex.readreal.i]
    movzx     rax,	byte [rbp + rax + mm_lex.readreal.str-1]
    mov       rdi,	rax
    cmp       rdi,	46
    jz        L7181
    movq      XMM4,	XMM15
    mulsd     XMM4,	[L13154]
    mov       rax,	rdi
    cvtsi2sd  XMM5,	rax
    addsd     XMM4,	XMM5
    mov       rax,	48
    cmp       rax,	0
    jl        L13155
    cvtsi2sd  XMM5,	rax
    jmp       L13156
L13155:
    and       rax,	[L12289]
    cvtsi2sd  XMM5,	rax
    addsd     XMM5,	[L12290]
L13156:
    subsd     XMM4,	XMM5
    movq      XMM15,	XMM4
L7181:
    mov       rax,	[rbp + mm_lex.readreal.i]
    inc       rax
    mov       [rbp + mm_lex.readreal.i],	rax
    cmp       rax,	[rbp + mm_lex.readreal.av_2]
    jle       L7177
L7179:
    cmp       r14,	0
    jl        L7183
    mov       [rbp + mm_lex.readreal.av_3],	r14
    mov       rax,	[rbp + mm_lex.readreal.av_3]
    cmp       rax,	0
    jle       L7186
L7184:
    movq      XMM4,	XMM15
    mulsd     XMM4,	[L13157]
    movq      XMM15,	XMM4
    dec       qword [rbp + mm_lex.readreal.av_3]
    jnz       L7184
L7186:
    jmp       L7182
L7183:
    mov       rax,	r14
    neg       rax
    mov       [rbp + mm_lex.readreal.av_4],	rax
    mov       rax,	[rbp + mm_lex.readreal.av_4]
    cmp       rax,	0
    jle       L7189
L7187:
    movq      XMM4,	XMM15
    divsd     XMM4,	[L13158]
    movq      XMM15,	XMM4
    dec       qword [rbp + mm_lex.readreal.av_4]
    jnz       L7187
L7189:
L7182:
    movq      XMM4,	XMM15
    lea       rax,	[mm_decls.nextlx]
    movq      [rax+8],	XMM4
    mov       al,	63
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L7130:
;---------------
    add       rsp,	1120
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.nodecimal
mm_lex.nodecimal:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L13159]
    call      mm_support.lxerror
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lex.start
mm_lex.start:
;?>>
   %define R.av_1 rdi
   %define R.c rbx
    push      rdi
    push      rbx
;?]]
;---------------
    xor       rbx,	rbx
    mov       rax,	255
    mov       rdi,	rax
    cmp       rdi,	0
    jl        L7194
L7192:
    mov       rax,	rbx
    cmp       rax,	97
    jl        L7198
    cmp       rax,	122
    jle       L7197
L7198:
    mov       rax,	rbx
    cmp       rax,	48
    jl        L7199
    cmp       rax,	57
    jle       L7197
L7199:
    mov       rax,	rbx
    cmp       rax,	95
    jz        L7200
    cmp       rax,	36
    jnz       L7196
L7200:
L7197:
    mov       al,	1
    lea       r10,	[mm_lex.namemap]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    jmp       L7195
L7196:
    mov       rax,	rbx
    cmp       rax,	65
    jl        L7201
    cmp       rax,	90
    jg        L7201
    mov       al,	2
    lea       r10,	[mm_lex.namemap]
    mov       r11,	rbx
    mov       [r10 + r11],	al
L7201:
L7195:
    inc       rbx
    cmp       rbx,	rdi
    jle       L7192
L7194:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.newstrec
mm_lib.newstrec:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	176
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rdi+88],	eax
    mov       al,	[mm_decls.currmoduleno]
    mov       [rdi+94],	al
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[mm_decls.currmoduleno]
    mov       al,	[rax + r10]
    mov       [rdi+95],	al
    mov       rax,	rdi
L7202:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.getduplnameptr
mm_lib.getduplnameptr:
;?>>
   %define R.owner rbx
   %define R.symptr rsi
   %define R.id r12
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      mm_lib.newstrec
    mov       rdi,	rax
    mov       rax,	[rsi]
    mov       [rdi],	rax
    mov       al,	[rsi+76]
    mov       [rdi+76],	al
    mov       al,	67
    mov       [rdi+77],	al
    mov       [rdi+8],	rbx
    mov       [rdi+78],	r12b
    mov       rax,	[rsi+40]
    mov       [rdi+40],	rax
    mov       [rsi+40],	rdi
    mov       [rdi+48],	rsi
    mov       rax,	rdi
L7203:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.adddef
mm_lib.adddef:
;?>>
   %define R.owner rbx
   %define R.p rsi
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rax,	[rsi+40]
    mov       rdi,	rax
    test      rax,	rax
    jz        L7206
    mov       rax,	[rdi+8]
    cmp       rax,	rbx
    jnz       L7208
    call      msys.m$print_startcon
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    lea       rcx,	[L13160]
    call      msys.m$print_str_nf
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13161]
    call      mm_support.serror
L7208:
L7206:
    mov       rax,	[rbx+16]
    test      rax,	rax
    jnz       L7210
    mov       [rbx+16],	rsi
    jmp       L7209
L7210:
    mov       rax,	[rbx+24]
    mov       r10,	rsi
    mov       [rax+32],	r10
L7209:
    mov       [rbx+24],	rsi
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createname
mm_lib.createname:
;?>>
   %define R.p rbx
   %define R.u rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       al,	4
    mov       [rdi],	al
    mov       [rdi+16],	rbx
    mov       rax,	rdi
L7211:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createunit0
mm_lib.createunit0:
;?>>
   %define R.tag rbx
   %define R.u rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       rax,	rdi
L7212:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createunit1
mm_lib.createunit1:
;?>>
   %define R.tag rbx
   %define R.p rsi
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	rsi
    mov       rax,	rdi
L7213:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createunit2
mm_lib.createunit2:
;?>>
   %define R.tag rbx
   %define R.p rsi
   %define R.q r12
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	rsi
    mov       [rdi+24],	r12
    mov       rax,	rdi
L7214:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createunit3
mm_lib.createunit3:
;?>>
   %define R.tag rbx
   %define R.p rsi
   %define R.q r12
   %define R.r r13
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	rsi
    mov       [rdi+24],	r12
    mov       [rdi+32],	r13
    mov       rax,	rdi
L7215:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.insertunit
mm_lib.insertunit:
;?>>
   %define R.p r12
   %define R.tag r13
   %define R.q rdi
   %define R.nextunit rbx
   %define R.mode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       rax,	r12
    push      rdi
    mov       r11,	8
L13162:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L13162
    mov       r10b,	[rax]
    mov       [rdi],	r10b
    pop       rdi
    movsxd    rax,	dword [rdi+49]
    mov       rsi,	rax
    mov       rbx,	[rdi+8]
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	r12
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       [rax+40],	r10
    mov       [rax+48],	r10
    mov       [rax+56],	r10
    mov       [rax+64],	r10b
    mov       [r12],	r13b
    mov       eax,	[rdi+4]
    mov       [r12+4],	eax
    mov       [r12+16],	rdi
    mov       [r12+49],	esi
    mov       [r12+8],	rbx
    mov       al,	[rdi+61]
    mov       [r12+61],	al
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.deleteunit
mm_lib.deleteunit:
;?>>
   %define R.p rcx
   %define R.q rdx
   %define R.r rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rdi,	[rcx+8]
    mov       rax,	rdx
    push      rcx
    mov       r11,	8
L13163:
    mov       r10,	[rax]
    mov       [rcx],	r10
    add       rcx,	8
    add       rax,	8
    dec       r11
    jnz       L13163
    mov       r10b,	[rax]
    mov       [rcx],	r10b
    pop       rcx
    mov       [rcx+8],	rdi
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_lib.createconstunit
mm_lib.createconstunit:
;?>>
   %define R.a rbx
   %define R.t rsi
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi],	al
    mov       [rdi+16],	rbx
    mov       [rdi+49],	esi
    mov       al,	1
    mov       [rdi+60],	al
    mov       rax,	rdi
L7218:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createstringconstunit
mm_lib.createstringconstunit:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi],	al
    mov       [rdi+16],	rbx
    mov       eax,	20
    mov       [rdi+49],	eax
    mov       al,	1
    mov       [rdi+44],	al
    cmp       rsi,	-1
    jnz       L7221
    mov       rcx,	rbx
    call      strlen
    inc       rax
    mov       [rdi+40],	eax
    jmp       L7220
L7221:
    mov       [rdi+40],	esi
L7220:
    mov       rax,	rdi
L7219:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.newtypename
mm_lib.newtypename:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	[mm_decls.ntypenames]
    cmp       rax,	38000
    jl        L7224
    lea       rcx,	[L13164]
    call      mm_support.serror
L7224:
    inc       qword [mm_decls.ntypenames]
    lea       rax,	[mm_decls.typenames]
    mov       r10,	[mm_decls.ntypenames]
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rdi
    mov       [rax+8],	r10
    lea       rax,	[mm_decls.typenames]
    mov       r10,	[mm_decls.ntypenames]
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rbx
    mov       [rax+16],	r10
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    lea       r10,	[mm_decls.typenamepos]
    mov       r11,	[mm_decls.ntypenames]
    lea       r10,	[r10 + r11*4]
    mov       [r10],	eax
    mov       rax,	[mm_decls.ntypenames]
    neg       rax
L7222:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createusertype
mm_lib.createusertype:
;?>>
   %define R.stname rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	16000
    jl        L7227
    call      msys.m$print_startcon
    mov       rcx,	[mm_decls.ntypes]
    call      msys.m$print_i64_nf
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13165]
    call      mm_support.serror
L7227:
    inc       qword [mm_decls.ntypes]
    mov       rax,	[rdi]
    lea       r10,	[mm_decls.ttname]
    mov       r11,	[mm_decls.ntypes]
    mov       [r10 + r11*8],	rax
    mov       rax,	rdi
    lea       r10,	[mm_decls.ttnamedef]
    mov       r11,	[mm_decls.ntypes]
    mov       [r10 + r11*8],	rax
    xor       eax,	eax
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	[mm_decls.ntypes]
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    lea       r10,	[mm_decls.ttlineno]
    mov       r11,	[mm_decls.ntypes]
    mov       [r10 + r11*4],	eax
    mov       eax,	[mm_decls.ntypes]
    mov       [rdi+72],	eax
    mov       rax,	[mm_decls.ntypes]
L7225:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.createusertypefromstr
mm_lib.createusertypefromstr:
;?>>
   %define R.name rbx
   %define R.stname rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mm_lex.addnamestr
    mov       rcx,	[mm_decls.stmodule]
    mov       rdx,	rax
    mov       r8,	5
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mm_lib.createusertype
L7228:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getrangelwbunit
mm_lib.getrangelwbunit:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [rdi]
    cmp       rax,	21
    jnz       L7231
    mov       rax,	[rdi+16]
    jmp       L7230
L7231:
    mov       rcx,	37
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	3
    mov       [rdi+62],	al
    mov       rax,	rdi
L7230:
L7229:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.getrangeupbunit
mm_lib.getrangeupbunit:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [rdi]
    cmp       rax,	21
    jnz       L7234
    mov       rax,	[rdi+24]
    jmp       L7233
L7234:
    mov       rcx,	37
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	4
    mov       [rdi+62],	al
    mov       rax,	rdi
L7233:
L7232:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.createarraymode
mm_lib.createarraymode:
;?>>
   %define R.owner rbx
   %define R.target rsi
   %define R.dimexpr r12
   %define R.typedefx r13
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    test      r13,	r13
    jnz       L7237
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rdi,	rax
    jmp       L7236
L7237:
    mov       rdi,	r13
L7236:
    mov       eax,	10
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       rax,	r12
    lea       r10,	[mm_decls.ttdimexpr]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    lea       rax,	[rax + r10*4]
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rbx
    lea       r10,	[mm_decls.ttowner]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7235:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.sameunit
mm_lib.sameunit:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.powner rsi
   %define R.qowner r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    cmp       rdi,	rbx
    jnz       L7240
    mov       rax,	1
    jmp       L7238
L7240:
    test      rdi,	rdi
    jz        L7243
    test      rbx,	rbx
    jnz       L7242
L7243:
    xor       eax,	eax
    jmp       L7238
L7242:
    movzx     rax,	byte [rdi]
    movzx     r10,	byte [rbx]
    cmp       rax,	r10
    jz        L7245
    xor       eax,	eax
    jmp       L7238
L7245:
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jz        L7247
    cmp       rax,	21
    jz        L7248
    cmp       rax,	27
    jz        L7248
    cmp       rax,	4
    jz        L7249
    jmp       L7250
L7247:
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    setz      al
    movzx     eax,	al
    jmp       L7238
L7248:
    mov       rax,	[rbx+16]
    mov       r10,	[rdi+16]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_lib.sameunit
    test      rax,	rax
    jz        L7251
    mov       rax,	[rbx+24]
    mov       r10,	[rdi+24]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_lib.sameunit
    test      rax,	rax
    jz        L7251
    mov       rax,	1
    jmp       L7252
L7251:
    xor       eax,	eax
L7252:
    jmp       L7238
L7249:
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L7254
    cmp       rsi,	r12
    jnz       L7254
    mov       rax,	1
    jmp       L7238
L7254:
L7250:
L7246:
    xor       eax,	eax
L7238:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createarraymodek
mm_lib.createarraymodek:
;?>>
   %define R.owner rsi
   %define R.target r12
   %define R.lower r13
   %define R.length r14
    %define mm_lib.createarraymodek.typedefx 96
   %define R.atype rdi
   %define R.m rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    mov       rdi,	10
    mov       rax,	[rbp + mm_lib.createarraymodek.typedefx]
    test      rax,	rax
    jnz       L7257
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rbx,	rax
    jmp       L7256
L7257:
    mov       rbx,	[rbp + mm_lib.createarraymodek.typedefx]
L7256:
    mov       eax,	edi
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    mov       eax,	r13d
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    mov       eax,	r14d
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    cmp       r12,	0
    jge       L7259
    lea       rcx,	[L13166]
    call      mm_support.serror
L7259:
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	r12
    mov       eax,	[rax + r10*4]
    mov       r10,	r14
    imul      r10,	rax
    lea       rax,	[mm_decls.ttsize]
    mov       r11,	rbx
    mov       [rax + r11*4],	r10d
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    lea       rax,	[rax + r10*4]
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rsi
    lea       r10,	[mm_decls.ttowner]
    mov       r11,	rbx
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    mov       rax,	rbx
L7255:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.nextautotype
mm_lib.nextautotype:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[mm_lib.nextautotype.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13167]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword [mm_lib.autotypeno]
    mov       rcx,	[mm_lib.autotypeno]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rax,	[mm_lib.nextautotype.str]
L7260:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lib.createslicemode
mm_lib.createslicemode:
;?>>
   %define R.owner rbx
   %define R.slicetype rsi
   %define R.target r12
   %define R.dimexpr r13
    %define mm_lib.createslicemode.typedefx 88
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rax,	[rbp + mm_lib.createslicemode.typedefx]
    test      rax,	rax
    jnz       L7263
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rdi,	rax
    jmp       L7262
L7263:
    mov       rdi,	[rbp + mm_lib.createslicemode.typedefx]
L7262:
    mov       eax,	esi
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    test      r13,	r13
    jz        L7265
    mov       rax,	r13
    lea       r10,	[mm_decls.ttdimexpr]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    jmp       L7264
L7265:
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
L7264:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    lea       rax,	[rax + r10*4]
    mov       rcx,	rbx
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rbx
    lea       r10,	[mm_decls.ttowner]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7261:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createslicemodek
mm_lib.createslicemodek:
;?>>
   %define R.owner rbx
   %define R.target rsi
   %define R.lower r12
   %define R.typedefx r13
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    test      r13,	r13
    jnz       L7268
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rdi,	rax
    jmp       L7267
L7268:
    mov       rdi,	r13
L7267:
    mov       eax,	11
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       eax,	r12d
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    lea       rax,	[rax + r10*4]
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rbx
    lea       r10,	[mm_decls.ttowner]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7266:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createrefmode
mm_lib.createrefmode:
;?>>
   %define R.owner rsi
   %define R.target r12
   %define R.typedefx r13
   %define R.k rdi
   %define R.m rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    test      r13,	r13
    jnz       L7271
    mov       rdi,	31
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	31
    jl        L7274
L7272:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7276
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	r12
    jnz       L7278
    mov       rax,	rdi
    jmp       L7269
L7278:
L7276:
    inc       rdi
    cmp       rdi,	[mm_decls.ntypes]
    jle       L7272
L7274:
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rbx,	rax
    jmp       L7270
L7271:
    mov       rbx,	r13
L7270:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    lea       rax,	[rax + r10*4]
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       eax,	7
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax+28]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttisref]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    mov       rax,	rbx
L7269:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createrefprocmode
mm_lib.createrefprocmode:
;?>>
    %define mm_lib.createrefprocmode.owner 48
   %define R.stproc rsi
   %define R.paramlist r12
    %define mm_lib.createrefprocmode.kwd 72
    %define mm_lib.createrefprocmode.prettype 80
    %define mm_lib.createrefprocmode.typedefx 88
   %define R.m rdi
   %define R.mproc rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rsi
    call      mm_lib.createusertype
    mov       rbx,	rax
    mov       [rsi+112],	r12
    mov       eax,	[rbp + mm_lib.createrefprocmode.prettype]
    mov       [rsi+72],	eax
    mov       eax,	24
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    mov       rax,	[rbp + mm_lib.createrefprocmode.typedefx]
    test      rax,	rax
    jnz       L7281
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rdi,	rax
    jmp       L7280
L7281:
    mov       rdi,	[rbp + mm_lib.createrefprocmode.typedefx]
L7280:
    mov       eax,	ebx
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       eax,	7
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax+28]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttisref]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7279:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.copyttvalues
mm_lib.copyttvalues:
;?>>
   %define R.dest rcx
   %define R.source rdx
;?]]
;---------------
    lea       rax,	[mm_decls.ttsigned]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttsigned]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisreal]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisshort]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisref]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisblock]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rcx
    mov       [r10 + r11],	al
;---------------
    ret       
;End 
;Proc mm_lib.getdottedname
mm_lib.getdottedname:
;?>>
   %define R.p rbx
    %define mm_lib.getdottedname.str2 -256
   %define R.owner rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rbx,	rcx
;---------------
    mov       rax,	[rbx]
    lea       rcx,	[mm_lib.getdottedname.str]
    mov       rdx,	rax
    call      strcpy
    mov       rdi,	[rbx+8]
    jmp       L7285
L7284:
    lea       rcx,	[rbp + mm_lib.getdottedname.str2]
    lea       rdx,	[mm_lib.getdottedname.str]
    call      strcpy
    mov       rax,	[rdi]
    lea       rcx,	[mm_lib.getdottedname.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[mm_lib.getdottedname.str]
    lea       rdx,	[L13168]
    call      strcat
    lea       rcx,	[mm_lib.getdottedname.str]
    lea       rdx,	[rbp + mm_lib.getdottedname.str2]
    call      strcat
    mov       rdi,	[rdi+8]
L7285:
    test      rdi,	rdi
    jz        L7287
    movzx     rax,	byte [rdi+78]
    cmp       rax,	1
    jnz       L7284
L7287:
    lea       rax,	[mm_lib.getdottedname.str]
L7283:
;---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getavname
mm_lib.getavname:
;?>>
   %define R.owner rsi
   %define R.id r12
   %define R.p rdi
    %define mm_lib.getavname.str -32
   %define R.name rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    cmp       r12,	11
    jnz       L7290
    movzx     rax,	byte [rsi+78]
    cmp       rax,	6
    jz        L7290
    lea       rcx,	[L13169]
    call      mm_support.serror
L7290:
    cmp       r12,	11
    jnz       L7292
    lea       rcx,	[rbp + mm_lib.getavname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13170]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword [mm_lib.nextavindex]
    mov       rcx,	[mm_lib.nextavindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L7291
L7292:
    lea       rcx,	[rbp + mm_lib.getavname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13171]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword [mm_lib.nextsvindex]
    mov       rcx,	[mm_lib.nextsvindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L7291:
    lea       rcx,	[rbp + mm_lib.getavname.str]
    call      mlib.pcm_copyheapstring
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mm_lex.addnamestr
    mov       rcx,	rbx
    call      mm_lex.addnamestr
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	r12
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       ax,	1
    mov       [rdi+168],	ax
    mov       eax,	3
    mov       [rdi+72],	eax
    mov       rcx,	rsi
    mov       rdx,	rdi
    call      mm_lib.adddef
    mov       rax,	rdi
L7288:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.unionstr_clear
mm_lib.unionstr_clear:
;?>>
   %define R.u rcx
;?]]
;---------------
    xor       eax,	eax
    mov       [rcx],	rax
;---------------
    ret       
;End 
;Proc mm_lib.unionstr_append
mm_lib.unionstr_append:
;?>>
   %define R.u rdi
   %define R.c rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rdi+7]
    cmp       rax,	6
    jnz       L7296
    lea       rcx,	[L13172]
    call      mm_support.serror
L7296:
    lea       rax,	[rdi+7]
    inc       byte [rax]
    movzx     rax,	byte [rdi+7]
    mov       r10b,	bl
    mov       [rdi + rax-1],	r10b
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.unionstr_concat
mm_lib.unionstr_concat:
;?>>
   %define R.u r12
   %define R.v r13
   %define R.ulen rdi
   %define R.vlen rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    movzx     rax,	byte [r12+7]
    mov       rdi,	rax
    movzx     rax,	byte [r13+7]
    mov       rbx,	rax
    mov       rax,	rdi
    add       rax,	rbx
    cmp       rax,	7
    jle       L7299
    lea       rcx,	[L13173]
    call      mm_support.serror
L7299:
    mov       rsi,	1
    cmp       rbx,	1
    jl        L7302
L7300:
    mov       al,	[r13 + rsi-1]
    mov       r10,	rsi
    add       r10,	rdi
    mov       [r12 + r10-1],	al
    inc       rsi
    cmp       rsi,	rbx
    jle       L7300
L7302:
    mov       rax,	rdi
    add       rax,	rbx
    mov       [r12+7],	al
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.unionstr_last
mm_lib.unionstr_last:
;?>>
   %define R.u rcx
;?]]
;---------------
    mov       al,	[rcx+7]
    test      al,	al
    jz        L7305
    movzx     rax,	byte [rcx+7]
    movzx     r10,	byte [rcx + rax-1]
    mov       rax,	r10
    jmp       L7303
L7305:
    xor       eax,	eax
L7303:
;---------------
    ret       
;End 
;Proc mm_lib.unionstr_copy
mm_lib.unionstr_copy:
;?>>
   %define R.u rdi
   %define R.v rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	8
    call      memcpy
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createrecordmode
mm_lib.createrecordmode:
;?>>
   %define R.owner rbx
   %define R.typedefx rsi
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rsi,	rsi
    jnz       L7309
    mov       rcx,	rbx
    call      mm_lib.createusertype
    mov       rdi,	rax
    jmp       L7308
L7309:
    mov       rdi,	rsi
L7308:
    mov       eax,	8
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttusercat]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7307:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createtuplemode
mm_lib.createtuplemode:
;?>>
   %define R.owner rsi
   %define R.elements r12
   %define R.elementslen r13
   %define R.typedefx r14
   %define R.m rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    test      r14,	r14
    jnz       L7312
    mov       rcx,	rsi
    call      mm_lib.createusertype
    mov       rdi,	rax
    jmp       L7311
L7312:
    mov       rdi,	r14
L7311:
    mov       eax,	28
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttusercat]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       eax,	r13d
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       rax,	r13
    shl       rax,	2
    mov       rcx,	rax
    call      mlib.pcm_alloc
    lea       r10,	[mm_decls.ttmult]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       rbx,	1
    cmp       r13,	1
    jl        L7315
L7313:
    lea       rax,	[mm_decls.ttmult]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       r10,	rbx
    lea       rax,	[rax + r10*4-4]
    mov       r10,	[r12 + rbx*8-8]
    mov       rcx,	rsi
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    inc       rbx
    cmp       rbx,	r13
    jle       L7313
L7315:
    mov       rax,	rdi
L7310:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.strexpr
mm_lib.strexpr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mm_lib.exprstr]
    call      mlib.gs_init
    mov       rcx,	[mm_lib.exprstr]
    mov       rdx,	rdi
    call      mm_lib.jevalx2
    mov       rax,	[mm_lib.exprstr]
L7316:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.jevalx2
mm_lib.jevalx2:
;?>>
   %define R.dest rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       [mm_lib.jdest],	rdi
    mov       rcx,	rbx
    call      mm_lib.jevalx
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.jevalx
mm_lib.jevalx:
;?>>
   %define R.p r12
   %define R.q rdi
   %define R.a rbx
   %define R.b rsi
    %define mm_lib.jevalx.str -504
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	544
    mov       r12,	rcx
;---------------
    test      r12,	r12
    jnz       L7320
    jmp       L7318
L7320:
    mov       rbx,	[r12+16]
    mov       rsi,	[r12+24]
    movzx     rax,	byte [r12]
    cmp       rax,	1
    jz        L7322
    cmp       rax,	4
    jz        L7323
    cmp       rax,	35
    jz        L7324
    cmp       rax,	33
    jz        L7324
    cmp       rax,	36
    jz        L7325
    cmp       rax,	18
    jz        L7325
    cmp       rax,	17
    jz        L7325
    cmp       rax,	37
    jz        L7326
    cmp       rax,	32
    jz        L7327
    cmp       rax,	46
    jz        L7328
    cmp       rax,	51
    jz        L7328
    cmp       rax,	48
    jz        L7328
    cmp       rax,	52
    jz        L7328
    cmp       rax,	49
    jz        L7329
    cmp       rax,	20
    jz        L7330
    cmp       rax,	21
    jz        L7331
    cmp       rax,	28
    jz        L7332
    cmp       rax,	92
    jz        L7333
    cmp       rax,	62
    jz        L7334
    cmp       rax,	58
    jz        L7335
    cmp       rax,	61
    jz        L7335
    cmp       rax,	59
    jz        L7336
    cmp       rax,	60
    jz        L7337
    cmp       rax,	27
    jz        L7338
    cmp       rax,	53
    jz        L7339
    cmp       rax,	6
    jz        L7340
    cmp       rax,	2
    jz        L7341
    cmp       rax,	55
    jz        L7342
    cmp       rax,	56
    jz        L7343
    cmp       rax,	67
    jz        L7344
    cmp       rax,	74
    jz        L7345
    cmp       rax,	73
    jz        L7345
    cmp       rax,	68
    jz        L7346
    cmp       rax,	86
    jz        L7347
    cmp       rax,	90
    jz        L7348
    cmp       rax,	40
    jz        L7349
    cmp       rax,	13
    jz        L7350
    jmp       L7351
L7322:
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	16
    jz        L7353
    cmp       r10,	3
    jz        L7353
    cmp       r10,	14
    jz        L7353
    cmp       r10,	15
    jz        L7353
    cmp       r10,	19
    jz        L7354
    cmp       r10,	4
    jz        L7354
    cmp       r10,	17
    jz        L7354
    cmp       r10,	18
    jz        L7354
    cmp       r10,	12
    jz        L7355
    cmp       r10,	5
    jz        L7355
    cmp       r10,	1
    jz        L7356
    cmp       r10,	2
    jz        L7356
    cmp       r10,	7
    jz        L7357
    jmp       L7358
L7353:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_lib.jevalx.str]
    call      msys.getstrint
    jmp       L7352
L7354:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strword
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L7352
L7355:
    mov       rax,	[r12+16]
    mov       [rbp + mm_lib.jevalx.str],	al
    xor       eax,	eax
    mov       [rbp + mm_lib.jevalx.str-1],	al
    jmp       L7352
L7356:
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      msys.m$print_startstr
    movq      XMM4,	[r12+16]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L7352
L7357:
    movsxd    rax,	dword [r12+49]
    cmp       rax,	20
    jnz       L7360
    mov       al,	[r12+44]
    test      al,	al
    jz        L7360
    mov       eax,	[r12+40]
    cmp       rax,	250
    jle       L7362
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    lea       rdx,	[L13174]
    call      strcpy
    jmp       L7361
L7362:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_lib.jevalx.str]
    call      pc_api.convertstring
L7361:
    lea       rcx,	[L13175]
    call      mm_lib.jadditem
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    lea       rcx,	[L13175]
    call      mm_lib.jadditem
    jmp       L7318
L7360:
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      msys.m$print_startstr
    mov       rcx,	[r12+16]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L7359:
    jmp       L7352
L7358:
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    lea       rdx,	[L13176]
    call      strcpy
L7352:
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    jmp       L7321
L7323:
    mov       rax,	[r12+16]
    mov       rcx,	[rax]
    call      mm_lib.jadditem
    jmp       L7321
L7324:
    movzx     rax,	byte [r12+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    mov       rdx,	r10
    call      strcpy
    lea       rcx,	[L13177]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    lea       rcx,	[L13178]
    call      mm_lib.jadditem
    jmp       L7321
L7325:
    movzx     rax,	byte [r12+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    mov       rdx,	r10
    call      strcpy
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    lea       rcx,	[L13179]
    call      mm_lib.jadditem
    movzx     rax,	byte [rbx]
    cmp       rax,	62
    jnz       L7364
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mm_lib.jadditem
    jmp       L7363
L7364:
    mov       rcx,	rbx
    call      mm_lib.jevalx
L7363:
    lea       rcx,	[L13180]
    call      mm_lib.jadditem
    jmp       L7321
L7326:
    movzx     rax,	byte [r12+62]
    lea       r10,	[mm_tables.propnames]
    mov       r10,	[r10 + rax*8-8]
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    mov       rdx,	r10
    call      strcpy
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    lea       rcx,	[L13181]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13182]
    call      mm_lib.jadditem
    jmp       L7321
L7327:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13183]
    call      mm_lib.jadditem
    mov       rdi,	rsi
    jmp       L7366
L7365:
    mov       rcx,	rdi
    call      mm_lib.jevalx
    mov       rdi,	[rdi+8]
    test      rdi,	rdi
    jz        L7369
    lea       rcx,	[L13184]
    call      mm_lib.jadditem
L7369:
L7366:
    test      rdi,	rdi
    jnz       L7365
    lea       rcx,	[L13185]
    call      mm_lib.jadditem
    jmp       L7321
L7328:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    movzx     rax,	byte [r12]
    cmp       rax,	51
    jz        L7372
    movzx     rax,	byte [r12]
    cmp       rax,	52
    jnz       L7371
L7372:
    lea       rcx,	[L13186]
    call      mm_lib.jadditem
L7371:
    lea       rcx,	[L13187]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    lea       rcx,	[L13188]
    call      mm_lib.jadditem
    jmp       L7321
L7329:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13189]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    jmp       L7321
L7330:
    lea       rcx,	[L13190]
    call      mm_lib.jadditem
    mov       rdi,	rbx
    jmp       L7374
L7373:
    mov       rcx,	rdi
    call      mm_lib.jevalx
    mov       rdi,	[rdi+8]
    test      rdi,	rdi
    jz        L7377
    lea       rcx,	[L13191]
    call      mm_lib.jadditem
L7377:
L7374:
    test      rdi,	rdi
    jnz       L7373
    lea       rcx,	[L13192]
    call      mm_lib.jadditem
    jmp       L7321
L7331:
    lea       rcx,	[L13193]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13194]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    lea       rcx,	[L13195]
    call      mm_lib.jadditem
    jmp       L7321
L7332:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13196]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    jmp       L7321
L7333:
    lea       rcx,	[L13197]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13198]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    lea       rcx,	[L13198]
    call      mm_lib.jadditem
    mov       rcx,	[r12+32]
    call      mm_lib.jevalx
    lea       rcx,	[L13199]
    call      mm_lib.jadditem
    jmp       L7321
L7334:
    movsxd    rax,	dword [r12+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mm_lib.jadditem
    jmp       L7321
L7335:
    movsxd    rax,	dword [r12+53]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mm_lib.jadditem
    movzx     rax,	byte [r12]
    cmp       rax,	61
    jnz       L7379
    lea       rcx,	[L13200]
    call      mm_lib.jadditem
L7379:
    lea       rcx,	[L13201]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13202]
    call      mm_lib.jadditem
    jmp       L7321
L7336:
    lea       rcx,	[L13203]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13204]
    call      mm_lib.jadditem
    jmp       L7321
L7337:
    lea       rcx,	[L13205]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13206]
    call      mm_lib.jadditem
    jmp       L7321
L7338:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13207]
    call      mm_lib.jadditem
    test      rsi,	rsi
    jz        L7381
    mov       rcx,	[r12+24]
    call      mm_lib.jevalx
    jmp       L7380
L7381:
    lea       rcx,	[L13208]
    call      mm_lib.jaddstr
L7380:
    jmp       L7321
L7339:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13209]
    call      mm_lib.jadditem
    jmp       L7321
L7340:
    lea       rcx,	[L13210]
    call      mm_lib.jadditem
    jmp       L7321
L7341:
    lea       rcx,	[L13211]
    call      mm_lib.jaddstr
    jmp       L7321
L7342:
    lea       rcx,	[L13212]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    test      rsi,	rsi
    jz        L7383
    lea       rcx,	[L13213]
    call      mm_lib.jaddstr
    mov       rax,	[rsi+16]
    mov       rcx,	[mm_lib.jdest]
    mov       rdx,	rax
    call      mlib.gs_strint
L7383:
    jmp       L7321
L7343:
    lea       rcx,	[L13214]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    jmp       L7321
L7344:
    lea       rcx,	[L13215]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13216]
    call      mm_lib.jadditem
    jmp       L7321
L7345:
    lea       rcx,	[L13217]
    call      mm_lib.jaddstr
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       r10,	[r10+1]
    mov       rcx,	r10
    call      mm_lib.jaddstr
    jmp       L7321
L7346:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13218]
    call      mm_lib.jaddstr
    movsx     rax,	word [r12+40]
    lea       r10,	[mm_tables.bitfieldnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      mm_lib.jaddstr
    jmp       L7321
L7347:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13219]
    call      mm_lib.jaddstr
    mov       rcx,	rsi
    call      mm_lib.jevalx
    jmp       L7321
L7348:
    movsx     rax,	word [r12+40]
    lea       r10,	[mm_tables.sysfnnames]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+3]
    mov       rcx,	r10
    call      mm_lib.jaddstr
    lea       rcx,	[L13220]
    call      mm_lib.jaddstr
    test      rbx,	rbx
    jz        L7385
    mov       rcx,	rbx
    call      mm_lib.jevalx
L7385:
    lea       rcx,	[L13221]
    call      mm_lib.jaddstr
    jmp       L7321
L7349:
    lea       rcx,	[L13222]
    call      mm_lib.jaddstr
    mov       rcx,	rbx
    call      mm_lib.jevalx
    jmp       L7321
L7350:
    lea       rcx,	[L13223]
    call      mm_lib.jaddstr
    mov       rcx,	rbx
    call      mm_lib.jevalx
    jmp       L7321
L7351:
    call      msys.m$print_startcon
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13224]
    mov       rdx,	r12
    call      mm_support.gerror
L7321:
L7318:
;---------------
    add       rsp,	544
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.jadditem
mm_lib.jadditem:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mm_lib.jdest]
    mov       rdx,	rdi
    call      mm_support.gs_additem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.jaddstr
mm_lib.jaddstr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mm_lib.jdest]
    mov       rdx,	rdi
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.strmode
mm_lib.strmode:
;?>>
   %define R.m rdi
   %define R.expand rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[mm_lib.strmode.str]
    call      mm_lib.istrmode
    lea       rax,	[mm_lib.strmode.str]
L7388:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.strmode2
mm_lib.strmode2:
;?>>
   %define R.m rdi
   %define R.expand rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[mm_lib.strmode2.str]
    call      mm_lib.istrmode
    lea       rax,	[mm_lib.strmode2.str]
L7389:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.istrmode
mm_lib.istrmode:
;?>>
   %define R.m r14
    %define mm_lib.istrmode.expand 72
    %define mm_lib.istrmode.dest 80
   %define R.d rdi
   %define R.q rbx
   %define R.needcomma rsi
   %define R.i r12
   %define R.target r13
    %define mm_lib.istrmode.mbase -8
    %define mm_lib.istrmode.n -16
    %define mm_lib.istrmode.sxx -32
    %define mm_lib.istrmode.xx -40
    %define mm_lib.istrmode.strdim -144
    %define mm_lib.istrmode.prefix -152
    %define mm_lib.istrmode.tn -184
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	224
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    lea       rax,	[rbp + mm_lib.istrmode.sxx]
    mov       [rbp + mm_lib.istrmode.xx],	rax
    cmp       r14,	0
    jge       L7392
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13225]
    call      strcpy
    mov       rax,	r14
    neg       rax
    lea       r10,	[mm_decls.typenames]
    mov       r11,	rax
    shl       r11,	5
    lea       r10,	[r10 + r11]
    lea       rax,	[rbp + mm_lib.istrmode.tn]
    mov       r11,	[r10]
    mov       [rax],	r11
    mov       r11,	[r10+8]
    mov       [rax+8],	r11
    mov       r11,	[r10+16]
    mov       [rax+16],	r11
    mov       r11,	[r10+24]
    mov       [rax+24],	r11
    mov       rax,	[rbp + mm_lib.istrmode.tn+8]
    test      rax,	rax
    jz        L7394
    mov       rax,	[rbp + mm_lib.istrmode.tn+8]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13226]
    call      strcat
L7394:
    mov       rax,	[rbp + mm_lib.istrmode.tn+16]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    jmp       L7390
L7392:
    cmp       r14,	31
    jge       L7396
    cmp       r14,	7
    jz        L7396
    mov       rcx,	r14
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L7390
L7396:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_lib.istrmode.mbase],	rax
    cmp       rax,	7
    jz        L7398
    cmp       rax,	10
    jz        L7399
    cmp       rax,	11
    jz        L7400
    cmp       rax,	8
    jz        L7401
    test      rax,	rax
    jz        L7402
    cmp       rax,	31
    jz        L7403
    cmp       rax,	24
    jz        L7404
    cmp       rax,	28
    jz        L7405
    cmp       rax,	27
    jz        L7406
    jmp       L7407
L7398:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13227]
    call      strcpy
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       r13,	rax
    cmp       r13,	0
    jl        L7409
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jnz       L7409
    mov       rcx,	r13
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    jmp       L7408
L7409:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.tttarget]
    mov       r11,	r14
    movsxd    rax,	dword [rax + r11*4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
L7408:
    jmp       L7397
L7399:
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L7411
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_lib.istrmode.strdim]
    call      mm_support.gs_copytostr
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13228]
    call      msys.m$print_setfmt
    lea       rcx,	[rbp + mm_lib.istrmode.strdim]
    call      msys.m$print_str_nf
    mov       rcx,	r14
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L7410
L7411:
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r14
    mov       eax,	[rax + r10*4]
    test      eax,	eax
    jz        L7413
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	1
    jnz       L7415
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13229]
    call      msys.m$print_setfmt
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	r14
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L7414
L7415:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13230]
    call      msys.m$print_setfmt
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	r14
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L7414:
    jmp       L7412
L7413:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	1
    jnz       L7417
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13231]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L7416
L7417:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13232]
    call      msys.m$print_setfmt
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L7416:
L7412:
L7410:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.tttarget]
    mov       r11,	r14
    movsxd    rax,	dword [rax + r11*4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    jmp       L7397
L7400:
    lea       rax,	[mm_tables.stdnames]
    mov       r10,	[rbp + mm_lib.istrmode.mbase]
    mov       rax,	[rax + r10*8]
    mov       [rbp + mm_lib.istrmode.prefix],	rax
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L7419
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_lib.istrmode.strdim]
    call      mm_support.gs_copytostr
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13233]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mm_lib.istrmode.prefix]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mm_lib.istrmode.strdim]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L7418
L7419:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	1
    jnz       L7421
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	[rbp + mm_lib.istrmode.prefix]
    call      strcpy
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13234]
    call      strcat
    jmp       L7420
L7421:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13235]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mm_lib.istrmode.prefix]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L7420:
L7418:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.tttarget]
    mov       r11,	r14
    movsxd    rax,	dword [rax + r11*4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    jmp       L7397
L7401:
    mov       rax,	[rbp + mm_lib.istrmode.expand]
    test      rax,	rax
    jnz       L7423
    mov       rcx,	r14
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L7390
L7423:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13236]
    call      strcpy
    mov       rax,	[rbp + mm_lib.istrmode.expand]
    cmp       rax,	2
    jz        L7425
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
L7425:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13237]
    call      strcat
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r14
    mov       rdi,	[rax + r10*8]
    xor       rsi,	rsi
    mov       rax,	[rdi+16]
    mov       rbx,	rax
    jmp       L7429
L7426:
    test      rsi,	rsi
    jz        L7431
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13238]
    call      strcat
L7431:
    mov       rsi,	1
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword [rbx+72]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13239]
    call      strcat
    mov       rax,	[rbx]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    mov       rbx,	[rbx+32]
L7429:
    test      rbx,	rbx
    jnz       L7426
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13240]
    call      strcat
    jmp       L7397
L7402:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13241]
    call      strcpy
    jmp       L7397
L7403:
    mov       rcx,	r14
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L7397
L7404:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r14
    mov       rdi,	[rax + r10*8]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13242]
    call      strcpy
    mov       rbx,	[rdi+112]
    xor       rsi,	rsi
    jmp       L7433
L7432:
    test      rsi,	rsi
    jz        L7436
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13243]
    call      strcat
L7436:
    mov       rsi,	1
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword [rbx+72]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13244]
    call      strcat
    mov       rax,	[rbx]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    mov       rbx,	[rbx+32]
L7433:
    test      rbx,	rbx
    jnz       L7432
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13245]
    call      strcat
    movsxd    rax,	dword [rdi+72]
    test      rax,	rax
    jz        L7438
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
L7438:
    jmp       L7397
L7405:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13246]
    call      strcpy
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_lib.istrmode.n],	rax
    mov       r12,	1
    mov       rax,	[rbp + mm_lib.istrmode.n]
    cmp       rax,	1
    jl        L7441
L7439:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.ttmult]
    mov       r11,	r14
    mov       rax,	[rax + r11*8]
    mov       r11,	r12
    movsxd    rax,	dword [rax + r11*4-4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    cmp       r12,	[rbp + mm_lib.istrmode.n]
    jge       L7443
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13247]
    call      strcat
L7443:
    inc       r12
    cmp       r12,	[rbp + mm_lib.istrmode.n]
    jle       L7439
L7441:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13248]
    call      strcat
    jmp       L7397
L7406:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13249]
    call      strcpy
    jmp       L7397
L7407:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	31
    jge       L7445
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13250]
    call      strcpy
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.tttarget]
    mov       r11,	r14
    movsxd    rax,	dword [rax + r11*4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    jmp       L7444
L7445:
    call      msys.m$print_startcon
    mov       rcx,	r14
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13251]
    call      mm_support.mcerror
L7444:
L7397:
L7390:
;---------------
    add       rsp,	224
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addtoproclist
mm_lib.addtoproclist:
;?>>
   %define R.d rbx
   %define R.pp rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[mm_decls.proclist]
    test      rax,	rax
    jnz       L7448
    mov       rax,	rdi
    mov       [mm_decls.proclistx],	rax
    mov       [mm_decls.proclist],	rax
    jmp       L7447
L7448:
    mov       rax,	rdi
    mov       r10,	[mm_decls.proclistx]
    mov       [r10+8],	rax
    mov       [mm_decls.proclistx],	rdi
L7447:
    mov       [rdi],	rbx
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addstatic
mm_lib.addstatic:
;?>>
   %define R.d rbx
   %define R.pp rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[mm_decls.staticlist]
    test      rax,	rax
    jnz       L7451
    mov       rax,	rdi
    mov       [mm_decls.staticlistx],	rax
    mov       [mm_decls.staticlist],	rax
    jmp       L7450
L7451:
    mov       rax,	rdi
    mov       r10,	[mm_decls.staticlistx]
    mov       [r10+8],	rax
    mov       [mm_decls.staticlistx],	rdi
L7450:
    mov       [rdi],	rbx
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addexpconst
mm_lib.addexpconst:
;?>>
   %define R.d rbx
   %define R.pp rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[mm_decls.constlist]
    test      rax,	rax
    jnz       L7454
    mov       rax,	rdi
    mov       [mm_decls.constlistx],	rax
    mov       [mm_decls.constlist],	rax
    jmp       L7453
L7454:
    mov       rax,	rdi
    mov       r10,	[mm_decls.constlistx]
    mov       [r10+8],	rax
    mov       [mm_decls.constlistx],	rdi
L7453:
    mov       [rdi],	rbx
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.typename
mm_lib.typename:
;?>>
   %define R.m rcx
;?]]
;---------------
    cmp       rcx,	0
    jl        L7457
    lea       rax,	[mm_decls.ttname]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8]
    jmp       L7455
L7457:
    mov       rax,	rcx
    neg       rax
    lea       r10,	[mm_decls.typenames]
    mov       r11,	rax
    shl       r11,	5
    lea       r10,	[r10 + r11]
    mov       r10,	[r10+16]
    mov       r10,	[r10]
    mov       rax,	r10
L7455:
;---------------
    ret       
;End 
;Proc mm_lib.allocunitrec
mm_lib.allocunitrec:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    inc       qword [mm_decls.nunits]
    mov       rax,	65
    add       [mm_decls.nunitsmem],	rax
    mov       rax,	[mm_lib.remainingunits]
    dec       qword [mm_lib.remainingunits]
    test      rax,	rax
    jz        L7460
    mov       rdi,	[mm_lib.unitheapptr]
    add       qword [mm_lib.unitheapptr],	65
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rdi+4],	eax
    mov       al,	[mm_decls.currmoduleno]
    mov       [rdi+57],	al
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[mm_decls.currmoduleno]
    mov       al,	[rax + r10]
    mov       [rdi+58],	al
    mov       rax,	rdi
    jmp       L7458
L7460:
    mov       rcx,	2129920
    call      mlib.pcm_alloc
    mov       [mm_lib.unitheapptr],	rax
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	2129920
    call      memset
    mov       rax,	32767
    mov       [mm_lib.remainingunits],	rax
    add       qword [mm_lib.unitheapptr],	65
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rdi+4],	eax
    mov       al,	[mm_decls.currmoduleno]
    mov       [rdi+57],	al
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[mm_decls.currmoduleno]
    mov       al,	[rax + r10]
    mov       [rdi+58],	al
    mov       rax,	rdi
L7458:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.createdupldef
mm_lib.createdupldef:
;?>>
   %define R.owner rbx
   %define R.symptr rsi
   %define R.id r12
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      mm_lib.newstrec
    mov       rdi,	rax
    mov       rax,	[rsi]
    mov       [rdi],	rax
    mov       al,	[rsi+76]
    mov       [rdi+76],	al
    mov       al,	67
    mov       [rdi+77],	al
    mov       [rdi+8],	rbx
    mov       [rdi+78],	r12b
    mov       rax,	[rsi+40]
    mov       [rdi+40],	rax
    mov       [rsi+40],	rdi
    test      rbx,	rbx
    jz        L7463
    mov       rax,	[rbx+16]
    test      rax,	rax
    jnz       L7465
    mov       rax,	rdi
    mov       [rbx+24],	rax
    mov       [rbx+16],	rax
    jmp       L7464
L7465:
    mov       rax,	[rbx+24]
    mov       r10,	rdi
    mov       [rax+32],	r10
    mov       [rbx+24],	rdi
L7464:
L7463:
    mov       rax,	rdi
L7461:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createnewmoduledef
mm_lib.createnewmoduledef:
;?>>
   %define R.owner rdi
   %define R.symptr rbx
   %define R.id rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createdupldef
L7466:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.duplunit
mm_lib.duplunit:
;?>>
   %define R.p r12
    %define mm_lib.duplunit.lineno 56
   %define R.q rdi
   %define R.av_1 rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    test      r12,	r12
    jnz       L7469
    xor       eax,	eax
    jmp       L7467
L7469:
    movzx     rax,	byte [r12]
    mov       rcx,	rax
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       rax,	r12
    push      rdi
    mov       r11,	8
L13252:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L13252
    mov       r10b,	[rax]
    mov       [rdi],	r10b
    pop       rdi
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rsi,	1
    movzx     rax,	byte [rdi]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       rbx,	r10
    cmp       rbx,	1
    jl        L7472
L7470:
    lea       rax,	[rdi+16]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_lib.duplunit
    lea       r10,	[rdi+16]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    inc       rsi
    cmp       rsi,	rbx
    jle       L7470
L7472:
    mov       rax,	rdi
L7467:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.isconstunit
mm_lib.isconstunit:
;?>>
   %define R.a rcx
;?]]
;---------------
    movzx     rax,	byte [rcx+60]
L7473:
;---------------
    ret       
;End 
;Proc mm_lib.getownername
mm_lib.getownername:
;?>>
   %define R.d rbx
   %define R.dest rsi
   %define R.owner rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	[rbx+8]
    test      rdi,	rdi
    jz        L7477
    movzx     rax,	byte [rdi+78]
    cmp       rax,	1
    jnz       L7476
L7477:
    jmp       L7474
L7476:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_lib.getownername
    mov       rax,	[rdi]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      strcat
    mov       rcx,	rsi
    lea       rdx,	[L13253]
    call      strcat
L7474:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getalignment
mm_lib.getalignment:
;?>>
   %define R.m rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L7480
    cmp       rax,	8
    jz        L7481
    jmp       L7482
L7480:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      mm_lib.getalignment
    jmp       L7478
L7481:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    movsx     rax,	word [rax+166]
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L7484
    mov       rdi,	8
L7484:
    mov       rax,	rdi
    jmp       L7478
L7482:
    lea       rax,	[mm_decls.ttisblock]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7486
    mov       rax,	8
    jmp       L7478
L7486:
L7479:
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	1
    jz        L7488
    cmp       rax,	2
    jz        L7488
    cmp       rax,	4
    jz        L7488
    cmp       rax,	8
    jz        L7488
    test      rax,	rax
    jz        L7489
    jmp       L7490
L7488:
    mov       rax,	rdi
    jmp       L7478
L7489:
    mov       rax,	8
    jmp       L7478
L7490:
L7487:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13254]
    xor       edx,	edx
    call      mm_support.gerror
    xor       eax,	eax
L7478:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addlistunit
mm_lib.addlistunit:
;?>>
   %define R.ulist rcx
   %define R.ulistx rdx
   %define R.p r8
;?]]
;---------------
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L7493
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L7492
L7493:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+8],	r10
L7492:
    mov       [rdx],	r8
;---------------
    ret       
;End 
;Proc mm_lib.storemode
mm_lib.storemode:
;?>>
   %define R.owner rbx
   %define R.m rsi
   %define R.pmode r12
   %define R.r rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    cmp       rsi,	0
    jl        L7496
    mov       [r12],	esi
    mov       rax,	rsi
    jmp       L7494
L7496:
    mov       rax,	rsi
    neg       rax
    lea       r10,	[mm_decls.typenames]
    mov       r11,	rax
    shl       r11,	5
    lea       r10,	[r10 + r11]
    mov       rdi,	r10
    mov       rax,	[rdi+24]
    test      rax,	rax
    jnz       L7498
    mov       [rdi],	rbx
    mov       [r12],	esi
    mov       [rdi+24],	r12
    mov       rax,	[rdi+24]
    test      rax,	rax
    jnz       L7500
    lea       rcx,	[L13255]
    call      mm_support.serror
L7500:
    mov       rax,	rsi
    jmp       L7494
L7498:
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.newtypename
    mov       rsi,	rax
    mov       rax,	rsi
    neg       rax
    lea       r10,	[mm_decls.typenames]
    mov       r11,	rax
    shl       r11,	5
    lea       r10,	[r10 + r11]
    mov       rdi,	r10
    mov       [rdi],	rbx
    mov       [r12],	esi
    mov       [rdi+24],	r12
    mov       rax,	rsi
L7494:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.gettypebase
mm_lib.gettypebase:
;?>>
   %define R.m rcx
;?]]
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rcx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	14
    jz        L7503
    cmp       rax,	15
    jz        L7503
    cmp       rax,	16
    jz        L7503
    cmp       rax,	17
    jz        L7504
    cmp       rax,	18
    jz        L7504
    cmp       rax,	19
    jz        L7504
    cmp       rax,	2
    jz        L7505
    cmp       rax,	12
    jz        L7506
    jmp       L7507
L7503:
    mov       rax,	3
    jmp       L7502
L7504:
    mov       rax,	3
    jmp       L7502
L7505:
    mov       rax,	1
    jmp       L7502
L7506:
    mov       rax,	5
    jmp       L7502
L7507:
    mov       rax,	rcx
L7502:
L7501:
;---------------
    ret       
;End 
;Proc mm_lib.writegsfile
mm_lib.writegsfile:
;?>>
   %define R.filename rbx
   %define R.d rsi
   %define R.f rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    lea       rdx,	[L13256]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    call      mlib.gs_println
    mov       rcx,	rdi
    call      fclose
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addtolog
mm_lib.addtolog:
;?>>
   %define R.filename rsi
   %define R.logdest r12
   %define R.f rdi
   %define R.c rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	rsi
    lea       rdx,	[L13257]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L7511
    call      msys.m$print_startcon
    lea       rcx,	[L13258]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L7509
L7511:
L7512:
    mov       rcx,	rdi
    call      fgetc
    movsxd    r10,	eax
    mov       rbx,	r10
    cmp       rbx,	-1
    jz        L7513
L7515:
    mov       rcx,	rbx
    mov       rdx,	r12
    call      fputc
    jmp       L7512
L7513:
    mov       rcx,	rdi
    call      fclose
L7509:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getprocretmodes
mm_lib.getprocretmodes:
;?>>
   %define R.p rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	32
    jz        L7518
    lea       rcx,	[L13259]
    xor       edx,	edx
    call      mm_support.txerror
L7518:
    mov       rdi,	[rbx+16]
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jnz       L7521
L7520:
    mov       rax,	[rdi+16]
    jmp       L7519
L7521:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttnamedef]
    mov       rax,	[rax + r10*8]
L7519:
L7516:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getpclmode
mm_lib.getpclmode:
;?>>
   %define R.t rcx
   %define R.u rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rcx
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_tables.stdpcl]
    movzx     r10,	byte [r10 + rax]
    mov       rdi,	r10
    cmp       rdi,	11
    jnz       L7524
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rcx
    mov       eax,	[rax + r10*4]
    cmp       rax,	8
    jz        L7526
    cmp       rax,	4
    jz        L7527
    cmp       rax,	2
    jz        L7528
    cmp       rax,	1
    jz        L7529
    jmp       L7530
L7526:
    mov       rdi,	6
    jmp       L7525
L7527:
    mov       rdi,	5
    jmp       L7525
L7528:
    mov       rdi,	4
    jmp       L7525
L7529:
    mov       rdi,	3
L7530:
L7525:
L7524:
    mov       rax,	rdi
L7522:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_libsources.loadbuiltins
mm_libsources.loadbuiltins:
;?>>
   %define R.pf rdi
   %define R.filename rbx
   %define R.av_1 rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    mov       r12,	1
    mov       rsi,	13
    cmp       rsi,	1
    jl        L7534
L7532:
    lea       rax,	[mm_libsources.syslibnames]
    mov       r10,	r12
    mov       rbx,	[rax + r10*8-8]
    call      mm_support.newsourcefile
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    lea       r10,	[mm_decls.sources]
    mov       r11,	[mm_decls.nsourcefiles]
    mov       r10,	[r10 + r11*8]
    mov       [r10],	rax
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    mov       r10,	rbx
    mov       [rax+8],	r10
    lea       rax,	[mm_libsources.syslibtext]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[mm_decls.sources]
    mov       r11,	[mm_decls.nsourcefiles]
    mov       r10,	[r10 + r11*8]
    mov       [r10+32],	rax
    lea       rax,	[mm_libsources.syslibtext]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    lea       r10,	[mm_decls.sources]
    mov       r11,	[mm_decls.nsourcefiles]
    mov       r10,	[r10 + r11*8]
    mov       [r10+32],	rax
    lea       rax,	[mm_libsources.syslibtext]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      strlen
    lea       r10,	[mm_decls.sources]
    mov       r11,	[mm_decls.nsourcefiles]
    mov       r10,	[r10 + r11*8]
    mov       [r10+48],	rax
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    lea       r10,	[L13260]
    mov       [rax+16],	r10
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    mov       r10,	rbx
    mov       [rax+24],	r10
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    mov       r10b,	1
    mov       [rax+56],	r10b
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    xor       r10d,	r10d
    mov       [rax+57],	r10b
    inc       r12
    cmp       r12,	rsi
    jle       L7532
L7534:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadsp
mm_modules.loadsp:
;?>>
    %define mm_modules.loadsp.filename 64
    %define mm_modules.loadsp.mainsub 72
   %define R.sp rdi
    %define mm_modules.loadsp.modnames -2000
    %define mm_modules.loadsp.aliases -4000
    %define mm_modules.loadsp.paths -6000
    %define mm_modules.loadsp.subnames -8000
    %define mm_modules.loadsp.subpaths -10000
   %define R.nmods rbx
   %define R.nsubs rsi
   %define R.hdrcode r12
   %define R.firstmod r13
   %define R.lastmod r14
    %define mm_modules.loadsp.issyslib -10008
    %define mm_modules.loadsp.pm -10016
    %define mm_modules.loadsp.d -10024
    %define mm_modules.loadsp.stalias -10032
    %define mm_modules.loadsp.path -10040
    %define mm_modules.loadsp.name -10048
    %define mm_modules.loadsp.ext -10056
    %define mm_modules.loadsp.proj -10064
    %define mm_modules.loadsp.sepheader -10072
    %define mm_modules.loadsp.i -10080
    %define mm_modules.loadsp.j -10088
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	10128
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    xor       rbx,	rbx
    xor       eax,	eax
    mov       rsi,	rax
    xor       eax,	eax
    mov       [rbp + mm_modules.loadsp.issyslib],	rax
    xor       eax,	eax
    mov       [rbp + mm_modules.loadsp.proj],	al
    xor       eax,	eax
    mov       [rbp + mm_modules.loadsp.sepheader],	al
    mov       rcx,	[rbp + mm_modules.loadsp.filename]
    call      mlib.extractbasefile
    mov       rcx,	rax
    mov       rdx,	[mm_cli.syslibname]
    call      mlib.eqstring
    test      rax,	rax
    jz        L7537
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.issyslib],	rax
L7537:
    mov       rcx,	[rbp + mm_modules.loadsp.filename]
    xor       edx,	edx
    call      mlib.extractext
    mov       [rbp + mm_modules.loadsp.ext],	rax
    mov       rcx,	[rbp + mm_modules.loadsp.ext]
    lea       rdx,	[L13261]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7539
    mov       rcx,	[rbp + mm_modules.loadsp.ext]
    call      mlib.pcm_copyheapstring
    mov       [mm_modules.fileext],	rax
L7539:
    mov       rcx,	[rbp + mm_modules.loadsp.filename]
    mov       rdx,	[rbp + mm_modules.loadsp.issyslib]
    call      mm_modules.loadmodule
    mov       [rbp + mm_modules.loadsp.pm],	rax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    test      rax,	rax
    jnz       L7541
    lea       rcx,	[L13262]
    mov       rdx,	[rbp + mm_modules.loadsp.filename]
    lea       r8,	[L13263]
    call      mm_support.loaderror
L7541:
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax+8]
    mov       rax,	[rax+16]
    mov       [rbp + mm_modules.loadsp.path],	rax
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.i],	rax
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L7544
L7542:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7546
    mov       rax,	[rdi]
    lea       rcx,	[L13264]
    mov       rdx,	rax
    lea       r8,	[L13265]
    call      mm_support.loaderror
L7546:
    mov       rax,	[rbp + mm_modules.loadsp.i]
    inc       rax
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rax,	[mm_decls.nsubprogs]
    jle       L7542
L7544:
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rcx,	[rax+8]
    call      mm_lex.startlex
    call      mm_lex.lex
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	115
    jnz       L7548
    mov       al,	1
    mov       [rbp + mm_modules.loadsp.proj],	al
    mov       rcx,	41
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
L7548:
L7549:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	125
    jz        L7552
    cmp       rax,	4
    jz        L7553
    jmp       L7554
L7552:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    mov       rax,	r12
    cmp       rax,	1
    jz        L7556
    cmp       rax,	2
    jz        L7557
    cmp       rax,	4
    jz        L7558
    cmp       rax,	3
    jz        L7559
    jmp       L7560
L7556:
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       [rbp + mm_modules.loadsp.name],	rax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mm_modules.loadsp.name]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7562
    cmp       rbx,	250
    jl        L7564
    lea       rcx,	[L13266]
    lea       rdx,	[L13267]
    lea       r8,	[L13267]
    call      mm_support.loaderror
L7564:
    inc       rbx
    mov       rax,	rbx
    mov       r10,	[rbp + mm_modules.loadsp.name]
    mov       [rbp + rax*8 + mm_modules.loadsp.modnames-8],	r10
    mov       rax,	[rbp + mm_modules.loadsp.path]
    mov       [rbp + rbx*8 + mm_modules.loadsp.paths-8],	rax
    xor       eax,	eax
    mov       [rbp + rbx*8 + mm_modules.loadsp.aliases-8],	rax
L7562:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L7566
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13268]
    call      mlib.eqstring
    test      rax,	rax
    jz        L7566
    call      mm_lex.lex
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L7568
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + mm_modules.loadsp.stalias],	rax
    call      mm_lex.lex
    jmp       L7567
L7568:
    mov       rcx,	65
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    mov       [rbp + mm_modules.loadsp.stalias],	rax
L7567:
    mov       rax,	[rbp + mm_modules.loadsp.stalias]
    mov       [rbp + rbx*8 + mm_modules.loadsp.aliases-8],	rax
L7566:
    jmp       L7555
L7557:
    mov       rcx,	67
    call      mm_parse.checksymbol
    cmp       rsi,	250
    jl        L7570
    lea       rcx,	[L13269]
    lea       rdx,	[L13270]
    lea       r8,	[L13270]
    call      mm_support.loaderror
L7570:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    inc       rsi
    mov       r10,	rsi
    mov       [rbp + r10*8 + mm_modules.loadsp.subnames-8],	rax
    mov       rax,	[rbp + mm_modules.loadsp.path]
    mov       [rbp + rsi*8 + mm_modules.loadsp.subpaths-8],	rax
    jmp       L7555
L7558:
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      mm_modules.addlib
    jmp       L7555
L7559:
    mov       rcx,	65
    call      mm_parse.checksymbol
    mov       al,	[mm_decls.loadedfromma]
    test      al,	al
    jnz       L7572
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mm_modules.loadsp.path],	rax
L7572:
    jmp       L7555
L7560:
    lea       rcx,	[L13271]
    lea       rdx,	[L13272]
    lea       r8,	[L13272]
    call      mm_support.loaderror
L7555:
    call      mm_lex.lex
    jmp       L7551
L7553:
    jmp       L7551
L7554:
    jmp       L7550
L7551:
    jmp       L7549
L7550:
    mov       al,	[rbp + mm_modules.loadsp.proj]
    test      al,	al
    jz        L7574
    mov       rcx,	87
    mov       rdx,	115
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
L7574:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	59
    jnz       L7576
    mov       al,	1
    mov       [rbp + mm_modules.loadsp.sepheader],	al
L7576:
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rsi,	1
    jl        L7579
L7577:
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + r10*8 + mm_modules.loadsp.subnames-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7581
    lea       rcx,	[L13273]
    lea       rdx,	[L13274]
    lea       r8,	[L13274]
    call      mm_support.loaderror
L7581:
    mov       rax,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rbp + rax*8 + mm_modules.loadsp.subnames-8]
    mov       r10,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + r10*8 + mm_modules.loadsp.subpaths-8]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_modules.getmodulefilename
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_modules.loadsp
    mov       rax,	[rbp + mm_modules.loadsp.i]
    inc       rax
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rax,	rsi
    jle       L7577
L7579:
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	30
    jl        L7583
    lea       rcx,	[L13275]
    lea       rdx,	[L13276]
    lea       r8,	[L13276]
    call      mm_support.loaderror
L7583:
    mov       rcx,	16
    call      mlib.pcm_allocz
    mov       rdi,	rax
    inc       qword [mm_decls.nsubprogs]
    mov       rax,	[mm_decls.nsubprogs]
    mov       r10,	rdi
    lea       r11,	[mm_decls.subprogs]
    mov       [r11 + rax*8],	r10
    mov       al,	[mm_decls.nsubprogs]
    mov       [rdi+15],	al
    mov       rax,	[rbp + mm_modules.loadsp.mainsub]
    test      rax,	rax
    jz        L7585
    mov       rax,	[mm_decls.nsubprogs]
    mov       [mm_decls.mainsubprogno],	rax
L7585:
    mov       rax,	[mm_decls.nmodules]
    inc       rax
    mov       r13,	rax
    mov       rax,	r13
    add       rax,	rbx
    mov       r14,	rax
    cmp       r14,	300
    jle       L7587
    lea       rcx,	[L13277]
    lea       rdx,	[L13278]
    lea       r8,	[L13278]
    call      mm_support.loaderror
L7587:
    mov       [mm_decls.nmodules],	r14
    mov       ax,	[mm_decls.nsubprogs]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+18],	ax
    mov       al,	1
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+23],	al
    mov       ax,	r13w
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+16],	ax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	rax
    mov       r8,	3
    call      mm_lib.createdupldef
    mov       [rbp + mm_modules.loadsp.d],	rax
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+24],	rax
    mov       al,	r13b
    mov       r10,	[rbp + mm_modules.loadsp.d]
    mov       [r10+94],	al
    mov       al,	[mm_decls.nsubprogs]
    mov       r10,	[rbp + mm_modules.loadsp.d]
    mov       [r10+95],	al
    mov       al,	[mm_decls.nsubprogs]
    lea       r10,	[mm_decls.moduletosub]
    mov       r11,	r13
    mov       [r10 + r11],	al
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       [rdi],	rax
    mov       [rdi+8],	r13w
    xor       eax,	eax
    mov       [rdi+10],	ax
    mov       [rdi+12],	r14w
    lea       rax,	[rdi+14]
    mov       r10b,	[rbp + mm_modules.loadsp.issyslib]
    and       byte [rax],	253
    shl       r10b,	1
    or        [rax],	r10b
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    lea       r10,	[mm_decls.modules]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rbx,	1
    jl        L7590
L7588:
    mov       rax,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rbp + rax*8 + mm_modules.loadsp.modnames-8]
    mov       r10,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + r10*8 + mm_modules.loadsp.paths-8]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mm_modules.loadsp.issyslib]
    call      mm_modules.getmodulefilename
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_modules.loadsp.issyslib]
    call      mm_modules.loadmodule
    mov       [rbp + mm_modules.loadsp.pm],	rax
    mov       rax,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rbp + rax*8 + mm_modules.loadsp.aliases-8]
    mov       [rbp + mm_modules.loadsp.stalias],	rax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    test      rax,	rax
    jnz       L7592
    mov       rax,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rbp + rax*8 + mm_modules.loadsp.modnames-8]
    lea       rcx,	[L13279]
    mov       rdx,	rax
    lea       r8,	[L13280]
    call      mm_support.loaderror
L7592:
    mov       rax,	r13
    add       rax,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    lea       r11,	[mm_decls.modules]
    mov       [r11 + rax*8],	r10
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	rax
    mov       r8,	3
    call      mm_lib.createdupldef
    mov       [rbp + mm_modules.loadsp.d],	rax
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+24],	rax
    mov       ax,	[mm_decls.nsubprogs]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+18],	ax
    mov       rax,	[rbp + mm_modules.loadsp.stalias]
    test      rax,	rax
    jz        L7594
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	[rbp + mm_modules.loadsp.stalias]
    mov       r8,	15
    call      mm_lib.getduplnameptr
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+40],	rax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax+40]
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	rax
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax+40]
    xor       r10d,	r10d
    mov       [rax+112],	r10
    mov       rcx,	[rbp + mm_modules.loadsp.d]
    call      mm_lib.createname
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       r10,	[r10+40]
    mov       [r10+64],	rax
L7594:
    mov       rax,	r13
    add       rax,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+16],	ax
    mov       r10,	[rbp + mm_modules.loadsp.d]
    mov       [r10+94],	al
    mov       al,	[mm_decls.nsubprogs]
    mov       r10,	[rbp + mm_modules.loadsp.d]
    mov       [r10+95],	al
    mov       rax,	[rbp + mm_modules.loadsp.d]
    movzx     rax,	byte [rax+94]
    mov       r10b,	[mm_decls.nsubprogs]
    lea       r11,	[mm_decls.moduletosub]
    mov       [r11 + rax],	r10b
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.j],	rax
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L7597
L7595:
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    lea       r10,	[mm_decls.modules]
    mov       r11,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[r10 + r11*8]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7599
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    lea       rcx,	[L13281]
    mov       rdx,	rax
    call      mm_support.serror_s
L7599:
    mov       rax,	[rbp + mm_modules.loadsp.j]
    inc       rax
    mov       [rbp + mm_modules.loadsp.j],	rax
    cmp       rax,	[mm_decls.nmodules]
    jle       L7595
L7597:
    mov       rax,	[rbp + mm_modules.loadsp.i]
    inc       rax
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rax,	rbx
    jle       L7588
L7590:
    mov       rax,	rdi
L7535:
;---------------
    add       rsp,	10128
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadmodule
mm_modules.loadmodule:
;?>>
   %define R.filespec rsi
   %define R.issyslib r12
   %define R.pm rdi
   %define R.pf rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_modules.loadsourcefile
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L7602
    xor       eax,	eax
    jmp       L7600
L7602:
    mov       rcx,	64
    call      mlib.pcm_allocz
    mov       rdi,	rax
    mov       rax,	[rbx]
    mov       [rdi],	rax
    mov       [rdi+8],	rbx
    mov       ax,	[rbx+64]
    mov       [rdi+20],	ax
    mov       [rdi+22],	r12b
    mov       rax,	rdi
L7600:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadsourcefile
mm_modules.loadsourcefile:
;?>>
   %define R.filespec r13
   %define R.issyslib r14
   %define R.pf rdi
   %define R.s rbx
   %define R.filename rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    mov       rcx,	r13
    call      mlib.extractfile
    mov       rsi,	rax
    mov       r12,	1
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L7606
L7604:
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+8]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7608
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    movzx     rax,	byte [rax+56]
    cmp       rax,	r14
    jnz       L7608
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    jmp       L7603
L7608:
    inc       r12
    cmp       r12,	[mm_decls.nsourcefiles]
    jle       L7604
L7606:
    call      mm_support.newsourcefile
    mov       rdi,	rax
    mov       rcx,	r13
    call      mlib.pcm_copyheapstring
    mov       [rdi+24],	rax
    mov       rcx,	r13
    call      mlib.extractpath
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rdi+16],	rax
    mov       rcx,	r13
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    mov       rcx,	rsi
    call      mlib.pcm_copyheapstring
    mov       [rdi+8],	rax
    mov       [rdi+56],	r14b
    mov       ax,	[mm_decls.nsourcefiles]
    mov       [rdi+64],	ax
    mov       rcx,	r13
    call      mlib.readfile
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L7610
    xor       eax,	eax
    jmp       L7603
L7610:
    mov       [rdi+32],	rbx
    mov       rax,	[mlib.rfsize]
    mov       [rdi+48],	rax
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	1
    jnz       L7612
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi+40],	rax
L7612:
    xor       eax,	eax
    mov       r10,	[mlib.rfsize]
    mov       [rbx + r10],	al
    mov       rax,	rdi
L7603:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.getmodulefilename
mm_modules.getmodulefilename:
;?>>
   %define R.path rdi
   %define R.name rbx
   %define R.issyslib rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[mm_modules.getmodulefilename.str]
    mov       rdx,	rdi
    call      strcpy
    lea       rcx,	[mm_modules.getmodulefilename.str]
    mov       rdx,	rbx
    call      strcat
    lea       rcx,	[mm_modules.getmodulefilename.str]
    lea       rdx,	[L13282]
    call      strcat
    test      rsi,	rsi
    jz        L7615
    lea       rax,	[L13283]
    jmp       L7614
L7615:
    mov       rax,	[mm_modules.fileext]
L7614:
    lea       rcx,	[mm_modules.getmodulefilename.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[mm_modules.getmodulefilename.str]
L7613:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.addlib
mm_modules.addlib:
;?>>
   %define R.libname rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	1
    jl        L7619
L7617:
    lea       rax,	[mm_decls.libfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7616
L7621:
    inc       rdi
    cmp       rdi,	[mm_decls.nlibfiles]
    jle       L7617
L7619:
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	50
    jl        L7623
    lea       rcx,	[L13284]
    lea       rdx,	[L13285]
    lea       r8,	[L13285]
    call      mm_support.loaderror
L7623:
    inc       qword [mm_decls.nlibfiles]
    mov       rax,	[mm_decls.nlibfiles]
    mov       r10,	rbx
    lea       r11,	[mm_decls.libfiles]
    mov       [r11 + rax*8],	r10
L7616:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadsyslib
mm_modules.loadsyslib:
;?>>
    %define mm_modules.loadsyslib.str -304
   %define R.name rdi
   %define R.frunpcl bl
   %define R.fgenpcl sil
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	344
;---------------
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    mov       bl,	al
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    setz      al
    movzx     eax,	al
    mov       sil,	al
    mov       al,	[mm_decls.dointlibs]
    test      al,	al
    jz        L7626
    xor       eax,	eax
    mov       [rbp + mm_modules.loadsyslib.str],	al
    jmp       L7625
L7626:
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    lea       rdx,	[L13286]
    call      strcpy
L7625:
    movzx     rax,	byte [mm_decls.msyslevel]
    test      rax,	rax
    jz        L7628
    cmp       rax,	1
    jz        L7629
    jmp       L7630
L7628:
    jmp       L7624
L7629:
    xor       eax,	eax
    test      ax,	ax
    jnz       L7633
    call      mwindows.os_iswindows
    test      rax,	rax
    jnz       L7632
L7633:
    lea       rax,	[L13287]
    jmp       L7631
L7632:
    lea       rax,	[L13288]
L7631:
    mov       rdi,	rax
    jmp       L7627
L7630:
    call      mwindows.os_iswindows
    test      rax,	rax
    jz        L7635
    mov       al,	[mm_decls.clinux]
    test      al,	al
    jnz       L7635
    xor       eax,	eax
    test      ax,	ax
    jz        L7637
    lea       rax,	[L13289]
    mov       rdi,	rax
    jmp       L7636
L7637:
    test      bl,	bl
    jnz       L7639
    test      sil,	sil
    jz        L7638
L7639:
    lea       rax,	[L13290]
    mov       rdi,	rax
    jmp       L7636
L7638:
    lea       rax,	[L13291]
    mov       rdi,	rax
L7636:
    jmp       L7634
L7635:
    lea       rax,	[L13292]
    mov       rdi,	rax
L7634:
L7627:
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    mov       rdx,	rdi
    call      strcat
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    call      mlib.pcm_copyheapstring
    mov       [mm_cli.syslibname],	rax
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	2
    jl        L7641
    call      msys.m$print_startcon
    lea       rcx,	[L13293]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_cli.syslibname]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L7641:
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    lea       rdx,	[L13294]
    call      strcat
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    xor       edx,	edx
    call      mm_modules.loadsp
L7624:
;---------------
    add       rsp,	344
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadproject
mm_modules.loadproject:
;?>>
   %define R.file rsi
    %define mm_modules.loadproject.str -304
   %define R.file2 rdi
   %define R.tt rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	344
    mov       rsi,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rbx,	r10
    mov       al,	[mm_decls.dointlibs]
    test      al,	al
    jz        L7644
    call      mm_libsources.loadbuiltins
L7644:
    call      mm_modules.loadsyslib
    mov       rcx,	rsi
    call      mlib.checkfile
    test      rax,	rax
    jnz       L7646
    mov       rcx,	rsi
    lea       rdx,	[L13295]
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mlib.checkfile
    test      rax,	rax
    jz        L7648
    mov       rsi,	rdi
L7648:
L7646:
    mov       rcx,	rsi
    xor       edx,	edx
    call      mlib.extractext
    mov       rcx,	rax
    lea       rdx,	[L13295]
    call      mlib.eqstring
    test      rax,	rax
    jz        L7650
    call      msys.m$print_startcon
    lea       rcx,	[L13296]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_modules.loadmafile
    mov       al,	1
    mov       [mm_decls.loadedfromma],	al
    mov       rcx,	rsi
    lea       rdx,	[L13297]
    call      mlib.changeext
    lea       rcx,	[rbp + mm_modules.loadproject.str]
    mov       rdx,	rax
    call      strcpy
    lea       rax,	[rbp + mm_modules.loadproject.str]
    mov       rsi,	rax
L7650:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_modules.loadsp
    lea       rcx,	[L13298]
    call      mm_modules.addlib
    call      mwindows.os_iswindows
    test      rax,	rax
    jz        L7652
    lea       rcx,	[L13299]
    call      mm_modules.addlib
    lea       rcx,	[L13300]
    call      mm_modules.addlib
    lea       rcx,	[L13301]
    call      mm_modules.addlib
L7652:
    call      clock
    movsxd    r10,	eax
    sub       r10,	rbx
    mov       [mm_cli.loadtime],	r10
;---------------
    add       rsp,	344
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.readfileline
mm_modules.readfileline:
;?>>
   %define R.s r12
    %define mm_modules.readfileline.str -2048
   %define R.t rdi
   %define R.n rbx
   %define R.c rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2080
    mov       r12,	rcx
;---------------
    lea       rax,	[rbp + mm_modules.readfileline.str]
    mov       rdi,	rax
    xor       rbx,	rbx
L7654:
    mov       rax,	r12
    inc       r12
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    test      rax,	rax
    jz        L7656
    cmp       rax,	10
    jz        L7657
    jmp       L7658
L7656:
    dec       r12
    jmp       L7655
L7657:
    jmp       L7655
L7658:
    cmp       rbx,	2048
    jge       L7660
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	sil
    mov       [rax],	r10b
L7660:
    jmp       L7654
L7655:
    xor       eax,	eax
    mov       [rdi],	al
    lea       rcx,	[rbp + mm_modules.readfileline.str]
    call      msys.m$read_strline
    mov       rax,	r12
L7653:
;---------------
    add       rsp,	2080
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.findnextlineheader
mm_modules.findnextlineheader:
;?>>
   %define R.s rcx
   %define R.c rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
L7662:
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    test      rax,	rax
    jz        L7664
    cmp       rax,	10
    jz        L7665
    jmp       L7666
L7664:
    xor       eax,	eax
    jmp       L7661
L7665:
    movzx     rax,	byte [rcx]
    cmp       rax,	61
    jnz       L7668
    movzx     rax,	byte [rcx+1]
    cmp       rax,	61
    jnz       L7668
    movzx     rax,	byte [rcx+2]
    cmp       rax,	61
    jnz       L7668
    lea       rax,	[rcx+3]
    jmp       L7661
L7668:
    jmp       L7662
L7666:
    jmp       L7662
    xor       eax,	eax
L7661:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadmafile
mm_modules.loadmafile:
;?>>
   %define R.filespec r15
    %define mm_modules.loadmafile.builtinstr 80
   %define R.s rdi
   %define R.t rbx
    %define mm_modules.loadmafile.name -104
   %define R.sys rsi
   %define R.support r12
   %define R.pf r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       r15,	rcx
    mov       [rbp+80],	rdx
;---------------
    test      r15,	r15
    jz        L7671
    mov       rcx,	r15
    call      mlib.readfile
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L7673
    lea       rcx,	[L13302]
    mov       rdx,	r15
    lea       r8,	[L13303]
    call      mm_support.loaderror
L7673:
    jmp       L7670
L7671:
    mov       rdi,	[rbp + mm_modules.loadmafile.builtinstr]
L7670:
    lea       rax,	[rdi+3]
    mov       rcx,	rax
    call      mm_modules.readfileline
    mov       rdi,	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    mov       rdx,	110
    xor       r8d,	r8d
    call      msys.readstr
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    lea       rdx,	[L13304]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7675
    lea       rcx,	[L13305]
    lea       rdx,	[L13306]
    lea       r8,	[L13306]
    call      mm_support.loaderror
L7675:
    dec       rdi
    mov       rcx,	rdi
    call      mm_modules.findnextlineheader
    mov       rdi,	rax
L7676:
    test      rdi,	rdi
    jnz       L7679
    lea       rcx,	[L13307]
    lea       rdx,	[L13308]
    lea       r8,	[L13308]
    call      mm_support.loaderror
    jmp       L7677
L7679:
    mov       rcx,	rdi
    call      mm_modules.readfileline
    mov       rdi,	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    mov       rdx,	110
    xor       r8d,	r8d
    call      msys.readstr
    xor       ecx,	ecx
    call      msys.m$read_i64
    mov       rsi,	rax
    xor       ecx,	ecx
    call      msys.m$read_i64
    mov       r12,	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    lea       rdx,	[L13309]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7677
L7681:
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	300
    jl        L7683
    lea       rcx,	[L13310]
    lea       rdx,	[L13311]
    lea       r8,	[L13311]
    call      mm_support.loaderror
L7683:
    mov       rcx,	rdi
    call      mm_modules.findnextlineheader
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L7685
    lea       rcx,	[L13312]
    lea       rdx,	[L13313]
    lea       r8,	[L13313]
    call      mm_support.loaderror
L7685:
    call      mm_support.newsourcefile
    mov       r13,	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    call      mlib.pcm_copyheapstring
    mov       [r13+24],	rax
    mov       [r13+8],	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [r13],	rax
    mov       rax,	rbx
    sub       rax,	rdi
    sub       rax,	3
    mov       [r13+48],	rax
    mov       [r13+32],	rdi
    lea       rax,	[L13313]
    mov       [r13+24],	rax
    mov       [r13+16],	rax
    mov       [r13+56],	sil
    mov       [r13+57],	r12b
    mov       rdi,	rbx
    jmp       L7676
L7677:
    mov       r14,	1
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L7688
L7686:
    lea       rax,	[mm_decls.sources]
    mov       r10,	r14
    mov       r13,	[rax + r10*8]
    mov       rax,	[r13+32]
    mov       r10,	[r13+48]
    xor       r11d,	r11d
    mov       [rax + r10],	r11b
    inc       r14
    cmp       r14,	[mm_decls.nsourcefiles]
    jle       L7686
L7688:
;---------------
    add       rsp,	136
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_typetable
mm_name.rx_typetable:
;?>>
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	31
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	31
    jl        L7692
L7690:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jnz       L7694
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8]
    mov       eax,	[rdi+144]
    test      eax,	eax
    jz        L7696
    mov       rcx,	rdi
    call      mm_name.do_baseclass
L7696:
L7694:
    inc       rbx
    cmp       rbx,	[mm_decls.ntypes]
    jle       L7690
L7692:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_unit
mm_name.rx_unit:
;?>>
    %define mm_name.rx_unit.owner 72
    %define mm_name.rx_unit.p 80
   %define R.d rdi
   %define R.a rbx
   %define R.b rsi
   %define R.n r12
   %define R.oldnoexpand r13
   %define R.oldnoassem r14
   %define R.oldtag r15
    %define mm_name.rx_unit.useparams -8
    %define mm_name.rx_unit.av_1 -16
    %define mm_name.rx_unit.i -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rsi,	[rax+24]
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       eax,	[rax+4]
    mov       [pc_decls.mmpos],	rax
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    sub       rax,	4
    cmp       rax,	46
    jae       L7700
    lea       r10,	[L7699]
    jmp       [r10 + rax*8]
    segment .data
L7699:
    dq  L7701
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7741
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7724
    dq  L7724
    dq  L7733
    dq  L7729
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7704
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7706
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7700
    dq  L7705
    segment .text
L7701:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.resolvename
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L7703
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rax,	[rax+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	15
    jnz       L7703
    mov       rax,	[mm_name.noexpand]
    test      rax,	rax
    jnz       L7703
    inc       qword [mm_name.macrolevels]
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    xor       r8d,	r8d
    call      mm_name.expandmacro
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.rx_unit
    dec       qword [mm_name.macrolevels]
L7703:
    jmp       L7698
L7704:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rsi
    call      mm_name.rx_unit
    jmp       L7698
L7705:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.resolvedot
    jmp       L7698
L7706:
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    mov       r15,	rax
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L7708
    mov       r13,	[mm_name.noexpand]
    mov       rax,	1
    mov       [mm_name.noexpand],	rax
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
    mov       [mm_name.noexpand],	r13
    jmp       L7707
L7708:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
L7707:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rsi
    call      mm_name.rx_unitlist
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L7710
    mov       rdi,	[rbx+16]
    movzx     rax,	byte [rdi+78]
    cmp       rax,	5
    jz        L7712
    cmp       rax,	15
    jz        L7713
    jmp       L7714
L7712:
    mov       al,	58
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10],	al
    mov       rax,	[rbp + mm_name.rx_unit.p]
    lea       rax,	[rax+53]
    movsxd    r10,	dword [rdi+72]
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rsi
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10+16],	rax
    mov       rax,	[rsi+8]
    test      rax,	rax
    jz        L7716
    mov       rcx,	20
    mov       rdx,	rsi
    call      mm_lib.createunit1
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10+16],	rax
    xor       r12,	r12
    jmp       L7718
L7717:
    inc       r12
    mov       rsi,	[rsi+8]
L7718:
    test      rsi,	rsi
    jnz       L7717
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rax,	[rax+16]
    mov       r10d,	r12d
    mov       [rax+40],	r10d
L7716:
    jmp       L7711
L7713:
    inc       qword [mm_name.macrolevels]
    mov       rax,	[rdi+16]
    test      rax,	rax
    jz        L7721
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_name.expandmacro
    xor       rsi,	rsi
    xor       eax,	eax
    mov       [rbp + mm_name.rx_unit.useparams],	rax
    jmp       L7720
L7721:
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_name.expandmacro
    mov       rax,	1
    mov       [rbp + mm_name.rx_unit.useparams],	rax
L7720:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.rx_unit
    dec       qword [mm_name.macrolevels]
    mov       rax,	[rbp + mm_name.rx_unit.useparams]
    test      rax,	rax
    jz        L7723
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    cmp       rax,	32
    jz        L7723
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	r15
    call      mm_lib.insertunit
    mov       rax,	rsi
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10+24],	rax
L7723:
L7714:
L7711:
L7710:
    jmp       L7698
L7724:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rsi
    call      mm_name.rx_unit
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L7726
    mov       rcx,	rbx
    mov       rdx,	18
    call      mm_lib.insertunit
L7726:
    movzx     rax,	byte [rsi]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L7728
    mov       rcx,	rsi
    mov       rdx,	18
    call      mm_lib.insertunit
L7728:
    jmp       L7698
L7729:
;mm_name.rx_unit.doistruel:
L7730:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L7732
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
L7732:
    jmp       L7698
L7733:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
    movzx     rax,	byte [rbx]
    cmp       rax,	17
    jz        L7735
    cmp       rax,	18
    jz        L7736
    cmp       rax,	19
    jz        L7737
    jmp       L7738
L7735:
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
    mov       al,	18
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10],	al
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
    jmp       L7730
L7736:
    mov       al,	19
    mov       [rbx],	al
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
    jmp       L7734
L7737:
    mov       al,	18
    mov       [rbx],	al
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
    jmp       L7734
L7738:
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L7740
    mov       al,	19
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10],	al
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
L7740:
L7734:
    jmp       L7698
L7741:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.resolvename
    mov       rax,	[mm_name.noexpand]
    test      rax,	rax
    jnz       L7743
    inc       qword [mm_name.macrolevels]
    mov       r14,	[mm_name.noassem]
    mov       rax,	1
    mov       [mm_name.noassem],	rax
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_name.expandmacro
    mov       [mm_name.noassem],	r14
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.rx_unit
    dec       qword [mm_name.macrolevels]
L7743:
    jmp       L7698
L7700:
;mm_name.rx_unit.doabc:
    mov       rax,	1
    mov       [rbp + mm_name.rx_unit.i],	rax
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       [rbp + mm_name.rx_unit.av_1],	r10
    mov       rax,	[rbp + mm_name.rx_unit.av_1]
    cmp       rax,	1
    jl        L7747
L7745:
    mov       rax,	[rbp + mm_name.rx_unit.p]
    lea       rax,	[rax+16]
    mov       r10,	[rbp + mm_name.rx_unit.i]
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rax
    call      mm_name.rx_unitlist
    mov       rax,	[rbp + mm_name.rx_unit.i]
    inc       rax
    mov       [rbp + mm_name.rx_unit.i],	rax
    cmp       rax,	[rbp + mm_name.rx_unit.av_1]
    jle       L7745
L7747:
L7698:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_module
mm_name.rx_module:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       [mm_decls.currmoduleno],	rdi
    lea       rax,	[mm_decls.modules]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+24]
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	rax
    call      mm_name.rx_passdef
    mov       rax,	1
L7748:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_deflist
mm_name.rx_deflist:
;?>>
   %define R.owner rbx
   %define R.p rsi
   %define R.pstart rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	rsi
    jmp       L7751
L7750:
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mm_name.rx_passdef
    mov       rsi,	[rsi+32]
L7751:
    test      rsi,	rsi
    jnz       L7750
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_passdef
mm_name.rx_passdef:
;?>>
   %define R.owner rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rbx+78]
    cmp       rax,	3
    jz        L7755
    cmp       rax,	4
    jz        L7755
    cmp       rax,	6
    jz        L7756
    cmp       rax,	7
    jz        L7757
    cmp       rax,	9
    jz        L7758
    cmp       rax,	10
    jz        L7758
    cmp       rax,	11
    jz        L7758
    cmp       rax,	12
    jz        L7758
    cmp       rax,	5
    jz        L7759
    jmp       L7760
L7755:
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_deflist
    jmp       L7754
L7756:
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_deflist
    mov       [mm_name.currstproc],	rbx
    mov       rax,	[rbx+64]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_unit
    xor       eax,	eax
    mov       [mm_name.currstproc],	rax
    jmp       L7754
L7757:
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_deflist
    jmp       L7754
L7758:
    movzx     rax,	word [rbx+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L7762
    mov       rax,	[rbx+96]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_name.rx_unit
L7762:
    mov       rax,	[rbx+64]
    test      rax,	rax
    jz        L7764
    mov       rax,	[rbx+64]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_name.rx_unit
L7764:
    jmp       L7754
L7759:
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_deflist
L7760:
L7754:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_unitlist
mm_name.rx_unitlist:
;?>>
   %define R.owner rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    jmp       L7767
L7766:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_name.rx_unit
    mov       rbx,	[rbx+8]
L7767:
    test      rbx,	rbx
    jnz       L7766
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.resolvetopname
mm_name.resolvetopname:
;?>>
   %define R.owner r13
   %define R.stnewname r14
    %define mm_name.resolvetopname.moduleno 80
    %define mm_name.resolvetopname.allowmod 88
   %define R.extcount rdi
   %define R.subprogno rbx
   %define R.p rsi
   %define R.q r12
    %define mm_name.resolvetopname.powner -8
    %define mm_name.resolvetopname.extdef -16
    %define mm_name.resolvetopname.moddef -24
    %define mm_name.resolvetopname.ambiglist -104
    %define mm_name.resolvetopname.i -112
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	144
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movzx     rax,	byte [r13+78]
    cmp       rax,	6
    jnz       L7771
    mov       r12,	[r13+16]
    jmp       L7775
L7772:
    mov       rax,	[r12+48]
    cmp       rax,	r14
    jnz       L7777
    mov       rax,	r12
    jmp       L7769
L7777:
    mov       r12,	[r12+32]
L7775:
    test      r12,	r12
    jnz       L7772
L7771:
    mov       rsi,	[r14+40]
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[rbp + mm_name.resolvetopname.moduleno]
    movzx     rax,	byte [rax + r10]
    mov       rbx,	rax
    xor       rdi,	rdi
    xor       eax,	eax
    mov       [rbp + mm_name.resolvetopname.moddef],	rax
    mov       [rbp + mm_name.resolvetopname.extdef],	rax
    jmp       L7781
L7778:
    mov       rax,	[rsi+8]
    mov       [rbp + mm_name.resolvetopname.powner],	rax
    mov       rax,	[rbp + mm_name.resolvetopname.powner]
    movzx     rax,	byte [rax+78]
    cmp       rax,	3
    jz        L7783
    cmp       rax,	5
    jz        L7784
    cmp       rax,	1
    jz        L7785
    jmp       L7786
L7783:
    mov       rax,	[rbp + mm_name.resolvetopname.powner]
    movzx     rax,	byte [rax+94]
    cmp       rax,	[rbp + mm_name.resolvetopname.moduleno]
    jnz       L7788
    mov       rax,	rsi
    jmp       L7769
L7788:
    mov       al,	[rsi+170]
    test      al,	al
    jz        L7789
    mov       rax,	[rbp + mm_name.resolvetopname.powner]
    movzx     rax,	byte [rax+95]
    cmp       rax,	rbx
    jz        L7792
    movzx     rax,	byte [rsi+170]
    cmp       rax,	2
    jz        L7792
    movzx     rax,	word [rsi+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L7791
L7792:
    inc       rdi
    mov       [rbp + mm_name.resolvetopname.extdef],	rsi
    cmp       rdi,	10
    jge       L7794
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       [rbp + rdi*8 + mm_name.resolvetopname.ambiglist-8],	rax
L7794:
L7791:
L7789:
L7787:
    jmp       L7782
L7784:
    mov       rax,	[rbp + mm_name.resolvetopname.powner]
    cmp       rax,	r13
    jz        L7797
    mov       rax,	[r13+8]
    mov       r10,	[rbp + mm_name.resolvetopname.powner]
    cmp       r10,	rax
    jnz       L7796
L7797:
    mov       rax,	rsi
    jmp       L7769
L7796:
    jmp       L7782
L7785:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jz        L7799
    cmp       rax,	2
    jz        L7799
    cmp       rax,	15
    jz        L7800
    jmp       L7801
L7799:
    movzx     rax,	byte [rsi+94]
    lea       r10,	[mm_decls.moduletosub]
    movzx     r10,	byte [r10 + rax]
    cmp       rbx,	r10
    jnz       L7803
    mov       [rbp + mm_name.resolvetopname.moddef],	rsi
    jmp       L7802
L7803:
    mov       rax,	1
    mov       [rbp + mm_name.resolvetopname.i],	rax
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L7806
L7804:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	[rbp + mm_name.resolvetopname.i]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    mov       r10,	[rsi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7808
    lea       rax,	[rsi+92]
    or        byte [rax+1],	4
    mov       [rbp + mm_name.resolvetopname.moddef],	rsi
    jmp       L7806
L7808:
    mov       rax,	[rbp + mm_name.resolvetopname.i]
    inc       rax
    mov       [rbp + mm_name.resolvetopname.i],	rax
    cmp       rax,	[mm_decls.nsubprogs]
    jle       L7804
L7806:
L7802:
    jmp       L7798
L7800:
    mov       rax,	rsi
    jmp       L7769
L7801:
L7798:
L7786:
L7782:
    mov       rsi,	[rsi+40]
L7781:
    test      rsi,	rsi
    jnz       L7778
    mov       rax,	[rbp + mm_name.resolvetopname.allowmod]
    test      rax,	rax
    jz        L7810
    mov       rax,	[rbp + mm_name.resolvetopname.moddef]
    test      rax,	rax
    jz        L7810
    mov       rax,	[rbp + mm_name.resolvetopname.moddef]
    jmp       L7769
L7810:
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    test      rax,	rax
    jz        L7812
    cmp       rdi,	1
    jle       L7814
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13314]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7816
    mov       rax,	1
    mov       [rbp + mm_name.resolvetopname.i],	rax
    cmp       rdi,	1
    jl        L7819
L7817:
    mov       rax,	[rbp + mm_name.resolvetopname.i]
    mov       rax,	[rbp + rax*8 + mm_name.resolvetopname.ambiglist-8]
    mov       [rbp + mm_name.resolvetopname.extdef],	rax
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mm_name.resolvetopname.i]
    call      msys.m$print_i64_nf
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_name.resolvetopname.i]
    inc       rax
    mov       [rbp + mm_name.resolvetopname.i],	rax
    cmp       rax,	rdi
    jle       L7817
L7819:
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13314]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7821
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax]
    lea       rcx,	[L13315]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7821:
L7816:
L7814:
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    jmp       L7769
L7812:
    xor       eax,	eax
L7769:
;---------------
    add       rsp,	144
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.resolvename
mm_name.resolvename:
;?>>
   %define R.owner r14
    %define mm_name.resolvename.p 72
   %define R.d rdi
   %define R.e rbx
   %define R.moduleno rsi
   %define R.mode r12
   %define R.islet r13
    %define mm_name.resolvename.str -304
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
    mov       r14,	rcx
    mov       [rbp+72],	rdx
;---------------
    mov       rax,	[rbp + mm_name.resolvename.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_name.resolvename.p]
    movzx     rax,	byte [rax+57]
    mov       rsi,	rax
    movzx     rax,	byte [rdi+78]
    test      rax,	rax
    jnz       L7822
L7824:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rsi
    mov       r9,	[mm_name.allowmodname]
    call      mm_name.resolvetopname
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L7826
    xor       r13,	r13
    xor       eax,	eax
    mov       r12,	rax
    mov       rax,	[rbp + mm_name.resolvename.p]
    movzx     rax,	byte [rax+41]
    cmp       rax,	73
    jz        L7828
    cmp       rax,	84
    jz        L7828
    cmp       rax,	83
    jz        L7828
    cmp       rax,	76
    jz        L7829
    cmp       rax,	65
    jz        L7829
    jmp       L7830
L7828:
    mov       r12,	3
    mov       r13,	1
    jmp       L7827
L7829:
    mov       r12,	23
L7830:
L7827:
    test      r12,	r12
    jnz       L7832
    mov       rax,	[rdi]
    lea       rcx,	[rbp + mm_name.resolvename.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mm_name.resolvename.str]
    call      mlib.convucstring
    lea       rcx,	[L13316]
    lea       rdx,	[rbp + mm_name.resolvename.str]
    mov       r8,	[rbp + mm_name.resolvename.p]
    call      mm_support.rxerror_s
    jmp       L7831
L7832:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_name.addframevar
    mov       rbx,	rax
    mov       rax,	[rbp + mm_name.resolvename.p]
    mov       eax,	[rax+4]
    mov       [rbx+88],	eax
    lea       rax,	[rbx+92]
    mov       r10b,	r13b
    and       byte [rax],	239
    shl       r10b,	4
    or        [rax],	r10b
L7831:
L7826:
    movzx     rax,	word [rbx+168]
    cmp       rax,	255
    jge       L7834
    lea       rax,	[rbx+168]
    inc       word [rax]
L7834:
    mov       rax,	rbx
    mov       r10,	[rbp + mm_name.resolvename.p]
    mov       [r10+16],	rax
L7822:
;---------------
    add       rsp,	336
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.finddupl
mm_name.finddupl:
;?>>
   %define R.d rcx
   %define R.pdupl rdx
;?]]
;---------------
    movzx     rax,	byte [rdx+78]
    test      rax,	rax
    jz        L7837
    mov       rax,	rdx
    jmp       L7835
L7837:
    mov       rdx,	[rdx+40]
    jmp       L7839
L7838:
    mov       rax,	[rdx+8]
    cmp       rax,	rcx
    jnz       L7842
    mov       rax,	rdx
    jmp       L7835
L7842:
    mov       rdx,	[rdx+40]
L7839:
    test      rdx,	rdx
    jnz       L7838
    xor       eax,	eax
L7835:
;---------------
    ret       
;End 
;Proc mm_name.finddupl_sub
mm_name.finddupl_sub:
;?>>
   %define R.d rcx
   %define R.pdupl rdx
   %define R.subprogno rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    movzx     rax,	byte [rdx+78]
    test      rax,	rax
    jz        L7845
    mov       rax,	rdx
    jmp       L7843
L7845:
    mov       rdx,	[rdx+40]
    movzx     rax,	byte [rcx+95]
    mov       rdi,	rax
    jmp       L7847
L7846:
    mov       rax,	[rdx+8]
    movzx     rax,	byte [rax+95]
    cmp       rax,	rdi
    jnz       L7850
    mov       rax,	rdx
    jmp       L7843
L7850:
    mov       rdx,	[rdx+40]
L7847:
    test      rdx,	rdx
    jnz       L7846
    xor       eax,	eax
L7843:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_name.resolvedot
mm_name.resolvedot:
;?>>
    %define mm_name.resolvedot.owner 72
    %define mm_name.resolvedot.p 80
   %define R.lhs rdi
   %define R.rhs rbx
   %define R.d rsi
   %define R.e r12
   %define R.t r13
   %define R.m r14
   %define R.moduleno r15
    %define mm_name.resolvedot.subprogno -8
    %define mm_name.resolvedot.oldallowmod -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rax,	[rbp + mm_name.resolvedot.p]
    movzx     rax,	byte [rax+57]
    mov       r15,	rax
    mov       rax,	[rbp + mm_name.resolvedot.p]
    movzx     rax,	byte [rax+58]
    mov       [rbp + mm_name.resolvedot.subprogno],	rax
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rbx,	[rax+24]
    mov       r12,	[rbx+16]
    mov       rax,	[mm_name.allowmodname]
    mov       [rbp + mm_name.resolvedot.oldallowmod],	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    setz      al
    movzx     eax,	al
    mov       [mm_name.allowmodname],	rax
    mov       rcx,	[rbp + mm_name.resolvedot.owner]
    mov       rdx,	rdi
    call      mm_name.rx_unit
    mov       rax,	[rbp + mm_name.resolvedot.oldallowmod]
    mov       [mm_name.allowmodname],	rax
    mov       rsi,	[rdi+16]
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jnz       L7854
L7853:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jz        L7856
    cmp       rax,	5
    jz        L7856
    cmp       rax,	6
    jz        L7856
    cmp       rax,	5
    jz        L7856
    cmp       rax,	11
    jz        L7857
    cmp       rax,	10
    jz        L7857
    cmp       rax,	12
    jz        L7857
    cmp       rax,	2
    jz        L7858
    jmp       L7859
L7856:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jnz       L7861
    movzx     rax,	byte [rsi+95]
    cmp       rax,	[rbp + mm_name.resolvedot.subprogno]
    jnz       L7862
L7861:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_name.finddupl
    mov       r12,	rax
    test      r12,	r12
    jz        L7864
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jnz       L7866
    movzx     rax,	byte [r12+95]
    cmp       rax,	[rbp + mm_name.resolvedot.subprogno]
    jz        L7868
    movzx     rax,	byte [r12+170]
    cmp       rax,	2
    jge       L7870
    movzx     rax,	word [r12+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jnz       L7870
    mov       rax,	[r12]
    lea       rcx,	[L13317]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7870:
    jmp       L7867
L7868:
    movzx     rax,	byte [r12+94]
    cmp       rax,	r15
    jz        L7871
    mov       al,	[r12+170]
    test      al,	al
    jnz       L7873
    mov       rax,	[r12]
    lea       rcx,	[L13318]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7873:
L7871:
L7867:
L7866:
;mm_name.resolvedot.domodule:
L7874:
    mov       al,	4
    mov       r10,	[rbp + mm_name.resolvedot.p]
    mov       [r10],	al
    xor       eax,	eax
    mov       r10,	[rbp + mm_name.resolvedot.p]
    mov       [r10+24],	rax
    mov       r10,	[rbp + mm_name.resolvedot.p]
    mov       [r10+16],	rax
    mov       rax,	r12
    mov       r10,	[rbp + mm_name.resolvedot.p]
    mov       [r10+16],	rax
    movzx     rax,	byte [r12+78]
    cmp       rax,	9
    jnz       L7877
L7876:
L7877:
L7875:
    jmp       L7863
L7864:
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    lea       rcx,	[L13319]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_name.resolvedot.p]
    call      mm_support.rxerror_s
L7863:
    jmp       L7855
L7857:
    movsxd    rax,	dword [rsi+72]
    mov       r14,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L7879
    cmp       rax,	7
    jz        L7880
    jmp       L7881
L7879:
    jmp       L7878
L7880:
L7882:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       r14,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L7885
    cmp       rax,	7
    jz        L7886
    jmp       L7887
L7885:
    jmp       L7883
L7886:
    jmp       L7884
L7887:
    lea       rcx,	[L13320]
    xor       edx,	edx
    call      mm_support.rxerror
L7884:
    jmp       L7882
L7883:
    jmp       L7878
L7881:
    lea       rcx,	[L13321]
    xor       edx,	edx
    call      mm_support.rxerror
L7878:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r14
    mov       r13,	[rax + r10*8]
    mov       rcx,	r13
    mov       rdx,	r12
    call      mm_name.finddupl
    mov       r12,	rax
    test      r12,	r12
    jz        L7889
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rax,	[rax+24]
    mov       r10,	r12
    mov       [rax+16],	r10
    jmp       L7888
L7889:
    mov       rax,	[rbx+16]
    mov       rax,	[rax]
    lea       rcx,	[L13322]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7888:
    jmp       L7855
L7858:
;mm_name.resolvedot.dosubprogid:
L7862:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_name.finddupl_sub
    mov       r12,	rax
    test      r12,	r12
    jz        L7891
    movzx     rax,	byte [r12+95]
    cmp       rax,	[rbp + mm_name.resolvedot.subprogno]
    jz        L7893
    movzx     rax,	byte [r12+170]
    cmp       rax,	2
    jge       L7895
    movzx     rax,	word [r12+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jnz       L7895
    mov       rax,	[r12]
    lea       rcx,	[L13323]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7895:
L7893:
    jmp       L7874
L7891:
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    lea       rcx,	[L13324]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_name.resolvedot.p]
    call      mm_support.rxerror_s
L7890:
L7859:
L7855:
    jmp       L7852
L7854:
    mov       rax,	[r12+40]
    test      rax,	rax
    jnz       L7897
    mov       rax,	[r12]
    lea       rcx,	[L13325]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7897:
L7852:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.fixmode
mm_name.fixmode:
;?>>
    %define mm_name.fixmode.p 64
   %define R.pmode rdi
   %define R.a rbx
   %define R.d rsi
   %define R.e r12
   %define R.owner r13
   %define R.m r14
    %define mm_name.fixmode.moduleno -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + mm_name.fixmode.p]
    mov       rdi,	[rax+24]
    movsxd    rax,	dword [rdi]
    neg       rax
    mov       r14,	rax
    mov       rax,	[rbp + mm_name.fixmode.p]
    mov       rax,	[rax]
    mov       r13,	rax
    mov       rsi,	rax
    jmp       L7900
L7899:
    mov       rsi,	[rsi+8]
L7900:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jnz       L7899
    movzx     rax,	byte [rsi+94]
    mov       [rbp + mm_name.fixmode.moduleno],	rax
    mov       rax,	[rbp + mm_name.fixmode.p]
    mov       rbx,	[rax+8]
    mov       rax,	[rbp + mm_name.fixmode.p]
    mov       rsi,	[rax+16]
    test      rbx,	rbx
    jnz       L7903
    test      rsi,	rsi
    jz        L7903
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	[rbp + mm_name.fixmode.moduleno]
    xor       r9d,	r9d
    call      mm_name.resolvetopname
    mov       r12,	rax
L7903:
    test      r12,	r12
    jz        L7905
    movzx     rax,	byte [r12+78]
    cmp       rax,	5
    jnz       L7905
    mov       eax,	[r12+72]
    mov       [rdi],	eax
    jmp       L7904
L7905:
    mov       rax,	[rsi]
    lea       rcx,	[L13326]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7904:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.fixusertypes
mm_name.fixusertypes:
;?>>
   %define R.p rdi
   %define R.npasses rbx
   %define R.notresolved rsi
   %define R.d r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    xor       rbx,	rbx
L7907:
    inc       rbx
    xor       rsi,	rsi
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mm_decls.ntypenames]
    cmp       rax,	1
    jl        L7912
L7910:
    lea       rax,	[mm_decls.typenames]
    mov       r10,	r13
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       rdi,	rax
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax]
    cmp       rax,	0
    jge       L7914
    lea       rax,	[mm_decls.typenamepos]
    mov       r10,	r13
    lea       rax,	[rax + r10*4]
    mov       eax,	[rax]
    mov       [pc_decls.mmpos],	rax
    mov       rcx,	rdi
    call      mm_name.fixmode
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax]
    cmp       rax,	0
    jge       L7916
    inc       rsi
L7916:
L7914:
    inc       r13
    cmp       r13,	[mm_decls.ntypenames]
    jle       L7910
L7912:
    cmp       rbx,	5
    jle       L7918
    call      msys.m$print_startcon
    lea       rcx,	[L13327]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r13,	1
    mov       rax,	[mm_decls.ntypenames]
    cmp       rax,	1
    jl        L7921
L7919:
    lea       rax,	[mm_decls.typenames]
    mov       r10,	r13
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       rdi,	rax
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax]
    cmp       rax,	0
    jge       L7923
    mov       r12,	[rdi+16]
    test      r12,	r12
    jnz       L7925
    mov       r12,	[rdi+8]
L7925:
    call      msys.m$print_startcon
    lea       rcx,	[L13328]
    call      msys.m$print_str_nf
    mov       rcx,	[r12]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L7923:
    inc       r13
    cmp       r13,	[mm_decls.ntypenames]
    jle       L7919
L7921:
    lea       rcx,	[L13329]
    xor       edx,	edx
    call      mm_support.rxerror
L7918:
    test      rsi,	rsi
    jnz       L7907
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.addframevar
mm_name.addframevar:
;?>>
   %define R.owner rbx
   %define R.d rsi
    %define mm_name.addframevar.moduleno 64
   %define R.mode r12
   %define R.e rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r9
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	11
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    lea       rax,	[rdi+72]
    mov       rcx,	rbx
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_lib.adddef
    mov       rax,	rdi
L7926:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.copylistunit
mm_name.copylistunit:
;?>>
   %define R.p rbx
   %define R.q rdi
    %define mm_name.copylistunit.plist -8
    %define mm_name.copylistunit.plistx -16
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + mm_name.copylistunit.plistx],	rax
    mov       [rbp + mm_name.copylistunit.plist],	rax
    jmp       L7929
L7928:
    mov       rcx,	rbx
    call      mm_name.copyunit
    mov       rdi,	rax
    lea       rcx,	[rbp + mm_name.copylistunit.plist]
    lea       rdx,	[rbp + mm_name.copylistunit.plistx]
    mov       r8,	rdi
    call      mm_lib.addlistunit
    mov       rbx,	[rbx+8]
L7929:
    test      rbx,	rbx
    jnz       L7928
    mov       rax,	[rbp + mm_name.copylistunit.plist]
L7927:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.copyunit
mm_name.copyunit:
;?>>
   %define R.p r13
   %define R.q rdi
   %define R.d rbx
   %define R.av_1 rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    test      r13,	r13
    jnz       L7933
    xor       eax,	eax
    jmp       L7931
L7933:
    movzx     rax,	byte [r13]
    cmp       rax,	4
    jnz       L7935
    mov       rbx,	[r13+16]
    mov       r12,	1
    mov       rax,	[mm_name.nmacroparams]
    cmp       rax,	1
    jl        L7938
L7936:
    lea       rax,	[mm_name.macroparamsgen]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    cmp       rax,	rbx
    jnz       L7940
    lea       rax,	[mm_name.macroargs]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mm_name.copyunit
    jmp       L7931
L7940:
    inc       r12
    cmp       r12,	[mm_name.nmacroparams]
    jle       L7936
L7938:
L7935:
    movzx     rax,	byte [r13]
    mov       rcx,	rax
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       rax,	r13
    push      rdi
    mov       r11,	8
L13330:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L13330
    mov       r10b,	[rax]
    mov       [rdi],	r10b
    pop       rdi
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       r12,	1
    movzx     rax,	byte [rdi]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       rsi,	r10
    cmp       rsi,	1
    jl        L7943
L7941:
    lea       rax,	[rdi+16]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mm_name.copylistunit
    lea       r10,	[rdi+16]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    inc       r12
    cmp       r12,	rsi
    jle       L7941
L7943:
    mov       rax,	rdi
L7931:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.replaceunit
mm_name.replaceunit:
;?>>
   %define R.p rcx
   %define R.q rdx
   %define R.pnext rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rdi,	[rcx+8]
    mov       rax,	rdx
    push      rcx
    mov       r11,	8
L13331:
    mov       r10,	[rax]
    mov       [rcx],	r10
    add       rcx,	8
    add       rax,	8
    dec       r11
    jnz       L13331
    mov       r10b,	[rax]
    mov       [rcx],	r10b
    pop       rcx
    mov       [rcx+8],	rdi
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_name.expandmacro
mm_name.expandmacro:
;?>>
   %define R.p r13
   %define R.a r14
   %define R.b r15
   %define R.d rdi
   %define R.pm rbx
   %define R.pnew rsi
   %define R.ignoreargs r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rax,	[mm_name.macrolevels]
    cmp       rax,	10
    jle       L7947
    lea       rcx,	[L13332]
    xor       edx,	edx
    call      mm_support.rxerror
L7947:
    mov       rdi,	[r14+16]
    mov       rbx,	[rdi+112]
    xor       eax,	eax
    mov       [mm_name.nmacroparams],	rax
    jmp       L7949
L7948:
    mov       rax,	[mm_name.nmacroparams]
    cmp       rax,	50
    jl        L7952
    lea       rcx,	[L13333]
    xor       edx,	edx
    call      mm_support.rxerror
L7952:
    inc       qword [mm_name.nmacroparams]
    mov       rax,	[mm_name.nmacroparams]
    mov       r10,	rbx
    lea       r11,	[mm_name.macroparams]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[rbx+48]
    lea       r10,	[mm_name.macroparamsgen]
    mov       r11,	[mm_name.nmacroparams]
    mov       [r10 + r11*8-8],	rax
    mov       rbx,	[rbx+152]
L7949:
    test      rbx,	rbx
    jnz       L7948
    xor       eax,	eax
    mov       [mm_name.nmacroargs],	rax
    jmp       L7954
L7953:
    mov       rax,	[mm_name.nmacroargs]
    cmp       rax,	50
    jl        L7957
    lea       rcx,	[L13334]
    xor       edx,	edx
    call      mm_support.rxerror
L7957:
    inc       qword [mm_name.nmacroargs]
    mov       rax,	[mm_name.nmacroargs]
    mov       r10,	r15
    lea       r11,	[mm_name.macroargs]
    mov       [r11 + rax*8-8],	r10
    mov       r15,	[r15+8]
L7954:
    test      r15,	r15
    jnz       L7953
    mov       rax,	[mm_name.nmacroargs]
    cmp       rax,	[mm_name.nmacroparams]
    jge       L7959
    call      msys.m$print_startcon
    lea       rcx,	[L13335]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_name.nmacroargs]
    call      msys.m$print_i64_nf
    mov       rcx,	[mm_name.nmacroparams]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13336]
    xor       edx,	edx
    call      mm_support.rxerror
L7959:
    xor       r12,	r12
    mov       rax,	[mm_name.nmacroargs]
    cmp       rax,	0
    jle       L7961
    mov       rax,	[mm_name.nmacroparams]
    test      rax,	rax
    jnz       L7961
    mov       r12,	1
    xor       eax,	eax
    mov       [mm_name.nmacroparams],	rax
    mov       [mm_name.nmacroargs],	rax
    jmp       L7960
L7961:
    mov       rax,	[mm_name.nmacroargs]
    cmp       rax,	[mm_name.nmacroparams]
    jle       L7962
    lea       rcx,	[L13337]
    xor       edx,	edx
    call      mm_support.rxerror
L7962:
L7960:
    mov       rax,	[rdi+64]
    mov       rcx,	rax
    call      mm_name.copyunit
    mov       rsi,	rax
    test      r12,	r12
    jnz       L7964
    mov       rcx,	r13
    mov       rdx,	rsi
    call      mm_name.replaceunit
    jmp       L7963
L7964:
    mov       [r13+16],	rsi
L7963:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.duplfield
mm_name.duplfield:
;?>>
   %define R.owner rdi
   %define R.p rbx
   %define R.q rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rax,	[rbx+64]
    test      rax,	rax
    jz        L7967
    lea       rcx,	[L13338]
    call      mm_support.serror
L7967:
    movzx     rax,	word [rbx+92]
    shr       eax,	7
    and       eax,	1
    lea       r10,	[rsi+92]
    and       byte [r10],	127
    shl       al,	7
    or        [r10],	al
    mov       ax,	[rbx+92]
    mov       [rsi+92],	ax
    mov       rax,	[rbx+136]
    mov       [rsi+136],	rax
    lea       rax,	[rsi+72]
    movsxd    r10,	dword [rbx+72]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.do_baseclass
mm_name.do_baseclass:
;?>>
   %define R.p r14
   %define R.d rdi
   %define R.e rbx
   %define R.newd rsi
   %define R.dbase r12
   %define R.normalexit r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    movsxd    rax,	dword [r14+144]
    lea       r10,	[mm_decls.ttnamedef]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    mov       rdi,	[r12+16]
    jmp       L7970
L7969:
    mov       rbx,	[r14+16]
    mov       r13,	1
    jmp       L7973
L7972:
    mov       rax,	[rbx]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7976
    xor       r13,	r13
    jmp       L7974
L7976:
    mov       rbx,	[rbx+32]
L7973:
    test      rbx,	rbx
    jnz       L7972
L7974:
    test      r13,	r13
    jz        L7978
    movzx     rax,	byte [rdi+78]
    cmp       rax,	6
    jz        L7980
    cmp       rax,	17
    jnz       L7981
L7980:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	17
    call      mm_lib.getduplnameptr
    mov       rsi,	rax
    mov       [rsi+128],	rdi
    jmp       L7979
L7981:
    movzx     rax,	byte [rdi+78]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.getduplnameptr
    mov       rsi,	rax
    mov       rax,	[r14+8]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mm_name.duplfield
L7979:
    mov       rcx,	r14
    mov       rdx,	rsi
    call      mm_lib.adddef
L7978:
    mov       rdi,	[rdi+32]
L7970:
    test      rdi,	rdi
    jnz       L7969
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.parsemodule
mm_parse.parsemodule:
;?>>
   %define R.pm rbx
   %define R.owner rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mm_parse.initparser
    movsx     rax,	word [rbx+16]
    mov       [mm_decls.currmoduleno],	rax
    mov       rax,	[rbx+24]
    mov       [mm_decls.stmodule],	rax
    mov       rax,	[mm_decls.stmodule]
    mov       [mm_decls.currproc],	rax
    mov       rcx,	[rbx+8]
    call      mm_lex.startlex
    mov       rdi,	[mm_decls.stmodule]
    call      mm_lex.lex
    mov       rcx,	rdi
    call      mm_parse.readmoduledefs
    mov       rax,	1
L7982:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readmoduledefs
mm_parse.readmoduledefs:
;?>>
   %define R.owner rbx
   %define R.globalflag rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    xor       rdi,	rdi
L7984:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    sub       rax,	1
    cmp       rax,	132
    jae       L7988
    lea       r10,	[L7987]
    jmp       [r10 + rax*8]
    segment .data
L7987:
    dq  L8015
    dq  L7988
    dq  L7988
    dq  L8003
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7995
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L8004
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L8016
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7995
    dq  L7995
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7994
    dq  L7994
    dq  L7988
    dq  L8001
    dq  L7988
    dq  L7988
    dq  L7998
    dq  L8006
    dq  L7999
    dq  L7995
    dq  L7988
    dq  L7988
    dq  L7997
    dq  L7995
    dq  L8005
    dq  L8000
    dq  L7988
    dq  L8011
    dq  L7989
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L7988
    dq  L8002
    segment .text
L7989:
    test      rdi,	rdi
    jz        L7991
    lea       rcx,	[L13339]
    call      mm_support.serror
L7991:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rdi,	rax
    cmp       rdi,	3
    jnz       L7993
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+95]
    cmp       rax,	[mm_decls.nsubprogs]
    jz        L7993
    mov       rdi,	2
L7993:
    call      mm_lex.lex
    jmp       L7986
L7994:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readprocdef
    xor       rdi,	rdi
    jmp       L7986
L7995:
;mm_parse.readmoduledefs.dovar:
L7996:
    sub       rsp,	8
    push      0
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    mov       r9,	10
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    xor       rdi,	rdi
    jmp       L7986
L7997:
    call      mm_lex.lex
    sub       rsp,	8
    push      120
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    mov       r9,	10
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    xor       rdi,	rdi
    jmp       L7986
L7998:
    mov       rcx,	rbx
    call      mm_parse.readimportmodule
    jmp       L7986
L7999:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readtypedef
    xor       rdi,	rdi
    jmp       L7986
L8000:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readconstdef
    xor       rdi,	rdi
    jmp       L7986
L8001:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readclassdef
    xor       rdi,	rdi
    jmp       L7986
L8002:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readtabledef
    xor       rdi,	rdi
    jmp       L7986
L8003:
    call      mm_lex.lex
    jmp       L7986
L8004:
    jmp       L7985
L8005:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readmacrodef
    xor       rdi,	rdi
    jmp       L7986
L8006:
L8007:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	87
    jz        L8010
    cmp       rax,	59
    jnz       L8007
L8010:
    mov       rcx,	87
    mov       rdx,	115
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    jmp       L7986
L8011:
L8012:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L8012
    jmp       L7986
L8015:
    lea       rcx,	[L13340]
    call      mm_support.serror
    jmp       L7986
L8016:
    call      mm_parse.istypestarter
    test      rax,	rax
    jnz       L7996
L8018:
    jmp       L8019
L7988:
;mm_parse.readmoduledefs.doexec:
L8019:
    lea       rcx,	[L13341]
    call      mm_support.serror
L7986:
    jmp       L7984
L7985:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.initparser
mm_parse.initparser:
;?>>
   %define R.tabledataname rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mm_decls.nullunit]
    test      rax,	rax
    jnz       L8022
    mov       rcx,	2
    call      mm_lib.createunit0
    mov       [mm_decls.nullunit],	rax
L8022:
    xor       eax,	eax
    mov       [mm_decls.currproc],	rax
    xor       eax,	eax
    mov       [mm_parse.varattribs],	rax
    xor       eax,	eax
    mov       [mm_parse.intabledata],	rax
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    xor       eax,	eax
    mov       [mm_parse.inparamlist],	rax
    xor       eax,	eax
    mov       [mm_parse.inrecordbody],	rax
    xor       eax,	eax
    mov       [mm_parse.inimportmodule],	rax
    lea       rax,	[L13342]
    mov       rdi,	rax
    xor       eax,	eax
    mov       [mm_parse.labelseen],	rax
    xor       eax,	eax
    mov       [mm_parse.ndollar],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.skipsemi
mm_parse.skipsemi:
;?>>
;?]]
    sub       rsp,	40
;---------------
    jmp       L8025
L8024:
    call      mm_lex.lex
L8025:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L8024
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_parse.makeblock
mm_parse.makeblock:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L8029
    movzx     rax,	byte [rdi]
    cmp       rax,	6
    jnz       L8029
    mov       rax,	rdi
    jmp       L8027
L8029:
    mov       rcx,	6
    mov       rdx,	rdi
    call      mm_lib.createunit1
L8027:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.checkequals
mm_parse.checkequals:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8032
    lea       rcx,	[L13343]
    call      mm_support.serror
L8032:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_parse.getcurrline
mm_parse.getcurrline:
;?>>
;?]]
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
L8033:
;---------------
    ret       
;End 
;Proc mm_parse.checkbegin
mm_parse.checkbegin:
;?>>
   %define R.fbrack rbx
   %define R.closesym rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8036
    test      rbx,	rbx
    jz        L8036
    mov       rdi,	10
    call      mm_lex.lex
    jmp       L8035
L8036:
    mov       rdi,	87
L8035:
    mov       rax,	rdi
L8034:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.checkbeginend
mm_parse.checkbeginend:
;?>>
   %define R.closesym rdi
   %define R.kwd rbx
   %define R.startline rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    call      mm_parse.skipsemi
    cmp       rdi,	10
    jnz       L8039
    mov       rcx,	rdi
    call      mm_parse.checksymbollex
    jmp       L8038
L8039:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	rsi
    call      mm_parse.checkend
L8038:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.checkend
mm_parse.checkend:
;?>>
   %define R.endsym rdi
   %define R.endkwd1 rbx
   %define R.endkwd2 rsi
   %define R.startline r12
    %define mm_parse.checkend.str -104
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	144
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	rdi
    jnz       L8042
    cmp       rax,	10
    jz        L8040
L8042:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	87
    jz        L8044
    lea       rcx,	[L13344]
    call      mm_support.serror
L8044:
    lea       rax,	[mm_decls.lx]
    mov       al,	[rax+1]
    test      al,	al
    jz        L8046
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	rbx
    jz        L8049
    cmp       rax,	rsi
    jnz       L8048
L8049:
    call      mm_lex.lex
    jmp       L8040
L8048:
;mm_parse.checkend.error:
    lea       rcx,	[rbp + mm_parse.checkend.str]
    lea       rdx,	[L13345]
    call      strcpy
    test      r12,	r12
    jz        L8052
    lea       rcx,	[rbp + mm_parse.checkend.str]
    call      strlen
    lea       r10,	[rbp + rax + mm_parse.checkend.str]
    mov       rcx,	r10
    call      msys.m$print_startstr
    lea       rcx,	[L13346]
    call      msys.m$print_setfmt
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L8052:
    lea       rcx,	[rbp + mm_parse.checkend.str]
    call      mm_support.serror
L8047:
L8046:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	rbx
    jz        L8055
    cmp       rax,	rsi
    jnz       L8054
L8055:
    call      mm_lex.lex
L8054:
L8040:
;---------------
    add       rsp,	144
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readvardef
mm_parse.readvardef:
;?>>
   %define R.owner r13
   %define R.scope r14
    %define mm_parse.readvardef.isstatic 80
    %define mm_parse.readvardef.varid 88
    %define mm_parse.readvardef.k 96
    %define mm_parse.readvardef.ulist -8
    %define mm_parse.readvardef.ulistx -16
   %define R.p rdi
   %define R.nvars rbx
   %define R.m rsi
   %define R.initcode r12
    %define mm_parse.readvardef.stname -24
    %define mm_parse.readvardef.$T1 -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mm_parse.readvardef.ulistx],	rax
    mov       [rbp + mm_parse.readvardef.ulist],	rax
    call      mm_parse.istypestarter
    test      rax,	rax
    jz        L8058
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rsi,	rax
    jmp       L8057
L8058:
    lea       rcx,	[L13347]
    call      mm_support.serror
L8057:
    xor       rbx,	rbx
    jmp       L8060
L8059:
    inc       rbx
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readvardef.varid]
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readvardef.stname],	rax
    mov       al,	r14b
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+170],	al
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    lea       rax,	[rax+92]
    mov       r10b,	[rbp + mm_parse.readvardef.isstatic]
    and       byte [rax],	254
    or        [rax],	r10b
    mov       rax,	[rbp + mm_parse.readvardef.k]
    cmp       rax,	120
    setz      al
    movzx     eax,	al
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    lea       r10,	[r10+92]
    and       byte [r10],	239
    shl       al,	4
    or        [r10],	al
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	8
    jnz       L8063
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    lea       rax,	[rax+92]
    or        byte [rax+1],	8
L8063:
    mov       rcx,	r13
    mov       rdx,	[rbp + mm_parse.readvardef.stname]
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	10
    jnz       L8065
    mov       rcx,	[rbp + mm_parse.readvardef.stname]
    call      mm_lib.addstatic
L8065:
    call      mm_lex.lex
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    lea       rax,	[rax+72]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jz        L8068
    cmp       rax,	41
    jnz       L8067
L8068:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8070
    cmp       rax,	6
    jz        L8071
    jmp       L8072
L8070:
    mov       r12,	1
    jmp       L8069
L8071:
    mov       r12,	2
    jmp       L8069
L8072:
    mov       r12,	3
L8069:
    mov       ax,	1
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+168],	ax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8074
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	10
    jnz       L8076
    lea       rcx,	[L13348]
    call      mm_support.serror
    movzx     rax,	byte [r13+78]
    cmp       rax,	6
    jnz       L8078
    lea       rcx,	[L13349]
    call      mm_support.serror
L8078:
L8076:
    jmp       L8073
L8074:
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	11
    jnz       L8080
    lea       rcx,	[L13350]
    call      mm_support.serror
    mov       rcx,	[rbp + mm_parse.readvardef.stname]
    call      mm_lib.addstatic
L8080:
L8073:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+64],	rax
    mov       al,	r12b
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+171],	al
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	11
    jnz       L8082
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    mov       rax,	[rax+64]
    mov       [rbp + mm_parse.readvardef.$T1],	rax
    mov       rcx,	[rbp + mm_parse.readvardef.stname]
    call      mm_lib.createname
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readvardef.$T1]
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+59],	al
    lea       rcx,	[rbp + mm_parse.readvardef.ulist]
    lea       rdx,	[rbp + mm_parse.readvardef.ulistx]
    mov       r8,	rdi
    call      mm_lib.addlistunit
L8082:
    jmp       L8066
L8067:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8083
    mov       rax,	[rbp + mm_parse.readvardef.k]
    cmp       rax,	120
    jnz       L8085
    lea       rcx,	[L13351]
    call      mm_support.serror
L8085:
    call      mm_lex.lex
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    lea       rax,	[rax+92]
    or        byte [rax+1],	1
    call      mm_parse.readunit
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+96],	rax
    jmp       L8066
L8083:
    mov       rax,	[rbp + mm_parse.readvardef.k]
    cmp       rax,	120
    jnz       L8086
    lea       rcx,	[L13352]
    call      mm_support.serror
L8086:
L8066:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8061
L8088:
    call      mm_lex.lex
L8060:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jz        L8059
L8061:
    test      rbx,	rbx
    jnz       L8090
    lea       rcx,	[L13353]
    call      mm_support.serror
L8090:
    mov       rax,	[rbp + mm_parse.readvardef.ulist]
L8056:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readconstdef
mm_parse.readconstdef:
;?>>
   %define R.owner r13
   %define R.scope r14
   %define R.nconsts rdi
   %define R.deft rbx
   %define R.m rsi
   %define R.stname r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    call      mm_lex.lex
    xor       rdi,	rdi
    call      mm_parse.istypestarter
    test      rax,	rax
    jz        L8093
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
    jmp       L8092
L8093:
    mov       rbx,	22
L8092:
    jmp       L8095
L8094:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	9
    call      mm_lib.getduplnameptr
    mov       r12,	rax
    call      mm_lex.lex
    call      mm_parse.checkequals
    call      mm_lex.lex
    mov       rcx,	1
    call      mm_parse.readconstexpr
    mov       [r12+64],	rax
    mov       rsi,	rbx
    lea       rax,	[r12+72]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    inc       rdi
    mov       [r12+170],	r14b
    mov       rcx,	r13
    mov       rdx,	r12
    call      mm_lib.adddef
    cmp       r14,	3
    jnz       L8098
    mov       rax,	[r12]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L8098
    mov       rcx,	r12
    call      mm_lib.addexpconst
L8098:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8096
L8100:
    call      mm_lex.lex
L8095:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jz        L8094
L8096:
    test      rdi,	rdi
    jnz       L8102
    lea       rcx,	[L13354]
    call      mm_support.serror
L8102:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readlbrack
mm_parse.readlbrack:
;?>>
    %define mm_parse.readlbrack.ulist -8
    %define mm_parse.readlbrack.ulistx -16
   %define R.p rdi
   %define R.q rbx
   %define R.r rsi
   %define R.plower r12
   %define R.oldirp r13
   %define R.length r14
    %define mm_parse.readlbrack.usecomma -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readlbrack.ulistx],	rax
    mov       [rbp + mm_parse.readlbrack.ulist],	rax
    xor       r12,	r12
    xor       eax,	eax
    mov       r14,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8105
    call      mm_lex.lex
    mov       r13,	[mm_parse.inreadprint]
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
    call      mm_parse.readunit
    mov       r12,	rax
    mov       [mm_parse.inreadprint],	r13
    mov       rcx,	5
    call      mm_parse.checksymbollex
    jmp       L8104
L8105:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L8106
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8106
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.createconstunit
    mov       r12,	rax
    call      mm_lex.lex
    call      mm_lex.lex
    jmp       L8104
L8106:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symboloptypes]
    movzx     r10,	byte [r10 + rax-1]
    cmp       r10,	1
    jnz       L8107
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8107
    mov       rcx,	63
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       [rdi+40],	ax
    call      mm_lex.lex
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8103
L8107:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symboloptypes]
    movzx     r10,	byte [r10 + rax-1]
    cmp       r10,	1
    jnz       L8108
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8108
    mov       rcx,	63
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symbolgentoops]
    mov       r10b,	[r10 + rax-1]
    mov       [rdi+62],	r10b
    call      mm_lex.lex
    mov       rcx,	10
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8103
L8108:
L8104:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8111
L8110:
    call      mm_lex.lex
    mov       rcx,	20
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       [rdi+24],	r12
    xor       eax,	eax
    mov       [rdi+40],	eax
    mov       rax,	rdi
    jmp       L8103
L8111:
    call      mm_parse.readunit
    mov       rdi,	rax
L8109:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8113
    cmp       rax,	3
    jz        L8114
    cmp       rax,	16
    jz        L8115
    cmp       rax,	4
    jz        L8116
    jmp       L8117
L8113:
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8103
L8114:
    mov       rax,	1
    mov       [rbp + mm_parse.readlbrack.usecomma],	rax
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8119
    call      mm_lex.lex
    call      mm_lex.lex
    mov       rcx,	20
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       eax,	1
    mov       [rdi+40],	eax
    mov       [rdi+24],	r12
    mov       rax,	rdi
    jmp       L8103
L8119:
;mm_parse.readlbrack.docomma:
L8120:
    mov       r14,	1
    mov       rax,	rdi
    mov       [rbp + mm_parse.readlbrack.ulistx],	rax
    mov       [rbp + mm_parse.readlbrack.ulist],	rax
    mov       rax,	[rbp + mm_parse.readlbrack.usecomma]
    test      rax,	rax
    jz        L8122
L8123:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8125
L8127:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8129
    lea       rcx,	[L13355]
    call      mm_support.serror
L8129:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    inc       r14
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8123
L8125:
    jmp       L8121
L8122:
L8130:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8132
L8134:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8136
    lea       rcx,	[L13355]
    call      mm_support.serror
L8136:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    inc       r14
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L8130
L8132:
L8121:
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	20
    mov       rdx,	[rbp + mm_parse.readlbrack.ulist]
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+40],	r14d
    mov       [rdi+24],	r12
    mov       rax,	rdi
    jmp       L8103
L8115:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	16
    jz        L8138
    cmp       rax,	10
    jz        L8139
    jmp       L8140
L8138:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rsi,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	rdi
    call      mm_parse.fixcond
    mov       rcx,	92
    mov       rdx,	rax
    mov       r8,	rbx
    mov       r9,	rsi
    call      mm_lib.createunit3
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+48],	al
    mov       rax,	rdi
    jmp       L8103
L8139:
    call      mm_lex.lex
    mov       rcx,	rdi
    call      mm_parse.fixcond
    mov       rcx,	92
    mov       rdx,	rax
    mov       r8,	rbx
    xor       r9d,	r9d
    call      mm_lib.createunit3
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+48],	al
    mov       rax,	rdi
    jmp       L8103
L8140:
L8137:
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rbx
    call      mm_lib.addlistunit
    mov       rcx,	3
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	16
    jz        L8142
L8143:
    call      mm_lex.lex
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8143
    mov       rcx,	16
    call      mm_parse.checksymbol
    jmp       L8141
L8142:
    call      mm_lex.lex
L8141:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rsi,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	112
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_parse.readlbrack.ulist]
    mov       r9,	rsi
    call      mm_lib.createunit3
    jmp       L8103
L8116:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L8147
    xor       eax,	eax
    mov       [rbp + mm_parse.readlbrack.usecomma],	rax
    jmp       L8120
L8147:
    mov       rax,	rdi
    mov       [rbp + mm_parse.readlbrack.ulistx],	rax
    mov       [rbp + mm_parse.readlbrack.ulist],	rax
L8148:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8150
L8152:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L8148
L8150:
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	[rbp + mm_parse.readlbrack.ulist]
    call      mm_parse.makeblock
    jmp       L8103
L8117:
    lea       rcx,	[L13356]
    call      mm_support.serror
L8112:
    xor       eax,	eax
L8103:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.addlistparam
mm_parse.addlistparam:
;?>>
   %define R.ulist rcx
   %define R.ulistx rdx
   %define R.p r8
;?]]
;---------------
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L8155
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L8154
L8155:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+152],	r10
L8154:
    mov       [rdx],	r8
;---------------
    ret       
;End 
;Proc mm_parse.readcast
mm_parse.readcast:
;?>>
   %define R.p rdi
   %define R.opc rbx
   %define R.t rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8158
    cmp       rax,	17
    jz        L8159
    cmp       rax,	1
    jz        L8160
    jmp       L8161
L8158:
    mov       rcx,	62
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       eax,	26
    mov       [rdi+49],	eax
    mov       [rdi+16],	rsi
    mov       rax,	rdi
    jmp       L8156
L8159:
    mov       rbx,	61
    call      mm_lex.lex
    jmp       L8157
L8160:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	116
    jnz       L8163
    call      mm_lex.lex
    mov       rcx,	62
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       [rdi+16],	rsi
    mov       eax,	26
    mov       [rdi+49],	eax
    call      mm_lex.lex
    jmp       L8162
L8163:
    mov       rcx,	62
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       [rdi+16],	rsi
L8162:
    mov       rax,	rdi
    jmp       L8156
L8161:
    mov       rbx,	58
L8157:
    mov       rcx,	9
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rdi,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    lea       rax,	[rdi+53]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rdi
L8156:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readopc
mm_parse.readopc:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.r rsi
   %define R.tag r12
   %define R.opc r13
   %define R.firstsym r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       r14,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	55
    jz        L8166
    cmp       rax,	56
    jz        L8167
    jmp       L8168
L8166:
    mov       r12,	36
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r13,	rax
    jmp       L8165
L8167:
    mov       r12,	35
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r13,	rax
    jmp       L8165
L8168:
    mov       r12,	36
    lea       rax,	[mm_tables.symbolgenops]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    mov       r13,	rax
L8165:
    call      mm_lex.lex
    mov       rax,	r14
    cmp       rax,	24
    jz        L8170
    cmp       rax,	25
    jz        L8171
    cmp       rax,	36
    jz        L8172
    cmp       rax,	37
    jz        L8172
    cmp       rax,	56
    jz        L8172
    cmp       rax,	31
    jz        L8172
    cmp       rax,	32
    jz        L8172
    cmp       rax,	33
    jz        L8172
    jmp       L8173
L8170:
    call      mm_parse.readterm2
    jmp       L8164
L8171:
    mov       r13,	60
    jmp       L8169
L8172:
    call      mm_parse.readterm2
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	20
    jnz       L8175
    mov       eax,	[rdi+40]
    cmp       rax,	2
    jz        L8177
    lea       rcx,	[L13357]
    call      mm_support.serror
L8177:
    mov       rbx,	[rdi+16]
    mov       rsi,	[rbx+8]
    xor       eax,	eax
    mov       [rbx+8],	rax
    mov       rcx,	35
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+62],	r13b
    mov       rax,	rdi
    jmp       L8164
L8175:
    lea       rcx,	[L13358]
    call      mm_support.serror
    mov       rcx,	r13
    mov       rdx,	rdi
    call      mm_lib.createunit1
    jmp       L8164
L8174:
    jmp       L8169
L8173:
    lea       rax,	[mm_tables.symboloptypes]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L8179
    lea       rcx,	[L13359]
    call      mm_support.serror
L8179:
L8169:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8181
    call      mm_lex.lex
    mov       r12,	39
    cmp       r14,	25
    jnz       L8184
L8183:
    mov       r13,	105
    jmp       L8182
L8184:
    lea       rax,	[mm_tables.symbolgentoops]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    mov       r13,	rax
    test      r13,	r13
    jnz       L8186
    lea       rcx,	[L13360]
    call      mm_support.serror
L8186:
L8182:
L8181:
    call      mm_parse.readterm2
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	r12
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+62],	r13b
    movzx     rax,	byte [rbx]
    cmp       rax,	20
    jnz       L8188
    lea       rcx,	[L13361]
    call      mm_support.serror
L8188:
    mov       rax,	rdi
L8164:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readcompilervar
mm_parse.readcompilervar:
;?>>
    %define mm_parse.readcompilervar.str -104
    %define mm_parse.readcompilervar.tm -120
   %define R.p rdi
   %define R.currmodule rbx
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
;---------------
    lea       rax,	[mm_decls.modules]
    mov       r10,	[mm_decls.currmoduleno]
    mov       rbx,	[rax + r10*8]
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    sub       rax,	71
    cmp       rax,	14
    jae       L8192
    lea       r10,	[L8191]
    jmp       [r10 + rax*8]
    segment .data
L8191:
    dq  L8196
    dq  L8197
    dq  L8198
    dq  L8199
    dq  L8200
    dq  L8201
    dq  L8202
    dq  L8203
    dq  L8192
    dq  L8193
    dq  L8194
    dq  L8195
    dq  L8204
    dq  L8204
    segment .text
L8193:
    xor       ecx,	ecx
    mov       rdx,	7
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8189
L8194:
    movq      XMM4,	[L13362]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8189
L8195:
    movq      XMM4,	[L13363]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8189
L8196:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       rcx,	rax
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8189
L8197:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_parse.readcompilervar.str]
    call      msys.getstrint
    jmp       L8190
L8198:
    mov       rax,	[mm_decls.stmodule]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L8190
L8199:
    movsx     rax,	word [rbx+20]
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+24]
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    mov       rdx,	r10
    call      strcpy
    jmp       L8190
L8200:
    mov       rax,	[mm_decls.currproc]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L8190
L8201:
    lea       rcx,	[rbp + mm_parse.readcompilervar.tm]
    call      mwindows.os_getsystime
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13364]
    call      msys.m$print_setfmt
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+6]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+2]
    lea       r10,	[mm_parse.readcompilervar.monthnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm]
    mov       rcx,	rax
    lea       rdx,	[L13365]
    call      msys.m$print_i64
    call      msys.m$print_end
    jmp       L8190
L8202:
    lea       rcx,	[rbp + mm_parse.readcompilervar.tm]
    call      mwindows.os_getsystime
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13366]
    call      msys.m$print_setfmt
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+8]
    mov       rcx,	rax
    lea       rdx,	[L13367]
    call      msys.m$print_i64
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+10]
    mov       rcx,	rax
    lea       rdx,	[L13367]
    call      msys.m$print_i64
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+12]
    mov       rcx,	rax
    lea       rdx,	[L13367]
    call      msys.m$print_i64
    call      msys.m$print_end
    jmp       L8190
L8203:
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    lea       rdx,	[L13368]
    call      strcpy
    jmp       L8190
L8204:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	83
    setz      al
    movzx     eax,	al
    mov       rcx,	rax
    mov       rdx,	6
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8189
L8192:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L13369]
    mov       rdx,	r10
    call      mm_support.serror_s
L8190:
    call      mm_lex.lex
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    mov       rdx,	-1
    call      mm_lib.createstringconstunit
L8189:
;---------------
    add       rsp,	160
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readcastx
mm_parse.readcastx:
;?>>
   %define R.opc rdi
   %define R.m rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    call      mm_lex.lex
    mov       rdi,	58
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8207
    mov       rdi,	61
    call      mm_lex.lex
L8207:
    mov       rcx,	9
    call      mm_parse.checksymbollex
    xor       rbx,	rbx
    call      mm_parse.readunit
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8209
    cmp       rdi,	61
    jnz       L8211
    lea       rcx,	[L13370]
    call      mm_support.serror
L8211:
    mov       rdi,	60
    jmp       L8208
L8209:
    call      mm_lex.lex
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
L8208:
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_lib.createunit1
    mov       rsi,	rax
    lea       rax,	[rsi+53]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rsi
L8205:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.checksymbol
mm_parse.checksymbol:
;?>>
   %define R.symbol rdi
    %define mm_parse.checksymbol.str -104
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       rdi,	rcx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	rdi
    jz        L8214
    lea       rcx,	[rbp + mm_parse.checksymbol.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13371]
    call      msys.m$print_setfmt
    lea       rax,	[mm_tables.symbolnames]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mm_parse.checksymbol.str]
    call      mm_support.serror
L8214:
;---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_parse.lexchecksymbol
mm_parse.lexchecksymbol:
;?>>
   %define R.symbol rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      mm_lex.lex
    mov       rcx,	rdi
    call      mm_parse.checksymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.checksymbollex
mm_parse.checksymbollex:
;?>>
   %define R.symbol rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_parse.checksymbol
    call      mm_lex.lex
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readtypespec
mm_parse.readtypespec:
;?>>
    %define mm_parse.readtypespec.owner 64
    %define mm_parse.readtypespec.typedefx 72
   %define R.d rdi
   %define R.t rbx
   %define R.dim rsi
   %define R.length r12
    %define mm_parse.readtypespec.dims -240
   %define R.ndims r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	272
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	11
    jz        L8219
    cmp       rax,	79
    jz        L8220
    cmp       rax,	67
    jz        L8221
    cmp       rax,	111
    jz        L8222
    cmp       rax,	112
    jz        L8222
    cmp       rax,	113
    jz        L8223
    cmp       rax,	117
    jz        L8224
    cmp       rax,	80
    jz        L8225
    cmp       rax,	121
    jz        L8226
    jmp       L8227
L8219:
;mm_parse.readtypespec.arraybounds:
    call      mm_lex.lex
    xor       r13,	r13
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
L8229:
    xor       r12,	r12
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8233
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8232
L8233:
    xor       rsi,	rsi
    jmp       L8231
L8232:
    call      mm_parse.readunit
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8235
    cmp       rax,	3
    jz        L8235
    cmp       rax,	5
    jz        L8236
    jmp       L8237
L8235:
    jmp       L8234
L8236:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8239
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8239
    call      mm_parse.readunit
    mov       r12,	rax
    mov       rcx,	27
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_lib.createunit2
    mov       rsi,	rax
    jmp       L8238
L8239:
    mov       rcx,	27
    mov       rdx,	rsi
    call      mm_lib.createunit1
    mov       rsi,	rax
L8238:
L8237:
L8234:
L8231:
    cmp       r13,	30
    jl        L8241
    lea       rcx,	[L13372]
    call      mm_support.serror
L8241:
    inc       r13
    mov       rax,	r13
    mov       r10,	rsi
    mov       [rbp + rax*8 + mm_parse.readtypespec.dims-8],	r10
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8230
L8243:
    call      mm_lex.lex
    jmp       L8229
L8230:
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    mov       rcx,	12
    call      mm_parse.checksymbollex
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
    mov       r14,	r13
    cmp       r14,	1
    jl        L8246
L8244:
    cmp       r14,	1
    jnz       L8248
    mov       rax,	[rbp + mm_parse.readtypespec.typedefx]
    jmp       L8247
L8248:
    xor       eax,	eax
L8247:
    mov       r10,	[rbp + r14*8 + mm_parse.readtypespec.dims-8]
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    mov       rdx,	rbx
    mov       r8,	r10
    mov       r9,	rax
    call      mm_lib.createarraymode
    mov       rbx,	rax
    dec       r14
    cmp       r14,	1
    jge       L8244
L8246:
    mov       rax,	rbx
    jmp       L8217
L8220:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rbx,	rax
    call      mm_lex.lex
    jmp       L8218
L8221:
    lea       rax,	[mm_decls.lx]
    mov       rdi,	[rax+8]
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L8250
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.newtypename
    mov       rbx,	rax
    call      mm_lex.lex
    jmp       L8249
L8250:
    xor       ecx,	ecx
    mov       rdx,	rdi
    call      mm_lib.newtypename
    mov       rbx,	rax
L8249:
    jmp       L8218
L8222:
    lea       rcx,	[L13373]
    call      mm_support.serror
    jmp       L8218
L8223:
    lea       rcx,	[L13374]
    call      mm_support.serror
    jmp       L8218
L8224:
;mm_parse.readtypespec.retry:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	94
    jnz       L8253
    call      mm_lex.lex
L8253:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	108
    jz        L8255
    cmp       rax,	109
    jz        L8255
    cmp       rax,	79
    jz        L8256
    cmp       rax,	118
    jz        L8257
    jmp       L8258
L8255:
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    mov       rdx,	[rbp + mm_parse.readtypespec.typedefx]
    call      mm_parse.readrefproc
    mov       rbx,	rax
    jmp       L8254
L8256:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	12
    jnz       L8261
L8260:
    mov       rbx,	20
    mov       rax,	[rbp + mm_parse.readtypespec.typedefx]
    test      rax,	rax
    jz        L8263
    mov       eax,	12
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	[rbp + mm_parse.readtypespec.typedefx]
    mov       [r10 + r11*4],	eax
L8263:
    jmp       L8259
L8261:
    jmp       L8264
L8259:
    call      mm_lex.lex
    jmp       L8254
L8257:
    call      mm_lex.lex
    xor       rbx,	rbx
    jmp       L8265
L8258:
;mm_parse.readtypespec.readtarget:
L8264:
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
;mm_parse.readtypespec.gottarget:
L8265:
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_parse.readtypespec.typedefx]
    call      mm_lib.createrefmode
    mov       rbx,	rax
L8254:
    jmp       L8218
L8225:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	12
    jnz       L8267
    mov       rbx,	20
    jmp       L8266
L8267:
    mov       rbx,	7
L8266:
    mov       rax,	[rbp + mm_parse.readtypespec.typedefx]
    test      rax,	rax
    jz        L8269
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	[rbp + mm_parse.readtypespec.typedefx]
    mov       [r10 + r11*4],	eax
L8269:
    call      mm_lex.lex
    jmp       L8218
L8226:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readtypespec.typedefx]
    call      mm_parse.readslicetype
    mov       rbx,	rax
    jmp       L8218
L8227:
    lea       rcx,	[L13375]
    call      mm_support.serror
L8218:
    mov       rax,	[rbp + mm_parse.readtypespec.typedefx]
    test      rax,	rax
    jz        L8271
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	[rbp + mm_parse.readtypespec.typedefx]
    mov       [r10 + r11*4],	eax
L8271:
    mov       rax,	rbx
L8217:
;---------------
    add       rsp,	272
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readslicetype
mm_parse.readslicetype:
;?>>
   %define R.owner rsi
   %define R.slicetype r12
   %define R.typedefx r13
   %define R.plower rdi
   %define R.t rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	11
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8274
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
    call      mm_parse.readunit
    mov       rdi,	rax
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    mov       rcx,	5
    call      mm_parse.checksymbol
    mov       rcx,	12
    call      mm_parse.lexchecksymbol
    jmp       L8273
L8274:
    xor       rdi,	rdi
L8273:
    call      mm_lex.lex
    mov       rcx,	rsi
    mov       rdx,	r13
    call      mm_parse.readtypespec
    mov       rbx,	rax
    sub       rsp,	8
    mov       rax,	r13
    push      rax
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	rbx
    mov       r9,	rdi
    sub       rsp,	32
    call      mm_lib.createslicemode
    add       rsp,	48
L8272:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readslist
mm_parse.readslist:
;?>>
   %define R.iscall rbx
   %define R.donulls rsi
    %define mm_parse.readslist.ulist -8
    %define mm_parse.readslist.ulistx -16
   %define R.oldinparamlist rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    xor       eax,	eax
    mov       [rbp + mm_parse.readslist.ulistx],	rax
    mov       [rbp + mm_parse.readslist.ulist],	rax
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8277
    mov       rax,	[rbp + mm_parse.readslist.ulist]
    jmp       L8275
L8277:
    mov       rdi,	[mm_parse.inparamlist]
    mov       [mm_parse.inparamlist],	rbx
L8278:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8281
    cmp       rax,	10
    jz        L8282
    jmp       L8283
L8281:
    test      rsi,	rsi
    jz        L8285
    mov       rcx,	2
    call      mm_lib.createunit0
    lea       rcx,	[rbp + mm_parse.readslist.ulist]
    lea       rdx,	[rbp + mm_parse.readslist.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    jmp       L8284
L8285:
    lea       rcx,	[L13376]
    call      mm_support.serror
L8284:
    call      mm_lex.lex
    jmp       L8280
L8282:
    test      rsi,	rsi
    jz        L8287
    lea       rcx,	[rbp + mm_parse.readslist.ulist]
    lea       rdx,	[rbp + mm_parse.readslist.ulistx]
    mov       r8,	[mm_decls.nullunit]
    call      mm_lib.addlistunit
L8287:
    jmp       L8279
L8283:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readslist.ulist]
    lea       rdx,	[rbp + mm_parse.readslist.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8290
    cmp       rax,	4
    jnz       L8289
L8290:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8279
L8292:
    jmp       L8288
L8289:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8279
L8294:
    lea       rcx,	[L13377]
    call      mm_support.serror
L8288:
L8280:
    jmp       L8278
L8279:
    mov       [mm_parse.inparamlist],	rdi
    mov       rax,	[rbp + mm_parse.readslist.ulist]
L8275:
;---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readindex
mm_parse.readindex:
;?>>
   %define R.p r12
   %define R.dot r13
   %define R.q rdi
   %define R.plower rbx
   %define R.pupper rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    call      mm_lex.lex
    test      r13,	r13
    jnz       L8297
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8299
    cmp       rax,	21
    jz        L8300
    cmp       rax,	5
    jz        L8300
    jmp       L8301
L8299:
;mm_parse.readindex.fullslice:
L8302:
    call      mm_lex.lex
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	36
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
    mov       al,	3
    mov       [rbx+62],	al
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	36
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rsi,	rax
    mov       al,	4
    mov       [rsi+62],	al
    mov       rcx,	21
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rcx,	48
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       r12,	rax
    mov       rax,	r12
    jmp       L8295
L8300:
    mov       rcx,	12
    call      mm_parse.lexchecksymbol
    jmp       L8302
L8301:
L8298:
L8297:
L8303:
    mov       rax,	[mm_parse.ndollar]
    cmp       rax,	10
    jl        L8306
    lea       rcx,	[L13378]
    call      mm_support.serror
L8306:
    inc       qword [mm_parse.ndollar]
    mov       rax,	[mm_parse.ndollar]
    mov       r10,	r12
    lea       r11,	[mm_parse.dollarstack]
    mov       [r11 + rax*8-8],	r10
    call      mm_parse.readunit
    mov       rdi,	rax
    dec       qword [mm_parse.ndollar]
    movzx     rax,	byte [rdi]
    cmp       rax,	21
    jnz       L8308
    test      r13,	r13
    jz        L8310
    mov       rax,	52
    jmp       L8309
L8310:
    mov       rax,	48
L8309:
    mov       rcx,	rax
    mov       rdx,	r12
    mov       r8,	rdi
    call      mm_lib.createunit2
    mov       r12,	rax
    jmp       L8307
L8308:
    test      r13,	r13
    jz        L8312
    mov       rax,	51
    jmp       L8311
L8312:
    mov       rax,	46
L8311:
    mov       rcx,	rax
    mov       rdx,	r12
    mov       r8,	rdi
    call      mm_lib.createunit2
    mov       r12,	rax
L8307:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8304
L8314:
    call      mm_lex.lex
    jmp       L8303
L8304:
    mov       rcx,	12
    call      mm_parse.checksymbollex
    mov       rax,	r12
L8295:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readdotsuffix
mm_parse.readdotsuffix:
;?>>
   %define R.p r12
   %define R.q rdi
   %define R.r rbx
   %define R.p2 rsi
    %define mm_parse.readdotsuffix.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
;---------------
    jmp       L8317
L8316:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	11
    jz        L8320
    cmp       rax,	67
    jz        L8321
    cmp       rax,	54
    jz        L8322
    cmp       rax,	57
    jz        L8323
    cmp       rax,	116
    jz        L8324
    cmp       rax,	37
    jz        L8325
    cmp       rax,	36
    jz        L8326
    cmp       rax,	79
    jz        L8327
    jmp       L8328
L8320:
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_parse.readindex
    mov       r12,	rax
    jmp       L8319
L8321:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rcx,	49
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       r12,	rax
    call      mm_lex.lex
    jmp       L8319
L8322:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	5
    jnz       L8330
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	37
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	37
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
    movzx     rax,	byte [r12]
    cmp       rax,	62
    jnz       L8332
    mov       al,	9
    mov       [rdi+62],	al
    mov       al,	10
    mov       [rbx+62],	al
    jmp       L8331
L8332:
    mov       al,	3
    mov       [rdi+62],	al
    mov       al,	4
    mov       [rbx+62],	al
L8331:
    mov       rcx,	21
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rsi,	rax
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mm_lib.deleteunit
    jmp       L8329
L8330:
;mm_parse.readdotsuffix.doprop:
L8333:
    mov       rcx,	37
    mov       rdx,	r12
    call      mm_lib.createunit1
    mov       r12,	rax
    lea       rax,	[mm_decls.lx]
    mov       al,	[rax+1]
    mov       [r12+62],	al
L8329:
    call      mm_lex.lex
    jmp       L8319
L8323:
    mov       rcx,	68
    mov       rdx,	r12
    call      mm_lib.createunit1
    mov       r12,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       [r12+40],	ax
    call      mm_lex.lex
    jmp       L8319
L8324:
    movzx     rax,	byte [r12]
    cmp       rax,	62
    jnz       L8336
L8335:
    jmp       L8334
L8336:
    lea       rcx,	[L13379]
    call      mm_support.serror
L8334:
    call      mm_lex.lex
    jmp       L8319
L8325:
    mov       al,	10
    lea       r10,	[mm_decls.lx]
    mov       [r10+1],	al
    jmp       L8333
L8326:
    mov       al,	9
    lea       r10,	[mm_decls.lx]
    mov       [r10+1],	al
    jmp       L8333
L8327:
    movzx     rax,	byte [r12]
    cmp       rax,	62
    jnz       L8338
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	9
    jnz       L8338
    mov       rcx,	36
    mov       rdx,	r12
    call      mm_lib.createunit1
    mov       [rbp + mm_parse.readdotsuffix.$T1],	rax
    mov       rcx,	36
    mov       rdx,	r12
    call      mm_lib.createunit1
    mov       rcx,	21
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readdotsuffix.$T1]
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       rax,	[rdi+16]
    mov       r10b,	9
    mov       [rax+62],	r10b
    mov       rax,	[rdi+24]
    mov       r10b,	10
    mov       [rax+62],	r10b
    jmp       L8337
L8338:
    jmp       L8339
L8337:
    call      mm_lex.lex
    mov       r12,	rdi
    jmp       L8319
L8328:
;mm_parse.readdotsuffix.error:
L8339:
    lea       rcx,	[L13380]
    call      mm_support.serror
L8319:
L8317:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L8316
    mov       rax,	r12
L8315:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readconstexpr
mm_parse.readconstexpr:
;?>>
    %define mm_parse.readconstexpr.needconst 16
;?]]
    sub       rsp,	40
;---------------
    call      mm_parse.readunit
L8340:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_parse.readconstint
mm_parse.readconstint:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L8343
    lea       rax,	[mm_decls.lx]
    mov       rdi,	[rax+8]
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8341
L8343:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	25
    jnz       L8344
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L8346
    lea       rax,	[mm_decls.lx]
    mov       rdi,	[rax+8]
    call      mm_lex.lex
    mov       rax,	rdi
    neg       rax
    jmp       L8341
L8346:
L8344:
L8342:
    lea       rcx,	[L13381]
    call      mm_support.serror
    xor       eax,	eax
L8341:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readprocdef
mm_parse.readprocdef:
;?>>
   %define R.procowner r15
    %define mm_parse.readprocdef.scope 80
   %define R.kwd rdi
   %define R.startline rbx
   %define R.closesym rsi
   %define R.shortfun r12
   %define R.stproc r13
   %define R.stname r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    setz      al
    movzx     eax,	al
    mov       r12,	rax
    xor       eax,	eax
    mov       [mm_parse.nforloops],	rax
    mov       rax,	1
    mov       [mm_decls.assemmode],	rax
    mov       rcx,	r15
    mov       rdx,	[rbp + mm_parse.readprocdef.scope]
    call      mm_parse.readprocdecl
    mov       r13,	rax
    xor       eax,	eax
    mov       [mm_decls.assemmode],	rax
    call      mm_parse.checkequals
    call      mm_lex.lex
    call      mm_parse.getcurrline
    mov       rbx,	rax
    test      r12,	r12
    jnz       L8349
    xor       ecx,	ecx
    call      mm_parse.checkbegin
    mov       rsi,	rax
L8349:
    mov       rcx,	r13
    call      mm_parse.pushproc
    xor       eax,	eax
    mov       [mm_lib.nextavindex],	rax
    mov       rax,	[mm_parse.dretvar]
    test      rax,	rax
    jz        L8351
    mov       rcx,	r13
    mov       rdx,	[mm_parse.dretvar]
    mov       r8,	11
    call      mm_lib.getduplnameptr
    mov       r14,	rax
    lea       rax,	[r14+72]
    movsxd    r10,	dword [r13+72]
    mov       rcx,	r15
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rcx,	r13
    mov       rdx,	r14
    call      mm_lib.adddef
L8351:
    mov       rcx,	r13
    call      mm_lib.addtoproclist
    test      r12,	r12
    jz        L8353
    call      mm_parse.readunit
    mov       [r13+64],	rax
    mov       rcx,	4
    call      mm_parse.checksymbollex
    jmp       L8352
L8353:
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [r13+64],	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_parse.checkbeginend
L8352:
    mov       rax,	[r13+64]
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       [r13+64],	rax
    call      mm_parse.popproc
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readprocdecl
mm_parse.readprocdecl:
;?>>
    %define mm_parse.readprocdecl.procowner 64
    %define mm_parse.readprocdecl.scope 72
   %define R.kwd rdi
    %define mm_parse.readprocdecl.varparams -8
    %define mm_parse.readprocdecl.nparams -16
   %define R.nretvalues rbx
   %define R.isthreaded rsi
    %define mm_parse.readprocdecl.retmodes -48
   %define R.ms r12
   %define R.ps r13
   %define R.metadata r14
    %define mm_parse.readprocdecl.truename -56
    %define mm_parse.readprocdecl.pequiv -64
    %define mm_parse.readprocdecl.stproc -72
    %define mm_parse.readprocdecl.owner -80
    %define mm_parse.readprocdecl.paramlist -88
    %define mm_parse.readprocdecl.nameptr -96
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	2
    setz      al
    movzx     eax,	al
    mov       rsi,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.pequiv],	rax
    lea       rax,	[L13382]
    mov       r14,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.truename],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.varparams],	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	65
    jnz       L8356
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mm_parse.readprocdecl.truename],	rax
    lea       rax,	[mm_decls.lx]
    mov       rcx,	[rax+8]
    call      mlib.convlcstring
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    lea       r10,	[mm_decls.lx]
    mov       [r10+8],	rax
    jmp       L8355
L8356:
    mov       rcx,	67
    call      mm_parse.checksymbol
L8355:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + mm_parse.readprocdecl.nameptr],	rax
    mov       rax,	[mm_parse.insidedllimport]
    test      rax,	rax
    jz        L8358
    mov       rax,	7
    jmp       L8357
L8358:
    mov       rax,	6
L8357:
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    mov       rdx,	[rbp + mm_parse.readprocdecl.nameptr]
    mov       r8,	rax
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readprocdecl.stproc],	rax
    mov       rax,	[mm_parse.insidedllimport]
    test      rax,	rax
    jz        L8360
    mov       rax,	1
    mov       [rbp + mm_parse.readprocdecl.scope],	rax
L8360:
    mov       al,	sil
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+124],	al
    mov       rax,	[rbp + mm_parse.readprocdecl.truename]
    test      rax,	rax
    jz        L8362
    mov       rax,	[rbp + mm_parse.readprocdecl.truename]
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+104],	rax
L8362:
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    mov       rdx,	[rbp + mm_parse.readprocdecl.stproc]
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    movzx     rax,	byte [rax+78]
    cmp       rax,	7
    jnz       L8364
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    lea       rax,	[rax+92]
    or        byte [rax+1],	8
L8364:
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [rbp + mm_parse.readprocdecl.owner],	rax
    mov       rcx,	[rbp + mm_parse.readprocdecl.stproc]
    call      mm_parse.pushproc
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	26
    jnz       L8366
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    lea       rax,	[rax+92]
    or        byte [rax],	64
    call      mm_lex.lex
L8366:
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.paramlist],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.retmodes],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.nparams],	rax
    xor       rbx,	rbx
    xor       eax,	eax
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8368
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8370
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    mov       rdx,	[rbp + mm_parse.readprocdecl.stproc]
    lea       r8,	[rbp + mm_parse.readprocdecl.varparams]
    lea       r9,	[rbp + mm_parse.readprocdecl.nparams]
    call      mm_parse.readparams
    mov       [rbp + mm_parse.readprocdecl.paramlist],	rax
    mov       rcx,	10
    call      mm_parse.checksymbol
L8370:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8373
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8372
L8373:
    call      mm_lex.lex
    mov       rcx,	[rbp + mm_parse.readprocdecl.owner]
    lea       rdx,	[rbp + mm_parse.readprocdecl.retmodes]
    call      mm_parse.readreturntype
    mov       rbx,	rax
    jmp       L8371
L8372:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_decls.typestarterset]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L8375
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8374
L8375:
    mov       rcx,	[rbp + mm_parse.readprocdecl.owner]
    lea       rdx,	[rbp + mm_parse.readprocdecl.retmodes]
    call      mm_parse.readreturntype
    mov       rbx,	rax
L8374:
L8371:
    jmp       L8367
L8368:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8377
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8376
L8377:
    call      mm_lex.lex
    mov       rcx,	[rbp + mm_parse.readprocdecl.owner]
    lea       rdx,	[rbp + mm_parse.readprocdecl.retmodes]
    call      mm_parse.readreturntype
    mov       rbx,	rax
L8376:
L8367:
    xor       eax,	eax
    mov       [mm_parse.dretvar],	rax
    cmp       rbx,	1
    jnz       L8379
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8381
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [mm_parse.dretvar],	rax
    call      mm_lex.lex
L8381:
L8379:
    test      rbx,	rbx
    jnz       L8383
    cmp       rdi,	109
    jnz       L8383
    lea       rcx,	[L13383]
    call      mm_support.serror
L8383:
    test      rbx,	rbx
    jz        L8385
    cmp       rdi,	109
    jz        L8385
    lea       rcx,	[L13384]
    call      mm_support.serror
L8385:
    mov       rax,	[rbp + mm_parse.readprocdecl.paramlist]
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+112],	rax
    mov       al,	bl
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+122],	al
    mov       rax,	rbx
    test      rax,	rax
    jz        L8387
    cmp       rax,	1
    jz        L8388
    jmp       L8389
L8387:
    xor       eax,	eax
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+72],	eax
    jmp       L8386
L8388:
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    lea       rax,	[rax+72]
    mov       r10,	[rbp + mm_parse.readprocdecl.retmodes]
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    jmp       L8386
L8389:
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    lea       rdx,	[rbp + mm_parse.readprocdecl.retmodes]
    mov       r8,	rbx
    xor       r9d,	r9d
    call      mm_lib.createtuplemode
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+72],	eax
L8386:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8391
    lea       rcx,	[L13385]
    call      mm_support.serror
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    lea       rax,	[rax+92]
    or        byte [rax+1],	1
L8391:
    xor       eax,	eax
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+64],	rax
    mov       al,	[rbp + mm_parse.readprocdecl.scope]
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+170],	al
    mov       al,	[rbp + mm_parse.readprocdecl.varparams]
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+123],	al
    mov       rax,	[rbp + mm_parse.readprocdecl.procowner]
    cmp       rax,	[mm_decls.stmodule]
    jnz       L8393
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    movzx     rax,	byte [rax+76]
    cmp       rax,	5
    jnz       L8395
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13386]
    call      mlib.eqstring
    test      rax,	rax
    jz        L8395
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+94]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+48],	rax
    mov       al,	1
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+170],	al
    jmp       L8396
L8395:
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    movzx     rax,	byte [rax+76]
    cmp       rax,	4
    jnz       L8397
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13387]
    call      mlib.eqstring
    test      rax,	rax
    jz        L8397
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+94]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+95]
    lea       r10,	[mm_decls.subprogs]
    mov       r10,	[r10 + rax*8]
    mov       r13,	r10
    mov       ax,	[r13+10]
    test      ax,	ax
    jz        L8399
    lea       rcx,	[L13388]
    call      mm_support.serror
L8399:
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+94]
    mov       [r13+10],	ax
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r12+56],	rax
    movzx     rax,	byte [r13+15]
    cmp       rax,	[mm_decls.mainsubprogno]
    jnz       L8401
    mov       al,	3
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+170],	al
;mm_parse.readprocdecl.dosigcheck:
L8396:
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       rax,	[rax+112]
    test      rax,	rax
    jnz       L8404
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    movsxd    rax,	dword [rax+72]
    test      rax,	rax
    jz        L8403
L8404:
    lea       rcx,	[L13389]
    call      mm_support.serror
L8403:
L8401:
L8397:
L8394:
L8393:
    call      mm_parse.popproc
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
L8354:
;---------------
    add       rsp,	128
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readparams
mm_parse.readparams:
;?>>
   %define R.procowner r13
   %define R.owner r14
    %define mm_parse.readparams.varparams 80
    %define mm_parse.readparams.nparams 88
    %define mm_parse.readparams.stlist -8
    %define mm_parse.readparams.stlistx -16
   %define R.stname rdi
   %define R.parammode rbx
   %define R.pmode rsi
   %define R.m r12
    %define mm_parse.readparams.isoptional -24
    %define mm_parse.readparams.types -32
    %define mm_parse.readparams.str -64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mm_parse.readparams.stlistx],	rax
    mov       [rbp + mm_parse.readparams.stlist],	rax
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r10,	[rbp + mm_parse.readparams.nparams]
    mov       [r10],	rax
    xor       rbx,	rbx
    xor       eax,	eax
    mov       [rbp + mm_parse.readparams.types],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8407
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8408
    cmp       rax,	10
    jnz       L8407
L8408:
    mov       rax,	1
    mov       [rbp + mm_parse.readparams.types],	rax
L8407:
L8409:
    xor       rbx,	rbx
    xor       eax,	eax
    mov       [rbp + mm_parse.readparams.isoptional],	rax
    mov       rax,	[rbp + mm_parse.readparams.types]
    test      rax,	rax
    jnz       L8413
    call      mm_parse.istypestarter
    test      rax,	rax
    jz        L8412
L8413:
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rsi,	rax
;mm_parse.readparams.gotmode:
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    mov       rax,	[rax]
    test      rax,	rax
    jnz       L8416
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8417
    cmp       rax,	10
    jnz       L8416
L8417:
L8418:
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    inc       qword [rax]
    mov       al,	36
    mov       [rbp + mm_parse.readparams.str],	al
    xor       eax,	eax
    mov       [rbp + mm_parse.readparams.str+1],	al
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    mov       rax,	[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + mm_parse.readparams.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mm_parse.readparams.str]
    call      mm_lex.addnamestr
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	12
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_lib.adddef
    lea       rax,	[rdi+72]
    mov       rcx,	r14
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    mov       [rdi+160],	bl
    lea       rcx,	[rbp + mm_parse.readparams.stlist]
    lea       rdx,	[rbp + mm_parse.readparams.stlistx]
    mov       r8,	rdi
    call      mm_parse.addlistparam
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8422
L8421:
    jmp       L8419
L8422:
L8420:
    mov       rcx,	3
    call      mm_parse.checksymbollex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	22
    jnz       L8424
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_parse.readparams.varparams]
    mov       [r10],	rax
    call      mm_lex.lex
    jmp       L8419
L8424:
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rsi,	rax
    jmp       L8418
L8419:
    mov       rax,	[rbp + mm_parse.readparams.stlist]
    jmp       L8405
L8416:
    jmp       L8411
L8412:
    test      rsi,	rsi
    jnz       L8425
    lea       rcx,	[L13390]
    call      mm_support.serror
L8425:
L8411:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	19
    jz        L8427
    cmp       rax,	22
    jz        L8428
    jmp       L8429
L8427:
    mov       rbx,	1
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8431
    call      mm_lex.lex
L8431:
    jmp       L8426
L8428:
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_parse.readparams.varparams]
    mov       [r10],	rax
    call      mm_lex.lex
    mov       rax,	[rbp + mm_parse.readparams.stlist]
    jmp       L8405
L8429:
L8426:
    mov       rcx,	67
    call      mm_parse.checksymbol
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    inc       qword [rax]
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	12
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_lib.adddef
    call      mm_lex.lex
    cmp       rbx,	1
    jnz       L8433
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       r12,	rax
    jmp       L8432
L8433:
    mov       r12,	rsi
L8432:
    lea       rax,	[rdi+72]
    mov       rcx,	r14
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       [rdi+160],	bl
    mov       al,	[rbp + mm_parse.readparams.isoptional]
    mov       [rdi+161],	al
    lea       rcx,	[rbp + mm_parse.readparams.stlist]
    lea       rdx,	[rbp + mm_parse.readparams.stlistx]
    mov       r8,	rdi
    call      mm_parse.addlistparam
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jz        L8435
    cmp       rax,	41
    jnz       L8436
L8435:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       [rdi+64],	rax
    mov       al,	1
    mov       [rdi+171],	al
    mov       al,	1
    mov       [rdi+161],	al
L8436:
L8434:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8438
    cmp       rax,	10
    jz        L8439
    jmp       L8440
L8438:
    call      mm_lex.lex
    jmp       L8437
L8439:
    jmp       L8410
L8440:
    lea       rcx,	[L13391]
    call      mm_support.serror
L8437:
    jmp       L8409
L8410:
    mov       rax,	[rbp + mm_parse.readparams.stlist]
L8405:
;---------------
    add       rsp,	96
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readcondsuffix
mm_parse.readcondsuffix:
;?>>
   %define R.p rbx
   %define R.q rdi
    %define mm_parse.readcondsuffix.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jz        L8443
    cmp       rax,	88
    jz        L8444
    jmp       L8445
L8443:
    call      mm_lex.lex
    mov       rcx,	6
    mov       rdx,	rbx
    call      mm_lib.createunit1
    mov       [rbp + mm_parse.readcondsuffix.$T1],	rax
    call      mm_parse.readunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rcx,	92
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readcondsuffix.$T1]
    call      mm_lib.createunit2
    jmp       L8442
L8444:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rcx,	17
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	63
    mov       [rdi+62],	al
    mov       rcx,	6
    mov       rdx,	rbx
    call      mm_lib.createunit1
    mov       rcx,	92
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    jmp       L8442
L8445:
    mov       rax,	rbx
L8442:
L8441:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readif
mm_parse.readif:
;?>>
   %define R.pos1 rdi
   %define R.kwd rbx
    %define mm_parse.readif.clist -8
    %define mm_parse.readif.clistx -16
    %define mm_parse.readif.plist -24
    %define mm_parse.readif.plistx -32
   %define R.pelse rsi
   %define R.p r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    call      mm_lex.lex
    call      mm_parse.skipsemi
    xor       eax,	eax
    mov       rsi,	rax
    mov       [rbp + mm_parse.readif.plistx],	rax
    mov       [rbp + mm_parse.readif.plist],	rax
    mov       [rbp + mm_parse.readif.clistx],	rax
    mov       [rbp + mm_parse.readif.clist],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	83
    jnz       L8448
    call      mm_lex.lex
L8448:
    jmp       L8449
L8450:
    call      mm_lex.lex
;mm_parse.readif.nextif:
L8449:
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    lea       rcx,	[rbp + mm_parse.readif.clist]
    lea       rdx,	[rbp + mm_parse.readif.clistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    call      mm_parse.skipsemi
    mov       rcx,	82
    call      mm_parse.checksymbollex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8454
    mov       rax,	[rbp + mm_parse.readif.clist]
    cmp       rax,	[rbp + mm_parse.readif.clistx]
    jnz       L8456
    cmp       rbx,	81
    jnz       L8456
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	92
    mov       rdx,	[rbp + mm_parse.readif.clist]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_lib.createunit3
    mov       r12,	rax
    mov       [r12+4],	edi
    mov       rax,	r12
    jmp       L8446
L8456:
    lea       rcx,	[L13392]
    call      mm_support.serror
L8455:
L8454:
    xor       ecx,	ecx
    call      mm_parse.readsunit
    lea       rcx,	[rbp + mm_parse.readif.plist]
    lea       rdx,	[rbp + mm_parse.readif.plistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	83
    jz        L8450
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jz        L8458
    cmp       rax,	85
    jz        L8459
    cmp       rax,	86
    jz        L8459
    jmp       L8460
L8458:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rsi,	rax
    mov       rcx,	87
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    jmp       L8457
L8459:
    mov       al,	bl
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    call      mm_parse.readswitchcase
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       rsi,	rax
    jmp       L8457
L8460:
    mov       rcx,	87
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
L8457:
    mov       rcx,	92
    mov       rdx,	[rbp + mm_parse.readif.clist]
    mov       r8,	[rbp + mm_parse.readif.plist]
    mov       r9,	rsi
    call      mm_lib.createunit3
    mov       r12,	rax
    mov       [r12+4],	edi
    mov       rax,	r12
L8446:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readgoto
mm_parse.readgoto:
;?>>
   %define R.gototag rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rcx,	rax
    call      mm_parse.readcondsuffix
L8461:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readunless
mm_parse.readunless:
;?>>
   %define R.pos rdi
   %define R.pcond rbx
   %define R.pthen rsi
   %define R.pelse r12
   %define R.p r13
   %define R.q r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rbx,	rax
    mov       rcx,	82
    call      mm_parse.checksymbollex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jnz       L8464
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       r12,	rax
    jmp       L8463
L8464:
    xor       r12,	r12
L8463:
    mov       rcx,	87
    mov       rdx,	88
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rcx,	17
    mov       rdx,	rbx
    call      mm_lib.createunit1
    mov       r10,	rax
    mov       r14,	r10
    mov       rcx,	92
    mov       rdx,	rax
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_lib.createunit3
    mov       r13,	rax
    mov       al,	63
    mov       [r14+62],	al
    mov       [r13+4],	edi
    mov       rax,	r13
L8462:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readswitchcase
mm_parse.readswitchcase:
;?>>
   %define R.pos1 rdi
   %define R.kwd rbx
   %define R.opc rsi
   %define R.pos2 r12
   %define R.rangeused r13
   %define R.nwhen r14
    %define mm_parse.readswitchcase.pexpr -8
    %define mm_parse.readswitchcase.pwhenlist -16
    %define mm_parse.readswitchcase.pwhenlistx -24
    %define mm_parse.readswitchcase.pwhen -32
    %define mm_parse.readswitchcase.pwhenx -40
    %define mm_parse.readswitchcase.pelse -48
    %define mm_parse.readswitchcase.p -56
    %define mm_parse.readswitchcase.pthen -64
    %define mm_parse.readswitchcase.pwhenthen -72
    %define mm_parse.readswitchcase.pjump -80
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rsi,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pjump],	rax
    call      mm_lex.lex
    call      mm_parse.skipsemi
    cmp       rsi,	110
    jnz       L8467
    mov       rcx,	9
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       [rbp + mm_parse.readswitchcase.pjump],	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rax,	[mm_decls.currproc]
    lea       rax,	[rax+92]
    or        byte [rax],	2
L8467:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jnz       L8469
    cmp       rbx,	104
    jnz       L8471
    lea       rcx,	[L13393]
    call      mm_support.serror
L8471:
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pexpr],	rax
    jmp       L8468
L8469:
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readswitchcase.pexpr],	rax
    mov       rax,	[rbp + mm_parse.readswitchcase.pjump]
    mov       r10,	[rbp + mm_parse.readswitchcase.pexpr]
    mov       [r10+8],	rax
L8468:
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pwhenlistx],	rax
    mov       [rbp + mm_parse.readswitchcase.pwhenlist],	rax
    xor       r13,	r13
    xor       eax,	eax
    mov       r14,	rax
    call      mm_parse.skipsemi
    jmp       L8473
L8472:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       r12,	rax
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pwhenx],	rax
    mov       [rbp + mm_parse.readswitchcase.pwhen],	rax
L8475:
    call      mm_parse.readunit
    mov       [rbp + mm_parse.readswitchcase.p],	rax
    inc       r14
    mov       eax,	r12d
    mov       r10,	[rbp + mm_parse.readswitchcase.p]
    mov       [r10+4],	eax
    mov       rax,	[rbp + mm_parse.readswitchcase.p]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jnz       L8478
    mov       r13,	1
L8478:
    lea       rcx,	[rbp + mm_parse.readswitchcase.pwhen]
    lea       rdx,	[rbp + mm_parse.readswitchcase.pwhenx]
    mov       r8,	[rbp + mm_parse.readswitchcase.p]
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8476
L8480:
    call      mm_lex.lex
    jmp       L8475
L8476:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jz        L8482
    mov       rcx,	82
    call      mm_parse.checksymbol
L8482:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readswitchcase.pthen],	rax
    mov       rcx,	85
    mov       rdx,	[rbp + mm_parse.readswitchcase.pwhen]
    mov       r8,	[rbp + mm_parse.readswitchcase.pthen]
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readswitchcase.pwhenthen],	rax
    mov       eax,	r12d
    mov       r10,	[rbp + mm_parse.readswitchcase.pwhenthen]
    mov       [r10+4],	eax
    lea       rcx,	[rbp + mm_parse.readswitchcase.pwhenlist]
    lea       rdx,	[rbp + mm_parse.readswitchcase.pwhenlistx]
    mov       r8,	[rbp + mm_parse.readswitchcase.pwhenthen]
    call      mm_lib.addlistunit
L8473:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jz        L8472
    cmp       rsi,	107
    jnz       L8484
    test      r13,	r13
    jnz       L8484
    cmp       r14,	8
    jg        L8486
    mov       rsi,	105
L8486:
L8484:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jz        L8488
    cmp       rax,	83
    jz        L8489
    cmp       rax,	85
    jz        L8490
    cmp       rax,	86
    jz        L8490
    jmp       L8491
L8488:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readswitchcase.pelse],	rax
    mov       rcx,	87
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    jmp       L8487
L8489:
    mov       al,	bl
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    call      mm_parse.readif
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       [rbp + mm_parse.readswitchcase.pelse],	rax
    jmp       L8487
L8490:
    mov       al,	bl
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    call      mm_parse.readswitchcase
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       [rbp + mm_parse.readswitchcase.pelse],	rax
    jmp       L8487
L8491:
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pelse],	rax
    mov       rcx,	87
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
L8487:
    mov       rcx,	rsi
    mov       rdx,	[rbp + mm_parse.readswitchcase.pexpr]
    mov       r8,	[rbp + mm_parse.readswitchcase.pwhenlist]
    mov       r9,	[rbp + mm_parse.readswitchcase.pelse]
    call      mm_lib.createunit3
    mov       [rbp + mm_parse.readswitchcase.p],	rax
    mov       eax,	edi
    mov       r10,	[rbp + mm_parse.readswitchcase.p]
    mov       [r10+4],	eax
    mov       rax,	[rbp + mm_parse.readswitchcase.p]
L8465:
;---------------
    add       rsp,	112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readstop
mm_parse.readstop:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8494
    call      mm_parse.readunit
    mov       rcx,	120
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    jmp       L8493
L8494:
    mov       rcx,	120
    call      mm_lib.createunit0
    mov       rdi,	rax
L8493:
    mov       rcx,	rdi
    call      mm_parse.readcondsuffix
L8492:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readreturn
mm_parse.readreturn:
;?>>
   %define R.p rdi
   %define R.q rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8497
    call      mm_parse.readunit
    mov       rbx,	rax
    mov       rcx,	89
    mov       rdx,	rbx
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       eax,	1
    mov       [rdi+40],	eax
    jmp       L8496
L8497:
    mov       rcx,	89
    call      mm_lib.createunit0
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rdi+40],	eax
L8496:
    mov       rcx,	rdi
    call      mm_parse.readcondsuffix
L8495:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readdo
mm_parse.readdo:
;?>>
   %define R.p rdi
   %define R.pos rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rdi,	rax
    mov       rcx,	87
    mov       rdx,	96
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rcx,	104
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+4],	ebx
    mov       rax,	rdi
L8498:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readto
mm_parse.readto:
;?>>
   %define R.pos rdi
   %define R.id rbx
   %define R.p rsi
   %define R.pcount r12
   %define R.pbody r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r12,	rax
    mov       rcx,	96
    call      mm_parse.checksymbollex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       r13,	rax
    mov       rcx,	87
    mov       rdx,	94
    mov       r8,	96
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rbx,	11
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+78]
    cmp       rax,	6
    jz        L8501
    mov       rbx,	10
L8501:
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rbx
    call      mm_lib.getavname
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rcx,	91
    mov       rdx,	r12
    mov       r8,	r13
    mov       r9,	rax
    call      mm_lib.createunit3
    mov       rsi,	rax
    mov       [rsi+4],	edi
    mov       rax,	rsi
L8499:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readwhile
mm_parse.readwhile:
;?>>
   %define R.pos rdi
   %define R.pcond rbx
   %define R.pbody rsi
   %define R.pincr r12
   %define R.p r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rcx,	1
    call      mm_parse.readsunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rbx,	rax
    xor       r12,	r12
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8504
    call      mm_lex.lex
    mov       rcx,	1
    call      mm_parse.readsunit
    mov       r12,	rax
L8504:
    mov       rcx,	96
    call      mm_parse.checksymbollex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rsi,	rax
    mov       rcx,	87
    mov       rdx,	97
    mov       r8,	96
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rcx,	97
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_lib.createunit3
    mov       r13,	rax
    mov       [r13+4],	edi
    mov       rax,	r13
L8502:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrepeat
mm_parse.readrepeat:
;?>>
   %define R.pos rdi
   %define R.pbody rbx
   %define R.pcond rsi
   %define R.p r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rbx,	rax
    mov       rcx,	99
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rsi,	rax
    mov       rcx,	98
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       r12,	rax
    mov       [r12+4],	edi
    mov       rax,	r12
L8505:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readloopcontrol
mm_parse.readloopcontrol:
;?>>
   %define R.opc rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rdi,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8508
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13394]
    call      mlib.eqstring
    test      rax,	rax
    jz        L8508
    call      mm_lex.lex
    xor       ecx,	ecx
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
    jmp       L8507
L8508:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8509
    mov       rcx,	1
    call      mm_parse.readconstexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
    jmp       L8507
L8509:
    mov       rcx,	1
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
L8507:
    mov       rcx,	rbx
    call      mm_parse.readcondsuffix
L8506:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readprint
mm_parse.readprint:
;?>>
   %define R.oldinreadprint rdi
   %define R.opc rbx
   %define R.isfprint rsi
   %define R.fshowname r12
   %define R.pformat r13
   %define R.pdev r14
    %define mm_parse.readprint.printlist -8
    %define mm_parse.readprint.printlistx -16
    %define mm_parse.readprint.p -24
    %define mm_parse.readprint.q -32
    %define mm_parse.readprint.expr -40
    %define mm_parse.readprint.s -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    mov       rdi,	[mm_parse.inreadprint]
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rbx,	rax
    mov       rax,	rbx
    cmp       rax,	116
    jz        L8512
    cmp       rax,	117
    jnz       L8513
L8512:
    mov       rsi,	1
    jmp       L8511
L8513:
    xor       rsi,	rsi
L8511:
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readprint.printlistx],	rax
    mov       [rbp + mm_parse.readprint.printlist],	rax
    xor       eax,	eax
    mov       r14,	rax
    mov       r13,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8515
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r14,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8517
    call      mm_lex.lex
    jmp       L8516
L8517:
    jmp       L8518
L8516:
L8515:
    test      rsi,	rsi
    jz        L8520
    call      mm_parse.readunit
    mov       r13,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8522
    call      mm_lex.lex
    jmp       L8521
L8522:
    jmp       L8518
L8521:
L8520:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L8524
    jmp       L8518
L8524:
L8525:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8528
    cmp       rax,	130
    jz        L8529
    jmp       L8530
L8528:
    mov       rcx,	87
    call      mm_lib.createunit0
    lea       rcx,	[rbp + mm_parse.readprint.printlist]
    lea       rdx,	[rbp + mm_parse.readprint.printlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    jmp       L8527
L8529:
    mov       rcx,	88
    call      mm_lib.createunit0
    lea       rcx,	[rbp + mm_parse.readprint.printlist]
    lea       rdx,	[rbp + mm_parse.readprint.printlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    call      mm_lex.lex
    jmp       L8527
L8530:
    xor       r12,	r12
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jnz       L8532
    mov       r12,	1
    call      mm_lex.lex
L8532:
    call      mm_parse.readunit
    mov       [rbp + mm_parse.readprint.p],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8534
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	86
    mov       rdx,	[rbp + mm_parse.readprint.p]
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readprint.p],	rax
L8534:
    test      r12,	r12
    jz        L8536
    mov       rcx,	[rbp + mm_parse.readprint.p]
    call      mm_lib.strexpr
    mov       [rbp + mm_parse.readprint.expr],	rax
    mov       rcx,	[rbp + mm_parse.readprint.expr]
    lea       rdx,	[L13395]
    mov       r8,	-1
    call      mlib.strbuffer_add
    mov       rax,	[rbp + mm_parse.readprint.expr]
    mov       rax,	[rax]
    mov       [rbp + mm_parse.readprint.s],	rax
    mov       rax,	[rbp + mm_parse.readprint.expr]
    movsxd    rax,	dword [rax+8]
    mov       r10,	[rbp + mm_parse.readprint.expr]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.iconvucn
    mov       rax,	[rbp + mm_parse.readprint.expr]
    movsxd    rax,	dword [rax+8]
    mov       rcx,	[rbp + mm_parse.readprint.s]
    mov       rdx,	rax
    call      mm_lib.createstringconstunit
    mov       r10,	rax
    mov       [rbp + mm_parse.readprint.q],	r10
    lea       rcx,	[rbp + mm_parse.readprint.printlist]
    lea       rdx,	[rbp + mm_parse.readprint.printlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
L8536:
    lea       rcx,	[rbp + mm_parse.readprint.printlist]
    lea       rdx,	[rbp + mm_parse.readprint.printlistx]
    mov       r8,	[rbp + mm_parse.readprint.p]
    call      mm_lib.addlistunit
L8527:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8526
L8538:
    call      mm_lex.lex
    jmp       L8525
L8526:
;mm_parse.readprint.finish:
L8518:
    mov       [mm_parse.inreadprint],	rdi
    cmp       rbx,	114
    jnz       L8540
    mov       rax,	[rbp + mm_parse.readprint.printlist]
    test      rax,	rax
    jnz       L8540
    lea       rcx,	[L13396]
    call      mm_support.serror
L8540:
    cmp       rbx,	116
    jnz       L8542
    mov       rax,	[rbp + mm_parse.readprint.printlist]
    test      rax,	rax
    jnz       L8542
    test      r13,	r13
    jnz       L8542
    lea       rcx,	[L13396]
    call      mm_support.serror
L8542:
    test      rsi,	rsi
    jz        L8544
    test      r13,	r13
    jnz       L8546
    lea       rcx,	[L13397]
    call      mm_support.serror
L8546:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r13
    mov       r9,	[rbp + mm_parse.readprint.printlist]
    call      mm_lib.createunit3
    jmp       L8543
L8544:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	[rbp + mm_parse.readprint.printlist]
    call      mm_lib.createunit2
L8543:
L8510:
;---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readread
mm_parse.readread:
;?>>
   %define R.oldinreadprint rdi
   %define R.opc rbx
   %define R.pformat rsi
   %define R.pdev r12
    %define mm_parse.readread.readlist -8
    %define mm_parse.readread.readlistx -16
   %define R.p r13
   %define R.pread r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rdi,	[mm_parse.inreadprint]
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readread.readlistx],	rax
    mov       [rbp + mm_parse.readread.readlist],	rax
    xor       eax,	eax
    mov       r12,	rax
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8549
    cmp       rbx,	118
    jnz       L8551
    lea       rcx,	[L13398]
    call      mm_support.serror
L8551:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r12,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8553
    call      mm_lex.lex
L8553:
L8549:
    cmp       rbx,	119
    jnz       L8555
    mov       rcx,	119
    mov       rdx,	r12
    call      mm_lib.createunit1
    lea       rcx,	[rbp + mm_parse.readread.readlist]
    lea       rdx,	[rbp + mm_parse.readread.readlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
L8555:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L8557
    jmp       L8558
L8557:
L8559:
    call      mm_parse.readunit
    mov       r13,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8562
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rsi,	rax
    jmp       L8561
L8562:
    xor       rsi,	rsi
L8561:
    mov       rcx,	118
    mov       rdx,	rsi
    call      mm_lib.createunit1
    mov       r14,	rax
    mov       rcx,	28
    mov       rdx,	r13
    mov       r8,	r14
    call      mm_lib.createunit2
    mov       r13,	rax
    lea       rcx,	[rbp + mm_parse.readread.readlist]
    lea       rdx,	[rbp + mm_parse.readread.readlistx]
    mov       r8,	r13
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8560
L8564:
    call      mm_lex.lex
    jmp       L8559
L8560:
;mm_parse.readread.finish:
L8558:
    mov       [mm_parse.inreadprint],	rdi
    cmp       rbx,	118
    jnz       L8566
    mov       rax,	[rbp + mm_parse.readread.readlist]
    test      rax,	rax
    jnz       L8566
    lea       rcx,	[L13399]
    call      mm_support.serror
L8566:
    mov       rcx,	6
    mov       rdx,	[rbp + mm_parse.readread.readlist]
    call      mm_lib.createunit1
L8547:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readfor
mm_parse.readfor:
;?>>
   %define R.pos rdi
   %define R.opc rbx
   %define R.pindex rsi
   %define R.plocal r12
   %define R.pfrom r13
   %define R.pto r14
    %define mm_parse.readfor.pstep -8
    %define mm_parse.readfor.ptoinit -16
    %define mm_parse.readfor.plist -24
    %define mm_parse.readfor.passign -32
    %define mm_parse.readfor.pcond -40
    %define mm_parse.readfor.pbody -48
    %define mm_parse.readfor.pelse -56
    %define mm_parse.readfor.p -64
    %define mm_parse.readfor.i -72
    %define mm_parse.readfor.$T1 -80
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       r12,	r12
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.ptoinit],	rax
    call      mm_parse.readname
    mov       rsi,	rax
    mov       rax,	[mm_parse.nforloops]
    cmp       rax,	10
    jl        L8569
    lea       rcx,	[L13400]
    call      mm_support.serror
L8569:
    mov       rax,	1
    mov       [rbp + mm_parse.readfor.i],	rax
    mov       rax,	[mm_parse.nforloops]
    cmp       rax,	1
    jl        L8572
L8570:
    lea       rax,	[mm_parse.forindexvars]
    mov       r10,	[rbp + mm_parse.readfor.i]
    mov       rax,	[rax + r10*8-8]
    mov       r10,	[rsi+16]
    cmp       rax,	r10
    jnz       L8574
    lea       rcx,	[L13401]
    call      mm_support.serror
L8574:
    mov       rax,	[rbp + mm_parse.readfor.i]
    inc       rax
    mov       [rbp + mm_parse.readfor.i],	rax
    cmp       rax,	[mm_parse.nforloops]
    jle       L8570
L8572:
    mov       rax,	[rsi+16]
    inc       qword [mm_parse.nforloops]
    mov       r10,	[mm_parse.nforloops]
    lea       r11,	[mm_parse.forindexvars]
    mov       [r11 + r10*8-8],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8576
    call      mm_lex.lex
    call      mm_parse.readname
    mov       r12,	rax
L8576:
    mov       rbx,	93
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.pstep],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.pcond],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	44
    jz        L8579
    cmp       rax,	46
    jnz       L8578
L8579:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	42
    jnz       L8581
    mov       rbx,	94
L8581:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       [rbp + mm_parse.readfor.plist],	rax
    mov       rax,	[rbp + mm_parse.readfor.plist]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jnz       L8583
    mov       rax,	[rbp + mm_parse.readfor.plist]
    mov       r13,	[rax+16]
    mov       rax,	[rbp + mm_parse.readfor.plist]
    mov       r14,	[rax+24]
    jmp       L8582
L8583:
    cmp       rbx,	93
    jnz       L8585
    mov       rax,	95
    jmp       L8584
L8585:
    mov       rax,	96
L8584:
    mov       rbx,	rax
    mov       rcx,	[rbp + mm_parse.readfor.plist]
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	rax
    call      mm_lib.getrangelwbunit
    mov       r13,	rax
    mov       rcx,	[rbp + mm_parse.readfor.plist]
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	rax
    call      mm_lib.getrangeupbunit
    mov       r14,	rax
L8582:
    jmp       L8577
L8578:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8587
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r13,	rax
    jmp       L8586
L8587:
    mov       rcx,	1
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       r13,	rax
L8586:
    mov       rcx,	94
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L8589
    mov       rax,	94
    jmp       L8588
L8589:
    mov       rax,	93
L8588:
    mov       rbx,	rax
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r14,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	95
    jnz       L8591
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readconstexpr
    mov       [rbp + mm_parse.readfor.pstep],	rax
    mov       rax,	[rbp + mm_parse.readfor.pstep]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L8593
    mov       rax,	[rbp + mm_parse.readfor.pstep]
    mov       rax,	[rax+16]
    cmp       rax,	1
    jnz       L8595
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.pstep],	rax
L8595:
L8593:
L8591:
L8577:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jnz       L8597
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       [rbp + mm_parse.readfor.pcond],	rax
L8597:
    mov       rcx,	96
    call      mm_parse.checksymbollex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readfor.pbody],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.pelse],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jnz       L8599
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readfor.pelse],	rax
L8599:
    mov       rcx,	87
    mov       rdx,	93
    mov       r8,	96
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rax,	[rbp + mm_parse.readfor.pcond]
    test      rax,	rax
    jz        L8601
    mov       rcx,	92
    mov       rdx,	[rbp + mm_parse.readfor.pcond]
    mov       r8,	[rbp + mm_parse.readfor.pbody]
    call      mm_lib.createunit2
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       [rbp + mm_parse.readfor.pbody],	rax
L8601:
    mov       rax,	[rbp + mm_parse.readfor.pelse]
    mov       r10,	[rbp + mm_parse.readfor.pbody]
    mov       [r10+8],	rax
    mov       rax,	rbx
    cmp       rax,	93
    jz        L8603
    cmp       rax,	94
    jnz       L8604
L8603:
    test      r12,	r12
    jz        L8606
    lea       rcx,	[L13402]
    call      mm_support.serror
L8606:
    mov       al,	73
    mov       [rsi+41],	al
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jz        L8608
    cmp       rax,	4
    jz        L8608
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	11
    call      mm_lib.getavname
    mov       rcx,	rax
    call      mm_lib.createname
    mov       r12,	rax
    mov       al,	73
    mov       [r12+41],	al
    mov       rcx,	28
    mov       rdx,	r12
    mov       r8,	r14
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readfor.ptoinit],	rax
    mov       rax,	[rbp + mm_parse.readfor.ptoinit]
    mov       [rsi+8],	rax
    mov       r14,	r12
L8608:
    mov       [r13+8],	r14
    mov       rax,	[rbp + mm_parse.readfor.pstep]
    mov       [r14+8],	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r13
    mov       r9,	[rbp + mm_parse.readfor.pbody]
    call      mm_lib.createunit3
    mov       [rbp + mm_parse.readfor.p],	rax
    jmp       L8602
L8604:
    test      r12,	r12
    jnz       L8610
    mov       r12,	rsi
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	11
    call      mm_lib.getavname
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rsi,	rax
L8610:
    mov       al,	73
    mov       [rsi+41],	al
    mov       al,	76
    mov       [r12+41],	al
    mov       [rsi+8],	r12
    mov       [r12+8],	r13
    mov       [r13+8],	r14
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       [rbp + mm_parse.readfor.$T1],	rax
    mov       rcx,	[rbp + mm_parse.readfor.plist]
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	46
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readfor.$T1]
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readfor.$T1],	rax
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readfor.$T1]
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readfor.passign],	rax
    mov       rax,	[rbp + mm_parse.readfor.passign]
    mov       r10,	[rbp + mm_parse.readfor.plist]
    mov       [r10+8],	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	[rbp + mm_parse.readfor.plist]
    mov       r9,	[rbp + mm_parse.readfor.pbody]
    call      mm_lib.createunit3
    mov       [rbp + mm_parse.readfor.p],	rax
L8602:
    mov       eax,	edi
    mov       r10,	[rbp + mm_parse.readfor.p]
    mov       [r10+4],	eax
    dec       qword [mm_parse.nforloops]
    mov       rax,	[rbp + mm_parse.readfor.p]
L8567:
;---------------
    add       rsp,	112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readname
mm_parse.readname:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      mm_parse.readterm2
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jz        L8613
    lea       rcx,	[L13403]
    call      mm_support.serror
L8613:
    mov       rax,	rdi
L8611:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readtypedef
mm_parse.readtypedef:
;?>>
   %define R.owner r13
   %define R.scope r14
   %define R.sttype rdi
   %define R.stname rbx
   %define R.t rsi
   %define R.m r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rbx,	[rax+8]
    call      mm_lex.lex
    call      mm_parse.checkequals
    call      mm_lex.lex
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	5
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       rcx,	r13
    mov       rdx,	rdi
    call      mm_lib.adddef
    mov       rcx,	rdi
    call      mm_lib.createusertype
    mov       r12,	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttusercat]
    mov       r11,	r12
    mov       [r10 + r11],	al
    mov       rcx,	rdi
    mov       rdx,	r12
    call      mm_parse.readtypespec
    mov       rsi,	rax
    mov       [rdi+170],	r14b
    lea       rax,	[rdi+72]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    cmp       rsi,	0
    jl        L8616
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    lea       r10,	[mm_decls.ttisreal]
    mov       r11,	rsi
    movzx     r10,	byte [r10 + r11]
    add       rax,	r10
    test      rax,	rax
    jz        L8618
    mov       eax,	esi
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	r12
    mov       [r10 + r11*4],	eax
    jmp       L8617
L8618:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rsi
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L8617
L8619:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L8621
    cmp       rax,	11
    jz        L8622
    cmp       rax,	8
    jz        L8623
    jmp       L8624
L8621:
    jmp       L8620
L8622:
    jmp       L8620
L8623:
    jmp       L8620
L8624:
    mov       eax,	esi
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	r12
    mov       [r10 + r11*4],	eax
L8620:
L8617:
    jmp       L8615
L8616:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    lea       rax,	[rax + r10*4]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
L8615:
    cmp       rsi,	0
    jl        L8626
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mm_lib.copyttvalues
    jmp       L8625
L8626:
    mov       eax,	29
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	r12
    mov       [r10 + r11*4],	eax
L8625:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrecordfields
mm_parse.readrecordfields:
;?>>
   %define R.owner r13
   %define R.m r14
   %define R.nvars rdi
   %define R.offset rbx
   %define R.stname rsi
   %define R.stbitfield r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    xor       rdi,	rdi
    jmp       L8629
L8628:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	13
    call      mm_lib.getduplnameptr
    mov       rsi,	rax
    lea       rax,	[rsi+72]
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	rax
    call      mm_lib.storemode
    inc       rdi
    lea       rax,	[mm_parse.unionpend]
    mov       al,	[rax+7]
    test      al,	al
    jz        L8632
    lea       rax,	[rsi+136]
    mov       rcx,	rax
    lea       rdx,	[mm_parse.unionpend]
    call      mm_lib.unionstr_copy
    lea       rcx,	[mm_parse.unionstring]
    lea       rdx,	[mm_parse.unionpend]
    call      mm_lib.unionstr_concat
    lea       rcx,	[mm_parse.unionpend]
    call      mm_lib.unionstr_clear
    jmp       L8631
L8632:
    lea       rax,	[rsi+136]
    mov       rcx,	rax
    call      mm_lib.unionstr_clear
L8631:
    mov       [mm_parse.unionlastvar],	rsi
    mov       rcx,	r13
    mov       rdx,	rsi
    call      mm_lib.adddef
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jz        L8634
    cmp       rax,	5
    jz        L8635
    jmp       L8636
L8634:
    call      mm_lex.lex
    lea       rax,	[rsi+92]
    or        byte [rax],	128
    mov       rcx,	r13
    call      mm_parse.readequivfield
    mov       [rsi+128],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	24
    jnz       L8638
    call      mm_lex.lex
    call      mm_parse.readconstint
    mov       rbx,	rax
    mov       rax,	rbx
    mov       r10,	9223372036854775807
    cmp       rax,	r10
    jle       L8640
    lea       rcx,	[L13404]
    call      mm_support.serror
L8640:
    mov       [rsi+151],	bl
L8638:
    jmp       L8633
L8635:
    mov       rcx,	9
    call      mm_parse.lexchecksymbol
L8641:
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	13
    call      mm_lib.getduplnameptr
    mov       r12,	rax
    mov       eax,	27
    mov       [r12+72],	eax
    mov       rcx,	r13
    mov       rdx,	r12
    call      mm_lib.adddef
    lea       rax,	[r12+92]
    or        byte [rax],	128
    mov       [r12+128],	rsi
    mov       rcx,	5
    call      mm_parse.lexchecksymbol
    mov       rcx,	62
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [r12+148],	al
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8641
    mov       rcx,	10
    call      mm_parse.checksymbollex
L8636:
L8633:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8630
L8645:
    call      mm_lex.lex
L8629:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jz        L8628
L8630:
    test      rdi,	rdi
    jnz       L8647
    lea       rcx,	[L13405]
    call      mm_support.serror
L8647:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readtabledef
mm_parse.readtabledef:
;?>>
    %define mm_parse.readtabledef.owner 72
    %define mm_parse.readtabledef.scope 80
   %define R.i rdi
   %define R.ncols rbx
   %define R.nrows rsi
   %define R.enums r12
   %define R.nextenumvalue r13
   %define R.firstval r14
   %define R.lastval r15
    %define mm_parse.readtabledef.startline -8
    %define mm_parse.readtabledef.closesym -16
    %define mm_parse.readtabledef.ltype -24
    %define mm_parse.readtabledef.stvar -32
    %define mm_parse.readtabledef.stenum -40
    %define mm_parse.readtabledef.stgen -48
    %define mm_parse.readtabledef.varnameptrs -208
    %define mm_parse.readtabledef.varlisttypes -368
    %define mm_parse.readtabledef.plist -528
    %define mm_parse.readtabledef.plistx -688
    %define mm_parse.readtabledef.enumvalues -4688
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	4728
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    xor       eax,	eax
    mov       [mm_parse.tabledataname],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8650
    test      r12,	r12
    jnz       L8652
    lea       rcx,	[L13406]
    call      mm_support.serror
L8652:
    mov       r12,	1
    call      mm_lex.lex
    mov       rcx,	10
    call      mm_parse.checksymbollex
L8650:
    mov       r13,	1
    xor       rsi,	rsi
    xor       eax,	eax
    mov       rbx,	rax
    jmp       L8654
L8653:
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       [rbp + mm_parse.readtabledef.ltype],	rax
    mov       rcx,	67
    call      mm_parse.checksymbol
    inc       rbx
    cmp       rbx,	20
    jle       L8657
    lea       rcx,	[L13407]
    call      mm_support.serror
L8657:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + rbx*8 + mm_parse.readtabledef.varnameptrs-8],	rax
    mov       rax,	[rbp + mm_parse.readtabledef.ltype]
    mov       [rbp + rbx*8 + mm_parse.readtabledef.varlisttypes-8],	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8659
    call      mm_lex.lex
    jmp       L8658
L8659:
    jmp       L8655
L8658:
L8654:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jnz       L8653
L8655:
    call      mm_lex.lex
    call      mm_parse.skipsemi
    call      mm_parse.getcurrline
    mov       [rbp + mm_parse.readtabledef.startline],	rax
    xor       ecx,	ecx
    call      mm_parse.checkbegin
    mov       [rbp + mm_parse.readtabledef.closesym],	rax
    call      mm_parse.skipsemi
    xor       eax,	eax
    mov       r15,	rax
    mov       r14,	rax
    mov       rdi,	1
    cmp       rbx,	1
    jl        L8662
L8660:
    xor       eax,	eax
    mov       [rbp + rdi*8 + mm_parse.readtabledef.plistx-8],	rax
    mov       [rbp + rdi*8 + mm_parse.readtabledef.plist-8],	rax
    inc       rdi
    cmp       rdi,	rbx
    jle       L8660
L8662:
    mov       rax,	1
    mov       [mm_parse.intabledata],	rax
L8663:
    call      mm_parse.skipsemi
    cmp       rbx,	0
    jle       L8666
    mov       rcx,	9
    call      mm_parse.checksymbollex
L8666:
    inc       rsi
    cmp       rsi,	500
    jle       L8668
    lea       rcx,	[L13408]
    call      mm_support.serror
L8668:
    test      r12,	r12
    jz        L8670
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + mm_parse.readtabledef.stgen],	rax
    mov       rax,	[rbp + mm_parse.readtabledef.stgen]
    mov       rax,	[rax]
    mov       [mm_parse.tabledataname],	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jnz       L8672
    cmp       rsi,	1
    jz        L8674
    lea       rcx,	[L13409]
    call      mm_support.serror
L8674:
    call      mm_lex.lex
    call      mm_parse.readconstint
    mov       r13,	rax
L8672:
    mov       [rbp + rsi*8 + mm_parse.readtabledef.enumvalues-8],	r13
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	[rbp + mm_parse.readtabledef.stgen]
    mov       r8,	9
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readtabledef.stenum],	rax
    mov       eax,	3
    mov       r10,	[rbp + mm_parse.readtabledef.stenum]
    mov       [r10+72],	eax
    mov       rcx,	r13
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       r10,	[rbp + mm_parse.readtabledef.stenum]
    mov       [r10+64],	rax
    mov       al,	[rbp + mm_parse.readtabledef.scope]
    mov       r10,	[rbp + mm_parse.readtabledef.stenum]
    mov       [r10+170],	al
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	[rbp + mm_parse.readtabledef.stenum]
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_parse.readtabledef.scope]
    cmp       rax,	3
    jnz       L8676
    mov       rcx,	[rbp + mm_parse.readtabledef.stenum]
    call      mm_lib.addexpconst
L8676:
    cmp       rsi,	1
    jnz       L8678
    mov       r14,	r13
L8678:
    mov       r15,	r13
    inc       r13
    test      rbx,	rbx
    jz        L8680
    mov       rcx,	3
    call      mm_parse.checksymbollex
L8680:
L8670:
    mov       rdi,	1
    cmp       rbx,	1
    jl        L8683
L8681:
    call      mm_parse.readunit
    lea       r10,	[rbp + rdi*8 + mm_parse.readtabledef.plistx-8]
    lea       r11,	[rbp + rdi*8 + mm_parse.readtabledef.plist-8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.addlistunit
    cmp       rdi,	rbx
    jnz       L8685
    mov       rcx,	10
    call      mm_parse.checksymbollex
    jmp       L8684
L8685:
    mov       rcx,	3
    call      mm_parse.checksymbollex
L8684:
    inc       rdi
    cmp       rdi,	rbx
    jle       L8681
L8683:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8664
L8687:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	[rbp + mm_parse.readtabledef.closesym]
    jz        L8664
L8689:
    jmp       L8663
L8664:
    xor       eax,	eax
    mov       [mm_parse.intabledata],	rax
    call      mm_parse.skipsemi
    mov       rcx,	[rbp + mm_parse.readtabledef.closesym]
    mov       rdx,	132
    mov       r8,	[rbp + mm_parse.readtabledef.startline]
    call      mm_parse.checkbeginend
    test      rsi,	rsi
    jnz       L8691
    lea       rcx,	[L13410]
    call      mm_support.serror
L8691:
    mov       rdi,	1
    cmp       rbx,	1
    jl        L8694
L8692:
    mov       rax,	[rbp + rdi*8 + mm_parse.readtabledef.varnameptrs-8]
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	rax
    mov       r8,	10
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readtabledef.stvar],	rax
    mov       rax,	[rbp + rdi*8 + mm_parse.readtabledef.plist-8]
    mov       rcx,	20
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       r10,	[rbp + mm_parse.readtabledef.stvar]
    mov       [r10+64],	rax
    mov       rax,	[rbp + mm_parse.readtabledef.stvar]
    mov       rax,	[rax+64]
    mov       r10d,	esi
    mov       [rax+40],	r10d
    mov       rax,	[rbp + mm_parse.readtabledef.stvar]
    lea       rax,	[rax+92]
    or        byte [rax+1],	2
    mov       rax,	[rbp + mm_parse.readtabledef.stvar]
    lea       rax,	[rax+72]
    mov       r10,	[rbp + rdi*8 + mm_parse.readtabledef.varlisttypes-8]
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    mov       al,	[rbp + mm_parse.readtabledef.scope]
    mov       r10,	[rbp + mm_parse.readtabledef.stvar]
    mov       [r10+170],	al
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	[rbp + mm_parse.readtabledef.stvar]
    call      mm_lib.adddef
    mov       rcx,	[rbp + mm_parse.readtabledef.stvar]
    call      mm_lib.addstatic
    inc       rdi
    cmp       rdi,	rbx
    jle       L8692
L8694:
;---------------
    add       rsp,	4728
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readclassdef
mm_parse.readclassdef:
;?>>
    %define mm_parse.readclassdef.owner 72
    %define mm_parse.readclassdef.scope 80
   %define R.kwd rdi
   %define R.baseclass rbx
   %define R.m rsi
   %define R.startline r12
   %define R.closesym r13
   %define R.mrec r14
   %define R.isrecord r15
    %define mm_parse.readclassdef.align -8
    %define mm_parse.readclassdef.nameptr -16
    %define mm_parse.readclassdef.sttype -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	111
    setz      al
    movzx     eax,	al
    mov       r15,	rax
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + mm_parse.readclassdef.nameptr],	rax
    call      mm_lex.lex
    xor       rbx,	rbx
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8697
    call      mm_lex.lex
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
L8697:
    call      mm_parse.checkequals
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readclassdef.align],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8699
    call      mm_lex.lex
    mov       rax,	1
    mov       [rbp + mm_parse.readclassdef.align],	rax
L8699:
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	[rbp + mm_parse.readclassdef.nameptr]
    mov       r8,	5
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readclassdef.sttype],	rax
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	[rbp + mm_parse.readclassdef.sttype]
    call      mm_lib.adddef
    mov       rcx,	[rbp + mm_parse.readclassdef.sttype]
    call      mm_lib.createusertype
    mov       rsi,	rax
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	rsi
    call      mm_lib.createrecordmode
    mov       r14,	rax
    mov       rax,	[rbp + mm_parse.readclassdef.sttype]
    lea       rax,	[rax+72]
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	r14
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	[rbp + mm_parse.readclassdef.sttype]
    lea       rax,	[rax+144]
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.storemode
    mov       al,	[rbp + mm_parse.readclassdef.align]
    mov       r10,	[rbp + mm_parse.readclassdef.sttype]
    mov       [r10+149],	al
    mov       rcx,	1
    call      mm_parse.checkbegin
    mov       r13,	rax
    call      mm_parse.getcurrline
    mov       r12,	rax
    mov       rcx,	[rbp + mm_parse.readclassdef.sttype]
    mov       rdx,	rdi
    call      mm_parse.readclassbody
    mov       rcx,	r13
    mov       rdx,	rdi
    mov       r8,	r12
    call      mm_parse.checkbeginend
    mov       al,	[rbp + mm_parse.readclassdef.scope]
    mov       r10,	[rbp + mm_parse.readclassdef.sttype]
    mov       [r10+170],	al
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readclassbody
mm_parse.readclassbody:
;?>>
   %define R.owner r12
    %define mm_parse.readclassbody.classkwd 56
   %define R.kwd rdi
   %define R.t rbx
   %define R.lbcount rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    xor       rsi,	rsi
    lea       rcx,	[mm_parse.unionstring]
    call      mm_lib.unionstr_clear
    lea       rcx,	[mm_parse.unionpend]
    call      mm_lib.unionstr_clear
L8701:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	123
    jz        L8703
    cmp       rax,	109
    jz        L8704
    cmp       rax,	108
    jz        L8704
    cmp       rax,	111
    jz        L8705
    cmp       rax,	116
    jz        L8706
    cmp       rax,	59
    jz        L8707
    cmp       rax,	4
    jz        L8708
    cmp       rax,	132
    jz        L8709
    cmp       rax,	122
    jz        L8710
    cmp       rax,	112
    jz        L8711
    cmp       rax,	113
    jz        L8711
    cmp       rax,	87
    jz        L8712
    cmp       rax,	10
    jz        L8712
    cmp       rax,	119
    jz        L8713
    cmp       rax,	120
    jz        L8714
    jmp       L8715
L8703:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readconstdef
    jmp       L8701
L8704:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    movzx     rax,	word [r12+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L8717
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readprocdecl
    jmp       L8716
L8717:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readprocdef
L8716:
    jmp       L8701
L8705:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readclassdef
    jmp       L8701
L8706:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readtypedef
    jmp       L8701
L8707:
    lea       rcx,	[L13411]
    call      mm_support.serror
    jmp       L8702
L8708:
    call      mm_lex.lex
    jmp       L8701
L8709:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readtabledef
    jmp       L8701
L8710:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readmacrodef
    jmp       L8701
L8711:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	112
    jnz       L8719
    mov       rax,	83
    jmp       L8718
L8719:
    mov       rax,	85
L8718:
    lea       rcx,	[mm_parse.unionpend]
    mov       rdx,	rax
    call      mm_lib.unionstr_append
    xor       eax,	eax
    mov       [mm_parse.unionlastvar],	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8721
    inc       rsi
    call      mm_lex.lex
L8721:
    jmp       L8701
L8712:
    lea       rax,	[mm_parse.unionstring]
    mov       al,	[rax+7]
    test      al,	al
    jz        L8723
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8725
    test      rsi,	rsi
    jz        L8725
    call      mm_lex.lex
    dec       rsi
    jmp       L8724
L8725:
    lea       rcx,	[mm_parse.unionstring]
    call      mm_lib.unionstr_last
    cmp       rax,	83
    jnz       L8727
    mov       rax,	112
    jmp       L8726
L8727:
    mov       rax,	113
L8726:
    mov       rcx,	87
    mov       rdx,	rax
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
L8724:
    mov       rax,	[mm_parse.unionlastvar]
    test      rax,	rax
    jz        L8730
    lea       rax,	[mm_parse.unionpend]
    mov       al,	[rax+7]
    test      al,	al
    jz        L8729
L8730:
    lea       rcx,	[L13412]
    call      mm_support.serror
L8729:
    mov       rax,	[mm_parse.unionlastvar]
    lea       rax,	[rax+136]
    mov       rcx,	rax
    call      mm_lib.unionstr_last
    cmp       rax,	69
    jz        L8732
    cmp       rax,	42
    jnz       L8733
L8732:
    jmp       L8731
L8733:
    mov       rax,	[mm_parse.unionlastvar]
    lea       rax,	[rax+136]
    mov       rcx,	rax
    mov       rdx,	42
    call      mm_lib.unionstr_append
L8731:
    mov       rax,	[mm_parse.unionlastvar]
    lea       rax,	[rax+136]
    mov       rcx,	rax
    mov       rdx,	69
    call      mm_lib.unionstr_append
    lea       rax,	[mm_parse.unionstring]
    lea       rax,	[rax+7]
    dec       byte [rax]
    jmp       L8722
L8723:
    jmp       L8702
L8722:
    jmp       L8701
L8713:
    call      mm_lex.lex
    call      mm_parse.istypestarter
    test      rax,	rax
    jz        L8735
;mm_parse.readclassbody.readmut:
L8736:
    inc       qword [mm_parse.insiderecord]
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
    dec       qword [mm_parse.insiderecord]
    jmp       L8734
L8735:
    mov       rbx,	22
L8734:
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mm_parse.readrecordfields
    jmp       L8701
L8714:
    lea       rcx,	[L13413]
    call      mm_support.serror
    jmp       L8701
L8715:
    call      mm_parse.istypestarter
    test      rax,	rax
    jnz       L8736
L8738:
    jmp       L8702
L8737:
    jmp       L8701
L8702:
    test      rsi,	rsi
    jz        L8740
    lea       rcx,	[L13414]
    call      mm_support.serror
L8740:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readimportmodule
mm_parse.readimportmodule:
;?>>
   %define R.owner r14
   %define R.isnew rdi
   %define R.startline rbx
   %define R.closesym rsi
   %define R.stname r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       rax,	[mm_parse.insidedllimport]
    test      rax,	rax
    jz        L8743
    lea       rcx,	[L13415]
    call      mm_support.serror
L8743:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	65
    jnz       L8745
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    mov       r12,	rax
    jmp       L8744
L8745:
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       r12,	[rax+8]
L8744:
    call      mm_lex.lex
    call      mm_parse.checkequals
    call      mm_lex.lex
    mov       rdi,	1
    mov       r13,	1
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	1
    jl        L8748
L8746:
    mov       rax,	[r12]
    lea       r10,	[mm_decls.libfiles]
    mov       r11,	r13
    mov       r10,	[r10 + r11*8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L8750
    xor       rdi,	rdi
    jmp       L8748
L8750:
    inc       r13
    cmp       r13,	[mm_decls.nlibfiles]
    jle       L8746
L8748:
    test      rdi,	rdi
    jz        L8752
    mov       rcx,	[r12]
    call      mm_modules.addlib
L8752:
    call      mm_parse.getcurrline
    mov       rbx,	rax
    xor       ecx,	ecx
    call      mm_parse.checkbegin
    mov       rsi,	rax
    mov       rax,	1
    mov       [mm_parse.insidedllimport],	rax
    mov       rcx,	r14
    call      mm_parse.readimportbody
    xor       eax,	eax
    mov       [mm_parse.insidedllimport],	rax
    mov       rcx,	rsi
    mov       rdx,	114
    mov       r8,	rbx
    call      mm_parse.checkbeginend
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readimportbody
mm_parse.readimportbody:
;?>>
   %define R.owner rsi
   %define R.pos rdi
   %define R.d rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
L8754:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	108
    jz        L8757
    cmp       rax,	109
    jz        L8757
    cmp       rax,	116
    jz        L8758
    cmp       rax,	123
    jz        L8759
    cmp       rax,	111
    jz        L8760
    cmp       rax,	119
    jz        L8761
    cmp       rax,	79
    jz        L8762
    cmp       rax,	67
    jz        L8762
    cmp       rax,	117
    jz        L8762
    cmp       rax,	80
    jz        L8762
    cmp       rax,	11
    jz        L8762
    cmp       rax,	121
    jz        L8762
    cmp       rax,	59
    jz        L8763
    cmp       rax,	87
    jz        L8764
    jmp       L8765
L8757:
;mm_parse.readimportbody.doproc:
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_parse.readprocdecl
    mov       rbx,	rax
    mov       rax,	[mm_decls.ndllproctable]
    cmp       rax,	1000
    jl        L8768
    lea       rcx,	[L13416]
    call      mm_support.serror
L8768:
    inc       qword [mm_decls.ndllproctable]
    mov       rax,	[mm_decls.ndllproctable]
    mov       r10,	rbx
    lea       r11,	[mm_decls.dllproctable]
    mov       [r11 + rax*8-8],	r10
    jmp       L8756
L8758:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_parse.readtypedef
    jmp       L8756
L8759:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_parse.readconstdef
    jmp       L8756
L8760:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_parse.readclassdef
    jmp       L8756
L8761:
    call      mm_lex.lex
    sub       rsp,	8
    push      119
    mov       rcx,	rsi
    mov       rdx,	1
    xor       r8d,	r8d
    mov       r9,	8
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    jmp       L8756
L8762:
    sub       rsp,	8
    push      0
    mov       rcx,	rsi
    mov       rdx,	1
    xor       r8d,	r8d
    mov       r9,	8
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    jmp       L8756
L8763:
    jmp       L8755
L8764:
    jmp       L8755
L8765:
    lea       rcx,	[L13417]
    call      mm_lex.ps
    lea       rcx,	[L13418]
    call      mm_support.serror
L8756:
    jmp       L8754
L8755:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readequivfield
mm_parse.readequivfield:
;?>>
   %define R.owner rsi
   %define R.p rdi
   %define R.d rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rbx,	[rax+8]
    call      mm_lex.lex
    mov       rdi,	[rsi+16]
    jmp       L8771
L8770:
    mov       rax,	[rbx]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L8774
    mov       rax,	rdi
    jmp       L8769
L8774:
    mov       rdi,	[rdi+32]
L8771:
    test      rdi,	rdi
    jnz       L8770
    call      msys.m$print_startcon
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13419]
    call      mm_support.serror
    xor       eax,	eax
L8769:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrefproc
mm_parse.readrefproc:
;?>>
    %define mm_parse.readrefproc.owner 64
    %define mm_parse.readrefproc.typedefx 72
   %define R.kwd rdi
   %define R.prettype rbx
   %define R.m rsi
    %define mm_parse.readrefproc.varparams -8
    %define mm_parse.readrefproc.nparams -16
    %define mm_parse.readrefproc.retmodes -48
   %define R.paramlist r12
   %define R.stproc r13
   %define R.nretvalues r14
    %define mm_parse.readrefproc.name -56
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       r12,	r12
    xor       eax,	eax
    mov       rbx,	rax
    xor       r14,	r14
    xor       eax,	eax
    mov       [rbp + mm_parse.readrefproc.varparams],	rax
    call      mm_lib.nextautotype
    mov       [rbp + mm_parse.readrefproc.name],	rax
    mov       rcx,	[rbp + mm_parse.readrefproc.name]
    call      mm_lex.addnamestr
    mov       rcx,	[mm_decls.stmodule]
    mov       rdx,	rax
    mov       r8,	5
    call      mm_lib.getduplnameptr
    mov       r13,	rax
    mov       rcx,	[mm_decls.stmodule]
    mov       rdx,	r13
    call      mm_lib.adddef
    xor       eax,	eax
    mov       [rbp + mm_parse.readrefproc.retmodes],	rax
    cmp       rdi,	109
    jnz       L8777
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8779
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8781
    mov       rcx,	[rbp + mm_parse.readrefproc.owner]
    mov       rdx,	r13
    lea       r8,	[rbp + mm_parse.readrefproc.varparams]
    lea       r9,	[rbp + mm_parse.readrefproc.nparams]
    call      mm_parse.readparams
    mov       r12,	rax
    mov       rcx,	10
    call      mm_parse.checksymbol
L8781:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8784
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8783
L8784:
    call      mm_lex.lex
    mov       rcx,	r13
    lea       rdx,	[rbp + mm_parse.readrefproc.retmodes]
    call      mm_parse.readreturntype
    mov       r14,	rax
    jmp       L8782
L8783:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_decls.typestarterset]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L8786
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8785
L8786:
    mov       rcx,	r13
    lea       rdx,	[rbp + mm_parse.readrefproc.retmodes]
    call      mm_parse.readreturntype
    mov       r14,	rax
L8785:
L8782:
    jmp       L8778
L8779:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8788
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8787
L8788:
    call      mm_lex.lex
    mov       rcx,	r13
    lea       rdx,	[rbp + mm_parse.readrefproc.retmodes]
    call      mm_parse.readreturntype
    mov       r14,	rax
L8787:
L8778:
    test      r14,	r14
    jnz       L8790
    lea       rcx,	[L13420]
    call      mm_support.serror
L8790:
    test      r14,	r14
    jz        L8792
    cmp       rdi,	108
    jnz       L8792
    lea       rcx,	[L13421]
    call      mm_support.serror
L8792:
    jmp       L8776
L8777:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8794
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8796
    mov       rcx,	[rbp + mm_parse.readrefproc.owner]
    mov       rdx,	r13
    lea       r8,	[rbp + mm_parse.readrefproc.varparams]
    lea       r9,	[rbp + mm_parse.readrefproc.nparams]
    call      mm_parse.readparams
    mov       r12,	rax
    mov       rcx,	10
    call      mm_parse.checksymbol
L8796:
    call      mm_lex.lex
L8794:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_decls.typestarterset]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L8799
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8799
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8798
L8799:
    lea       rcx,	[L13422]
    call      mm_support.serror
L8798:
L8776:
    push      qword [rbp + mm_parse.readrefproc.typedefx]
    mov       rax,	rbx
    push      rax
    mov       rcx,	[rbp + mm_parse.readrefproc.owner]
    mov       rdx,	r13
    mov       r8,	r12
    mov       r9,	rdi
    sub       rsp,	32
    call      mm_lib.createrefprocmode
    add       rsp,	48
    mov       rsi,	rax
    lea       rax,	[r13+72]
    mov       r10,	[rbp + mm_parse.readrefproc.retmodes]
    mov       rcx,	[rbp + mm_parse.readrefproc.owner]
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    mov       [r13+122],	r14b
    mov       rax,	r13
    lea       r10,	[mm_decls.ttnamedef]
    mov       r11,	rsi
    mov       [r10 + r11*8],	rax
    mov       al,	[rbp + mm_parse.readrefproc.varparams]
    mov       [r13+123],	al
    mov       rax,	rsi
L8775:
;---------------
    add       rsp,	96
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.pushproc
mm_parse.pushproc:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mm_parse.nprocstack]
    cmp       rax,	10
    jl        L8802
    lea       rcx,	[L13423]
    call      mm_support.serror
L8802:
    inc       qword [mm_parse.nprocstack]
    mov       rax,	[mm_parse.nprocstack]
    mov       r10,	[mm_decls.currproc]
    lea       r11,	[mm_parse.procstack]
    mov       [r11 + rax*8-8],	r10
    mov       [mm_decls.currproc],	rdi
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.popproc
mm_parse.popproc:
;?>>
;?]]
;---------------
    mov       rax,	[mm_parse.nprocstack]
    test      rax,	rax
    jz        L8805
    mov       rax,	[mm_parse.nprocstack]
    dec       qword [mm_parse.nprocstack]
    lea       r10,	[mm_parse.procstack]
    mov       r10,	[r10 + rax*8-8]
    mov       [mm_decls.currproc],	r10
    jmp       L8804
L8805:
    mov       rax,	[mm_decls.stmodule]
    mov       [mm_decls.currproc],	rax
L8804:
;---------------
    ret       
;End 
;Proc mm_parse.readreturntype
mm_parse.readreturntype:
;?>>
   %define R.owner rbx
   %define R.retmodes rsi
   %define R.nretvalues rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       [rsi],	rax
    mov       rdi,	1
    jmp       L8808
L8807:
    cmp       rdi,	4
    jl        L8811
    lea       rcx,	[L13424]
    call      mm_support.serror
L8811:
    call      mm_lex.lex
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_parse.readtypespec
    inc       rdi
    mov       r10,	rdi
    mov       [rsi + r10*8-8],	rax
L8808:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8807
    mov       rax,	rdi
L8806:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readset
mm_parse.readset:
;?>>
   %define R.length rdi
   %define R.nkeyvalues rbx
   %define R.oldirp rsi
   %define R.p r12
    %define mm_parse.readset.ulist -8
    %define mm_parse.readset.ulistx -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jnz       L8815
L8814:
    call      mm_lex.lex
    mov       rcx,	22
    xor       edx,	edx
    call      mm_lib.createunit1
    jmp       L8812
L8815:
L8813:
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rbx,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readset.ulistx],	rax
    mov       [rbp + mm_parse.readset.ulist],	rax
L8816:
    mov       rsi,	[mm_parse.inreadprint]
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    call      mm_parse.readunit
    mov       r12,	rax
    mov       [mm_parse.inreadprint],	rsi
    movzx     rax,	byte [r12]
    cmp       rax,	27
    jnz       L8819
    inc       rbx
L8819:
    inc       rdi
    lea       rcx,	[rbp + mm_parse.readset.ulist]
    lea       rdx,	[rbp + mm_parse.readset.ulistx]
    mov       r8,	r12
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8821
    cmp       rax,	4
    jz        L8822
    cmp       rax,	12
    jz        L8823
    jmp       L8824
L8821:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8817
L8826:
    jmp       L8820
L8822:
    mov       rcx,	12
    call      mm_parse.lexchecksymbol
    jmp       L8817
L8823:
    jmp       L8817
L8824:
    lea       rcx,	[L13425]
    call      mm_support.serror
L8820:
    call      mm_parse.skipsemi
    jmp       L8816
L8817:
    call      mm_lex.lex
    test      rbx,	rbx
    jz        L8828
    cmp       rdi,	rbx
    jle       L8830
    lea       rcx,	[L13426]
    call      mm_support.serror
L8830:
    mov       rcx,	23
    mov       rdx,	[rbp + mm_parse.readset.ulist]
    call      mm_lib.createunit1
    mov       r12,	rax
    jmp       L8827
L8828:
    mov       rcx,	22
    mov       rdx,	[rbp + mm_parse.readset.ulist]
    call      mm_lib.createunit1
    mov       r12,	rax
L8827:
    mov       [r12+40],	edi
    mov       rax,	r12
L8812:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.istypestarter
mm_parse.istypestarter:
;?>>
;?]]
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_decls.typestarterset]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L8833
    mov       rax,	1
    jmp       L8831
L8833:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8835
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jz        L8837
    cmp       rax,	19
    jz        L8838
    jmp       L8839
L8837:
    mov       rax,	1
    jmp       L8831
L8838:
    mov       rax,	1
    jmp       L8831
L8839:
L8836:
L8835:
    xor       eax,	eax
L8831:
;---------------
    ret       
;End 
;Proc mm_parse.readunit
mm_parse.readunit:
;?>>
   %define R.p rdi
   %define R.pt rbx
   %define R.pos rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    xor       rbx,	rbx
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rsi,	rax
    call      mm_parse.readterm2
    mov       rbx,	rax
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.jisexpr]
    movzx     r10,	byte [r10 + rax]
    test      r10,	r10
    jnz       L8842
    mov       rax,	rbx
    jmp       L8840
L8842:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.endsexpr]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8844
    mov       rax,	rbx
    jmp       L8840
L8844:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8846
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.endsexpr]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8848
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	esi
    mov       rax,	rdi
    jmp       L8840
L8848:
    mov       rcx,	rdi
    call      mm_parse.readassignment
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    jmp       L8845
L8846:
    mov       rcx,	rbx
    call      mm_parse.readassignment
    mov       rdi,	rax
    mov       [rdi+4],	esi
L8845:
    jmp       L8850
L8849:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readassignment
    mov       rcx,	32
    mov       rdx,	rax
    mov       r8,	rdi
    call      mm_lib.createunit2
    mov       rdi,	rax
L8850:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	8
    jz        L8849
    mov       rax,	rdi
L8840:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readassignment
mm_parse.readassignment:
;?>>
   %define R.pt r13
   %define R.p rdi
   %define R.pos rbx
   %define R.opc rsi
   %define R.q r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mm_parse.readorterms
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    cmp       rax,	6
    jnz       L8854
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readassignment
    mov       r12,	rax
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	r12
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	ebx
L8854:
    mov       rax,	rdi
L8852:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readorterms
mm_parse.readorterms:
;?>>
   %define R.pt rsi
   %define R.p rdi
   %define R.pos rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_parse.readandterms
    mov       rdi,	rax
    jmp       L8857
L8856:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8860
    lea       rcx,	[L13427]
    call      mm_support.serror
L8860:
    xor       ecx,	ecx
    call      mm_parse.readandterms
    mov       rcx,	16
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	ebx
L8857:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	39
    jz        L8856
    mov       rax,	rdi
L8855:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readandterms
mm_parse.readandterms:
;?>>
   %define R.pt rsi
   %define R.p rdi
   %define R.pos rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_parse.readcmpterms
    mov       rdi,	rax
    jmp       L8863
L8862:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8866
    lea       rcx,	[L13428]
    call      mm_support.serror
L8866:
    xor       ecx,	ecx
    call      mm_parse.readcmpterms
    mov       rcx,	15
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	ebx
L8863:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	38
    jz        L8862
    mov       rax,	rdi
L8861:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readcmpterms
mm_parse.readcmpterms:
;?>>
   %define R.pt r13
   %define R.p rdi
   %define R.pos rbx
   %define R.n rsi
    %define mm_parse.readcmpterms.ulist -8
    %define mm_parse.readcmpterms.ulistx -16
   %define R.q r12
    %define mm_parse.readcmpterms.genops -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mm_parse.readinterms
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8869
    cmp       rax,	42
    jz        L8869
    mov       rax,	rdi
    jmp       L8867
L8869:
    mov       rax,	rdi
    mov       [rbp + mm_parse.readcmpterms.ulistx],	rax
    mov       [rbp + mm_parse.readcmpterms.ulist],	rax
    mov       rcx,	34
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    xor       rsi,	rsi
    lea       rax,	[rbp + mm_parse.readcmpterms.genops]
    xor       r10d,	r10d
    mov       [rax],	r10d
L8870:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8872
    cmp       rax,	42
    jnz       L8873
L8872:
    inc       rsi
    cmp       rsi,	4
    jle       L8875
    lea       rcx,	[L13429]
    call      mm_support.serror
L8875:
    lea       rax,	[mm_decls.lx]
    mov       al,	[rax+1]
    mov       [rbp + rsi + mm_parse.readcmpterms.genops-1],	al
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readinterms
    mov       r12,	rax
    lea       rcx,	[rbp + mm_parse.readcmpterms.ulist]
    lea       rdx,	[rbp + mm_parse.readcmpterms.ulistx]
    mov       r8,	r12
    call      mm_lib.addlistunit
    mov       [r12+4],	ebx
    jmp       L8870
L8873:
    jmp       L8871
L8871:
    cmp       rsi,	1
    jnz       L8877
    mov       al,	33
    mov       [rdi],	al
    mov       r12,	[rdi+16]
    mov       al,	[rbp + mm_parse.readcmpterms.genops]
    mov       [rdi+64],	al
    mov       rax,	[r12+8]
    mov       [rdi+24],	rax
    xor       eax,	eax
    mov       [r12+8],	rax
    jmp       L8876
L8877:
    mov       eax,	[rbp + mm_parse.readcmpterms.genops]
    mov       [rdi+40],	eax
L8876:
    mov       rax,	rdi
L8867:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readinterms
mm_parse.readinterms:
;?>>
   %define R.pt r12
   %define R.p rdi
   %define R.pos rbx
   %define R.opc rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      mm_parse.readrangeterm
    mov       rdi,	rax
L8879:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	44
    jz        L8881
    cmp       rax,	45
    jnz       L8882
L8881:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readrangeterm
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+62],	sil
    mov       [rdi+4],	ebx
    jmp       L8879
L8882:
    jmp       L8880
L8880:
    mov       rax,	rdi
L8878:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrangeterm
mm_parse.readrangeterm:
;?>>
   %define R.pt rsi
   %define R.p rdi
   %define R.pos rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_parse.readaddterms
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jnz       L8885
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readaddterms
    mov       rcx,	21
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	ebx
L8885:
    mov       rax,	rdi
L8883:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readaddterms
mm_parse.readaddterms:
;?>>
   %define R.pt r13
   %define R.p rdi
   %define R.pos rbx
   %define R.sym rsi
   %define R.genop r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mm_parse.readmulterms
    mov       rdi,	rax
L8887:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    cmp       rax,	24
    jz        L8889
    cmp       rax,	25
    jz        L8889
    cmp       rax,	31
    jz        L8889
    cmp       rax,	32
    jz        L8889
    cmp       rax,	33
    jz        L8889
    cmp       rax,	36
    jz        L8889
    cmp       rax,	37
    jnz       L8890
L8889:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8892
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readassignment
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    lea       rax,	[mm_tables.symbolgentoops]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rdi+62],	al
    mov       [rdi+4],	ebx
    jmp       L8888
L8892:
    xor       ecx,	ecx
    call      mm_parse.readmulterms
    mov       rcx,	35
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    lea       rax,	[mm_tables.symbolgenops]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rdi+62],	al
    mov       [rdi+4],	ebx
    jmp       L8887
L8890:
    jmp       L8888
L8888:
    mov       rax,	rdi
L8886:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readmulterms
mm_parse.readmulterms:
;?>>
   %define R.pt r12
   %define R.p rdi
   %define R.pos rbx
   %define R.sym rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      mm_parse.readpowerterms
    mov       rdi,	rax
L8894:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    cmp       rax,	26
    jz        L8896
    cmp       rax,	27
    jz        L8896
    cmp       rax,	28
    jz        L8896
    cmp       rax,	29
    jz        L8896
    cmp       rax,	34
    jz        L8896
    cmp       rax,	35
    jz        L8896
    cmp       rax,	30
    jnz       L8897
L8896:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8899
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readassignment
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    lea       rax,	[mm_tables.symbolgentoops]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rdi+62],	al
    mov       [rdi+4],	ebx
    jmp       L8895
L8899:
    xor       ecx,	ecx
    call      mm_parse.readpowerterms
    mov       rcx,	35
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    lea       rax,	[mm_tables.symbolgenops]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rdi+62],	al
    mov       [rdi+4],	ebx
    jmp       L8894
L8897:
    jmp       L8895
L8895:
    mov       rax,	rdi
L8893:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readpowerterms
mm_parse.readpowerterms:
;?>>
   %define R.p rbx
   %define R.pos rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    test      rbx,	rbx
    jnz       L8902
    call      mm_parse.readterm2
    mov       rbx,	rax
L8902:
    jmp       L8904
L8903:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readpowerterms
    mov       rcx,	35
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rbx,	rax
    mov       al,	82
    mov       [rbx+62],	al
    mov       [rbx+4],	edi
L8904:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	43
    jz        L8903
    mov       rax,	rbx
L8900:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readterm2
mm_parse.readterm2:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.opc rsi
   %define R.oldinrp r12
   %define R.pos r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       r13,	rax
    call      mm_parse.readterm
    mov       rdi,	rax
L8907:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jz        L8909
    cmp       rax,	15
    jz        L8910
    cmp       rax,	11
    jz        L8911
    cmp       rax,	1
    jz        L8912
    cmp       rax,	5
    jz        L8913
    cmp       rax,	61
    jz        L8914
    cmp       rax,	13
    jz        L8915
    jmp       L8916
L8909:
    call      mm_lex.lex
    mov       r12,	[mm_parse.inreadprint]
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    mov       rcx,	1
    mov       rdx,	1
    call      mm_parse.readslist
    mov       rbx,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    movzx     rax,	byte [rdi]
    cmp       rax,	90
    jnz       L8918
    mov       [rdi+16],	rbx
    jmp       L8917
L8918:
    mov       rcx,	32
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rdi,	rax
L8917:
    mov       [mm_parse.inreadprint],	r12
    mov       rcx,	rdi
    call      mm_parse.readcondsuffix
    mov       rdi,	rax
    jmp       L8907
L8910:
    mov       rcx,	53
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    call      mm_lex.lex
    jmp       L8907
L8911:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_parse.readindex
    mov       rdi,	rax
    jmp       L8907
L8912:
    mov       rcx,	rdi
    call      mm_parse.readdotsuffix
    mov       rdi,	rax
    jmp       L8907
L8913:
    mov       rax,	[mm_parse.inreadprint]
    test      rax,	rax
    jnz       L8908
L8920:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rbx,	rax
    mov       rax,	[mm_parse.inparamlist]
    test      rax,	rax
    jz        L8922
    mov       rax,	26
    jmp       L8921
L8922:
    mov       rax,	27
L8921:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rdi,	rax
    jmp       L8907
L8914:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	84
    jz        L8924
    cmp       rax,	85
    jz        L8925
    jmp       L8926
L8924:
    mov       rsi,	88
    jmp       L8923
L8925:
    mov       rsi,	89
L8926:
L8923:
    call      mm_lex.lex
    mov       rcx,	40
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+62],	sil
    jmp       L8907
L8915:
    lea       rcx,	[L13430]
    call      mm_support.serror
    jmp       L8907
L8916:
    jmp       L8908
L8908:
    mov       [rdi+4],	r13d
    mov       rax,	rdi
L8906:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readterm
mm_parse.readterm:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.r rsi
    %define mm_parse.readterm.a -8
   %define R.opc r12
   %define R.pos r13
   %define R.length r14
   %define R.strtype r15b
    %define mm_parse.readterm.s -16
    %define mm_parse.readterm.cstr -272
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	312
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       r13,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    sub       rax,	2
    cmp       rax,	135
    jae       L8930
    lea       r10,	[L8929]
    jmp       [r10 + rax*8]
    segment .data
L8929:
    dq  L8957
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8941
    dq  L8930
    dq  L8950
    dq  L8930
    dq  L8995
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8952
    dq  L8952
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8943
    dq  L8943
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8943
    dq  L8943
    dq  L8943
    dq  L8930
    dq  L8930
    dq  L8943
    dq  L8943
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8944
    dq  L8947
    dq  L8943
    dq  L8943
    dq  L8943
    dq  L8943
    dq  L8943
    dq  L8930
    dq  L8943
    dq  L8943
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8951
    dq  L8934
    dq  L8934
    dq  L8936
    dq  L8935
    dq  L8930
    dq  L8931
    dq  L8930
    dq  L8993
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8942
    dq  L8942
    dq  L8973
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8974
    dq  L8975
    dq  L8975
    dq  L8976
    dq  L8930
    dq  L8977
    dq  L8978
    dq  L8930
    dq  L8979
    dq  L8980
    dq  L8981
    dq  L8930
    dq  L8983
    dq  L8984
    dq  L8982
    dq  L8972
    dq  L8975
    dq  L8975
    dq  L8985
    dq  L8986
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8942
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8996
    dq  L8930
    dq  L8930
    dq  L8994
    dq  L8930
    dq  L8930
    dq  L8930
    dq  L8968
    dq  L8958
    dq  L8959
    dq  L8988
    dq  L8930
    dq  L8969
    dq  L8987
    dq  L8989
    dq  L8992
    segment .text
L8931:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8933
    call      mm_parse.readcast
    mov       rdi,	rax
    jmp       L8932
L8933:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rdi+4],	eax
    call      mm_lex.lex
L8932:
    jmp       L8928
L8934:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    jmp       L8928
L8935:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	word [rax+2]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.createstringconstunit
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       al,	[rax+1]
    mov       [rdi+45],	al
    call      mm_lex.lex
    jmp       L8928
L8936:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	word [rax+2]
    dec       rax
    mov       r14,	rax
    cmp       r14,	8
    jle       L8938
    lea       rcx,	[L13431]
    call      mm_support.serror
L8938:
    xor       eax,	eax
    mov       [rbp + mm_parse.readterm.a],	rax
    test      r14,	r14
    jz        L8940
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    lea       rcx,	[rbp + mm_parse.readterm.a]
    mov       rdx,	rax
    mov       r8,	r14
    call      memcpy
L8940:
    mov       rcx,	[rbp + mm_parse.readterm.a]
    mov       rdx,	5
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    jmp       L8928
L8941:
    call      mm_parse.readlbrack
    mov       rdi,	rax
    jmp       L8928
L8942:
    call      mm_parse.readcast
    mov       rdi,	rax
    jmp       L8928
L8943:
    call      mm_parse.readopc
    mov       rdi,	rax
    jmp       L8928
L8944:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8946
    call      mm_parse.readopc
    mov       rdi,	rax
    jmp       L8945
L8946:
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	17
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	63
    mov       [rdi+62],	al
L8945:
    jmp       L8928
L8947:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8949
    call      mm_parse.readopc
    mov       rdi,	rax
    jmp       L8948
L8949:
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	18
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
L8948:
    jmp       L8928
L8950:
    call      mm_parse.readset
    mov       rdi,	rax
    jmp       L8928
L8951:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	40
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+62],	r12b
    jmp       L8928
L8952:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	r12
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       rax,	[rdi+16]
    movzx     rax,	byte [rax]
    cmp       rax,	32
    jnz       L8954
    mov       rax,	[rdi+16]
    mov       rax,	[rax+24]
    test      rax,	rax
    jz        L8956
    lea       rcx,	[L13432]
    call      mm_support.serror
L8956:
    mov       rax,	[rdi+16]
    mov       rax,	[rax+16]
    mov       [rdi+16],	rax
L8954:
    jmp       L8928
L8957:
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	56
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    jmp       L8928
L8958:
    call      mm_parse.readcompilervar
    mov       rdi,	rax
    jmp       L8928
L8959:
    mov       rax,	[mm_parse.intabledata]
    test      rax,	rax
    jz        L8961
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L8963
    xor       eax,	eax
    mov       [rbp + mm_parse.readterm.cstr],	rax
    lea       rcx,	[rbp + mm_parse.readterm.cstr]
    mov       rdx,	[mm_parse.tabledataname]
    call      strcpy
    mov       rax,	[rbp + mm_parse.readterm.cstr]
    mov       rcx,	rax
    mov       rdx,	4
    call      mm_lib.createconstunit
    mov       rdi,	rax
    jmp       L8962
L8963:
    mov       rax,	[mm_parse.tabledataname]
    mov       [rbp + mm_parse.readterm.s],	rax
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	24
    jnz       L8965
    call      mm_lex.lex
    call      mm_lex.lex
    mov       rcx,	62
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    add       [rbp + mm_parse.readterm.s],	rax
L8965:
    mov       rcx,	[rbp + mm_parse.readterm.s]
    mov       rdx,	-1
    call      mm_lib.createstringconstunit
    mov       rdi,	rax
L8962:
    jmp       L8960
L8961:
    mov       rax,	[mm_parse.ndollar]
    cmp       rax,	0
    jg        L8967
    lea       rcx,	[L13433]
    call      mm_support.serror
L8967:
    lea       rax,	[mm_parse.dollarstack]
    mov       r10,	[mm_parse.ndollar]
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	36
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	4
    mov       [rdi+62],	al
L8960:
    call      mm_lex.lex
    jmp       L8928
L8968:
    call      mm_parse.readcastx
    mov       rdi,	rax
    jmp       L8928
L8969:
    mov       rcx,	9
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rdi,	rax
    mov       rcx,	3
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8971
    movzx     rax,	byte [rbx]
    cmp       rax,	21
    jnz       L8971
    mov       rsi,	[rbx+24]
    mov       rbx,	[rbx+16]
    jmp       L8970
L8971:
    mov       rcx,	3
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rsi,	rax
    mov       rcx,	10
    call      mm_parse.checksymbol
L8970:
    call      mm_lex.lex
    mov       rcx,	35
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rbx,	rax
    mov       al,	56
    mov       [rbx+62],	al
    mov       rcx,	35
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       al,	55
    mov       [rdi+62],	al
    jmp       L8928
L8972:
    mov       rcx,	99
    call      mm_parse.readgoto
    mov       rdi,	rax
    jmp       L8928
L8973:
    call      mm_parse.readif
    mov       rdi,	rax
    jmp       L8928
L8974:
    call      mm_parse.readunless
    mov       rdi,	rax
    jmp       L8928
L8975:
    call      mm_parse.readswitchcase
    mov       rdi,	rax
    jmp       L8928
L8976:
    call      mm_parse.readrecase
    mov       rdi,	rax
    jmp       L8928
L8977:
    call      mm_parse.readfor
    mov       rdi,	rax
    jmp       L8928
L8978:
    call      mm_parse.readto
    mov       rdi,	rax
    jmp       L8928
L8979:
    call      mm_parse.readdo
    mov       rdi,	rax
    jmp       L8928
L8980:
    call      mm_parse.readwhile
    mov       rdi,	rax
    jmp       L8928
L8981:
    call      mm_parse.readrepeat
    mov       rdi,	rax
    jmp       L8928
L8982:
    call      mm_parse.readloopcontrol
    mov       rdi,	rax
    jmp       L8928
L8983:
    call      mm_parse.readreturn
    mov       rdi,	rax
    jmp       L8928
L8984:
    call      mm_parse.readstop
    mov       rdi,	rax
    jmp       L8928
L8985:
    call      mm_parse.readprint
    mov       rdi,	rax
    jmp       L8928
L8986:
    call      mm_parse.readread
    mov       rdi,	rax
    jmp       L8928
L8987:
    mov       rcx,	9
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rdi,	rax
    mov       rcx,	3
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rbx,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	111
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rdi,	rax
    jmp       L8928
L8988:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	121
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    jmp       L8928
L8989:
    mov       al,	1
    mov       r10,	[mm_decls.currproc]
    mov       [r10+120],	al
    mov       rax,	1
    mov       [mm_decls.assemmode],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    test      rax,	rax
    jnz       L8991
    call      mm_assem.readassemline
    mov       rdi,	rax
    jmp       L8990
L8991:
    call      mm_assem.readassemblock
    mov       rdi,	rax
L8990:
    xor       eax,	eax
    mov       [mm_decls.assemmode],	rax
    jmp       L8928
L8992:
    mov       rcx,	90
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       [rdi+40],	ax
    call      mm_lex.lex
    jmp       L8928
L8993:
    lea       rax,	[mm_decls.lx]
    mov       r15b,	[rax+1]
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	13
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+45],	r15b
    jmp       L8928
L8994:
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	122
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    jmp       L8928
L8995:
    lea       rcx,	[L13434]
    call      mm_support.serror
    jmp       L8928
L8996:
    mov       rcx,	9
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rdi,	rax
    mov       rcx,	3
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rbx,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	24
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rdi,	rax
    jmp       L8928
L8930:
;mm_parse.readterm.doelse:
    call      msys.m$print_startcon
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[L13435]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      mm_parse.istypestarter
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13436]
    call      mm_support.serror
L8928:
    mov       [rdi+4],	r13d
    mov       rax,	rdi
L8927:
;---------------
    add       rsp,	312
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readmacrodef
mm_parse.readmacrodef:
;?>>
   %define R.owner r12
   %define R.scope r13
   %define R.nameptr rdi
   %define R.stmacro rbx
    %define mm_parse.readmacrodef.paramlist -8
    %define mm_parse.readmacrodef.paramlistx -16
   %define R.stname rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rdi,	[rax+8]
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	15
    call      mm_lib.getduplnameptr
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mm_lib.adddef
    mov       r12,	rbx
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readmacrodef.paramlistx],	rax
    mov       [rbp + mm_parse.readmacrodef.paramlist],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L9000
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L9002
L9003:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L9007
L9006:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r12
    mov       rdx,	rax
    mov       r8,	16
    call      mm_lib.getduplnameptr
    mov       rsi,	rax
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mm_lib.adddef
    lea       rcx,	[rbp + mm_parse.readmacrodef.paramlist]
    lea       rdx,	[rbp + mm_parse.readmacrodef.paramlistx]
    mov       r8,	rsi
    call      mm_parse.addlistparam
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L9004
L9009:
    mov       rcx,	3
    call      mm_parse.checksymbollex
    jmp       L9005
L9007:
    lea       rcx,	[L13437]
    call      mm_support.serror
L9005:
    jmp       L9003
L9004:
L9002:
    call      mm_lex.lex
L9000:
    mov       rax,	[rbp + mm_parse.readmacrodef.paramlist]
    mov       [rbx+112],	rax
    mov       [rbx+170],	r13b
    call      mm_parse.checkequals
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       [rbx+64],	rax
;---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrecase
mm_parse.readrecase:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jnz       L9012
    call      mm_lex.lex
    mov       rcx,	113
    call      mm_lib.createunit0
    jmp       L9011
L9012:
    call      mm_parse.readunit
    mov       rcx,	113
    mov       rdx,	rax
    call      mm_lib.createunit1
L9011:
L9010:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_parse.fixcond
mm_parse.fixcond:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_parse.checknotempty
    movzx     rax,	byte [rdi]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L9015
    mov       rcx,	rdi
    mov       rdx,	18
    call      mm_lib.insertunit
L9015:
    mov       rax,	rdi
L9013:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readsunit
mm_parse.readsunit:
;?>>
    %define mm_parse.readsunit.inwhile 64
   %define R.pos rdi
   %define R.sym rbx
   %define R.opc rsi
    %define mm_parse.readsunit.ulist -8
    %define mm_parse.readsunit.ulistx -16
   %define R.p r12
   %define R.q r13
   %define R.r r14
    %define mm_parse.readsunit.stname -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readsunit.ulistx],	rax
    mov       [rbp + mm_parse.readsunit.ulist],	rax
L9017:
    jmp       L9021
L9020:
    call      mm_lex.lex
L9021:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L9020
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    sub       rax,	4
    cmp       rax,	129
    jae       L9025
    lea       r10,	[L9024]
    jmp       [r10 + rax*8]
    segment .data
L9024:
    dq  L9056
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9047
    dq  L9031
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9057
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9046
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9048
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9031
    dq  L9031
    dq  L9025
    dq  L9047
    dq  L9047
    dq  L9047
    dq  L9047
    dq  L9047
    dq  L9047
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9047
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9053
    dq  L9025
    dq  L9025
    dq  L9047
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9030
    dq  L9030
    dq  L9025
    dq  L9043
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9041
    dq  L9031
    dq  L9025
    dq  L9037
    dq  L9037
    dq  L9031
    dq  L9044
    dq  L9042
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9026
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9025
    dq  L9045
    segment .text
L9026:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	120
    jz        L9029
    cmp       rax,	119
    jnz       L9028
L9029:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    call      mm_lex.lex
    jmp       L9027
L9028:
    xor       rsi,	rsi
L9027:
    sub       rsp,	8
    mov       rax,	rsi
    push      rax
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	10
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    jmp       L9023
L9030:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readprocdef
    jmp       L9023
L9031:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jz        L9034
    cmp       rax,	17
    jz        L9034
    cmp       rax,	1
    jnz       L9033
L9034:
    jmp       L9035
L9033:
    xor       rbx,	rbx
    jmp       L9036
L9032:
    jmp       L9023
L9037:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    call      mm_lex.lex
;mm_parse.readsunit.dovar:
L9036:
    sub       rsp,	8
    mov       rax,	rbx
    push      rax
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    xor       r8d,	r8d
    mov       r9,	11
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    mov       r13,	rax
    jmp       L9039
L9038:
    mov       r14,	[r13+8]
    xor       eax,	eax
    mov       [r13+8],	rax
    lea       rcx,	[rbp + mm_parse.readsunit.ulist]
    lea       rdx,	[rbp + mm_parse.readsunit.ulistx]
    mov       r8,	r13
    call      mm_lib.addlistunit
    mov       r13,	r14
L9039:
    test      r13,	r13
    jnz       L9038
    jmp       L9023
L9041:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readtypedef
    jmp       L9023
L9042:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readconstdef
    jmp       L9023
L9043:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readclassdef
    jmp       L9023
L9044:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readmacrodef
    jmp       L9023
L9045:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readtabledef
    jmp       L9023
L9046:
    call      msys.m$print_startcon
    mov       rax,	[mm_decls.currproc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13438]
    call      mm_support.serror
    jmp       L9023
L9047:
    jmp       L9019
L9048:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L9050
    cmp       rax,	67
    jz        L9051
    jmp       L9052
L9050:
    mov       rcx,	100
    call      mm_lib.createunit0
    mov       r12,	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rax
    mov       r8,	14
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readsunit.stname],	rax
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	[rbp + mm_parse.readsunit.stname]
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_parse.readsunit.stname]
    mov       [r12+16],	rax
    call      mm_lex.lex
    mov       al,	4
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    lea       rcx,	[rbp + mm_parse.readsunit.ulist]
    lea       rdx,	[rbp + mm_parse.readsunit.ulistx]
    mov       r8,	r12
    call      mm_lib.addlistunit
    jmp       L9049
L9051:
    mov       rbx,	119
    jmp       L9036
    jmp       L9049
L9052:
    jmp       L9035
L9049:
    jmp       L9023
L9053:
    mov       rax,	[rbp + mm_parse.readsunit.inwhile]
    test      rax,	rax
    jnz       L9019
L9055:
    jmp       L9035
L9056:
    jmp       L9023
L9057:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	-1
    call      mm_lib.createstringconstunit
    mov       rcx,	14
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       r12,	rax
    mov       al,	4
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    jmp       L9058
L9025:
;mm_parse.readsunit.doexec:
L9035:
    call      mm_parse.readunit
    mov       r12,	rax
;mm_parse.readsunit.doexec2:
    movzx     rax,	byte [r12]
    cmp       rax,	4
    jnz       L9061
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L9061
    lea       rcx,	[L13439]
    call      mm_support.serror
L9061:
;mm_parse.readsunit.doexec3:
L9058:
    lea       rcx,	[rbp + mm_parse.readsunit.ulist]
    lea       rdx,	[rbp + mm_parse.readsunit.ulistx]
    mov       r8,	r12
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	96
    jz        L9019
L9063:
L9023:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L9017
L9019:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L9065
    cmp       rax,	82
    jz        L9065
    cmp       rax,	83
    jz        L9065
    cmp       rax,	84
    jz        L9065
    cmp       rax,	99
    jz        L9065
    cmp       rax,	92
    jz        L9065
    cmp       rax,	96
    jz        L9065
    cmp       rax,	85
    jz        L9065
    cmp       rax,	86
    jz        L9065
    cmp       rax,	87
    jz        L9065
    cmp       rax,	3
    jz        L9065
    cmp       rax,	16
    jnz       L9066
L9065:
    jmp       L9064
L9066:
    lea       rcx,	[L13440]
    call      mm_support.serror
L9064:
    mov       rax,	[rbp + mm_parse.readsunit.ulist]
    test      rax,	rax
    jz        L9069
    mov       rax,	[rbp + mm_parse.readsunit.ulist]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L9068
L9069:
    mov       rcx,	6
    mov       rdx,	[rbp + mm_parse.readsunit.ulist]
    call      mm_lib.createunit1
    jmp       L9067
L9068:
    mov       rax,	[rbp + mm_parse.readsunit.ulist]
L9067:
L9016:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readbxdata
mm_parse.readbxdata:
;?>>
   %define R.p rdi
   %define R.curralloc rbx
   %define R.n rsi
   %define R.q r12
   %define R.r r13
   %define R.qnew r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	4
    xor       rsi,	rsi
    xor       eax,	eax
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       r13,	rax
    mov       r12,	rax
L9071:
    call      mm_lex.lex
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L9072
L9074:
    cmp       rsi,	rbx
    jnz       L9076
    mov       rax,	rbx
    shl       rax,	1
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       r14,	rax
    mov       rcx,	r14
    mov       rdx,	r12
    mov       r8,	rsi
    call      memcpy
    mov       rax,	r13
    sub       rax,	r12
    lea       r10,	[r14 + rax]
    mov       r13,	r10
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mlib.pcm_free
    mov       r12,	r14
L9076:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10,	r13
    inc       r13
    mov       [r10],	al
    inc       rsi
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L9072
L9078:
    jmp       L9071
L9072:
    mov       rcx,	10
    call      mm_parse.checksymbol
    call      mm_lex.lex
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mm_lib.createstringconstunit
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+45],	al
    mov       rax,	rdi
L9070:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.checknotempty
mm_parse.checknotempty:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L9082
    movzx     rax,	byte [rdi]
    cmp       rax,	6
    jnz       L9081
    mov       rax,	[rdi+16]
    test      rax,	rax
    jnz       L9081
L9082:
    lea       rcx,	[L13441]
    call      mm_support.serror
L9081:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.newsourcefile
mm_support.newsourcefile:
;?>>
   %define R.pf rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	68
    call      mlib.pcm_allocz
    mov       rdi,	rax
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	300
    jl        L9085
    lea       rcx,	[L13442]
    lea       rdx,	[L13443]
    lea       r8,	[L13443]
    call      mm_support.loaderror
L9085:
    inc       qword [mm_decls.nsourcefiles]
    mov       rax,	[mm_decls.nsourcefiles]
    mov       r10,	rdi
    lea       r11,	[mm_decls.sources]
    mov       [r11 + rax*8],	r10
    mov       ax,	[mm_decls.nsourcefiles]
    mov       [rdi+64],	ax
    mov       rax,	rdi
L9083:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.mcerror
mm_support.mcerror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13444]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.serror_gen
mm_support.serror_gen:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	42
    call      mm_support.showdivider
    call      msys.m$print_startcon
    lea       rcx,	[L13445]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    mov       rdx,	[mm_decls.currproc]
    call      mm_support.showerrorsource
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    lea       r10,	[mm_decls.lx]
    mov       r10d,	[r10+4]
    shr       r10,	24
    and       r10,	255
    lea       r11,	[mm_decls.sources]
    mov       r11,	[r11 + r10*8]
    mov       r11,	[r11+24]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mm_support.stopcompiler
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.showdivider
mm_support.showdivider:
;?>>
   %define R.ch rbx
   %define R.av_1 rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	87
L9089:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
    dec       rdi
    jnz       L9089
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.showerrorsource
mm_support.showerrorsource:
;?>>
    %define mm_support.showerrorsource.pos 72
    %define mm_support.showerrorsource.stproc 80
   %define R.fileno rdi
   %define R.lineoffset rbx
   %define R.errorline rsi
   %define R.s r12
   %define R.av_1 r13
   %define R.av_2 r14
   %define R.av_3 r15
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rcx,	[rbp + mm_support.showerrorsource.pos]
    call      mm_support.getfileno
    mov       rdi,	rax
    call      msys.m$print_startcon
    lea       rcx,	[L13446]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mm_support.showerrorsource.pos]
    call      mm_support.getlineno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_support.showerrorsource.stproc]
    test      rax,	rax
    jz        L9094
    mov       rax,	[rbp + mm_support.showerrorsource.stproc]
    movzx     rax,	byte [rax+78]
    cmp       rax,	6
    jnz       L9094
    call      msys.m$print_startcon
    lea       rcx,	[L13447]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + mm_support.showerrorsource.stproc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9094:
    call      msys.m$print_startcon
    lea       rcx,	[L13448]
    call      msys.m$print_setfmt
    lea       rax,	[mm_decls.sources]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.sources]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax+24]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	45
    call      mm_support.showdivider
    mov       rcx,	[rbp + mm_support.showerrorsource.pos]
    call      mm_support.getsourceline
    mov       rsi,	rax
    mov       r12,	rax
    mov       rcx,	[rbp + mm_support.showerrorsource.pos]
    call      mm_support.getsourcepos
    sub       rax,	rsi
    mov       rbx,	rax
    mov       r13,	6
L9095:
    call      msys.m$print_startcon
    lea       rcx,	[L13449]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       r13
    jnz       L9095
    jmp       L9099
L9098:
    call      msys.m$print_startcon
    mov       rax,	r12
    inc       r12
    movzx     rax,	byte [rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
L9099:
    movzx     rax,	byte [r12]
    cmp       rax,	10
    jz        L9101
    test      rax,	rax
    jnz       L9098
L9101:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r12,	rsi
    mov       r14,	6
L9102:
    call      msys.m$print_startcon
    lea       rcx,	[L13449]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       r14
    jnz       L9102
    mov       r15,	rbx
    cmp       r15,	0
    jle       L9107
L9105:
    movzx     rax,	byte [r12]
    cmp       rax,	9
    jnz       L9109
    call      msys.m$print_startcon
    mov       rcx,	9
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
    jmp       L9108
L9109:
    call      msys.m$print_startcon
    mov       rcx,	32
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
L9108:
    inc       r12
    dec       r15
    jnz       L9105
L9107:
    call      msys.m$print_startcon
    lea       rcx,	[L13450]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	45
    call      mm_support.showdivider
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.stopcompiler
mm_support.stopcompiler:
;?>>
   %define R.filename rbx
   %define R.lineno rsi
   %define R.f rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rcx,	[L13451]
    lea       rdx,	[L13452]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      fclose
    call      msys.m$print_startcon
    lea       rcx,	[L13453]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_getch
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.serror
mm_support.serror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.serror_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.serror_s
mm_support.serror_s:
;?>>
   %define R.mess rdi
   %define R.a rbx
    %define mm_support.serror_s.str -256
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rcx,	[rbp + mm_support.serror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mm_support.serror_s.str]
    call      mm_support.serror_gen
;---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.error_gen
mm_support.error_gen:
;?>>
   %define R.pass rbx
   %define R.mess rsi
   %define R.p r12
   %define R.pos rdi
    %define mm_support.error_gen.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    test      r12,	r12
    jz        L9115
    call      msys.m$print_startcon
    lea       rcx,	[L13454]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       eax,	[r12+4]
    mov       rdi,	rax
    jmp       L9114
L9115:
    call      msys.m$print_startcon
    lea       rcx,	[L13455]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[pc_decls.mmpos]
L9114:
    call      msys.m$print_startcon
    lea       rcx,	[L13456]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      mm_support.getfileno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	42
    call      mm_support.showdivider
    mov       rax,	rbx
    cmp       rax,	78
    jz        L9117
    cmp       rax,	84
    jz        L9118
    cmp       rax,	71
    jz        L9119
    cmp       rax,	65
    jz        L9120
    jmp       L9121
L9117:
    call      msys.m$print_startcon
    lea       rcx,	[L13457]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9116
L9118:
    call      msys.m$print_startcon
    lea       rcx,	[L13458]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9116
L9119:
    call      msys.m$print_startcon
    lea       rcx,	[L13459]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9116
L9120:
    call      msys.m$print_startcon
    lea       rcx,	[L13460]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9121:
L9116:
    mov       rcx,	rdi
    mov       rdx,	[mm_decls.currproc]
    call      mm_support.showerrorsource
    call      msys.m$print_startcon
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      mm_support.getlineno
    mov       [rbp + mm_support.error_gen.$T1],	rax
    mov       rcx,	rdi
    call      mm_support.getfileno
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+24]
    mov       rcx,	r10
    mov       rdx,	[rbp + mm_support.error_gen.$T1]
    call      mm_support.stopcompiler
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.rxerror
mm_support.rxerror:
;?>>
   %define R.mess rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	78
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_support.error_gen
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.gerror
mm_support.gerror:
;?>>
   %define R.mess rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	71
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_support.error_gen
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.txerror
mm_support.txerror:
;?>>
   %define R.mess rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	84
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_support.error_gen
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.txerror_s
mm_support.txerror_s:
;?>>
   %define R.mess rdi
   %define R.a rbx
   %define R.p rsi
    %define mm_support.txerror_s.str -256
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[rbp + mm_support.txerror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	84
    lea       rdx,	[rbp + mm_support.txerror_s.str]
    mov       r8,	rsi
    call      mm_support.error_gen
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.txerror_ss
mm_support.txerror_ss:
;?>>
   %define R.mess rdi
   %define R.a rbx
   %define R.b rsi
    %define mm_support.txerror_ss.str -256
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[rbp + mm_support.txerror_ss.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	84
    lea       rdx,	[rbp + mm_support.txerror_ss.str]
    xor       r8d,	r8d
    call      mm_support.error_gen
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.rxerror_s
mm_support.rxerror_s:
;?>>
   %define R.mess rdi
   %define R.a rbx
   %define R.p rsi
    %define mm_support.rxerror_s.str -256
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[rbp + mm_support.rxerror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	78
    lea       rdx,	[rbp + mm_support.rxerror_s.str]
    mov       r8,	rsi
    call      mm_support.error_gen
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.gerror_s
mm_support.gerror_s:
;?>>
   %define R.mess rdi
   %define R.s rbx
   %define R.p rsi
    %define mm_support.gerror_s.str -256
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[rbp + mm_support.gerror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	71
    lea       rdx,	[rbp + mm_support.gerror_s.str]
    mov       r8,	rsi
    call      mm_support.error_gen
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.lxerror_gen
mm_support.lxerror_gen:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13461]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L13462]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    shr       rax,	24
    and       rax,	255
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+24]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L13463]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rcx,	[L13464]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    lea       r10,	[mm_decls.lx]
    mov       r10d,	[r10+4]
    shr       r10,	24
    and       r10,	255
    lea       r11,	[mm_decls.sources]
    mov       r11,	[r11 + r10*8]
    mov       r11,	[r11+24]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mm_support.stopcompiler
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.lxerror
mm_support.lxerror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.lxerror_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.loaderror
mm_support.loaderror:
;?>>
   %define R.mess rdi
   %define R.mess2 rbx
   %define R.mess3 rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13465]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L13466]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.gs_additem
mm_support.gs_additem:
;?>>
   %define R.dest r12
   %define R.s r13
   %define R.d rdi
   %define R.lastchar rbx
   %define R.nextchar rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rdi,	[r12]
    mov       eax,	[r12+8]
    test      eax,	eax
    jz        L9134
    movsxd    rax,	dword [r12+8]
    lea       r10,	[rdi + rax]
    sub       r10,	1
    movzx     r10,	byte [r10]
    mov       rbx,	r10
    movzx     rax,	byte [r13]
    mov       rsi,	rax
    mov       rcx,	rbx
    call      mm_support.isalphanum
    test      rax,	rax
    jz        L9136
    mov       rcx,	rsi
    call      mm_support.isalphanum
    test      rax,	rax
    jz        L9136
    mov       rcx,	r12
    lea       rdx,	[L13467]
    mov       r8,	-1
    call      mlib.strbuffer_add
L9136:
L9134:
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.gs_copytostr
mm_support.gs_copytostr:
;?>>
   %define R.source rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       eax,	[rdi+8]
    test      eax,	eax
    jz        L9139
    movsxd    rax,	dword [rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
    movsxd    rax,	dword [rdi+8]
    xor       r10d,	r10d
    mov       [rbx + rax],	r10b
    jmp       L9138
L9139:
    xor       eax,	eax
    mov       [rbx],	al
L9138:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.isalphanum
mm_support.isalphanum:
;?>>
   %define R.c rcx
;?]]
;---------------
    cmp       rcx,	65
    jl        L9144
    cmp       rcx,	90
    jle       L9143
L9144:
    cmp       rcx,	97
    jl        L9145
    cmp       rcx,	122
    jle       L9143
L9145:
    cmp       rcx,	48
    jl        L9142
    cmp       rcx,	57
    jg        L9142
L9143:
    mov       rax,	1
    jmp       L9140
L9142:
    xor       eax,	eax
L9140:
;---------------
    ret       
;End 
;Proc mm_support.init_tt_tables
mm_support.init_tt_tables:
;?>>
   %define R.i rdi
   %define R.size rbx
   %define R.bitsize rsi
   %define R.av_1 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    xor       rdi,	rdi
    mov       rax,	30
    mov       r12,	rax
    cmp       r12,	0
    jl        L9149
L9147:
    lea       rax,	[mm_tables.stdnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[mm_decls.ttname]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       eax,	edi
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_tables.stdsize]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10]
    shl       rax,	3
    mov       rsi,	rax
    mov       rax,	rsi
    test      rax,	rax
    jz        L9151
    cmp       rax,	1
    jz        L9152
    cmp       rax,	2
    jz        L9152
    cmp       rax,	4
    jz        L9152
    jmp       L9153
L9151:
    xor       rbx,	rbx
    jmp       L9150
L9152:
    mov       rbx,	1
    jmp       L9150
L9153:
    mov       rax,	rsi
    sar       rax,	3
    mov       rbx,	rax
L9150:
    mov       eax,	ebx
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       rax,	rdi
    cmp       rax,	14
    jz        L9155
    cmp       rax,	15
    jz        L9155
    cmp       rax,	16
    jz        L9155
    cmp       rax,	3
    jz        L9155
    cmp       rax,	17
    jz        L9156
    cmp       rax,	18
    jz        L9156
    cmp       rax,	19
    jz        L9156
    cmp       rax,	4
    jz        L9156
    cmp       rax,	12
    jz        L9156
    cmp       rax,	5
    jz        L9156
    cmp       rax,	2
    jz        L9157
    cmp       rax,	1
    jz        L9157
    cmp       rax,	7
    jz        L9158
    cmp       rax,	20
    jz        L9158
    cmp       rax,	21
    jz        L9158
    jmp       L9159
L9155:
    mov       al,	1
    lea       r10,	[mm_decls.ttsigned]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       al,	1
    lea       r10,	[mm_decls.ttisinteger]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    jmp       L9154
L9156:
    mov       al,	1
    lea       r10,	[mm_decls.ttisinteger]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    jmp       L9154
L9157:
    mov       al,	1
    lea       r10,	[mm_decls.ttisreal]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    jmp       L9154
L9158:
    mov       al,	1
    lea       r10,	[mm_decls.ttisref]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L9159:
L9154:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9161
    cmp       rbx,	8
    jge       L9161
    mov       al,	1
    lea       r10,	[mm_decls.ttisshort]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L9161:
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       rax,	rdi
    cmp       rax,	8
    jz        L9164
    cmp       rax,	9
    jz        L9164
    cmp       rax,	10
    jz        L9164
    cmp       rax,	11
    jnz       L9163
L9164:
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L9163:
    inc       rdi
    cmp       rdi,	r12
    jle       L9147
L9149:
    mov       eax,	7
    lea       r10,	[mm_decls.ttbasetype]
    mov       [r10+80],	eax
    mov       eax,	12
    lea       r10,	[mm_decls.tttarget]
    mov       [r10+80],	eax
    mov       rax,	30
    mov       [mm_decls.ntypes],	rax
    xor       ecx,	ecx
    mov       rdx,	24
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       [mm_tables.trefproc],	rax
    xor       ecx,	ecx
    mov       rdx,	25
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       [mm_tables.treflabel],	rax
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getsupportfile
mm_support.getsupportfile:
;?>>
   %define R.filename r13
   %define R.ext r14
   %define R.path r15
    %define mm_support.getsupportfile.filespec -304
    %define mm_support.getsupportfile.filespec2 -608
   %define R.file rdi
   %define R.fileno rbx
   %define R.pfile rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	648
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rdi,	r13
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	3
    jnz       L9167
    call      msys.m$print_startcon
    lea       rcx,	[L13468]
    call      msys.m$print_setfmt
    mov       rcx,	r13
    call      msys.m$print_str_nf
    mov       rcx,	r14
    call      msys.m$print_str_nf
    mov       rcx,	r15
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9167:
    mov       al,	[r14]
    test      al,	al
    jz        L9169
    mov       rcx,	r13
    mov       rdx,	r14
    call      mlib.addext
    lea       rcx,	[rbp + mm_support.getsupportfile.filespec]
    mov       rdx,	rax
    call      strcpy
    lea       rax,	[rbp + mm_support.getsupportfile.filespec]
    mov       rdi,	rax
L9169:
    mov       al,	[mm_decls.loadedfromma]
    test      al,	al
    jz        L9171
    mov       rcx,	rdi
    call      mlib.extractfile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
L9171:
    mov       r12,	1
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L9174
L9172:
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L9176
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    mov       al,	[rax+56]
    test      al,	al
    jnz       L9176
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    jmp       L9165
L9176:
    inc       r12
    cmp       r12,	[mm_decls.nsourcefiles]
    jle       L9172
L9174:
    mov       rcx,	rdi
    call      mm_support.isabspath
    test      rax,	rax
    jnz       L9178
    lea       rcx,	[rbp + mm_support.getsupportfile.filespec2]
    mov       rdx,	r15
    call      strcpy
    lea       rcx,	[rbp + mm_support.getsupportfile.filespec2]
    mov       rdx,	rdi
    call      strcat
    lea       rax,	[rbp + mm_support.getsupportfile.filespec2]
    mov       rdi,	rax
L9178:
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	3
    jnz       L9180
    test      rbx,	rbx
    jz        L9180
    call      msys.m$print_startcon
    lea       rcx,	[L13469]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9180:
    test      rdi,	rdi
    jz        L9183
    mov       rcx,	rdi
    call      mlib.checkfile
    test      rax,	rax
    jnz       L9182
L9183:
    lea       rcx,	[L13470]
    mov       rdx,	rdi
    lea       r8,	[L13471]
    call      mm_support.loaderror
L9182:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_modules.loadsourcefile
    mov       rsi,	rax
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	3
    jnz       L9185
    test      rsi,	rsi
    jz        L9185
    call      msys.m$print_startcon
    lea       rcx,	[L13472]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9185:
    mov       al,	1
    mov       [rsi+57],	al
    mov       rax,	rsi
L9165:
;---------------
    add       rsp,	648
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.isabspath
mm_support.isabspath:
;?>>
   %define R.filespec rbx
   %define R.path rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mlib.extractpath
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	92
    jz        L9189
    cmp       rax,	47
    jz        L9189
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jz        L9188
    movzx     rax,	byte [rdi+1]
    cmp       rax,	58
    jnz       L9188
L9189:
    mov       rax,	1
    jmp       L9186
L9188:
    xor       eax,	eax
L9186:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.initbblib
mm_support.initbblib:
;?>>
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    mov       rbx,	1
    mov       rdi,	6
    cmp       rdi,	1
    jl        L9193
L9191:
    lea       rax,	[mm_tables.d_typestarterset]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       r10b,	1
    lea       r11,	[mm_decls.typestarterset]
    mov       [r11 + rax],	r10b
    inc       rbx
    cmp       rbx,	rdi
    jle       L9191
L9193:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getfileno
mm_support.getfileno:
;?>>
   %define R.pos rbx
   %define R.fileno rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	rbx
    shr       rax,	24
    and       rax,	255
    mov       rdi,	rax
    cmp       rdi,	1
    jl        L9197
    cmp       rdi,	[mm_decls.nsourcefiles]
    jle       L9196
L9197:
    lea       rcx,	[L13473]
    call      mlib.abortprogram
L9196:
    mov       rax,	rdi
L9194:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getlineno
mm_support.getlineno:
;?>>
   %define R.pos r13
   %define R.source rdi
   %define R.sline rbx
   %define R.s rsi
   %define R.lineno r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mm_support.getsourcestart
    mov       rdi,	rax
    mov       rcx,	r13
    call      mm_support.getsourceline
    mov       rbx,	rax
    mov       rsi,	rbx
    mov       r12,	1
    jmp       L9200
L9199:
    movzx     rax,	byte [rsi]
    cmp       rax,	10
    jnz       L9203
    inc       r12
L9203:
    dec       rsi
L9200:
    cmp       rsi,	rdi
    jae       L9199
    mov       rax,	r12
L9198:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getsourceline
mm_support.getsourceline:
;?>>
   %define R.pos rsi
   %define R.source rdi
   %define R.s rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_support.getsourcestart
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mm_support.getsourcepos
    mov       rbx,	rax
    jmp       L9206
L9205:
    dec       rbx
L9206:
    cmp       rbx,	rdi
    jbe       L9208
    movzx     rax,	byte [rbx]
    cmp       rax,	10
    jnz       L9205
L9208:
    movzx     rax,	byte [rbx]
    cmp       rax,	10
    jnz       L9210
    inc       rbx
L9210:
    mov       rax,	rbx
L9204:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getsourcestart
mm_support.getsourcestart:
;?>>
   %define R.pos rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.getfileno
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+32]
    mov       rax,	r10
L9211:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.getsourcepos
mm_support.getsourcepos:
;?>>
   %define R.pos rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.getfileno
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+32]
    mov       rax,	rdi
    and       rax,	16777215
    lea       r10,	[r10 + rax]
    mov       rax,	r10
L9212:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.mgetsourceinfo
mm_support.mgetsourceinfo:
;?>>
   %define R.pos rbx
   %define R.filename rsi
   %define R.sourceline r12
   %define R.lineno rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    call      mm_support.getlineno
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mm_support.getsourcestart
    mov       [r12],	rax
    mov       rcx,	rbx
    call      mm_support.getfileno
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+24]
    mov       [rsi],	r10
    mov       rax,	rdi
L9213:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.do_writema
mm_support.do_writema:
;?>>
   %define R.inpfile r14
    %define mm_support.do_writema.filename -304
    %define mm_support.do_writema.sflist -2704
   %define R.f rdi
   %define R.offset rbx
   %define R.nfiles rsi
   %define R.pf r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2736
    mov       r14,	rcx
;---------------
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	1
    jnz       L9214
L9216:
    mov       rcx,	r14
    lea       rdx,	[L13474]
    call      mlib.changeext
    lea       rcx,	[rbp + mm_support.do_writema.filename]
    mov       rdx,	rax
    call      strcpy
    xor       rsi,	rsi
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L9219
L9217:
    lea       rax,	[mm_decls.sources]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    mov       al,	[rax+56]
    test      al,	al
    jnz       L9221
    inc       rsi
    mov       rax,	rsi
    mov       r10,	r13
    mov       [rbp + rax*8 + mm_support.do_writema.sflist-8],	r10
L9221:
    inc       r13
    cmp       r13,	[mm_decls.nsourcefiles]
    jle       L9217
L9219:
    test      rsi,	rsi
    jnz       L9223
    lea       rcx,	[L13475]
    lea       rdx,	[L13476]
    lea       r8,	[L13476]
    call      mm_support.loaderror
L9223:
    lea       rcx,	[rbp + mm_support.do_writema.filename]
    lea       rdx,	[L13477]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L9225
    lea       rcx,	[L13478]
    lea       rdx,	[rbp + mm_support.do_writema.filename]
    lea       r8,	[L13479]
    call      mm_support.loaderror
L9225:
    mov       rax,	[mm_decls.fverbose]
    test      rax,	rax
    jz        L9227
    call      msys.m$print_startcon
    lea       rcx,	[L13480]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mm_support.do_writema.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9227:
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13481]
    call      msys.m$print_setfmt
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r13,	1
    cmp       rsi,	1
    jl        L9230
L9228:
    mov       rax,	[rbp + r13*8 + mm_support.do_writema.sflist-8]
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13482]
    call      msys.m$print_setfmt
    mov       rcx,	[r12+8]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r12+56]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte [r12+57]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    mov       rcx,	r13
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      mlib.getfilepos
    mov       rbx,	rax
    mov       rax,	[r12+48]
    mov       r10,	[r12+40]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rbx
    mov       r9,	rax
    call      mlib.writerandom
    inc       r13
    cmp       r13,	rsi
    jle       L9228
L9230:
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13483]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r13,	1
    cmp       rsi,	1
    jl        L9233
L9231:
    mov       rax,	[rbp + r13*8 + mm_support.do_writema.sflist-8]
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rcx,	r13
    call      msys.m$print_i64_nf
    mov       rcx,	[r12+8]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r12+56]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte [r12+57]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       r13
    cmp       r13,	rsi
    jle       L9231
L9233:
    mov       rcx,	rdi
    call      fclose
    xor       ecx,	ecx
    call      exit
L9214:
;---------------
    add       rsp,	2736
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.do_getinfo
mm_support.do_getinfo:
;?>>
   %define R.filename r13
   %define R.f rdi
   %define R.fs rbx
   %define R.pm rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	2
    jnz       L9236
    mov       rcx,	r13
    lea       rdx,	[L13484]
    call      mlib.changeext
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    lea       rdx,	[L13485]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L9238
    call      msys.m$print_startcon
    lea       rcx,	[L13486]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    mov       rdx,	[mm_decls.stprogram]
    call      mm_support.getst
    mov       rcx,	rdi
    call      fclose
L9238:
L9236:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	3
    jnz       L9240
    mov       rcx,	r13
    lea       rdx,	[L13487]
    call      mlib.changeext
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    lea       rdx,	[L13488]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L9242
    call      msys.m$print_startcon
    lea       rcx,	[L13489]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r12,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L9245
L9243:
    lea       rax,	[mm_decls.modules]
    mov       r10,	r12
    mov       rsi,	[rax + r10*8]
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rax,	[rsi]
    mov       rcx,	rax
    lea       rdx,	[L13490]
    call      msys.m$print_str
    movsx     rax,	word [rsi+18]
    lea       r10,	[mm_decls.subprogs]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10]
    mov       rcx,	r10
    lea       rdx,	[L13490]
    call      msys.m$print_str
    mov       rax,	[rsi+8]
    mov       rax,	[rax+24]
    mov       rcx,	rax
    lea       rdx,	[L13491]
    call      msys.m$print_str
    movzx     rax,	byte [rsi+22]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       r12
    cmp       r12,	[mm_decls.nmodules]
    jle       L9243
L9245:
    mov       rcx,	rdi
    call      fclose
L9242:
L9240:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getst
mm_support.getst:
;?>>
   %define R.f rbx
   %define R.d rsi
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mm_support.getstrec
    mov       rdi,	[rsi+16]
    jmp       L9250
L9247:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_support.getst
    mov       rdi,	[rdi+32]
L9250:
    test      rdi,	rdi
    jnz       L9247
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getstrec
mm_support.getstrec:
;?>>
   %define R.f rbx
   %define R.d rsi
   %define R.name rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [rsi+78]
    cmp       rax,	6
    jz        L9253
    cmp       rax,	7
    jz        L9253
    cmp       rax,	5
    jz        L9253
    cmp       rax,	9
    jz        L9253
    cmp       rax,	10
    jz        L9253
    cmp       rax,	15
    jz        L9253
    cmp       rax,	8
    jnz       L9254
L9253:
    jmp       L9252
L9254:
    jmp       L9251
L9252:
    mov       rax,	[rsi+8]
    test      rax,	rax
    jz        L9256
    mov       rax,	[rsi+8]
    movzx     rax,	byte [rax+78]
    cmp       rax,	3
    jnz       L9251
L9256:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    movzx     rax,	byte [rsi+94]
    lea       r10,	[mm_decls.moduletosub]
    movzx     r10,	byte [r10 + rax]
    lea       rax,	[mm_decls.subprogs]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13492]
    call      msys.m$print_str
    call      msys.m$print_space
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rax,	[rsi+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13493]
    call      msys.m$print_str
    call      msys.m$print_space
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rax,	[rsi]
    mov       rcx,	rax
    lea       rdx,	[L13494]
    call      msys.m$print_str
    call      msys.m$print_space
    call      msys.m$print_end
    movzx     rax,	byte [rsi+78]
    cmp       rax,	6
    jz        L9258
    cmp       rax,	7
    jz        L9259
    jmp       L9260
L9258:
    mov       eax,	[rsi+72]
    test      eax,	eax
    jz        L9262
    lea       rax,	[L13495]
    jmp       L9261
L9262:
    lea       rax,	[L13496]
L9261:
    mov       rdi,	rax
    jmp       L9257
L9259:
    mov       eax,	[rsi+72]
    test      eax,	eax
    jz        L9264
    lea       rax,	[L13497]
    jmp       L9263
L9264:
    lea       rax,	[L13498]
L9263:
    mov       rdi,	rax
    jmp       L9257
L9260:
    movzx     rax,	byte [rsi+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rdi,	r10
L9257:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	rdi
    lea       rdx,	[L13499]
    call      msys.m$print_str
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       eax,	[rsi+88]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       rcx,	rax
    lea       rdx,	[L13500]
    call      msys.m$print_i64
    call      msys.m$print_space
    call      msys.m$print_end
    movzx     rax,	byte [rsi+170]
    test      rax,	rax
    jz        L9266
    cmp       rax,	1
    jz        L9267
    cmp       rax,	2
    jz        L9268
    jmp       L9269
L9266:
    lea       rax,	[L13501]
    mov       rdi,	rax
    jmp       L9265
L9267:
    lea       rax,	[L13502]
    mov       rdi,	rax
    jmp       L9265
L9268:
    lea       rax,	[L13503]
    mov       rdi,	rax
    jmp       L9265
L9269:
    lea       rax,	[L13504]
    mov       rdi,	rax
L9265:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_space
    call      msys.m$print_end
    movzx     rax,	word [rsi+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L9271
    mov       rcx,	rbx
    call      msys.m$print_startfile
    lea       rcx,	[L13505]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L9271:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    movsxd    rax,	dword [rsi+72]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    lea       rdx,	[L13506]
    call      msys.m$print_str
    call      msys.m$print_space
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    movzx     rax,	byte [rsi+94]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    movsx     r10,	word [r10+20]
    lea       rax,	[mm_decls.sources]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+24]
    mov       rcx,	rax
    lea       rdx,	[L13507]
    call      msys.m$print_str
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L9251:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_tables.start
mm_tables.start:
;?>>
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    mov       rbx,	1
    mov       rdi,	12
    cmp       rdi,	1
    jl        L9275
L9273:
    lea       rax,	[mm_tables.exprendsymbols]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    mov       r10b,	1
    lea       r11,	[mm_tables.endsexpr]
    mov       [r11 + rax-1],	r10b
    inc       rbx
    cmp       rbx,	rdi
    jle       L9273
L9275:
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+33],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+34],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+15],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+16],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+17],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+18],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+19],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+43],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+44],	al
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tpass
mm_type.tpass:
;?>>
   %define R.p r14
    %define mm_type.tpass.t 72
    %define mm_type.tpass.lv 80
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
   %define R.oldmmpos r12
   %define R.m r13
    %define mm_type.tpass.paramtype -8
    %define mm_type.tpass.restype -16
    %define mm_type.tpass.av_1 -24
    %define mm_type.tpass.i -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    test      r14,	r14
    jnz       L9278
    jmp       L9276
L9278:
    mov       rax,	[mm_type.tpass.depth]
    cmp       rax,	100
    jnz       L9280
    lea       rcx,	[L13508]
    xor       edx,	edx
    call      mm_support.txerror
L9280:
    inc       qword [mm_type.tpass.depth]
    mov       r12,	[pc_decls.mmpos]
    mov       eax,	[r14+4]
    mov       [pc_decls.mmpos],	rax
    mov       rdi,	[r14+16]
    mov       rbx,	[r14+24]
    mov       rsi,	[r14+32]
    mov       rax,	[rbp + mm_type.tpass.t]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       [r14+61],	al
    movzx     rax,	byte [r14]
    sub       rax,	1
    cmp       rax,	122
    jae       L9283
    lea       r10,	[L9282]
    jmp       [r10 + rax*8]
    segment .data
L9282:
    dq  L9285
    dq  L9283
    dq  L9283
    dq  L9284
    dq  L9283
    dq  L9316
    dq  L9285
    dq  L9346
    dq  L9283
    dq  L9349
    dq  L9349
    dq  L9350
    dq  L9388
    dq  L9391
    dq  L9304
    dq  L9304
    dq  L9305
    dq  L9305
    dq  L9305
    dq  L9332
    dq  L9309
    dq  L9390
    dq  L9283
    dq  L9389
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9294
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9302
    dq  L9288
    dq  L9382
    dq  L9288
    dq  L9290
    dq  L9291
    dq  L9292
    dq  L9293
    dq  L9308
    dq  L9289
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9300
    dq  L9283
    dq  L9315
    dq  L9303
    dq  L9283
    dq  L9314
    dq  L9314
    dq  L9301
    dq  L9283
    dq  L9295
    dq  L9298
    dq  L9283
    dq  L9306
    dq  L9387
    dq  L9329
    dq  L9307
    dq  L9286
    dq  L9283
    dq  L9283
    dq  L9287
    dq  L9287
    dq  L9351
    dq  L9368
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9367
    dq  L9367
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9283
    dq  L9354
    dq  L9345
    dq  L9345
    dq  L9319
    dq  L9369
    dq  L9328
    dq  L9299
    dq  L9326
    dq  L9326
    dq  L9327
    dq  L9327
    dq  L9337
    dq  L9341
    dq  L9335
    dq  L9336
    dq  L9334
    dq  L9334
    dq  L9334
    dq  L9318
    dq  L9313
    dq  L9313
    dq  L9312
    dq  L9312
    dq  L9312
    dq  L9312
    dq  L9310
    dq  L9311
    dq  L9362
    dq  L9320
    dq  L9320
    dq  L9320
    dq  L9320
    dq  L9356
    dq  L9355
    dq  L9333
    dq  L9317
    dq  L9383
    segment .text
L9284:
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_type.tpass.t]
    mov       r8,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_name
    jmp       L9281
L9285:
    jmp       L9281
L9286:
    mov       eax,	3
    mov       [r14+49],	eax
    jmp       L9281
L9287:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	3
    mov       [r14+49],	eax
    jmp       L9281
L9288:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_bin
    jmp       L9281
L9289:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_in
    jmp       L9281
L9290:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_unary
    jmp       L9281
L9291:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_prop
    jmp       L9281
L9292:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_binto
    jmp       L9281
L9293:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_unaryto
    jmp       L9281
L9294:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_assign
    jmp       L9281
L9295:
    movzx     rax,	byte [rdi]
    cmp       rax,	53
    jnz       L9297
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    mov       rax,	[r14+16]
    mov       rcx,	r14
    mov       rdx,	rax
    call      mm_lib.deleteunit
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_type.tpass.t]
    mov       r8,	[rbp + mm_type.tpass.lv]
    call      mm_type.tpass
    jmp       L9296
L9297:
    mov       rcx,	rdi
    mov       rdx,	23
    call      mm_type.tpasslv
    movsxd    rax,	dword [rdi+49]
    xor       ecx,	ecx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       [r14+49],	eax
L9296:
    jmp       L9281
L9298:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_addroffirst
    jmp       L9281
L9299:
    push      qword [rbp + mm_type.tpass.lv]
    push      qword [rbp + mm_type.tpass.t]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_type.tx_if
    add       rsp,	48
    jmp       L9281
L9300:
    sub       rsp,	8
    push      qword [rbp + mm_type.tpass.lv]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.t]
    sub       rsp,	32
    call      mm_type.tx_index
    add       rsp,	48
    jmp       L9281
L9301:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_ptr
    jmp       L9281
L9302:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_callproc
    jmp       L9281
L9303:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_dot
    jmp       L9281
L9304:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_andl
    jmp       L9281
L9305:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_notl
    jmp       L9281
L9306:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	1
    call      mm_type.tx_convert
    jmp       L9281
L9307:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_typepun
    jmp       L9281
L9308:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_incrto
    jmp       L9281
L9309:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_makerange
    jmp       L9281
L9310:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_swap
    jmp       L9281
L9311:
    push      qword [rbp + mm_type.tpass.lv]
    push      qword [rbp + mm_type.tpass.t]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_type.tx_select
    add       rsp,	48
    jmp       L9281
L9312:
    push      qword [rbp + mm_type.tpass.lv]
    push      qword [rbp + mm_type.tpass.t]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_type.tx_switch
    add       rsp,	48
    jmp       L9281
L9313:
    push      qword [rbp + mm_type.tpass.lv]
    push      qword [rbp + mm_type.tpass.t]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_type.tx_case
    add       rsp,	48
    jmp       L9281
L9314:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_dotindex
    jmp       L9281
L9315:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_slice
    jmp       L9281
L9316:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_block
    jmp       L9281
L9317:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9281
L9318:
    mov       rcx,	rdi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9281
L9319:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_return
    jmp       L9281
L9320:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    mov       rcx,	rdi
    call      mm_type.fixchararray
    jmp       L9322
L9321:
    movzx     rax,	byte [rbx]
    cmp       rax,	86
    jnz       L9325
    mov       rax,	[rbx+16]
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbx+24]
    mov       rcx,	rax
    mov       rdx,	20
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9324
L9325:
    mov       rax,	rbx
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
L9324:
    mov       rcx,	rsi
    call      mm_type.fixchararray
    mov       rbx,	[rbx+8]
L9322:
    test      rbx,	rbx
    jnz       L9321
    mov       rax,	[r14+32]
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    jmp       L9281
L9326:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_type.tx_for
    jmp       L9281
L9327:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_type.tx_forall
    jmp       L9281
L9328:
    mov       rcx,	rdi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9281
L9329:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tpass.t]
    cmp       rax,	23
    jnz       L9331
    lea       rcx,	[L13509]
    xor       edx,	edx
    call      mm_support.txerror
L9331:
    mov       rcx,	rdi
    mov       rdx,	[rbp + mm_type.tpass.t]
    mov       r8,	1
    call      mm_type.coerceunit
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    jmp       L9281
L9332:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_makelist
    jmp       L9281
L9333:
    mov       rcx,	rdi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9281
L9334:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_exit
    jmp       L9281
L9335:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_goto
    jmp       L9281
L9336:
    jmp       L9281
L9337:
    mov       rcx,	rdi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rdi
    call      mm_type.iscondtrue
    test      rax,	rax
    jz        L9339
    mov       al,	104
    mov       [r14],	al
    mov       [r14+16],	rbx
    jmp       L9338
L9339:
    mov       rcx,	rdi
    call      mm_type.iscondfalse
    test      rax,	rax
    jz        L9340
    mov       al,	2
    mov       [r14],	al
L9340:
L9338:
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9281
L9341:
    mov       rcx,	rdi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    call      mm_type.iscondtrue
    test      rax,	rax
    jnz       L9344
    mov       rcx,	rbx
    call      mm_type.iscondfalse
    test      rax,	rax
    jz        L9343
L9344:
    lea       rcx,	[L13510]
    xor       edx,	edx
    call      mm_support.txerror
L9343:
    jmp       L9281
L9345:
    jmp       L9281
L9346:
    mov       rax,	[rbp + mm_type.tpass.t]
    test      rax,	rax
    jz        L9348
    mov       eax,	[rbp + mm_type.tpass.t]
    mov       [r14+49],	eax
L9348:
    mov       rax,	1
    mov       [mm_type.inassem],	rax
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    mov       rcx,	rsi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    xor       eax,	eax
    mov       [mm_type.inassem],	rax
    jmp       L9281
L9349:
    jmp       L9281
L9350:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9281
L9351:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [rdi]
    cmp       rax,	62
    jnz       L9353
    mov       r13,	[rdi+16]
    jmp       L9352
L9353:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rdi+49]
    mov       r13,	rax
L9352:
    mov       al,	1
    mov       [r14],	al
    mov       eax,	20
    mov       [r14+49],	eax
    xor       eax,	eax
    mov       [r14+16],	rax
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [r14+16],	rax
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      strlen
    inc       rax
    mov       [r14+40],	eax
    mov       al,	1
    mov       [r14+44],	al
    jmp       L9281
L9354:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9281
L9355:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9281
L9356:
    test      rdi,	rdi
    jz        L9358
    mov       rcx,	rdi
    mov       rdx,	5
    xor       r8d,	r8d
    call      mm_type.tpass
L9358:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	[rbp + mm_type.tpass.t]
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L9361
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	[rbp + mm_type.tpass.t]
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9360
L9361:
    mov       rcx,	[rbp + mm_type.tpass.t]
    call      mm_lib.gettypebase
    mov       [rbp + mm_type.tpass.t],	rax
L9360:
    mov       eax,	[rbp + mm_type.tpass.t]
    mov       [r14+49],	eax
    jmp       L9281
L9362:
    test      rdi,	rdi
    jz        L9364
    mov       rcx,	rdi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jz        L9366
    lea       rcx,	[L13511]
    xor       edx,	edx
    call      mm_support.txerror
L9366:
L9364:
    jmp       L9281
L9367:
    mov       eax,	20
    mov       [r14+49],	eax
    jmp       L9281
L9368:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_bitfield
    jmp       L9281
L9369:
    xor       eax,	eax
    mov       [rbp + mm_type.tpass.restype],	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tpass.paramtype],	rax
    movsx     rax,	word [r14+40]
    cmp       rax,	29
    jz        L9371
    cmp       rax,	30
    jz        L9372
    cmp       rax,	31
    jz        L9373
    jmp       L9374
L9371:
    mov       rax,	3
    mov       [rbp + mm_type.tpass.restype],	rax
    jmp       L9370
L9372:
    mov       rax,	3
    mov       [rbp + mm_type.tpass.paramtype],	rax
    mov       rax,	20
    mov       [rbp + mm_type.tpass.restype],	rax
    jmp       L9370
L9373:
    mov       rax,	3
    mov       [rbp + mm_type.tpass.paramtype],	rax
    mov       rax,	7
    mov       [rbp + mm_type.tpass.restype],	rax
L9374:
L9370:
    mov       rax,	[rbp + mm_type.tpass.paramtype]
    test      rax,	rax
    jz        L9376
    test      rdi,	rdi
    jnz       L9378
    lea       rcx,	[L13512]
    xor       edx,	edx
    call      mm_support.txerror
L9378:
    mov       rcx,	rdi
    mov       rdx,	[rbp + mm_type.tpass.paramtype]
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rdi+8]
    test      rax,	rax
    jz        L9380
    lea       rcx,	[L13513]
    xor       edx,	edx
    call      mm_support.txerror
L9380:
    jmp       L9375
L9376:
    test      rdi,	rdi
    jz        L9381
    lea       rcx,	[L13513]
    xor       edx,	edx
    call      mm_support.txerror
L9381:
L9375:
    mov       eax,	[rbp + mm_type.tpass.restype]
    mov       [r14+49],	eax
    jmp       L9281
L9382:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_cmpchain
    jmp       L9281
L9383:
    mov       rcx,	rdi
    mov       rdx,	23
    call      mm_type.tpasslv
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	8
    jz        L9385
    cmp       r10,	10
    jz        L9385
    jmp       L9386
L9385:
    jmp       L9384
L9386:
    lea       rcx,	[L13514]
    xor       edx,	edx
    call      mm_support.txerror
L9384:
    jmp       L9281
L9387:
    jmp       L9281
L9388:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_strinclude
    jmp       L9281
L9389:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_makeslice
    jmp       L9281
L9390:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_makeset
    jmp       L9281
L9391:
    jmp       L9281
L9283:
    call      msys.m$print_startcon
    lea       rcx,	[L13515]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r14]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;mm_type.tpass.doelse:
    mov       rax,	1
    mov       [rbp + mm_type.tpass.i],	rax
    movzx     rax,	byte [r14]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       [rbp + mm_type.tpass.av_1],	r10
    mov       rax,	[rbp + mm_type.tpass.av_1]
    cmp       rax,	1
    jl        L9395
L9393:
    lea       rax,	[r14+16]
    mov       r10,	[rbp + mm_type.tpass.i]
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tpass.t]
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    mov       rax,	[rbp + mm_type.tpass.i]
    inc       rax
    mov       [rbp + mm_type.tpass.i],	rax
    cmp       rax,	[rbp + mm_type.tpass.av_1]
    jle       L9393
L9395:
L9281:
    mov       rcx,	r14
    call      mm_type.tevaluate
    movzx     rax,	byte [r14]
    cmp       rax,	20
    jz        L9397
    cmp       rax,	89
    jnz       L9398
L9397:
    jmp       L9396
L9398:
    mov       rax,	[rbp + mm_type.tpass.t]
    cmp       rax,	23
    jz        L9400
    mov       rax,	[rbp + mm_type.tpass.t]
    test      rax,	rax
    jz        L9400
    movsxd    rax,	dword [r14+49]
    cmp       rax,	[rbp + mm_type.tpass.t]
    jz        L9400
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_type.tpass.t]
    xor       r8d,	r8d
    call      mm_type.coerceunit
L9400:
L9396:
    mov       rax,	[rbp + mm_type.tpass.t]
    test      rax,	rax
    jnz       L9402
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jz        L9404
    cmp       rax,	35
    jz        L9404
    cmp       rax,	36
    jz        L9404
    cmp       rax,	33
    jz        L9404
    cmp       rax,	4
    jz        L9405
    jmp       L9406
L9404:
    jmp       L9403
L9405:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L9409
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	25
    jz        L9408
L9409:
L9408:
L9406:
L9403:
L9402:
    mov       [pc_decls.mmpos],	r12
    dec       qword [mm_type.tpass.depth]
L9276:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_allprocs
mm_type.tx_allprocs:
;?>>
   %define R.pp rdi
   %define R.pcode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rdi,	[mm_decls.proclist]
    jmp       L9412
L9411:
    mov       rax,	[rdi]
    mov       [mm_decls.currproc],	rax
    mov       rax,	[mm_decls.currproc]
    mov       rbx,	[rax+64]
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+122]
    cmp       rax,	1
    jle       L9415
    mov       rax,	28
    jmp       L9414
L9415:
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
L9414:
    mov       rcx,	rbx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    test      r10,	r10
    jz        L9417
    cmp       r10,	28
    jz        L9418
    jmp       L9419
L9417:
    jmp       L9416
L9418:
    jmp       L9416
L9419:
    movzx     rax,	byte [rbx]
    cmp       rax,	89
    jz        L9421
    mov       rcx,	rbx
    mov       rdx,	89
    call      mm_lib.insertunit
    mov       rax,	[mm_decls.currproc]
    mov       eax,	[rax+72]
    mov       [rbx+49],	eax
    mov       al,	1
    mov       [rbx+61],	al
L9421:
L9416:
    mov       rdi,	[rdi+8]
L9412:
    test      rdi,	rdi
    jnz       L9411
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_block
mm_type.tx_block:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.t rsi
   %define R.lv r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    jmp       L9424
L9423:
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rbx,	[rbx+8]
L9424:
    test      rbx,	rbx
    jz        L9426
    mov       rax,	[rbx+8]
    test      rax,	rax
    jnz       L9423
L9426:
    test      rbx,	rbx
    jz        L9428
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_type.tpass
    test      rsi,	rsi
    jz        L9430
    movsxd    rax,	dword [rbx+49]
    jmp       L9429
L9430:
    xor       eax,	eax
L9429:
    mov       [rdi+49],	eax
L9428:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_typetable
mm_type.tx_typetable:
;?>>
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	31
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	31
    jl        L9434
L9432:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jnz       L9436
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    call      mm_type.tx_passdef
L9436:
    mov       rcx,	rbx
    call      mm_type.setmodesize
    inc       rbx
    cmp       rbx,	[mm_decls.ntypes]
    jle       L9432
L9434:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.setmodesize
mm_type.setmodesize:
;?>>
   %define R.m rsi
   %define R.size rdi
   %define R.target rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rsi
    mov       eax,	[rax + r10*4]
    test      eax,	eax
    jnz       L9437
L9439:
    lea       rax,	[mm_decls.ttlineno]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       [pc_decls.mmpos],	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L9441
    cmp       rax,	8
    jz        L9442
    test      rax,	rax
    jz        L9443
    cmp       rax,	24
    jz        L9443
    cmp       rax,	11
    jz        L9444
    cmp       rax,	22
    jz        L9445
    cmp       rax,	23
    jz        L9446
    cmp       rax,	29
    jz        L9447
    cmp       rax,	28
    jz        L9448
    jmp       L9449
L9441:
    mov       rcx,	rsi
    call      mm_type.setarraysize
    jmp       L9440
L9442:
    mov       rcx,	rsi
    call      mm_type.setrecordsize
    jmp       L9440
L9443:
    jmp       L9440
L9444:
    mov       rcx,	rsi
    call      mm_type.setslicesize
    jmp       L9440
L9445:
    lea       rcx,	[L13516]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L9440
L9446:
    jmp       L9440
L9447:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mm_type.setmodesize
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    lea       r10,	[mm_decls.ttnamedef]
    mov       r11,	rsi
    mov       [r10 + r11*8],	rax
    jmp       L9440
L9448:
    jmp       L9440
L9449:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       rdi,	r10
    test      r10,	r10
    jz        L9451
    mov       eax,	edi
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    jmp       L9437
L9451:
    call      msys.m$print_startcon
    lea       rcx,	[L13517]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    lea       rcx,	[L13518]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    lea       rcx,	[L13519]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_tables.stdnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L13520]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9440:
L9437:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.setarraysize
mm_type.setarraysize:
;?>>
    %define mm_type.setarraysize.m 72
   %define R.lower rdi
   %define R.length rbx
   %define R.elemsize rsi
   %define R.target r12
   %define R.size r13
   %define R.pdim r14
   %define R.a r15
    %define mm_type.setarraysize.b -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
;---------------
    lea       rax,	[mm_decls.ttsizeset]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L9452
L9454:
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    mov       r14,	[rax + r10*8]
    test      r14,	r14
    jz        L9456
    mov       r15,	[r14+16]
    mov       rax,	[r14+24]
    mov       [rbp + mm_type.setarraysize.b],	rax
    lea       rax,	[mm_decls.ttowner]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mm_name.rx_unit
    movzx     rax,	byte [r14]
    cmp       rax,	21
    jz        L9458
    cmp       rax,	27
    jz        L9459
    jmp       L9460
L9458:
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	[rbp + mm_type.setarraysize.b]
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r15
    call      mm_type.getconstint
    mov       rdi,	rax
    mov       rcx,	[rbp + mm_type.setarraysize.b]
    call      mm_type.getconstint
    sub       rax,	rdi
    inc       rax
    mov       rbx,	rax
    jmp       L9457
L9459:
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r15
    call      mm_type.getconstint
    mov       rdi,	rax
    mov       rax,	[rbp + mm_type.setarraysize.b]
    test      rax,	rax
    jz        L9462
    mov       rcx,	[rbp + mm_type.setarraysize.b]
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	[rbp + mm_type.setarraysize.b]
    call      mm_type.getconstint
    mov       rbx,	rax
    jmp       L9461
L9462:
    xor       rbx,	rbx
L9461:
    jmp       L9457
L9460:
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r14
    call      mm_type.getconstint
    mov       rbx,	rax
    mov       rdi,	1
L9457:
    jmp       L9455
L9456:
    mov       rdi,	1
    xor       rbx,	rbx
L9455:
    cmp       rbx,	0
    jge       L9464
    lea       rcx,	[L13521]
    xor       edx,	edx
    call      mm_support.txerror
L9464:
    xor       eax,	eax
    lea       r10,	[mm_decls.ttdimexpr]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11*8],	rax
    mov       eax,	edi
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11*4],	eax
    mov       eax,	ebx
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    mov       rcx,	r12
    call      mm_type.setmodesize
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       rsi,	r10
    mov       rax,	rbx
    imul      rax,	rsi
    mov       r13,	rax
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttsizeset]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11],	al
    mov       rcx,	[rbp + mm_type.setarraysize.m]
    call      mm_type.checkblocktype
L9452:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.setslicesize
mm_type.setslicesize:
;?>>
   %define R.m rbx
   %define R.pdim rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    test      eax,	eax
    jnz       L9465
L9467:
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8]
    test      rdi,	rdi
    jz        L9469
    lea       rax,	[mm_decls.ttowner]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mm_name.rx_unit
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rdi
    call      mm_type.getconstint
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    xor       eax,	eax
    lea       r10,	[mm_decls.ttdimexpr]
    mov       r11,	rbx
    mov       [r10 + r11*8],	rax
    jmp       L9468
L9469:
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
L9468:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      mm_type.setmodesize
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax+44]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
L9465:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_module
mm_type.tx_module:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       [mm_decls.currmoduleno],	rdi
    lea       rax,	[mm_decls.modules]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax+24]
    call      mm_type.tx_passdef
    mov       rax,	1
L9470:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_passdef
mm_type.tx_passdef:
;?>>
   %define R.p r12
   %define R.d rdi
   %define R.oldmmpos rbx
   %define R.q rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    movzx     rax,	word [r12+92]
    shr       eax,	2
    and       eax,	1
    test      rax,	rax
    jnz       L9471
L9473:
    mov       rbx,	[pc_decls.mmpos]
    mov       eax,	[r12+88]
    mov       [pc_decls.mmpos],	rax
    mov       rdi,	[r12+16]
    jmp       L9475
L9474:
    mov       rcx,	rdi
    call      mm_type.tx_passdef
    mov       rdi,	[rdi+32]
L9475:
    test      rdi,	rdi
    jnz       L9474
    mov       rsi,	[r12+64]
    movzx     rax,	byte [r12+78]
    cmp       rax,	6
    jz        L9478
    cmp       rax,	9
    jz        L9479
    cmp       rax,	10
    jz        L9480
    cmp       rax,	11
    jz        L9480
    cmp       rax,	12
    jz        L9480
    jmp       L9481
L9478:
    xor       eax,	eax
    mov       [mm_decls.currproc],	rax
    xor       eax,	eax
    mov       [mm_decls.currproc],	rax
    jmp       L9477
L9479:
    mov       rcx,	r12
    call      mm_type.tx_namedconst
    jmp       L9477
L9480:
    mov       rcx,	r12
    call      mm_type.tx_namedef
L9481:
L9477:
    lea       rax,	[r12+92]
    or        byte [rax],	4
    mov       [pc_decls.mmpos],	rbx
L9471:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_unitlist
mm_type.tx_unitlist:
;?>>
   %define R.p rdi
   %define R.t rbx
    %define mm_type.tx_unitlist.lv 48
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    jmp       L9484
L9483:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rdi,	[rdi+8]
L9484:
    test      rdi,	rdi
    jnz       L9483
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_namedef
mm_type.tx_namedef:
;?>>
   %define R.d r14
   %define R.m rdi
   %define R.mold rbx
   %define R.inidataold rsi
   %define R.dcode r12
   %define R.pequiv r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    movzx     rax,	word [r14+92]
    shr       eax,	3
    and       eax,	1
    test      rax,	rax
    jz        L9488
    lea       rcx,	[L13522]
    xor       edx,	edx
    call      mm_support.txerror
L9488:
    movzx     rax,	word [r14+92]
    shr       eax,	2
    and       eax,	1
    test      rax,	rax
    jnz       L9486
L9490:
    movsxd    rax,	dword [r14+72]
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mm_type.setmodesize
    mov       r12,	[r14+64]
    lea       rax,	[r14+92]
    or        byte [rax],	8
    movzx     rax,	word [r14+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L9492
    mov       r13,	[r14+96]
    movzx     rax,	byte [r13]
    cmp       rax,	55
    jnz       L9494
    mov       rax,	[r13+16]
    mov       rcx,	r13
    mov       rdx,	rax
    call      mm_lib.deleteunit
L9494:
    movzx     rax,	byte [r13]
    cmp       rax,	4
    jz        L9496
    lea       rcx,	[L13523]
    xor       edx,	edx
    call      mm_support.txerror
L9496:
    mov       rcx,	r13
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
L9492:
    test      r12,	r12
    jz        L9498
    movzx     rax,	byte [r14+78]
    cmp       rax,	11
    jz        L9498
    mov       rbx,	rdi
    mov       rcx,	rdi
    call      mm_lib.gettypebase
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	11
    jnz       L9500
    movzx     rax,	byte [r12]
    cmp       rax,	1
    jnz       L9500
    movsxd    rax,	dword [r12+49]
    cmp       rax,	20
    jnz       L9500
    mov       rcx,	r12
    mov       rdx,	20
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9499
L9500:
    mov       rsi,	[mm_type.inidata]
    mov       rax,	1
    mov       [mm_type.inidata],	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       [mm_type.inidata],	rsi
L9499:
    lea       rax,	[r14+92]
    and       byte [rax],	247
    lea       rax,	[r14+92]
    or        byte [rax],	4
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jnz       L9502
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jnz       L9502
    mov       eax,	[r12+49]
    mov       [r14+72],	eax
L9502:
    cmp       rbx,	rdi
    jz        L9504
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9506
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9506
    mov       rax,	[r14+64]
    mov       rcx,	rax
    mov       rdx,	59
    call      mm_lib.insertunit
    mov       rax,	[r14+64]
    mov       r10d,	ebx
    mov       [rax+49],	r10d
    jmp       L9505
L9506:
    cmp       rbx,	2
    jnz       L9507
    mov       rax,	[r14+64]
    mov       r10d,	ebx
    mov       [rax+49],	r10d
L9507:
L9505:
L9504:
    movzx     rax,	byte [r14+78]
    cmp       rax,	10
    jnz       L9509
    mov       rcx,	[r14+64]
    call      mm_type.checkconstexpr
L9509:
    jmp       L9497
L9498:
    test      r12,	r12
    jz        L9510
    movzx     rax,	byte [r14+78]
    cmp       rax,	11
    jnz       L9510
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jnz       L9510
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jnz       L9510
    mov       rcx,	r12
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	[r12+49]
    mov       [r14+72],	eax
    lea       rax,	[r14+92]
    and       byte [rax],	247
    lea       rax,	[r14+92]
    or        byte [rax],	4
    jmp       L9497
L9510:
    lea       rax,	[r14+92]
    and       byte [rax],	247
    lea       rax,	[r14+92]
    or        byte [rax],	4
L9497:
L9486:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_namedconst
mm_type.tx_namedconst:
;?>>
   %define R.d rsi
   %define R.m rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	word [rsi+92]
    shr       eax,	3
    and       eax,	1
    test      rax,	rax
    jz        L9513
    lea       rcx,	[L13524]
    xor       edx,	edx
    call      mm_support.txerror
L9513:
    movzx     rax,	word [rsi+92]
    shr       eax,	2
    and       eax,	1
    test      rax,	rax
    jnz       L9511
L9515:
    mov       rbx,	[rsi+64]
    movsxd    rax,	dword [rsi+72]
    mov       rdi,	rax
    lea       rax,	[rsi+92]
    or        byte [rax],	8
    cmp       rdi,	22
    jnz       L9517
    mov       rax,	23
    jmp       L9516
L9517:
    mov       rax,	rdi
L9516:
    mov       rcx,	rbx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    lea       rax,	[rsi+92]
    and       byte [rax],	247
    mov       rcx,	rbx
    call      mm_type.checkconstexpr
    cmp       rdi,	22
    jnz       L9519
    mov       eax,	[rbx+49]
    mov       [rsi+72],	eax
L9519:
    movsxd    rax,	dword [rsi+72]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L9521
    jmp       L9522
L9521:
    movsxd    rax,	dword [rsi+72]
    cmp       rax,	20
    jz        L9524
    lea       rcx,	[L13525]
    xor       edx,	edx
    call      mm_support.txerror
L9524:
L9522:
L9520:
    lea       rax,	[rsi+92]
    or        byte [rax],	4
L9511:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.checkconstexpr
mm_type.checkconstexpr:
;?>>
   %define R.p rbx
   %define R.q rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jz        L9527
    cmp       rax,	62
    jz        L9527
    cmp       rax,	20
    jz        L9528
    cmp       rax,	58
    jz        L9529
    cmp       rax,	59
    jz        L9530
    cmp       rax,	55
    jz        L9531
    cmp       rax,	56
    jz        L9531
    cmp       rax,	4
    jz        L9532
    jmp       L9533
L9527:
    jmp       L9525
L9528:
    mov       rdi,	[rbx+16]
    jmp       L9535
L9534:
    mov       rcx,	rdi
    call      mm_type.checkconstexpr
    mov       rdi,	[rdi+8]
L9535:
    test      rdi,	rdi
    jnz       L9534
    jmp       L9526
L9529:
    mov       rax,	[rbx+16]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jnz       L9538
    mov       eax,	[rbx+49]
    mov       r10,	[rbx+16]
    mov       [r10+49],	eax
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_lib.deleteunit
    jmp       L9537
L9538:
    jmp       L9539
L9537:
    jmp       L9526
L9530:
    mov       rcx,	[rbx+16]
    call      mm_type.checkconstexpr
    jmp       L9526
L9531:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L9542
L9541:
    jmp       L9540
L9542:
    jmp       L9539
L9540:
    jmp       L9526
L9532:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jz        L9525
L9544:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	6
    jz        L9525
L9546:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	14
    jz        L9525
L9548:
    jmp       L9539
L9533:
;mm_type.checkconstexpr.error:
L9539:
    call      msys.m$print_startcon
    lea       rcx,	[L13526]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    xor       edx,	edx
    lea       r8,	[L13527]
    xor       r9d,	r9d
    call      mm_diags.printunit
    lea       rcx,	[L13528]
    xor       edx,	edx
    call      mm_support.txerror
L9526:
L9525:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.getconstint
mm_type.getconstint:
;?>>
   %define R.q rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_type.checkconstexpr
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L9552
    movzx     rax,	byte [rdi]
    cmp       rax,	62
    jnz       L9551
L9552:
    mov       rax,	[rdi+16]
    jmp       L9549
L9551:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L9553
    movq      XMM4,	[rdi+16]
    cvttsd2si rax,	XMM4
    jmp       L9549
L9553:
    call      msys.m$print_startcon
    movsxd    rax,	dword [rdi+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13529]
    xor       edx,	edx
    call      mm_support.txerror
L9550:
    xor       eax,	eax
L9549:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_type.makenewconst
mm_type.makenewconst:
;?>>
   %define R.p rcx
   %define R.x rdx
   %define R.t r8
;?]]
;---------------
    mov       al,	1
    mov       [rcx],	al
    xor       eax,	eax
    mov       [rcx+24],	rax
    mov       [rcx+16],	rax
    mov       [rcx+16],	rdx
    mov       al,	1
    mov       [rcx+60],	al
    test      r8,	r8
    jz        L9556
    mov       [rcx+49],	r8d
L9556:
;---------------
    ret       
;End 
;Proc mm_type.tx_name
mm_type.tx_name:
;?>>
   %define R.p r12
    %define mm_type.tx_name.t 64
   %define R.lv r13
   %define R.d rdi
   %define R.oldmmpos rbx
   %define R.pcode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	r8
;---------------
    mov       rbx,	[pc_decls.mmpos]
    mov       al,	[r12+2]
    test      al,	al
    jnz       L9557
L9559:
    lea       rax,	[r12+2]
    inc       byte [rax]
    mov       rdi,	[r12+16]
    mov       eax,	[rdi+88]
    mov       [pc_decls.mmpos],	rax
    movzx     rax,	byte [rdi+78]
    cmp       rax,	9
    jz        L9561
    cmp       rax,	10
    jz        L9562
    cmp       rax,	11
    jz        L9562
    cmp       rax,	12
    jz        L9562
    cmp       rax,	6
    jz        L9563
    cmp       rax,	7
    jz        L9563
    cmp       rax,	14
    jz        L9564
    cmp       rax,	3
    jz        L9565
    cmp       rax,	13
    jz        L9566
    cmp       rax,	5
    jz        L9567
    cmp       rax,	8
    jz        L9568
    jmp       L9569
L9561:
    test      r13,	r13
    jz        L9571
    lea       rcx,	[L13530]
    xor       edx,	edx
    call      mm_support.txerror
L9571:
    mov       rcx,	rdi
    call      mm_type.tx_namedconst
    mov       rsi,	[rdi+64]
    mov       al,	1
    mov       [r12],	al
    xor       eax,	eax
    mov       [r12+16],	rax
    xor       eax,	eax
    mov       [r12+16],	rax
    xor       eax,	eax
    mov       [r12+32],	rax
    movzx     rax,	byte [rsi]
    cmp       rax,	58
    jnz       L9573
    mov       rax,	[rsi+16]
    mov       rax,	[rax+16]
    mov       [r12+16],	rax
    jmp       L9572
L9573:
    mov       rax,	[rsi+16]
    mov       [r12+16],	rax
L9572:
    mov       eax,	[rsi+40]
    mov       [r12+40],	eax
    mov       eax,	[rdi+72]
    mov       [r12+49],	eax
    mov       al,	1
    mov       [r12+60],	al
    mov       al,	[rsi+44]
    mov       [r12+44],	al
    jmp       L9560
L9562:
    movzx     rax,	word [rdi+92]
    shr       eax,	4
    and       eax,	1
    test      rax,	rax
    jz        L9575
    test      r13,	r13
    jz        L9575
    mov       rax,	[rdi]
    lea       rcx,	[L13531]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9575:
    mov       rcx,	rdi
    call      mm_type.tx_namedef
    mov       rax,	[mm_type.inassem]
    test      rax,	rax
    jnz       L9577
    mov       eax,	[rdi+72]
    mov       [r12+49],	eax
    movzx     rax,	byte [rdi+160]
    cmp       rax,	1
    jnz       L9579
    mov       al,	[r12+1]
    test      al,	al
    jnz       L9581
    lea       rax,	[r12+1]
    inc       byte [rax]
    mov       rcx,	r12
    mov       rdx,	53
    call      mm_lib.insertunit
    movsxd    rax,	dword [rdi+72]
    lea       r10,	[mm_decls.tttarget]
    mov       r10d,	[r10 + rax*4]
    mov       [r12+49],	r10d
L9581:
L9579:
    mov       rcx,	r12
    mov       rdx,	r13
    call      mm_type.twiden
    jmp       L9576
L9577:
    mov       eax,	20
    mov       [r12+49],	eax
L9576:
    jmp       L9560
L9563:
    mov       eax,	[mm_tables.trefproc]
    mov       [r12+49],	eax
    jmp       L9560
L9564:
    mov       eax,	[mm_tables.treflabel]
    mov       [r12+49],	eax
    jmp       L9560
L9565:
    mov       rax,	[rdi]
    lea       rcx,	[L13532]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
    jmp       L9560
L9566:
    mov       al,	1
    mov       [r12],	al
    xor       eax,	eax
    mov       [r12+16],	rax
    xor       eax,	eax
    mov       [r12+16],	rax
    xor       eax,	eax
    mov       [r12+32],	rax
    movsxd    rax,	dword [rdi+84]
    mov       [r12+16],	rax
    mov       eax,	3
    mov       [r12+49],	eax
    mov       al,	1
    mov       [r12+60],	al
    jmp       L9560
L9567:
    mov       al,	62
    mov       [r12],	al
    movsxd    rax,	dword [rdi+72]
    mov       [r12+16],	rax
    mov       eax,	3
    mov       [r12+49],	eax
    jmp       L9560
L9568:
    mov       rax,	[rdi+64]
    test      rax,	rax
    jz        L9583
    lea       rcx,	[L13533]
    xor       edx,	edx
    call      mm_support.txerror
L9583:
    mov       eax,	[rdi+72]
    mov       [r12+49],	eax
    jmp       L9560
L9569:
    mov       eax,	[r12+4]
    mov       [pc_decls.mmpos],	rax
    mov       rax,	[rdi]
    movzx     r10,	byte [rdi+78]
    lea       r11,	[mm_tables.namenames]
    mov       r11,	[r11 + r10*8]
    lea       rcx,	[L13534]
    mov       rdx,	r11
    mov       r8,	rax
    call      mm_support.txerror_ss
L9560:
    mov       [pc_decls.mmpos],	rbx
L9557:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_bin
mm_type.tx_bin:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.b r13
   %define R.amode rdi
   %define R.bmode rbx
    %define mm_type.tx_bin.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r13
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r13+49]
    mov       rbx,	rax
    movzx     rax,	byte [rsi+62]
    cmp       rax,	43
    jz        L9586
    cmp       rax,	44
    jz        L9587
    cmp       rax,	45
    jz        L9588
    cmp       rax,	46
    jz        L9589
    cmp       rax,	47
    jz        L9590
    cmp       rax,	48
    jz        L9590
    cmp       rax,	49
    jz        L9590
    cmp       rax,	50
    jz        L9590
    cmp       rax,	51
    jz        L9590
    cmp       rax,	52
    jz        L9590
    cmp       rax,	55
    jz        L9591
    cmp       rax,	56
    jz        L9591
    cmp       rax,	82
    jz        L9592
    cmp       rax,	83
    jz        L9593
    cmp       rax,	81
    jz        L9593
    cmp       rax,	53
    jz        L9594
    cmp       rax,	54
    jz        L9594
    jmp       L9595
L9586:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9584
L9597:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9599
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9601
    mov       al,	[r12+44]
    test      al,	al
    jz        L9601
    mov       al,	[r13+44]
    test      al,	al
    jz        L9601
    mov       rcx,	rsi
    call      mm_type.combinestrings
    jmp       L9584
L9601:
    cmp       rbx,	5
    jg        L9603
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       al,	57
    mov       [rsi+62],	al
    mov       [rsi+49],	edi
    jmp       L9584
L9603:
L9599:
    jmp       L9585
L9587:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9584
L9605:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9607
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9609
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L9611
    mov       al,	59
    mov       [rsi+62],	al
    mov       eax,	3
    mov       [rsi+49],	eax
    jmp       L9584
L9611:
    lea       rcx,	[L13535]
    xor       edx,	edx
    call      mm_support.txerror
L9610:
L9609:
    cmp       rbx,	5
    jg        L9613
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       al,	58
    mov       [rsi+62],	al
    mov       [rsi+49],	edi
    jmp       L9584
L9613:
L9607:
    jmp       L9585
L9588:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9584
L9615:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9617
    mov       al,	[r12+44]
    test      al,	al
    jz        L9619
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L9619
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jnz       L9619
    mov       rcx,	rsi
    call      mm_type.mulstrings
    jmp       L9584
L9619:
L9617:
    jmp       L9585
L9589:
    mov       rax,	rdi
    cmp       rax,	3
    jz        L9622
    cmp       rax,	4
    jz        L9622
    cmp       rax,	5
    jnz       L9621
L9622:
    mov       rax,	rbx
    cmp       rax,	3
    jz        L9623
    cmp       rax,	4
    jz        L9623
    cmp       rax,	5
    jnz       L9621
L9623:
    mov       al,	47
    mov       [rsi+62],	al
    jmp       L9624
L9621:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumf
    test      rax,	rax
    jnz       L9584
L9626:
    cmp       rdi,	5
    jg        L9628
    cmp       rbx,	5
    jg        L9628
    mov       eax,	1
    mov       [rsi+49],	eax
    mov       rcx,	r12
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    jmp       L9584
L9628:
    jmp       L9585
L9590:
;mm_type.tx_bin.doidiv:
L9624:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumi
    test      rax,	rax
    jnz       L9584
L9630:
    jmp       L9585
L9591:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9584
L9632:
    jmp       L9585
L9592:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9584
L9634:
    jmp       L9585
L9593:
    mov       rcx,	r12
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       eax,	1
    mov       [rsi+49],	eax
    jmp       L9584
L9594:
    mov       rax,	rdi
    cmp       rax,	3
    jz        L9637
    cmp       rax,	4
    jz        L9637
    cmp       rax,	5
    jnz       L9636
L9637:
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       [rsi+49],	edi
    jmp       L9584
L9636:
    jmp       L9585
L9595:
    mov       al,	[rsi+64]
    test      al,	al
    jz        L9639
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jz        L9641
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L9584
L9641:
    mov       eax,	6
    mov       [rsi+49],	eax
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9643
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9643
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9645
    lea       rcx,	[L13536]
    xor       edx,	edx
    call      mm_support.txerror
L9645:
    jmp       L9584
L9643:
    movzx     rax,	byte [rsi+64]
    cmp       rax,	1
    jz        L9648
    cmp       rax,	2
    jnz       L9647
L9648:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9584
L9650:
L9647:
    jmp       L9638
L9639:
    lea       rcx,	[L13537]
    xor       edx,	edx
    call      mm_support.txerror
L9638:
L9585:
    call      msys.m$print_startcon
    movzx     rax,	byte [rsi+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.tx_bin.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13538]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_bin.$T1]
    call      mm_support.txerror_ss
L9584:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_binto
mm_type.tx_binto:
;?>>
   %define R.p r13
   %define R.a r14
   %define R.b r15
   %define R.abase rdi
   %define R.bbase rbx
   %define R.amode rsi
   %define R.bmode r12
    %define mm_type.tx_binto.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rcx,	r14
    mov       rdx,	23
    call      mm_type.tpasslv
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    mov       rsi,	rax
    movsxd    rax,	dword [r15+49]
    mov       r12,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    movzx     rax,	byte [r13+62]
    cmp       rax,	93
    jnz       L9653
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9653
    mov       al,	94
    mov       [r13+62],	al
L9653:
    xor       eax,	eax
    mov       [r13+49],	eax
    movzx     rax,	byte [r13+62]
    cmp       rax,	90
    jz        L9655
    cmp       rax,	91
    jz        L9656
    cmp       rax,	99
    jz        L9657
    cmp       rax,	100
    jz        L9657
    cmp       rax,	96
    jz        L9657
    cmp       rax,	97
    jz        L9657
    cmp       rax,	98
    jz        L9657
    jmp       L9658
L9655:
    cmp       rdi,	7
    jnz       L9660
    cmp       rbx,	7
    jnz       L9660
    lea       rcx,	[L13539]
    xor       edx,	edx
    call      mm_support.txerror
L9660:
    cmp       rdi,	7
    jnz       L9662
    cmp       rbx,	5
    jg        L9662
    mov       rcx,	r15
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       al,	103
    mov       [r13+62],	al
    jmp       L9651
L9662:
    jmp       L9654
L9656:
    cmp       rdi,	7
    jnz       L9664
    cmp       rbx,	5
    jg        L9664
    mov       rcx,	r15
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       al,	104
    mov       [r13+62],	al
    jmp       L9651
L9664:
    jmp       L9654
L9657:
    mov       rcx,	r15
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    jmp       L9651
L9658:
L9654:
    cmp       rdi,	5
    jg        L9666
    cmp       rbx,	5
    jg        L9666
    mov       rcx,	r15
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    jmp       L9665
L9666:
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9667
    cmp       rbx,	5
    jg        L9667
    mov       rcx,	r15
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    jmp       L9665
L9667:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9669
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_lib.strmode
    mov       [rbp + mm_type.tx_binto.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13540]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_binto.$T1]
    call      mm_support.txerror_ss
L9669:
L9665:
L9651:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.getdominantmode
mm_type.getdominantmode:
;?>>
   %define R.amode rsi
   %define R.bmode r12
   %define R.abase rdi
   %define R.bbase rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    cmp       rdi,	5
    jg        L9672
    cmp       rbx,	5
    jg        L9672
    mov       rax,	rdi
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    jmp       L9670
L9672:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9674
    lea       rcx,	[L13541]
    xor       edx,	edx
    call      mm_support.txerror
L9674:
    mov       rax,	rsi
L9670:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_cmpchain
mm_type.tx_cmpchain:
;?>>
   %define R.p r15
    %define mm_type.tx_cmpchain.a 80
   %define R.u rdi
   %define R.genop rbx
   %define R.q rsi
   %define R.r r12
   %define R.av_1 r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rsi,	[rbp + mm_type.tx_cmpchain.a]
    jmp       L9677
L9676:
    mov       rcx,	rsi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    cmp       rsi,	[rbp + mm_type.tx_cmpchain.a]
    jnz       L9680
    movsxd    rax,	dword [rsi+49]
    mov       rdi,	rax
    jmp       L9679
L9680:
    movsxd    rax,	dword [rsi+49]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rdi,	rax
L9679:
    mov       rsi,	[rsi+8]
L9677:
    test      rsi,	rsi
    jnz       L9676
    mov       rsi,	[rbp + mm_type.tx_cmpchain.a]
    mov       rax,	[rbp + mm_type.tx_cmpchain.a]
    mov       r12,	[rax+8]
    jmp       L9682
L9681:
    mov       rcx,	rsi
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rsi,	[rsi+8]
L9682:
    test      rsi,	rsi
    jnz       L9681
    mov       r14,	1
    mov       r13,	4
    cmp       r13,	1
    jl        L9686
L9684:
    lea       rax,	[r15+40]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L9688
    jmp       L9686
L9688:
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    lea       r10,	[r15+32]
    mov       r11,	r14
    mov       [r10 + r11*2-2],	ax
    inc       r14
    cmp       r14,	r13
    jle       L9684
L9686:
    mov       eax,	3
    mov       [r15+49],	eax
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_callproc
mm_type.tx_callproc:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_type.tx_callproc.pargs 80
    %define mm_type.tx_callproc.t 88
   %define R.q rdi
   %define R.d rbx
   %define R.e rsi
   %define R.pm r12
    %define mm_type.tx_callproc.paramlist -800
    %define mm_type.tx_callproc.arglist -1600
    %define mm_type.tx_callproc.newarglist -2400
    %define mm_type.tx_callproc.nparams -2408
    %define mm_type.tx_callproc.i -2416
    %define mm_type.tx_callproc.j -2424
    %define mm_type.tx_callproc.k -2432
    %define mm_type.tx_callproc.nargs -2440
    %define mm_type.tx_callproc.m -2448
    %define mm_type.tx_callproc.kwdused -2456
    %define mm_type.tx_callproc.qm -2464
    %define mm_type.tx_callproc.ismproc -2472
    %define mm_type.tx_callproc.name -2480
    %define mm_type.tx_callproc.ulist -2488
    %define mm_type.tx_callproc.ulistx -2496
    %define mm_type.tx_callproc.$T1 -2504
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2544
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.nparams],	rax
    mov       [rbp + mm_type.tx_callproc.nargs],	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.ismproc],	rax
;mm_type.tx_callproc.retry:
L9690:
    movzx     rax,	byte [r14]
    cmp       rax,	4
    jz        L9692
    cmp       rax,	92
    jz        L9693
    cmp       rax,	112
    jz        L9693
    cmp       rax,	6
    jz        L9693
    jmp       L9694
L9692:
    mov       rbx,	[r14+16]
    movzx     rax,	byte [rbx+78]
    cmp       rax,	6
    jz        L9697
    cmp       rax,	7
    jnz       L9696
L9697:
    movzx     rax,	byte [rbx+78]
    cmp       rax,	6
    setz      al
    movzx     eax,	al
    mov       [rbp + mm_type.tx_callproc.ismproc],	rax
;mm_type.tx_callproc.getparams:
L9698:
    mov       rsi,	[rbx+16]
    jmp       L9700
L9699:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	12
    jnz       L9703
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	100
    jl        L9705
    lea       rcx,	[L13542]
    xor       edx,	edx
    call      mm_support.txerror
L9705:
    inc       qword [rbp + mm_type.tx_callproc.nparams]
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    mov       r10,	rsi
    mov       [rbp + rax*8 + mm_type.tx_callproc.paramlist-8],	r10
L9703:
    mov       rsi,	[rsi+32]
L9700:
    test      rsi,	rsi
    jnz       L9699
    jmp       L9695
L9696:
    jmp       L9707
L9706:
    mov       rcx,	r14
    mov       rdx,	53
    call      mm_lib.insertunit
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.tttarget]
    mov       r10d,	[r10 + rax*4]
    mov       [r14+49],	r10d
L9707:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L9706
    jmp       L9709
L9695:
    jmp       L9691
L9693:
    lea       rcx,	[L13543]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L9691
L9694:
;mm_type.tx_callproc.dorefproc:
L9709:
    movzx     rax,	byte [r14]
    cmp       rax,	49
    jnz       L9711
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	[rbp + mm_type.tx_callproc.pargs]
    call      mm_type.tmethodcall
    mov       r14,	[r13+16]
    mov       rax,	[r13+24]
    mov       [rbp + mm_type.tx_callproc.pargs],	rax
    jmp       L9690
L9711:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	24
    jz        L9713
    lea       rcx,	[L13544]
    xor       edx,	edx
    call      mm_support.txerror
L9713:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttnamedef]
    mov       r10,	[r10 + rax*8]
    mov       rbx,	r10
    test      rbx,	rbx
    jnz       L9715
    lea       rcx,	[L13545]
    xor       edx,	edx
    call      mm_support.txerror
L9715:
    jmp       L9698
L9691:
    mov       rdi,	[rbp + mm_type.tx_callproc.pargs]
    jmp       L9717
L9716:
    mov       rax,	[rbp + mm_type.tx_callproc.nargs]
    cmp       rax,	100
    jl        L9720
    lea       rcx,	[L13546]
    xor       edx,	edx
    call      mm_support.txerror
L9720:
    inc       qword [rbp + mm_type.tx_callproc.nargs]
    mov       rax,	[rbp + mm_type.tx_callproc.nargs]
    mov       r10,	rdi
    mov       [rbp + rax*8 + mm_type.tx_callproc.arglist-8],	r10
    mov       rdi,	[rdi+8]
L9717:
    test      rdi,	rdi
    jnz       L9716
    mov       eax,	[rbx+72]
    mov       [r13+49],	eax
    mov       eax,	[r13+49]
    test      eax,	eax
    jz        L9722
    mov       rax,	[rbp + mm_type.tx_callproc.t]
    test      rax,	rax
    jz        L9722
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_type.twiden
L9722:
    mov       al,	[rbx+123]
    test      al,	al
    jz        L9724
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nargs]
    cmp       rax,	1
    jl        L9727
L9725:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jg        L9729
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rax,	[rbp + rax*8 + mm_type.tx_callproc.paramlist-8]
    movsxd    rax,	dword [rax+72]
    mov       r10,	[rbp + mm_type.tx_callproc.i]
    mov       r10,	[rbp + r10*8 + mm_type.tx_callproc.arglist-8]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9728
L9729:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rax,	[rbp + rax*8 + mm_type.tx_callproc.arglist-8]
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
L9728:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nargs]
    jle       L9725
L9727:
    jmp       L9689
L9724:
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.k],	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.kwdused],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	1
    jl        L9732
L9730:
    xor       eax,	eax
    mov       r10,	[rbp + mm_type.tx_callproc.i]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jle       L9730
L9732:
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nargs]
    cmp       rax,	1
    jl        L9735
L9733:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rdi,	[rbp + rax*8 + mm_type.tx_callproc.arglist-8]
    movzx     rax,	byte [rdi]
    cmp       rax,	26
    jnz       L9738
L9737:
    mov       rax,	[rdi+16]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    mov       [rbp + mm_type.tx_callproc.name],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.j],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	1
    jl        L9742
L9739:
    mov       rax,	[rbp + mm_type.tx_callproc.j]
    mov       rax,	[rbp + rax*8 + mm_type.tx_callproc.paramlist-8]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tx_callproc.name]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L9741
L9744:
    mov       rax,	[rbp + mm_type.tx_callproc.j]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.j],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jle       L9739
L9742:
    lea       rcx,	[L13547]
    mov       rdx,	[rbp + mm_type.tx_callproc.name]
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9741:
    mov       rax,	[rbp + mm_type.tx_callproc.j]
    mov       rax,	[rbp + rax*8 + mm_type.tx_callproc.newarglist-8]
    test      rax,	rax
    jz        L9746
    lea       rcx,	[L13548]
    mov       rdx,	[rbp + mm_type.tx_callproc.name]
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9746:
    mov       rax,	[rdi+24]
    mov       r10,	[rbp + mm_type.tx_callproc.j]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.kwdused],	rax
    jmp       L9736
L9738:
    mov       rax,	[rbp + mm_type.tx_callproc.kwdused]
    test      rax,	rax
    jz        L9748
    lea       rcx,	[L13549]
    xor       edx,	edx
    call      mm_support.txerror
L9748:
    mov       rax,	[rbp + mm_type.tx_callproc.k]
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jl        L9750
    call      msys.m$print_startcon
    lea       rcx,	[L13550]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_type.tx_callproc.k]
    call      msys.m$print_i64_nf
    lea       rcx,	[L13551]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_type.tx_callproc.nparams]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13552]
    xor       edx,	edx
    call      mm_support.txerror
L9750:
    movzx     rax,	byte [rdi]
    cmp       rax,	2
    jnz       L9752
    xor       eax,	eax
    jmp       L9751
L9752:
    mov       rax,	rdi
L9751:
    inc       qword [rbp + mm_type.tx_callproc.k]
    mov       r10,	[rbp + mm_type.tx_callproc.k]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
L9736:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nargs]
    jle       L9733
L9735:
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	1
    jl        L9755
L9753:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rdi,	[rbp + rax*8 + mm_type.tx_callproc.newarglist-8]
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       r12,	[rbp + rax*8 + mm_type.tx_callproc.paramlist-8]
    test      rdi,	rdi
    jnz       L9757
    mov       al,	[r12+161]
    test      al,	al
    jnz       L9759
    mov       rcx,	[rbp + mm_type.tx_callproc.i]
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[L13553]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9759:
    mov       rax,	[r12+64]
    test      rax,	rax
    jz        L9761
    mov       eax,	[r13+4]
    mov       r10,	[r12+64]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.duplunit
    mov       r10,	[rbp + mm_type.tx_callproc.i]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
    jmp       L9760
L9761:
    xor       ecx,	ecx
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       r10,	[rbp + mm_type.tx_callproc.i]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
L9760:
L9757:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jle       L9753
L9755:
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.ulist],	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.ulistx],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	1
    jl        L9764
L9762:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       r12,	[rbp + rax*8 + mm_type.tx_callproc.paramlist-8]
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rdi,	[rbp + rax*8 + mm_type.tx_callproc.newarglist-8]
    movzx     rax,	byte [r12+160]
    cmp       rax,	1
    jnz       L9766
    movsxd    rax,	dword [r12+72]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       [rbp + mm_type.tx_callproc.m],	r10
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	1
    call      mm_type.tpass
    movsxd    rax,	dword [rdi+49]
    mov       [rbp + mm_type.tx_callproc.qm],	rax
    mov       rcx,	[rbp + mm_type.tx_callproc.qm]
    mov       rdx,	[rbp + mm_type.tx_callproc.m]
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9768
    mov       rcx,	[rbp + mm_type.tx_callproc.m]
    mov       rdx,	1
    call      mm_lib.strmode
    mov       [rbp + mm_type.tx_callproc.$T1],	rax
    mov       rcx,	[rbp + mm_type.tx_callproc.qm]
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13554]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_callproc.$T1]
    call      mm_support.txerror_ss
L9768:
    mov       rcx,	rdi
    mov       rdx,	55
    call      mm_lib.insertunit
    mov       eax,	[r12+72]
    mov       [rdi+49],	eax
    jmp       L9765
L9766:
    movsxd    rax,	dword [r12+72]
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
L9765:
    lea       rcx,	[rbp + mm_type.tx_callproc.ulist]
    lea       rdx,	[rbp + mm_type.tx_callproc.ulistx]
    mov       r8,	rdi
    call      mm_lib.addlistunit
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jle       L9762
L9764:
    mov       rax,	[rbp + mm_type.tx_callproc.ulist]
    mov       [r13+24],	rax
L9689:
;---------------
    add       rsp,	2544
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_unary
mm_type.tx_unary:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.amode rdi
   %define R.resmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    mov       rbx,	rdi
    movzx     rax,	byte [rsi+62]
    cmp       rax,	73
    jz        L9771
    cmp       rax,	74
    jz        L9771
    cmp       rax,	75
    jz        L9771
    cmp       rax,	76
    jz        L9771
    cmp       rax,	67
    jz        L9771
    cmp       rax,	68
    jz        L9771
    cmp       rax,	69
    jz        L9771
    cmp       rax,	70
    jz        L9771
    cmp       rax,	71
    jz        L9771
    cmp       rax,	72
    jz        L9771
    cmp       rax,	78
    jz        L9771
    cmp       rax,	79
    jz        L9771
    cmp       rax,	60
    jz        L9772
    cmp       rax,	61
    jz        L9772
    cmp       rax,	66
    jz        L9772
    cmp       rax,	62
    jz        L9773
    cmp       rax,	63
    jz        L9773
    cmp       rax,	64
    jz        L9773
    cmp       rax,	80
    jz        L9774
    jmp       L9775
L9771:
    mov       rcx,	r12
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rbx,	1
    jmp       L9770
L9772:
    cmp       rdi,	5
    jle       L9777
    lea       rcx,	[L13555]
    xor       edx,	edx
    call      mm_support.txerror
L9777:
    jmp       L9770
L9773:
    cmp       rdi,	2
    jg        L9779
    lea       rcx,	[L13556]
    xor       edx,	edx
    call      mm_support.txerror
L9779:
    jmp       L9770
L9774:
    mov       rbx,	3
    jmp       L9770
L9775:
    call      msys.m$print_startcon
    lea       rcx,	[L13557]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rsi+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9770:
    mov       [rsi+49],	ebx
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_prop
mm_type.tx_prop:
;?>>
   %define R.p r14
   %define R.a r15
   %define R.size rdi
   %define R.amode rbx
   %define R.mbase rsi
   %define R.x r12
   %define R.resmode r13
    %define mm_type.tx_prop.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
;---------------
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r15+49]
    mov       rbx,	rax
    mov       r13,	rbx
    movzx     rax,	byte [r14+62]
    cmp       rax,	3
    jz        L9782
    cmp       rax,	4
    jz        L9782
    cmp       rax,	2
    jz        L9782
    cmp       rax,	5
    jz        L9782
    cmp       rax,	1
    jz        L9782
    cmp       rax,	7
    jz        L9783
    cmp       rax,	6
    jz        L9783
    cmp       rax,	9
    jz        L9784
    cmp       rax,	10
    jz        L9784
    cmp       rax,	8
    jz        L9785
    jmp       L9786
L9782:
    mov       rcx,	r14
    mov       rdx,	r15
    call      mm_type.do_bounds
    jmp       L9780
L9783:
    movzx     rax,	byte [r15]
    cmp       rax,	62
    jnz       L9788
    mov       rax,	[r15+16]
    jmp       L9787
L9788:
    movsxd    rax,	dword [r15+49]
L9787:
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       [rbp + mm_type.tx_prop.$T1],	r10
    movzx     rax,	byte [r14+62]
    cmp       rax,	7
    jnz       L9790
    mov       rax,	1
    jmp       L9789
L9790:
    mov       rax,	8
L9789:
    mov       r10,	[rbp + mm_type.tx_prop.$T1]
    imul      r10,	rax
    mov       rdi,	r10
    mov       rcx,	r14
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.makenewconst
    mov       r13,	3
    jmp       L9781
L9784:
    mov       r13,	3
    movzx     rax,	byte [r15]
    cmp       rax,	62
    jnz       L9792
    mov       rax,	[r15+16]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rsi,	r10
    jmp       L9791
L9792:
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rsi,	r10
L9791:
    movzx     rax,	byte [r14+62]
    cmp       rax,	9
    jnz       L9794
    mov       rax,	rsi
    cmp       rax,	14
    jz        L9796
    cmp       rax,	15
    jz        L9797
    cmp       rax,	16
    jz        L9798
    cmp       rax,	3
    jz        L9799
    cmp       rax,	17
    jz        L9800
    cmp       rax,	18
    jz        L9800
    cmp       rax,	19
    jz        L9800
    cmp       rax,	4
    jz        L9800
    cmp       rax,	12
    jz        L9800
    cmp       rax,	5
    jz        L9800
    jmp       L9801
L9796:
    mov       r12,	-128
    jmp       L9795
L9797:
    mov       r12,	-32768
    jmp       L9795
L9798:
    mov       r12,	-2147483648
    jmp       L9795
L9799:
    mov       r12,	-9223372036854775808
    jmp       L9795
L9800:
    xor       r12,	r12
    jmp       L9795
L9801:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13558]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9795:
    jmp       L9793
L9794:
    mov       rax,	rsi
    cmp       rax,	14
    jz        L9803
    cmp       rax,	15
    jz        L9804
    cmp       rax,	16
    jz        L9805
    cmp       rax,	3
    jz        L9806
    cmp       rax,	17
    jz        L9807
    cmp       rax,	12
    jz        L9807
    cmp       rax,	18
    jz        L9808
    cmp       rax,	19
    jz        L9809
    cmp       rax,	4
    jz        L9810
    jmp       L9811
L9803:
    mov       r12,	127
    jmp       L9802
L9804:
    mov       r12,	32767
    jmp       L9802
L9805:
    mov       r12,	2147483647
    jmp       L9802
L9806:
    mov       r12,	9223372036854775807
    jmp       L9802
L9807:
    mov       r12,	255
    jmp       L9802
L9808:
    mov       r12,	65535
    jmp       L9802
L9809:
    mov       r12,	4294967295
    jmp       L9802
L9810:
    xor       r12,	r12
    dec       r12
    mov       r13,	4
    jmp       L9802
L9811:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13559]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9802:
L9793:
    mov       al,	1
    mov       [r14],	al
    xor       eax,	eax
    mov       [r14+16],	rax
    mov       [r14+16],	r12
    mov       al,	1
    mov       [r14+60],	al
    jmp       L9781
L9785:
    mov       al,	1
    mov       [r14],	al
    movzx     rax,	byte [r15]
    cmp       rax,	62
    jnz       L9813
    mov       rbx,	[r15+16]
    jmp       L9812
L9813:
    movsxd    rax,	dword [r15+49]
    mov       rbx,	rax
L9812:
    mov       eax,	20
    mov       [r14+49],	eax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [r14+16],	rax
    mov       al,	1
    mov       [r14+44],	al
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      strlen
    mov       [r14+40],	eax
    jmp       L9780
L9786:
    call      msys.m$print_startcon
    lea       rcx,	[L13560]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r14+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9781:
    mov       [r14+49],	r13d
L9780:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_unaryto
mm_type.tx_unaryto:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    call      mm_type.tpasslv
    movzx     rax,	byte [rdi+62]
    cmp       rax,	107
    jz        L9816
    cmp       rax,	108
    jz        L9816
    cmp       rax,	109
    jnz       L9817
L9816:
    movsxd    rax,	dword [rbx+49]
    cmp       rax,	2
    jg        L9819
    lea       rcx,	[L13561]
    xor       edx,	edx
    call      mm_support.txerror
L9819:
L9817:
L9815:
    xor       eax,	eax
    mov       [rdi+49],	eax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_if
mm_type.tx_if:
;?>>
   %define R.p r12
   %define R.pcond r13
   %define R.plist r14
    %define mm_type.tx_if.pelse 88
    %define mm_type.tx_if.t 96
    %define mm_type.tx_if.lv 104
   %define R.pc rdi
   %define R.pl rbx
   %define R.u rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    mov       rdi,	r13
    mov       rbx,	r14
    xor       rsi,	rsi
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jz        L9822
    mov       rsi,	[rbp + mm_type.tx_if.t]
L9822:
    jmp       L9826
L9823:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.tx_if.t]
    mov       r8,	[rbp + mm_type.tx_if.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jnz       L9828
    test      rsi,	rsi
    jnz       L9830
    movsxd    rax,	dword [rbx+49]
    mov       rsi,	rax
    jmp       L9829
L9830:
    mov       rax,	[rbp + mm_type.tx_if.lv]
    test      rax,	rax
    jz        L9831
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9833
    lea       rcx,	[L13562]
    xor       edx,	edx
    call      mm_support.txerror
L9833:
    jmp       L9829
L9831:
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rsi,	rax
L9829:
L9828:
    mov       rdi,	[rdi+8]
    mov       rbx,	[rbx+8]
L9826:
    test      rdi,	rdi
    jnz       L9823
    mov       rax,	[rbp + mm_type.tx_if.t]
    test      rax,	rax
    jz        L9835
    mov       rax,	[rbp + mm_type.tx_if.pelse]
    test      rax,	rax
    jnz       L9835
    lea       rcx,	[L13563]
    xor       edx,	edx
    call      mm_support.txerror
L9835:
    mov       rcx,	[rbp + mm_type.tx_if.pelse]
    mov       rdx,	[rbp + mm_type.tx_if.t]
    mov       r8,	[rbp + mm_type.tx_if.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jnz       L9837
    mov       rax,	[rbp + mm_type.tx_if.lv]
    test      rax,	rax
    jz        L9839
    mov       rax,	[rbp + mm_type.tx_if.pelse]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9841
    lea       rcx,	[L13564]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L9840
L9841:
    mov       rax,	[rbp + mm_type.tx_if.pelse]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rsi,	rax
L9840:
L9839:
L9837:
    mov       rax,	[rbp + mm_type.tx_if.t]
    test      rax,	rax
    jz        L9843
    mov       rbx,	r14
    jmp       L9847
L9844:
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jnz       L9849
    mov       rcx,	rbx
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
L9849:
    mov       rbx,	[rbx+8]
L9847:
    test      rbx,	rbx
    jnz       L9844
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jnz       L9851
    mov       rcx,	[rbp + mm_type.tx_if.pelse]
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
L9851:
    mov       [r12+49],	esi
L9843:
    mov       rax,	[r13+8]
    mov       r10,	[r14+8]
    cmp       r10,	rax
    jnz       L9853
    test      r10,	r10
    jnz       L9853
    mov       rcx,	r13
    call      mm_type.iscondtrue
    test      rax,	rax
    jz        L9855
    mov       rcx,	r12
    mov       rdx,	r14
    call      mm_lib.deleteunit
    jmp       L9854
L9855:
    mov       rcx,	r13
    call      mm_type.iscondfalse
    test      rax,	rax
    jz        L9856
    mov       rax,	[rbp + mm_type.tx_if.pelse]
    test      rax,	rax
    jnz       L9858
    mov       rcx,	6
    call      mm_lib.createunit0
    mov       [rbp + mm_type.tx_if.pelse],	rax
L9858:
    mov       rcx,	r12
    mov       rdx,	[rbp + mm_type.tx_if.pelse]
    call      mm_lib.deleteunit
L9856:
L9854:
L9853:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_incrto
mm_type.tx_incrto:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.t rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    call      mm_type.tpasslv
    test      rsi,	rsi
    jz        L9861
    movzx     rax,	byte [rdi+62]
    cmp       rax,	84
    jz        L9863
    cmp       rax,	85
    jz        L9864
    jmp       L9865
L9863:
    mov       al,	86
    mov       [rdi+62],	al
    jmp       L9862
L9864:
    mov       al,	87
    mov       [rdi+62],	al
L9865:
L9862:
    mov       eax,	[rbx+49]
    mov       [rdi+49],	eax
    jmp       L9860
L9861:
    movzx     rax,	byte [rdi+62]
    cmp       rax,	88
    jz        L9867
    cmp       rax,	89
    jz        L9868
    jmp       L9869
L9867:
    mov       al,	84
    mov       [rdi+62],	al
    jmp       L9866
L9868:
    mov       al,	85
    mov       [rdi+62],	al
L9869:
L9866:
    xor       eax,	eax
    mov       [rdi+49],	eax
L9860:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_type.twiden
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_for
mm_type.tx_for:
;?>>
   %define R.pindex r12
   %define R.pfrom r13
   %define R.pbody r14
   %define R.pto rdi
   %define R.pstep rbx
   %define R.u rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    mov       rdi,	[r13+8]
    mov       rbx,	[rdi+8]
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [r12]
    cmp       rax,	4
    jz        L9872
    lea       rcx,	[L13565]
    xor       edx,	edx
    call      mm_support.txerror
L9872:
    movsxd    rax,	dword [r12+49]
    mov       rsi,	rax
    mov       rax,	[r12+8]
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rdi
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r14
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[r14+8]
    mov       rcx,	rax
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_forall
mm_type.tx_forall:
;?>>
   %define R.pindex r15
    %define mm_type.tx_forall.plist 80
    %define mm_type.tx_forall.pbody 88
   %define R.plocal rdi
   %define R.pfrom rbx
   %define R.pto rsi
   %define R.passign r12
   %define R.mlist r13
   %define R.elemtype r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rdi,	[r15+8]
    mov       rbx,	[rdi+8]
    mov       rsi,	[rbx+8]
    mov       rax,	[rbp + mm_type.tx_forall.plist]
    mov       r12,	[rax+8]
    mov       rcx,	r15
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	[rbp + mm_type.tx_forall.plist]
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_forall.plist]
    movsxd    rax,	dword [rax+49]
    mov       r13,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L9875
    cmp       rax,	11
    jz        L9876
    jmp       L9877
L9875:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    mov       r14,	rax
    jmp       L9874
L9876:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    mov       r14,	rax
    jmp       L9874
L9877:
    lea       rcx,	[L13566]
    xor       edx,	edx
    call      mm_support.txerror
L9874:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rdi+49]
    cmp       rax,	23
    jnz       L9879
    mov       [rdi+49],	r14d
    mov       rax,	[rdi+16]
    mov       r10d,	r14d
    mov       [rax+72],	r10d
L9879:
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	[rbp + mm_type.tx_forall.pbody]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_forall.pbody]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_index
mm_type.tx_index:
;?>>
   %define R.p rbx
   %define R.a rsi
   %define R.b r12
   %define R.t r13
    %define mm_type.tx_index.lv 88
   %define R.amode rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	rsi
    mov       rdx,	23
    mov       r8,	[rbp + mm_type.tx_index.lv]
    call      mm_type.tpass
    mov       rax,	r13
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.deref
    movsxd    rax,	dword [rsi+49]
    mov       rdi,	rax
    mov       rcx,	r12
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L9882
    cmp       rax,	11
    jz        L9882
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13567]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9882:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    mov       [rbx+49],	eax
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.tx_index.lv]
    call      mm_type.twiden
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_makerange
mm_type.tx_makerange:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.b r13
   %define R.amode rdi
   %define R.bmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	r12
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r13+49]
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       eax,	9
    mov       [rsi+49],	eax
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_ptr
mm_type.tx_ptr:
;?>>
   %define R.p rdi
   %define R.a rbx
    %define mm_type.tx_ptr.t 56
   %define R.lv rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r9
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    test      r10,	r10
    jz        L9886
    cmp       r10,	7
    jz        L9887
    cmp       r10,	11
    jz        L9888
    jmp       L9889
L9886:
    lea       rcx,	[L13568]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L9885
L9887:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    mov       r10d,	[r10 + rax*4]
    mov       [rdi+49],	r10d
    jmp       L9885
L9888:
    call      msys.m$print_startcon
    lea       rcx,	[L13569]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9885
L9889:
    lea       rcx,	[L13570]
    xor       edx,	edx
    call      mm_support.txerror
L9885:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_type.twiden
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.setrecordsize
mm_type.setrecordsize:
;?>>
   %define R.m r14
    %define mm_type.setrecordsize.fieldlist -1664
   %define R.nfields rdi
    %define mm_type.setrecordsize.size -1672
    %define mm_type.setrecordsize.index -1680
    %define mm_type.setrecordsize.maxalign -1688
   %define R.d rbx
   %define R.e rsi
   %define R.flags r12
   %define R.flag r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1728
    mov       r14,	rcx
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	r14
    mov       eax,	[rax + r10*4]
    test      eax,	eax
    jnz       L9890
L9892:
    inc       qword [mm_type.setrecordsize.depth]
    mov       rax,	[mm_type.setrecordsize.depth]
    cmp       rax,	10
    jle       L9894
    lea       rcx,	[L13571]
    call      mm_support.serror
L9894:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r14
    mov       rbx,	[rax + r10*8]
    mov       rsi,	[rbx+16]
    xor       rdi,	rdi
    inc       rdi
    mov       rax,	rdi
    mov       r10,	83
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
    jmp       L9896
L9895:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	13
    jnz       L9899
    cmp       rdi,	200
    jl        L9901
    lea       rcx,	[L13572]
    xor       edx,	edx
    call      mm_support.gerror
L9901:
    movsxd    rax,	dword [rsi+72]
    mov       rcx,	rax
    call      mm_type.setmodesize
    lea       rax,	[rsi+136]
    mov       r12,	rax
L9902:
    movzx     rax,	byte [r12]
    cmp       rax,	83
    jz        L9904
    cmp       rax,	85
    jnz       L9905
L9904:
    movzx     rax,	byte [r12]
    mov       r13,	rax
    inc       rdi
    mov       rax,	rdi
    mov       r10,	r13
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
    inc       r12
    jmp       L9902
L9905:
    jmp       L9903
L9903:
    inc       rdi
    mov       rax,	rdi
    mov       r10,	rsi
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
L9906:
    mov       rax,	r12
    inc       r12
    movzx     rax,	byte [rax]
    mov       r13,	rax
    mov       rax,	r13
    cmp       rax,	42
    jz        L9909
    cmp       rax,	69
    jz        L9910
    jmp       L9911
L9909:
    jmp       L9908
L9910:
    inc       rdi
    mov       rax,	rdi
    mov       r10,	69
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
    jmp       L9908
L9911:
    jmp       L9907
L9908:
    jmp       L9906
L9907:
L9899:
    mov       rsi,	[rsi+32]
L9896:
    test      rsi,	rsi
    jnz       L9895
    inc       rdi
    mov       rax,	rdi
    mov       r10,	69
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
    xor       eax,	eax
    mov       [rbp + rdi*8 + mm_type.setrecordsize.fieldlist],	rax
    xor       eax,	eax
    mov       [mm_type.countedfields],	rax
    mov       rax,	2
    mov       [rbp + mm_type.setrecordsize.index],	rax
    mov       rax,	1
    mov       [rbp + mm_type.setrecordsize.maxalign],	rax
    sub       rsp,	8
    lea       rax,	[rbp + mm_type.setrecordsize.maxalign]
    push      rax
    movzx     rax,	byte [rbx+149]
    push      rax
    push      0
    mov       rcx,	83
    lea       rdx,	[rbp + mm_type.setrecordsize.fieldlist]
    lea       r8,	[rbp + mm_type.setrecordsize.index]
    lea       r9,	[rbp + mm_type.setrecordsize.size]
    sub       rsp,	32
    call      mm_type.scanrecord
    add       rsp,	64
    mov       al,	[rbx+149]
    test      al,	al
    jz        L9913
    mov       rcx,	[rbp + mm_type.setrecordsize.size]
    mov       rdx,	[rbp + mm_type.setrecordsize.maxalign]
    call      mm_type.roundoffset
    mov       [rbp + mm_type.setrecordsize.size],	rax
    mov       ax,	[rbp + mm_type.setrecordsize.maxalign]
    mov       [rbx+166],	ax
    jmp       L9912
L9913:
    mov       ax,	1
    mov       [rbx+166],	ax
    mov       rax,	[rbp + mm_type.setrecordsize.size]
    and       rax,	7
    jnz       L9915
    mov       ax,	8
    mov       [rbx+166],	ax
    jmp       L9914
L9915:
    mov       rax,	[rbp + mm_type.setrecordsize.size]
    and       rax,	3
    jnz       L9916
    mov       ax,	4
    mov       [rbx+166],	ax
    jmp       L9914
L9916:
    mov       rax,	[rbp + mm_type.setrecordsize.size]
    and       rax,	1
    jnz       L9917
    mov       ax,	2
    mov       [rbx+166],	ax
L9917:
L9914:
L9912:
    mov       eax,	[rbp + mm_type.setrecordsize.size]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	r14
    mov       [r10 + r11*4],	eax
    mov       eax,	[mm_type.countedfields]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	r14
    mov       [r10 + r11*4],	eax
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	r14
    mov       [r10 + r11*4],	eax
    mov       rcx,	r14
    call      mm_type.checkblocktype
    dec       qword [mm_type.setrecordsize.depth]
L9890:
;---------------
    add       rsp,	1728
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.checkblocktype
mm_type.checkblocktype:
;?>>
   %define R.m rcx
;?]]
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rcx
    mov       eax,	[rax + r10*4]
    cmp       rax,	1
    jz        L9920
    cmp       rax,	2
    jz        L9920
    cmp       rax,	4
    jz        L9920
    cmp       rax,	8
    jnz       L9921
L9920:
    xor       eax,	eax
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rcx
    mov       [r10 + r11],	al
L9921:
L9919:
;---------------
    ret       
;End 
;Proc mm_type.scanrecord
mm_type.scanrecord:
;?>>
   %define R.state r13
   %define R.fields r14
    %define mm_type.scanrecord.index 80
    %define mm_type.scanrecord.isize 88
    %define mm_type.scanrecord.offset 96
    %define mm_type.scanrecord.calign 104
    %define mm_type.scanrecord.maxalign 112
   %define R.e rdi
   %define R.f rbx
   %define R.ea rsi
   %define R.size r12
    %define mm_type.scanrecord.fieldsize -8
    %define mm_type.scanrecord.bitoffset -16
    %define mm_type.scanrecord.alignment -24
    %define mm_type.scanrecord.newoffset -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    xor       r12,	r12
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.bitoffset],	rax
    jmp       L9924
L9923:
    mov       rax,	rbx
    cmp       rax,	83
    jz        L9927
    cmp       rax,	85
    jz        L9927
    cmp       rax,	69
    jz        L9928
    jmp       L9929
L9927:
    sub       rsp,	8
    push      qword [rbp + mm_type.scanrecord.maxalign]
    push      qword [rbp + mm_type.scanrecord.calign]
    push      qword [rbp + mm_type.scanrecord.offset]
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	[rbp + mm_type.scanrecord.index]
    lea       r9,	[rbp + mm_type.scanrecord.fieldsize]
    sub       rsp,	32
    call      mm_type.scanrecord
    add       rsp,	64
    jmp       L9926
L9928:
    cmp       r13,	85
    jnz       L9931
    inc       qword [mm_type.countedfields]
L9931:
    mov       rax,	r12
    mov       r10,	[rbp + mm_type.scanrecord.isize]
    mov       [r10],	rax
    jmp       L9922
L9929:
    movsxd    rax,	dword [rbx+72]
    cmp       rax,	27
    jnz       L9933
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.fieldsize],	rax
    mov       rsi,	[rbx+128]
    mov       eax,	[rsi+84]
    mov       [rbx+84],	eax
    mov       al,	[rbp + mm_type.scanrecord.bitoffset]
    mov       [rbx+150],	al
    movzx     rax,	byte [rbx+148]
    add       [rbp + mm_type.scanrecord.bitoffset],	rax
    mov       rax,	[rbx+128]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    shl       r10,	3
    mov       rax,	[rbp + mm_type.scanrecord.bitoffset]
    cmp       rax,	r10
    jle       L9935
    lea       rcx,	[L13573]
    xor       edx,	edx
    call      mm_support.txerror
L9935:
    jmp       L9932
L9933:
    movzx     rax,	word [rbx+92]
    shr       eax,	7
    and       eax,	1
    test      rax,	rax
    jz        L9936
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.bitoffset],	rax
    mov       rdi,	[rbx+128]
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.fieldsize],	rax
    movsxd    rax,	dword [rdi+84]
    movzx     r10,	byte [rbx+151]
    add       rax,	r10
    mov       [rbx+84],	eax
    jmp       L9932
L9936:
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.bitoffset],	rax
    cmp       r13,	83
    jnz       L9938
    inc       qword [mm_type.countedfields]
L9938:
    movsxd    rax,	dword [rbx+72]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       [rbp + mm_type.scanrecord.fieldsize],	r10
    mov       rax,	[rbp + mm_type.scanrecord.calign]
    test      rax,	rax
    jz        L9940
    movsxd    rax,	dword [rbx+72]
    mov       rcx,	rax
    call      mm_lib.getalignment
    mov       [rbp + mm_type.scanrecord.alignment],	rax
    mov       rax,	[rbp + mm_type.scanrecord.maxalign]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_type.scanrecord.alignment]
    cmp       r10,	rax
    jle       L9942
    mov       rax,	[rbp + mm_type.scanrecord.alignment]
    mov       r10,	[rbp + mm_type.scanrecord.maxalign]
    mov       [r10],	rax
L9942:
    mov       rcx,	[rbp + mm_type.scanrecord.offset]
    mov       rdx,	[rbp + mm_type.scanrecord.alignment]
    call      mm_type.roundoffset
    mov       [rbp + mm_type.scanrecord.newoffset],	rax
    mov       rax,	[rbp + mm_type.scanrecord.newoffset]
    sub       rax,	[rbp + mm_type.scanrecord.offset]
    add       r12,	rax
    jmp       L9939
L9940:
    mov       rax,	[rbp + mm_type.scanrecord.offset]
    mov       [rbp + mm_type.scanrecord.newoffset],	rax
L9939:
    mov       eax,	[rbp + mm_type.scanrecord.newoffset]
    mov       [rbx+84],	eax
    mov       rax,	[rbp + mm_type.scanrecord.newoffset]
    mov       [rbp + mm_type.scanrecord.offset],	rax
L9932:
L9926:
    cmp       r13,	83
    jnz       L9944
    mov       rax,	[rbp + mm_type.scanrecord.fieldsize]
    add       [rbp + mm_type.scanrecord.offset],	rax
    mov       rax,	[rbp + mm_type.scanrecord.fieldsize]
    add       r12,	rax
    jmp       L9943
L9944:
    mov       rax,	r12
    mov       r10,	[rbp + mm_type.scanrecord.fieldsize]
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r12,	rax
L9943:
L9924:
    mov       rax,	[rbp + mm_type.scanrecord.index]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       r10,	[r14 + r10*8-8]
    mov       rbx,	r10
    test      r10,	r10
    jnz       L9923
L9922:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.roundoffset
mm_type.roundoffset:
;?>>
   %define R.offset rcx
   %define R.alignment rdx
   %define R.mask rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    cmp       rdx,	1
    jnz       L9947
    mov       rax,	rcx
    jmp       L9945
L9947:
    lea       rax,	[rdx-1]
    mov       rdi,	rax
    jmp       L9949
L9948:
    inc       rcx
L9949:
    mov       rax,	rcx
    and       rax,	rdi
    jnz       L9948
    mov       rax,	rcx
L9945:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_convert
mm_type.tx_convert:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.hard rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	20
    jnz       L9954
L9953:
    movsxd    rax,	dword [rdi+53]
    mov       r10,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_type.tx_makelist
    jmp       L9952
L9954:
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rdi+53]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	rsi
    call      mm_type.coerceunit
L9952:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_lib.deleteunit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_makelist
mm_type.tx_makelist:
;?>>
   %define R.p r12
   %define R.a r13
    %define mm_type.tx_makelist.t 80
    %define mm_type.tx_makelist.lv 88
   %define R.alength rdi
   %define R.tlength rbx
   %define R.elemtype rsi
    %define mm_type.tx_makelist.newt -8
    %define mm_type.tx_makelist.isconst -16
    %define mm_type.tx_makelist.q -24
    %define mm_type.tx_makelist.e -32
    %define mm_type.tx_makelist.$T1 -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       r12,	rcx
    mov       r13,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       eax,	[r12+40]
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tx_makelist.newt],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_makelist.isconst],	rax
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L9957
    cmp       rdi,	rbx
    jge       L9959
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       [rbp + mm_type.tx_makelist.$T1],	rax
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[L13574]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_makelist.$T1]
    call      mm_support.txerror_ss
    jmp       L9958
L9959:
    cmp       rdi,	rbx
    jle       L9960
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       [rbp + mm_type.tx_makelist.$T1],	rax
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[L13575]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_makelist.$T1]
    call      mm_support.txerror_ss
L9960:
L9958:
L9957:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L9962
    cmp       rax,	8
    jz        L9963
    cmp       rax,	11
    jz        L9964
    jmp       L9965
L9962:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       rsi,	rax
    test      rbx,	rbx
    jnz       L9967
    sub       rsp,	8
    push      0
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    movsxd    rax,	dword [rax + r10*4]
    xor       ecx,	ecx
    mov       rdx,	rsi
    mov       r8,	rax
    mov       r9,	rdi
    sub       rsp,	32
    call      mm_lib.createarraymodek
    add       rsp,	48
    mov       [rbp + mm_type.tx_makelist.newt],	rax
    jmp       L9966
L9967:
    mov       rax,	[rbp + mm_type.tx_makelist.t]
    mov       [rbp + mm_type.tx_makelist.newt],	rax
L9966:
    mov       [rbp + mm_type.tx_makelist.q],	r13
    jmp       L9969
L9968:
    mov       rcx,	[rbp + mm_type.tx_makelist.q]
    mov       rdx,	rsi
    mov       r8,	[rbp + mm_type.tx_makelist.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L9972
    xor       eax,	eax
    mov       [rbp + mm_type.tx_makelist.isconst],	rax
L9972:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_type.tx_makelist.q],	rax
L9969:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    test      rax,	rax
    jnz       L9968
    mov       eax,	[rbp + mm_type.tx_makelist.newt]
    mov       [r12+49],	eax
    jmp       L9961
L9963:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+16]
    mov       [rbp + mm_type.tx_makelist.e],	rax
    mov       [rbp + mm_type.tx_makelist.q],	r13
    jmp       L9974
L9973:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jnz       L9977
    jmp       L9979
L9978:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_type.tx_makelist.e],	rax
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    test      rax,	rax
    jz        L9980
L9982:
L9979:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jz        L9978
L9980:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movsxd    rax,	dword [rax+72]
    mov       rcx,	[rbp + mm_type.tx_makelist.q]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_makelist.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L9984
    xor       eax,	eax
    mov       [rbp + mm_type.tx_makelist.isconst],	rax
L9984:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_type.tx_makelist.q],	rax
L9977:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_type.tx_makelist.e],	rax
L9974:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    test      rax,	rax
    jz        L9985
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    test      rax,	rax
    jnz       L9973
L9985:
    jmp       L9987
L9986:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_type.tx_makelist.e],	rax
L9987:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    test      rax,	rax
    jz        L9989
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jnz       L9986
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jz        L9986
L9989:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    test      rax,	rax
    jnz       L9992
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    test      rax,	rax
    jz        L9991
L9992:
    lea       rcx,	[L13576]
    xor       edx,	edx
    call      mm_support.txerror
L9991:
    mov       eax,	[rbp + mm_type.tx_makelist.t]
    mov       [r12+49],	eax
    mov       al,	1
    mov       [r12+61],	al
    jmp       L9961
L9964:
    call      msys.m$print_startcon
    lea       rcx,	[L13577]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9961
L9965:
    mov       rcx,	[rbp + mm_type.tx_makelist.t]
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13578]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9961:
    mov       al,	[rbp + mm_type.tx_makelist.isconst]
    mov       [r12+60],	al
    mov       rax,	[r12+24]
    mov       rcx,	rax
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [r12]
    cmp       rax,	24
    jz        L9994
    mov       rax,	[mm_type.inidata]
    test      rax,	rax
    jnz       L9996
    mov       rax,	[rbp + mm_type.tx_makelist.isconst]
    test      rax,	rax
    jz        L9996
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	10
    call      mm_lib.getavname
    mov       [rbp + mm_type.tx_makelist.e],	rax
    mov       eax,	[rbp + mm_type.tx_makelist.t]
    mov       r10,	[rbp + mm_type.tx_makelist.e]
    mov       [r10+72],	eax
    mov       rcx,	[rbp + mm_type.tx_makelist.e]
    call      mm_lib.addstatic
    xor       ecx,	ecx
    call      mm_lib.createunit0
    mov       [rbp + mm_type.tx_makelist.q],	rax
    mov       rax,	r12
    mov       r10,	[rbp + mm_type.tx_makelist.q]
    push      r10
    mov       r14,	8
L13579:
    mov       r11,	[rax]
    mov       [r10],	r11
    add       r10,	8
    add       rax,	8
    dec       r14
    jnz       L13579
    mov       r11b,	[rax]
    mov       [r10],	r11b
    pop       r10
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    mov       r10,	[rbp + mm_type.tx_makelist.e]
    mov       [r10+64],	rax
    mov       al,	4
    mov       [r12],	al
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    mov       [r12+16],	rax
L9996:
L9994:
;---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_makeslicefromlist
mm_type.tx_makeslicefromlist:
;?>>
    %define mm_type.tx_makeslicefromlist.p 16
    %define mm_type.tx_makeslicefromlist.a 24
    %define mm_type.tx_makeslicefromlist.t 32
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13580]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13581]
    xor       edx,	edx
    call      mm_support.txerror
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_type.tx_makeslice
mm_type.tx_makeslice:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
   %define R.t r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13582]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L10000
    lea       rcx,	[L13583]
    xor       edx,	edx
    call      mm_support.txerror
L10000:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    test      r10,	r10
    jz        L10002
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    xor       ecx,	ecx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    movsxd    r10,	dword [rbx+49]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10004
    lea       rcx,	[L13584]
    xor       edx,	edx
    call      mm_support.txerror
L10004:
L10002:
    mov       rcx,	rsi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       [rdi+49],	r12d
    call      msys.m$print_startcon
    lea       rcx,	[L13585]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       al,	1
    mov       [rdi+61],	al
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_makeset
mm_type.tx_makeset:
;?>>
   %define R.p rdi
   %define R.a rbx
    %define mm_type.tx_makeset.t 48
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	1
    mov       [rdi+60],	al
    jmp       L10009
L10006:
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       al,	[rbx+60]
    test      al,	al
    jnz       L10011
    xor       eax,	eax
    mov       [rdi+60],	al
L10011:
    mov       rbx,	[rbx+8]
L10009:
    test      rbx,	rbx
    jnz       L10006
    xor       eax,	eax
    mov       [rdi+49],	eax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_dot
mm_type.tx_dot:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_type.tx_dot.b 80
    %define mm_type.tx_dot.lv 88
   %define R.recmode rdi
   %define R.recbasemode rbx
   %define R.i rsi
   %define R.j r12
    %define mm_type.tx_dot.newtag -8
    %define mm_type.tx_dot.tmode -16
    %define mm_type.tx_dot.pindex -24
    %define mm_type.tx_dot.d -32
    %define mm_type.tx_dot.dequiv -40
    %define mm_type.tx_dot.$T1 -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    jmp       L10014
L10013:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_type.tx_dot.tmode],	rax
    mov       rcx,	r14
    mov       rdx,	53
    call      mm_lib.insertunit
    mov       eax,	[rbp + mm_type.tx_dot.tmode]
    mov       [r14+49],	eax
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
L10014:
    cmp       rbx,	7
    jz        L10013
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L10017
    lea       rcx,	[L13586]
    xor       edx,	edx
    call      mm_support.txerror
L10017:
    mov       rax,	[rbp + mm_type.tx_dot.b]
    mov       rax,	[rax+16]
    mov       [rbp + mm_type.tx_dot.d],	rax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    movzx     rax,	byte [rax+78]
    test      rax,	rax
    jnz       L10019
    mov       rcx,	[rbp + mm_type.tx_dot.d]
    mov       rdx,	rdi
    call      mm_type.resolvefield
    mov       r10,	[rbp + mm_type.tx_dot.b]
    mov       [r10+16],	rax
    mov       [rbp + mm_type.tx_dot.d],	rax
L10019:
    mov       rax,	[rbp + mm_type.tx_dot.d]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jnz       L10021
    mov       rax,	[rbp + mm_type.tx_dot.d]
    movzx     rax,	byte [rax+150]
    mov       rsi,	rax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    movzx     rax,	byte [rax+148]
    mov       r10,	rsi
    add       r10,	rax
    dec       r10
    mov       r12,	r10
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       rax,	[rax+128]
    mov       [rbp + mm_type.tx_dot.dequiv],	rax
    mov       rax,	[rbp + mm_type.tx_dot.dequiv]
    mov       r10,	[rbp + mm_type.tx_dot.b]
    mov       [r10+16],	rax
    mov       rax,	[rbp + mm_type.tx_dot.dequiv]
    mov       eax,	[rax+72]
    mov       r10,	[rbp + mm_type.tx_dot.b]
    mov       [r10+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       eax,	[rax+84]
    mov       [r13+40],	eax
    cmp       rsi,	r12
    jnz       L10023
    mov       rcx,	rsi
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [rbp + mm_type.tx_dot.pindex],	rax
    mov       rax,	51
    mov       [rbp + mm_type.tx_dot.newtag],	rax
    jmp       L10022
L10023:
    mov       rcx,	r12
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [rbp + mm_type.tx_dot.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	21
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_dot.$T1]
    call      mm_lib.createunit2
    mov       [rbp + mm_type.tx_dot.pindex],	rax
    mov       eax,	9
    mov       r10,	[rbp + mm_type.tx_dot.pindex]
    mov       [r10+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.pindex]
    mov       rax,	[rax+16]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       rax,	[rbp + mm_type.tx_dot.pindex]
    mov       rax,	[rax+24]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       rax,	52
    mov       [rbp + mm_type.tx_dot.newtag],	rax
L10022:
    mov       rax,	[rbp + mm_type.tx_dot.b]
    mov       eax,	[rax+49]
    mov       [r13+49],	eax
    mov       rcx,	r13
    mov       rdx,	[rbp + mm_type.tx_dot.lv]
    call      mm_type.twiden
    mov       rcx,	r13
    mov       rdx,	[rbp + mm_type.tx_dot.newtag]
    call      mm_lib.insertunit
    mov       eax,	4
    mov       [r13+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.pindex]
    mov       [r13+24],	rax
    mov       rax,	[r13+16]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       rax,	[r13+24]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       al,	1
    mov       [r13+61],	al
    jmp       L10012
L10021:
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       eax,	[rax+72]
    mov       r10,	[rbp + mm_type.tx_dot.b]
    mov       [r10+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       eax,	[rax+72]
    mov       [r13+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       eax,	[rax+84]
    mov       [r13+40],	eax
    mov       rcx,	r13
    mov       rdx,	[rbp + mm_type.tx_dot.lv]
    call      mm_type.twiden
L10012:
;---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.resolvefield
mm_type.resolvefield:
;?>>
   %define R.d rsi
   %define R.m r12
   %define R.e rdi
   %define R.t rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L10026
    cmp       rax,	7
    jz        L10027
    jmp       L10028
L10026:
    jmp       L10025
L10027:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L10030
    lea       rcx,	[L13587]
    xor       edx,	edx
    call      mm_support.txerror
L10030:
    jmp       L10025
L10028:
    lea       rcx,	[L13588]
    xor       edx,	edx
    call      mm_support.txerror
L10025:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r12
    mov       rbx,	[rax + r10*8]
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mm_name.finddupl
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L10032
    mov       rax,	[rsi]
    lea       rcx,	[L13589]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10032:
    mov       rax,	rdi
L10024:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_andl
mm_type.tx_andl:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	6
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	6
    mov       [rdi+49],	eax
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.convintconst
mm_type.convintconst:
;?>>
   %define R.p rcx
   %define R.x rdx
;?]]
;---------------
    mov       al,	1
    mov       [rcx],	al
    mov       eax,	3
    mov       [rcx+49],	eax
    xor       eax,	eax
    mov       [rcx+32],	rax
    mov       [rcx+24],	rax
    mov       [rcx+16],	rax
    mov       [rcx+16],	rdx
    mov       al,	1
    mov       [rcx+60],	al
;---------------
    ret       
;End 
;Proc mm_type.tx_sliceptr
mm_type.tx_sliceptr:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.m rdi
   %define R.tmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	11
    jnz       L10038
L10037:
    jmp       L10036
L10038:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13590]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10036:
    sub       rsp,	8
    push      0
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	rdi
    movsxd    r10,	dword [r10 + r11*4]
    xor       ecx,	ecx
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_lib.createarraymodek
    add       rsp,	48
    mov       rbx,	rax
    xor       ecx,	ecx
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       [rsi+49],	eax
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_swap
mm_type.tx_swap:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    call      mm_type.tpasslv
    mov       rcx,	rsi
    mov       rdx,	23
    call      mm_type.tpasslv
    movsxd    rax,	dword [rsi+49]
    movsxd    r10,	dword [rbx+49]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10041
    lea       rcx,	[L13591]
    xor       edx,	edx
    call      mm_support.txerror
L10041:
    xor       eax,	eax
    mov       [rdi+49],	eax
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_select
mm_type.tx_select:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.b r13
   %define R.c r14
    %define mm_type.tx_select.t 96
    %define mm_type.tx_select.lv 104
   %define R.u rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    mov       rcx,	r12
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rbx,	r13
    jmp       L10044
L10043:
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.tx_select.t]
    mov       r8,	[rbp + mm_type.tx_select.lv]
    call      mm_type.tpass
    cmp       rbx,	r13
    jnz       L10047
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    jmp       L10046
L10047:
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rdi,	rax
L10046:
    mov       rbx,	[rbx+8]
L10044:
    test      rbx,	rbx
    jnz       L10043
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_type.tx_select.t]
    mov       r8,	[rbp + mm_type.tx_select.lv]
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rdi,	rax
    mov       rbx,	r13
    jmp       L10049
L10048:
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rbx,	[rbx+8]
L10049:
    test      rbx,	rbx
    jnz       L10048
    mov       [rsi+49],	edi
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_case
mm_type.tx_case:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_type.tx_case.b 80
    %define mm_type.tx_case.c 88
    %define mm_type.tx_case.t 96
    %define mm_type.tx_case.lv 104
   %define R.amode rdi
   %define R.u rbx
   %define R.wt rsi
   %define R.w r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movzx     rax,	byte [r13]
    cmp       rax,	106
    jnz       L10053
    mov       rax,	[rbp + mm_type.tx_case.lv]
    test      rax,	rax
    jz        L10053
    lea       rcx,	[L13592]
    xor       edx,	edx
    call      mm_support.gerror
L10053:
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    test      r14,	r14
    jnz       L10055
    mov       rdi,	23
    jmp       L10054
L10055:
    movsxd    rax,	dword [r14+49]
    mov       rdi,	rax
L10054:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10057
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    cmp       rax,	8
    jge       L10057
    mov       rcx,	r14
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rdi,	3
L10057:
    xor       rbx,	rbx
    mov       rax,	[rbp + mm_type.tx_case.b]
    mov       rsi,	rax
    jmp       L10059
L10058:
    mov       r12,	[rsi+16]
    jmp       L10062
L10061:
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [r12]
    cmp       rax,	21
    jnz       L10065
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L10067
    lea       rcx,	[L13593]
    xor       edx,	edx
    call      mm_support.txerror
L10067:
    jmp       L10064
L10065:
    cmp       rdi,	23
    jnz       L10069
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10071
    lea       rcx,	[L13594]
    xor       edx,	edx
    call      mm_support.txerror
    mov       rcx,	r12
    mov       rdx,	18
    call      mm_lib.insertunit
L10071:
    jmp       L10068
L10069:
    mov       rcx,	r12
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
L10068:
L10064:
    mov       r12,	[r12+8]
L10062:
    test      r12,	r12
    jnz       L10061
    mov       rax,	[rsi+24]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tx_case.t]
    mov       r8,	[rbp + mm_type.tx_case.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_case.t]
    test      rax,	rax
    jz        L10073
    test      rbx,	rbx
    jz        L10075
    mov       rax,	[rsi+24]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rbx,	rax
    jmp       L10074
L10075:
    mov       rax,	[rsi+24]
    movsxd    rax,	dword [rax+49]
    mov       rbx,	rax
L10074:
L10073:
    mov       rsi,	[rsi+8]
L10059:
    test      rsi,	rsi
    jnz       L10058
    mov       rax,	[rbp + mm_type.tx_case.c]
    test      rax,	rax
    jz        L10077
    mov       rcx,	[rbp + mm_type.tx_case.c]
    mov       rdx,	[rbp + mm_type.tx_case.t]
    mov       r8,	[rbp + mm_type.tx_case.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_case.t]
    cmp       rax,	23
    jnz       L10079
    mov       rax,	[rbp + mm_type.tx_case.c]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rbx,	rax
L10079:
    jmp       L10076
L10077:
    mov       rax,	[rbp + mm_type.tx_case.t]
    test      rax,	rax
    jz        L10080
    lea       rcx,	[L13595]
    xor       edx,	edx
    call      mm_support.txerror
L10080:
L10076:
    mov       rax,	[rbp + mm_type.tx_case.t]
    test      rax,	rax
    jz        L10082
    mov       [r13+49],	ebx
    jmp       L10081
L10082:
    xor       eax,	eax
    mov       [r13+49],	eax
L10081:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_notl
mm_type.tx_notl:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	6
    mov       [rdi+49],	eax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_typepun
mm_type.tx_typepun:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.smode rdi
   %define R.tmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [r12]
    cmp       rax,	20
    jnz       L10087
L10086:
    lea       rcx,	[L13596]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L10085
L10087:
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rdi,	r10
    movsxd    rax,	dword [rsi+53]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rbx,	r10
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10090
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L10089
L10090:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10091
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L10089
L10091:
    lea       rcx,	[L13597]
    xor       edx,	edx
    call      mm_support.txerror
L10089:
    mov       rax,	rbx
    cmp       rax,	16
    jz        L10094
    cmp       rax,	19
    jnz       L10093
L10094:
    mov       rbx,	3
L10093:
    mov       [rsi+49],	ebx
L10085:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_exit
mm_type.tx_exit:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rbx,	rbx
    jnz       L10097
    jmp       L10095
L10097:
    mov       rcx,	rbx
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jz        L10099
    lea       rcx,	[L13598]
    xor       edx,	edx
    call      mm_support.txerror
L10099:
    mov       rax,	[rbx+16]
    mov       [rdi+40],	eax
    xor       eax,	eax
    mov       [rdi+16],	rax
L10095:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_goto
mm_type.tx_goto:
;?>>
    %define mm_type.tx_goto.p 32
   %define R.a rbx
   %define R.m rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	7
    jnz       L10103
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	25
    jz        L10102
L10103:
    lea       rcx,	[L13599]
    xor       edx,	edx
    call      mm_support.txerror
L10102:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_switch
mm_type.tx_switch:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_type.tx_switch.b 80
    %define mm_type.tx_switch.c 88
    %define mm_type.tx_switch.t 96
    %define mm_type.tx_switch.lv 104
    %define mm_type.tx_switch.valueset -2048
   %define R.wt rdi
   %define R.w rbx
   %define R.ax rsi
   %define R.bx r12
    %define mm_type.tx_switch.i -2056
    %define mm_type.tx_switch.u -2064
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2096
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movzx     rax,	byte [r13]
    cmp       rax,	108
    jnz       L10106
    mov       rax,	[rbp + mm_type.tx_switch.lv]
    test      rax,	rax
    jz        L10106
    lea       rcx,	[L13600]
    xor       edx,	edx
    call      mm_support.gerror
L10106:
    movzx     rax,	byte [r13]
    cmp       rax,	110
    jnz       L10108
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[r14+8]
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L10110
    lea       rcx,	[L13601]
    xor       edx,	edx
    call      mm_support.txerror
L10110:
    jmp       L10107
L10108:
    mov       rcx,	r14
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
L10107:
    lea       rcx,	[rbp + mm_type.tx_switch.valueset]
    xor       edx,	edx
    mov       r8,	2048
    call      memset
    xor       eax,	eax
    mov       [rbp + mm_type.tx_switch.u],	rax
    mov       rdi,	[rbp + mm_type.tx_switch.b]
    jmp       L10112
L10111:
    mov       rbx,	[rdi+16]
    jmp       L10115
L10114:
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    call      mm_lib.isconstunit
    test      rax,	rax
    jnz       L10118
    mov       rcx,	rbx
    xor       edx,	edx
    lea       r8,	[L13602]
    xor       r9d,	r9d
    call      mm_diags.printunit
    lea       rcx,	[L13603]
    xor       edx,	edx
    call      mm_support.txerror
L10118:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	9
    jz        L10120
    jmp       L10121
L10120:
    mov       rax,	[rbx+16]
    mov       rsi,	[rax+16]
    mov       rax,	[rbx+24]
    mov       r12,	[rax+16]
;mm_type.tx_switch.dorange:
L10122:
    mov       [rbp + mm_type.tx_switch.i],	rsi
    mov       rax,	[rbp + mm_type.tx_switch.i]
    cmp       rax,	r12
    jg        L10125
L10123:
    mov       rax,	[rbp + mm_type.tx_switch.i]
    cmp       rax,	0
    jl        L10128
    mov       rax,	[rbp + mm_type.tx_switch.i]
    cmp       rax,	2047
    jle       L10127
L10128:
    lea       rcx,	[L13604]
    xor       edx,	edx
    call      mm_support.txerror
L10127:
    mov       rax,	[rbp + mm_type.tx_switch.i]
    mov       al,	[rbp + rax + mm_type.tx_switch.valueset]
    test      al,	al
    jz        L10130
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mm_type.tx_switch.i]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13605]
    xor       edx,	edx
    call      mm_support.txerror
L10130:
    mov       al,	1
    mov       r10,	[rbp + mm_type.tx_switch.i]
    mov       [rbp + r10 + mm_type.tx_switch.valueset],	al
    mov       rax,	[rbp + mm_type.tx_switch.i]
    inc       rax
    mov       [rbp + mm_type.tx_switch.i],	rax
    cmp       rax,	r12
    jle       L10123
L10125:
    jmp       L10119
L10121:
    mov       rcx,	rbx
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	rbx
    call      mm_type.tevaluate
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jz        L10132
    lea       rcx,	[L13606]
    xor       edx,	edx
    call      mm_support.txerror
L10132:
    mov       rax,	[rbx+16]
    mov       r12,	rax
    mov       rsi,	rax
    jmp       L10122
L10119:
    mov       rbx,	[rbx+8]
L10115:
    test      rbx,	rbx
    jnz       L10114
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tx_switch.t]
    mov       r8,	[rbp + mm_type.tx_switch.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_switch.t]
    cmp       rax,	23
    jnz       L10134
    mov       rax,	[rbp + mm_type.tx_switch.u]
    test      rax,	rax
    jz        L10136
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	[rbp + mm_type.tx_switch.u]
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       [rbp + mm_type.tx_switch.u],	rax
    jmp       L10135
L10136:
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax+49]
    mov       [rbp + mm_type.tx_switch.u],	rax
L10135:
L10134:
    mov       rdi,	[rdi+8]
L10112:
    test      rdi,	rdi
    jnz       L10111
    mov       rax,	[rbp + mm_type.tx_switch.c]
    test      rax,	rax
    jz        L10138
    mov       rcx,	[rbp + mm_type.tx_switch.c]
    mov       rdx,	[rbp + mm_type.tx_switch.t]
    mov       r8,	[rbp + mm_type.tx_switch.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_switch.t]
    cmp       rax,	23
    jnz       L10140
    mov       rax,	[rbp + mm_type.tx_switch.c]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	[rbp + mm_type.tx_switch.u]
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       [rbp + mm_type.tx_switch.u],	rax
L10140:
    jmp       L10137
L10138:
    mov       rax,	[rbp + mm_type.tx_switch.t]
    test      rax,	rax
    jz        L10141
    lea       rcx,	[L13607]
    xor       edx,	edx
    call      mm_support.txerror
L10141:
L10137:
    mov       rax,	[rbp + mm_type.tx_switch.t]
    test      rax,	rax
    jz        L10143
    mov       rax,	[rbp + mm_type.tx_switch.b]
    mov       rbx,	[rax+16]
    jmp       L10145
L10144:
    mov       rax,	[rbp + mm_type.tx_switch.t]
    cmp       rax,	23
    jnz       L10148
    mov       rax,	[rbp + mm_type.tx_switch.b]
    mov       rax,	[rax+24]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tx_switch.u]
    xor       r8d,	r8d
    call      mm_type.coerceunit
L10148:
    mov       rax,	[rbp + mm_type.tx_switch.b]
    mov       rax,	[rax+24]
    mov       eax,	[rax+49]
    mov       [rbx+49],	eax
    mov       rbx,	[rbx+8]
L10145:
    test      rbx,	rbx
    jnz       L10144
    mov       rax,	[rbp + mm_type.tx_switch.t]
    cmp       rax,	23
    jnz       L10150
    mov       rcx,	[rbp + mm_type.tx_switch.c]
    mov       rdx,	[rbp + mm_type.tx_switch.u]
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       eax,	[rbp + mm_type.tx_switch.u]
    mov       [r13+49],	eax
    jmp       L10149
L10150:
    mov       eax,	[rbp + mm_type.tx_switch.t]
    mov       [r13+49],	eax
L10149:
    jmp       L10142
L10143:
    xor       eax,	eax
    mov       [r13+49],	eax
L10142:
;---------------
    add       rsp,	2096
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_addroffirst
mm_type.tx_addroffirst:
;?>>
   %define R.p rbx
   %define R.a rsi
    %define mm_type.tx_addroffirst.t 56
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rsi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rsi+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L10153
    lea       rcx,	[L13608]
    xor       edx,	edx
    call      mm_support.txerror
L10153:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    xor       ecx,	ecx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       rdi,	rax
    movzx     rax,	byte [rsi]
    cmp       rax,	4
    jnz       L10155
    mov       al,	1
    mov       [rsi+40],	al
L10155:
    mov       [rbx+49],	edi
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_return
mm_type.tx_return:
;?>>
   %define R.p r14
   %define R.a r15
    %define mm_type.tx_return.t 88
   %define R.m rdi
   %define R.nret rbx
   %define R.i rsi
   %define R.pmult r12
   %define R.q r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
    mov       rdi,	rax
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+122]
    mov       rbx,	rax
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttmult]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    test      r15,	r15
    jnz       L10158
    test      rbx,	rbx
    jz        L10160
    lea       rcx,	[L13609]
    xor       edx,	edx
    call      mm_support.txerror
L10160:
    jmp       L10156
L10158:
    test      rbx,	rbx
    jnz       L10161
    lea       rcx,	[L13610]
    xor       edx,	edx
    call      mm_support.txerror
L10161:
L10157:
    movzx     rax,	byte [r15]
    cmp       rax,	20
    jnz       L10163
    mov       al,	25
    mov       [r15],	al
    mov       eax,	[r15+40]
    cmp       rax,	rbx
    jz        L10165
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L10167
    cmp       rax,	10
    jnz       L10168
L10167:
    lea       rcx,	[L13611]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L10166
L10168:
    lea       rcx,	[L13612]
    xor       edx,	edx
    call      mm_support.txerror
L10166:
L10165:
    mov       r13,	[r15+16]
    mov       rsi,	1
    cmp       rbx,	1
    jl        L10171
L10169:
    movsxd    rax,	dword [r12 + rsi*4-4]
    mov       rcx,	r13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       r13,	[r13+8]
    inc       rsi
    cmp       rsi,	rbx
    jle       L10169
L10171:
    mov       rcx,	r14
    mov       rdx,	r15
    call      mm_lib.deleteunit
    mov       rax,	[rbp + mm_type.tx_return.t]
    test      rax,	rax
    jnz       L10173
    xor       eax,	eax
    mov       [r14+49],	eax
    jmp       L10172
L10173:
    mov       eax,	28
    mov       [r14+49],	eax
L10172:
    jmp       L10162
L10163:
    cmp       rbx,	1
    jle       L10175
    lea       rcx,	[L13613]
    xor       edx,	edx
    call      mm_support.txerror
L10175:
    mov       rcx,	r15
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_return.t]
    test      rax,	rax
    jnz       L10177
    xor       eax,	eax
    mov       [r14+49],	eax
    jmp       L10176
L10177:
    mov       rcx,	r14
    mov       rdx,	r15
    call      mm_lib.deleteunit
L10176:
L10162:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttisshort]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10179
    lea       rcx,	[L13614]
    xor       edx,	edx
    call      mm_support.txerror
L10179:
L10156:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_dotindex
mm_type.tx_dotindex:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
    %define mm_type.tx_dotindex.lv 96
   %define R.pmode rdi
   %define R.i rbx
   %define R.j rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+96],	r9
;---------------
    mov       rcx,	r13
    mov       rdx,	23
    mov       r8,	[rbp + mm_type.tx_dotindex.lv]
    call      mm_type.tpass
    mov       rdi,	4
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10182
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10184
    mov       rcx,	r13
    mov       rdx,	61
    call      mm_lib.insertunit
    mov       eax,	4
    mov       [r13+53],	eax
    mov       [r13+49],	eax
    mov       al,	1
    mov       [r13+61],	al
    jmp       L10183
L10184:
    lea       rcx,	[L13615]
    xor       edx,	edx
    call      mm_support.txerror
L10183:
L10182:
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	9
    jz        L10186
    jmp       L10187
L10186:
    mov       rbx,	[r14+16]
    mov       rsi,	[r14+24]
    movzx     rax,	byte [rbx]
    movzx     r10,	byte [rsi]
    cmp       r10,	rax
    jnz       L10189
    cmp       r10,	1
    jnz       L10189
    mov       rax,	[rbx+16]
    mov       r10,	[rsi+16]
    cmp       rax,	r10
    jle       L10191
    lea       rax,	[r14+16]
    lea       r10,	[r14+24]
    mov       r11,	[rax]
    mov       r15,	[r10]
    mov       [r10],	r11
    mov       [rax],	r15
L10191:
L10189:
    jmp       L10185
L10187:
    mov       rcx,	r14
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
L10185:
    mov       [r12+49],	edi
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_slice
mm_type.tx_slice:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rbx+49]
    cmp       rax,	20
    jnz       L10194
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	12
    mov       r8,	1
    xor       r9d,	r9d
    call      mm_lib.createslicemodek
    mov       [rdi+49],	eax
    jmp       L10193
L10194:
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_type.deref
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	10
    jz        L10196
    cmp       r10,	11
    jz        L10197
    jmp       L10198
L10196:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	r10
    mov       r8,	1
    xor       r9d,	r9d
    call      mm_lib.createslicemodek
    mov       [rdi+49],	eax
    jmp       L10195
L10197:
    mov       eax,	[rbx+49]
    mov       [rdi+49],	eax
    jmp       L10195
L10198:
    call      msys.m$print_startcon
    lea       rcx,	[L13616]
    call      msys.m$print_str_nf
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13617]
    xor       edx,	edx
    call      mm_support.txerror
L10195:
L10193:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.twiden
mm_type.twiden:
;?>>
   %define R.p rsi
   %define R.lv r12
   %define R.m rdi
   %define R.mbase rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movsxd    rax,	dword [rsi+49]
    mov       rdi,	rax
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rbx,	r10
    test      rbx,	rbx
    jnz       L10201
    jmp       L10199
L10201:
    test      r12,	r12
    jz        L10203
    jmp       L10199
L10203:
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10199
L10205:
    movzx     rax,	byte [rsi]
    cmp       rax,	4
    jz        L10207
    cmp       rax,	53
    jz        L10207
    cmp       rax,	46
    jz        L10207
    cmp       rax,	49
    jz        L10207
    cmp       rax,	32
    jz        L10207
    cmp       rax,	40
    jnz       L10208
L10207:
    mov       rcx,	rsi
    mov       rdx,	58
    call      mm_lib.insertunit
    mov       al,	4
    mov       [rsi+62],	al
    mov       [rsi+53],	edi
    mov       rcx,	rdi
    call      mm_lib.gettypebase
    mov       [rsi+49],	eax
    jmp       L10206
L10208:
    mov       rcx,	rsi
    xor       edx,	edx
    lea       r8,	[L13618]
    xor       r9d,	r9d
    call      mm_diags.printunit
    movzx     rax,	byte [rsi]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L13619]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10206:
L10199:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tstringslice
mm_type.tstringslice:
;?>>
   %define R.p r12
   %define R.slicemode r13
   %define R.a rdi
   %define R.b rbx
   %define R.prange rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jz        L10211
    lea       rcx,	[L13620]
    xor       edx,	edx
    call      mm_support.txerror
L10211:
    mov       rdi,	r12
    mov       rcx,	r12
    mov       rdx,	48
    call      mm_lib.insertunit
    mov       rax,	[r12+16]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L10212
L10213:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rbx,	rax
    mov       rcx,	rbx
    mov       rdx,	36
    call      mm_lib.insertunit
    mov       rcx,	1
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	21
    mov       rdx,	rax
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rsi,	rax
    mov       eax,	9
    mov       [rsi+49],	eax
    mov       [r12+24],	rsi
L10212:
    mov       [r12+49],	r13d
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_bitfield
mm_type.tx_bitfield:
;?>>
   %define R.p r14
   %define R.a r15
    %define mm_type.tx_bitfield.lv 88
   %define R.i rdi
   %define R.j rbx
   %define R.bitsize rsi
   %define R.topbit r12
   %define R.r r13
    %define mm_type.tx_bitfield.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rcx,	r15
    mov       rdx,	23
    mov       r8,	[rbp + mm_type.tx_bitfield.lv]
    call      mm_type.tpass
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10216
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10216
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10218
    mov       rcx,	r15
    mov       rdx,	61
    call      mm_lib.insertunit
    mov       eax,	4
    mov       [r15+53],	eax
    mov       [r15+49],	eax
    mov       al,	1
    mov       [r15+61],	al
    jmp       L10217
L10218:
    lea       rcx,	[L13621]
    xor       edx,	edx
    call      mm_support.txerror
L10217:
L10216:
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    shl       rax,	3
    mov       rsi,	rax
    lea       rax,	[rsi-1]
    mov       r12,	rax
    movsx     rax,	word [r14+40]
    cmp       rax,	2
    jz        L10220
    cmp       rax,	1
    jz        L10221
    cmp       rax,	4
    jz        L10222
    cmp       rax,	7
    jz        L10223
    cmp       rax,	8
    jz        L10223
    cmp       rax,	3
    jz        L10224
    cmp       rax,	6
    jz        L10225
    cmp       rax,	5
    jz        L10226
    jmp       L10227
L10220:
    xor       rdi,	rdi
    mov       rax,	7
    mov       rbx,	rax
    jmp       L10219
L10221:
    mov       rbx,	r12
    lea       rax,	[r12-7]
    mov       rdi,	rax
    jmp       L10219
L10222:
    xor       eax,	eax
    mov       rbx,	rax
    mov       rdi,	rax
    jmp       L10219
L10223:
    mov       rax,	[rbp + mm_type.tx_bitfield.lv]
    test      rax,	rax
    jz        L10229
    lea       rcx,	[L13622]
    xor       edx,	edx
    call      mm_support.txerror
L10229:
    xor       eax,	eax
    mov       rbx,	rax
    mov       rdi,	rax
    jmp       L10219
L10224:
    mov       rax,	r12
    mov       rbx,	rax
    mov       rdi,	rax
    jmp       L10219
L10225:
    xor       rdi,	rdi
    mov       rax,	rsi
    sar       rax,	1
    dec       rax
    mov       rbx,	rax
    jmp       L10219
L10226:
    mov       rax,	rsi
    sar       rax,	1
    mov       rdi,	rax
    mov       rbx,	r12
    jmp       L10219
L10227:
    call      msys.m$print_startcon
    movsx     rax,	word [r14+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13623]
    xor       edx,	edx
    call      mm_support.txerror
L10219:
    cmp       rdi,	rbx
    jnz       L10231
    mov       al,	51
    mov       [r14],	al
    mov       rcx,	rdi
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [r14+24],	rax
    mov       al,	1
    mov       [r14+61],	al
    mov       rax,	[r14+24]
    mov       r10b,	1
    mov       [rax+61],	r10b
    movsx     rax,	word [r14+40]
    cmp       rax,	8
    jnz       L10233
    mov       eax,	4
    mov       [r14+49],	eax
    mov       rcx,	r14
    call      mm_type.addnotl
L10233:
    jmp       L10230
L10231:
    mov       rcx,	rbx
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [rbp + mm_type.tx_bitfield.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	21
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_bitfield.$T1]
    call      mm_lib.createunit2
    mov       r13,	rax
    mov       rax,	[r13+16]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       rax,	[r13+24]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       eax,	9
    mov       [r13+49],	eax
    mov       al,	52
    mov       [r14],	al
    mov       [r14+24],	r13
L10230:
    mov       eax,	4
    mov       [r14+49],	eax
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.deref
mm_type.deref:
;?>>
   %define R.a rsi
    %define mm_type.deref.needres 48
   %define R.abasemode rdi
   %define R.tmode rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rdi,	r10
    jmp       L10236
L10235:
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rbx,	r10
    mov       rcx,	rsi
    mov       rdx,	53
    call      mm_lib.insertunit
    mov       [rsi+49],	ebx
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rdi,	r10
L10236:
    cmp       rdi,	7
    jz        L10235
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tmethodcall
mm_type.tmethodcall:
;?>>
   %define R.p r15
    %define mm_type.tmethodcall.pdot 80
    %define mm_type.tmethodcall.pargs 88
   %define R.mrec rdi
   %define R.prec rbx
   %define R.pfield rsi
   %define R.pfunc r12
   %define R.d r13
   %define R.e r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rax,	[rbp + mm_type.tmethodcall.pdot]
    mov       rbx,	[rax+16]
    mov       rax,	[rbp + mm_type.tmethodcall.pdot]
    mov       rsi,	[rax+24]
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    mov       r13,	[rsi+16]
    mov       rcx,	r13
    mov       rdx,	rdi
    call      mm_type.resolvefield
    mov       r14,	rax
    test      r14,	r14
    jnz       L10240
    mov       rax,	[r13]
    lea       rcx,	[L13624]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10240:
    mov       rcx,	r14
    call      mm_lib.createname
    mov       r12,	rax
    mov       eax,	[r14+72]
    mov       [r12+49],	eax
    mov       rax,	[rbp + mm_type.tmethodcall.pargs]
    mov       [rbx+8],	rax
    mov       [r15+16],	r12
    mov       [r15+24],	rbx
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.do_bounds
mm_type.do_bounds:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.m rdi
   %define R.mbase rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_type.deref
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    movzx     rax,	byte [r12]
    cmp       rax,	62
    jnz       L10243
    mov       rdi,	[r12+16]
L10243:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    mov       eax,	3
    mov       [rsi+49],	eax
    movzx     rax,	byte [rsi+62]
    cmp       rax,	3
    jz        L10245
    cmp       rax,	4
    jz        L10246
    cmp       rax,	2
    jz        L10247
    cmp       rax,	5
    jz        L10248
    cmp       rax,	1
    jz        L10249
    jmp       L10250
L10245:
    mov       rax,	rbx
    cmp       rax,	10
    jz        L10252
    cmp       rax,	11
    jnz       L10253
L10252:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.convintconst
    jmp       L10241
L10253:
;mm_type.do_bounds.error:
L10254:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13625]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10251:
    jmp       L10244
L10246:
    mov       rax,	rbx
    cmp       rax,	10
    jz        L10256
    cmp       rax,	11
    jz        L10257
    jmp       L10258
L10256:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rdi
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.convintconst
    jmp       L10255
L10257:
    mov       al,	36
    mov       [rsi],	al
    jmp       L10255
L10258:
    jmp       L10254
L10255:
    jmp       L10244
L10247:
    mov       rax,	rbx
    cmp       rax,	10
    jz        L10260
    cmp       rax,	11
    jz        L10261
    jmp       L10262
L10260:
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.convintconst
    jmp       L10259
L10261:
    mov       al,	36
    mov       [rsi],	al
    jmp       L10259
L10262:
    jmp       L10254
L10259:
    jmp       L10244
L10248:
    mov       eax,	9
    mov       [rsi+49],	eax
    mov       rax,	rbx
    cmp       rax,	10
    jz        L10264
    cmp       rax,	11
    jz        L10265
    jmp       L10266
L10264:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       [rsi+16],	rax
    mov       rax,	[rsi+16]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rdi
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       [rsi+24],	rax
    mov       al,	1
    mov       [rsi],	al
    xor       eax,	eax
    mov       [rsi+32],	rax
    mov       [rsi+24],	rax
    mov       [rsi+16],	rax
    mov       al,	1
    mov       [rsi+60],	al
    jmp       L10241
L10265:
    jmp       L10263
L10266:
    jmp       L10254
L10263:
    jmp       L10244
L10249:
    cmp       rbx,	11
    jz        L10268
    lea       rcx,	[L13626]
    xor       edx,	edx
    call      mm_support.txerror
L10268:
    mov       al,	36
    mov       [rsi],	al
L10250:
L10244:
L10241:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.addnotl
mm_type.addnotl:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	17
    call      mm_lib.insertunit
    mov       eax,	6
    mov       [rdi+49],	eax
    mov       al,	63
    mov       [rdi+62],	al
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_type.tevaluate
mm_type.tevaluate:
;?>>
   %define R.p r13
   %define R.a rdi
   %define R.b rbx
   %define R.pname rsi
    %define mm_type.tevaluate.offset -8
   %define R.tag r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [r13]
    mov       r12,	rax
    lea       rax,	[mm_tables.jisexpr]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    cmp       rax,	2
    jnz       L10272
    mov       rcx,	r13
    call      mm_type.tevalbinop
    jmp       L10271
L10272:
    lea       rax,	[mm_tables.jisexpr]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    cmp       rax,	1
    jnz       L10273
    mov       rcx,	r13
    call      mm_type.tevalmonop
    jmp       L10271
L10273:
    mov       rax,	r12
    cmp       rax,	21
    jz        L10275
    cmp       rax,	55
    jz        L10276
    jmp       L10277
L10275:
    mov       rdi,	[r13+16]
    mov       rbx,	[r13+24]
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    cmp       r10,	8
    jg        L10279
    mov       rcx,	rdi
    call      mm_type.tevaluate
    mov       rcx,	rbx
    call      mm_type.tevaluate
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jnz       L10281
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jnz       L10281
    movzx     rax,	byte [rdi+60]
    movzx     r10,	byte [rbx+60]
    and       rax,	r10
    mov       [r13+60],	al
L10281:
L10279:
    jmp       L10274
L10276:
    mov       rdi,	[r13+16]
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_type.tevaluate.offset]
    call      mm_type.addrdotindex
    mov       rsi,	rax
    test      rsi,	rsi
    jz        L10283
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_lib.deleteunit
    mov       rax,	[r13+24]
    test      rax,	rax
    jnz       L10285
    mov       rcx,	[rbp + mm_type.tevaluate.offset]
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [r13+24],	rax
    jmp       L10284
L10285:
    mov       rax,	[r13+24]
    lea       rax,	[rax+16]
    mov       r10,	[rbp + mm_type.tevaluate.offset]
    add       [rax],	r10
L10284:
L10283:
L10277:
L10274:
L10271:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.addrdotindex
mm_type.addrdotindex:
;?>>
   %define R.p rsi
   %define R.offset r12
   %define R.q rdi
   %define R.axmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [rsi]
    cmp       rax,	49
    jz        L10288
    cmp       rax,	46
    jz        L10289
    jmp       L10290
L10288:
    mov       rax,	[rsi+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L10292
    mov       eax,	[rsi+40]
    mov       [r12],	rax
    mov       rax,	[rsi+16]
    jmp       L10291
L10292:
    mov       rax,	[rsi+16]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mm_type.addrdotindex
    mov       rdi,	rax
    mov       eax,	[rsi+40]
    mov       r10,	r12
    add       [r10],	rax
    mov       rax,	rdi
L10291:
    jmp       L10287
L10289:
    mov       rax,	[rsi+16]
    movsxd    rax,	dword [rax+49]
    mov       rbx,	rax
    mov       rax,	[rsi+24]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L10294
    mov       rax,	[rsi+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L10296
    mov       rax,	[rsi+24]
    mov       rax,	[rax+16]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    movsxd    r10,	dword [r10 + r11*4]
    sub       rax,	r10
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	rbx
    movsxd    r10,	dword [r10 + r11*4]
    lea       r11,	[mm_decls.ttsize]
    mov       r11d,	[r11 + r10*4]
    imul      rax,	r11
    mov       [r12],	rax
    mov       rax,	[rsi+16]
    jmp       L10295
L10296:
    mov       rax,	[rsi+16]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mm_type.addrdotindex
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L10298
    mov       rax,	[rsi+24]
    mov       rax,	[rax+16]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    movsxd    r10,	dword [r10 + r11*4]
    sub       rax,	r10
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	rbx
    movsxd    r10,	dword [r10 + r11*4]
    lea       r11,	[mm_decls.ttsize]
    mov       r11d,	[r11 + r10*4]
    imul      rax,	r11
    mov       r10,	r12
    add       [r10],	rax
L10298:
    mov       rax,	rdi
L10295:
    jmp       L10293
L10294:
    xor       eax,	eax
L10293:
    jmp       L10287
L10290:
    xor       eax,	eax
L10287:
L10286:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tevalbinop
mm_type.tevalbinop:
;?>>
   %define R.p r15
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
   %define R.offset r12
   %define R.x XMM15
   %define R.y XMM14
   %define R.z XMM13
   %define R.lhs r13
   %define R.rhs r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
    movq      rax,	XMM13
    push      rax
    movq      rax,	XMM14
    push      rax
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	40
    mov       r15,	rcx
;---------------
    mov       r13,	[r15+16]
    mov       r14,	[r15+24]
    movzx     rax,	byte [r13]
    movzx     r10,	byte [r14]
    cmp       r10,	rax
    jnz       L10302
    cmp       r10,	1
    jz        L10301
L10302:
    movzx     rax,	byte [r13]
    cmp       rax,	55
    jnz       L10304
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jnz       L10304
    mov       rax,	[r13+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L10306
    mov       rax,	[r14+16]
    movsxd    r10,	dword [r13+49]
    lea       r11,	[mm_decls.tttarget]
    movsxd    r11,	dword [r11 + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + r11*4]
    imul      rax,	r10
    mov       r12,	rax
    movzx     rax,	byte [r15+62]
    cmp       rax,	58
    jnz       L10308
    mov       rax,	r12
    neg       rax
    mov       r12,	rax
L10308:
    mov       rax,	[r13+24]
    test      rax,	rax
    jnz       L10310
    mov       rcx,	r12
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [r13+24],	rax
    jmp       L10309
L10310:
    mov       rax,	[r13+24]
    lea       rax,	[rax+16]
    mov       r10,	r12
    add       [rax],	r10
L10309:
    mov       rcx,	r15
    mov       rdx,	r13
    call      mm_lib.deleteunit
L10306:
L10304:
    jmp       L10299
L10301:
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10312
    mov       rax,	[r15+16]
    movq      XMM4,	[rax+16]
    movq      XMM15,	XMM4
    mov       rax,	[r15+24]
    movq      XMM4,	[rax+16]
    movq      XMM14,	XMM4
    jmp       L10311
L10312:
    mov       rax,	[r15+16]
    mov       rdi,	[rax+16]
    mov       rax,	[r15+24]
    mov       rbx,	[rax+16]
L10311:
    movsxd    rax,	dword [r15+49]
    cmp       rax,	3
    jz        L10314
    cmp       rax,	4
    jz        L10314
    cmp       rax,	1
    jz        L10315
    cmp       rax,	2
    jz        L10315
    jmp       L10316
L10314:
    movzx     rax,	byte [r15+62]
    cmp       rax,	43
    jz        L10318
    cmp       rax,	44
    jz        L10319
    cmp       rax,	45
    jz        L10320
    cmp       rax,	47
    jz        L10321
    cmp       rax,	48
    jz        L10322
    cmp       rax,	53
    jz        L10323
    cmp       rax,	50
    jz        L10324
    cmp       rax,	51
    jz        L10325
    cmp       rax,	82
    jz        L10326
    jmp       L10327
L10318:
    mov       rax,	rdi
    add       rax,	rbx
    mov       rsi,	rax
    jmp       L10317
L10319:
    mov       rax,	rdi
    sub       rax,	rbx
    mov       rsi,	rax
    jmp       L10317
L10320:
    mov       rax,	rdi
    imul      rax,	rbx
    mov       rsi,	rax
    jmp       L10317
L10321:
    test      rbx,	rbx
    jnz       L10329
    lea       rcx,	[L13627]
    xor       edx,	edx
    call      mm_support.txerror
L10329:
    mov       rax,	rdi
    mov       r10,	rbx
    cqo       
    idiv      r10
    mov       rsi,	rax
    jmp       L10317
L10322:
    test      rbx,	rbx
    jnz       L10331
    lea       rcx,	[L13628]
    xor       edx,	edx
    call      mm_support.txerror
L10331:
    mov       rax,	rdi
    mov       r10,	rbx
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       rsi,	rax
    jmp       L10317
L10323:
    mov       rax,	rdi
    mov       cl,	bl
    shl       rax,	cl
    mov       rsi,	rax
    jmp       L10317
L10324:
    mov       rax,	rdi
    and       rax,	rbx
    mov       rsi,	rax
    jmp       L10317
L10325:
    mov       rax,	rdi
    or        rax,	rbx
    mov       rsi,	rax
    jmp       L10317
L10326:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      msys.m$power_i64
    mov       rsi,	rax
    jmp       L10317
L10327:
    jmp       L10299
L10317:
    jmp       L10313
L10315:
    movzx     rax,	byte [r15+62]
    cmp       rax,	43
    jz        L10333
    cmp       rax,	44
    jz        L10334
    cmp       rax,	45
    jz        L10335
    cmp       rax,	82
    jz        L10336
    jmp       L10337
L10333:
    movq      XMM4,	XMM15
    addsd     XMM4,	XMM14
    movq      XMM13,	XMM4
    jmp       L10332
L10334:
    movq      XMM4,	XMM15
    subsd     XMM4,	XMM14
    movq      XMM13,	XMM4
    jmp       L10332
L10335:
    movq      XMM4,	XMM15
    mulsd     XMM4,	XMM14
    movq      XMM13,	XMM4
    jmp       L10332
L10336:
    movq      XMM0,	XMM15
    movq      XMM1,	XMM14
    call      pow
    movq      XMM13,	XMM0
    jmp       L10332
L10337:
    jmp       L10299
L10332:
    jmp       L10313
L10316:
    jmp       L10299
L10313:
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10339
    movq      XMM4,	XMM13
    movq      rax,	XMM4
    mov       rcx,	r15
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.makenewconst
    jmp       L10338
L10339:
    mov       rcx,	r15
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.makenewconst
L10338:
L10299:
;---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rcx
    movq      XMM14,	rcx
    pop       rcx
    movq      XMM13,	rcx
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tevalmonop
mm_type.tevalmonop:
;?>>
   %define R.p rsi
   %define R.a rdi
   %define R.c rbx
   %define R.x XMM15
   %define R.z XMM14
    push      rdi
    push      rbx
    push      rsi
    movq      rax,	XMM14
    push      rax
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rax,	[rsi+16]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L10340
L10342:
    mov       rax,	[rsi+16]
    mov       rdi,	[rax+16]
    mov       rax,	[rsi+16]
    movq      XMM4,	[rax+16]
    movq      XMM15,	XMM4
    movsxd    rax,	dword [rsi+49]
    cmp       rax,	3
    jz        L10344
    cmp       rax,	4
    jz        L10344
    cmp       rax,	1
    jz        L10345
    cmp       rax,	2
    jz        L10345
    cmp       rax,	6
    jz        L10346
    jmp       L10347
L10344:
    movzx     rax,	byte [rsi]
    cmp       rax,	18
    jz        L10350
    cmp       rax,	19
    jnz       L10349
L10350:
    jmp       L10351
L10349:
    movzx     rax,	byte [rsi+62]
    cmp       rax,	60
    jz        L10353
    cmp       rax,	63
    jz        L10354
    cmp       rax,	62
    jz        L10355
    cmp       rax,	61
    jz        L10356
    jmp       L10357
L10353:
    mov       rax,	rdi
    neg       rax
    mov       rbx,	rax
    jmp       L10352
L10354:
    mov       rax,	rdi
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L10352
L10355:
    mov       rax,	rdi
    not       rax
    mov       rbx,	rax
    jmp       L10352
L10356:
    mov       rax,	rdi
    cmp       rax,	0
    jge       L13629
    neg       rax
L13629:
    mov       rbx,	rax
    jmp       L10352
L10357:
    jmp       L10340
L10352:
    jmp       L10343
L10345:
    movzx     rax,	byte [rsi+62]
    cmp       rax,	60
    jz        L10359
    cmp       rax,	73
    jz        L10360
    cmp       rax,	67
    jz        L10361
    jmp       L10362
L10359:
    movq      XMM4,	XMM15
    xorpd     XMM4,	[L12280]
    movq      XMM14,	XMM4
    jmp       L10358
L10360:
    movq      XMM0,	XMM15
    call      atan
    movq      XMM14,	XMM0
    jmp       L10358
L10361:
    movq      XMM4,	XMM15
    sqrtsd    XMM4,	XMM4
    movq      XMM14,	XMM4
    jmp       L10358
L10362:
    jmp       L10340
L10358:
    jmp       L10343
L10346:
;mm_type.tevalmonop.dobool:
L10351:
    movzx     rax,	byte [rsi]
    cmp       rax,	18
    jz        L10364
    cmp       rax,	19
    jz        L10365
    jmp       L10366
L10364:
    mov       rax,	rdi
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L10363
L10365:
    mov       rax,	rdi
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L10363
L10366:
    movzx     rax,	byte [rsi+62]
    cmp       rax,	64
    jz        L10368
    cmp       rax,	63
    jz        L10369
    jmp       L10370
L10368:
    mov       rax,	rdi
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L10367
L10369:
    mov       rax,	rdi
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
L10370:
L10367:
L10363:
    jmp       L10343
L10347:
    jmp       L10340
L10343:
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10372
    movq      XMM4,	XMM14
    movq      rax,	XMM4
    mov       rcx,	rsi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.makenewconst
    jmp       L10371
L10372:
    mov       rcx,	rsi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.makenewconst
L10371:
L10340:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rcx
    movq      XMM14,	rcx
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.iscondtrue
mm_type.iscondtrue:
;?>>
   %define R.p rcx
;?]]
;---------------
    movzx     rax,	byte [rcx]
    cmp       rax,	1
    jnz       L10374
    mov       rax,	[rcx+16]
    test      rax,	rax
    jz        L10374
    mov       rax,	1
    jmp       L10375
L10374:
    xor       eax,	eax
L10375:
L10373:
;---------------
    ret       
;End 
;Proc mm_type.iscondfalse
mm_type.iscondfalse:
;?>>
   %define R.p rcx
;?]]
;---------------
    movzx     rax,	byte [rcx]
    cmp       rax,	1
    jnz       L10377
    mov       rax,	[rcx+16]
    test      rax,	rax
    jnz       L10377
    mov       rax,	1
    jmp       L10378
L10377:
    xor       eax,	eax
L10378:
L10376:
;---------------
    ret       
;End 
;Proc mm_type.fixchararray
mm_type.fixchararray:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L10381
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	10
    jnz       L10381
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	12
    jnz       L10381
    mov       rcx,	rdi
    mov       rdx,	20
    xor       r8d,	r8d
    call      mm_type.coerceunit
L10381:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_type.combinestrings
mm_type.combinestrings:
;?>>
    %define mm_type.combinestrings.p 72
   %define R.a rdi
   %define R.b rbx
   %define R.alen rsi
   %define R.blen r12
   %define R.clen r13
   %define R.needterm r14
   %define R.atype r15b
    %define mm_type.combinestrings.btype -8
    %define mm_type.combinestrings.ctype -16
    %define mm_type.combinestrings.s -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mm_type.combinestrings.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_type.combinestrings.p]
    mov       rbx,	[rax+24]
    mov       eax,	[rdi+40]
    mov       rsi,	rax
    mov       eax,	[rbx+40]
    mov       r12,	rax
    mov       r15b,	[rdi+45]
    mov       al,	[rbx+45]
    mov       [rbp + mm_type.combinestrings.btype],	al
    movzx     rax,	r15b
    movzx     r10,	byte [rbp + mm_type.combinestrings.btype]
    cmp       r10,	rax
    jnz       L10384
    cmp       r10,	66
    jnz       L10384
    xor       r14,	r14
    mov       al,	66
    mov       [rbp + mm_type.combinestrings.ctype],	al
    jmp       L10383
L10384:
    movzx     rax,	r15b
    cmp       rax,	66
    jz        L10386
    movzx     rax,	byte [rbp + mm_type.combinestrings.btype]
    cmp       rax,	66
    jnz       L10385
L10386:
    lea       rcx,	[L13630]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L10383
L10385:
    dec       rsi
    dec       r12
    mov       r14,	1
    movzx     rax,	r15b
    cmp       rax,	83
    jz        L10389
    movzx     rax,	byte [rbp + mm_type.combinestrings.btype]
    cmp       rax,	83
    jnz       L10388
L10389:
    mov       al,	83
    mov       [rbp + mm_type.combinestrings.ctype],	al
    jmp       L10387
L10388:
    xor       eax,	eax
    mov       [rbp + mm_type.combinestrings.ctype],	al
L10387:
L10383:
    mov       rax,	rsi
    add       rax,	r12
    mov       r13,	rax
    test      r12,	r12
    jnz       L10391
    mov       rcx,	[rbp + mm_type.combinestrings.p]
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    jmp       L10382
L10391:
    test      rsi,	rsi
    jnz       L10392
    mov       rcx,	[rbp + mm_type.combinestrings.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
    jmp       L10382
L10392:
L10390:
    mov       rax,	r13
    add       rax,	r14
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mm_type.combinestrings.s],	rax
    mov       rax,	[rdi+16]
    mov       rcx,	[rbp + mm_type.combinestrings.s]
    mov       rdx,	rax
    mov       r8,	rsi
    call      memcpy
    mov       rax,	[rbx+16]
    mov       r10,	[rbp + mm_type.combinestrings.s]
    mov       r11,	rsi
    lea       r10,	[r10 + r11]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	r12
    call      memcpy
    test      r14,	r14
    jz        L10394
    xor       eax,	eax
    mov       r10,	[rbp + mm_type.combinestrings.s]
    mov       r11,	r13
    mov       [r10 + r11],	al
L10394:
    mov       rcx,	[rbp + mm_type.combinestrings.p]
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    mov       rax,	r13
    add       rax,	r14
    mov       r10,	[rbp + mm_type.combinestrings.p]
    mov       [r10+40],	eax
    mov       rax,	[rbp + mm_type.combinestrings.s]
    mov       r10,	[rbp + mm_type.combinestrings.p]
    mov       [r10+16],	rax
    mov       al,	r15b
    mov       r10,	[rbp + mm_type.combinestrings.p]
    mov       [r10+45],	al
L10382:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.mulstrings
mm_type.mulstrings:
;?>>
    %define mm_type.mulstrings.p 72
   %define R.a rdi
   %define R.b rbx
   %define R.alen rsi
   %define R.scale r12
   %define R.clen r13
   %define R.needterm r14
   %define R.atype r15b
    %define mm_type.mulstrings.s -8
    %define mm_type.mulstrings.t -16
    %define mm_type.mulstrings.av_1 -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mm_type.mulstrings.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_type.mulstrings.p]
    mov       rbx,	[rax+24]
    mov       eax,	[rdi+40]
    mov       rsi,	rax
    mov       r12,	[rbx+16]
    mov       r15b,	[rdi+45]
    dec       rsi
    mov       r14,	1
    movzx     rax,	r15b
    cmp       rax,	83
    jnz       L10397
    mov       r14,	1
L10397:
    mov       rax,	rsi
    imul      rax,	r12
    mov       r13,	rax
    cmp       r12,	1
    jl        L10400
    cmp       r13,	1
    jl        L10400
    cmp       r13,	100000
    jg        L10400
    cmp       rsi,	1
    jge       L10399
L10400:
    lea       rcx,	[L13631]
    xor       edx,	edx
    call      mm_support.txerror
L10399:
    mov       rax,	r13
    add       rax,	r14
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mm_type.mulstrings.s],	rax
    mov       [rbp + mm_type.mulstrings.t],	rax
    mov       [rbp + mm_type.mulstrings.av_1],	r12
    mov       rax,	[rbp + mm_type.mulstrings.av_1]
    cmp       rax,	0
    jle       L10403
L10401:
    mov       rax,	[rdi+16]
    mov       rcx,	[rbp + mm_type.mulstrings.t]
    mov       rdx,	rax
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rsi
    add       [rbp + mm_type.mulstrings.t],	rax
    dec       qword [rbp + mm_type.mulstrings.av_1]
    jnz       L10401
L10403:
    test      r14,	r14
    jz        L10405
    xor       eax,	eax
    mov       r10,	[rbp + mm_type.mulstrings.s]
    mov       r11,	r13
    mov       [r10 + r11],	al
L10405:
    mov       rcx,	[rbp + mm_type.mulstrings.p]
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    mov       rax,	r13
    add       rax,	r14
    mov       r10,	[rbp + mm_type.mulstrings.p]
    mov       [r10+40],	eax
    mov       rax,	[rbp + mm_type.mulstrings.s]
    mov       r10,	[rbp + mm_type.mulstrings.p]
    mov       [r10+16],	rax
    mov       al,	r15b
    mov       r10,	[rbp + mm_type.mulstrings.p]
    mov       [r10+45],	al
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_strinclude
mm_type.tx_strinclude:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.fileno rdi
   %define R.pf rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [r12]
    cmp       rax,	1
    jnz       L10409
    mov       al,	[r12+44]
    test      al,	al
    jnz       L10408
L10409:
    lea       rcx,	[L13632]
    xor       edx,	edx
    call      mm_support.txerror
L10408:
    movzx     rax,	byte [rsi+57]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    movsx     r10,	word [r10+20]
    mov       rdi,	r10
    lea       rax,	[mm_decls.sources]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+16]
    mov       r10,	[r12+16]
    mov       rcx,	r10
    lea       rdx,	[L13633]
    mov       r8,	rax
    call      mm_support.getsupportfile
    mov       rbx,	rax
    mov       rax,	[rbx+32]
    mov       [r12+16],	rax
    mov       rax,	[rbx+48]
    inc       rax
    mov       [r12+40],	eax
    mov       al,	[rsi+45]
    mov       [r12+45],	al
    movzx     rax,	byte [r12+45]
    cmp       rax,	66
    jnz       L10411
    lea       rax,	[r12+40]
    dec       dword [rax]
L10411:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_lib.deleteunit
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.coerceunit
mm_type.coerceunit:
;?>>
   %define R.p r13
    %define mm_type.coerceunit.t 64
    %define mm_type.coerceunit.hard 72
   %define R.opc rdi
   %define R.s rbx
   %define R.n rsi
   %define R.sbase r12
    %define mm_type.coerceunit.tbase -8
    %define mm_type.coerceunit.starg -16
    %define mm_type.coerceunit.ttarg -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r13,	rcx
    mov       [rbp+64],	rdx
    mov       [rbp+72],	r8
;---------------
    movsxd    rax,	dword [r13+49]
    mov       rbx,	rax
    mov       rax,	[rbp + mm_type.coerceunit.t]
    test      rax,	rax
    jz        L10415
    cmp       rbx,	[rbp + mm_type.coerceunit.t]
    jnz       L10414
L10415:
    jmp       L10412
L10414:
    test      rbx,	rbx
    jnz       L10417
    lea       rcx,	[L13634]
    xor       edx,	edx
    call      mm_support.txerror
L10417:
    cmp       rbx,	[rbp + mm_type.coerceunit.t]
    jz        L10412
L10419:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	[rbp + mm_type.coerceunit.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_type.coerceunit.tbase],	rax
    xor       rdi,	rdi
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_type.coerceunit.starg],	rax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.coerceunit.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_type.coerceunit.ttarg],	rax
    cmp       rbx,	20
    jnz       L10421
    mov       r12,	20
L10421:
    mov       rax,	[rbp + mm_type.coerceunit.t]
    cmp       rax,	20
    jnz       L10423
    mov       rax,	20
    mov       [rbp + mm_type.coerceunit.tbase],	rax
L10423:
    mov       rax,	r12
    cmp       rax,	1
    jl        L10425
    cmp       rax,	5
    jg        L10425
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	1
    jl        L10427
    cmp       rax,	5
    jg        L10427
    lea       rax,	[mm_tables.softconvtable]
    mov       r10,	r12
    shl       r10,	1
    lea       r10,	[r10 + r10*4]
    lea       rax,	[rax + r10-10]
    mov       r10,	[rbp + mm_type.coerceunit.tbase]
    movsx     rax,	word [rax + r10*2-2]
    mov       rdi,	rax
    jmp       L10426
L10427:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	7
    jz        L10429
    cmp       rax,	20
    jnz       L10430
L10429:
    mov       rdi,	7
;mm_type.coerceunit.checkhard:
L10431:
    mov       rax,	[rbp + mm_type.coerceunit.hard]
    test      rax,	rax
    jnz       L10433
    mov       rdi,	9
L10433:
    jmp       L10428
L10430:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	12
    jl        L10435
    cmp       rax,	19
    jg        L10435
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	r12
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10437
    mov       rax,	[rbp + mm_type.coerceunit.hard]
    test      rax,	rax
    jnz       L10439
    mov       rdi,	10
    jmp       L10438
L10439:
    mov       rdi,	3
L10438:
L10437:
    jmp       L10434
L10435:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	6
    jz        L10441
    cmp       rax,	26
    jz        L10442
    jmp       L10443
L10441:
    mov       rdi,	8
    jmp       L10440
L10442:
    mov       rdi,	7
L10443:
L10440:
L10434:
L10428:
L10426:
    jmp       L10424
L10425:
    mov       rax,	r12
    cmp       rax,	6
    jz        L10445
    cmp       rax,	7
    jz        L10446
    cmp       rax,	20
    jz        L10447
    cmp       rax,	10
    jz        L10448
    cmp       rax,	11
    jz        L10449
    cmp       rax,	26
    jz        L10450
    jmp       L10451
L10445:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	3
    jz        L10454
    cmp       rax,	4
    jnz       L10453
L10454:
    mov       rdi,	7
L10453:
    jmp       L10444
L10446:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	3
    jz        L10456
    cmp       rax,	4
    jz        L10456
    cmp       rax,	7
    jz        L10457
    cmp       rax,	20
    jz        L10458
    cmp       rax,	6
    jz        L10459
    jmp       L10460
L10456:
    mov       rdi,	7
    jmp       L10431
L10457:
    mov       rax,	[rbp + mm_type.coerceunit.starg]
    test      rax,	rax
    jz        L10463
    mov       rax,	[rbp + mm_type.coerceunit.ttarg]
    test      rax,	rax
    jnz       L10462
L10463:
    mov       rdi,	7
    jmp       L10461
L10462:
;mm_type.coerceunit.checkref:
L10464:
    mov       rdi,	7
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.coerceunit.t]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10431
L10466:
L10461:
    jmp       L10455
L10458:
    jmp       L10464
L10459:
    mov       rdi,	8
L10460:
L10455:
    jmp       L10444
L10447:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	3
    jz        L10468
    cmp       rax,	4
    jz        L10468
    cmp       rax,	7
    jz        L10469
    cmp       rax,	6
    jz        L10470
    cmp       rax,	11
    jz        L10471
    cmp       rax,	10
    jz        L10472
    jmp       L10473
L10468:
    mov       rdi,	7
    jmp       L10431
L10469:
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.coerceunit.t]
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10476
    mov       rax,	[rbp + mm_type.coerceunit.hard]
    test      rax,	rax
    jz        L10475
L10476:
    mov       rdi,	7
    jmp       L10474
L10475:
    mov       rdi,	9
L10474:
    jmp       L10467
L10470:
    mov       rdi,	8
    jmp       L10467
L10471:
    mov       rax,	[rbp + mm_type.coerceunit.ttarg]
    cmp       rax,	12
    jz        L10479
    cmp       rax,	17
    jnz       L10478
L10479:
    mov       rdi,	11
L10478:
    jmp       L10467
L10472:
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jnz       L10481
    mov       al,	[r13+45]
    test      al,	al
    jz        L10481
    mov       rdi,	7
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	[rbp + mm_type.coerceunit.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L10483
    mov       eax,	[r13+40]
    movsxd    r10,	dword [r13+49]
    lea       r11,	[mm_decls.tttarget]
    movsxd    r11,	dword [r11 + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + r11*4]
    cqo       
    idiv      r10
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	[rbp + mm_type.coerceunit.t]
    mov       [r10 + r11*4],	eax
    mov       eax,	[r13+40]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	[rbp + mm_type.coerceunit.t]
    mov       [r10 + r11*4],	eax
    jmp       L10482
L10483:
    lea       rcx,	[L13635]
    xor       edx,	edx
    call      mm_support.txerror
L10482:
L10481:
L10473:
L10467:
    jmp       L10444
L10448:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	10
    jz        L10485
    cmp       rax,	11
    jz        L10486
    cmp       rax,	20
    jz        L10487
    cmp       rax,	7
    jz        L10488
    jmp       L10489
L10485:
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.coerceunit.t]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10491
    mov       rdi,	7
L10491:
    jmp       L10484
L10486:
    mov       rcx,	[rbp + mm_type.coerceunit.starg]
    mov       rdx,	[rbp + mm_type.coerceunit.ttarg]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10493
    mov       rdi,	12
L10493:
    jmp       L10484
L10487:
    mov       rax,	[rbp + mm_type.coerceunit.starg]
    cmp       rax,	12
    jz        L10496
    cmp       rax,	17
    jnz       L10495
L10496:
    mov       rdi,	13
L10495:
    jmp       L10484
L10488:
    mov       rax,	[rbp + mm_type.coerceunit.ttarg]
    test      rax,	rax
    jnz       L10498
    mov       rdi,	13
L10498:
L10489:
L10484:
    jmp       L10444
L10449:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	11
    jz        L10500
    cmp       rax,	7
    jz        L10501
    jmp       L10502
L10500:
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.coerceunit.t]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10504
    mov       rdi,	7
L10504:
    jmp       L10499
L10501:
    mov       rax,	[rbp + mm_type.coerceunit.ttarg]
    test      rax,	rax
    jz        L10507
    mov       rcx,	[rbp + mm_type.coerceunit.starg]
    mov       rdx,	[rbp + mm_type.coerceunit.ttarg]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10506
L10507:
    lea       rcx,	[L13636]
    xor       edx,	edx
    call      mm_support.gerror
L10506:
L10502:
L10499:
    jmp       L10444
L10450:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	5
    jg        L10509
    mov       rdi,	7
L10509:
L10451:
L10444:
L10424:
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_type.coerceunit.t]
    mov       r9,	rdi
    call      mm_type.applyconversion
L10412:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.applyconversion
mm_type.applyconversion:
;?>>
   %define R.p rdi
   %define R.s rbx
   %define R.t rsi
   %define R.opc r12
    %define mm_type.applyconversion.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rax,	r12
    test      rax,	rax
    jz        L10512
    cmp       rax,	9
    jz        L10513
    cmp       rax,	7
    jz        L10514
    cmp       rax,	10
    jz        L10515
    cmp       rax,	12
    jz        L10516
    cmp       rax,	11
    jz        L10517
    cmp       rax,	13
    jz        L10518
    jmp       L10519
L10512:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.applyconversion.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13637]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.applyconversion.$T1]
    call      mm_support.txerror_ss
    jmp       L10511
L10513:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.applyconversion.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13638]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.applyconversion.$T1]
    call      mm_support.txerror_ss
    jmp       L10511
L10514:
    mov       [rdi+49],	esi
    jmp       L10510
L10515:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_type.tevalconvert
    test      rax,	rax
    jnz       L10510
L10521:
    mov       rcx,	rdi
    mov       rdx,	59
    call      mm_lib.insertunit
    mov       [rdi+49],	esi
    jmp       L10510
L10516:
    mov       rcx,	rdi
    mov       rdx,	48
    call      mm_lib.insertunit
    mov       [rdi+49],	esi
    jmp       L10510
L10517:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_type.tstringslice
    jmp       L10510
L10518:
    mov       rcx,	rdi
    mov       rdx,	56
    call      mm_lib.insertunit
    mov       eax,	20
    mov       [rdi+49],	eax
    jmp       L10510
L10519:
L10511:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_type.tevalconvert
    test      rax,	rax
    jnz       L10510
L10523:
    mov       rcx,	rdi
    mov       rdx,	58
    call      mm_lib.insertunit
    mov       [rdi+62],	r12b
    mov       [rdi+53],	ebx
    mov       al,	1
    mov       [rdi+61],	al
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rsi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10525
    mov       [rdi+53],	esi
    mov       rcx,	rsi
    call      mm_lib.gettypebase
    mov       rsi,	rax
L10525:
    mov       [rdi+49],	esi
L10510:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.checkmodes
mm_type.checkmodes:
;?>>
   %define R.s rdi
   %define R.t rbx
    %define mm_type.checkmodes.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10528
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.checkmodes.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13639]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.checkmodes.$T1]
    call      mm_support.txerror_ss
L10528:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.comparemodes
mm_type.comparemodes:
;?>>
   %define R.s r15
    %define mm_type.comparemodes.t 80
   %define R.sbase rdi
   %define R.tbase rbx
   %define R.starg rsi
   %define R.ttarg r12
   %define R.d r13
   %define R.e r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
;---------------
    cmp       r15,	[rbp + mm_type.comparemodes.t]
    jnz       L10531
    mov       rax,	1
    jmp       L10529
L10531:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r15
    movsxd    rax,	dword [rax + r10*4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	[rbp + mm_type.comparemodes.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r15
    movsxd    rax,	dword [rax + r10*4]
    mov       rsi,	rax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.comparemodes.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    cmp       rdi,	rbx
    jnz       L10533
    mov       rax,	rdi
    cmp       rax,	7
    jz        L10535
    cmp       rax,	10
    jz        L10536
    cmp       rax,	11
    jz        L10537
    cmp       rax,	24
    jz        L10538
    jmp       L10539
L10535:
    test      rsi,	rsi
    jz        L10542
    test      r12,	r12
    jnz       L10541
L10542:
    mov       rax,	1
    jmp       L10529
L10541:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    jmp       L10529
L10536:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10544
    xor       eax,	eax
    jmp       L10529
L10544:
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r15
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	[rbp + mm_type.comparemodes.t]
    movsxd    r10,	dword [r10 + r11*4]
    cmp       rax,	r10
    jz        L10547
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r15
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jz        L10547
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	[rbp + mm_type.comparemodes.t]
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jnz       L10546
L10547:
    mov       rax,	1
    jmp       L10529
L10546:
    jmp       L10534
L10537:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    jmp       L10529
L10538:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r15
    mov       r13,	[rax + r10*8]
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	[rbp + mm_type.comparemodes.t]
    mov       r14,	[rax + r10*8]
    test      r13,	r13
    jz        L10549
    test      r14,	r14
    jz        L10549
    movsxd    rax,	dword [r14+72]
    movsxd    r10,	dword [r13+72]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10551
    xor       eax,	eax
    jmp       L10529
L10551:
    mov       rax,	[r13+112]
    test      rax,	rax
    jnz       L10553
    mov       rax,	[r14+112]
    test      rax,	rax
    jnz       L10553
    mov       rax,	1
    jmp       L10529
L10553:
L10549:
L10539:
L10534:
    jmp       L10532
L10533:
    cmp       rdi,	12
    jnz       L10556
    cmp       rbx,	17
    jz        L10555
L10556:
    cmp       rdi,	17
    jnz       L10554
    cmp       rbx,	12
    jnz       L10554
L10555:
    mov       rax,	1
    jmp       L10529
L10554:
L10532:
    xor       eax,	eax
L10529:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tevalconvert
mm_type.tevalconvert:
;?>>
   %define R.p r13
   %define R.s r14
    %define mm_type.tevalconvert.t 96
    %define mm_type.tevalconvert.opc 104
   %define R.x XMM15
   %define R.z XMM14
   %define R.a rdi
   %define R.c rbx
   %define R.sbase rsi
   %define R.tbase r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    movq      rax,	XMM14
    push      rax
    movq      rax,	XMM15
    push      rax
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+96],	r8
;---------------
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jz        L10559
    xor       eax,	eax
    jmp       L10557
L10559:
    mov       rdi,	[r13+16]
    movq      XMM4,	[r13+16]
    movq      XMM15,	XMM4
    mov       rax,	r14
    shl       rax,	16
    or        rax,	[rbp + mm_type.tevalconvert.t]
    cmp       rax,	196609
    jz        L10561
    cmp       rax,	196610
    jz        L10561
    cmp       rax,	65539
    jz        L10562
    cmp       rax,	65538
    jz        L10563
    cmp       rax,	196625
    jz        L10564
    cmp       rax,	196623
    jz        L10565
    jmp       L10566
L10561:
    mov       rax,	rdi
    cvtsi2sd  XMM4,	rax
    movq      XMM14,	XMM4
    jmp       L10560
L10562:
    movq      XMM4,	XMM15
    cvttsd2si rax,	XMM4
    mov       rbx,	rax
    jmp       L10560
L10563:
    movq      XMM4,	XMM15
    movq      XMM14,	XMM4
    jmp       L10560
L10564:
    mov       al,	dil
    movzx     rax,	al
    mov       rbx,	rax
    jmp       L10560
L10565:
    mov       ax,	di
    movsx     rax,	ax
    mov       rbx,	rax
    jmp       L10560
L10566:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	r14
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10568
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	[rbp + mm_type.tevalconvert.t]
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10568
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	r14
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	[rbp + mm_type.tevalconvert.t]
    mov       r10d,	[r10 + r11*4]
    cmp       rax,	r10
    jnz       L10568
    mov       rbx,	rdi
    jmp       L10567
L10568:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rsi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	[rbp + mm_type.tevalconvert.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    cmp       rsi,	r12
    jnz       L10570
    mov       rax,	1
    jmp       L10557
L10570:
    xor       eax,	eax
    jmp       L10557
L10567:
L10560:
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	[rbp + mm_type.tevalconvert.t]
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10572
    movq      XMM4,	XMM14
    movq      rax,	XMM4
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tevalconvert.t]
    call      mm_type.makenewconst
    jmp       L10571
L10572:
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_type.tevalconvert.t]
    call      mm_type.makenewconst
L10571:
    mov       rax,	1
L10557:
;---------------
    add       rsp,	32
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rcx
    movq      XMM14,	rcx
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_assign
mm_type.tx_assign:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
    %define mm_type.tx_assign.t 88
   %define R.m rdi
   %define R.mm rbx
   %define R.needres rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    mov       rax,	[rbp + mm_type.tx_assign.t]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       rsi,	rax
    movzx     rax,	byte [r13]
    cmp       rax,	20
    jz        L10575
    cmp       rax,	51
    jz        L10576
    cmp       rax,	52
    jz        L10576
    jmp       L10577
L10575:
    movzx     rax,	byte [r14]
    cmp       rax,	20
    jnz       L10579
    test      rsi,	rsi
    jz        L10581
    lea       rcx,	[L13640]
    xor       edx,	edx
    call      mm_support.txerror
L10581:
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	r14
    call      mm_type.tx_assignmultmult
    jmp       L10578
L10579:
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	r14
    mov       r9,	[rbp + mm_type.tx_assign.t]
    call      mm_type.tx_assignmultscalar
L10578:
    jmp       L10573
L10576:
    mov       rax,	[r13+24]
    mov       r10,	[r13+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	1
    call      mm_type.tx_dotindex
    movsxd    rax,	dword [r13+49]
    mov       rcx,	r14
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	3
    mov       [r12+49],	eax
    jmp       L10573
L10577:
L10574:
    movzx     rax,	byte [r13]
    cmp       rax,	4
    jnz       L10583
    mov       rax,	[r13+16]
    movzx     rax,	word [rax+92]
    shr       eax,	4
    and       eax,	1
    test      rax,	rax
    jz        L10583
    mov       al,	[r12+59]
    test      al,	al
    jz        L10583
    mov       rcx,	r13
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10582
L10583:
    mov       rcx,	r13
    mov       rdx,	23
    call      mm_type.tpasslv
L10582:
    movsxd    rax,	dword [r13+49]
    mov       rdi,	rax
    mov       [r13+61],	sil
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	11
    jnz       L10585
    movzx     rax,	byte [r14]
    cmp       rax,	20
    jnz       L10585
    mov       rax,	[r14+16]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	rdi
    call      mm_type.tx_makeslicefromlist
    mov       [r12+49],	edi
    jmp       L10584
L10585:
    movzx     rax,	byte [r14+62]
    cmp       rax,	47
    jz        L10588
    cmp       rax,	48
    jnz       L10587
L10588:
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10586
L10587:
    movzx     rax,	byte [r14]
    cmp       rax,	118
    jnz       L10589
    mov       rcx,	r14
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10586
L10589:
    mov       rbx,	rdi
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10591
    mov       rcx,	rdi
    call      mm_lib.gettypebase
    mov       rbx,	rax
L10591:
    movzx     rax,	byte [r14]
    cmp       rax,	60
    jz        L10593
    cmp       rax,	20
    jz        L10594
    jmp       L10595
L10593:
    mov       rcx,	r14
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10592
L10594:
    mov       rcx,	r14
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10592
L10595:
    mov       rcx,	r14
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.tpass
L10592:
    mov       [r12+49],	ebx
    movzx     rax,	byte [r14]
    cmp       rax,	58
    jnz       L10597
    movzx     rax,	byte [r14+62]
    cmp       rax,	4
    jnz       L10597
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    movsxd    rax,	dword [r14+53]
    lea       r11,	[mm_decls.ttsize]
    mov       r11d,	[r11 + rax*4]
    cmp       r10,	r11
    jg        L10597
    test      rsi,	rsi
    jnz       L10597
    mov       rax,	[r14+16]
    mov       rcx,	r14
    mov       rdx,	rax
    call      mm_lib.deleteunit
L10597:
L10586:
L10584:
L10573:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_assignmultmult
mm_type.tx_assignmultmult:
;?>>
   %define R.pp r13
   %define R.a r14
   %define R.b r15
   %define R.p rdi
   %define R.q rbx
   %define R.lhs rsi
   %define R.rhs r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       al,	29
    mov       [r13],	al
    mov       eax,	[r14+40]
    mov       r10d,	[r15+40]
    cmp       rax,	r10
    jz        L10600
    lea       rcx,	[L13641]
    xor       edx,	edx
    call      mm_support.txerror
L10600:
    mov       eax,	[r14+40]
    test      rax,	rax
    jnz       L10602
    lea       rcx,	[L13642]
    xor       edx,	edx
    call      mm_support.txerror
L10602:
    mov       r12,	[r15+16]
    mov       rsi,	[r14+16]
    mov       rdi,	rsi
    jmp       L10606
L10603:
    mov       rcx,	rdi
    mov       rdx,	23
    call      mm_type.tpasslv
    mov       rdi,	[rdi+8]
L10606:
    test      rdi,	rdi
    jnz       L10603
    mov       rdi,	rsi
    mov       rbx,	r12
    jmp       L10610
L10607:
    movsxd    rax,	dword [rdi+49]
    mov       rcx,	rbx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rdi,	[rdi+8]
    mov       rbx,	[rbx+8]
L10610:
    test      rbx,	rbx
    jnz       L10607
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_assignmultscalar
mm_type.tx_assignmultscalar:
;?>>
   %define R.pp r13
   %define R.a r14
    %define mm_type.tx_assignmultscalar.b 80
    %define mm_type.tx_assignmultscalar.t 88
   %define R.p rdi
   %define R.alist rbx
   %define R.nretmodes rsi
   %define R.i r12
    %define mm_type.tx_assignmultscalar.alength -8
    %define mm_type.tx_assignmultscalar.pmult -16
    %define mm_type.tx_assignmultscalar.d -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rbx,	[r14+16]
    mov       eax,	[r14+40]
    mov       [rbp + mm_type.tx_assignmultscalar.alength],	rax
    xor       rsi,	rsi
    mov       al,	30
    mov       [r13],	al
    mov       rcx,	[rbp + mm_type.tx_assignmultscalar.b]
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	28
    jz        L10613
    cmp       r10,	11
    jz        L10614
    cmp       r10,	9
    jz        L10615
    cmp       r10,	8
    jz        L10616
    jmp       L10617
L10613:
    mov       rcx,	[rbp + mm_type.tx_assignmultscalar.b]
    call      mm_lib.getprocretmodes
    mov       [rbp + mm_type.tx_assignmultscalar.d],	rax
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.d]
    movzx     rax,	byte [rax+122]
    mov       rsi,	rax
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.d]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	28
    jz        L10619
    lea       rcx,	[L13643]
    xor       edx,	edx
    call      mm_support.txerror
L10619:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.alength]
    cmp       rax,	rsi
    jle       L10621
    lea       rcx,	[L13644]
    xor       edx,	edx
    call      mm_support.txerror
L10621:
    cmp       rsi,	1
    jg        L10623
    lea       rcx,	[L13645]
    xor       edx,	edx
    call      mm_support.txerror
L10623:
    mov       rdi,	rbx
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.d]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttmult]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mm_type.tx_assignmultscalar.pmult],	r10
    mov       r12,	1
    jmp       L10627
L10624:
    mov       rax,	r12
    inc       r12
    mov       r10,	[rbp + mm_type.tx_assignmultscalar.pmult]
    movsxd    r10,	dword [r10 + rax*4-4]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mm_type.tpasslv
    mov       rdi,	[rdi+8]
L10627:
    test      rdi,	rdi
    jnz       L10624
    jmp       L10612
L10614:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.alength]
    cmp       rax,	2
    jz        L10629
    lea       rcx,	[L13646]
    xor       edx,	edx
    call      mm_support.txerror
L10629:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    xor       ecx,	ecx
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_type.tpasslv
    mov       rax,	[rbx+8]
    mov       rcx,	rax
    mov       rdx,	3
    call      mm_type.tpasslv
    jmp       L10612
L10615:
    jmp       L10612
L10616:
    jmp       L10612
L10617:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movzx     rax,	byte [rax]
    cmp       rax,	35
    jnz       L10631
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movzx     rax,	byte [rax+62]
    cmp       rax,	49
    jnz       L10631
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.alength]
    cmp       rax,	2
    jz        L10633
    lea       rcx,	[L13647]
    xor       edx,	edx
    call      mm_support.txerror
L10633:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_type.tpasslv
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    mov       r10,	[rbx+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_type.tpasslv
    mov       al,	31
    mov       [r13],	al
    jmp       L10630
L10631:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13648]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10630:
L10612:
    mov       eax,	[rbp + mm_type.tx_assignmultscalar.t]
    mov       [r13+49],	eax
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tpasslv
mm_type.tpasslv:
;?>>
   %define R.p rdi
   %define R.t rbx
    %define mm_type.tpasslv.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	23
    mov       r8,	1
    call      mm_type.tpass
    mov       rax,	rbx
    cmp       rax,	23
    jz        L10636
    test      rax,	rax
    jz        L10636
    movsxd    rax,	dword [rdi+49]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10638
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.tpasslv.$T1],	rax
    movsxd    rax,	dword [rdi+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13649]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tpasslv.$T1]
    call      mm_support.txerror_ss
L10638:
L10636:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.dobinnumx
mm_type.dobinnumx:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
   %define R.amode rdi
   %define R.bmode rbx
   %define R.cmode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    movsxd    rax,	dword [r13+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r14+49]
    mov       rbx,	rax
    cmp       rdi,	5
    jg        L10641
    cmp       rbx,	5
    jg        L10641
    mov       rax,	rdi
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rsi,	rax
    mov       [r12+49],	eax
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10639
L10641:
    cmp       rdi,	5
    jg        L10643
    mov       rax,	rbx
    cmp       rax,	13
    jz        L10644
    cmp       rax,	6
    jnz       L10643
L10644:
    mov       [r12+49],	edi
    mov       rcx,	r14
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10639
L10643:
    mov       rax,	rdi
    cmp       rax,	13
    jz        L10646
    cmp       rax,	6
    jnz       L10645
L10646:
    cmp       rbx,	5
    jg        L10645
    mov       [r12+49],	ebx
    mov       rcx,	r13
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10639
L10645:
L10642:
    xor       eax,	eax
L10639:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.dobinnumf
mm_type.dobinnumf:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
   %define R.amode rdi
   %define R.bmode rbx
   %define R.cmode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    movsxd    rax,	dword [r13+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r14+49]
    mov       rbx,	rax
    cmp       rdi,	2
    jg        L10649
    cmp       rbx,	2
    jg        L10649
    mov       rax,	rdi
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rsi,	rax
    mov       [r12+49],	eax
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10647
L10649:
    xor       eax,	eax
L10647:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.dobinnumi
mm_type.dobinnumi:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
   %define R.amode rdi
   %define R.bmode rbx
   %define R.cmode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    movsxd    rax,	dword [r13+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r14+49]
    mov       rbx,	rax
    mov       rax,	rdi
    cmp       rax,	3
    jz        L10653
    cmp       rax,	4
    jz        L10653
    cmp       rax,	5
    jnz       L10652
L10653:
    mov       rax,	rbx
    cmp       rax,	3
    jz        L10654
    cmp       rax,	4
    jz        L10654
    cmp       rax,	5
    jnz       L10652
L10654:
    mov       rax,	rdi
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rsi,	rax
    mov       [r12+49],	eax
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10650
L10652:
    xor       eax,	eax
L10650:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_in
mm_type.tx_in:
;?>>
   %define R.p r13
   %define R.a r14
   %define R.b r15
   %define R.simpleset rdi
   %define R.amode rbx
   %define R.bmode rsi
   %define R.q r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    mov       rbx,	rax
    movsxd    rax,	dword [r15+49]
    mov       rsi,	rax
    mov       rcx,	r14
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rdi,	1
    movzx     rax,	byte [r15]
    cmp       rax,	22
    jnz       L10657
    mov       r12,	[r15+16]
    jmp       L10661
L10658:
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10663
    xor       rdi,	rdi
    jmp       L10660
L10663:
    mov       r12,	[r12+8]
L10661:
    test      r12,	r12
    jnz       L10658
L10660:
L10657:
    movsxd    rax,	dword [r14+49]
    cmp       rax,	5
    jg        L10665
    movzx     rax,	byte [r15]
    cmp       rax,	21
    jz        L10666
    cmp       rax,	22
    jnz       L10665
L10666:
    test      rdi,	rdi
    jz        L10665
    movzx     rax,	byte [r15]
    cmp       rax,	21
    jnz       L10668
    mov       rax,	43
    jmp       L10667
L10668:
    mov       rax,	44
L10667:
    mov       [r13],	al
    jmp       L10664
L10665:
    lea       rcx,	[L13650]
    xor       edx,	edx
    call      mm_support.txerror
L10664:
    mov       eax,	6
    mov       [r13+49],	eax
    mov       al,	[r13+62]
    test      al,	al
    jz        L10670
    mov       rcx,	r13
    call      mm_type.addnotl
L10670:
    mov       rax,	1
L10655:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msyswin.start
msyswin.start:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.start
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pcl.start
pcl.start:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mc_genss.start
    call      mc_decls.start
    call      mc_writenasm.start
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm.start
mm.start:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_genpcl.start
    call      mm_lex.start
    call      mm_tables.start
;---------------
    add       rsp,	40
    ret       
;End 
    segment .data
$procaddr:
    dq  mc_genmcl.px_nop
    dq  mc_genmcl.px_dupl
    dq  mc_genmcl.px_double
    dq  mc_genmcl.px_opnd
    dq  mc_genmcl.px_type
    dq  mc_genmcl.px_comment
    dq  mc_genmcl.px_proc
    dq  mc_genmcl.px_endproc
    dq  mc_genmcl.px_endprog
    dq  mc_genmcl.px_istatic
    dq  mc_genmcl.px_zstatic
    dq  mc_genmcl.px_data
    dq  mc_genmcl.px_label
    dq  mc_genmcl.px_load
    dq  mc_genmcl.px_store
    dq  mc_genmcl.px_add
    dq  mc_genmcl.px_sub
    dq  mc_genmcl.px_mul
    dq  mc_genmcl.px_div
    dq  mc_genmcl.px_eval
    dq  mc_genmcl.px_widen
    dq  mc_genmcl.px_jump
    dq  mc_genmcl.px_ijump
    dq  mc_genmcl.px_neg
    dq  mc_genmcl.px_abs
    dq  mc_genmcl.px_bitnot
    dq  mc_genmcl.px_not
    dq  mc_genmcl.px_toboolt
    dq  mc_genmcl.px_sqr
    dq  mc_genmcl.px_sqrt
    dq  mc_genmcl.px_jumpcc
    dq  mc_genmcl.px_jumpt
    dq  mc_genmcl.px_jumpf
    dq  mc_genmcl.px_bitand
    dq  mc_genmcl.px_bitor
    dq  mc_genmcl.px_bitxor
    dq  mc_genmcl.px_shl
    dq  mc_genmcl.px_shr
    dq  mc_genmcl.px_retproc
    dq  mc_genmcl.px_retfn
    dq  mc_genmcl.px_setcall
    dq  mc_genmcl.px_setarg
    dq  mc_genmcl.px_callp
    dq  mc_genmcl.px_jumpret
    dq  mc_genmcl.px_jumpretm
    dq  mc_genmcl.px_startmx
    dq  mc_genmcl.px_resetmx
    dq  mc_genmcl.px_stop
    dq  mc_genmcl.px_incrto
    dq  mc_genmcl.px_decrto
    dq  mc_genmcl.px_incrload
    dq  mc_genmcl.px_decrload
    dq  mc_genmcl.px_loadincr
    dq  mc_genmcl.px_loaddecr
    dq  mc_genmcl.px_forup
    dq  mc_genmcl.px_fordown
    dq  mc_genmcl.px_iload
    dq  mc_genmcl.px_iloadx
    dq  mc_genmcl.px_istore
    dq  mc_genmcl.px_istorex
    dq  mc_genmcl.px_storem
    dq  mc_genmcl.px_addpx
    dq  mc_genmcl.px_subpx
    dq  mc_genmcl.px_to
    dq  mc_genmcl.px_iswap
    dq  mc_genmcl.px_swapstk
    dq  mc_genmcl.px_labeldef
    dq  mc_genmcl.px_addto
    dq  mc_genmcl.px_subto
    dq  mc_genmcl.px_multo
    dq  mc_genmcl.px_bitandto
    dq  mc_genmcl.px_bitorto
    dq  mc_genmcl.px_bitxorto
    dq  mc_genmcl.px_shlto
    dq  mc_genmcl.px_shrto
    dq  mc_genmcl.px_fix
    dq  mc_genmcl.px_float
    dq  mc_genmcl.px_idiv
    dq  mc_genmcl.px_irem
    dq  mc_genmcl.px_idivrem
    dq  mc_genmcl.px_clear
    dq  mc_genmcl.px_subp
    dq  mc_genmcl.px_switch
    dq  mc_genmcl.px_switchu
    dq  mc_genmcl.px_swlabel
    dq  mc_genmcl.px_endsw
    dq  mc_genmcl.px_fwiden
    dq  mc_genmcl.px_fnarrow
    dq  mc_genmcl.px_truncate
    dq  mc_genmcl.px_typepun
    dq  mc_genmcl.px_unload
    dq  mc_genmcl.px_loadbit
    dq  mc_genmcl.px_assem
    dq  mc_genmcl.px_sin
    dq  mc_genmcl.px_cos
    dq  mc_genmcl.px_tan
    dq  mc_genmcl.px_asin
    dq  mc_genmcl.px_acos
    dq  mc_genmcl.px_atan
    dq  mc_genmcl.px_log
    dq  mc_genmcl.px_log10
    dq  mc_genmcl.px_exp
    dq  mc_genmcl.px_round
    dq  mc_genmcl.px_floor
    dq  mc_genmcl.px_ceil
    dq  mc_genmcl.px_atan2
    dq  mc_genmcl.px_fmod
    dq  mc_genmcl.px_setcc
    dq  mc_genmcl.px_min
    dq  mc_genmcl.px_max
    dq  mc_genmcl.px_power
    dq  mc_genmcl.px_minto
    dq  mc_genmcl.px_maxto
    dq  mc_genmcl.px_negto
    dq  mc_genmcl.px_absto
    dq  mc_genmcl.px_addpxto
    dq  mc_genmcl.px_subpxto
    dq  mc_genmcl.px_divto
    dq  mc_genmcl.px_bitnotto
    dq  mc_genmcl.px_notto
    dq  mc_genmcl.px_toboolto
    dq  mc_genmcl.px_sign
    dq  mc_genmcl.px_loadbf
    dq  mc_genmcl.px_storebit
    dq  mc_genmcl.px_storebf
    dq  mc_genmcl.px_loadall
    dq  mc_genmcl.px_setjmp
    dq  mc_genmcl.px_longjmp
    dq  mc_genmcl.px_initdswx
    dq  mc_auxmcl.do_addrmode
$procname:
    dq  L13651
    dq  L13652
    dq  L13653
    dq  L13654
    dq  L13655
    dq  L13656
    dq  L13657
    dq  L13658
    dq  L13659
    dq  L13660
    dq  L13661
    dq  L13662
    dq  L13663
    dq  L13664
    dq  L13665
    dq  L13666
    dq  L13667
    dq  L13668
    dq  L13669
    dq  L13670
    dq  L13671
    dq  L13672
    dq  L13673
    dq  L13674
    dq  L13675
    dq  L13676
    dq  L13677
    dq  L13678
    dq  L13679
    dq  L13680
    dq  L13681
    dq  L13682
    dq  L13683
    dq  L13684
    dq  L13685
    dq  L13686
    dq  L13687
    dq  L13688
    dq  L13689
    dq  L13690
    dq  L13691
    dq  L13692
    dq  L13693
    dq  L13694
    dq  L13695
    dq  L13696
    dq  L13697
    dq  L13698
    dq  L13699
    dq  L13700
    dq  L13701
    dq  L13702
    dq  L13703
    dq  L13704
    dq  L13705
    dq  L13706
    dq  L13707
    dq  L13708
    dq  L13709
    dq  L13710
    dq  L13711
    dq  L13712
    dq  L13713
    dq  L13714
    dq  L13715
    dq  L13716
    dq  L13717
    dq  L13718
    dq  L13719
    dq  L13720
    dq  L13721
    dq  L13722
    dq  L13723
    dq  L13724
    dq  L13725
    dq  L13726
    dq  L13727
    dq  L13728
    dq  L13729
    dq  L13730
    dq  L13731
    dq  L13732
    dq  L13733
    dq  L13734
    dq  L13735
    dq  L13736
    dq  L13737
    dq  L13738
    dq  L13739
    dq  L13740
    dq  L13741
    dq  L13742
    dq  L13743
    dq  L13744
    dq  L13745
    dq  L13746
    dq  L13747
    dq  L13748
    dq  L13749
    dq  L13750
    dq  L13751
    dq  L13752
    dq  L13753
    dq  L13754
    dq  L13755
    dq  L13756
    dq  L13757
    dq  L13758
    dq  L13759
    dq  L13760
    dq  L13761
    dq  L13762
    dq  L13763
    dq  L13764
    dq  L13765
    dq  L13766
    dq  L13767
    dq  L13768
    dq  L13769
    dq  L13770
    dq  L13771
    dq  L13772
    dq  L13773
    dq  L13774
    dq  L13775
    dq  L13776
    dq  L13777
    dq  L13778
    dq  L13779
    dq  L13780
$nprocs:
    dq  0x82
;Real Table
    align     8
L13363:
    dq  0x7FF0000000000000
L13362:
    dq  3.14159265358979310000
L13158:
    dq  10.00000000000000000000
L13157:
    dq  10.00000000000000000000
L13154:
    dq  10.00000000000000000000
L13153:
    dq  0.00000000000000000000
L13107:
    dq  100.00000000000000000000
L12387:
    dq  0x7FF0000000000000
L12385:
    dq  0x7FF0000000000000
L12368:
    dq  0.00000000000000000000
L12186:
    dq  0x7FF0000000000000
L12114:
    dq  9223372036854775800.00000000000000000000
L12113:
    dq  1.00000000000000000000
L12112:
    dq  9223372036854775800.00000000000000000000
L12090:
    dq  0.00000000000000000000
L12089:
    dq  1.00000000000000000000
L12088:
    dq  0.00000000000000000000
L12087:
    dq  -1.00000000000000000000
L12086:
    dq  0.00000000000000000000
L12083:
    dq  0.00000000000000000000
L12081:
    dq  0.00000000000000000000
;Real32 Table
    align     16
;lababs64
L12281:
    dq  0x7FFFFFFFFFFFFFFF
    dq  0x7FFFFFFFFFFFFFFF
;labneg64
L12280:
    dq  0x8000000000000000
    dq  0x8000000000000000
;mask63/offset64
L12289:
    dq  0x7FFFFFFFFFFFFFFF
L12290:
    dq  0x43E0000000000000
;String Table
    align     8
L13780:
    db        "do_addrmode"
    db        0
L13779:
    db        "px_initdswx"
    db        0
L13778:
    db        "px_longjmp"
    db        0
L13777:
    db        "px_setjmp"
    db        0
L13776:
    db        "px_loadall"
    db        0
L13775:
    db        "px_storebf"
    db        0
L13774:
    db        "px_storebit"
    db        0
L13773:
    db        "px_loadbf"
    db        0
L13772:
    db        "px_sign"
    db        0
L13771:
    db        "px_toboolto"
    db        0
L13770:
    db        "px_notto"
    db        0
L13769:
    db        "px_bitnotto"
    db        0
L13768:
    db        "px_divto"
    db        0
L13767:
    db        "px_subpxto"
    db        0
L13766:
    db        "px_addpxto"
    db        0
L13765:
    db        "px_absto"
    db        0
L13764:
    db        "px_negto"
    db        0
L13763:
    db        "px_maxto"
    db        0
L13762:
    db        "px_minto"
    db        0
L13761:
    db        "px_power"
    db        0
L13760:
    db        "px_max"
    db        0
L13759:
    db        "px_min"
    db        0
L13758:
    db        "px_setcc"
    db        0
L13757:
    db        "px_fmod"
    db        0
L13756:
    db        "px_atan2"
    db        0
L13755:
    db        "px_ceil"
    db        0
L13754:
    db        "px_floor"
    db        0
L13753:
    db        "px_round"
    db        0
L13752:
    db        "px_exp"
    db        0
L13751:
    db        "px_log10"
    db        0
L13750:
    db        "px_log"
    db        0
L13749:
    db        "px_atan"
    db        0
L13748:
    db        "px_acos"
    db        0
L13747:
    db        "px_asin"
    db        0
L13746:
    db        "px_tan"
    db        0
L13745:
    db        "px_cos"
    db        0
L13744:
    db        "px_sin"
    db        0
L13743:
    db        "px_assem"
    db        0
L13742:
    db        "px_loadbit"
    db        0
L13741:
    db        "px_unload"
    db        0
L13740:
    db        "px_typepun"
    db        0
L13739:
    db        "px_truncate"
    db        0
L13738:
    db        "px_fnarrow"
    db        0
L13737:
    db        "px_fwiden"
    db        0
L13736:
    db        "px_endsw"
    db        0
L13735:
    db        "px_swlabel"
    db        0
L13734:
    db        "px_switchu"
    db        0
L13733:
    db        "px_switch"
    db        0
L13732:
    db        "px_subp"
    db        0
L13731:
    db        "px_clear"
    db        0
L13730:
    db        "px_idivrem"
    db        0
L13729:
    db        "px_irem"
    db        0
L13728:
    db        "px_idiv"
    db        0
L13727:
    db        "px_float"
    db        0
L13726:
    db        "px_fix"
    db        0
L13725:
    db        "px_shrto"
    db        0
L13724:
    db        "px_shlto"
    db        0
L13723:
    db        "px_bitxorto"
    db        0
L13722:
    db        "px_bitorto"
    db        0
L13721:
    db        "px_bitandto"
    db        0
L13720:
    db        "px_multo"
    db        0
L13719:
    db        "px_subto"
    db        0
L13718:
    db        "px_addto"
    db        0
L13717:
    db        "px_labeldef"
    db        0
L13716:
    db        "px_swapstk"
    db        0
L13715:
    db        "px_iswap"
    db        0
L13714:
    db        "px_to"
    db        0
L13713:
    db        "px_subpx"
    db        0
L13712:
    db        "px_addpx"
    db        0
L13711:
    db        "px_storem"
    db        0
L13710:
    db        "px_istorex"
    db        0
L13709:
    db        "px_istore"
    db        0
L13708:
    db        "px_iloadx"
    db        0
L13707:
    db        "px_iload"
    db        0
L13706:
    db        "px_fordown"
    db        0
L13705:
    db        "px_forup"
    db        0
L13704:
    db        "px_loaddecr"
    db        0
L13703:
    db        "px_loadincr"
    db        0
L13702:
    db        "px_decrload"
    db        0
L13701:
    db        "px_incrload"
    db        0
L13700:
    db        "px_decrto"
    db        0
L13699:
    db        "px_incrto"
    db        0
L13698:
    db        "px_stop"
    db        0
L13697:
    db        "px_resetmx"
    db        0
L13696:
    db        "px_startmx"
    db        0
L13695:
    db        "px_jumpretm"
    db        0
L13694:
    db        "px_jumpret"
    db        0
L13693:
    db        "px_callp"
    db        0
L13692:
    db        "px_setarg"
    db        0
L13691:
    db        "px_setcall"
    db        0
L13690:
    db        "px_retfn"
    db        0
L13689:
    db        "px_retproc"
    db        0
L13688:
    db        "px_shr"
    db        0
L13687:
    db        "px_shl"
    db        0
L13686:
    db        "px_bitxor"
    db        0
L13685:
    db        "px_bitor"
    db        0
L13684:
    db        "px_bitand"
    db        0
L13683:
    db        "px_jumpf"
    db        0
L13682:
    db        "px_jumpt"
    db        0
L13681:
    db        "px_jumpcc"
    db        0
L13680:
    db        "px_sqrt"
    db        0
L13679:
    db        "px_sqr"
    db        0
L13678:
    db        "px_toboolt"
    db        0
L13677:
    db        "px_not"
    db        0
L13676:
    db        "px_bitnot"
    db        0
L13675:
    db        "px_abs"
    db        0
L13674:
    db        "px_neg"
    db        0
L13673:
    db        "px_ijump"
    db        0
L13672:
    db        "px_jump"
    db        0
L13671:
    db        "px_widen"
    db        0
L13670:
    db        "px_eval"
    db        0
L13669:
    db        "px_div"
    db        0
L13668:
    db        "px_mul"
    db        0
L13667:
    db        "px_sub"
    db        0
L13666:
    db        "px_add"
    db        0
L13665:
    db        "px_store"
    db        0
L13664:
    db        "px_load"
    db        0
L13663:
    db        "px_label"
    db        0
L13662:
    db        "px_data"
    db        0
L13661:
    db        "px_zstatic"
    db        0
L13660:
    db        "px_istatic"
    db        0
L13659:
    db        "px_endprog"
    db        0
L13658:
    db        "px_endproc"
    db        0
L13657:
    db        "px_proc"
    db        0
L13656:
    db        "px_comment"
    db        0
L13655:
    db        "px_type"
    db        0
L13654:
    db        "px_opnd"
    db        0
L13653:
    db        "px_double"
    db        0
L13652:
    db        "px_dupl"
    db        0
L13651:
    db        "px_nop"
    db        0
L13650:
    db        "doin"
    db        0
L13649:
    db        "PassLV type mismatch: #:=#"
    db        0
L13648:
    db        "Can't expand to mult values:"
    db        0
L13647:
    db        "(a,b):=divrem"
    db        0
L13646:
    db        "(a,b):=slice"
    db        0
L13645:
    db        "mult ass rhs needs fn yielding 2+ values"
    db        0
L13644:
    db        "mult ass/mult returns don't agree in number"
    db        0
L13643:
    db        "Not a tuple"
    db        0
L13642:
    db        "Invalid assignment"
    db        0
L13641:
    db        "Mult assign: count mismatch"
    db        0
L13640:
    db        "Mult assign has no result"
    db        0
L13639:
    db        "Type-compare error: # <-> #"
    db        0
L13638:
    db        "Need explicit cast: # => #"
    db        0
L13637:
    db        "Can't do conversion: # => #"
    db        0
L13636:
    db        "COERCE/SLICEPTR"
    db        0
L13635:
    db        "Array not empty"
    db        0
L13634:
    db        "Void expression/return value missing"
    db        0
L13633:
    db        0
L13632:
    db        "strincl/not string"
    db        0
L13631:
    db        "mulstr"
    db        0
L13630:
    db        "Mixed str+bin strings"
    db        0
L13628:
    db        "x rem 0"
    db        0
L13627:
    db        "x/0"
    db        0
L13626:
    db        "Not slice"
    db        0
L13625:
    db        "lwb/upb/len?"
    db        0
L13624:
    db        "Can't resolve method:"
    db        0
L13623:
    db        "BITFIELD"
    db        0
L13622:
    db        "Can't assign"
    db        0
L13621:
    db        "Int/ref needed"
    db        0
L13620:
    db        "Not char slice"
    db        0
L13619:
    db        "widen? #"
    db        0
L13618:
    db        "*"
    db        0
L13617:
    db        "a[i..j]: not array"
    db        0
L13616:
    db        "STRMODE(A.MODE)="
    db        0
L13615:
    db        "a.[i]: not int/str value"
    db        0
L13614:
    db        "SHORT RET TYPE"
    db        0
L13613:
    db        "RETERROR?"
    db        0
L13612:
    db        "Wrong number of return values"
    db        0
L13611:
    db        "return constructor not supported"
    db        0
L13610:
    db        "Superfluous return value"
    db        0
L13609:
    db        "return value(s) missing"
    db        0
L13608:
    db        "&. ref[] expected"
    db        0
L13607:
    db        "switch needs else"
    db        0
L13606:
    db        "Switch value: not const int"
    db        0
L13605:
    db        "Duplicate switch value"
    db        0
L13604:
    db        "switch: value out of range"
    db        0
L13603:
    db        "Switch not constant"
    db        0
L13602:
    db        "*"
    db        0
L13601:
    db        "not ref"
    db        0
L13600:
    db        "&doswitch"
    db        0
L13599:
    db        "goto: not label"
    db        0
L13598:
    db        "exit/etc not const"
    db        0
L13597:
    db        "Invalid type-punning; only real<->int"
    db        0
L13596:
    db        "TYPEPUN/LIST"
    db        0
L13595:
    db        "case needs else"
    db        0
L13594:
    db        "CASE/BOOL?"
    db        0
L13593:
    db        "case: need int index"
    db        0
L13592:
    db        "&docase"
    db        0
L13591:
    db        "SWAP: type mismatch"
    db        0
L13590:
    db        "SLICEPTR #"
    db        0
L13589:
    db        "Not a field: #"
    db        0
L13588:
    db        "4:record expected"
    db        0
L13587:
    db        "3:record expected"
    db        0
L13586:
    db        "Bad record type"
    db        0
L13585:
    db        "MKSLICE2"
    db        0
L13584:
    db        "slice/ptr mismatch"
    db        0
L13583:
    db        "slice init not ref"
    db        0
L13582:
    db        "MAKESLICE/TX"
    db        0
L13581:
    db        "MAKESLICE FROM LIST NOT READY"
    db        0
L13580:
    db        "MAKESLICE/TX"
    db        0
L13578:
    db        "Unknown makelist type: #"
    db        0
L13577:
    db        "TSLICE"
    db        0
L13576:
    db        "Can't initialise unions"
    db        0
L13575:
    db        "Too many elements"
    db        0
L13574:
    db        "Too few elements"
    db        0
L13573:
    db        "Bit fields overflow type"
    db        0
L13572:
    db        "srs:too many fields"
    db        0
L13571:
    db        "Recursive record?"
    db        0
L13570:
    db        "PTR: need ref T"
    db        0
L13569:
    db        "DEREF SLICE"
    db        0
L13568:
    db        "Deref Void"
    db        0
L13567:
    db        "Can't index: #"
    db        0
L13566:
    db        "forall/can't iterate"
    db        0
L13565:
    db        "Loop index not a variable"
    db        0
L13564:
    db        "IF/LV2?"
    db        0
L13563:
    db        "else needed"
    db        0
L13562:
    db        "IF/LV?"
    db        0
L13561:
    db        "Not int"
    db        0
L13560:
    db        "PROP"
    db        0
L13559:
    db        "Can't do maxvalue on #"
    db        0
L13558:
    db        "Can't do minvalue on #"
    db        0
L13557:
    db        "TTT"
    db        0
L13556:
    db        "toboolt"
    db        0
L13555:
    db        "not num"
    db        0
L13554:
    db        "&param: type mismatch"
    db        0
L13553:
    db        "Param not optional: #"
    db        0
L13552:
    db        "Too many params supplied"
    db        0
L13551:
    db        "NPARAMS="
    db        0
L13550:
    db        "K="
    db        0
L13549:
    db        "Normal param follows kwd"
    db        0
L13548:
    db        "Kwd: # already used or was implicit"
    db        0
L13547:
    db        "Can't find kwd param: #"
    db        0
L13546:
    db        "Param overflow"
    db        0
L13545:
    db        "Function expected"
    db        0
L13544:
    db        "Function pointer expected"
    db        0
L13543:
    db        "Can't do ifx/function"
    db        0
L13542:
    db        "Param overflow"
    db        0
L13541:
    db        "Getdom: no dominant mode"
    db        0
L13540:
    db        "BIN: modes not compatible: # #"
    db        0
L13539:
    db        "to:ref+ref"
    db        0
L13538:
    db        "BIN/CAN'T RESOLVE MODES"
    db        0
L13537:
    db        "txbin?"
    db        0
L13536:
    db        "Cmp ref/ref not compat"
    db        0
L13535:
    db        "ref-ref: not compat"
    db        0
L13534:
    db        "TNAME? # #"
    db        0
L13533:
    db        "Can't init dllvar"
    db        0
L13532:
    db        "Module name can't be used on it's own: #"
    db        0
L13531:
    db        "Can't use 'let' as lvalue: "
    db        0
L13530:
    db        "&const"
    db        0
L13529:
    db        "Getconstint: not i32/64"
    db        0
L13528:
    db        "Getconstexpr: not const"
    db        0
L13527:
    db        "*"
    db        0
L13526:
    db        "JTAGNAMES[P.TAG]="
    db        0
L13525:
    db        "Bad const type"
    db        0
L13524:
    db        "Circular const reference detected"
    db        0
L13523:
    db        "@name needed"
    db        0
L13522:
    db        "Circular reference detected"
    db        0
L13521:
    db        "Neg length"
    db        0
L13520:
    db        "Can't set mode size"
    db        0
L13519:
    db        "STDNAMES[TTBASETYPE[M]]="
    db        0
L13518:
    db        "M="
    db        0
L13517:
    db        "SIZE 0:"
    db        0
L13516:
    db        "SETMODESIZE/AUTO?"
    db        0
L13515:
    db        "TXUNIT: CAN'T DO:"
    db        0
L13514:
    db        "Clear scalar?"
    db        0
L13513:
    db        "sys: too many args"
    db        0
L13512:
    db        "sys: arg missing"
    db        0
L13511:
    db        "recase must be const"
    db        0
L13510:
    db        "repeat/const cond"
    db        0
L13509:
    db        "cast() needs type"
    db        0
L13508:
    db        "TX looping detected"
    db        0
L13507:
    db        "q"
    db        0
L13506:
    db        "10jlq"
    db        0
L13505:
    db        "Import "
    db        0
L13504:
    db        "Export"
    db        0
L13503:
    db        "Program"
    db        0
L13502:
    db        "Subprog"
    db        0
L13501:
    db        "Module"
    db        0
L13500:
    db        "5"
    db        0
L13499:
    db        "10jl"
    db        0
L13498:
    db        "dllprocid"
    db        0
L13497:
    db        "dllfuncid"
    db        0
L13496:
    db        "procid"
    db        0
L13495:
    db        "funcid"
    db        0
L13494:
    db        "18jl"
    db        0
L13493:
    db        "12jl"
    db        0
L13492:
    db        "10jl"
    db        0
L13491:
    db        "q"
    db        0
L13490:
    db        "16jl"
    db        0
L13489:
    db        "Writing"
    db        0
L13488:
    db        "wb"
    db        0
L13487:
    db        "proj"
    db        0
L13486:
    db        "Writing"
    db        0
L13485:
    db        "wb"
    db        0
L13484:
    db        "list"
    db        0
L13483:
    db        "=== END ==="
    db        0
L13482:
    db        "=== # # # #/# ==="
    db        0
L13481:
    db        "=== MA # ==="
    db        0
L13480:
    db        "Writing "
    db        0
L13479:
    db        0
L13478:
    db        "Can't create MA file "
    db        0
L13477:
    db        "wb"
    db        0
L13476:
    db        0
L13475:
    db        "MA: no files"
    db        0
L13474:
    db        "ma"
    db        0
L13473:
    db        "No file no"
    db        0
L13472:
    db        "Found:"
    db        0
L13471:
    db        0
L13470:
    db        "Can't find file: "
    db        0
L13469:
    db        "Checkfile:"
    db        0
L13468:
    db        "Get file:# (ext:#) (path:#)"
    db        0
L13467:
    db        " "
    db        0
L13466:
    db        "Stopping"
    db        0
L13465:
    db        "Load Error:"
    db        0
L13464:
    db        "****"
    db        0
L13463:
    db        "**** Lex Error:"
    db        0
L13462:
    db        "in file"
    db        0
L13461:
    db        "On line"
    db        0
L13460:
    db        "AX Code Gen Error: "
    db        0
L13459:
    db        "GX Code Gen Error: "
    db        0
L13458:
    db        "TX Type Error: "
    db        0
L13457:
    db        "RX Name Error: "
    db        0
L13456:
    db        "GETFILENO(POS)="
    db        0
L13455:
    db        "MMPOS"
    db        0
L13454:
    db        "P.POS"
    db        0
L13453:
    db        "PRESS key"
    db        0
L13452:
    db        "w"
    db        0
L13451:
    db        "$error.tmp"
    db        0
L13450:
    db        "^"
    db        0
L13449:
    db        " "
    db        0
L13448:
    db        "    Module:   # (#)"
    db        0
L13447:
    db        "    Function: #()"
    db        0
L13446:
    db        "    Line:     #"
    db        0
L13445:
    db        "Syntax Error:"
    db        0
L13444:
    db        "MC Error:"
    db        0
L13443:
    db        0
L13442:
    db        "Too many sources"
    db        0
L13441:
    db        "Empty sunit"
    db        0
L13440:
    db        "Readsunit: "
    db        34
    db        ";"
    db        34
    db        " expected, or bad unit starter"
    db        0
L13439:
    db        "Possibly var/let needed"
    db        0
L13438:
    db        "Unexpected EOF in proc"
    db        0
L13437:
    db        "macro def params"
    db        0
L13436:
    db        "readterm?"
    db        0
L13435:
    db        "LX.SYMBOL="
    db        0
L13434:
    db        "{...} not ready"
    db        0
L13433:
    db        "[$] No array"
    db        0
L13432:
    db        "Params not allowed"
    db        0
L13431:
    db        "Char const too long"
    db        0
L13430:
    db        "X{...} not ready"
    db        0
L13429:
    db        "cmpchain: Too many items"
    db        0
L13428:
    db        "AND:="
    db        0
L13427:
    db        "OR:="
    db        0
L13426:
    db        "dict: mixed elements"
    db        0
L13425:
    db        "readset?"
    db        0
L13424:
    db        "Too many return values"
    db        0
L13423:
    db        "Too many nested proc"
    db        0
L13422:
    db        "proc can't have ret value"
    db        0
L13421:
    db        "Proc can't return value"
    db        0
L13420:
    db        "Function needs return type"
    db        0
L13419:
    db        "Can't find @ field"
    db        0
L13418:
    db        "Not allowed in importmodule"
    db        0
L13417:
    db        "symbol"
    db        0
L13416:
    db        "Too many dll procs"
    db        0
L13415:
    db        "nested importdll"
    db        0
L13414:
    db        "LB?"
    db        0
L13413:
    db        "Let not allowed"
    db        0
L13412:
    db        "Empty union group"
    db        0
L13411:
    db        "Class eof?"
    db        0
L13410:
    db        "No table data"
    db        0
L13409:
    db        "enum=x, 1st row only"
    db        0
L13408:
    db        "tabledata:too many rows"
    db        0
L13407:
    db        "tabledata/too many columns"
    db        0
L13406:
    db        "Use 'enumdata'"
    db        0
L13405:
    db        "No fields declared"
    db        0
L13404:
    db        "Offset>255"
    db        0
L13403:
    db        "Name expected"
    db        0
L13402:
    db        "for i,x?"
    db        0
L13401:
    db        "Re-using nested loop index"
    db        0
L13400:
    db        "Too many for-loops"
    db        0
L13399:
    db        "No read items"
    db        0
L13398:
    db        "@ on read"
    db        0
L13397:
    db        "No fmt str"
    db        0
L13396:
    db        "No print items"
    db        0
L13395:
    db        "="
    db        0
L13394:
    db        "all"
    db        0
L13393:
    db        "switch expr missing"
    db        0
L13392:
    db        "then: not allowed"
    db        0
L13391:
    db        "nameparams1"
    db        0
L13390:
    db        "Type expected"
    db        0
L13389:
    db        "Wrong 'main/start' sig"
    db        0
L13388:
    db        "More than one main() in SP"
    db        0
L13387:
    db        "main"
    db        0
L13386:
    db        "start"
    db        0
L13385:
    db        "READPROCDEF @"
    db        0
L13384:
    db        "Proc can't return value"
    db        0
L13383:
    db        "Function needs ret type"
    db        0
L13382:
    db        0
L13381:
    db        "Can't do complex expr"
    db        0
L13380:
    db        "Unknown dot suffix"
    db        0
L13379:
    db        "RDS:TYPEOF"
    db        0
L13378:
    db        "Too many nested a[$]"
    db        0
L13377:
    db        "SLIST?"
    db        0
L13376:
    db        "null comma expr not allowed"
    db        0
L13375:
    db        "Bad type starter"
    db        0
L13374:
    db        "Top-level union not allowed"
    db        0
L13373:
    db        "Use 'record name =' syntax"
    db        0
L13372:
    db        "Too many array dims"
    db        0
L13371:
    db        "# expected, not #"
    db        0
L13370:
    db        "@ type missing"
    db        0
L13369:
    db        "compiler var not impl: #"
    db        0
L13368:
    db        "Compiler:M6.4"
    db        0
L13367:
    db        "z2"
    db        0
L13366:
    db        "#:#:#"
    db        0
L13365:
    db        "4"
    db        0
L13364:
    db        "#-#-#"
    db        0
L13361:
    db        "Too many opnds"
    db        0
L13360:
    db        "op:= not available"
    db        0
L13359:
    db        "Can't be used as unary op"
    db        0
L13358:
    db        "READOPC/SINGLE OPND?"
    db        0
L13357:
    db        "Needs (x,y)"
    db        0
L13356:
    db        "(x ..."
    db        0
L13355:
    db        ",, null expr not allowed"
    db        0
L13354:
    db        "No consts declared"
    db        0
L13353:
    db        "No vars declared"
    db        0
L13352:
    db        "let needs :=/="
    db        0
L13351:
    db        "let@"
    db        0
L13350:
    db        "Need 'static' for '='"
    db        0
L13349:
    db        "Can't use := for statics inside procs"
    db        0
L13348:
    db        "Non-variants can't use :="
    db        0
L13347:
    db        "Readvar?"
    db        0
L13346:
    db        " (from line #)"
    db        0
L13345:
    db        "Mismatched end "
    db        0
L13344:
    db        "'End' expected"
    db        0
L13343:
    db        34
    db        "="
    db        34
    db        " expected"
    db        0
L13342:
    db        0
L13341:
    db        "Code outside a function"
    db        0
L13340:
    db        "MODULE/DOT"
    db        0
L13339:
    db        "global global?"
    db        0
L13338:
    db        "DUPLFIELD"
    db        0
L13337:
    db        "Too many macro args"
    db        0
L13336:
    db        "Too few macro args"
    db        0
L13335:
    db        "NMACROARGS="
    db        0
L13334:
    db        "macro arg overflow"
    db        0
L13333:
    db        "macro param overflow"
    db        0
L13332:
    db        "Too many macro levels (recursive macro?)"
    db        0
L13329:
    db        "Fixtypes: too many passes (cyclic ref?)"
    db        0
L13328:
    db        9
    db        0
L13327:
    db        "Type phase errors - check these user types:"
    db        0
L13326:
    db        "2:Can't resolve tentative type: #"
    db        0
L13325:
    db        "Not a field: #"
    db        0
L13324:
    db        "Can't resolve sub.#"
    db        0
L13323:
    db        "Need export to import '#'"
    db        0
L13322:
    db        "Not a field: #"
    db        0
L13321:
    db        "Record expected"
    db        0
L13320:
    db        "2:Record expected"
    db        0
L13319:
    db        "Can't resolve .#"
    db        0
L13318:
    db        "Need global to import '#'"
    db        0
L13317:
    db        "Need export to import '#'"
    db        0
L13316:
    db        "pcl:Undefined: #"
    db        0
L13315:
    db        "Ambiguous ext name: #"
    db        0
L13314:
    db        "mclib"
    db        0
L13313:
    db        0
L13312:
    db        "MA error"
    db        0
L13311:
    db        0
L13310:
    db        "Too many files in MA"
    db        0
L13309:
    db        "end"
    db        0
L13308:
    db        0
L13307:
    db        "Unexpected EOF in MA file"
    db        0
L13306:
    db        0
L13305:
    db        "MA: bad header"
    db        0
L13304:
    db        "ma"
    db        0
L13303:
    db        0
L13302:
    db        "Can't find MA file "
    db        0
L13301:
    db        "kernel32"
    db        0
L13300:
    db        "gdi32"
    db        0
L13299:
    db        "user32"
    db        0
L13298:
    db        "msvcrt"
    db        0
L13297:
    db        "m"
    db        0
L13296:
    db        "LOADING FROM MA FILE"
    db        0
L13295:
    db        "ma"
    db        0
L13294:
    db        ".m"
    db        0
L13293:
    db        "SYSLIBNAME="
    db        0
L13292:
    db        "msyslinc"
    db        0
L13291:
    db        "msyswin"
    db        0
L13290:
    db        "msyswini"
    db        0
L13289:
    db        "msyswinc"
    db        0
L13288:
    db        "msysmin"
    db        0
L13287:
    db        "msysminc"
    db        0
L13286:
    db        "C:/mx/"
    db        0
L13285:
    db        0
L13284:
    db        "Too many libs"
    db        0
L13283:
    db        "m"
    db        0
L13282:
    db        "."
    db        0
L13281:
    db        "Dupl mod name:"
    db        0
L13280:
    db        0
L13279:
    db        "Can't load: "
    db        0
L13278:
    db        0
L13277:
    db        "Too many modules"
    db        0
L13276:
    db        0
L13275:
    db        "Too many subprogs"
    db        0
L13274:
    db        0
L13273:
    db        "Importing self"
    db        0
L13272:
    db        0
L13271:
    db        "Hdr cmd not ready"
    db        0
L13270:
    db        0
L13269:
    db        "Too many imports in header"
    db        0
L13268:
    db        "as"
    db        0
L13267:
    db        0
L13266:
    db        "Too many modules in header"
    db        0
L13265:
    db        0
L13264:
    db        "Subprog already loaded: "
    db        0
L13263:
    db        0
L13262:
    db        "Can't load lead module: "
    db        0
L13261:
    db        "m"
    db        0
L13260:
    db        0
L13259:
    db        "multass/need multfn"
    db        0
L13258:
    db        "ATL ERROR"
    db        0
L13257:
    db        "rb"
    db        0
L13256:
    db        "w"
    db        0
L13255:
    db        "PMODE=NIL"
    db        0
L13254:
    db        "GETALIGN SIZE NOT 1248"
    db        0
L13253:
    db        "."
    db        0
L13251:
    db        "NEWSTRMODE"
    db        0
L13250:
    db        "Alias for:"
    db        0
L13249:
    db        "bitfield"
    db        0
L13248:
    db        ")"
    db        0
L13247:
    db        ","
    db        0
L13246:
    db        "Tuple("
    db        0
L13245:
    db        ")"
    db        0
L13244:
    db        " "
    db        0
L13243:
    db        ","
    db        0
L13242:
    db        "proc("
    db        0
L13241:
    db        "void"
    db        0
L13240:
    db        ")"
    db        0
L13239:
    db        " "
    db        0
L13238:
    db        ","
    db        0
L13237:
    db        "("
    db        0
L13236:
    db        0
L13235:
    db        "#[#:]"
    db        0
L13234:
    db        "[]"
    db        0
L13233:
    db        "@#[#:]"
    db        0
L13232:
    db        "[#:]"
    db        0
L13231:
    db        "[]"
    db        0
L13230:
    db        "[#..#]"
    db        0
L13229:
    db        "[#]"
    db        0
L13228:
    db        "@[#<#>"
    db        0
L13227:
    db        "ref "
    db        0
L13226:
    db        "."
    db        0
L13225:
    db        "*"
    db        0
L13224:
    db        "CAN'T DO JEVAL"
    db        0
L13223:
    db        "strinclude "
    db        0
L13222:
    db        "incr "
    db        0
L13221:
    db        ")"
    db        0
L13220:
    db        "("
    db        0
L13219:
    db        ":"
    db        0
L13218:
    db        "."
    db        0
L13217:
    db        "$"
    db        0
L13216:
    db        ")"
    db        0
L13215:
    db        "TYPESTR("
    db        0
L13214:
    db        "&."
    db        0
L13213:
    db        "+"
    db        0
L13212:
    db        "&"
    db        0
L13211:
    db        "<nullunit>"
    db        0
L13210:
    db        "<JBLOCK>"
    db        0
L13209:
    db        "^"
    db        0
L13208:
    db        "-"
    db        0
L13207:
    db        ":"
    db        0
L13206:
    db        ")"
    db        0
L13205:
    db        "cast("
    db        0
L13204:
    db        ")"
    db        0
L13203:
    db        "shorten("
    db        0
L13202:
    db        ")"
    db        0
L13201:
    db        "("
    db        0
L13200:
    db        "@"
    db        0
L13199:
    db        ")"
    db        0
L13198:
    db        "|"
    db        0
L13197:
    db        "("
    db        0
L13196:
    db        ":="
    db        0
L13195:
    db        ")"
    db        0
L13194:
    db        ".."
    db        0
L13193:
    db        "("
    db        0
L13192:
    db        ")"
    db        0
L13191:
    db        ","
    db        0
L13190:
    db        "("
    db        0
L13189:
    db        "."
    db        0
L13188:
    db        "]"
    db        0
L13187:
    db        "["
    db        0
L13186:
    db        "."
    db        0
L13185:
    db        ")"
    db        0
L13184:
    db        ","
    db        0
L13183:
    db        "("
    db        0
L13182:
    db        ")"
    db        0
L13181:
    db        "("
    db        0
L13180:
    db        ")"
    db        0
L13179:
    db        "("
    db        0
L13178:
    db        ")"
    db        0
L13177:
    db        "("
    db        0
L13176:
    db        "<EVAL/CONST PROBABLY VOID>"
    db        0
L13175:
    db        34
    db        0
L13174:
    db        "LONGSTR)"
    db        0
L13173:
    db        "Uflags overflow/c"
    db        0
L13172:
    db        "Uflags overflow/a"
    db        0
L13171:
    db        "sv_"
    db        0
L13170:
    db        "av_"
    db        0
L13169:
    db        "Auto frame not in proc"
    db        0
L13168:
    db        "."
    db        0
L13167:
    db        "$T"
    db        0
L13166:
    db        "CREATEARRAYMODEK/TARGET NOT RESOLVED"
    db        0
L13165:
    db        "Too many types"
    db        0
L13164:
    db        "Too many type names"
    db        0
L13161:
    db        "Duplicate name"
    db        0
L13160:
    db        "in"
    db        0
L13159:
    db        "Decimal not ready"
    db        0
L13152:
    db        "r64lit too long"
    db        0
L13151:
    db        "expon?"
    db        0
L13150:
    db        "double expon"
    db        0
L13149:
    db        "bin overflow"
    db        0
L13148:
    db        "bin bad digit"
    db        0
L13147:
    db        "MAKEDEC"
    db        0
L13146:
    db        "Numlit too long"
    db        0
L13145:
    db        "bad bin digit"
    db        0
L13144:
    db        "bin overflow"
    db        0
L13143:
    db        "Bad hex digit"
    db        0
L13142:
    db        0
L13141:
    db        "String not terminated"
    db        0
L13140:
    db        "Unknown string escape: "
    db        92
    db        "%s"
    db        0
L13139:
    db        "Bad ` name"
    db        0
L13138:
    db        "Include file/macro overflow"
    db        0
L13137:
    db        9
    db        0
L13136:
    db        ": "
    db        0
L13135:
    db        "PS:"
    db        0
L13134:
    db        0
L13133:
    db        "m"
    db        0
L13132:
    db        "include: string expected"
    db        0
L13131:
    db        "Hashtable:"
    db        0
L13130:
    db        "SYS:HASHTABLE FULL"
    db        0
L13129:
    db        "Lex dupl name:"
    db        0
L13128:
    db        "HASHTABLE FULL"
    db        0
L13127:
    db        "Raw string not terminated"
    db        0
L13126:
    db        ".*"
    db        0
L13125:
    db        "v"
    db        0
L13124:
    db        "Unknown char"
    db        0
L13123:
    db        ".123 not done"
    db        0
L13122:
    db        92
    db        " not followed by eol"
    db        0
L13121:
    db        "Bad base"
    db        0
L13120:
    db        "Unit suffix after float not implem"
    db        0
L13119:
    db        "Can't do this unit index"
    db        0
L13118:
    db        "Total:"
    db        0
L13117:
    db        "-----------------------------"
    db        0
L13116:
    db        "EXE:"
    db        0
L13115:
    db        "SS:"
    db        0
L13114:
    db        "MCL:"
    db        0
L13113:
    db        "PCL:"
    db        0
L13112:
    db        "Type:"
    db        0
L13111:
    db        "Resolve:"
    db        0
L13110:
    db        "Parse:"
    db        0
L13109:
    db        "Load:"
    db        0
L13108:
    db        "5.1jr"
    db        0
L13106:
    db        "5"
    db        0
L13105:
    db        "12jl"
    db        0
L13104:
    db        "# # ms # %"
    db        0
L13103:
    db        "LX.FILENO="
    db        0
L13102:
    db        "SUBCODE:"
    db        0
L13101:
    db        "'"
    db        0
L13100:
    db        34
    db        0
L13099:
    db        "word"
    db        0
L13098:
    db        "int"
    db        0
L13097:
    db        " [#]"
    db        0
L13096:
    db        "%-18s"
    db        0
L13095:
    db        0
L13094:
    db        "PROC"
    db        0
L13093:
    db        "w"
    db        0
L13092:
    db        "End"
    db        10
    db        0
L13091:
    db        "20jl"
    db        0
L13090:
    db        "#"
    db        9
    db        "#.# (#) Mod:"
    db        0
L13089:
    db        "DLL Proc List:"
    db        0
L13088:
    db        "End"
    db        10
    db        0
L13087:
    db        "20jl"
    db        0
L13086:
    db        "#"
    db        9
    db        "#.# (#) Mod:"
    db        0
L13085:
    db        "Proc List:"
    db        0
L13084:
    db        "PROC"
    db        0
L13083:
    db        "mx.log"
    db        0
L13082:
    db        "Diagnostic outputs written to"
    db        0
L13081:
    db        "mm.m"
    db        0
L13080:
    db        "mx.log"
    db        0
L13079:
    db        92
    db        "m"
    db        92
    db        "ed.bat "
    db        0
L13078:
    db        "PRESS KEY..."
    db        0
L13077:
    db        "FLAT SYMBOL TABLE"
    db        0
L13076:
    db        "SYMBOL TABLE"
    db        0
L13075:
    db        "AST1"
    db        0
L13074:
    db        "AST2"
    db        0
L13073:
    db        "AST3"
    db        0
L13072:
    db        "PSYMTAB"
    db        0
L13071:
    db        "pcl"
    db        0
L13070:
    db        "asm"
    db        0
L13069:
    db        "PROC ASSEMBLY"
    db        0
L13068:
    db        "w"
    db        0
L13067:
    db        "mx.log"
    db        0
L13066:
    db        "16jl"
    db        0
L13065:
    db        "Link files"
    db        0
L13064:
    db        "7"
    db        0
L13063:
    db        "30jl"
    db        0
L13062:
    db        "20jl"
    db        0
L13061:
    db        "jl18"
    db        0
L13060:
    db        "jl16"
    db        0
L13059:
    db        "2"
    db        0
L13058:
    db        "  #:  Name=# File=# Path=# Spec=# Size=#"
    db        0
L13057:
    db        "Sourcefiles"
    db        0
L13056:
    db        ")"
    db        0
L13055:
    db        "("
    db        0
L13054:
    db        "Sys:"
    db        0
L13053:
    db        "MAINSUBPROGNO="
    db        0
L13052:
    db        "Subprograms"
    db        0
L13051:
    db        ":"
    db        0
L13050:
    db        " Alias:"
    db        0
L13049:
    db        "Fileno:"
    db        0
L13048:
    db        "Sub:"
    db        0
L13047:
    db        "Sys:"
    db        0
L13046:
    db        "16jl"
    db        0
L13045:
    db        "2"
    db        0
L13044:
    db        "  "
    db        0
L13043:
    db        "m "
    db        0
L13042:
    db        "h "
    db        0
L13041:
    db        "hm"
    db        0
L13040:
    db        "Modules"
    db        0
L13039:
    db        "---------------------------------------"
    db        0
L13038:
    db        "Project Structure:"
    db        0
L13037:
    db        "Isblock:"
    db        0
L13036:
    db        "Isref:"
    db        0
L13035:
    db        "Isshort:"
    db        0
L13034:
    db        "Isinteger:"
    db        0
L13033:
    db        "Isreal:"
    db        0
L13032:
    db        "Signed:"
    db        0
L13031:
    db        " "
    db        0
L13030:
    db        "Mult:"
    db        0
L13029:
    db        "# Bounds: #..#  Length:#"
    db        0
L13028:
    db        "Sizeset"
    db        0
L13027:
    db        "Size:"
    db        0
L13026:
    db        "Target:"
    db        0
L13025:
    db        "-"
    db        0
L13024:
    db        "ttnamedef:"
    db        0
L13023:
    db        "ttname:"
    db        0
L13022:
    db        "Basetype:"
    db        0
L13021:
    db        "4"
    db        0
L13020:
    db        "MODELIST"
    db        0
L13019:
    db        "z4"
    db        0
L13018:
    db        "Z2"
    db        0
L13017:
    db        "# # "
    db        0
L13016:
    db        " "
    db        0
L13015:
    db        "-----------------------------"
    db        0
L13014:
    db        "---"
    db        0
L13013:
    db        "RES"
    db        0
L13012:
    db        "# #:#"
    db        0
L13011:
    db        "S"
    db        0
L13010:
    db        "E"
    db        0
L13009:
    db        "S"
    db        0
L13008:
    db        "- "
    db        0
L13007:
    db        " Pclcond<#>"
    db        0
L13006:
    db        " Conv<#>"
    db        0
L13005:
    db        " Prop<#>"
    db        0
L13004:
    db        " no-op"
    db        0
L13003:
    db        " Pcl<#>"
    db        0
L13002:
    db        " Not const"
    db        0
L13001:
    db        " Is const"
    db        0
L13000:
    db        " "
    db        0
L12999:
    db        "#"
    db        0
L12998:
    db        "Offset:"
    db        0
L12997:
    db        " Makeax:"
    db        0
L12996:
    db        "Len:"
    db        0
L12995:
    db        " Convmode:"
    db        0
L12994:
    db        "Len:"
    db        0
L12993:
    db        " *L"
    db        0
L12992:
    db        " <isstr>(#)"
    db        0
L12991:
    db        " "
    db        0
L12990:
    db        "<PRINTUNIT BAD CONST PROBABLY VOID"
    db        0
L12989:
    db        "TYPENAME(T)="
    db        0
L12988:
    db        "P.SLENGTH="
    db        0
L12987:
    db        "P.STRTYPE="
    db        0
L12986:
    db        "<ARRAY>"
    db        0
L12985:
    db        "False"
    db        0
L12984:
    db        "True"
    db        0
L12983:
    db        "NIL"
    db        0
L12982:
    db        "#"
    db        0
L12981:
    db        34
    db        34
    db        0
L12980:
    db        34
    db        " *"
    db        0
L12979:
    db        34
    db        0
L12978:
    db        34
    db        " *"
    db        0
L12977:
    db        "(LONGSTR)"
    db        0
L12976:
    db        34
    db        0
L12975:
    db        "P.INDEX="
    db        0
L12974:
    db        " AV:"
    db        0
L12973:
    db        " Moduleno:"
    db        0
L12972:
    db        " Addroffirst."
    db        0
L12971:
    db        " Lastcall:"
    db        0
L12970:
    db        0
L12969:
    db        " {Dotted}"
    db        0
L12968:
    db        " "
    db        0
L12967:
    db        "}"
    db        0
L12966:
    db        " {"
    db        0
L12965:
    db        ": "
    db        0
L12964:
    db        ":"
    db        0
L12963:
    db        "1"
    db        0
L12962:
    db        " in record"
    db        0
L12961:
    db        "Mod"
    db        0
L12960:
    db        "Exp"
    db        0
L12959:
    db        "Prog"
    db        0
L12958:
    db        "Sub"
    db        0
L12957:
    db        "="
    db        0
L12956:
    db        " (From #:#)"
    db        0
L12955:
    db        ":"
    db        0
L12954:
    db        "     "
    db        0
L12953:
    db        ":"
    db        0
L12952:
    db        "5"
    db        0
L12951:
    db        "GLOBAL SYMBOL TABLE:"
    db        0
L12950:
    db        "*"
    db        0
L12949:
    db        " Lineno: ???"
    db        0
L12948:
    db        " +"
    db        0
L12947:
    db        " @"
    db        0
L12946:
    db        "<HAS BASECLASS>"
    db        0
L12945:
    db        "Baseclass:"
    db        0
L12944:
    db        "Const:"
    db        0
L12943:
    db        ":="
    db        0
L12942:
    db        "="
    db        0
L12941:
    db        " Truename:"
    db        0
L12940:
    db        "Index/PCaddr:"
    db        0
L12939:
    db        " Nret:"
    db        0
L12938:
    db        "Index:"
    db        0
L12937:
    db        "..."
    db        0
L12936:
    db        "/:="
    db        0
L12935:
    db        "-"
    db        0
L12934:
    db        " UFLAGS:"
    db        0
L12933:
    db        ".*"
    db        0
L12932:
    db        "v"
    db        0
L12931:
    db        "%.*s"
    db        0
L12930:
    db        ":"
    db        0
L12929:
    db        " Bitoffset:"
    db        0
L12928:
    db        " Offset:"
    db        0
L12927:
    db        " "
    db        0
L12926:
    db        ":"
    db        0
L12925:
    db        "Void "
    db        0
L12924:
    db        "()"
    db        0
L12923:
    db        "(#)"
    db        0
L12922:
    db        "]"
    db        0
L12921:
    db        "Threaded "
    db        0
L12920:
    db        "U "
    db        0
L12919:
    db        "Subno#"
    db        0
L12918:
    db        "Modno#"
    db        0
L12917:
    db        " "
    db        0
L12916:
    db        "Var:"
    db        0
L12915:
    db        "Opt "
    db        0
L12914:
    db        " "
    db        0
L12913:
    db        " maxalign:"
    db        0
L12912:
    db        "@@"
    db        0
L12911:
    db        "Stat"
    db        0
L12910:
    db        " "
    db        0
L12909:
    db        "Imp "
    db        0
L12908:
    db        "["
    db        0
L12906:
    db        ":"
    db        0
L12905:
    db        "    "
    db        0
L12904:
    db        " "
    db        0
L12903:
    db        "FIXASMLABEL: zero"
    db        0
L12902:
    db        "genasmopnd?"
    db        0
L12901:
    db        "ax:imm/add"
    db        0
L12900:
    db        "Can't do memexpr"
    db        0
L12899:
    db        0
L12898:
    db        "ASSEM/SYSFN?"
    db        0
L12897:
    db        "-name"
    db        0
L12896:
    db        0
L12895:
    db        "assume/unary"
    db        0
L12894:
    db        "pcmpistr/no imm"
    db        0
L12893:
    db        "ASM: Bad operand?"
    db        0
L12892:
    db        "BAD OPND"
    db        0
L12891:
    db        "Empty []"
    db        0
L12890:
    db        "Bad scale"
    db        0
L12889:
    db        "Bad prefix"
    db        0
L12888:
    db        "Too many asm opnds"
    db        0
L12887:
    db        "ASM???"
    db        0
L12886:
    db        "ASM"
    db        0
L12885:
    db        "x64 op expected"
    db        0
L12884:
    db        "ASM"
    db        0
L12883:
    db        "EOF: 'End' missing in Assembler code"
    db        0
L12882:
    db        "recase outside case stmt"
    db        0
L12881:
    db        "Bad mult assign element"
    db        0
L12880:
    db        "(a,b):=x; var only"
    db        0
L12879:
    db        "DECONSTR SLICE NOT READY"
    db        0
L12878:
    db        "multassign from fn: not simple fn"
    db        0
L12877:
    db        "Assignment not suitable for []char type"
    db        0
L12876:
    db        "ASSIGN BLOCK"
    db        0
L12875:
    db        "SYSCALL/GENERIC"
    db        0
L12874:
    db        "rd@dev?"
    db        0
L12873:
    db        "@dev no ref"
    db        0
L12872:
    db        "CAN'T READ THIS ITEM"
    db        0
L12871:
    db        "STRMODE(M)="
    db        0
L12870:
    db        "too many cases"
    db        0
L12869:
    db        "case"
    db        0
L12868:
    db        "case nested too deeply"
    db        0
L12867:
    db        "EMPTY CASE NOT DONE"
    db        0
L12866:
    db        "selectx: too many labels"
    db        0
L12865:
    db        "J3"
    db        0
L12864:
    db        "J2"
    db        0
L12863:
    db        "J1"
    db        0
L12862:
    db        "doswx in main?"
    db        0
L12861:
    db        "doswx not ref"
    db        0
L12860:
    db        "doswx not name"
    db        0
L12859:
    db        "Switch too big"
    db        0
L12858:
    db        "Switch when2: not const: #"
    db        0
L12857:
    db        "CONV/ERROR"
    db        0
L12856:
    db        "Bad for-step"
    db        0
L12855:
    db        "for/step non-const not ready"
    db        0
L12854:
    db        "Possibly using &param as for-loop limit"
    db        0
L12853:
    db        "PRINT/T=#"
    db        0
L12852:
    db        "PRINTSLICE"
    db        0
L12851:
    db        "PRINTRECORD"
    db        0
L12850:
    db        "PRINTARRAY"
    db        0
L12849:
    db        "string expected"
    db        0
L12848:
    db        "@dev?"
    db        0
L12847:
    db        "@dev no ref"
    db        0
L12846:
    db        "Mixed stack args"
    db        0
L12845:
    db        "maxparams"
    db        0
L12844:
    db        "call/not ptr"
    db        0
L12843:
    db        "Mult?"
    db        0
L12842:
    db        "Bad exit/loop index"
    db        0
L12841:
    db        "Can't assign"
    db        0
L12840:
    db        "Assign to proc?"
    db        0
L12839:
    db        "ASS/SLICE"
    db        0
L12838:
    db        "do_const"
    db        0
L12837:
    db        "1:B-str?"
    db        0
L12836:
    db        "Unimplemented: #"
    db        0
L12835:
    db        "jumpt/f"
    db        0
L12834:
    db        "empty set"
    db        0
L12833:
    db        "evalref"
    db        0
L12832:
    db        "*"
    db        0
L12831:
    db        "NOT ALLOWED BY ITSELF:"
    db        0
L12830:
    db        "*"
    db        0
L12829:
    db        "UNSUPPORTED TAG "
    db        0
L12828:
    db        " "
    db        0
L12827:
    db        "geteqv"
    db        0
L12826:
    db        "."
    db        0
L12825:
    db        "$procaddr"
    db        0
L12824:
    db        "$procname"
    db        0
L12823:
    db        "$nprocs"
    db        0
L12822:
    db        "PCL proctab overflow"
    db        0
L12821:
    db        "------------------------"
    db        0
L12820:
    db        "No m$unimpl"
    db        0
L12819:
    db        "Sysfn not found:"
    db        0
L12818:
    db        "m$"
    db        0
L12817:
    db        "Bad loop index"
    db        0
L12816:
    db        "Too many nested loops"
    db        0
L12815:
    db        "IDATA: "
    db        0
L12814:
    db        "Idata &frameXXX"
    db        0
L12813:
    db        "IDATA/ARRAY/NOT BLOCKDATA"
    db        0
L12812:
    db        "1:B-str?"
    db        0
L12811:
    db        "$cmdskip"
    db        0
L12810:
    db        "------------------------"
    db        0
L12809:
    db        0
L12808:
    db        "start"
    db        0
L12807:
    db        "dll"
    db        0
L12806:
    db        "M Compiler for 64-bit Windows"
    db        10
    db        10
    db        "Normal use:           Compiles lead module prog.m to:"
    db        10
    db        10
    db        "    mm      prog      prog.exe (default)"
    db        10
    db        "    mm -r   prog      in-memory native code then execute"
    db        10
    db        "    mm -i   prog      in-memory IL then interpret"
    db        10
    db        10
    db        "    mm -exe prog      prog.exe"
    db        10
    db        "    mm -dll prog      prog.dll"
    db        10
    db        "    mm -obj prog      prog.obj"
    db        10
    db        "    mm -a   prog      prog.asm"
    db        10
    db        "    mm -n   prog      prog.nasm"
    db        10
    db        "    mm -mx  prog      prog.mx"
    db        10
    db        "    mm -p   prog      prog.pcl (textual IL)"
    db        10
    db        "    mm -ma   prog     prog.ma (single amalgamated source file)"
    db        10
    db        10
    db        "Other options:"
    db        10
    db        10
    db        "    -ext              Used std headers external to compiler"
    db        10
    db        "    -opt              Optimise native code"
    db        10
    db        "    -out:file         Name output file (extension can be added)"
    db        10
    db        "    -rip              Use RIP address modes"
    db        10
    db        "    -himem            Generate PIC code (automatic with -obj/-dll)"
    db        10
    db        "    @file             Read files and options from a file"
    db        10
    db        0
L12805:
    db        "11:46:20"
    db        0
L12804:
    db        "21-Jul-2025"
    db        0
L12803:
    db        "M Compiler [M7.1]"
    db        0
L12802:
    db        0
L12801:
    db        "Path needs to end with "
    db        92
    db        " or /"
    db        0
L12800:
    db        0
L12799:
    db        "mixed out/path"
    db        0
L12798:
    db        0
L12797:
    db        "mixed out/path"
    db        0
L12796:
    db        0
L12795:
    db        "dupl debug option"
    db        0
L12794:
    db        0
L12793:
    db        "dupl prod option:"
    db        0
L12792:
    db        "New dest="
    db        0
L12791:
    db        "2.m"
    db        0
L12790:
    db        " -h           Show all options"
    db        0
L12789:
    db        "   "
    db        0
L12788:
    db        " prog[.m]  Compile prog.m to prog.exe"
    db        0
L12787:
    db        "   "
    db        0
L12786:
    db        "Usage:"
    db        0
L12785:
    db        "exe"
    db        0
L12784:
    db        "m"
    db        0
L12783:
    db        0
L12782:
    db        "Invalid params"
    db        0
L12781:
    db        0
L12780:
    db        "Lib files go in module headers"
    db        0
L12779:
    db        0
L12778:
    db        "Specify one lead module only"
    db        0
L12777:
    db        "Unknown option:"
    db        0
L12776:
    db        0
L12775:
    db        "ms.exe"
    db        0
L12774:
    db        "PSYMTAB"
    db        0
L12773:
    db        "$prog"
    db        0
L12772:
    db        "PROGRAM"
    db        0
L12771:
    db        "PSYMTAB"
    db        0
L12770:
    db        "asm"
    db        0
L12769:
    db        "PSYMTAB"
    db        0
L12768:
    db        "pcl"
    db        0
L12767:
    db        "AST3"
    db        0
L12766:
    db        "AST2"
    db        0
L12765:
    db        "AST1"
    db        0
L12764:
    db        "Compiling # to #"
    db        0
L12763:
    db        "mx"
    db        0
L12762:
    db        "dll"
    db        0
L12761:
    db        "exe"
    db        0
L12760:
    db        "obj"
    db        0
L12759:
    db        "Finished."
    db        0
L12758:
    db        "reloc?"
    db        0
L12757:
    db        "rel32/rel not imported"
    db        0
L12756:
    db        "0.1234"
    db        0
L12755:
    db        0
L12754:
    db        "No entry point found"
    db        0
L12753:
    db        "$cmdskip"
    db        0
L12752:
    db        "msys.$cmdskip"
    db        0
L12751:
    db        0
L12750:
    db        "Too many Imports"
    db        0
L12749:
    db        0
L12748:
    db        "Too many DLLs"
    db        0
L12747:
    db        "Dupl symbol:"
    db        0
L12746:
    db        "Can't find #"
    db        0
L12745:
    db        "ml"
    db        0
L12744:
    db        "Loading sublib"
    db        0
L12743:
    db        0
L12742:
    db        "imprel32?"
    db        0
L12741:
    db        "Undef"
    db        0
L12740:
    db        "Can't find DLL: #"
    db        0
L12739:
    db        0
L12738:
    db        "Too many libs"
    db        0
L12737:
    db        "Lib already exists:"
    db        0
L12736:
    db        "Aborting"
    db        0
L12735:
    db        0
L12734:
    db        "Can't alloc code memory"
    db        0
L12733:
    db        "Unknown directive:"
    db        0
L12732:
    db        "Bad sig - not MCX file"
    db        0
L12730:
    db        "NO MAIN FOUND"
    db        0
L12729:
    db        "reloc?"
    db        0
L12728:
    db        "rel32/rel not imported"
    db        0
L12727:
    db        "0.1234"
    db        0
L12725:
    db        "W:too many strings"
    db        0
L12724:
    db        ".text"
    db        0
L12723:
    db        ".data"
    db        0
L12722:
    db        ".bss"
    db        0
L12721:
    db        ".file"
    db        0
L12720:
    db        "as:Too many symbols"
    db        0
L12719:
    db        "OBJ/phighmem 1?"
    db        0
L12718:
    db        "wrelocs/bad seg"
    db        0
L12717:
    db        "Writing file:"
    db        0
L12716:
    db        ".text"
    db        0
L12715:
    db        ".data"
    db        0
L12714:
    db        "Too many relocs (exceeds 16-bit field)"
    db        0
L12713:
    db        ".bss"
    db        0
L12712:
    db        "GSN"
    db        0
L12711:
    db        "Too many blocks"
    db        0
L12709:
    db        "Too many exports - can't sort"
    db        0
L12708:
    db        "Entry point not found: main"
    db        0
L12707:
    db        "User entry point not found"
    db        0
L12705:
    db        "Can't do this rel type"
    db        0
L12704:
    db        "RELOCDATA/SEG?"
    db        0
L12703:
    db        "rel32/not imported"
    db        0
L12702:
    db        "gendll: Too many exports"
    db        0
L12701:
    db        "genexe: Too many imports"
    db        0
L12700:
    db        "2:Too many libs"
    db        0
L12699:
    db        ".dll"
    db        0
L12698:
    db        "Can't find external function"
    db        0
L12697:
    db        "Too many libs"
    db        0
L12696:
    db        ".dll"
    db        0
L12695:
    db        ".idata"
    db        0
L12694:
    db        ".bss"
    db        0
L12693:
    db        ".data"
    db        0
L12692:
    db        "10s,jr"
    db        0
L12691:
    db        "Zdata size:"
    db        0
L12690:
    db        "10s,jr"
    db        0
L12689:
    db        "Code+Idata:"
    db        0
L12688:
    db        "10s,jr"
    db        0
L12687:
    db        "Idata size:"
    db        0
L12686:
    db        "bytes"
    db        0
L12685:
    db        "10s,jr"
    db        0
L12684:
    db        "Code size: "
    db        0
L12683:
    db        ".text"
    db        0
L12682:
    db        "Can't load search lib"
    db        0
L12681:
    db        "File:"
    db        0
L12680:
    db        "Error writing exe file (possibly still running)"
    db        0
L12679:
    db        "10s,jr"
    db        0
L12678:
    db        "EXE size:  "
    db        0
L12677:
    db        0
L12676:
    db        "qword "
    db        0
L12675:
    db        "dword "
    db        0
L12674:
    db        "word "
    db        0
L12673:
    db        "byte "
    db        0
L12672:
    db        0
L12671:
    db        "#.$T#"
    db        0
L12670:
    db        "T"
    db        0
L12669:
    db        "R"
    db        0
L12668:
    db        "#.#"
    db        0
L12667:
    db        "XMM"
    db        0
L12666:
    db        "-"
    db        0
L12665:
    db        0
L12664:
    db        "Stropnd?"
    db        0
L12663:
    db        "L"
    db        0
L12662:
    db        34
    db        0
L12661:
    db        "M"
    db        0
L12660:
    db        "20.20"
    db        0
L12659:
    db        0
L12658:
    db        "+"
    db        0
L12657:
    db        0
L12656:
    db        "<BAD OPND>"
    db        0
L12655:
    db        "BAD OPND"
    db        0
L12654:
    db        "]"
    db        0
L12653:
    db        " + "
    db        0
L12652:
    db        "*"
    db        0
L12651:
    db        " + "
    db        0
L12650:
    db        0
L12649:
    db        "["
    db        0
L12648:
    db        "M#"
    db        0
L12647:
    db        "H"
    db        0
L12646:
    db        "0x"
    db        0
L12645:
    db        ","
    db        0
L12644:
    db        ","
    db        9
    db        0
L12643:
    db        " "
    db        0
L12642:
    db        "  "
    db        0
L12641:
    db        " "
    db        0
L12640:
    db        "alignb"
    db        0
L12639:
    db        "movsxd"
    db        0
L12638:
    db        "imul"
    db        0
L12637:
    db        "not"
    db        0
L12636:
    db        "xor"
    db        0
L12635:
    db        "or"
    db        0
L12634:
    db        "and"
    db        0
L12633:
    db        "cmov"
    db        0
L12632:
    db        "set"
    db        0
L12631:
    db        "j"
    db        0
L12630:
    db        "    segment .bss"
    db        0
L12629:
    db        "    segment .data"
    db        0
L12628:
    db        "    segment .text"
    db        0
L12627:
    db        " "
    db        0
L12626:
    db        "   %define "
    db        0
L12625:
    db        " "
    db        0
L12624:
    db        "    %define "
    db        0
L12623:
    db        "L#:"
    db        0
L12622:
    db        ":"
    db        0
L12621:
    db        10
    db        0
L12620:
    db        ":"
    db        0
L12619:
    db        0
L12618:
    db        "strmcl/lab"
    db        0
L12617:
    db        ";End "
    db        0
L12616:
    db        ";Proc "
    db        0
L12615:
    db        10
    db        0
L12614:
    db        "    global "
    db        0
L12613:
    db        10
    db        0
L12612:
    db        "    extern "
    db        0
L12611:
    db        10
    db        0
L12610:
    db        "    global main"
    db        10
    db        0
L12609:
    db        "    extern __getmainargs"
    db        10
    db        0
L12608:
    db        "    extern exit"
    db        10
    db        0
L12607:
    db        "    extern pow"
    db        10
    db        0
L12606:
    db        "    extern ceil"
    db        10
    db        0
L12605:
    db        "    extern floor"
    db        10
    db        0
L12604:
    db        "    extern exp"
    db        10
    db        0
L12603:
    db        "    extern log10"
    db        10
    db        0
L12602:
    db        "    extern log"
    db        10
    db        0
L12601:
    db        "    extern atan"
    db        10
    db        0
L12600:
    db        "    extern acos"
    db        10
    db        0
L12599:
    db        "    extern asin"
    db        10
    db        0
L12598:
    db        "    extern tan"
    db        10
    db        0
L12597:
    db        "    extern cos"
    db        10
    db        0
L12596:
    db        "    extern sin"
    db        10
    db        0
L12595:
    db        "    extern fmod"
    db        10
    db        0
L12594:
    db        "    default rel"
    db        10
    db        0
L12593:
    db        ";NASM VERSION"
    db        10
    db        0
L12592:
    db        "dshift/size"
    db        0
L12591:
    db        "bswap reg>"
    db        0
L12590:
    db        "fixrip disp?"
    db        0
L12589:
    db        "DISPSIZE="
    db        0
L12588:
    db        "movdq opnds"
    db        0
L12587:
    db        "movdq mem,?"
    db        0
L12586:
    db        "5:movdq size"
    db        0
L12585:
    db        "movdq xreg,?"
    db        0
L12584:
    db        "31:movdq size"
    db        0
L12583:
    db        "3:movdq size"
    db        0
L12582:
    db        "movdq reg,?"
    db        0
L12581:
    db        "1:movdq size"
    db        0
L12580:
    db        "float opnds"
    db        0
L12579:
    db        "fix opnds"
    db        0
L12578:
    db        "convertfloat opnds"
    db        0
L12577:
    db        "logicxmm opnds"
    db        0
L12576:
    db        "arithxmm opnds"
    db        0
L12575:
    db        "Wrong size"
    db        0
L12574:
    db        "A.SIZE="
    db        0
L12573:
    db        "Need size"
    db        0
L12572:
    db        "setcc opnd/size"
    db        0
L12571:
    db        "test opnds"
    db        0
L12570:
    db        "shift opnds2?"
    db        0
L12569:
    db        "cl or b10 needed"
    db        0
L12568:
    db        "shift/label"
    db        0
L12567:
    db        "shift opnds1?"
    db        0
L12566:
    db        "imul2 opnds"
    db        0
L12565:
    db        "mul/label"
    db        0
L12564:
    db        "imul2 size"
    db        0
L12563:
    db        "imul2 byte"
    db        0
L12562:
    db        "imul2 opnds"
    db        0
L12561:
    db        "movsxd opnds"
    db        0
L12560:
    db        "movsxd size"
    db        0
L12559:
    db        "exch size"
    db        0
L12558:
    db        "exch opnds"
    db        0
L12557:
    db        "exch size"
    db        0
L12556:
    db        "movsx not reg/mem"
    db        0
L12555:
    db        "movsx size 8"
    db        0
L12554:
    db        "movsx need size prefix"
    db        0
L12553:
    db        "movsx 4=>8 bytes?"
    db        0
L12552:
    db        "movsx size error"
    db        0
L12551:
    db        "movsx not reg"
    db        0
L12550:
    db        "LEA size error"
    db        0
L12549:
    db        "LEA not reg/mem"
    db        0
L12548:
    db        "neg/div/etc opnd?"
    db        0
L12547:
    db        "inc/opnd?"
    db        0
L12546:
    db        "pop opnd?"
    db        0
L12545:
    db        "pop not 64-bit"
    db        0
L12544:
    db        "popreg not 64-bit"
    db        0
L12543:
    db        "push opnd?"
    db        0
L12542:
    db        "push not 64-bit"
    db        0
L12541:
    db        "push imm value too large"
    db        0
L12540:
    db        "pushreg not 64-bit"
    db        0
L12539:
    db        "MOV ?/.."
    db        0
L12538:
    db        "MOV MEM/?"
    db        0
L12537:
    db        "mov imm?"
    db        0
L12536:
    db        "3:Opnd size mismatch"
    db        0
L12535:
    db        "MOV REG/??"
    db        0
L12534:
    db        "1:exceeding u32 value"
    db        0
L12533:
    db        "exceeding u16 value"
    db        0
L12532:
    db        "exceeding byte value"
    db        0
L12531:
    db        "mov imm?"
    db        0
L12530:
    db        "2:Opnd size mismatch"
    db        0
L12529:
    db        "1:Can't add to this opnd"
    db        0
L12528:
    db        "CODE="
    db        0
L12527:
    db        "ADD mem,???"
    db        0
L12526:
    db        "ADD reg,???"
    db        0
L12525:
    db        "Exceeding i8/u8 range"
    db        0
L12524:
    db        "add imm/size"
    db        0
L12523:
    db        "Addr32 can't use RIP, line"
    db        0
L12522:
    db        "Can't scale rstack"
    db        0
L12521:
    db        "Scaled rstack?"
    db        0
L12520:
    db        "genrm not mem"
    db        0
L12519:
    db        "2:exceeding u32 value"
    db        0
L12518:
    db        "exceeding u16 value"
    db        0
L12517:
    db        "exceeding byte value"
    db        0
L12516:
    db        "dbuffer error"
    db        0
L12515:
    db        "l#"
    db        0
L12514:
    db        "bsf size"
    db        0
L12513:
    db        "genrel8"
    db        0
L12512:
    db        "fmem int size"
    db        0
L12511:
    db        "fst i64?"
    db        0
L12510:
    db        "fmem size"
    db        0
L12509:
    db        "SIZE="
    db        0
L12508:
    db        "r80 not allowed"
    db        0
L12507:
    db        "fmem/not mem"
    db        0
L12506:
    db        "cmov/byte"
    db        0
L12505:
    db        "1:Opnd size mismatch"
    db        0
L12504:
    db        "jmp[]size"
    db        0
L12503:
    db        "call[]size"
    db        0
L12502:
    db        "Can't do jcxz fwd jump"
    db        0
L12501:
    db        "jcxz jmp out of range"
    db        0
L12500:
    db        "Can't do loopxx fwd jump"
    db        0
L12499:
    db        "loop jmp out of range"
    db        0
L12498:
    db        "Operand size not set"
    db        0
L12497:
    db        "genamode size 2/8"
    db        0
L12496:
    db        "GENAMODE/MODE?"
    db        0
L12495:
    db        "genam/3"
    db        0
L12494:
    db        "DOFWDREFS/CAN'T DO RELTYPE"
    db        0
L12493:
    db        "Fwd ref in zdata"
    db        0
L12492:
    db        "Rel label across segments2"
    db        0
L12491:
    db        "getdef/no def"
    db        0
L12490:
    db        "Rel label across segments"
    db        0
L12489:
    db        "OPND/8/VALTYPE?"
    db        0
L12488:
    db        "OPND/4/VALTYPE?"
    db        0
L12487:
    db        "8/16-BIT RELOC"
    db        0
L12486:
    db        "GENSS/NAME OPND"
    db        0
L12485:
    db        "STOPPING"
    db        0
L12484:
    db        "M_HALT="
    db        0
L12483:
    db        "M.OPCODE="
    db        0
L12482:
    db        "line"
    db        0
L12481:
    db        "*** Can't do opcode"
    db        0
L12480:
    db        "align?"
    db        0
L12479:
    db        "align2"
    db        0
L12478:
    db        "resb?"
    db        0
L12477:
    db        "retn?"
    db        0
L12476:
    db        "Zdata contains code or data"
    db        0
L12475:
    db        0
L12474:
    db        "delmcl?"
    db        0
L12473:
    db        " ncalldepth:"
    db        0
L12472:
    db        " noperands:"
    db        0
L12471:
    db        ") hwstack:"
    db        0
L12470:
    db        "0 "
    db        0
L12469:
    db        "1 "
    db        0
L12468:
    db        "XWR:("
    db        0
L12467:
    db        ") "
    db        0
L12466:
    db        "0 "
    db        0
L12465:
    db        "1 "
    db        0
L12464:
    db        "WR:("
    db        0
L12463:
    db        " "
    db        0
L12462:
    db        ") "
    db        0
L12461:
    db        ", "
    db        0
L12460:
    db        ">"
    db        0
L12459:
    db        "<"
    db        0
L12458:
    db        "@"
    db        0
L12457:
    db        ")"
    db        0
L12456:
    db        "("
    db        0
L12455:
    db        "T"
    db        0
L12454:
    db        "*"
    db        0
L12453:
    db        0
L12452:
    db        "W:"
    db        0
L12451:
    db        "X:"
    db        0
L12450:
    db        "Y:"
    db        0
L12449:
    db        "Z:"
    db        0
L12448:
    db        "#:("
    db        0
L12447:
    db        "========================================#:("
    db        0
L12446:
    db        0
L12445:
    db        "MSA"
    db        0
L12444:
    db        0
L12443:
    db        "makeopndind"
    db        0
L12442:
    db        0
L12441:
    db        "SOR1"
    db        0
L12440:
    db        0
L12439:
    db        "MOVE TO REG: XREG IN USE"
    db        0
L12438:
    db        0
L12437:
    db        "No more work xregs"
    db        0
L12436:
    db        0
L12435:
    db        "No more work regs"
    db        0
L12434:
    db        0
L12433:
    db        "poppcl/underflow"
    db        0
L12432:
    db        0
L12431:
    db        "PCL stack overflow"
    db        0
L12430:
    db        0
L12429:
    db        "PCL stack overflow"
    db        0
L12428:
    db        "getopnd"
    db        0
L12427:
    db        0
L12426:
    db        "Ext nametab overflow"
    db        0
L12425:
    db        "$B#"
    db        0
L12424:
    db        0
L12423:
    db        "Too many block temps"
    db        0
L12422:
    db        "AASEQ:"
    db        0
L12421:
    db        "AX ERROR:"
    db        0
L12420:
    db        "MCL Opnd not supported: # (#) [#]"
    db        0
L12419:
    db        0
L12418:
    db        "2:SIZE=0"
    db        0
L12417:
    db        0
L12416:
    db        "1:SIZE=0"
    db        0
L12415:
    db        0
L12414:
    db        "BAD SEG CODE"
    db        0
L12413:
    db        0
L12412:
    db        "CAN'T DO RODATA SEG"
    db        0
L12411:
    db        "MCLREC>64B"
    db        0
L12410:
    db        "__getmainargs*"
    db        0
L12409:
    db        "$info"
    db        0
L12408:
    db        "$env"
    db        0
L12407:
    db        "()"
    db        0
L12406:
    db        "High block arg not copied in"
    db        0
L12405:
    db        "No host fn:"
    db        0
L12404:
    db        "gethostfn?"
    db        0
L12403:
    db        "msysc.m$power_i64"
    db        0
L12402:
    db        "msys.m$power_i64"
    db        0
L12401:
    db        0
L12400:
    db        "storebf not imm"
    db        0
L12399:
    db        0
L12398:
    db        "Storebit: both vars"
    db        0
L12397:
    db        0
L12396:
    db        "STOREBIT/VAR"
    db        0
L12395:
    db        0
L12394:
    db        "LOADBF_VAR"
    db        0
L12393:
    db        "mask63/offset64"
    db        0
L12392:
    db        "labzero"
    db        0
L12391:
    db        "labneg64"
    db        0
L12390:
    db        "labneg32"
    db        0
L12389:
    db        "lababs64"
    db        0
L12388:
    db        "lababs32"
    db        0
L12386:
    db        "Real32 Table"
    db        0
L12384:
    db        "Real Table"
    db        0
L12383:
    db        "String Table"
    db        0
L12382:
    db        "ENDDATA"
    db        0
L12381:
    db        0
L12380:
    db        "div/u8"
    db        0
L12379:
    db        0
L12378:
    db        "Divide by zero"
    db        0
L12377:
    db        "---------------"
    db        0
L12376:
    db        "?]]"
    db        0
L12375:
    db        0
L12374:
    db        "Threaded proc has temps"
    db        0
L12373:
    db        0
L12372:
    db        "Threaded proc has locals/params"
    db        0
L12371:
    db        0
L12370:
    db        "@PARAM"
    db        0
L12369:
    db        "$1x"
    db        0
L12367:
    db        0
L12366:
    db        "SUBTOREF/EXTRA"
    db        0
L12365:
    db        "pow*"
    db        0
L12364:
    db        0
L12363:
    db        "setcc/block"
    db        0
L12362:
    db        "fmod*"
    db        0
L12361:
    db        "atan2*"
    db        0
L12360:
    db        "ceil*"
    db        0
L12359:
    db        "floor*"
    db        0
L12358:
    db        "round*"
    db        0
L12357:
    db        "exp*"
    db        0
L12356:
    db        "log10*"
    db        0
L12355:
    db        "log*"
    db        0
L12354:
    db        "atan*"
    db        0
L12353:
    db        "acos*"
    db        0
L12352:
    db        "asin*"
    db        0
L12351:
    db        "tan*"
    db        0
L12350:
    db        "cos*"
    db        0
L12349:
    db        "sin*"
    db        0
L12348:
    db        0
L12347:
    db        "No Assem handler"
    db        0
L12346:
    db        0
L12345:
    db        "SUB/REF NOT POWER OF xx"
    db        0
L12344:
    db        0
L12343:
    db        "float/short"
    db        0
L12342:
    db        0
L12341:
    db        "multo/byte"
    db        0
L12340:
    db        ":"
    db        0
L12339:
    db        0
L12338:
    db        "swap/block"
    db        0
L12337:
    db        0
L12336:
    db        "SUBREF/EXTRA"
    db        0
L12335:
    db        "EXTRA="
    db        0
L12334:
    db        0
L12333:
    db        "Storem not 16"
    db        0
L12332:
    db        "exit*"
    db        0
L12331:
    db        0
L12330:
    db        "Too many nested calls"
    db        0
L12329:
    db        "---"
    db        0
L12328:
    db        0
L12327:
    db        "JUMPCC/BLOCK"
    db        0
L12326:
    db        0
L12325:
    db        "DATA/not 1248"
    db        0
L12324:
    db        "STRPMODE(P.MODE)="
    db        0
L12323:
    db        "P.SIZE="
    db        0
L12322:
    db        "db/dq optype? #"
    db        0
L12321:
    db        "PCL STACK NOT EMPTY"
    db        0
L12320:
    db        "?>>"
    db        0
L12319:
    db        "Unimpl: # (#)"
    db        0
L12318:
    db        "                       "
    db        0
L12317:
    db        "Invalid handler name:"
    db        0
L12316:
    db        "px_"
    db        0
L12315:
    db        "********* ASM HAS PCL INFO *********"
    db        0
L12314:
    db        "$cmdskip"
    db        0
L12313:
    db        "Can't load lib:"
    db        0
L12312:
    db        "Can't find DLL func:"
    db        0
L12311:
    db        "in"
    db        0
L12310:
    db        "Unsupported operand:"
    db        0
L12309:
    db        "seq:"
    db        0
L12308:
    db        "PC Exec error:"
    db        0
L12307:
    db        0
L12306:
    db        "Not mem"
    db        0
L12305:
    db        "Null ptr access"
    db        0
L12304:
    db        "Stopped"
    db        0
L12303:
    db        "Run PCL:"
    db        0
L12302:
    db        0
L12301:
    db        "No 'main' entry point"
    db        0
L12300:
    db        0
L12299:
    db        "data &mem = nil"
    db        0
L12298:
    db        0
L12297:
    db        "data &mem"
    db        0
L12296:
    db        0
L12295:
    db        "FIX/DATA/MEM"
    db        0
L12294:
    db        "Unimpl: # at seq: #"
    db        0
L12293:
    db        "GETOPCODE="
    db        0
L12292:
    db        "# Enter:  # SP=# FP=#"
    db        0
L12291:
    db        "  "
    db        0
L12273:
    db        0
L12272:
    db        "swap/block"
    db        0
L12271:
    db        0
L12270:
    db        "setcc/r32"
    db        0
L12269:
    db        0
L12268:
    db        "setcc/r64"
    db        0
L12267:
    db        0
L12266:
    db        "ICALLF NIL PTR"
    db        0
L12265:
    db        0
L12264:
    db        "ICALLP NIL PTR"
    db        0
L12263:
    db        0
L12262:
    db        "RETF/SP mismatch: old=# curr=# "
    db        0
L12261:
    db        0
L12260:
    db        "ref/call underflow"
    db        0
L12259:
    db        0
L12258:
    db        "RETP/SP mismatch: old=# curr=# "
    db        0
L12257:
    db        0
L12256:
    db        "retp/call underflow"
    db        0
L12255:
    db        "Proc not defined:"
    db        0
L12254:
    db        0
L12253:
    db        "Stack overflow"
    db        0
L12252:
    db        "# Call:   # # SP=# FP=#"
    db        0
L12251:
    db        "  "
    db        0
L12250:
    db        "<Fn ptr>"
    db        0
L12249:
    db        "  Loc: # used:#, addrof:#"
    db        0
L12248:
    db        "  Pm: # used:#, addrof:#"
    db        0
L12247:
    db        "  Hasblocks:#"
    db        0
L12246:
    db        "  MCLdone:  #"
    db        0
L12245:
    db        "  Assem:    #"
    db        0
L12244:
    db        "  Nmaxargs: #"
    db        0
L12243:
    db        "  Leaf:     #"
    db        0
L12242:
    db        "  Locals:   #"
    db        0
L12241:
    db        "  Params:   #"
    db        0
L12240:
    db        "PROC INFO FOR: #"
    db        0
L12239:
    db        " Has statics"
    db        0
L12238:
    db        ")"
    db        0
L12237:
    db        "H"
    db        0
L12236:
    db        ") (D:"
    db        0
L12235:
    db        " (Proc:"
    db        0
L12234:
    db        ")"
    db        0
L12233:
    db        " "
    db        0
L12232:
    db        " ("
    db        0
L12231:
    db        "H"
    db        0
L12230:
    db        " .PCADDR ="
    db        0
L12229:
    db        " ENTRY PT"
    db        0
L12228:
    db        " Dot"
    db        0
L12227:
    db        " TC"
    db        0
L12226:
    db        " Var:"
    db        0
L12225:
    db        " Imp"
    db        0
L12224:
    db        " Exp"
    db        0
L12223:
    db        " Loc:"
    db        0
L12222:
    db        " Pm:"
    db        0
L12221:
    db        " "
    db        0
L12220:
    db        "4"
    db        0
L12219:
    db        "21jl"
    db        0
L12218:
    db        "    "
    db        0
L12217:
    db        "21jl"
    db        0
L12216:
    db        "    "
    db        0
L12215:
    db        "25jl"
    db        0
L12214:
    db        " "
    db        0
L12213:
    db        "H"
    db        0
L12212:
    db        "PROC PC Symbol table"
    db        0
L12211:
    db        " "
    db        0
L12210:
    db        "  "
    db        0
L12209:
    db        "    data mem:"
    db        0
L12208:
    db        " "
    db        0
L12207:
    db        ":"
    db        0
L12206:
    db        "#"
    db        0
L12205:
    db        " "
    db        0
L12204:
    db        10
    db        0
L12203:
    db        " 1"
    db        0
L12202:
    db        "extproc    "
    db        0
L12201:
    db        34
    db        0
L12200:
    db        "addlib    "
    db        34
    db        0
L12199:
    db        "!PROC PCL"
    db        0
L12198:
    db        "<BIGSTR>"
    db        0
L12197:
    db        "<PCLOPND?>"
    db        0
L12196:
    db        "---------"
    db        0
L12195:
    db        "<Data * # (#)>"
    db        0
L12194:
    db        0
L12193:
    db        "#"
    db        0
L12192:
    db        "## "
    db        0
L12191:
    db        "&"
    db        0
L12190:
    db        ":"
    db        0
L12189:
    db        34
    db        0
L12188:
    db        "e16.16"
    db        0
L12187:
    db        "infinity"
    db        0
L12185:
    db        0
L12184:
    db        " "
    db        0
L12183:
    db        "/"
    db        0
L12182:
    db        " "
    db        0
L12181:
    db        "/"
    db        0
L12180:
    db        "set"
    db        0
L12179:
    db        "jump"
    db        0
L12178:
    db        "    "
    db        0
L12177:
    db        "endprog"
    db        0
L12176:
    db        "endproc"
    db        0
L12175:
    db        "    variadic"
    db        0
L12174:
    db        "    rettype  "
    db        0
L12173:
    db        "       "
    db        0
L12172:
    db        "    local    "
    db        0
L12171:
    db        "       "
    db        0
L12170:
    db        "    param    "
    db        0
L12169:
    db        ":"
    db        0
L12168:
    db        "::"
    db        0
L12167:
    db        " "
    db        0
L12166:
    db        "proc"
    db        0
L12165:
    db        "tcproc"
    db        0
L12164:
    db        "! - - -"
    db        0
L12163:
    db        "!"
    db        0
L12162:
    db        ":"
    db        0
L12161:
    db        "! "
    db        0
L12160:
    db        " NOT USED"
    db        0
L12159:
    db        "z2h"
    db        0
L12157:
    db        "MCL Error: # (#) on Line: # in #, PCL:#"
    db        0
L12156:
    db        "Proc:"
    db        0
L12155:
    db        "?"
    db        0
L12154:
    db        "FILENAME="
    db        0
L12153:
    db        "LINENO="
    db        0
L12152:
    db        "No proc"
    db        0
L12151:
    db        "Dupl proc:"
    db        0
L12150:
    db        "Nested proc"
    db        0
L12149:
    db        0
L12148:
    db        "Too many libs"
    db        0
L12147:
    db        "w"
    db        0
L12146:
    db        "$error.tmp"
    db        0
L12145:
    db        "."
    db        0
L12144:
    db        "*"
    db        0
L12143:
    db        "`"
    db        0
L12142:
    db        "PCL Error:"
    db        0
L12141:
    db        ":"
    db        0
L12140:
    db        "PCL error:"
    db        0
L12139:
    db        "---"
    db        0
L12138:
    db        "mem:"
    db        0
L12137:
    db        0
L12136:
    db        "dummy"
    db        0
L12135:
    db        "PHIGHMEM="
    db        0
L12134:
    db        "w"
    db        0
L12133:
    db        "Writing"
    db        0
L12132:
    db        "w"
    db        0
L12131:
    db        0
L12130:
    db        "Writing PST"
    db        0
L12129:
    db        0
L12128:
    db        "Writing PCL"
    db        0
L12127:
    db        "PCL start?"
    db        0
L12126:
    db        "C:@@@@"
    db        92
    db        "m"
    db        92
    db        34
    db        0
L12125:
    db        "wb"
    db        0
L12124:
    db        "con"
    db        0
L12123:
    db        "rb"
    db        0
L12122:
    db        "con"
    db        0
L12121:
    db        "W64"
    db        0
L12120:
    db        "Regclass error: %lld %lld"
    db        10
    db        0
L12118:
    db        "pcc001"
    db        0
L12116:
    db        "Winexec error: %lld"
    db        10
    db        0
L12111:
    db        "@file item too long"
    db        0
L12110:
    db        "Unexpected EOF in @file"
    db        0
L12109:
    db        "mcx"
    db        0
L12108:
    db        "dll"
    db        0
L12107:
    db        "Can't open"
    db        0
L12106:
    db        13
    db        0
L12105:
    db        10
    db        0
L12104:
    db        " "
    db        0
L12103:
    db        0
L12102:
    db        "."
    db        0
L12101:
    db        0
L12100:
    db        "."
    db        0
L12099:
    db        "line too long"
    db        0
L12098:
    db        "rb"
    db        0
L12097:
    db        "wb"
    db        0
L12096:
    db        "rb"
    db        0
L12095:
    db        "ABORTING: Press key..."
    db        0
L12094:
    db        "Realloc mem failure"
    db        0
L12093:
    db        "Alloc mem failure"
    db        0
L12092:
    db        "Can't alloc pc heap"
    db        0
L12091:
    db        "pcm_alloc failure"
    db        0
L12085:
    db        "%.*s"
    db        0
L12084:
    db        "MCL-UNIMPL: %s"
    db        10
    db        0
L12082:
    db        "%lf%n"
    db        0
L12080:
    db        "READ CMDLINE"
    db        0
L12078:
    db        "<mindint>"
    db        0
L12077:
    db        "1000000000000000000000000000000000000000000000000000000000000000"
    db        0
L12076:
    db        "8000000000000000"
    db        0
L12075:
    db        "9223372036854775808"
    db        0
L12074:
    db        "|"
    db        0
L12073:
    db        "%.*s"
    db        0
L12072:
    db        " "
    db        0
L12071:
    db        13
    db        10
    db        0
L12070:
    db        "PRTSL"
    db        0
L12069:
    db        "<null>"
    db        0
L12068:
    db        "%f"
    db        0
L12067:
    db        "%llu"
    db        0
L12066:
    db        "False"
    db        0
L12065:
    db        "True"
    db        0
L12064:
    db        "z8H"
    db        0
L12063:
    db        "Too many io levels"
    db        10
    db        0
L12062:
    db        "Too many params"
    db        10
    db        0
L12061:
    db        "kkcx2ichar"
    db        0
L12060:
    db        "kkax2slice"
    db        0
L12059:
    db        "kkichar2sl"
    db        0
L12058:
    db        "kksofttrun"
    db        0
L12057:
    db        "kkharderr"
    db        0
L12056:
    db        "kktoboolt"
    db        0
L12055:
    db        "kksoftconv"
    db        0
L12054:
    db        "kkfnarrow"
    db        0
L12053:
    db        "kkfwiden"
    db        0
L12052:
    db        "kkwiden"
    db        0
L12051:
    db        "kktruncate"
    db        0
L12050:
    db        "kkfix"
    db        0
L12049:
    db        "kkfloat"
    db        0
L12048:
    db        "kkerror"
    db        0
L12047:
    db        "linkdll"
    db        0
L12046:
    db        "$sourcepath"
    db        0
L12045:
    db        "import"
    db        0
L12044:
    db        "module"
    db        0
L12043:
    db        "clear"
    db        0
L12042:
    db        "$caligned"
    db        0
L12041:
    db        "od"
    db        0
L12040:
    db        "esac"
    db        0
L12039:
    db        "fi"
    db        0
L12038:
    db        "even"
    db        0
L12037:
    db        "odd"
    db        0
L12036:
    db        "lsw"
    db        0
L12035:
    db        "msw"
    db        0
L12034:
    db        "lsbit"
    db        0
L12033:
    db        "msbit"
    db        0
L12032:
    db        "lsb"
    db        0
L12031:
    db        "msb"
    db        0
L12030:
    db        "typestr"
    db        0
L12029:
    db        "bytes"
    db        0
L12028:
    db        "bitwidth"
    db        0
L12027:
    db        "bounds"
    db        0
L12026:
    db        "upb"
    db        0
L12025:
    db        "lwb"
    db        0
L12024:
    db        "len"
    db        0
L12023:
    db        "sliceptr"
    db        0
L12022:
    db        "fmod"
    db        0
L12021:
    db        "atan2"
    db        0
L12020:
    db        "ceil"
    db        0
L12019:
    db        "floor"
    db        0
L12018:
    db        "round"
    db        0
L12017:
    db        "exp"
    db        0
L12016:
    db        "log10"
    db        0
L12015:
    db        "log"
    db        0
L12014:
    db        "atan"
    db        0
L12013:
    db        "acos"
    db        0
L12012:
    db        "asin"
    db        0
L12011:
    db        "tan"
    db        0
L12010:
    db        "cos"
    db        0
L12009:
    db        "sin"
    db        0
L12008:
    db        "sign"
    db        0
L12007:
    db        "sqrt"
    db        0
L12006:
    db        "sqr"
    db        0
L12005:
    db        "abs"
    db        0
L12004:
    db        "istrue"
    db        0
L12003:
    db        "inot"
    db        0
L12002:
    db        "not"
    db        0
L12001:
    db        "max"
    db        0
L12000:
    db        "min"
    db        0
L11999:
    db        "divrem"
    db        0
L11998:
    db        "rem"
    db        0
L11997:
    db        "inrev"
    db        0
L11996:
    db        "notin"
    db        0
L11995:
    db        "in"
    db        0
L11994:
    db        "ixor"
    db        0
L11993:
    db        "ior"
    db        0
L11992:
    db        "iand"
    db        0
L11991:
    db        "xor"
    db        0
L11990:
    db        "or"
    db        0
L11989:
    db        "and"
    db        0
L11988:
    db        "$"
    db        0
L11987:
    db        "infinity"
    db        0
L11986:
    db        "false"
    db        0
L11985:
    db        "true"
    db        0
L11984:
    db        "pi"
    db        0
L11983:
    db        "nil"
    db        0
L11982:
    db        "$typename"
    db        0
L11981:
    db        "$version"
    db        0
L11980:
    db        "$time"
    db        0
L11979:
    db        "$date"
    db        0
L11978:
    db        "$function"
    db        0
L11977:
    db        "$modulename"
    db        0
L11976:
    db        "$filename"
    db        0
L11975:
    db        "$strlineno"
    db        0
L11974:
    db        "$lineno"
    db        0
L11973:
    db        "billion"
    db        0
L11972:
    db        "million"
    db        0
L11971:
    db        "slice"
    db        0
L11970:
    db        "label"
    db        0
L11969:
    db        "bool8"
    db        0
L11968:
    db        "bool"
    db        0
L11967:
    db        "bool64"
    db        0
L11966:
    db        "c64"
    db        0
L11965:
    db        "c8"
    db        0
L11964:
    db        "char"
    db        0
L11963:
    db        "u64"
    db        0
L11962:
    db        "u32"
    db        0
L11961:
    db        "u16"
    db        0
L11960:
    db        "u8"
    db        0
L11959:
    db        "byte"
    db        0
L11958:
    db        "r64"
    db        0
L11957:
    db        "r32"
    db        0
L11956:
    db        "i64"
    db        0
L11955:
    db        "i32"
    db        0
L11954:
    db        "i16"
    db        0
L11953:
    db        "i8"
    db        0
L11952:
    db        "ivoid"
    db        0
L11951:
    db        "ichar"
    db        0
L11950:
    db        "real"
    db        0
L11949:
    db        "word"
    db        0
L11948:
    db        "int"
    db        0
L11947:
    db        "void"
    db        0
L11946:
    db        "swap"
    db        0
L11945:
    db        "export"
    db        0
L11944:
    db        "global"
    db        0
L11943:
    db        "unless"
    db        0
L11942:
    db        "project"
    db        0
L11941:
    db        "importdll"
    db        0
L11940:
    db        "$getprocaddr"
    db        0
L11939:
    db        "$getprocname"
    db        0
L11938:
    db        "$getnprocs"
    db        0
L11937:
    db        "const"
    db        0
L11936:
    db        "static"
    db        0
L11935:
    db        "asm"
    db        0
L11934:
    db        "assem"
    db        0
L11933:
    db        "macro"
    db        0
L11932:
    db        "strinclude"
    db        0
L11931:
    db        "sinclude"
    db        0
L11930:
    db        "binclude"
    db        0
L11929:
    db        "include"
    db        0
L11928:
    db        "let"
    db        0
L11927:
    db        "var"
    db        0
L11926:
    db        "ref"
    db        0
L11925:
    db        "union"
    db        0
L11924:
    db        "struct"
    db        0
L11923:
    db        "record"
    db        0
L11922:
    db        "type"
    db        0
L11921:
    db        "threadedproc"
    db        0
L11920:
    db        "fun"
    db        0
L11919:
    db        "proc"
    db        0
L11918:
    db        "func"
    db        0
L11917:
    db        "function"
    db        0
L11916:
    db        "cast"
    db        0
L11915:
    db        "readln"
    db        0
L11914:
    db        "read"
    db        0
L11913:
    db        "cpl"
    db        0
L11912:
    db        "cp"
    db        0
L11911:
    db        "fprintln"
    db        0
L11910:
    db        "fprint"
    db        0
L11909:
    db        "println"
    db        0
L11908:
    db        "print"
    db        0
L11907:
    db        "eval"
    db        0
L11906:
    db        "clamp"
    db        0
L11905:
    db        "enumdata"
    db        0
L11904:
    db        "tabledata"
    db        0
L11903:
    db        "doswitchx"
    db        0
L11902:
    db        "doswitchu"
    db        0
L11901:
    db        "doswitch"
    db        0
L11900:
    db        "switch"
    db        0
L11899:
    db        "goto"
    db        0
L11898:
    db        "exit"
    db        0
L11897:
    db        "nextloop"
    db        0
L11896:
    db        "redoloop"
    db        0
L11895:
    db        "stop"
    db        0
L11894:
    db        "return"
    db        0
L11893:
    db        "until"
    db        0
L11892:
    db        "repeat"
    db        0
L11891:
    db        "while"
    db        0
L11890:
    db        "end"
    db        0
L11889:
    db        "do"
    db        0
L11888:
    db        "by"
    db        0
L11887:
    db        "downto"
    db        0
L11886:
    db        "to"
    db        0
L11885:
    db        "for"
    db        0
L11884:
    db        "when"
    db        0
L11883:
    db        "recase"
    db        0
L11882:
    db        "docase"
    db        0
L11881:
    db        "case"
    db        0
L11880:
    db        "elseswitch"
    db        0
L11879:
    db        "elsecase"
    db        0
L11878:
    db        "dummyelse"
    db        0
L11877:
    db        "else"
    db        0
L11876:
    db        "elsif"
    db        0
L11875:
    db        "then"
    db        0
L11874:
    db        "if"
    db        0
L11873:
    db        "kkmaxval"
    db        0
L11872:
    db        "kkminval"
    db        0
L11871:
    db        "kktypestr"
    db        0
L11870:
    db        "kkbytesize"
    db        0
L11869:
    db        "kkbitwidth"
    db        0
L11868:
    db        "kkbounds"
    db        0
L11867:
    db        "kkupb"
    db        0
L11866:
    db        "kklwb"
    db        0
L11865:
    db        "kklen"
    db        0
L11864:
    db        "kksliceptr"
    db        0
L11863:
    db        "linkid"
    db        0
L11862:
    db        "macroparamid"
    db        0
L11861:
    db        "macroid"
    db        0
L11860:
    db        "labelid"
    db        0
L11859:
    db        "fieldid"
    db        0
L11858:
    db        "paramid"
    db        0
L11857:
    db        "frameid"
    db        0
L11856:
    db        "staticid"
    db        0
L11855:
    db        "constid"
    db        0
L11854:
    db        "dllvarid"
    db        0
L11853:
    db        "dllprocid"
    db        0
L11852:
    db        "procid"
    db        0
L11851:
    db        "typeid"
    db        0
L11850:
    db        "dllmoduleid"
    db        0
L11849:
    db        "moduleid"
    db        0
L11848:
    db        "subprogid"
    db        0
L11847:
    db        "programid"
    db        0
L11846:
    db        "nullid"
    db        0
L11845:
    db        "Byref "
    db        0
L11844:
    db        "Byval "
    db        0
L11843:
    db        "Export"
    db        0
L11842:
    db        "Program"
    db        0
L11841:
    db        "Global"
    db        0
L11840:
    db        "Local"
    db        0
L11839:
    db        "hdr_linkdll"
    db        0
L11838:
    db        "hdr_sourcepath"
    db        0
L11837:
    db        "hdr_import"
    db        0
L11836:
    db        "hdr_module"
    db        0
L11835:
    db        "ksyscallsym"
    db        0
L11834:
    db        "kassemsym"
    db        0
L11833:
    db        "kswapsym"
    db        0
L11832:
    db        "kclampsym"
    db        0
L11831:
    db        "ktabledatasym"
    db        0
L11830:
    db        "kevalsym"
    db        0
L11829:
    db        "dollarsym"
    db        0
L11828:
    db        "compilervarsym"
    db        0
L11827:
    db        "kcastsym"
    db        0
L11826:
    db        "kstaticsym"
    db        0
L11825:
    db        "kglobalsym"
    db        0
L11824:
    db        "kheadersym"
    db        0
L11823:
    db        "kclearsym"
    db        0
L11822:
    db        "kconstsym"
    db        0
L11821:
    db        "kmacrosym"
    db        0
L11820:
    db        "kslicesym"
    db        0
L11819:
    db        "kletsym"
    db        0
L11818:
    db        "kvarsym"
    db        0
L11817:
    db        "kvoidsym"
    db        0
L11816:
    db        "krefsym"
    db        0
L11815:
    db        "ktypesym"
    db        0
L11814:
    db        "kprojectsym"
    db        0
L11813:
    db        "kimportmodulesym"
    db        0
L11812:
    db        "kunionsym"
    db        0
L11811:
    db        "kstructsym"
    db        0
L11810:
    db        "krecordsym"
    db        0
L11809:
    db        "klabelsym"
    db        0
L11808:
    db        "kfunctionsym"
    db        0
L11807:
    db        "kprocsym"
    db        0
L11806:
    db        "kreadsym"
    db        0
L11805:
    db        "kprintsym"
    db        0
L11804:
    db        "kdoswitchsym"
    db        0
L11803:
    db        "kswitchsym"
    db        0
L11802:
    db        "kgotosym"
    db        0
L11801:
    db        "kloopsym"
    db        0
L11800:
    db        "kstopsym"
    db        0
L11799:
    db        "kreturnsym"
    db        0
L11798:
    db        "kuntilsym"
    db        0
L11797:
    db        "krepeatsym"
    db        0
L11796:
    db        "kwhilesym"
    db        0
L11795:
    db        "kdosym"
    db        0
L11794:
    db        "kbysym"
    db        0
L11793:
    db        "ktosym"
    db        0
L11792:
    db        "kforsym"
    db        0
L11791:
    db        "kwhensym"
    db        0
L11790:
    db        "krecasesym"
    db        0
L11789:
    db        "kdocasesym"
    db        0
L11788:
    db        "kcasesym"
    db        0
L11787:
    db        "kunlesssym"
    db        0
L11786:
    db        "kendsym"
    db        0
L11785:
    db        "kelseswitchsym"
    db        0
L11784:
    db        "kelsecasesym"
    db        0
L11783:
    db        "kelsesym"
    db        0
L11782:
    db        "kelsifsym"
    db        0
L11781:
    db        "kthensym"
    db        0
L11780:
    db        "kifsym"
    db        0
L11779:
    db        "kicharsym"
    db        0
L11778:
    db        "stdtypesym"
    db        0
L11777:
    db        "asmopcodesym"
    db        0
L11776:
    db        "segnamesym"
    db        0
L11775:
    db        "movccsym"
    db        0
L11774:
    db        "setccsym"
    db        0
L11773:
    db        "jmpccsym"
    db        0
L11772:
    db        "mregsym"
    db        0
L11771:
    db        "fregsym"
    db        0
L11770:
    db        "xregsym"
    db        0
L11769:
    db        "regsym"
    db        0
L11768:
    db        "kstrincludesym"
    db        0
L11767:
    db        "kincludesym"
    db        0
L11766:
    db        "namesym"
    db        0
L11765:
    db        "unitnamesym"
    db        0
L11764:
    db        "stringconstsym"
    db        0
L11763:
    db        "charconstsym"
    db        0
L11762:
    db        "realconstsym"
    db        0
L11761:
    db        "intconstsym"
    db        0
L11760:
    db        "incrsym"
    db        0
L11759:
    db        "rawxnamesym"
    db        0
L11758:
    db        "eofsym"
    db        0
L11757:
    db        "eolsym"
    db        0
L11756:
    db        "bitfieldsym"
    db        0
L11755:
    db        "maths2opsym"
    db        0
L11754:
    db        "mathsopsym"
    db        0
L11753:
    db        "propsym"
    db        0
L11752:
    db        "sqr"
    db        0
L11751:
    db        "sqrt"
    db        0
L11750:
    db        "sign"
    db        0
L11749:
    db        "abs"
    db        0
L11748:
    db        "inot"
    db        0
L11747:
    db        "istrue"
    db        0
L11746:
    db        "not"
    db        0
L11745:
    db        "inrev"
    db        0
L11744:
    db        "notin"
    db        0
L11743:
    db        "in"
    db        0
L11742:
    db        "**"
    db        0
L11741:
    db        "cmp"
    db        0
L11740:
    db        "="
    db        0
L11739:
    db        "xor"
    db        0
L11738:
    db        "or"
    db        0
L11737:
    db        "and"
    db        0
L11736:
    db        "max"
    db        0
L11735:
    db        "min"
    db        0
L11734:
    db        ">>"
    db        0
L11733:
    db        "<<"
    db        0
L11732:
    db        "ixor"
    db        0
L11731:
    db        "ior"
    db        0
L11730:
    db        "iand"
    db        0
L11729:
    db        "divrem"
    db        0
L11728:
    db        "rem"
    db        0
L11727:
    db        "%"
    db        0
L11726:
    db        "/"
    db        0
L11725:
    db        "*"
    db        0
L11724:
    db        "-"
    db        0
L11723:
    db        "+"
    db        0
L11722:
    db        "#"
    db        0
L11721:
    db        "..."
    db        0
L11720:
    db        ".."
    db        0
L11719:
    db        "&&"
    db        0
L11718:
    db        "&"
    db        0
L11717:
    db        "?"
    db        0
L11716:
    db        "@"
    db        0
L11715:
    db        "|"
    db        0
L11714:
    db        "^"
    db        0
L11713:
    db        "}"
    db        0
L11712:
    db        "{"
    db        0
L11711:
    db        "]"
    db        0
L11710:
    db        "["
    db        0
L11709:
    db        ")"
    db        0
L11708:
    db        "("
    db        0
L11707:
    db        "->"
    db        0
L11706:
    db        "=>"
    db        0
L11705:
    db        ":="
    db        0
L11704:
    db        ":"
    db        0
L11703:
    db        ";"
    db        0
L11702:
    db        ","
    db        0
L11701:
    db        "&."
    db        0
L11700:
    db        "."
    db        0
L11699:
    db        "prop_op"
    db        0
L11698:
    db        "mon_op"
    db        0
L11697:
    db        "bin_op"
    db        0
L11696:
    db        "no_op"
    db        0
L11695:
    db        "bf_even"
    db        0
L11694:
    db        "bf_odd"
    db        0
L11693:
    db        "bf_lsw"
    db        0
L11692:
    db        "bf_msw"
    db        0
L11691:
    db        "bf_lsbit"
    db        0
L11690:
    db        "bf_msbit"
    db        0
L11689:
    db        "bf_lsb"
    db        0
L11688:
    db        "bf_msb"
    db        0
L11687:
    db        "jclear"
    db        0
L11686:
    db        "jeval"
    db        0
L11685:
    db        "jstop"
    db        0
L11684:
    db        "jreadln"
    db        0
L11683:
    db        "jread"
    db        0
L11682:
    db        "jfprintln"
    db        0
L11681:
    db        "jfprint"
    db        0
L11680:
    db        "jprintln"
    db        0
L11679:
    db        "jprint"
    db        0
L11678:
    db        "jrecase"
    db        0
L11677:
    db        "jselect"
    db        0
L11676:
    db        "jswap"
    db        0
L11675:
    db        "jdoswitchx"
    db        0
L11674:
    db        "jdoswitchu"
    db        0
L11673:
    db        "jdoswitch"
    db        0
L11672:
    db        "jswitch"
    db        0
L11671:
    db        "jdocase"
    db        0
L11670:
    db        "jcase"
    db        0
L11669:
    db        "jdo"
    db        0
L11668:
    db        "jexit"
    db        0
L11667:
    db        "jnext"
    db        0
L11666:
    db        "jredo"
    db        0
L11665:
    db        "jlabeldef"
    db        0
L11664:
    db        "jgoto"
    db        0
L11663:
    db        "jrepeat"
    db        0
L11662:
    db        "jwhile"
    db        0
L11661:
    db        "jforallrev"
    db        0
L11660:
    db        "jforall"
    db        0
L11659:
    db        "jfordown"
    db        0
L11658:
    db        "jforup"
    db        0
L11657:
    db        "jif"
    db        0
L11656:
    db        "jto"
    db        0
L11655:
    db        "jsyscall"
    db        0
L11654:
    db        "jreturn"
    db        0
L11653:
    db        "jspace"
    db        0
L11652:
    db        "jnogap"
    db        0
L11651:
    db        "jfmtitem"
    db        0
L11650:
    db        "jwhenthen"
    db        0
L11649:
    db        "jcvfalse"
    db        0
L11648:
    db        "jcvtrue"
    db        0
L11647:
    db        "jcvinfinity"
    db        0
L11646:
    db        "jcvpi"
    db        0
L11645:
    db        "jcvnil"
    db        0
L11644:
    db        "jcvtypename"
    db        0
L11643:
    db        "jcvversion"
    db        0
L11642:
    db        "jcvtime"
    db        0
L11641:
    db        "jcvdate"
    db        0
L11640:
    db        "jcvfunction"
    db        0
L11639:
    db        "jcvfilename"
    db        0
L11638:
    db        "jcvmodulename"
    db        0
L11637:
    db        "jcvstrlineno"
    db        0
L11636:
    db        "jcvlineno"
    db        0
L11635:
    db        "jmaxvalue"
    db        0
L11634:
    db        "jminvalue"
    db        0
L11633:
    db        "jbitfield"
    db        0
L11632:
    db        "jtypestr"
    db        0
L11631:
    db        "jbytesize"
    db        0
L11630:
    db        "jbitwidth"
    db        0
L11629:
    db        "jupper"
    db        0
L11628:
    db        "joperator"
    db        0
L11627:
    db        "jtypeconst"
    db        0
L11626:
    db        "jtypepun"
    db        0
L11625:
    db        "jautocast"
    db        0
L11624:
    db        "jshorten"
    db        0
L11623:
    db        "jconvert"
    db        0
L11622:
    db        "jdaddrvv"
    db        0
L11621:
    db        "jaddroffirst"
    db        0
L11620:
    db        "jaddrof"
    db        0
L11619:
    db        "jptrlv"
    db        0
L11618:
    db        "jptr"
    db        0
L11617:
    db        "jdotslice"
    db        0
L11616:
    db        "jdotindex"
    db        0
L11615:
    db        "jdotlv"
    db        0
L11614:
    db        "jdot"
    db        0
L11613:
    db        "jslice"
    db        0
L11612:
    db        "jindexlv"
    db        0
L11611:
    db        "jindex"
    db        0
L11610:
    db        "jstringz"
    db        0
L11609:
    db        "jinset"
    db        0
L11608:
    db        "jinrange"
    db        0
L11607:
    db        "jinrev"
    db        0
L11606:
    db        "jin"
    db        0
L11605:
    db        "jincr"
    db        0
L11604:
    db        "junaryto"
    db        0
L11603:
    db        "jbinto"
    db        0
L11602:
    db        "jprop"
    db        0
L11601:
    db        "junary"
    db        0
L11600:
    db        "jbin"
    db        0
L11599:
    db        "jcmpchain"
    db        0
L11598:
    db        "jcmp"
    db        0
L11597:
    db        "jcall"
    db        0
L11596:
    db        "jassignmdrem"
    db        0
L11595:
    db        "jassignms"
    db        0
L11594:
    db        "jassignmm"
    db        0
L11593:
    db        "jassign"
    db        0
L11592:
    db        "jkeyvalue"
    db        0
L11591:
    db        "jkeyword"
    db        0
L11590:
    db        "jreturnmult"
    db        0
L11589:
    db        "jmakeslice"
    db        0
L11588:
    db        "jmakedict"
    db        0
L11587:
    db        "jmakeset"
    db        0
L11586:
    db        "jmakerange"
    db        0
L11585:
    db        "jmakelist"
    db        0
L11584:
    db        "jisfalsel"
    db        0
L11583:
    db        "jistruel"
    db        0
L11582:
    db        "jnotl"
    db        0
L11581:
    db        "jorl"
    db        0
L11580:
    db        "jandl"
    db        0
L11579:
    db        "jsourceline"
    db        0
L11578:
    db        "jstrinclude"
    db        0
L11577:
    db        "jassemmem"
    db        0
L11576:
    db        "jassemxreg"
    db        0
L11575:
    db        "jassemreg"
    db        0
L11574:
    db        "jassemmacro"
    db        0
L11573:
    db        "jassem"
    db        0
L11572:
    db        "jdecimal"
    db        0
L11571:
    db        "jblock"
    db        0
L11570:
    db        "jnamelv"
    db        0
L11569:
    db        "jname"
    db        0
L11568:
    db        "jvoidvar"
    db        0
L11567:
    db        "jnull"
    db        0
L11566:
    db        "jconst"
    db        0
L11565:
    db        "jnone"
    db        0
L11564:
    db        "sf_unimpl"
    db        0
L11563:
    db        "sf_power_i64"
    db        0
L11562:
    db        "sf_getprocaddr"
    db        0
L11561:
    db        "sf_getprocname"
    db        0
L11560:
    db        "sf_getnprocs"
    db        0
L11559:
    db        "sf_read_conline"
    db        0
L11558:
    db        "sf_read_strline"
    db        0
L11557:
    db        "sf_read_fileline"
    db        0
L11556:
    db        "sf_read_str"
    db        0
L11555:
    db        "sf_read_r64"
    db        0
L11554:
    db        "sf_read_i64"
    db        0
L11553:
    db        "sf_print_end"
    db        0
L11552:
    db        "sf_print_newline"
    db        0
L11551:
    db        "sf_print_bool"
    db        0
L11550:
    db        "sf_print_c8"
    db        0
L11549:
    db        "sf_print_ptr_nf"
    db        0
L11548:
    db        "sf_print_ptr"
    db        0
L11547:
    db        "sf_print_strsl"
    db        0
L11546:
    db        "sf_print_str_nf"
    db        0
L11545:
    db        "sf_print_str"
    db        0
L11544:
    db        "sf_print_r32"
    db        0
L11543:
    db        "sf_print_r64"
    db        0
L11542:
    db        "sf_print_u64"
    db        0
L11541:
    db        "sf_print_i64_nf"
    db        0
L11540:
    db        "sf_print_i64"
    db        0
L11539:
    db        "sf_print_space"
    db        0
L11538:
    db        "sf_print_nogap"
    db        0
L11537:
    db        "sf_print_setfmt"
    db        0
L11536:
    db        "sf_print_startcon"
    db        0
L11535:
    db        "sf_print_startptr"
    db        0
L11534:
    db        "sf_print_startstr"
    db        0
L11533:
    db        "sf_print_startfile"
    db        0
L11532:
    db        "sf_init"
    db        0
L11531:
    db        "last "
    db        0
L11530:
    db        "block"
    db        0
L11529:
    db        "pend"
    db        0
L11528:
    db        "tuple"
    db        0
L11527:
    db        "bitfl"
    db        0
L11526:
    db        "type"
    db        0
L11525:
    db        "label"
    db        0
L11524:
    db        "proc"
    db        0
L11523:
    db        "any"
    db        0
L11522:
    db        "auto"
    db        0
L11521:
    db        "refbit"
    db        0
L11520:
    db        "ichar"
    db        0
L11519:
    db        "u32"
    db        0
L11518:
    db        "u16"
    db        0
L11517:
    db        "u8"
    db        0
L11516:
    db        "i32"
    db        0
L11515:
    db        "i16"
    db        0
L11514:
    db        "i8"
    db        0
L11513:
    db        "b8"
    db        0
L11512:
    db        "c8"
    db        0
L11511:
    db        "slice"
    db        0
L11510:
    db        "array"
    db        0
L11509:
    db        "range"
    db        0
L11508:
    db        "rec"
    db        0
L11507:
    db        "ref"
    db        0
L11506:
    db        "bool64"
    db        0
L11505:
    db        "c64"
    db        0
L11504:
    db        "u64"
    db        0
L11503:
    db        "i64"
    db        0
L11502:
    db        "r32"
    db        0
L11501:
    db        "r64"
    db        0
L11500:
    db        "void"
    db        0
L11499:
    db        "Dec"
    db        0
L11498:
    db        "Nov"
    db        0
L11497:
    db        "Oct"
    db        0
L11496:
    db        "Sep"
    db        0
L11495:
    db        "Aug"
    db        0
L11494:
    db        "Jul"
    db        0
L11493:
    db        "Jun"
    db        0
L11492:
    db        "May"
    db        0
L11491:
    db        "Apr"
    db        0
L11490:
    db        "Mar"
    db        0
L11489:
    db        "Feb"
    db        0
L11488:
    db        "Jan"
    db        0
L11487:
    db        "m"
    db        0
L11486:
    db        "type dll0_int=ref function:int"
    db        10
    db        "type dll1_int=ref function(int)int"
    db        10
    db        "type dll2_int=ref function(int,int)int"
    db        10
    db        "type dll3_int=ref function(int,int,int)int"
    db        10
    db        "type dll4_int=ref function(int,int,int,int)int"
    db        10
    db        "type dll5_int=ref function(int,int,int,int,int)int"
    db        10
    db        "type dll6_int=ref function(int,int,int,int,int,int)int"
    db        10
    db        "type dll8_int=ref function(int,int,int,int, int,int,int,int)int"
    db        10
    db        "type dll9_int=ref function(int,int,int,int, int,int,int,int, int)int"
    db        10
    db        "type dll10_int=ref function(int,int,int,int, int,int,int,int, int,int)int"
    db        10
    db        "type dll11_int=ref function(int,int,int,int, int,int,int,int, int,int,int)int"
    db        10
    db        "type dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int"
    db        10
    db        "type dll14_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int, int,int)int"
    db        10
    db        10
    db        "type dll0_r64=ref function:r64"
    db        10
    db        "type dll1_r64=ref function(int)r64"
    db        10
    db        "type dll2_r64=ref function(int,int)r64"
    db        10
    db        10
    db        "type dll0_r64x=ref function:r64"
    db        10
    db        "type dll1_r64x=ref function(real)r64"
    db        10
    db        "type dll2_r64x=ref function(real,real)r64"
    db        10
    db        10
    db        "type m_dll0_int=ref function:int"
    db        10
    db        "type m_dll1_int=ref function(int)int"
    db        10
    db        "type m_dll2_int=ref function(int,int)int"
    db        10
    db        "type m_dll3_int=ref function(int,int,int)int"
    db        10
    db        "type m_dll4_int=ref function(int,int,int,int)int"
    db        10
    db        "type m_dll5_int=ref function(int,int,int,int,int)int"
    db        10
    db        "type m_dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int"
    db        10
    db        10
    db        "type m_dll0_r64=ref function:r64"
    db        10
    db        "type m_dll1_r64=ref function(int)r64"
    db        10
    db        "type m_dll2_r64=ref function(int,int)r64"
    db        10
    db        10
    db        10
    db        "export function os_calldllfunction(ref proc fnaddr,"
    db        10
    db        9
    db        9
    db        "int retcode, nargs, ref[]i64 args, ref[]byte argcodes)u64 ="
    db        10
    db        "!retcode is 'R' or 'I'"
    db        10
    db        "!each argcodes element is 'R' or 'I' too"
    db        10
    db        "!The x64 version can work with any combination."
    db        10
    db        "!Here, for C, only some combinations are dealt with:"
    db        10
    db        "! I result, params all I (not all param counts)"
    db        10
    db        "! R result, params all I (not all param counts)"
    db        10
    db        "!Mixed params, for arbitrary return type, not handled (not really detected either)"
    db        10
    db        10
    db        9
    db        "u64 a"
    db        10
    db        9
    db        "r64 x"
    db        10
    db        9
    db        "int oddstack, nextra, pushedbytes"
    db        10
    db        10
    db        "!CPL "
    db        34
    db        "/////CCCCCCCCCCCCCCCCCC"
    db        34
    db        10
    db        10
    db        9
    db        "if retcode='I' then"
    db        10
    db        9
    db        9
    db        "return calldll_cint(fnaddr,args,nargs)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return calldll_creal(fnaddr,args,nargs)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        9
    db        10
    db        10
    db        "global function os_pushargs(ref[]u64 args, int nargs, nextra,"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "ref proc fnaddr, int isfloat)u64="
    db        10
    db        9
    db        "u64 a"
    db        10
    db        9
    db        "r64 x"
    db        10
    db        "!ABORTPROGRAM("
    db        34
    db        "PUSHARGS/C NOT READY"
    db        34
    db        ")"
    db        10
    db        10
    db        9
    db        "return os_calldllfunction(fnaddr, (isfloat|0|'I'), nargs, cast(args), nil)"
    db        10
    db        10
    db        10
    db        "!"
    db        9
    db        "return a"
    db        10
    db        "end"
    db        10
    db        10
    db        "function calldll_cint (ref proc fnaddr,ref[]i64 params,int nparams)i64="
    db        10
    db        "switch nparams"
    db        10
    db        "when 0 then"
    db        10
    db        9
    db        "return dll0_int(fnaddr)^()"
    db        10
    db        "when 1 then"
    db        10
    db        9
    db        "return dll1_int(fnaddr)^(params^[1])"
    db        10
    db        "when 2 then"
    db        10
    db        9
    db        "return dll2_int(fnaddr)^(params^[1],params^[2])"
    db        10
    db        "when 3 then"
    db        10
    db        9
    db        "return dll3_int(fnaddr)^(params^[1],params^[2],params^[3])"
    db        10
    db        "when 4 then"
    db        10
    db        9
    db        "return dll4_int(fnaddr)^(params^[1],params^[2],params^[3],"
    db        10
    db        9
    db        9
    db        9
    db        "params^[4])"
    db        10
    db        "when 5 then"
    db        10
    db        9
    db        "return dll5_int(fnaddr)^(params^[1],params^[2],params^[3],"
    db        10
    db        9
    db        9
    db        9
    db        "params^[4], params^[5])"
    db        10
    db        "when 6 then"
    db        10
    db        9
    db        "return dll6_int(fnaddr)^(params^[1],params^[2],params^[3],"
    db        10
    db        9
    db        9
    db        9
    db        "params^[4], params^[5],params^[6])"
    db        10
    db        "when 8 then "
    db        10
    db        9
    db        "return (dll8_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8])"
    db        10
    db        "when 9 then "
    db        10
    db        9
    db        "return (dll9_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9])"
    db        10
    db        "when 10 then "
    db        10
    db        9
    db        "return (dll10_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9],params^[10])"
    db        10
    db        "when 11 then "
    db        10
    db        9
    db        "return (dll11_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9],params^[10],"
    db        9
    db        "params^[11])"
    db        10
    db        10
    db        "when 12 then "
    db        10
    db        9
    db        "return (dll12_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9],params^[10],"
    db        9
    db        "params^[11],params^[12])"
    db        10
    db        10
    db        "!when 14 then "
    db        10
    db        "!"
    db        9
    db        "return (dll14_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9],params^[10],"
    db        9
    db        "params^[11],params^[12],"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "params^[13],params^[14])"
    db        10
    db        "!"
    db        10
    db        "else"
    db        10
    db        9
    db        "cpl nparams"
    db        10
    db        9
    db        "println "
    db        34
    db        "calldll/c/int unsupported # of params"
    db        34
    db        ", nparams"
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end switch"
    db        10
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "function calldll_creal (ref proc fnaddr,ref[]i64 params,int nparams)i64="
    db        10
    db        "r64 x"
    db        10
    db        10
    db        "switch nparams"
    db        10
    db        "when 0 then"
    db        10
    db        9
    db        "return dll0_r64(fnaddr)^()"
    db        10
    db        "when 1 then"
    db        10
    db        9
    db        "os_dummycall(params^[1],params^[2],params^[3],params^[4])"
    db        10
    db        9
    db        "x:=dll1_r64(fnaddr)^(params^[1])"
    db        10
    db        "when 2 then"
    db        10
    db        9
    db        "x:=dll2_r64(fnaddr)^(params^[1],params^[2])"
    db        10
    db        "else"
    db        10
    db        9
    db        "println "
    db        34
    db        "calldll/c/real too many params"
    db        34
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end switch"
    db        10
    db        "return i64@(x)"
    db        10
    db        "end"
    db        10
    db        10
    db        10
    db        "global proc os_dummycall(r64 a,b,c,d)="
    db        10
    db        "end"
    db        10
    db        0
L11485:
    db        "export function os_calldllfunction("
    db        10
    db        9
    db        "ref proc fnaddr,"
    db        10
    db        9
    db        "int retcode, nargs,"
    db        10
    db        9
    db        "ref[]i64 args,"
    db        10
    db        9
    db        "ref[]byte argcodes)u64 ="
    db        10
    db        10
    db        9
    db        "u64 a"
    db        10
    db        9
    db        "r64 x"
    db        10
    db        9
    db        "int nextra := 0, pushedbytes"
    db        10
    db        10
    db        "!Stack is 16-byte aligned at this point"
    db        10
    db        10
    db        9
    db        "if nargs<4 then"
    db        10
    db        9
    db        9
    db        "nextra:=4-nargs"
    db        9
    db        9
    db        9
    db        "!need at least 4 slots for shadow space"
    db        10
    db        9
    db        "elsif nargs.odd then"
    db        9
    db        9
    db        "!need one more for a 16-byte-aligned stack"
    db        10
    db        9
    db        9
    db        "nextra:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "pushedbytes:=(nextra+nargs)*8"
    db        10
    db        10
    db        9
    db        "to nextra do"
    db        10
    db        9
    db        9
    db        "asm push 0"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "for i:=nargs downto 1 do"
    db        10
    db        9
    db        9
    db        "a:=args[i]"
    db        9
    db        9
    db        9
    db        9
    db        "!get generic 64-bit value to push"
    db        10
    db        9
    db        9
    db        "asm push u64 [a]"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        "! blindly load first 4 args to both int/float regs, whether used or not,"
    db        10
    db        "! and assuming calling a variadic function whether it is or not"
    db        10
    db        10
    db        9
    db        "assem"
    db        10
    db        9
    db        9
    db        "mov D10,   [Dstack]"
    db        10
    db        9
    db        9
    db        "movq XMM0, [Dstack]"
    db        10
    db        9
    db        9
    db        "mov D11,   [Dstack+8]"
    db        10
    db        9
    db        9
    db        "movq XMM1, [Dstack+8]"
    db        10
    db        9
    db        9
    db        "mov D12,   [Dstack+16]"
    db        10
    db        9
    db        9
    db        "movq XMM2, [Dstack+16]"
    db        10
    db        9
    db        9
    db        "mov D13,   [Dstack+24]"
    db        10
    db        9
    db        9
    db        "movq XMM3, [Dstack+24]"
    db        10
    db        9
    db        "end"
    db        10
    db        10
    db        9
    db        "if retcode='I' then"
    db        10
    db        9
    db        9
    db        "a:=(ref func:i64(fnaddr))^()"
    db        10
    db        9
    db        9
    db        "asm add Dstack,[pushedbytes]"
    db        10
    db        9
    db        9
    db        "return a"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "x:=(ref func:r64(fnaddr))^()"
    db        10
    db        9
    db        9
    db        "asm add Dstack,[pushedbytes]"
    db        10
    db        9
    db        9
    db        "return u64@(x)"
    db        9
    db        9
    db        9
    db        "!(type-punning cast)"
    db        10
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        9
    db        10
    db        0
L11484:
    db        "!import clib"
    db        10
    db        "!import mlib"
    db        10
    db        "!"
    db        10
    db        "!importlib cstd="
    db        10
    db        "!"
    db        9
    db        "clang proc     sleep"
    db        9
    db        "(word32)"
    db        10
    db        "!end"
    db        10
    db        10
    db        "record termios ="
    db        10
    db        9
    db        "i32 c_iflag"
    db        10
    db        9
    db        "i32 c_oflag"
    db        10
    db        9
    db        "i32 c_cflag"
    db        10
    db        9
    db        "i32 c_lflag"
    db        10
    db        9
    db        "char c_line"
    db        10
    db        9
    db        "[32]char c_cc"
    db        9
    db        9
    db        9
    db        9
    db        "!at offset 17"
    db        10
    db        9
    db        "[3]byte filler"
    db        10
    db        9
    db        "i32 c_ispeed"
    db        9
    db        9
    db        9
    db        9
    db        "!at offset 52"
    db        10
    db        9
    db        "i32 c_ospeed"
    db        10
    db        "end"
    db        10
    db        10
    db        "!importdll dlstuff="
    db        10
    db        "importdll msvcrt="
    db        10
    db        9
    db        "func dlopen"
    db        9
    db        9
    db        9
    db        "(ichar, i32)ref void"
    db        10
    db        9
    db        "func dlsym"
    db        9
    db        9
    db        9
    db        "(ref void, ichar)ref void"
    db        10
    db        9
    db        "func tcgetattr"
    db        9
    db        9
    db        "(i32, ref termios) i32"
    db        10
    db        9
    db        "func tcsetattr"
    db        9
    db        9
    db        "(i32, i32, ref termios) i32"
    db        10
    db        9
    db        "func gettimeofday"
    db        9
    db        "(ref timeval, ref void) i32"
    db        10
    db        9
    db        "func gmtime_r  "
    db        9
    db        "   (ref i64, ref tm_rec) ref void"
    db        10
    db        9
    db        "proc stdin"
    db        10
    db        9
    db        "proc stdout"
    db        10
    db        "end"
    db        10
    db        " "
    db        10
    db        "record timeval ="
    db        10
    db        9
    db        "i64 tv_sec"
    db        10
    db        9
    db        "i64 tv_usec"
    db        10
    db        "end"
    db        10
    db        10
    db        "record tm_rec ="
    db        10
    db        9
    db        "i32 tm_sec"
    db        10
    db        9
    db        "i32 tm_min"
    db        10
    db        9
    db        "i32 tm_hour"
    db        10
    db        9
    db        "i32 tm_mday"
    db        10
    db        10
    db        9
    db        "i32 tm_mon"
    db        10
    db        9
    db        "i32 tm_year"
    db        10
    db        9
    db        "i32 tm_wday"
    db        10
    db        9
    db        "i32 tm_yday"
    db        10
    db        9
    db        "i32 tm_isdst"
    db        10
    db        9
    db        "[20]byte padding"
    db        10
    db        "end"
    db        10
    db        10
    db        "!this record is used by some apps, so these fields must be present"
    db        10
    db        "export record rsystemtime ="
    db        10
    db        9
    db        "i32 year"
    db        10
    db        9
    db        "i32 month"
    db        10
    db        9
    db        "i32 dayofweek"
    db        10
    db        9
    db        "i32 day"
    db        10
    db        9
    db        "i32 hour"
    db        10
    db        9
    db        "i32 minute"
    db        10
    db        9
    db        "i32 second"
    db        10
    db        9
    db        "int milliseconds"
    db        10
    db        "end"
    db        10
    db        10
    db        "int init_flag=0"
    db        10
    db        10
    db        10
    db        "export proc os_init="
    db        10
    db        9
    db        "init_flag:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int ="
    db        10
    db        9
    db        "return system(cmdline)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_execcmd(ichar cmdline, int newconsole)int ="
    db        10
    db        9
    db        "return system(cmdline)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getch:int="
    db        10
    db        9
    db        "const ICANON  = 2"
    db        10
    db        9
    db        "const ECHO    = 8"
    db        10
    db        9
    db        "const TCSANOW = 0"
    db        10
    db        9
    db        "const ISIG    = 1"
    db        10
    db        10
    db        9
    db        "termios old,new"
    db        10
    db        9
    db        "char ch"
    db        10
    db        10
    db        9
    db        "tcgetattr(0,&old)"
    db        10
    db        9
    db        "new:=old"
    db        10
    db        9
    db        "new.c_lflag iand:=inot ICANON"
    db        10
    db        9
    db        "new.c_lflag iand:=inot ECHO"
    db        10
    db        9
    db        "new.c_lflag iand:=inot ISIG"
    db        10
    db        10
    db        9
    db        "tcsetattr(0,TCSANOW,&new)"
    db        10
    db        10
    db        9
    db        "ch:=getchar()"
    db        10
    db        10
    db        9
    db        "tcsetattr(0,TCSANOW,&old)"
    db        10
    db        10
    db        9
    db        "return ch"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_kbhit:int="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "kbhit"
    db        34
    db        ")"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_flushkeys="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "flushkeys"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getconsolein:ref void="
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getconsoleout:ref void="
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_proginstance:ref void="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "PROGINST"
    db        34
    db        ")"
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getdllinst(ichar name)u64="
    db        10
    db        9
    db        "const RTLD_LAZY=1"
    db        10
    db        9
    db        "ref void h"
    db        10
    db        10
    db        9
    db        "h:=dlopen(name,RTLD_LAZY)"
    db        10
    db        10
    db        9
    db        "if h=nil then"
    db        10
    db        9
    db        9
    db        "if strcmp(name,"
    db        34
    db        "msvcrt"
    db        34
    db        ")=0 then"
    db        9
    db        9
    db        9
    db        "!might be linux"
    db        10
    db        9
    db        9
    db        9
    db        "h:=dlopen("
    db        34
    db        "libc.so.6"
    db        34
    db        ",RTLD_LAZY);"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return cast(h)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getdllprocaddr(int hlib,ichar name)ref void="
    db        10
    db        9
    db        "ref void fnaddr"
    db        10
    db        10
    db        9
    db        "if hlib=0 then"
    db        10
    db        9
    db        9
    db        "return nil"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fnaddr:=dlsym(cast(int(hlib)), name)"
    db        10
    db        9
    db        "return fnaddr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_initwindows="
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getchx:int="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "getchx"
    db        34
    db        ")"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getos=>ichar="
    db        10
    db        "!"
    db        9
    db        "if $targetbits=32 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return "
    db        34
    db        "L32"
    db        34
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return "
    db        34
    db        "L64"
    db        34
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_gethostsize=>int="
    db        10
    db        9
    db        "return 64"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_iswindows:int="
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_shellexec(ichar opc, file)int="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "SHELL EXEC"
    db        34
    db        ")"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc  os_sleep(int a)="
    db        10
    db        "!*!"
    db        9
    db        "sleep(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getstdin:filehandle ="
    db        10
    db        9
    db        "ref filehandle pf:=cast(stdin)"
    db        10
    db        9
    db        "return pf^"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getstdout:filehandle ="
    db        10
    db        9
    db        "ref filehandle pf:=cast(stdout)"
    db        10
    db        9
    db        "return pf^"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_gethostname:ichar="
    db        10
    db        "!"
    db        9
    db        "abortprogram("
    db        34
    db        "gethostname"
    db        34
    db        ")"
    db        10
    db        9
    db        "return "
    db        34
    db        34
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getmpath:ichar="
    db        10
    db        "!"
    db        9
    db        "abortprogram("
    db        34
    db        "getmpath"
    db        34
    db        ")"
    db        10
    db        9
    db        "return "
    db        34
    db        34
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_exitprocess(int x)="
    db        10
    db        9
    db        "stop"
    db        10
    db        "!"
    db        9
    db        "_exit(0)"
    db        10
    db        "!"
    db        9
    db        "ExitProcess(x)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_clock:i64="
    db        10
    db        9
    db        "if os_iswindows() then"
    db        10
    db        9
    db        9
    db        "return clock()"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return clock()/1000"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_ticks:i64="
    db        10
    db        9
    db        "return clock()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getclockspersec:i64="
    db        10
    db        9
    db        "return (os_iswindows()|1000|1000'000)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_setmesshandler(ref void addr)="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "SETMESSHANDLER"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        "wndproc_callbackfn:=addr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_hpcounter:i64="
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_hpfrequency:i64="
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_filelastwritetime(ichar filename)i64="
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_getsystime(ref rsystemtime tm)="
    db        10
    db        9
    db        "timeval tv"
    db        10
    db        9
    db        "tm_rec tmr"
    db        10
    db        10
    db        10
    db        9
    db        "gettimeofday(&tv, nil)"
    db        10
    db        9
    db        "gmtime_r(&tv.tv_sec, &tmr)"
    db        10
    db        10
    db        9
    db        "tm.year := tmr.tm_year + 1900"
    db        10
    db        9
    db        "tm.month := tmr.tm_mon + 1"
    db        10
    db        9
    db        "tm.dayofweek := tmr.tm_wday + 1"
    db        10
    db        9
    db        "tm.day := tmr.tm_mday"
    db        10
    db        9
    db        "tm.hour := tmr.tm_hour"
    db        10
    db        9
    db        "tm.minute := tmr.tm_min"
    db        10
    db        9
    db        "tm.second := tmr.tm_sec"
    db        10
    db        9
    db        "tm.milliseconds := tv.tv_usec/1000"
    db        10
    db        "tm.month:=1"
    db        9
    db        9
    db        9
    db        "!avoid crashing the M compiler"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_peek="
    db        10
    db        "end"
    db        10
    db        10
    db        "export func  os_allocexecmem(int n)ref byte="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "No allocexec"
    db        34
    db        ")"
    db        10
    db        9
    db        "nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int="
    db        10
    db        9
    db        "0"
    db        10
    db        "end"
    db        10
    db        0
L11483:
    db        "const wm_destroy=2"
    db        10
    db        10
    db        "export type wt_word"
    db        9
    db        "= u16"
    db        10
    db        "export type wt_wordpm"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_bool"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_dword"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_wchar"
    db        9
    db        "= u16"
    db        10
    db        "export type wt_wcharpm"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_char"
    db        9
    db        "= byte"
    db        10
    db        "export type wt_ichar"
    db        9
    db        "= ref char"
    db        10
    db        "export type wt_ptr"
    db        9
    db        9
    db        "= ref void"
    db        10
    db        "export type wt_wndproc"
    db        9
    db        "= ref proc"
    db        10
    db        "export type wt_handle"
    db        9
    db        "= ref void"
    db        10
    db        "export type wt_int"
    db        9
    db        9
    db        "= i32"
    db        10
    db        "export type wt_uint"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_long"
    db        9
    db        "= i32"
    db        10
    db        "export type wt_wparam"
    db        9
    db        "= word"
    db        10
    db        "export type wt_lparam"
    db        9
    db        "= word"
    db        10
    db        "export type wt_point"
    db        9
    db        "= rpoint"
    db        10
    db        10
    db        "export record rsystemtime ="
    db        10
    db        9
    db        "wt_word year"
    db        10
    db        9
    db        "wt_word month"
    db        10
    db        9
    db        "wt_word dayofweek"
    db        10
    db        9
    db        "wt_word day"
    db        10
    db        9
    db        "wt_word hour"
    db        10
    db        9
    db        "wt_word minute"
    db        10
    db        9
    db        "wt_word second"
    db        10
    db        9
    db        "wt_word milliseconds"
    db        10
    db        "end"
    db        10
    db        10
    db        "importdll $windowsdlls="
    db        10
    db        "!"
    db        9
    db        "func "
    db        34
    db        "VirtualAlloc"
    db        34
    db        "(wt_ptr, dint,wt_dword,wt_dword)wt_ptr"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetStdHandle"
    db        34
    db        "(wt_dword)wt_handle"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetConsoleScreenBufferInfo"
    db        34
    db        "(wt_handle,wt_ptr)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "SetConsoleCtrlHandler"
    db        34
    db        "(wt_wndproc,int)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "SetConsoleMode"
    db        34
    db        "(wt_handle,wt_dword)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "CreateProcessA"
    db        34
    db        "(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "wt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetLastError"
    db        34
    db        ":wt_dword"
    db        10
    db        9
    db        "func "
    db        34
    db        "WaitForSingleObject"
    db        34
    db        "(wt_handle,wt_dword)wt_dword"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetExitCodeProcess"
    db        34
    db        "(wt_handle,wt_ptr)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "CloseHandle"
    db        34
    db        "(wt_handle)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetNumberOfConsoleInputEvents"
    db        34
    db        "(wt_handle,wt_ptr)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "FlushConsoleInputBuffer"
    db        34
    db        "(wt_handle)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "LoadLibraryA"
    db        34
    db        "(wt_ichar)wt_handle"
    db        10
    db        "!"
    db        9
    db        "func "
    db        34
    db        "GetProcAddress"
    db        34
    db        "(wt_handle,wt_ichar)wt_wndproc"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetProcAddress"
    db        34
    db        "(wt_handle,wt_ichar)ref void"
    db        10
    db        9
    db        "func "
    db        34
    db        "LoadCursorA"
    db        34
    db        "(wt_handle,wt_ichar)wt_handle"
    db        10
    db        9
    db        "func "
    db        34
    db        "RegisterClassExA"
    db        34
    db        "(wt_ptr)wt_wordpm"
    db        10
    db        9
    db        "func "
    db        34
    db        "DefWindowProcA"
    db        34
    db        "(wt_handle,wt_uint,wt_wparam,wt_lparam)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "ReadConsoleInputA"
    db        34
    db        "(wt_handle,wt_ptr,wt_dword,wt_ptr)int"
    db        10
    db        9
    db        "proc "
    db        34
    db        "Sleep"
    db        34
    db        "(wt_dword)"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetModuleFileNameA"
    db        34
    db        "(wt_handle,wt_ichar,wt_dword)wt_dword"
    db        10
    db        10
    db        9
    db        "proc "
    db        34
    db        "ExitProcess"
    db        34
    db        "(wt_uint)"
    db        10
    db        9
    db        "proc "
    db        34
    db        "PostQuitMessage"
    db        34
    db        "(wt_int)"
    db        10
    db        10
    db        9
    db        "proc "
    db        34
    db        "MessageBoxA"
    db        34
    db        "(wt_int x=0,wt_ichar message, caption="
    db        34
    db        "Caption"
    db        34
    db        ",wt_int y=0)"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "QueryPerformanceCounter"
    db        34
    db        "(ref i64)wt_bool"
    db        10
    db        9
    db        "func "
    db        34
    db        "QueryPerformanceFrequency"
    db        34
    db        "(ref i64)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "CreateFileA"
    db        34
    db        "(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetFileTime"
    db        34
    db        "(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool"
    db        10
    db        10
    db        9
    db        "proc "
    db        34
    db        "GetSystemTime"
    db        34
    db        "(ref rsystemtime)"
    db        10
    db        9
    db        "proc "
    db        34
    db        "GetLocalTime"
    db        34
    db        "(ref rsystemtime)"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "GetTickCount64"
    db        34
    db        ":u64"
    db        10
    db        9
    db        "func "
    db        34
    db        "PeekMessageA"
    db        34
    db        9
    db        9
    db        "(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "GetCommandLineA"
    db        34
    db        ":ichar"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "VirtualAlloc"
    db        34
    db        " (ref void, wt_dword, wt_dword, wt_dword)ref void"
    db        10
    db        9
    db        "func "
    db        34
    db        "VirtualProtect"
    db        34
    db        " (ref void, wt_dword, wt_dword, ref wt_dword)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "WriteConsoleA"
    db        34
    db        " (ref void, ref void, i32, ref i32, ref void)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "FindFirstFileA"
    db        34
    db        " (wt_ichar,ref rfinddata)wt_handle"
    db        10
    db        9
    db        "func "
    db        34
    db        "FindNextFileA"
    db        34
    db        "  (wt_handle, ref rfinddata)wt_bool"
    db        10
    db        9
    db        "func "
    db        34
    db        "FindClose"
    db        34
    db        "      (wt_handle)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "MessageBeep"
    db        34
    db        "    (i32)wt_bool"
    db        10
    db        9
    db        "func "
    db        34
    db        "Beep"
    db        34
    db        "    (i32 freq, dur)wt_bool"
    db        10
    db        "end"
    db        10
    db        10
    db        "record input_record = $caligned"
    db        10
    db        9
    db        "wt_word"
    db        9
    db        "eventtype"
    db        10
    db        "!"
    db        9
    db        "u16"
    db        9
    db        "padding"
    db        10
    db        9
    db        9
    db        "wt_bool"
    db        9
    db        "keydown"
    db        9
    db        9
    db        9
    db        "!key event record (was inside 'Event' union in win32)"
    db        10
    db        9
    db        9
    db        "wt_word"
    db        9
    db        "repeatcount"
    db        10
    db        9
    db        9
    db        "wt_word"
    db        9
    db        "virtualkeycode"
    db        10
    db        9
    db        9
    db        "wt_word"
    db        9
    db        "virtualscancode"
    db        10
    db        9
    db        9
    db        "union"
    db        10
    db        9
    db        9
    db        9
    db        "wt_word unicodechar"
    db        10
    db        9
    db        9
    db        9
    db        "wt_char asciichar"
    db        10
    db        9
    db        9
    db        "end"
    db        10
    db        9
    db        9
    db        "wt_dword controlkeystate"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rspoint=(i16 x,y)"
    db        10
    db        10
    db        "record rsrect="
    db        10
    db        9
    db        "i16 leftx,top,rightx,bottom"
    db        10
    db        "end"
    db        10
    db        10
    db        "global record rpoint ="
    db        10
    db        9
    db        "wt_long x,y"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rconsole="
    db        10
    db        9
    db        "rspoint size,pos"
    db        10
    db        9
    db        "u16 attributes"
    db        10
    db        9
    db        "rsrect window"
    db        10
    db        9
    db        "rspoint maxwindowsize"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rstartupinfo ="
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "size"
    db        10
    db        9
    db        "u32 dummy1"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "reserved"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "desktop"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "title"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "x"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "y"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "xsize"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "ysize"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "xcountchars"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "ycountchars"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "fillattribute"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "flags"
    db        10
    db        9
    db        "wt_word"
    db        9
    db        9
    db        "showwindow"
    db        10
    db        9
    db        "wt_word"
    db        9
    db        9
    db        "reserved2"
    db        10
    db        9
    db        "u32 dummy2"
    db        10
    db        9
    db        "wt_ptr"
    db        9
    db        9
    db        "reserved4"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "stdinput"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "stdoutput"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "stderror"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rprocess_information ="
    db        10
    db        9
    db        "wt_handle process"
    db        10
    db        9
    db        "wt_handle thread"
    db        10
    db        9
    db        "wt_dword processid"
    db        10
    db        9
    db        "wt_dword threadid"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rwndclassex ="
    db        10
    db        9
    db        "wt_uint"
    db        9
    db        9
    db        "size"
    db        10
    db        9
    db        "wt_uint"
    db        9
    db        9
    db        "style"
    db        10
    db        9
    db        "wt_wndproc"
    db        9
    db        "wndproc"
    db        10
    db        9
    db        "wt_int"
    db        9
    db        9
    db        "clsextra"
    db        10
    db        9
    db        "wt_int"
    db        9
    db        9
    db        "wndextra"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "instance"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "icon"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "cursor"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "background"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "menuname"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "classname"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "iconsm"
    db        10
    db        "end"
    db        10
    db        10
    db        "global record rmsg ="
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "hwnd"
    db        10
    db        9
    db        "wt_uint"
    db        9
    db        9
    db        "message"
    db        10
    db        9
    db        "u32"
    db        9
    db        9
    db        "dummy1"
    db        10
    db        9
    db        "wt_wparam"
    db        9
    db        "wParam"
    db        10
    db        9
    db        "wt_lparam"
    db        9
    db        "lParam"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "time"
    db        10
    db        9
    db        "u32"
    db        9
    db        9
    db        "dummy2"
    db        10
    db        9
    db        "wt_point"
    db        9
    db        "pt"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rfiletime ="
    db        10
    db        9
    db        "wt_dword lowdatetime"
    db        10
    db        9
    db        "wt_dword highdatetime"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rfinddata ="
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "fileattributes"
    db        10
    db        9
    db        "rfiletime"
    db        9
    db        "creationtime"
    db        10
    db        9
    db        "rfiletime"
    db        9
    db        "lastaccesstime"
    db        10
    db        9
    db        "rfiletime"
    db        9
    db        "lastwritetime"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "filesizehigh"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "filesizelow"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "reserved0"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "reserved1"
    db        10
    db        9
    db        "[260]char"
    db        9
    db        "filename"
    db        10
    db        9
    db        "[14]char"
    db        9
    db        9
    db        "altfilename"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "obs1, obs2"
    db        10
    db        9
    db        "wt_word"
    db        9
    db        9
    db        "obs3"
    db        10
    db        "end"
    db        10
    db        10
    db        "const NORMAL_PRIORITY_CLASS=32"
    db        10
    db        "const CREATE_NEW_CONSOLE=16"
    db        10
    db        "const DETACHED_PROCESS=16"
    db        10
    db        10
    db        "const MEM_COMMIT"
    db        9
    db        9
    db        9
    db        9
    db        "= 4096"
    db        10
    db        "const MEM_RESERVE"
    db        9
    db        9
    db        9
    db        9
    db        "= 8192"
    db        10
    db        "const PAGE_EXECUTE"
    db        9
    db        9
    db        9
    db        9
    db        "= 16"
    db        10
    db        "const PAGE_EXECUTE_READ"
    db        9
    db        9
    db        9
    db        "= 32"
    db        10
    db        "const PAGE_EXECUTE_READWRITE"
    db        9
    db        "= 64"
    db        10
    db        "const PAGE_NOACCESS"
    db        9
    db        9
    db        9
    db        9
    db        "= 1"
    db        10
    db        10
    db        10
    db        "export wt_handle hconsole, hconsolein"
    db        10
    db        10
    db        "input_record lastkey, pendkey"
    db        10
    db        "int keypending"
    db        9
    db        9
    db        9
    db        "!whether pendkey contains a new key event detected by flushkbd"
    db        10
    db        10
    db        "int hpfreq"
    db        9
    db        9
    db        9
    db        9
    db        "!counts per msec"
    db        10
    db        10
    db        10
    db        "ref func (ref void)int wndproc_callbackfn=nil"
    db        9
    db        "!windows call-back: address of handler"
    db        10
    db        10
    db        "int init_flag=0"
    db        10
    db        10
    db        "export proc os_init="
    db        10
    db        "!general initialisation"
    db        10
    db        9
    db        "hconsole:=GetStdHandle(u32(-11))"
    db        10
    db        9
    db        "hconsolein:=GetStdHandle(u32(-10))"
    db        10
    db        10
    db        9
    db        "lastkey.repeatcount:=0"
    db        10
    db        9
    db        "keypending:=0"
    db        10
    db        10
    db        9
    db        "SetConsoleCtrlHandler(nil,1)"
    db        10
    db        10
    db        9
    db        "SetConsoleMode(hconsole,1 ior 2)"
    db        10
    db        10
    db        9
    db        "init_flag:=1"
    db        10
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int ="
    db        10
    db        9
    db        "wt_dword exitcode"
    db        10
    db        9
    db        "int status"
    db        10
    db        9
    db        "int cflags:=0"
    db        10
    db        10
    db        9
    db        "rstartupinfo si"
    db        10
    db        9
    db        "rprocess_information xpi"
    db        10
    db        10
    db        9
    db        "clear si"
    db        10
    db        9
    db        "clear xpi"
    db        10
    db        10
    db        9
    db        "case newconsole"
    db        10
    db        9
    db        "when 0 then cflags := NORMAL_PRIORITY_CLASS"
    db        10
    db        9
    db        "when 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE"
    db        10
    db        9
    db        "when 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "si.size := rstartupinfo.bytes"
    db        10
    db        10
    db        9
    db        "status:=CreateProcessA("
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "cmdline,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "1,"
    db        10
    db        9
    db        9
    db        "cflags,"
    db        10
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "&si,"
    db        10
    db        9
    db        9
    db        "&xpi )"
    db        10
    db        10
    db        9
    db        "if status=0 then"
    db        9
    db        9
    db        "!fails"
    db        10
    db        9
    db        9
    db        "status:=GetLastError()"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Winexec error: %lld"
    db        92
    db        "n"
    db        34
    db        ",status)"
    db        10
    db        9
    db        9
    db        "return -1"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "WaitForSingleObject(xpi.process, 0xFFFF'FFFF)"
    db        10
    db        9
    db        "GetExitCodeProcess(xpi.process,&exitcode)"
    db        10
    db        10
    db        9
    db        "CloseHandle(xpi.process)"
    db        10
    db        9
    db        "CloseHandle(xpi.thread)"
    db        10
    db        10
    db        9
    db        "return exitcode"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_execcmd(ichar cmdline, int newconsole=0)int ="
    db        10
    db        9
    db        "rstartupinfo si"
    db        10
    db        9
    db        "rprocess_information xpi"
    db        10
    db        10
    db        9
    db        "clear si"
    db        10
    db        9
    db        "clear xpi"
    db        10
    db        10
    db        9
    db        "si.size := rstartupinfo.bytes"
    db        10
    db        10
    db        9
    db        "CreateProcessA( nil,"
    db        10
    db        9
    db        9
    db        "cmdline,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "1,"
    db        10
    db        9
    db        9
    db        "NORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "&si,"
    db        10
    db        9
    db        9
    db        "&xpi )"
    db        10
    db        10
    db        9
    db        "CloseHandle(xpi.process)"
    db        10
    db        9
    db        "CloseHandle(xpi.thread)"
    db        10
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getch:int="
    db        10
    db        9
    db        "int k"
    db        10
    db        10
    db        9
    db        "k:=os_getchx() iand 255"
    db        10
    db        10
    db        9
    db        "return k"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_kbhit:int="
    db        10
    db        9
    db        "wt_dword count"
    db        10
    db        10
    db        9
    db        "unless init_flag then os_init() end"
    db        10
    db        10
    db        9
    db        "GetNumberOfConsoleInputEvents(hconsolein,&count)"
    db        10
    db        9
    db        "return count>1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getdllinst(ichar name)u64="
    db        10
    db        9
    db        "wt_handle hinst"
    db        10
    db        10
    db        9
    db        "hinst:=LoadLibraryA(name)"
    db        10
    db        9
    db        "return cast(hinst)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getdllprocaddr(int hinst,ichar name)ref void="
    db        10
    db        9
    db        "return GetProcAddress(cast(hinst),name)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_initwindows="
    db        10
    db        9
    db        "os_init()"
    db        10
    db        9
    db        "os_gxregisterclass("
    db        34
    db        "pcc001"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_gxregisterclass(ichar classname)="
    db        10
    db        9
    db        "const idcarrow=32512"
    db        10
    db        9
    db        "rwndclassex r"
    db        10
    db        9
    db        "static byte registered"
    db        10
    db        10
    db        9
    db        "if registered then"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "clear r"
    db        10
    db        10
    db        9
    db        "r.size:=r.bytes"
    db        10
    db        9
    db        "r.style:=8 ior 32"
    db        10
    db        9
    db        "r.wndproc:=cast(&mainwndproc)"
    db        10
    db        9
    db        "r.instance:=nil"
    db        10
    db        10
    db        9
    db        "r.icon:=nil"
    db        10
    db        9
    db        "r.cursor:=LoadCursorA(nil,ref void(idcarrow))"
    db        10
    db        9
    db        "r.background:=cast(15+1)"
    db        10
    db        9
    db        "r.menuname:=nil"
    db        10
    db        9
    db        "r.classname:=classname"
    db        10
    db        9
    db        "r.iconsm:=nil"
    db        10
    db        10
    db        9
    db        "if RegisterClassExA(&r)=0 then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Regclass error: %lld %lld"
    db        92
    db        "n"
    db        34
    db        ",classname,GetLastError())"
    db        10
    db        9
    db        9
    db        "stop 1"
    db        10
    db        9
    db        "end"
    db        10
    db        9
    db        "registered:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function mainwndproc ("
    db        10
    db        9
    db        9
    db        "wt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)int="
    db        10
    db        9
    db        "rmsg m"
    db        10
    db        9
    db        "int result"
    db        10
    db        9
    db        "static int count=0"
    db        10
    db        10
    db        "!CPL "
    db        34
    db        "MAINWNDPROC"
    db        34
    db        ",HWND"
    db        10
    db        10
    db        9
    db        "m.hwnd:=hwnd"
    db        10
    db        9
    db        "m.message:=message"
    db        10
    db        9
    db        "m.wParam:=wParam"
    db        10
    db        9
    db        "m.lParam:=lParam"
    db        10
    db        9
    db        "m.pt.x:=0"
    db        10
    db        9
    db        "m.pt.y:=0"
    db        10
    db        9
    db        10
    db        9
    db        "if (wndproc_callbackfn) then"
    db        10
    db        9
    db        9
    db        "result:=(wndproc_callbackfn^)(&m)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "result:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if m.message=wm_destroy then"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if not result then"
    db        10
    db        9
    db        9
    db        "return DefWindowProcA(hwnd,message,wParam,lParam)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_setmesshandler(ref void addr)="
    db        10
    db        9
    db        "wndproc_callbackfn:=addr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getchx:int="
    db        10
    db        "!Q! function  os_getchx_c:int"
    db        10
    db        "!return a 32-bit value containing:"
    db        10
    db        "! 15..B0:"
    db        9
    db        "char code"
    db        10
    db        "! 23..16"
    db        9
    db        "virtual keycode"
    db        10
    db        "! 31..24"
    db        9
    db        "shift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)"
    db        10
    db        9
    db        "const rightaltmask"
    db        9
    db        "= 1"
    db        10
    db        9
    db        "const leftaltmask"
    db        9
    db        "= 2"
    db        10
    db        9
    db        "const leftctrlmask"
    db        9
    db        "= 8"
    db        10
    db        9
    db        "const rightctrlmask"
    db        9
    db        "= 4"
    db        10
    db        9
    db        "const shiftmask"
    db        9
    db        9
    db        "= 16"
    db        10
    db        9
    db        "const capsmask"
    db        9
    db        9
    db        "= 128"
    db        10
    db        9
    db        "const scrollmask"
    db        9
    db        "= 64"
    db        10
    db        9
    db        "int count"
    db        10
    db        9
    db        "int charcode,keyshift,keycode"
    db        10
    db        9
    db        "int altdown,ctrldown,shiftdown,capslock"
    db        10
    db        10
    db        "!os_init() unless init_flag"
    db        10
    db        9
    db        "unless init_flag then os_init() end"
    db        10
    db        10
    db        9
    db        "if keypending then"
    db        10
    db        9
    db        9
    db        "lastkey:=pendkey"
    db        10
    db        9
    db        9
    db        "keypending:=0"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if lastkey.repeatcount=0 then"
    db        10
    db        9
    db        9
    db        9
    db        "repeat"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "count:=0"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "ReadConsoleInputA(hconsolein,&lastkey,1,&count)"
    db        10
    db        9
    db        9
    db        9
    db        "until (lastkey.eventtype=1 and lastkey.keydown=1)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!set shift flags"
    db        10
    db        10
    db        9
    db        "altdown"
    db        9
    db        9
    db        ":= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)"
    db        10
    db        9
    db        "ctrldown"
    db        9
    db        ":= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)"
    db        10
    db        9
    db        "shiftdown"
    db        9
    db        ":= ((lastkey.controlkeystate iand shiftmask)|1|0)"
    db        10
    db        9
    db        "capslock"
    db        9
    db        ":= ((lastkey.controlkeystate iand capsmask)|1|0)"
    db        10
    db        10
    db        9
    db        "--lastkey.repeatcount"
    db        9
    db        9
    db        "!count this key out"
    db        10
    db        10
    db        9
    db        "charcode:=lastkey.asciichar"
    db        10
    db        9
    db        "keycode:=lastkey.virtualkeycode iand 255"
    db        10
    db        10
    db        9
    db        "if charcode<0 then"
    db        10
    db        9
    db        9
    db        "if charcode<-128 then"
    db        10
    db        9
    db        9
    db        9
    db        "charcode:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "charcode+:=256"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might"
    db        10
    db        "!wish to set charcode to the appropriate printed char code (currently charcode will be"
    db        10
    db        "!zero, and keyboard handlers need to detect keycodes such as vkequals)"
    db        10
    db        "!...."
    db        10
    db        10
    db        9
    db        "if altdown and ctrldown and charcode=166 then"
    db        10
    db        9
    db        9
    db        "altdown:=ctrldown:=0"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if altdown or ctrldown then"
    db        10
    db        9
    db        9
    db        9
    db        "charcode:=0"
    db        10
    db        9
    db        9
    db        9
    db        "if keycode>='A' and keycode<= 'Z' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "charcode:=keycode-'@'"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "keyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown"
    db        10
    db        10
    db        9
    db        "return keyshift<<24 ior keycode<<16 ior charcode"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getos=>ichar="
    db        10
    db        9
    db        "return "
    db        34
    db        "W64"
    db        34
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_gethostsize=>int="
    db        10
    db        9
    db        "return 64"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_shellexec(ichar opc, file)int="
    db        10
    db        9
    db        "return system(file)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_sleep(int a)="
    db        10
    db        9
    db        "Sleep(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getstdin:filehandle ="
    db        10
    db        9
    db        "return fopen("
    db        34
    db        "con"
    db        34
    db        ","
    db        34
    db        "rb"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getstdout:filehandle ="
    db        10
    db        9
    db        "return fopen("
    db        34
    db        "con"
    db        34
    db        ","
    db        34
    db        "wb"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_gethostname:ichar="
    db        10
    db        9
    db        "static [300]char name"
    db        10
    db        9
    db        "static int n"
    db        10
    db        10
    db        9
    db        "GetModuleFileNameA(nil,&.name,name.bytes)"
    db        10
    db        9
    db        "return &.name"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getmpath:ichar="
    db        10
    db        "!BART"
    db        10
    db        "!"
    db        9
    db        "return "
    db        34
    db        "C:"
    db        92
    db        92
    db        "m"
    db        92
    db        92
    db        34
    db        10
    db        9
    db        "return F"
    db        34
    db        "C:@@@@"
    db        92
    db        "m"
    db        92
    db        34
    db        " !ABC"
    db        10
    db        "!"
    db        9
    db        "return "
    db        34
    db        "C:@@@@"
    db        92
    db        92
    db        "m"
    db        92
    db        92
    db        34
    db        " !ABC"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_clock:i64="
    db        10
    db        "!"
    db        9
    db        "return clock()"
    db        10
    db        9
    db        "return os_hpcounter()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_ticks:i64="
    db        10
    db        9
    db        "return GetTickCount64()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_iswindows:int="
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_getsystime(ref rsystemtime tm)="
    db        10
    db        9
    db        "GetLocalTime(tm)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_peek="
    db        10
    db        9
    db        "int ticks"
    db        10
    db        9
    db        "static int lastticks"
    db        10
    db        9
    db        "[100]byte m"
    db        10
    db        9
    db        "ticks:=GetTickCount64()"
    db        10
    db        9
    db        "if ticks-lastticks>=1000 then"
    db        10
    db        9
    db        9
    db        "lastticks:=ticks"
    db        10
    db        9
    db        9
    db        "PeekMessageA(&m,nil,0,0,0)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_allocexecmem(int n)ref byte="
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        9
    db        "u32 oldprot"
    db        10
    db        9
    db        "int status"
    db        10
    db        10
    db        9
    db        "p := VirtualAlloc(nil, n, MEM_RESERVE ior MEM_COMMIT, PAGE_NOACCESS)"
    db        10
    db        9
    db        "if p = nil then return nil fi"
    db        10
    db        10
    db        9
    db        "status := VirtualProtect(p, n, PAGE_EXECUTE_READWRITE, &oldprot)"
    db        10
    db        9
    db        "if status = 0 then return nil fi"
    db        10
    db        10
    db        9
    db        "return p"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int="
    db        10
    db        "!filespec is a filename (eg. "
    db        34
    db        "*.dwg"
    db        34
    db        ") with possible drive/path; scan"
    db        10
    db        "!directory for all matching files:"
    db        10
    db        "! Store each file in dest array up to capacity"
    db        10
    db        "! Return:"
    db        10
    db        "!  -1:"
    db        9
    db        "capacity exceeded"
    db        10
    db        "!   N:  number of files found including 0 for no matching files"
    db        10
    db        10
    db        "!t has this value"
    db        10
    db        "! +1  Include normal files only, no sub-directory names"
    db        10
    db        "! +2  Include directories"
    db        10
    db        "! +3  (+1 +2) Include all files including directories"
    db        10
    db        "! +4  Convert to lower case"
    db        10
    db        9
    db        "ref void hfind"
    db        10
    db        9
    db        "rfinddata file"
    db        10
    db        9
    db        "int nfiles:=0"
    db        10
    db        9
    db        "[300]char path"
    db        10
    db        9
    db        "[300]char fullfilename"
    db        10
    db        10
    db        9
    db        "strcpy(path, extractpath(filespec))"
    db        10
    db        10
    db        10
    db        9
    db        "if (hfind:=findfirstfilea(filespec,&file))<>ref void(-1) then"
    db        9
    db        "!at least one file"
    db        10
    db        9
    db        9
    db        "repeat"
    db        10
    db        9
    db        9
    db        9
    db        "if (file.fileattributes iand 16) then"
    db        9
    db        9
    db        "!this is a directory"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if (t iand 2)=0 then nextloop fi"
    db        9
    db        9
    db        "!no directories"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!this is a file"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if (t iand 1)=0 then nextloop fi"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "if nfiles>=capacity then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "nfiles:=-1"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        9
    db        "if (t iand 4) then"
    db        9
    db        9
    db        9
    db        9
    db        "!to lower case"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "convlcstring(file.filename)"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "convlcstring(&.file.filename)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "strcpy(fullfilename, path)"
    db        10
    db        9
    db        9
    db        9
    db        "strcat(fullfilename, file.filename)"
    db        10
    db        10
    db        9
    db        9
    db        9
    db        "dest[++nfiles]:=pcm_copyheapstring(fullfilename)"
    db        10
    db        10
    db        9
    db        9
    db        "until not findnextfilea(hfind,&file)"
    db        10
    db        9
    db        9
    db        "findclose(hfind)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return nfiles"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_hpcounter:int a ="
    db        10
    db        "!return counter such that successive calls indicate duration in msec"
    db        10
    db        10
    db        9
    db        "if hpfreq=0 then"
    db        10
    db        9
    db        9
    db        "hpfreq:=os_hpfreq()/1000"
    db        9
    db        9
    db        "!counts per msec"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "QueryPerformanceCounter(&a)"
    db        10
    db        9
    db        "a/hpfreq"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_hpfreq:int a ="
    db        10
    db        9
    db        "QueryPerformanceFrequency(&a)"
    db        10
    db        9
    db        "a"
    db        10
    db        "end"
    db        10
    db        10
    db        0
L11482:
    db        "export type filehandle=ref void"
    db        10
    db        10
    db        "importdll $cstd="
    db        10
    db        9
    db        "func malloc"
    db        9
    db        9
    db        "(u64)ref void"
    db        10
    db        9
    db        "func realloc"
    db        9
    db        "(ref void, word)ref void"
    db        10
    db        9
    db        "proc free"
    db        9
    db        9
    db        "(ref void)"
    db        10
    db        9
    db        "proc memset"
    db        9
    db        9
    db        "(ref void, i32, word)"
    db        10
    db        9
    db        "proc memcpy"
    db        9
    db        9
    db        "(ref void, ref void, word)"
    db        10
    db        9
    db        "proc memmove"
    db        9
    db        9
    db        "(ref void, ref void, word)"
    db        10
    db        9
    db        "func clock"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "func ftell"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func fseek"
    db        9
    db        9
    db        "(filehandle, i32, i32)i32"
    db        10
    db        9
    db        "func fread"
    db        9
    db        9
    db        "(ref void, word, word, filehandle)word"
    db        10
    db        9
    db        "func fwrite"
    db        9
    db        9
    db        "(ref void, word, word, filehandle)word"
    db        10
    db        9
    db        "func getc"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func ungetc"
    db        9
    db        9
    db        "(i32, filehandle)i32"
    db        10
    db        9
    db        "func fopen"
    db        9
    db        9
    db        "(ichar a, b="
    db        34
    db        "rb"
    db        34
    db        ")filehandle"
    db        10
    db        9
    db        "func fclose"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func fgets"
    db        9
    db        9
    db        "(ichar, int, filehandle)ichar"
    db        10
    db        9
    db        "func remove"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func rename"
    db        9
    db        9
    db        "(ichar, ichar)i32"
    db        10
    db        9
    db        "func getchar"
    db        9
    db        ":i32"
    db        10
    db        9
    db        "proc putchar"
    db        9
    db        "(i32)"
    db        10
    db        9
    db        "proc setbuf"
    db        9
    db        9
    db        "(filehandle, ref byte)"
    db        10
    db        10
    db        9
    db        "func strlen"
    db        9
    db        9
    db        "(ichar)int"
    db        10
    db        9
    db        "func strcpy"
    db        9
    db        9
    db        "(ichar, ichar)ichar"
    db        10
    db        9
    db        "func strcmp"
    db        9
    db        9
    db        "(ichar, ichar)i32"
    db        10
    db        9
    db        "func strncmp"
    db        9
    db        "(ichar, ichar, word)i32"
    db        10
    db        9
    db        "func strncpy"
    db        9
    db        "(ichar, ichar, word)word"
    db        10
    db        9
    db        "func memcmp"
    db        9
    db        9
    db        "(ref void, ref void, word)i32"
    db        10
    db        9
    db        "func strcat"
    db        9
    db        9
    db        "(ichar, ichar)ichar"
    db        10
    db        9
    db        "func tolower"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func toupper"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func isalpha"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func isupper"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func islower"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func isalnum"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func isspace"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func strstr"
    db        9
    db        9
    db        "(ichar, ichar)ichar"
    db        10
    db        9
    db        "func atol"
    db        9
    db        9
    db        "(ichar)int"
    db        10
    db        9
    db        "func atoi"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func strtod"
    db        9
    db        9
    db        "(ichar,ref ref char)r64"
    db        10
    db        9
    db        "func _strdup"
    db        9
    db        "(ichar)ichar"
    db        10
    db        10
    db        9
    db        "func puts"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func printf"
    db        9
    db        9
    db        "(ichar, ...)i32"
    db        10
    db        10
    db        9
    db        "func sprintf"
    db        9
    db        "(ichar, ichar, ...)i32"
    db        10
    db        10
    db        9
    db        "func sscanf"
    db        9
    db        9
    db        "(ichar, ichar, ...)i32"
    db        10
    db        9
    db        "func scanf"
    db        9
    db        9
    db        "(ichar, ...)i32"
    db        10
    db        10
    db        9
    db        "func rand"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "proc srand"
    db        9
    db        9
    db        "(u32)"
    db        10
    db        9
    db        "func system"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        10
    db        9
    db        "func fgetc"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func fputc"
    db        9
    db        9
    db        "(i32,  filehandle)i32"
    db        10
    db        9
    db        "func fprintf"
    db        9
    db        "(filehandle, ichar, ...)i32"
    db        10
    db        9
    db        "func fputs"
    db        9
    db        9
    db        "(ichar,  filehandle)i32"
    db        10
    db        9
    db        "func feof"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func getch"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "func _getch"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "func kbhit"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "func _mkdir"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func mkdir"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func strchr"
    db        9
    db        9
    db        "(ichar,i32)ichar"
    db        10
    db        10
    db        9
    db        "func _setmode"
    db        9
    db        "(i32,i32)i32"
    db        10
    db        10
    db        9
    db        "proc _exit"
    db        9
    db        9
    db        "(i32)"
    db        10
    db        9
    db        "proc "
    db        34
    db        "exit"
    db        34
    db        9
    db        9
    db        "(i32)"
    db        10
    db        "!"
    db        9
    db        "proc `exit"
    db        9
    db        9
    db        "(i32)"
    db        10
    db        9
    db        "func pow"
    db        9
    db        9
    db        "(real,real)real"
    db        10
    db        10
    db        9
    db        "func `sin "
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `cos"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `tan"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `asin"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `acos"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `atan "
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `log"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `log10"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `exp"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `floor"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `ceil"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        10
    db        9
    db        "proc  qsort   "
    db        9
    db        "(ref void, u64, u64, ref proc)"
    db        10
    db        10
    db        "end"
    db        10
    db        10
    db        "export macro strdup=_strdup"
    db        10
    db        10
    db        "importdll $cstdextra="
    db        10
    db        9
    db        "func __getmainargs"
    db        9
    db        "(ref i32, ref void, ref void, int, ref void)i32"
    db        10
    db        "end"
    db        10
    db        10
    db        "export const c_eof"
    db        9
    db        9
    db        "=-1"
    db        10
    db        "export const seek_set"
    db        9
    db        "= 0"
    db        10
    db        "export const seek_curr"
    db        9
    db        "= 1"
    db        10
    db        "export const seek_end"
    db        9
    db        "= 2"
    db        10
    db        0
L11481:
    db        "!const mem_check=1"
    db        10
    db        "const mem_check=0"
    db        10
    db        10
    db        "global [0..300]u64 allocupper"
    db        10
    db        "global int alloccode"
    db        9
    db        9
    db        9
    db        9
    db        "!set by heapalloc"
    db        10
    db        "export int allocbytes"
    db        9
    db        9
    db        9
    db        9
    db        "!set by heapalloc"
    db        10
    db        "export int fdebug=0"
    db        10
    db        "export int rfsize"
    db        10
    db        10
    db        "const threshold=1<<25"
    db        10
    db        "const alloc_step=1<<25"
    db        10
    db        "word maxmemory"
    db        10
    db        "int  maxalloccode"
    db        10
    db        10
    db        "!GLOBAL REF VOID ALLOCBASE"
    db        10
    db        10
    db        "byte pcm_setup=0"
    db        10
    db        10
    db        "int show=0"
    db        10
    db        10
    db        "global int memtotal=0"
    db        10
    db        "export i64 smallmemtotal=0"
    db        10
    db        "global int smallmemobjs=0"
    db        10
    db        "global int maxmemtotal=0"
    db        10
    db        10
    db        "!store all allocated pointers"
    db        10
    db        "const int maxmemalloc=(mem_check|500000|2)"
    db        10
    db        "[maxmemalloc+1]ref i32 memalloctable"
    db        10
    db        "[maxmemalloc+1]i32 memallocsize"
    db        10
    db        10
    db        "const pcheapsize=1048576*2"
    db        10
    db        "ref byte pcheapstart"
    db        10
    db        "ref byte pcheapend"
    db        9
    db        9
    db        9
    db        "!points to first address past heap"
    db        10
    db        "ref byte pcheapptr"
    db        10
    db        10
    db        "const int maxblockindex = 8 "
    db        9
    db        9
    db        "!2048"
    db        10
    db        "export const int maxblocksize = 2048"
    db        10
    db        "export const int $maxblocksizexx = 2048"
    db        10
    db        10
    db        "[0:maxblocksize+1]byte sizeindextable"
    db        9
    db        "!convert byte size to block index 1..maxblockindex"
    db        10
    db        10
    db        "const int size16   = 1"
    db        9
    db        9
    db        9
    db        "!the various index codes"
    db        10
    db        "const int size32   = 2"
    db        10
    db        "const int size64   = 3"
    db        10
    db        "const int size128  = 4"
    db        10
    db        "const int size256  = 5"
    db        10
    db        "const int size512  = 6"
    db        10
    db        "const int size1024 = 7"
    db        10
    db        "const int size2048 = 8"
    db        10
    db        10
    db        "export [0:9]ref word freelist"
    db        10
    db        10
    db        "export record strbuffer ="
    db        10
    db        9
    db        "ichar strptr"
    db        10
    db        9
    db        "i32 length"
    db        10
    db        9
    db        "i32 allocated"
    db        10
    db        "end"
    db        10
    db        10
    db        "export enumdata [0:]ichar pmnames="
    db        10
    db        9
    db        "(pm_end=0,"
    db        9
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_option,"
    db        9
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_sourcefile,"
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_libfile,"
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_colon,"
    db        9
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_extra,"
    db        9
    db        9
    db        "$),"
    db        10
    db        "end"
    db        10
    db        10
    db        "[2]int seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)"
    db        10
    db        10
    db        "!PROC START="
    db        10
    db        "!CPL "
    db        34
    db        "MLIB START"
    db        34
    db        10
    db        "!END"
    db        10
    db        10
    db        10
    db        "export function pcm_alloc(int n)ref void ="
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        10
    db        10
    db        9
    db        "if not pcm_setup then"
    db        10
    db        9
    db        9
    db        "pcm_init()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!GOTO DOLARGE"
    db        10
    db        10
    db        9
    db        "if n>maxblocksize then"
    db        9
    db        9
    db        9
    db        "!large block allocation"
    db        10
    db        "!DOLARGE:"
    db        10
    db        9
    db        9
    db        "alloccode:=pcm_getac(n)"
    db        10
    db        9
    db        9
    db        "allocbytes:=allocupper[alloccode]"
    db        10
    db        10
    db        9
    db        9
    db        "p:=allocmem(allocbytes)"
    db        10
    db        9
    db        9
    db        "if not p then"
    db        10
    db        9
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "pcm_alloc failure"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!CPL "
    db        34
    db        "DOSMALL"
    db        34
    db        10
    db        10
    db        9
    db        "alloccode:=sizeindextable[n]"
    db        9
    db        9
    db        "!Size code := 0,1,2 etc for 0, 16, 32 etc"
    db        10
    db        9
    db        "allocbytes:=allocupper[alloccode]"
    db        10
    db        "!"
    db        9
    db        "smallmemtotal+:=allocbytes"
    db        10
    db        10
    db        9
    db        "if p:=ref byte(freelist[alloccode]) then"
    db        9
    db        9
    db        "!Items of this block size available"
    db        10
    db        9
    db        9
    db        "freelist[alloccode]:=ref word(int((freelist[alloccode])^))"
    db        10
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!No items in freelists: allocate new space in this heap block"
    db        10
    db        9
    db        "p:=pcheapptr"
    db        9
    db        9
    db        9
    db        9
    db        "!Create item at start of remaining pool in heap block"
    db        10
    db        9
    db        "pcheapptr+:=allocbytes"
    db        9
    db        9
    db        9
    db        "!Shrink remaining pool"
    db        10
    db        10
    db        9
    db        "if pcheapptr>=pcheapend then"
    db        9
    db        9
    db        "!Overflows?"
    db        10
    db        9
    db        9
    db        "p:=pcm_newblock(allocbytes)"
    db        9
    db        9
    db        "!Create new heap block, and allocate from start of that"
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return p"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_free(ref void p,int n) ="
    db        10
    db        "!n can be the actual size requested it does not need to be the allocated size"
    db        10
    db        9
    db        "int acode"
    db        10
    db        10
    db        9
    db        "return when n=0 or p=nil"
    db        10
    db        10
    db        9
    db        "if n>maxblocksize then"
    db        9
    db        9
    db        "!large block"
    db        10
    db        9
    db        9
    db        "free(p)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "acode:=sizeindextable[n]"
    db        9
    db        9
    db        "!Size code := 0,1,2 etc for 0, 16, 32 etc"
    db        10
    db        9
    db        9
    db        "cast(p,ref word)^:=word(int(freelist[acode]))"
    db        10
    db        9
    db        9
    db        "freelist[acode]:=p"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_freeac(ref void p,int alloc) ="
    db        10
    db        9
    db        "pcm_free(p,allocupper[alloc])"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_clearmem(ref void p,int n) ="
    db        10
    db        9
    db        "memset(p,0,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_init ="
    db        10
    db        "!set up sizeindextable too"
    db        10
    db        9
    db        "int j, k"
    db        10
    db        9
    db        "i64 size"
    db        10
    db        9
    db        "const limit=1<<33"
    db        10
    db        10
    db        9
    db        "alloccode:=0"
    db        10
    db        9
    db        "if pcm_setup then"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "pcm_newblock(0)"
    db        10
    db        10
    db        9
    db        "for i to maxblocksize do"
    db        9
    db        "!table converts eg. 78 to 4 (4th of 16,32,64,128)"
    db        10
    db        9
    db        9
    db        "j:=1"
    db        10
    db        9
    db        9
    db        "k:=16"
    db        10
    db        9
    db        9
    db        "while i>k do"
    db        10
    db        9
    db        9
    db        9
    db        "k:=k<<1"
    db        10
    db        9
    db        9
    db        9
    db        "++j"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "sizeindextable[i]:=j"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "allocupper[1]:=16"
    db        10
    db        9
    db        "size:=16"
    db        10
    db        10
    db        9
    db        "for i:=2 to 27 do"
    db        10
    db        9
    db        9
    db        "size*:=2"
    db        10
    db        9
    db        9
    db        "allocupper[i]:=size"
    db        10
    db        9
    db        9
    db        "if size>=threshold then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "k:=i"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "for i:=k+1 to allocupper.upb do"
    db        10
    db        9
    db        9
    db        "size+:=alloc_step"
    db        10
    db        9
    db        9
    db        "if size<limit then"
    db        10
    db        9
    db        9
    db        9
    db        "allocupper[i]:=size"
    db        10
    db        9
    db        9
    db        9
    db        "maxmemory:=size"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "maxalloccode:=i-1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "pcm_setup:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_getac(int size)int ="
    db        10
    db        "! convert linear blocksize from 0..approx 2GB to 8-bit allocation code"
    db        10
    db        10
    db        "!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9"
    db        10
    db        10
    db        9
    db        "if size<=maxblocksize then"
    db        10
    db        9
    db        9
    db        "return sizeindextable[size]"
    db        9
    db        9
    db        "!size 0 to 2KB"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "size:=(size+255)>>8"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!scale by 256"
    db        10
    db        10
    db        "!now same sizetable can be used for 2KB to 512KB (288 to 2KB)"
    db        10
    db        10
    db        9
    db        "if size<=maxblocksize then"
    db        10
    db        9
    db        9
    db        "return sizeindextable[size]+8"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!sizetable now used for 512KB to 128MB (to 2KB)"
    db        10
    db        9
    db        "size:=(size+63)>>6"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!scale by 256"
    db        10
    db        10
    db        9
    db        "if size<=maxblocksize then"
    db        10
    db        9
    db        9
    db        "return sizeindextable[size]+14"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!size>2048, which means it had been over 128MB."
    db        10
    db        9
    db        "size:=(size-2048+2047)/2048+22"
    db        10
    db        9
    db        "return size"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_newblock(int itemsize)ref void="
    db        10
    db        "!create new heap block (can be first)"
    db        10
    db        "!also optionally allocate small item at start"
    db        10
    db        "!return pointer to this item (and to the heap block)"
    db        10
    db        9
    db        "static int totalheapsize"
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        10
    db        9
    db        "totalheapsize+:=pcheapsize"
    db        10
    db        9
    db        "alloccode:=0"
    db        10
    db        9
    db        "p:=allocmem(pcheapsize)"
    db        9
    db        "!can't free this block until appl terminates"
    db        10
    db        9
    db        "if p=nil then"
    db        10
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "Can't alloc pc heap"
    db        34
    db        ")"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memset(p,0,pcheapsize)"
    db        10
    db        10
    db        9
    db        "pcheapptr:=p"
    db        10
    db        9
    db        "pcheapend:=p+pcheapsize"
    db        10
    db        10
    db        9
    db        "if pcheapstart=nil then"
    db        9
    db        9
    db        "!this is first block"
    db        10
    db        9
    db        9
    db        "pcheapstart:=p"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "pcheapptr+:=itemsize"
    db        10
    db        9
    db        "return ref u32(p)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_round(int n)int ="
    db        10
    db        "!for any size n, return actual number of bytes that would be allocated"
    db        10
    db        9
    db        "static [0:maxblockindex+1]i32 allocbytes=(0,16,32,64,128,256,512,1024,2048)"
    db        10
    db        10
    db        9
    db        "if n>maxblocksize then"
    db        10
    db        9
    db        9
    db        "return n"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return allocbytes[sizeindextable[n]]"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_allocz(int n)ref void ="
    db        10
    db        9
    db        "ref void p"
    db        10
    db        9
    db        "p:=pcm_alloc(n)"
    db        10
    db        10
    db        9
    db        "memset(p,0,n)"
    db        10
    db        9
    db        "return p"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_copyheapstring(ref char s)ref char ="
    db        10
    db        "!allocate enough bytes for string s: copy s to the heap"
    db        10
    db        "!return pointer to new string"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "if s=nil then return nil fi"
    db        10
    db        10
    db        9
    db        "n:=strlen(s)+1"
    db        10
    db        9
    db        "q:=pcm_alloc(n)"
    db        10
    db        9
    db        "memcpy(q,s,n)"
    db        10
    db        9
    db        "return q"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_copyheapstringn(ref char s,int n)ref char ="
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "if s=nil then return nil fi"
    db        10
    db        10
    db        9
    db        "q:=pcm_alloc(n+1)"
    db        10
    db        9
    db        "memcpy(q,s,n)"
    db        10
    db        9
    db        "(q+n)^:=0"
    db        10
    db        9
    db        "return q"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_copyheapblock(ref char s, int length)ref char ="
    db        10
    db        "!allocate enough bytes for string s: copy s to the heap"
    db        10
    db        "!return pointer to new string"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "if length=0 then return nil fi"
    db        10
    db        10
    db        9
    db        "q:=pcm_alloc(length)"
    db        10
    db        9
    db        "memcpy(q,s,length)"
    db        10
    db        9
    db        "return q"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function allocmem(int n)ref void ="
    db        10
    db        9
    db        "ref void p"
    db        10
    db        10
    db        9
    db        "p:=malloc(n)"
    db        10
    db        9
    db        "if p then"
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "println n,memtotal"
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "Alloc mem failure"
    db        34
    db        ")"
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function reallocmem(ref void p,int n)ref void ="
    db        10
    db        9
    db        "p:=realloc(p,n)"
    db        10
    db        9
    db        "return p when p"
    db        10
    db        9
    db        "println n"
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "Realloc mem failure"
    db        34
    db        ")"
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc abortprogram(ref char s) ="
    db        10
    db        9
    db        "println s"
    db        10
    db        9
    db        "print   "
    db        34
    db        "ABORTING: Press key..."
    db        34
    db        10
    db        "!os_getch()"
    db        10
    db        9
    db        "stop 5"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function getfilesize(filehandle handlex)int="
    db        10
    db        9
    db        "u32 p,size"
    db        10
    db        10
    db        9
    db        "p:=ftell(handlex)"
    db        9
    db        9
    db        "!current position"
    db        10
    db        9
    db        "fseek(handlex,0,2)"
    db        9
    db        9
    db        "!get to eof"
    db        10
    db        9
    db        "size:=ftell(handlex)"
    db        9
    db        9
    db        "!size in bytes"
    db        10
    db        9
    db        "fseek(handlex,p,seek_set)"
    db        9
    db        "!restore position"
    db        10
    db        9
    db        "return size"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc readrandom(filehandle handlex, ref byte memx, int offset, size) ="
    db        10
    db        9
    db        "int a"
    db        10
    db        9
    db        "fseek(handlex,offset,seek_set)"
    db        10
    db        9
    db        "a:=fread(memx,1,size,handlex)"
    db        9
    db        9
    db        9
    db        "!assign so as to remove gcc warning"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function writerandom(filehandle handlex, ref byte memx, int offset,size)int ="
    db        10
    db        9
    db        "fseek(handlex,offset,seek_set)"
    db        10
    db        9
    db        "return fwrite(memx,1,size,handlex)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function setfilepos(filehandle file,int offset)int="
    db        10
    db        9
    db        "return fseek(file,offset,0)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function getfilepos(filehandle file)int="
    db        10
    db        9
    db        "return ftell(file)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function readfile(ref char filename)ref byte ="
    db        10
    db        9
    db        "filehandle f"
    db        10
    db        9
    db        "int size"
    db        10
    db        9
    db        "ref byte m,p"
    db        10
    db        10
    db        9
    db        "f:=fopen(filename,"
    db        34
    db        "rb"
    db        34
    db        ")"
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "return nil"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "rfsize:=size:=getfilesize(f)"
    db        10
    db        10
    db        9
    db        "m:=malloc(size+2)"
    db        9
    db        9
    db        "!allow space for etx/zeof etc"
    db        10
    db        10
    db        9
    db        "if m=nil then"
    db        10
    db        9
    db        9
    db        "return nil"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "readrandom(f,m,0,size)"
    db        10
    db        9
    db        "p:=m+size"
    db        9
    db        9
    db        9
    db        "!point to following byte"
    db        10
    db        9
    db        "(ref u16(p)^:=0)"
    db        9
    db        "!add two zero bytes"
    db        10
    db        10
    db        9
    db        "fclose(f)"
    db        10
    db        9
    db        "return m"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function writefile(ref char filename,ref byte data,int size)int ="
    db        10
    db        9
    db        "filehandle f"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "f:=fopen(filename,"
    db        34
    db        "wb"
    db        34
    db        ")"
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "n:=writerandom(f,data,0,size)"
    db        10
    db        9
    db        "fclose(f)"
    db        10
    db        9
    db        "return n"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function checkfile(ref char file)int="
    db        10
    db        9
    db        "filehandle f"
    db        10
    db        9
    db        "if f:=fopen(file,"
    db        34
    db        "rb"
    db        34
    db        ") then"
    db        10
    db        9
    db        9
    db        "fclose(f)"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc readlinen(filehandle handlex,ref char buffer,int size) ="
    db        10
    db        "!size>2"
    db        10
    db        9
    db        "int ch"
    db        10
    db        9
    db        "ref char p"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "byte crseen"
    db        10
    db        10
    db        9
    db        "if handlex=nil then"
    db        10
    db        9
    db        9
    db        "handlex:=filehandle(os_getstdin())"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if handlex=nil then"
    db        10
    db        9
    db        9
    db        "n:=0"
    db        10
    db        9
    db        9
    db        "p:=buffer"
    db        10
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        "ch:=getchar()"
    db        10
    db        9
    db        9
    db        9
    db        "if ch=13 or ch=10 or ch=-1 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "p^:=0"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "p++^:=ch"
    db        10
    db        9
    db        9
    db        9
    db        "++n"
    db        10
    db        9
    db        9
    db        9
    db        "if n>=(size-2) then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "p^:=0"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "buffer^:=0"
    db        10
    db        9
    db        "if fgets(buffer,size-2,handlex)=nil then"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "n:=strlen(buffer)"
    db        10
    db        9
    db        "if n=0 then"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "p:=buffer+n-1"
    db        9
    db        9
    db        "!point to last char"
    db        10
    db        9
    db        "crseen:=0"
    db        10
    db        9
    db        "while (p>=buffer and (p^=13 or p^=10)) do"
    db        10
    db        9
    db        9
    db        "if p^=13 or p^=10 then crseen:=1 fi"
    db        10
    db        9
    db        9
    db        "p--^ :=0"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        "!NOTE: this check doesn't work when a line simply doesn't end with cr-lf"
    db        10
    db        10
    db        9
    db        "if not crseen and (n+4>size) then"
    db        10
    db        9
    db        9
    db        "cpl size,n"
    db        10
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "line too long"
    db        34
    db        ")"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc iconvlcn(ref char s,int n) ="
    db        10
    db        9
    db        "to n do"
    db        10
    db        9
    db        9
    db        "s^:=tolower(s^)"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc iconvucn(ref char s,int n) ="
    db        10
    db        9
    db        "to n do"
    db        10
    db        9
    db        9
    db        "s^:=toupper(s^)"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function convlcstring(ref char s)ichar s0="
    db        10
    db        9
    db        "s0:=s"
    db        10
    db        9
    db        "while (s^) do"
    db        10
    db        9
    db        9
    db        "s^:=tolower(s^)"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "s0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function convucstring(ref char s)ichar s0="
    db        10
    db        9
    db        "s0:=s"
    db        10
    db        9
    db        "while (s^) do"
    db        10
    db        9
    db        9
    db        "s^:=toupper(s^)"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "s0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function changeext(ref char s,newext)ichar="
    db        10
    db        "!whether filespec has an extension or not, change it to newext"
    db        10
    db        "!newext should start with "
    db        34
    db        "."
    db        34
    db        10
    db        "!return new string (locally stored static string, so must be used before calling again)"
    db        10
    db        9
    db        "static [260]char newfile"
    db        10
    db        9
    db        "[32]char newext2"
    db        10
    db        9
    db        "ref char sext"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "strcpy(&newfile[1],s)"
    db        10
    db        10
    db        9
    db        "case newext^"
    db        10
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        "newext2[1]:=0"
    db        10
    db        9
    db        9
    db        "newext2[2]:=0"
    db        10
    db        9
    db        "when '.' then"
    db        10
    db        9
    db        9
    db        "strcpy(&newext2[1],newext)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strcpy(&newext2[1],"
    db        34
    db        "."
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "strcat(&newext2[1],newext)"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        10
    db        9
    db        "sext:=extractext(s,1)"
    db        9
    db        9
    db        9
    db        "!include "
    db        34
    db        "."
    db        34
    db        " when it is only extension"
    db        10
    db        10
    db        9
    db        "case sext^"
    db        10
    db        9
    db        "when 0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!no extension not even "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        9
    db        "strcat(&newfile[1],&newext2[1])"
    db        10
    db        9
    db        "when '.' then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!no extension not even "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        9
    db        "strcat(&newfile[1],&newext2[2])"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!has extension"
    db        10
    db        9
    db        9
    db        "n:=sext-s-2"
    db        9
    db        9
    db        9
    db        "!n is number of chars before the "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        9
    db        "strcpy(&newfile[1]+n+1,&newext2[1])"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "return &newfile[1]"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function extractext(ref char s,int period=0)ichar="
    db        10
    db        "!if filespec s has an extension, then return pointer to it otherwise return "
    db        34
    db        34
    db        10
    db        "!if s ends with "
    db        34
    db        "."
    db        34
    db        ", then returns "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        "ref char t,u"
    db        10
    db        10
    db        9
    db        "t:=extractfile(s)"
    db        10
    db        10
    db        9
    db        "if t^=0 then"
    db        9
    db        9
    db        9
    db        "!s contains no filename"
    db        10
    db        9
    db        9
    db        "return "
    db        34
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!t contains filename+ext"
    db        10
    db        9
    db        "u:=t+strlen(t)-1"
    db        9
    db        9
    db        "!u points to last char of t"
    db        10
    db        10
    db        9
    db        "while u>=t do"
    db        10
    db        9
    db        9
    db        "if u^='.' then"
    db        9
    db        9
    db        "!start extension found"
    db        10
    db        9
    db        9
    db        9
    db        "if (u+1)^=0 then"
    db        9
    db        9
    db        "!null extension"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "return (period|"
    db        34
    db        "."
    db        34
    db        "|"
    db        34
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return u+1"
    db        9
    db        9
    db        9
    db        "!return last part of filename as extension exclude the dot"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "--u"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return "
    db        34
    db        34
    db        9
    db        9
    db        9
    db        "!no extension seen"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function extractpath(ref char s)ichar="
    db        10
    db        9
    db        "static [0:260]char str"
    db        10
    db        9
    db        "ref char t"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "t:=s+strlen(s)-1"
    db        9
    db        9
    db        "!t points to last char"
    db        10
    db        10
    db        9
    db        "while (t>=s) do"
    db        10
    db        9
    db        9
    db        "case t^"
    db        10
    db        9
    db        9
    db        "when '"
    db        92
    db        92
    db        "','/',':' then"
    db        9
    db        9
    db        "!path separator or drive letter terminator assume no extension"
    db        10
    db        9
    db        9
    db        9
    db        "n:=t-s+1"
    db        9
    db        9
    db        9
    db        "!n is number of chars in path, which includes rightmost / or "
    db        92
    db        " or :"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(&.str,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "str[n]:=0"
    db        10
    db        9
    db        9
    db        9
    db        "return &.str"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        "--t"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return "
    db        34
    db        34
    db        9
    db        9
    db        9
    db        "!no path found"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function extractfile(ref char s)ichar="
    db        10
    db        9
    db        "ref char t"
    db        10
    db        10
    db        9
    db        "t:=extractpath(s)"
    db        10
    db        10
    db        9
    db        "if t^=0 then"
    db        9
    db        9
    db        9
    db        "!s contains no path"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return s+strlen(t)"
    db        9
    db        9
    db        "!point to last part of s that contains the file"
    db        10
    db        9
    db        "end"
    db        10
    db        10
    db        "export function extractbasefile(ref char s)ichar="
    db        10
    db        9
    db        "static [0:100]char str"
    db        10
    db        9
    db        "ref char f,e"
    db        10
    db        9
    db        "int n,flen"
    db        10
    db        10
    db        9
    db        "f:=extractfile(s)"
    db        10
    db        9
    db        "flen:=strlen(f)"
    db        10
    db        9
    db        "if flen=0 then"
    db        9
    db        9
    db        "!s contains no path"
    db        10
    db        9
    db        9
    db        "return "
    db        34
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "e:=extractext(f,0)"
    db        10
    db        10
    db        9
    db        "if e^ then"
    db        9
    db        9
    db        9
    db        "!not null extension"
    db        10
    db        9
    db        9
    db        "n:=flen-strlen(e)-1"
    db        10
    db        9
    db        9
    db        "memcpy(&str,f,n)"
    db        10
    db        9
    db        9
    db        "str[n]:=0"
    db        10
    db        9
    db        9
    db        "return &.str"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if (f+flen-1)^='.' then"
    db        10
    db        9
    db        9
    db        "memcpy(&str,f,flen-1)"
    db        10
    db        9
    db        9
    db        "str[flen-1]:=0"
    db        10
    db        9
    db        9
    db        "return &.str"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return f"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function addext(ref char s,ref char newext)ichar="
    db        10
    db        "!when filespec has no extension of its own, add newext"
    db        10
    db        9
    db        "ref char sext"
    db        10
    db        10
    db        9
    db        "sext:=extractext(s,1)"
    db        10
    db        10
    db        9
    db        "if sext^=0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!no extension not even "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        9
    db        "return changeext(s,newext)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return s"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!has own extension; use that"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_alloc32:ref void ="
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        10
    db        9
    db        "allocbytes:=32"
    db        10
    db        "!"
    db        9
    db        "smallmemtotal+:=32"
    db        10
    db        10
    db        9
    db        "if p:=ref byte(freelist[2]) then"
    db        9
    db        9
    db        "!Items of this block size available"
    db        10
    db        9
    db        9
    db        "freelist[2]:=ref word(int((freelist[2])^))"
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!No items in freelists: allocate new space in this heap block"
    db        10
    db        9
    db        "return pcm_alloc(32)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_free32(ref void p) ="
    db        10
    db        "!n can be the actual size requested it does not need to be the allocated size"
    db        10
    db        10
    db        "!"
    db        9
    db        "smallmemtotal-:=32"
    db        10
    db        10
    db        9
    db        "cast(p,ref word)^:=word(int(freelist[2]))"
    db        10
    db        9
    db        "freelist[2]:=p"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outbyte(filehandle f,int x)="
    db        10
    db        9
    db        "fwrite(&x,1,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outu16(filehandle f,word x)="
    db        10
    db        9
    db        "fwrite(&x,2,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outu32(filehandle f,word x)="
    db        10
    db        9
    db        "fwrite(&x,4,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outu64(filehandle f,u64 x)="
    db        10
    db        9
    db        "fwrite(&x,8,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outstring(filehandle f, ichar s)="
    db        10
    db        9
    db        "fwrite(s,strlen(s)+1,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outblock(filehandle f, ref void p, int n)="
    db        10
    db        9
    db        "fwrite(p,n,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function myeof(filehandle f)int="
    db        10
    db        9
    db        "int c"
    db        10
    db        10
    db        9
    db        "c:=fgetc(f)"
    db        10
    db        9
    db        "if c=c_eof then return 1 fi"
    db        10
    db        9
    db        "ungetc(c,f)"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)="
    db        10
    db        9
    db        "int newlen,oldlen"
    db        10
    db        9
    db        "ichar newptr"
    db        10
    db        10
    db        "!"
    db        9
    db        "IF N=0 THEN CPL "
    db        34
    db        "N=0"
    db        34
    db        " FI"
    db        10
    db        10
    db        9
    db        "if n=-1 then"
    db        10
    db        9
    db        9
    db        "n:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "oldlen:=dest.length"
    db        10
    db        10
    db        9
    db        "if oldlen=0 then"
    db        9
    db        9
    db        9
    db        9
    db        "!first string"
    db        10
    db        9
    db        9
    db        "dest.strptr:=pcm_alloc(n+1)"
    db        10
    db        9
    db        9
    db        "dest.allocated:=allocbytes"
    db        10
    db        9
    db        9
    db        "dest.length:=n"
    db        9
    db        9
    db        9
    db        9
    db        "!length always excludes terminator"
    db        10
    db        9
    db        9
    db        "memcpy(dest.strptr,s,n)"
    db        10
    db        9
    db        9
    db        "(dest.strptr+n)^:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "newlen:=oldlen+n"
    db        10
    db        9
    db        "if newlen+1>dest.allocated then"
    db        10
    db        9
    db        9
    db        "newptr:=pcm_alloc(newlen+1)"
    db        10
    db        9
    db        9
    db        "memcpy(newptr,dest.strptr,oldlen)"
    db        10
    db        9
    db        9
    db        "dest.strptr:=newptr"
    db        10
    db        9
    db        9
    db        "dest.allocated:=allocbytes"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "memcpy(dest.strptr+oldlen,s,n)"
    db        10
    db        9
    db        "(dest.strptr+newlen)^:=0"
    db        10
    db        10
    db        9
    db        "dest.length:=newlen"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_init(ref strbuffer dest)="
    db        10
    db        9
    db        "pcm_clearmem(dest,strbuffer.bytes)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_free(ref strbuffer dest)="
    db        10
    db        9
    db        "if dest.allocated then"
    db        10
    db        9
    db        9
    db        "pcm_free(dest.strptr,dest.allocated)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_str(ref strbuffer dest,ichar s)="
    db        10
    db        9
    db        "strbuffer_add(dest,s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_char(ref strbuffer dest,int c)="
    db        10
    db        9
    db        "[16]char s"
    db        10
    db        10
    db        9
    db        "s[1]:=c"
    db        10
    db        9
    db        "s[2]:=0"
    db        10
    db        10
    db        9
    db        "strbuffer_add(dest,&.s,1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strn(ref strbuffer dest,ichar s,int length)="
    db        10
    db        9
    db        "strbuffer_add(dest,s,length)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strvar(ref strbuffer dest,s)="
    db        10
    db        9
    db        "strbuffer_add(dest,s.strptr)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strint(ref strbuffer dest,i64 a)="
    db        10
    db        9
    db        "strbuffer_add(dest,strint(a))"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strln(ref strbuffer dest,ichar s)="
    db        10
    db        9
    db        "gs_str(dest,s)"
    db        10
    db        9
    db        "gs_line(dest)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strsp(ref strbuffer dest,ichar s)="
    db        10
    db        9
    db        "gs_str(dest,s)"
    db        10
    db        9
    db        "gs_str(dest,"
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_line(ref strbuffer dest)="
    db        10
    db        "!"
    db        9
    db        "strbuffer_add(dest,"
    db        34
    db        92
    db        "w"
    db        34
    db        ")"
    db        10
    db        9
    db        "strbuffer_add(dest,"
    db        34
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function gs_getcol(ref strbuffer dest)int="
    db        10
    db        9
    db        "return dest.length"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')="
    db        10
    db        9
    db        "int col,i,n,slen"
    db        10
    db        9
    db        "[2560]char str"
    db        10
    db        9
    db        "col:=dest.length"
    db        10
    db        9
    db        "strcpy(&.str,s)"
    db        10
    db        9
    db        "slen:=strlen(s)"
    db        10
    db        9
    db        "n:=w-slen"
    db        10
    db        9
    db        "if n>0 then"
    db        10
    db        9
    db        9
    db        "for i:=1 to n do"
    db        10
    db        9
    db        9
    db        9
    db        "str[slen+i]:=padch"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "str[slen+n+1]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "gs_str(dest,&.str)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')="
    db        10
    db        9
    db        "gs_leftstr(dest,strint(a),w,padch)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_padto(ref strbuffer dest,int col, ch=' ')="
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "[2560]char str"
    db        10
    db        10
    db        9
    db        "n:=col-dest.length"
    db        10
    db        9
    db        "if n<=0 then return fi"
    db        10
    db        9
    db        "for i:=1 to n do"
    db        10
    db        9
    db        9
    db        "str[i]:=ch"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "str[n+1]:=0"
    db        10
    db        9
    db        "gs_str(dest,&.str)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_println(ref strbuffer dest,filehandle f=nil)="
    db        10
    db        9
    db        "if dest.length=0 then return fi"
    db        10
    db        9
    db        "(dest.strptr+dest.length)^:=0"
    db        10
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "println dest.strptr,,"
    db        34
    db        92
    db        "c"
    db        34
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "println @f,dest.strptr,,"
    db        34
    db        92
    db        "c"
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function nextcmdparamnew(int &paramno, ichar &name, &value, ichar defext=nil)int="
    db        10
    db        9
    db        "static int infile=0"
    db        10
    db        9
    db        "static ichar filestart=nil"
    db        10
    db        9
    db        "static ichar fileptr=nil"
    db        10
    db        9
    db        "static byte colonseen=0"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "ichar item,fileext"
    db        10
    db        9
    db        "int length"
    db        10
    db        9
    db        "static [300]char str"
    db        10
    db        10
    db        9
    db        "reenter:"
    db        10
    db        9
    db        "value:=nil"
    db        10
    db        9
    db        "name:=nil"
    db        10
    db        10
    db        9
    db        "if infile then"
    db        10
    db        9
    db        9
    db        "if readnextfileitem(fileptr,item)=0 then"
    db        9
    db        9
    db        "!eof"
    db        10
    db        9
    db        9
    db        9
    db        "free(filestart)"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!file allocated via malloc"
    db        10
    db        9
    db        9
    db        9
    db        "infile:=0"
    db        10
    db        9
    db        9
    db        9
    db        "goto reenter"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if paramno>ncmdparams then"
    db        10
    db        9
    db        9
    db        9
    db        "return pm_end"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "item:=cmdparams[paramno]"
    db        10
    db        9
    db        9
    db        "++paramno"
    db        10
    db        10
    db        9
    db        9
    db        "length:=strlen(item)"
    db        10
    db        10
    db        9
    db        9
    db        "if item^='@' then"
    db        9
    db        9
    db        "!@ file"
    db        10
    db        9
    db        9
    db        9
    db        "filestart:=fileptr:=readfile(item+1)"
    db        10
    db        9
    db        9
    db        9
    db        "if filestart=nil then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "println "
    db        34
    db        "Can't open"
    db        34
    db        ",item"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "stop 7"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "infile:=1"
    db        10
    db        9
    db        9
    db        9
    db        "goto reenter"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "if item^=':' then"
    db        10
    db        9
    db        9
    db        9
    db        "colonseen:=1"
    db        10
    db        9
    db        9
    db        9
    db        "return pm_colon"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "value:=nil"
    db        10
    db        9
    db        "if item^='-' then"
    db        10
    db        9
    db        9
    db        "name:=item+(colonseen|0|1)"
    db        10
    db        9
    db        9
    db        "q:=strchr(item,':')"
    db        10
    db        9
    db        9
    db        "if not q then"
    db        10
    db        9
    db        9
    db        9
    db        "q:=strchr(item,'=')"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if q then"
    db        10
    db        9
    db        9
    db        9
    db        "value:=q+1"
    db        10
    db        9
    db        9
    db        9
    db        "q^:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "return (colonseen|pm_extra|pm_option)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fileext:=extractext(item,0)"
    db        10
    db        9
    db        "name:=item"
    db        10
    db        10
    db        9
    db        "if fileext^=0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!no extension"
    db        10
    db        9
    db        9
    db        "strcpy(&.str,name)"
    db        10
    db        9
    db        9
    db        "if defext and not colonseen then"
    db        10
    db        9
    db        9
    db        9
    db        "name:=addext(&.str,defext)"
    db        9
    db        9
    db        9
    db        9
    db        "!try .c"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        "!"
    db        9
    db        "elsif eqstring(fileext,"
    db        34
    db        "dll"
    db        34
    db        ") then"
    db        10
    db        9
    db        "elsif eqstring(fileext,"
    db        34
    db        "dll"
    db        34
    db        ") or eqstring(fileext,"
    db        34
    db        "mcx"
    db        34
    db        ") then"
    db        10
    db        9
    db        9
    db        "return (colonseen|pm_extra|pm_libfile)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return (colonseen|pm_extra|pm_sourcefile)"
    db        10
    db        "end"
    db        10
    db        10
    db        "function readnextfileitem(ichar &fileptr,&item)int="
    db        10
    db        9
    db        "ref char p,pstart,pend"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "static [256]char str"
    db        10
    db        10
    db        9
    db        "p:=fileptr"
    db        10
    db        10
    db        9
    db        "reenter:"
    db        10
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        "case p^"
    db        10
    db        9
    db        9
    db        "when ' ','"
    db        92
    db        "t',13,10 then"
    db        9
    db        "!skip white space"
    db        10
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        "when 26,0 then"
    db        9
    db        9
    db        9
    db        9
    db        "!eof"
    db        10
    db        9
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "case p^"
    db        10
    db        9
    db        "when '!', '#' then"
    db        9
    db        9
    db        9
    db        "!comment"
    db        10
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        "docase p++^"
    db        10
    db        9
    db        9
    db        "when 10 then"
    db        10
    db        9
    db        9
    db        9
    db        "goto reenter"
    db        10
    db        9
    db        9
    db        "when 26,0 then"
    db        10
    db        9
    db        9
    db        9
    db        "fileptr:=p-1"
    db        10
    db        9
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        10
    db        9
    db        9
    db        "end docase"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        10
    db        9
    db        "case p^"
    db        10
    db        9
    db        "when '"
    db        34
    db        "' then"
    db        9
    db        9
    db        9
    db        9
    db        "!read until closing "
    db        34
    db        10
    db        9
    db        9
    db        "pstart:=++p"
    db        10
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        "case p^"
    db        10
    db        9
    db        9
    db        9
    db        "when 0,26 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "println "
    db        34
    db        "Unexpected EOF in @file"
    db        34
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "stop 8"
    db        10
    db        9
    db        9
    db        9
    db        "when '"
    db        34
    db        "' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "pend:=p++"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if p^=',' then ++p fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "pstart:=p"
    db        10
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        "case p^"
    db        10
    db        9
    db        9
    db        9
    db        "when 0,26 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "pend:=p"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        "when ' ','"
    db        92
    db        "t',',',13,10 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "pend:=p++"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "n:=pend-pstart"
    db        10
    db        9
    db        "if n>=str.len then"
    db        10
    db        9
    db        9
    db        "println "
    db        34
    db        "@file item too long"
    db        34
    db        10
    db        9
    db        9
    db        "stop 9"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(&.str,pstart,n)"
    db        10
    db        9
    db        "str[n+1]:=0"
    db        10
    db        9
    db        "item:=&.str"
    db        10
    db        9
    db        "fileptr:=p"
    db        10
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc ipadstr(ref char s,int width,ref char padchar="
    db        34
    db        " "
    db        34
    db        ")="
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "n:=strlen(s)"
    db        10
    db        9
    db        "to width-n do"
    db        10
    db        9
    db        9
    db        "strcat(s,padchar)"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function padstr(ref char s,int width,ref char padchar="
    db        34
    db        " "
    db        34
    db        ")ichar="
    db        10
    db        9
    db        "static [256]char str"
    db        10
    db        10
    db        9
    db        "strcpy(&.str,s)"
    db        10
    db        9
    db        "ipadstr(&.str,width,padchar)"
    db        10
    db        9
    db        "return &.str"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function chr(int c)ichar="
    db        10
    db        9
    db        "static [8]char str"
    db        10
    db        10
    db        9
    db        "str[1]:=c"
    db        10
    db        9
    db        "str[2]:=0"
    db        10
    db        9
    db        "return &.str"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function cmpstring(ichar s,t)int="
    db        10
    db        9
    db        "int res"
    db        10
    db        9
    db        "if (res:=strcmp(s,t))<0 then"
    db        10
    db        9
    db        9
    db        "return -1"
    db        10
    db        9
    db        "elsif res>0 then"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function cmpstringn(ichar s,t,int n)int="
    db        10
    db        9
    db        "int res"
    db        10
    db        9
    db        "if (res:=strncmp(s,t,n))<0 then"
    db        10
    db        9
    db        9
    db        "return -1"
    db        10
    db        9
    db        "elsif res>0 then"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function eqstring(ichar s,t)int="
    db        10
    db        9
    db        "return strcmp(s,t)=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function cmpbytes(ref void p,q,int n)int="
    db        10
    db        9
    db        "int res"
    db        10
    db        9
    db        "if (res:=memcmp(p,q,n))<0 then"
    db        10
    db        9
    db        9
    db        "return -1"
    db        10
    db        9
    db        "elsif res>0 then"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function eqbytes(ref void p,q,int n)int="
    db        10
    db        9
    db        "return memcmp(p,q,n)=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc mseed(u64 a,b=0)="
    db        10
    db        9
    db        "seed[1]:=a"
    db        10
    db        9
    db        "if b then"
    db        10
    db        9
    db        9
    db        "seed[2]:=b"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "seed[2] ixor:=a"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandom:word ="
    db        10
    db        "!return pure 64-bit word value, 0 to 2**64-1"
    db        10
    db        "!(cast result for signed value)"
    db        10
    db        "!"
    db        9
    db        "u64 x,y"
    db        10
    db        9
    db        "int x,y"
    db        10
    db        9
    db        "x:=seed[1]"
    db        10
    db        9
    db        "y:=seed[2]"
    db        10
    db        9
    db        "seed[1]:=y"
    db        10
    db        9
    db        "x ixor:=(x<<23)"
    db        10
    db        9
    db        "seed[2]:= x ixor y ixor (x>>17) ixor (y>>26)"
    db        10
    db        9
    db        "return seed[2]+y"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomp:int ="
    db        10
    db        "!pure 64-bit int value, positive only, 0 to 2**63-1"
    db        10
    db        9
    db        "return mrandom() iand 0x7FFF'FFFF'FFFF'FFFF"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomint(int n)int="
    db        10
    db        "!positive random int value from 0 to n-1"
    db        10
    db        9
    db        "return mrandomp() rem n"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomrange(int a,b)int="
    db        10
    db        "!random int value from a to b inclusive"
    db        10
    db        "!span extent must be 1 to 2**63-1"
    db        10
    db        9
    db        "int span"
    db        10
    db        9
    db        "span:=b-a+1"
    db        10
    db        9
    db        "if span<=0 then"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return (mrandomp() rem span)+a"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomreal:real x="
    db        10
    db        "!positive random real value from 0 to just under (but not including) 1.0"
    db        10
    db        9
    db        "repeat x:=mrandomp()/9223372036854775808.0 until x<>1.0"
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomreal1:real="
    db        10
    db        "!positive random real value from 0 to 1.0 inclusive"
    db        10
    db        9
    db        "return mrandomp()/9223372036854775807.0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function readline:ichar="
    db        10
    db        9
    db        "readln"
    db        10
    db        9
    db        "return rd_buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function findfunction(ichar name)ref void="
    db        10
    db        9
    db        "for i to $getnprocs() do"
    db        10
    db        9
    db        9
    db        "if eqstring($getprocname(i),name) then"
    db        10
    db        9
    db        9
    db        9
    db        "return $getprocaddr(i)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function roundtoblock(int n,align)int="
    db        10
    db        "!round up n until it is a multiple of filealign (which is a power of two)"
    db        10
    db        "!return aligned value. Returns original if already aligned"
    db        10
    db        9
    db        "if n iand (align-1)=0 then return n fi"
    db        10
    db        9
    db        "return n+(align-(n iand (align-1)))"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_allocnfz(int n)ref void ="
    db        10
    db        "!non-freeing allocator for small objects"
    db        10
    db        "!n should be a multiple of 8 bytes, but is rounded up here if needed"
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        10
    db        "!make n a multiple of 8"
    db        10
    db        9
    db        "if n iand 7 then"
    db        10
    db        9
    db        9
    db        "n:=n+(8-(n iand 7))"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "p:=pcheapptr"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!Create item at start of remaining pool in heap block"
    db        10
    db        9
    db        "pcheapptr+:=n"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!Shrink remaining pool"
    db        10
    db        10
    db        9
    db        "if pcheapptr>=pcheapend then"
    db        9
    db        "!Overflows?"
    db        10
    db        9
    db        9
    db        "p:=pcm_newblock(n)"
    db        9
    db        9
    db        9
    db        "!Create new heap block, and allocate from start of that"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return p"
    db        10
    db        "end"
    db        10
    db        10
    db        "!export proc freddy="
    db        10
    db        "!"
    db        9
    db        "PRINTLN "
    db        34
    db        "FREDDY"
    db        34
    db        10
    db        "!end"
    db        10
    db        0
L11480:
    db        "!import clib"
    db        10
    db        "!export type filehandle=ref void"
    db        10
    db        10
    db        "!importdll $cstd="
    db        10
    db        "importdll msvcrt="
    db        10
    db        9
    db        "func malloc"
    db        9
    db        "(u64)ref void"
    db        10
    db        9
    db        "proc free"
    db        9
    db        9
    db        "(ref void)"
    db        10
    db        "!"
    db        9
    db        "func pow"
    db        9
    db        9
    db        "(real,real)real"
    db        10
    db        "!"
    db        10
    db        9
    db        "func printf (ref char,...)i32"
    db        10
    db        "!"
    db        9
    db        "func fprintf (ref void,ref char,...)i32"
    db        10
    db        9
    db        "func puts (ref char)i32"
    db        10
    db        9
    db        "proc `exit(i32)"
    db        10
    db        9
    db        "func getchar"
    db        9
    db        ":i32"
    db        10
    db        9
    db        "proc memcpy"
    db        9
    db        9
    db        "(ref void, ref void, word)"
    db        10
    db        9
    db        "proc memset"
    db        9
    db        9
    db        "(ref void, i32, u64)"
    db        10
    db        9
    db        "func strlen"
    db        9
    db        9
    db        "(ichar)u64"
    db        10
    db        9
    db        "func strcpy"
    db        9
    db        9
    db        "(ichar,ichar)ichar"
    db        10
    db        9
    db        "func strcat"
    db        9
    db        9
    db        "(ichar,ichar)ichar"
    db        10
    db        9
    db        "func strcmp"
    db        9
    db        9
    db        "(ichar,ichar)i32"
    db        10
    db        10
    db        9
    db        "func _strdup"
    db        9
    db        "(ichar)ichar"
    db        10
    db        "end"
    db        10
    db        10
    db        "export macro strdup=_strdup"
    db        10
    db        10
    db        "!export proc free(ref void) = end"
    db        10
    db        10
    db        10
    db        "int needgap"
    db        10
    db        10
    db        "!proc start="
    db        10
    db        "!"
    db        9
    db        "CPL "
    db        34
    db        "MIN/START"
    db        34
    db        10
    db        "!end"
    db        10
    db        10
    db        10
    db        "global proc m$print_startcon="
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_end="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "!global proc m$print_ptr(u64 a,ichar fmtstyle=nil)="
    db        10
    db        "!!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        9
    db        "printf("
    db        34
    db        "%p"
    db        34
    db        ",a)"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        10
    db        "global proc m$print_ptr_nf(u64 a)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%p"
    db        34
    db        ",a)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        "!"
    db        10
    db        "!global proc m$print_i64(i64 a,ichar fmtstyle=nil)="
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        9
    db        "printf("
    db        34
    db        "%lld"
    db        34
    db        ",a)"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        10
    db        "!global proc m$print_i128(i64 a,ichar fmtstyle=nil)="
    db        10
    db        "!"
    db        9
    db        "puts("
    db        34
    db        "<128>"
    db        34
    db        ")"
    db        10
    db        "!!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!!"
    db        9
    db        "printf("
    db        34
    db        "%lld"
    db        34
    db        ",a)"
    db        10
    db        "!!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        10
    db        "global proc m$print_i64_nf(i64 a)="
    db        10
    db        "!puts("
    db        34
    db        "PRINTI64_nf"
    db        34
    db        ")"
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%lld"
    db        34
    db        ",a)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_u64(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%llu"
    db        34
    db        ",a)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_r64(real x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%f"
    db        34
    db        ",x)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_r32(real x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%f"
    db        34
    db        ",x)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "!global proc m$print_c8(i64 a,ichar fmtstyle=nil)="
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        9
    db        "printf("
    db        34
    db        "%c"
    db        34
    db        ",a)"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        "!"
    db        10
    db        "!global proc m$print_str(ichar s, fmtstyle=nil)="
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        9
    db        "printf("
    db        34
    db        "%s"
    db        34
    db        ",s)"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        10
    db        "global proc m$print_str_nf(ichar s)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%s"
    db        34
    db        ",s)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_space="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "printf("
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_newline="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "printf("
    db        34
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$unimpl="
    db        10
    db        9
    db        "puts("
    db        34
    db        "Sysfn unimpl"
    db        34
    db        ")"
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_nogap="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "!global proc nextfmtchars(int lastx=0)="
    db        10
    db        "global proc nextfmtchars="
    db        10
    db        9
    db        "if needgap then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "!global proc m$stop(int stopcode)="
    db        10
    db        "!"
    db        9
    db        "`exit(stopcode)"
    db        10
    db        "!end"
    db        10
    db        "!"
    db        10
    db        "!global func strint(i64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        "!"
    db        9
    db        "return "
    db        34
    db        "?"
    db        34
    db        10
    db        "!end"
    db        10
    db        "!"
    db        10
    db        10
    db        "!global function m$power_i64(i64 a,n)i64="
    db        10
    db        "!"
    db        9
    db        "if n<0 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return 0"
    db        10
    db        "!"
    db        9
    db        "elsif n=0 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return 1"
    db        10
    db        "!"
    db        9
    db        "elsif n=1 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return a"
    db        10
    db        "!"
    db        9
    db        "elsif (n iand 1)=0 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return m$power_i64(sqr a,n/2)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        "!assume odd"
    db        10
    db        "!"
    db        9
    db        9
    db        "return m$power_i64(sqr a,(n-1)/2)*a"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "!end"
    db        10
    db        "!"
    db        10
    db        "!"
    db        10
    db        0
L11479:
    db        "global record procinforec="
    db        10
    db        9
    db        "u16"
    db        9
    db        9
    db        "fnindex"
    db        10
    db        9
    db        "byte"
    db        9
    db        9
    db        "rettype"
    db        10
    db        9
    db        "byte"
    db        9
    db        9
    db        "nparams"
    db        10
    db        9
    db        "[12]byte"
    db        9
    db        "paramlist"
    db        10
    db        "end"
    db        10
    db        10
    db        "!for print/read routines"
    db        10
    db        "!------------------------------------------"
    db        10
    db        "export record fmtrec="
    db        9
    db        "! (default)"
    db        10
    db        9
    db        "byte"
    db        9
    db        "minwidth"
    db        9
    db        "! n (0)   min field width (0 if not used or don't care)"
    db        10
    db        9
    db        "i8"
    db        9
    db        9
    db        "precision"
    db        9
    db        "! .n (0)   number of decimals/significant figures/max width"
    db        10
    db        9
    db        "byte"
    db        9
    db        "base"
    db        9
    db        9
    db        "! B,H or Xn (10)  2 to 16"
    db        10
    db        10
    db        9
    db        "char"
    db        9
    db        "quotechar"
    db        9
    db        "! Qc (0)   0 or '"
    db        34
    db        "' or c"
    db        10
    db        9
    db        "char"
    db        9
    db        "padchar"
    db        9
    db        9
    db        "! Pc, Z (' ')"
    db        10
    db        9
    db        "char"
    db        9
    db        "realfmt"
    db        9
    db        9
    db        "! E,F,G ('f') 'e' or 'f' or 'g'"
    db        10
    db        10
    db        9
    db        "char"
    db        9
    db        "plus"
    db        9
    db        9
    db        "! (0)   0 or '+'"
    db        10
    db        9
    db        "char"
    db        9
    db        "sepchar"
    db        9
    db        9
    db        "! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits"
    db        10
    db        9
    db        "char"
    db        9
    db        "lettercase"
    db        9
    db        "! A,a ('A') 'A' or 'a'"
    db        10
    db        9
    db        "char"
    db        9
    db        "justify"
    db        9
    db        9
    db        "! JL, JR, JC ('R') 'L' or 'R' or 'C'?"
    db        10
    db        9
    db        "char"
    db        9
    db        "suffix"
    db        9
    db        9
    db        "! Tc (0)   0 or 'B' or 'H' or c"
    db        10
    db        9
    db        "char"
    db        9
    db        "usigned"
    db        9
    db        9
    db        "! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)"
    db        10
    db        9
    db        "char"
    db        9
    db        "charmode"
    db        9
    db        "! C,M (0)  0 or 'C' or 'M'"
    db        9
    db        "o/p int as int or single char or multi-char"
    db        10
    db        9
    db        "char"
    db        9
    db        "heapmode"
    db        9
    db        "! D (0)  'D' for str-functions, return ptr to heap string"
    db        10
    db        9
    db        "char"
    db        9
    db        "param"
    db        9
    db        9
    db        "! Use int value for <fmtparam>"
    db        10
    db        9
    db        "byte"
    db        9
    db        "spare : (showtype:1, newline:1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "int fmtparam"
    db        9
    db        9
    db        9
    db        "!as set with :'V'"
    db        10
    db        10
    db        "enumdata ="
    db        10
    db        9
    db        "std_io,file_io,str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "const comma = ','"
    db        10
    db        10
    db        "export int $cmdskip"
    db        9
    db        9
    db        9
    db        "!0 unless set by READMCX/etc"
    db        10
    db        10
    db        "export int needgap"
    db        9
    db        9
    db        9
    db        "= 0"
    db        10
    db        "int outdev"
    db        9
    db        9
    db        9
    db        "= std_io"
    db        10
    db        "filehandle outchan"
    db        9
    db        "= nil"
    db        10
    db        "ref char fmtstr "
    db        9
    db        "= nil"
    db        10
    db        10
    db        "const maxiostack=10"
    db        10
    db        "[maxiostack]filehandle"
    db        9
    db        "outchan_stack"
    db        10
    db        "[maxiostack]int"
    db        9
    db        9
    db        9
    db        "outdev_stack"
    db        10
    db        "[maxiostack]ref char"
    db        9
    db        "fmtstr_stack"
    db        10
    db        "[maxiostack]byte"
    db        9
    db        9
    db        "needgap_stack"
    db        10
    db        10
    db        "[maxiostack]ref char"
    db        9
    db        "ptr_stack"
    db        9
    db        9
    db        "!this one doesn't need pushing, as each is pointed to from outchan"
    db        10
    db        "int niostack=0"
    db        10
    db        10
    db        "[0:]char digits=A"
    db        34
    db        "0123456789ABCDEF"
    db        34
    db        10
    db        "const onesixty=360"
    db        10
    db        "fmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)"
    db        10
    db        10
    db        "!Read buffer vars"
    db        10
    db        "export const rd_buffersize = 16384"
    db        9
    db        "!total capacity of line buffer"
    db        10
    db        10
    db        "export ref char rd_buffer"
    db        9
    db        9
    db        "! point to start of read buffer"
    db        10
    db        "export int rd_length"
    db        9
    db        9
    db        9
    db        "! length of this line (as read by readln)"
    db        10
    db        "export ref char rd_pos"
    db        9
    db        9
    db        9
    db        "! current position it's up to (next read starts here)"
    db        10
    db        "export ref char rd_lastpos"
    db        9
    db        9
    db        "! set by sread() just before reading used for reread()"
    db        10
    db        10
    db        "int termchar"
    db        9
    db        9
    db        9
    db        "! terminator char set by readxxx()"
    db        10
    db        "int itemerror"
    db        9
    db        9
    db        9
    db        "!"
    db        9
    db        "set by some read functions, eg for reals"
    db        10
    db        10
    db        "[4096]char printbuffer"
    db        10
    db        "ichar printptr"
    db        10
    db        "int printlen"
    db        10
    db        10
    db        "!------------------------------------------"
    db        10
    db        10
    db        "export int ncmdparams"
    db        10
    db        "!export ref[]ichar cmdparams"
    db        10
    db        "export ref[0:]ichar cmdparams"
    db        10
    db        10
    db        "proc $getcommands(int ncmd, ref[0:]ichar cmds, int cmdskipL)="
    db        10
    db        "!CPL =$CMDSKIP"
    db        10
    db        "!CPL =CMDSKIPL"
    db        10
    db        9
    db        "ncmdparams:=ncmd-1"
    db        10
    db        9
    db        "cmdparams:=cmds"
    db        10
    db        "end"
    db        10
    db        10
    db        "!export proc m$init(int nargs, ref[]ichar args)="
    db        10
    db        "!"
    db        9
    db        "nsysparams:=nargs"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "if nsysparams>maxparam then"
    db        10
    db        "!"
    db        9
    db        9
    db        "printf("
    db        34
    db        "Too many params"
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "stop 1"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "for i:=1 to nargs do"
    db        10
    db        "!"
    db        9
    db        9
    db        "sysparams[i]:=args[i]"
    db        10
    db        "!"
    db        9
    db        "od"
    db        10
    db        "!"
    db        10
    db        "!!assume nsysparams is >=1, since first is always the program name"
    db        10
    db        "!"
    db        9
    db        "ncmdparams:=nsysparams-($cmdskip+1)"
    db        10
    db        "!"
    db        9
    db        "cmdparams:=cast(&sysparams[$cmdskip+1])"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "int j:=1"
    db        10
    db        "!"
    db        9
    db        "nenvstrings:=0"
    db        10
    db        "!!"
    db        9
    db        "while envstrings[j] do"
    db        10
    db        "!!"
    db        9
    db        9
    db        "++nenvstrings"
    db        10
    db        "!!"
    db        9
    db        9
    db        "++j"
    db        10
    db        "!!"
    db        9
    db        "od"
    db        10
    db        "!"
    db        10
    db        "!end"
    db        10
    db        10
    db        "proc pushio="
    db        10
    db        9
    db        "if niostack>=maxiostack then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Too many io levels"
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "stop 53"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "++niostack"
    db        10
    db        9
    db        "outchan_stack[niostack]"
    db        9
    db        ":= outchan"
    db        10
    db        9
    db        "outdev_stack[niostack]"
    db        9
    db        ":= outdev"
    db        10
    db        9
    db        "fmtstr_stack[niostack]"
    db        9
    db        ":= fmtstr"
    db        10
    db        9
    db        "needgap_stack[niostack]"
    db        9
    db        ":= needgap"
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "fmtstr:=nil"
    db        10
    db        9
    db        "outchan:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startfile(ref void dev)="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        9
    db        "outchan:=cast(dev)"
    db        10
    db        9
    db        "if dev then"
    db        10
    db        9
    db        9
    db        "outdev:=file_io"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "outdev:=std_io"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startstr(ref char s)="
    db        10
    db        9
    db        "ref ref char p"
    db        10
    db        9
    db        "pushio()"
    db        10
    db        10
    db        9
    db        "ptr_stack[niostack]:=s"
    db        10
    db        9
    db        "p:=&ptr_stack[niostack]"
    db        10
    db        10
    db        9
    db        "outchan:=cast(p)"
    db        10
    db        9
    db        "outdev:=str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startptr(ref ref char p)="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        10
    db        9
    db        "outchan:=cast(p)"
    db        10
    db        9
    db        "outdev:=str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startcon="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        9
    db        "outdev:=std_io"
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_setfmt(ref char format)="
    db        10
    db        9
    db        "fmtstr:=format"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_end="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "nextfmtchars(1)"
    db        10
    db        9
    db        "if niostack=1 and outdev in [std_io,file_io] then"
    db        10
    db        9
    db        9
    db        "dumpprintbuffer()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if niostack=0 then return fi"
    db        10
    db        9
    db        "outchan"
    db        9
    db        ":= outchan_stack[niostack]"
    db        10
    db        9
    db        "outdev"
    db        9
    db        ":= outdev_stack[niostack]"
    db        10
    db        9
    db        "fmtstr"
    db        9
    db        ":= fmtstr_stack[niostack]"
    db        10
    db        9
    db        "needgap"
    db        9
    db        ":= needgap_stack[niostack]"
    db        10
    db        10
    db        9
    db        "--niostack"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_ptr(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "fmtstyle:="
    db        34
    db        "z8H"
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "m$print_u64(a,fmtstyle)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_ptr_nf(u64 a)="
    db        10
    db        9
    db        "m$print_ptr(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_i64(i64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[40]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "if a>=0 then"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(a,&.s,10,0)"
    db        10
    db        9
    db        9
    db        "elsif a=i64.min then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt:=defaultfmt"
    db        10
    db        9
    db        9
    db        9
    db        "dofmt"
    db        10
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "s[1]:='-'"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(-a,&s[2],10,0)+1"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "printstr_n(&.s,n)"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "if fmt.param='V' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmtparam:=a"
    db        10
    db        9
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        "dofmt:"
    db        10
    db        9
    db        9
    db        9
    db        "tostr_i64(a,&fmt)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_i64_nf(i64 a)="
    db        10
    db        9
    db        "m$print_i64(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_bool(i64 a, ichar fmtstyle=nil)="
    db        10
    db        9
    db        "if a then"
    db        10
    db        9
    db        9
    db        "m$print_str("
    db        34
    db        "True"
    db        34
    db        ",fmtstyle)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "m$print_str("
    db        34
    db        "False"
    db        34
    db        ",fmtstyle)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_u64(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[40]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "sprintf(&.s,"
    db        34
    db        "%llu"
    db        34
    db        ",a)"
    db        10
    db        9
    db        9
    db        "printstr(&.s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_u64(a,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_r64(real x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[360]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "sprintf(&.s,"
    db        34
    db        "%f"
    db        34
    db        ",x)"
    db        10
    db        9
    db        9
    db        "printstr(&.s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_r64(x,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_r32(r32 x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "m$print_r64(x,fmtstyle)"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_c8(i64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[32]char s"
    db        10
    db        "!"
    db        9
    db        "int cc@s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "byte charmode:=0"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if fmtstyle then"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1, &fmt)"
    db        10
    db        9
    db        9
    db        "charmode:=fmt.charmode"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if charmode='M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a), 8, &.s, &fmt)"
    db        10
    db        "!"
    db        9
    db        9
    db        "n:=domultichar(ref char(&a), 8, &.str, fmt)"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!assume 'C'"
    db        10
    db        9
    db        9
    db        "(ref int(&s)^):=a"
    db        9
    db        10
    db        "!"
    db        9
    db        9
    db        "cc:=a"
    db        9
    db        10
    db        9
    db        9
    db        "s[9]:=0"
    db        10
    db        10
    db        9
    db        9
    db        "n:=getutfsize(s)"
    db        9
    db        9
    db        9
    db        "!isolate size of next char"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "printstr_n(s,n)"
    db        10
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_str(ichar s, fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if s=nil then"
    db        10
    db        9
    db        9
    db        "printstr("
    db        34
    db        "<null>"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "printstr(s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_str(s,-1,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if s=nil then"
    db        10
    db        9
    db        9
    db        "printstr("
    db        34
    db        "<null>"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "printstr_n(s,length)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_str(s,length,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_str_nf(ichar s)="
    db        10
    db        9
    db        "m$print_str(s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)="
    db        10
    db        "ABORTPROGRAM("
    db        34
    db        "PRTSL"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        10
    db        "!!"
    db        9
    db        "fmtrec fmt"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        "!"
    db        9
    db        9
    db        "printstr_n(cast(s.sliceptr),s.len)"
    db        10
    db        "!!"
    db        9
    db        9
    db        "printstr_n(cast(ss.str),ss.length)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        "!"
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "FORMATED PRINT SLICE NOT READY"
    db        34
    db        ")"
    db        10
    db        "!!"
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        "!!"
    db        9
    db        9
    db        "tostr_str(s,s.len,&fmt)"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_newline="
    db        10
    db        "!PUTS("
    db        34
    db        "<NEWLINE>"
    db        34
    db        ")"
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "nextfmtchars(1)"
    db        10
    db        9
    db        "printstr("
    db        34
    db        92
    db        "w"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_nogap="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_space="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "printstr("
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstr(ichar s)="
    db        10
    db        9
    db        "printstr_n(s,strlen(s))"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstr_n(ichar s,int n)="
    db        10
    db        10
    db        "!"
    db        9
    db        "return when n=0"
    db        10
    db        10
    db        "!"
    db        9
    db        "if niostack=1 and outdev in [std_io,file_io] then"
    db        10
    db        "!!puts("
    db        34
    db        "ADDTO BUFF"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "addtobuffer(s,n)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        "!printf("
    db        34
    db        "DUMPSTR %lld"
    db        92
    db        "n"
    db        34
    db        ", n)"
    db        10
    db        9
    db        9
    db        "dumpstr(s,n)"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstrn_app(ichar s, int length, filehandle f=nil)="
    db        10
    db        "if length then"
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "%.*s"
    db        34
    db        ",length,s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "fprintf(f,"
    db        34
    db        "%.*s"
    db        34
    db        ",length,s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc printchar(int ch)="
    db        10
    db        9
    db        "[4]char str"
    db        10
    db        10
    db        9
    db        "str[1]:=ch"
    db        10
    db        9
    db        "str[2]:=0"
    db        10
    db        9
    db        "printstr_n(str,1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc nextfmtchars(int lastx=0)="
    db        10
    db        9
    db        "char c"
    db        10
    db        9
    db        "ref char pstart"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "if not fmtstr then"
    db        9
    db        9
    db        9
    db        "!format not in use"
    db        10
    db        9
    db        9
    db        "if needgap then"
    db        10
    db        9
    db        9
    db        9
    db        "printchar(' ')"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "pstart:=fmtstr"
    db        10
    db        9
    db        "n:=0"
    db        10
    db        10
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        "c:=fmtstr^"
    db        10
    db        9
    db        9
    db        "case c"
    db        10
    db        9
    db        9
    db        "when '#' then"
    db        10
    db        9
    db        9
    db        9
    db        "if lastx then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "goto skip"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        "elsif not lastx then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n("
    db        34
    db        "|"
    db        34
    db        ",1)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "when '~' then"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "n:=0"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        "c:=fmtstr^"
    db        10
    db        9
    db        9
    db        9
    db        "if c then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printchar(c)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "pstart:=fmtstr"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        "skip:"
    db        10
    db        9
    db        9
    db        9
    db        "++n"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc strtofmt(ref char s,int slen,ref fmtrec fmt) ="
    db        9
    db        9
    db        "!PC_STRTOFMT"
    db        10
    db        "!convert format code string in s, to fmtrec at fmt^"
    db        10
    db        "!Format code is a string containing the following char codes (upper or lower when mostly)"
    db        10
    db        "!n"
    db        9
    db        "Width"
    db        10
    db        "!.n"
    db        9
    db        "Max width/precision"
    db        10
    db        "!A"
    db        9
    db        "Convert to upper case"
    db        10
    db        "!a"
    db        9
    db        "Convert to lower case"
    db        10
    db        "!B"
    db        9
    db        "Binary"
    db        10
    db        "!C"
    db        9
    db        "Show int as single n-bit (unicode) character"
    db        10
    db        "!D"
    db        9
    db        "Duplicate string returned via STRINT etc on heap"
    db        10
    db        "!E,F,G"
    db        9
    db        "Specify format for double (corresponds to C format codes)"
    db        10
    db        "!F"
    db        10
    db        "!G"
    db        10
    db        "!H"
    db        9
    db        "Hex"
    db        10
    db        "!JC"
    db        9
    db        "Justify centre"
    db        10
    db        "!JL"
    db        9
    db        "Justify left"
    db        10
    db        "!JR"
    db        9
    db        "Justify right"
    db        10
    db        "!M"
    db        9
    db        "Show int as multi-bit (unicode) character"
    db        10
    db        "!M"
    db        9
    db        "HEAPMODE???"
    db        10
    db        "!O"
    db        9
    db        "Octal"
    db        10
    db        "!Pc"
    db        9
    db        "Use padding char c"
    db        10
    db        "!Q"
    db        9
    db        "Add double quotes around string (and deal with embedded quotes)"
    db        10
    db        "!'"
    db        9
    db        "Add single quotes around string (and deal with embedded quotes)"
    db        10
    db        "!Sc"
    db        9
    db        "Use separator char c between every 3 or 4 digits"
    db        10
    db        "!Tc"
    db        9
    db        "Use terminator char c (typically B or H)"
    db        10
    db        "!U"
    db        9
    db        "Show ints as unsigned"
    db        10
    db        "!V"
    db        9
    db        "For ints, don't display: store value as parameter for subsequent '*'"
    db        10
    db        "!W"
    db        9
    db        "Unsigned"
    db        10
    db        "!Xn"
    db        9
    db        "Use base n (n is hex 0 to F)"
    db        10
    db        "!Z"
    db        9
    db        "Use "
    db        34
    db        "0"
    db        34
    db        " padding"
    db        10
    db        "!+"
    db        9
    db        "Always have + or - in front of integers"
    db        10
    db        "!~"
    db        9
    db        "Quote char is ~"
    db        10
    db        "!*"
    db        9
    db        "Same as n but uses parameter set with :'V' on previous int"
    db        10
    db        10
    db        9
    db        "int c, base"
    db        10
    db        9
    db        "byte wset"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "[0:100]char str"
    db        10
    db        10
    db        9
    db        "fmt^:=defaultfmt"
    db        10
    db        10
    db        9
    db        "if s=nil then return fi"
    db        10
    db        10
    db        9
    db        "if slen=-1 then slen:=strlen(s) fi"
    db        10
    db        10
    db        9
    db        "memcpy(&.str,s,slen)"
    db        9
    db        9
    db        "!convert s/slen to zero-terminated string"
    db        10
    db        9
    db        "str[slen]:=0"
    db        10
    db        9
    db        "s:=&.str"
    db        10
    db        10
    db        9
    db        "wset:=0"
    db        10
    db        9
    db        "while s^ do"
    db        10
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        "if c='A' then fmt.lettercase:='A'"
    db        10
    db        9
    db        9
    db        "elsif c='a' then fmt.lettercase:='a'"
    db        10
    db        9
    db        9
    db        "elseswitch toupper(c)"
    db        10
    db        9
    db        9
    db        "when 'B' then fmt.base:=2"
    db        10
    db        9
    db        9
    db        "when 'H' then fmt.base:=16"
    db        10
    db        9
    db        9
    db        "when 'O' then fmt.base:=8"
    db        10
    db        9
    db        9
    db        "when 'X' then"
    db        10
    db        9
    db        9
    db        9
    db        "base:=0"
    db        10
    db        9
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if c in '0'..'9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "base:=base*10+c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "if base in 2..16 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fmt.base:=base"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "when 'Q' then fmt.quotechar:='"
    db        34
    db        "'"
    db        10
    db        9
    db        9
    db        "when 'J' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.justify:=toupper(s^)"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'Z' then fmt.padchar:='0'"
    db        10
    db        9
    db        9
    db        "when 'S' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.sepchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'P' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.padchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'T' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.suffix:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'U' then fmt.usigned:='W'"
    db        10
    db        9
    db        9
    db        "when 'E' then fmt.realfmt:='e'"
    db        10
    db        9
    db        9
    db        "when 'F' then fmt.realfmt:='f'"
    db        10
    db        9
    db        9
    db        "when 'G' then fmt.realfmt:='g'"
    db        10
    db        9
    db        9
    db        "when 'D' then fmt.heapmode:='D'"
    db        10
    db        9
    db        9
    db        "when 'C' then fmt.charmode:='C'"
    db        10
    db        9
    db        9
    db        "when 'M' then fmt.charmode:='M'"
    db        10
    db        9
    db        9
    db        "when 'V' then fmt.param:='V'"
    db        10
    db        9
    db        9
    db        "when 'Y' then fmt.showtype:=1"
    db        10
    db        9
    db        9
    db        "when 'N' then fmt.newline:=1"
    db        10
    db        9
    db        9
    db        "elsecase c"
    db        10
    db        9
    db        9
    db        "when '.' then"
    db        10
    db        9
    db        9
    db        9
    db        "wset:=1"
    db        10
    db        9
    db        9
    db        "when comma,'_' then fmt.sepchar:=c"
    db        10
    db        9
    db        9
    db        "when '+' then fmt.plus:='+'"
    db        10
    db        9
    db        9
    db        "when '~' then fmt.quotechar:='~'"
    db        10
    db        9
    db        9
    db        "when '*' then"
    db        10
    db        9
    db        9
    db        9
    db        "n:=fmtparam"
    db        10
    db        9
    db        9
    db        9
    db        "goto gotwidth"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "if c>='0' and c<='9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "n:=c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if c>='0' and c<='9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "n:=n*10+c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        "gotwidth:"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if not wset then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fmt.minwidth:=n"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "wset:=1"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fmt.precision:=n"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "function domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int ="
    db        10
    db        "!there are n (4 or 8) chars at p.!"
    db        10
    db        "!There could be 0 to 4 or 8 printable chars converted to string at dest"
    db        10
    db        9
    db        "[0:20]char str"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "int nchars"
    db        10
    db        10
    db        9
    db        "q:=&.str"
    db        10
    db        10
    db        9
    db        "nchars:=n"
    db        10
    db        10
    db        9
    db        "to n do"
    db        10
    db        9
    db        9
    db        "if p^=0 then exit fi"
    db        10
    db        9
    db        9
    db        "q^:=p^"
    db        10
    db        9
    db        9
    db        "++q"
    db        10
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "q^:=0"
    db        10
    db        10
    db        9
    db        "return expandstr(&.str,dest,strlen(&.str),fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int ="
    db        9
    db        9
    db        "!EXPANDSTR"
    db        10
    db        "!s contains a partly stringified value."
    db        10
    db        "!widen s if necessary, according to fmt, and copy result to t"
    db        10
    db        "!n is current length of s"
    db        10
    db        "!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving"
    db        10
    db        "!a leading +/- when right-justifying with '0' padding."
    db        10
    db        "!t MUST be big enough for the expanded string; caller must take care of this"
    db        10
    db        "!result will be zero-terminated, for use in this module"
    db        10
    db        10
    db        9
    db        "int i,w,m"
    db        10
    db        10
    db        "!check to see if result is acceptable as it is"
    db        10
    db        9
    db        "w:=fmt.minwidth"
    db        10
    db        9
    db        "if w=0 or w<=n then"
    db        9
    db        9
    db        "! allow str to be longer than minwidth"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "(t+n)^:=0"
    db        10
    db        9
    db        9
    db        "return n"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if fmt.justify='L' then"
    db        9
    db        "! left-justify"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "t+:=n"
    db        10
    db        9
    db        9
    db        "for i:=1 to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "t^:=0"
    db        10
    db        9
    db        "elsif fmt.justify='R' then"
    db        10
    db        9
    db        9
    db        "if fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside "
    db        10
    db        9
    db        9
    db        9
    db        "t^:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "strncpy(t,s+1,n-1)"
    db        10
    db        9
    db        9
    db        9
    db        "(t+n-1)^:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "(t+n)^:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        "! centre-justify?"
    db        10
    db        10
    db        9
    db        9
    db        "m:=(w-n+1)/2"
    db        10
    db        9
    db        9
    db        "to m do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "t+:=n"
    db        10
    db        9
    db        9
    db        "to w-n-m do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "t^:=0"
    db        10
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return w"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function u64tostr(u64 aa,ref char s,word base,int sep)int ="
    db        9
    db        9
    db        "!U64TOSTR"
    db        10
    db        "!convert 64-bit int a to string in s^"
    db        10
    db        "!base is number base, usually 10 but can be 2 or 16. Other bases allowed"
    db        10
    db        "!result when a=minint (will give "
    db        34
    db        "<minint>"
    db        34
    db        ")"
    db        10
    db        9
    db        "[0:onesixty]char t"
    db        10
    db        9
    db        "u64 dd"
    db        10
    db        9
    db        "int i,j,k,g"
    db        10
    db        9
    db        "ref char s0"
    db        10
    db        10
    db        9
    db        "i:=0"
    db        10
    db        9
    db        "k:=0"
    db        10
    db        9
    db        "g:=(base=10|3|4)"
    db        10
    db        10
    db        9
    db        "repeat"
    db        10
    db        "!"
    db        9
    db        9
    db        "if base=10 then"
    db        9
    db        9
    db        9
    db        "!BUGGY FOR AA OVER I64.MAX"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "assem"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rcx, [aa]"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rax, rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rdx, 7378697629483820647"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "imul"
    db        9
    db        "rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rax, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rdx, rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sar"
    db        9
    db        9
    db        "rdx, 63"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sar"
    db        9
    db        9
    db        "rax, 2"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sub"
    db        9
    db        9
    db        "rax, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "lea"
    db        9
    db        9
    db        "rdx, [rax+rax*4]"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "add"
    db        9
    db        9
    db        "rdx, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sub"
    db        9
    db        9
    db        "rcx, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "[dd], rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "[aa], rax"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "end"
    db        10
    db        "!"
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "dd:=aa rem base"
    db        10
    db        9
    db        9
    db        9
    db        "aa:=aa/base"
    db        10
    db        "!"
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "t[++i]:=digits[dd]"
    db        10
    db        10
    db        "!BUG in separator logic, doesn't work when leading zeros used, eg. printing"
    db        10
    db        "!out a full length binary"
    db        10
    db        "!so perhaps move this out to expandstr"
    db        10
    db        9
    db        9
    db        "++k"
    db        10
    db        9
    db        9
    db        "if sep and aa<>0 and k=g then"
    db        10
    db        9
    db        9
    db        9
    db        "t[++i]:=sep"
    db        10
    db        9
    db        9
    db        9
    db        "k:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "until aa=0"
    db        10
    db        10
    db        9
    db        "j:=i"
    db        10
    db        9
    db        "s0:=s"
    db        10
    db        9
    db        "while i do"
    db        10
    db        9
    db        9
    db        "s^:=t[i--]"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "s^:=0"
    db        10
    db        10
    db        9
    db        "return j"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int ="
    db        10
    db        "!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec"
    db        10
    db        "!convert a to a string in s, according to fmt"
    db        10
    db        "!a basic conversion is done first,: the field manipulation is done"
    db        10
    db        "!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)"
    db        10
    db        "!returns length of s"
    db        10
    db        9
    db        "[0:onesixty]char str"
    db        9
    db        9
    db        9
    db        9
    db        "! allow for binary with separators!"
    db        10
    db        9
    db        "int n, usigned"
    db        10
    db        9
    db        "const i64 mindint=0x8000'0000'0000'0000"
    db        10
    db        10
    db        9
    db        "usigned:=0"
    db        10
    db        9
    db        "if fmt.usigned then"
    db        10
    db        9
    db        9
    db        "usigned:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if aa=mindint and not usigned then"
    db        9
    db        9
    db        "! minint"
    db        10
    db        10
    db        9
    db        9
    db        "str[0]:='-'"
    db        10
    db        9
    db        9
    db        "n:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if (not usigned and aa<0) or fmt.plus then"
    db        10
    db        9
    db        9
    db        9
    db        "if aa<0 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "aa:=-aa"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "str[0]:='-'"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "str[0]:='+'"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if fmt.suffix then"
    db        10
    db        9
    db        9
    db        "str[n]:=fmt.suffix"
    db        10
    db        9
    db        9
    db        "str[++n]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!str uses upper cases for hex/etc see if lc needed"
    db        10
    db        9
    db        "if (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'"
    db        9
    db        "then"
    db        9
    db        "! need lower when"
    db        10
    db        9
    db        9
    db        "convlcstring(&.str)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        9
    db        "return expandstr(&.str,s,n,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int ="
    db        9
    db        9
    db        "!U64TOSTRFMT"
    db        10
    db        "!see i64tostrfmt"
    db        10
    db        9
    db        "[0:onesixty]char str"
    db        9
    db        9
    db        9
    db        9
    db        "! allow for binary with separators!"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "n:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)"
    db        10
    db        10
    db        9
    db        "if fmt.suffix then"
    db        10
    db        9
    db        9
    db        "str[n]:=fmt.suffix"
    db        10
    db        9
    db        9
    db        "str[++n]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!str uses upper cases for hex/etc see if lc needed"
    db        10
    db        9
    db        "if fmt.base>10 or fmt.suffix and fmt.lettercase='a'"
    db        9
    db        "then"
    db        9
    db        "! need lower when"
    db        10
    db        "!"
    db        9
    db        9
    db        "convlcstring(&.str)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        9
    db        "return expandstr(&.str,s,n,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function i64mintostr(ref char s,int base,int sep)int ="
    db        9
    db        9
    db        "!I64MINTOSTR"
    db        10
    db        "!convert minint to string in s do not include minus sign"
    db        10
    db        "!return number of chars in string"
    db        10
    db        9
    db        "[0:onesixty]char t"
    db        10
    db        9
    db        "int i,j,k,g"
    db        10
    db        10
    db        9
    db        "case base"
    db        10
    db        9
    db        "when 10 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "9223372036854775808"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=3"
    db        10
    db        9
    db        "when 16 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "8000000000000000"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=1"
    db        10
    db        9
    db        "when 2 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "1000000000000000000000000000000000000000000000000000000000000000"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=7"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "<mindint>"
    db        34
    db        ")"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "i:=strlen(&t[0])"
    db        10
    db        9
    db        "s+:=i"
    db        10
    db        9
    db        "if sep then"
    db        10
    db        9
    db        9
    db        "s+:=j"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "s^:=0"
    db        10
    db        10
    db        9
    db        "k:=0"
    db        10
    db        9
    db        "g:=(base=10|3|4)"
    db        10
    db        10
    db        9
    db        "while i do"
    db        10
    db        9
    db        9
    db        "--s"
    db        10
    db        9
    db        9
    db        "s^:=t[i-- -1]"
    db        10
    db        9
    db        9
    db        "if sep and i and ++k=g then"
    db        10
    db        9
    db        9
    db        9
    db        "--s"
    db        10
    db        9
    db        9
    db        9
    db        "s^:=sep"
    db        10
    db        9
    db        9
    db        9
    db        "k:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return strlen(s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int ="
    db        10
    db        "!s is a string process according to fmtrec fmt^, and return result in t"
    db        10
    db        "!caller should check whether any changes are required to s (now it can just use s), but this"
    db        10
    db        "!check is done here anyway (with a simple copy to t)"
    db        10
    db        "!n is current length of s"
    db        10
    db        "!return length of t"
    db        10
    db        "!Three processing stages:"
    db        10
    db        "!1 Basic input string s"
    db        10
    db        "!2 Additions or mods: quotes, suffix, when conversion"
    db        10
    db        "!3 Width adjustment"
    db        10
    db        "!1 is detected here, 2 is done here, 3 is done by expandstr"
    db        10
    db        9
    db        "ref char u,v"
    db        10
    db        9
    db        "[256]char str"
    db        10
    db        9
    db        "int w,nheap"
    db        9
    db        9
    db        "! whether any heap storage is used  bytes allocated"
    db        10
    db        10
    db        9
    db        "nheap:=0"
    db        10
    db        10
    db        9
    db        "if fmt.quotechar or fmt.lettercase then"
    db        9
    db        9
    db        "! need local copy"
    db        10
    db        9
    db        9
    db        "if n<256 then"
    db        10
    db        9
    db        9
    db        9
    db        "u:=&.str"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "nheap:=n+3"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "! allow for quotes+terminator"
    db        10
    db        9
    db        9
    db        9
    db        "u:=pcm_alloc(nheap)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if fmt.quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        "v:=u"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=fmt.quotechar"
    db        10
    db        9
    db        9
    db        9
    db        "++v"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "strcpy(v,s)"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "v+:=n"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=fmt.quotechar"
    db        10
    db        9
    db        9
    db        9
    db        "++v"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "n+:=2"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(u,s,n)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "case fmt.lettercase"
    db        10
    db        9
    db        9
    db        "when 'a' then"
    db        9
    db        "! need lower when"
    db        10
    db        9
    db        9
    db        9
    db        "convlcstring(u)"
    db        10
    db        9
    db        9
    db        "when 'A' then"
    db        10
    db        9
    db        9
    db        9
    db        "convucstring(u)"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        "s:=u"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "w:=fmt.minwidth"
    db        10
    db        9
    db        "if w>n then"
    db        10
    db        9
    db        9
    db        "n:=expandstr(s,t,n,fmt)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "memcpy(t,s,n)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if nheap then"
    db        10
    db        9
    db        9
    db        "pcm_free(u,nheap)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return n"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_i64(i64 a, ref fmtrec fmt)="
    db        10
    db        9
    db        "[360]char str"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "case fmt.charmode"
    db        10
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        "n:=i64tostrfmt(a,&.str,fmt)"
    db        10
    db        9
    db        "when 'M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a),8,&.str,fmt)"
    db        10
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!assume 'C'"
    db        10
    db        9
    db        9
    db        "m$print_c8(a, nil)"
    db        10
    db        "!"
    db        9
    db        9
    db        "printchar(a)"
    db        9
    db        9
    db        9
    db        "!no other formatting allowed"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_u64(u64 a, ref fmtrec fmt)="
    db        10
    db        9
    db        "[360]char str"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "case fmt.charmode"
    db        10
    db        9
    db        "when 'M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a),8,&.str,fmt)"
    db        10
    db        10
    db        9
    db        "when 'C' then"
    db        10
    db        9
    db        9
    db        "m$print_c8(a, nil)"
    db        10
    db        "!"
    db        9
    db        9
    db        "printchar(a)"
    db        9
    db        9
    db        9
    db        "!no other formatting allowed"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "n:=u64tostrfmt(a,&.str,fmt)"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_r64(real x,ref fmtrec fmt) ="
    db        10
    db        9
    db        "[360]char str,str2"
    db        10
    db        9
    db        "[0:10]char cfmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "cfmt[0]:='%'"
    db        10
    db        10
    db        9
    db        "if fmt.precision then"
    db        10
    db        9
    db        9
    db        "cfmt[1]:='.'"
    db        10
    db        9
    db        9
    db        "cfmt[2]:='*'"
    db        10
    db        9
    db        9
    db        "cfmt[3]:=fmt.realfmt"
    db        10
    db        9
    db        9
    db        "cfmt[4]:=0"
    db        10
    db        9
    db        9
    db        "sprintf(&.str,&.cfmt,fmt.precision,x)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "cfmt[1]:=fmt.realfmt"
    db        10
    db        9
    db        9
    db        "cfmt[2]:=0"
    db        10
    db        9
    db        9
    db        "sprintf(&.str,&.cfmt,x)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        10
    db        9
    db        "n:=strlen(&.str)"
    db        9
    db        9
    db        "! current length"
    db        10
    db        10
    db        9
    db        "if n<fmt.minwidth then"
    db        10
    db        9
    db        9
    db        "n:=expandstr(&.str,&.str2,n,fmt)"
    db        10
    db        9
    db        9
    db        "strcpy(&.str,&.str2)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_str(ref char s, int oldlen, ref fmtrec fmt) ="
    db        10
    db        9
    db        "int newlen,n"
    db        10
    db        9
    db        "ref char t"
    db        10
    db        10
    db        "!try and work out size of formatted string"
    db        10
    db        9
    db        "if oldlen=-1 then"
    db        10
    db        9
    db        9
    db        "oldlen:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "newlen:=oldlen"
    db        10
    db        10
    db        9
    db        "if fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then"
    db        10
    db        9
    db        9
    db        "if fmt.quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        "newlen+:=2"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if fmt.minwidth>newlen then"
    db        10
    db        9
    db        9
    db        9
    db        "newlen:=fmt.minwidth"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "t:=pcm_alloc(newlen+1)"
    db        10
    db        9
    db        9
    db        "n:=strtostrfmt(s,t,oldlen,fmt)"
    db        10
    db        9
    db        9
    db        "if fmt.precision then"
    db        10
    db        9
    db        9
    db        9
    db        "n min:=fmt.precision"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "printstr_n(t,n)"
    db        10
    db        9
    db        9
    db        "pcm_free(t,newlen+1)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "printstr_n(s,oldlen)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "function getfmt(ichar fmtstyle)ref fmtrec="
    db        10
    db        9
    db        "static fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle then"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "return &fmt"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return &defaultfmt"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strint(i64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [100]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_i64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc getstrint(i64 a, ichar dest)="
    db        10
    db        9
    db        "m$print_startstr(dest)"
    db        10
    db        9
    db        "tostr_i64(a,getfmt(nil))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strword(u64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [100]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_u64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strreal(real a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [320]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_r64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function getstr(ichar s, ref fmtrec fmt)ichar="
    db        10
    db        9
    db        "if fmt.heapmode then"
    db        10
    db        9
    db        9
    db        "return pcm_copyheapstring(s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc initreadbuffer="
    db        10
    db        9
    db        "if rd_buffer then return fi"
    db        10
    db        9
    db        "rd_buffer:=pcm_alloc(rd_buffersize)"
    db        10
    db        9
    db        "rd_buffer^:=0"
    db        10
    db        9
    db        "rd_pos:=rd_lastpos:=rd_buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_conline="
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        10
    db        9
    db        "readlinen(nil,rd_buffer,rd_buffersize)"
    db        10
    db        10
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_fileline(filehandle f)="
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        10
    db        9
    db        "if f=filehandle(1) then"
    db        10
    db        "ABORTPROGRAM("
    db        34
    db        "READ CMDLINE"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_buffer^:=0"
    db        10
    db        "!"
    db        9
    db        9
    db        "p:=getcommandlinea()"
    db        10
    db        "!"
    db        9
    db        9
    db        "repeat"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        "!"
    db        9
    db        9
    db        "until p^ in [' ','"
    db        92
    db        "t',0]"
    db        10
    db        "!"
    db        9
    db        9
    db        "strcpy(rd_buffer, p)"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "readlinen(f,rd_buffer,rd_buffersize)"
    db        10
    db        10
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_strline(ichar s)="
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "n:=strlen(s)"
    db        10
    db        10
    db        9
    db        "if n<rd_buffersize then"
    db        10
    db        9
    db        9
    db        "strcpy(rd_buffer,s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "memcpy(rd_buffer,s,rd_buffersize-1)"
    db        10
    db        9
    db        9
    db        "(rd_buffer+rd_buffersize-1)^:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "rd_length:=n"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "function readitem(int &itemlength)ref char ="
    db        10
    db        "!read next item from rd_buffer"
    db        10
    db        "!identify a substring that can contain a name, int, real, string or filename"
    db        10
    db        "!return updated position of s that points past the item and past the immediate"
    db        10
    db        "!terminator "
    db        10
    db        "!information about the read item is returned in itemstr, which points to"
    db        10
    db        "!the start of the item, and in itemlength. Item excludes any surrounding whitespace"
    db        10
    db        "!Item can be quoted, then the item points inside the quotes"
    db        10
    db        "!Any embedded quotes are removed, and the characters moved up. The item will"
    db        10
    db        "!be that reduced subsequence"
    db        10
    db        "!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different."
    db        10
    db        "!I can mitigate this by adding spaces between the end of the item, and the next item,"
    db        10
    db        "!overwriting also the terminator. But this won't restore the line if one of the next"
    db        10
    db        "!reads is literal, using 'L' or 'C' codes."
    db        10
    db        9
    db        "ref char p,s,itemstr"
    db        10
    db        9
    db        "char quotechar, c"
    db        10
    db        10
    db        9
    db        "unless rd_buffer then "
    db        10
    db        9
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "end unless"
    db        10
    db        10
    db        9
    db        "s:=rd_pos"
    db        10
    db        10
    db        "!scan string, eliminating leading white space"
    db        10
    db        9
    db        "while s^=' ' or s^=9 do"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "itemstr:=s"
    db        10
    db        9
    db        "rd_lastpos:=rd_pos:=s"
    db        10
    db        10
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        "termchar:=0"
    db        10
    db        9
    db        9
    db        "itemlength:=0"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "quotechar:=0"
    db        10
    db        9
    db        "if s^='"
    db        34
    db        "' then"
    db        10
    db        9
    db        9
    db        "quotechar:='"
    db        34
    db        "'"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "elsif s^='"
    db        92
    db        "'' then"
    db        10
    db        9
    db        9
    db        "quotechar:='"
    db        92
    db        "''"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!loop reading characters until separator or end reached"
    db        10
    db        9
    db        "p:=itemstr:=s"
    db        10
    db        10
    db        9
    db        "while s^ do"
    db        10
    db        9
    db        9
    db        "c:=s++^"
    db        10
    db        9
    db        9
    db        "case c"
    db        10
    db        9
    db        9
    db        "when ' ', 9, comma, '=' then"
    db        9
    db        9
    db        "! separator"
    db        10
    db        9
    db        9
    db        9
    db        "if quotechar or p=s then"
    db        9
    db        9
    db        9
    db        "!can be considered part of name if inside quotes, or is only char"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "goto normalchar"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "termchar:=c"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        "normalchar:"
    db        10
    db        9
    db        9
    db        9
    db        "if c=quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if s^=quotechar then"
    db        9
    db        "! embedded quote"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "p^:=c"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "! end of name"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "termchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if termchar in [',', '='] then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "termchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "p^:=c"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        "termchar:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "itemlength:=p-itemstr"
    db        9
    db        9
    db        9
    db        9
    db        "! actual length of token"
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        10
    db        9
    db        "return itemstr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strtoint(ichar s,int length=-1, word base=10)i64="
    db        10
    db        "!return point to next char after terminator (which can be just off length of string)"
    db        10
    db        9
    db        "byte signd"
    db        10
    db        9
    db        "u64 aa"
    db        10
    db        9
    db        "word c,d"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        10
    db        9
    db        "if length=-1 then"
    db        10
    db        9
    db        9
    db        "length:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "!check for sign"
    db        10
    db        9
    db        "signd:=0"
    db        10
    db        9
    db        "if length and s^='-' then"
    db        10
    db        9
    db        9
    db        "signd:=1; ++s; --length"
    db        10
    db        9
    db        "elsif length and s^='+' then"
    db        10
    db        9
    db        9
    db        "++s; --length"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "aa:=0"
    db        10
    db        9
    db        "while length do"
    db        10
    db        9
    db        9
    db        "c:=s++^"
    db        10
    db        9
    db        9
    db        "--length"
    db        10
    db        9
    db        9
    db        "if c in 'A'..'F' then d:=c-'A'+10"
    db        10
    db        9
    db        9
    db        "elsif c in 'a'..'f' then d:=c-'a'+10"
    db        10
    db        9
    db        9
    db        "elsif c in '0'..'9' then d:=c-'0'"
    db        10
    db        9
    db        9
    db        "elsif c in ['_', '"
    db        92
    db        "''] then"
    db        10
    db        9
    db        9
    db        9
    db        "nextloop"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "if d>=base then"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "aa:=aa*base+d"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "if signd then"
    db        10
    db        9
    db        9
    db        "return -aa"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return aa"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$read_i64(int fmt=0)i64="
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        10
    db        9
    db        "fmt:=toupper(fmt)"
    db        10
    db        10
    db        9
    db        "case fmt"
    db        10
    db        9
    db        "when 'C' then"
    db        10
    db        9
    db        9
    db        "rd_lastpos:=rd_pos"
    db        10
    db        9
    db        9
    db        "if rd_pos^ then"
    db        10
    db        9
    db        9
    db        9
    db        "return rd_pos++^"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "when 'T' then"
    db        10
    db        9
    db        9
    db        "return termchar"
    db        10
    db        9
    db        "when 'E' then"
    db        10
    db        9
    db        9
    db        "return itemerror"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        "case fmt"
    db        10
    db        9
    db        "when 0,'I' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length)"
    db        10
    db        9
    db        "when 'B' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length,2)"
    db        10
    db        9
    db        "when 'H' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length,16)"
    db        10
    db        9
    db        "esac"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$read_r64(int fmt=0)real="
    db        10
    db        9
    db        "[512]char str"
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        9
    db        "i32 numlength"
    db        10
    db        9
    db        "real x"
    db        10
    db        10
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        "if length=0 or length>=str.len then"
    db        9
    db        9
    db        "!assume not a real"
    db        10
    db        9
    db        9
    db        "return 0.0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(&.str,s,length)"
    db        10
    db        9
    db        "str[length+1]:=0"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        10
    db        9
    db        "if sscanf(&.str,"
    db        34
    db        "%lf%n"
    db        34
    db        ", &x, &numlength)=0 or numlength<>length then"
    db        10
    db        9
    db        9
    db        "x:=0.0"
    db        10
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_str(ref char dest, int destlen=0,fmt=0)="
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        9
    db        "if fmt in ['L','l'] then"
    db        10
    db        9
    db        9
    db        "s:=rd_pos"
    db        10
    db        9
    db        9
    db        "length:=rd_buffer+rd_length-rd_pos"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        9
    db        "if fmt in ['N','n'] then"
    db        10
    db        9
    db        9
    db        9
    db        "iconvlcn(s,length)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if destlen>0 then"
    db        10
    db        9
    db        9
    db        "if length>=destlen then"
    db        10
    db        9
    db        9
    db        9
    db        "length:=destlen-1"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(dest,s,length)"
    db        10
    db        9
    db        "(dest+length)^:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc readstr(ref char dest, int fmt=0,destlen=0)="
    db        10
    db        9
    db        "m$read_str(dest,destlen,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc rereadln="
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=rd_pos"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc reread="
    db        10
    db        9
    db        "rd_pos:=rd_lastpos"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function valint(ichar s, int fmt=0)i64="
    db        10
    db        9
    db        "ref char old_pos, old_lastpos"
    db        10
    db        9
    db        "i64 aa"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "old_pos:=rd_pos"
    db        10
    db        9
    db        "old_lastpos:=rd_lastpos"
    db        10
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        9
    db        "aa:=m$read_i64(fmt)"
    db        10
    db        9
    db        "rd_pos:=old_pos"
    db        10
    db        9
    db        "rd_lastpos:=old_lastpos"
    db        10
    db        9
    db        "return aa"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function valreal(ichar s)real="
    db        10
    db        9
    db        "ref char old_pos, old_lastpos"
    db        10
    db        9
    db        "real x"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "old_pos:=rd_pos"
    db        10
    db        9
    db        "old_lastpos:=rd_lastpos"
    db        10
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        9
    db        "x:=m$read_r64()"
    db        10
    db        9
    db        "rd_pos:=old_pos"
    db        10
    db        9
    db        "rd_lastpos:=old_lastpos"
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc mclunimpl(ichar mess)="
    db        10
    db        9
    db        "printf("
    db        34
    db        "MCL-UNIMPL: %s"
    db        92
    db        "n"
    db        34
    db        ",mess)"
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc dumpstr(ichar s, int n, fbuffer=0)="
    db        10
    db        "!fbuffer=1 when outputting contents of buffer"
    db        10
    db        10
    db        9
    db        "ref ref char p"
    db        10
    db        10
    db        9
    db        "if outdev=str_io then"
    db        10
    db        9
    db        9
    db        "p:=cast(outchan)"
    db        10
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(p^,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "p^+:=n"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "p^^:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return when n=0"
    db        10
    db        9
    db        "if fbuffer and n>=2 and outdev=std_io then"
    db        10
    db        9
    db        9
    db        "--printptr"
    db        9
    db        9
    db        9
    db        9
    db        "!point to last char"
    db        10
    db        9
    db        9
    db        "if printptr^=10 then"
    db        10
    db        9
    db        9
    db        9
    db        "if (printptr-1)^=13 then"
    db        9
    db        9
    db        "!crlf"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "(printptr-1)^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!lf only"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printptr^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "puts(printbuffer)"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "case outdev"
    db        10
    db        9
    db        "when std_io then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "%.*s"
    db        34
    db        ",n,s)"
    db        10
    db        9
    db        "when file_io then"
    db        10
    db        9
    db        9
    db        "fprintf(outchan,"
    db        34
    db        "%.*s"
    db        34
    db        ",n,s)"
    db        10
    db        9
    db        "esac"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc dumpprintbuffer="
    db        10
    db        9
    db        "if printlen then"
    db        10
    db        9
    db        9
    db        "dumpstr(&.printbuffer,printlen,1)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc resetprintbuffer="
    db        10
    db        9
    db        "printptr:=&.printbuffer"
    db        10
    db        9
    db        "printlen:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc addtobuffer(ichar s, int n)="
    db        10
    db        9
    db        "if printlen+n>=(printbuffer.len-8) then"
    db        10
    db        9
    db        9
    db        "dumpprintbuffer()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if n<printbuffer.len then"
    db        10
    db        9
    db        9
    db        "memcpy(printptr,s,n)"
    db        10
    db        9
    db        9
    db        "printptr+:=n"
    db        10
    db        9
    db        9
    db        "printlen+:=n"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "dumpstr(s, n)"
    db        9
    db        9
    db        9
    db        "!don't bother with buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "func getutfsize(ref char s)int ="
    db        10
    db        "!work out the size in bytes of the ascii or utf8 character that s points to"
    db        10
    db        9
    db        "int a"
    db        10
    db        10
    db        9
    db        "a:=s++^"
    db        10
    db        10
    db        9
    db        "if a=0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!end of string"
    db        10
    db        9
    db        9
    db        "0"
    db        10
    db        9
    db        "elsif a.[7]=0 then"
    db        9
    db        9
    db        9
    db        9
    db        "!ascii"
    db        10
    db        9
    db        9
    db        "1"
    db        10
    db        9
    db        "elsif a.[7..5]=2x110 then"
    db        10
    db        9
    db        9
    db        "2"
    db        10
    db        9
    db        "elsif a.[7..4]=2x1110 then"
    db        10
    db        9
    db        9
    db        "3"
    db        10
    db        9
    db        "elsif a.[7..3]=2x11110 then"
    db        10
    db        9
    db        9
    db        "4"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!error: just assume a byte of random binary"
    db        10
    db        9
    db        9
    db        "1"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "!export fun fraction(real x)real = fmod(x,1.0)"
    db        10
    db        10
    db        "export fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))"
    db        10
    db        10
    db        "export func m$sign_r64(real x)real ="
    db        10
    db        9
    db        "if x<0 then return -1 fi"
    db        10
    db        9
    db        "if x>0 then return 1 fi"
    db        10
    db        9
    db        "0"
    db        10
    db        "end"
    db        10
    db        0
L11478:
    db        "global record procinforec="
    db        10
    db        9
    db        "u16"
    db        9
    db        9
    db        9
    db        "fnindex"
    db        10
    db        9
    db        "byte"
    db        9
    db        9
    db        "rettype"
    db        10
    db        9
    db        "byte"
    db        9
    db        9
    db        "nparams"
    db        10
    db        9
    db        "[12]byte"
    db        9
    db        "paramlist"
    db        10
    db        "end"
    db        10
    db        10
    db        "!for print/read routines"
    db        10
    db        "!------------------------------------------"
    db        10
    db        "export record fmtrec="
    db        9
    db        "! (default)"
    db        10
    db        9
    db        "byte"
    db        9
    db        "minwidth"
    db        9
    db        "! n (0)   min field width (0 if not used or don't care)"
    db        10
    db        9
    db        "i8"
    db        9
    db        9
    db        "precision"
    db        9
    db        "! .n (0)   number of decimals/significant figures/max width"
    db        10
    db        9
    db        "byte"
    db        9
    db        "base"
    db        9
    db        9
    db        "! B,H or Xn (10)  2 to 16"
    db        10
    db        10
    db        9
    db        "char"
    db        9
    db        "quotechar"
    db        9
    db        "! Qc (0)   0 or '"
    db        34
    db        "' or c"
    db        10
    db        9
    db        "char"
    db        9
    db        "padchar"
    db        9
    db        9
    db        "! Pc, Z (' ')"
    db        10
    db        9
    db        "char"
    db        9
    db        "realfmt"
    db        9
    db        9
    db        "! E,F,G ('f') 'e' or 'f' or 'g'"
    db        10
    db        10
    db        9
    db        "char"
    db        9
    db        "plus"
    db        9
    db        9
    db        "! (0)   0 or '+'"
    db        10
    db        9
    db        "char"
    db        9
    db        "sepchar"
    db        9
    db        9
    db        "! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits"
    db        10
    db        9
    db        "char"
    db        9
    db        "lettercase"
    db        9
    db        "! A,a ('A') 'A' or 'a'"
    db        10
    db        9
    db        "char"
    db        9
    db        "justify"
    db        9
    db        9
    db        "! JL, JR, JC ('R') 'L' or 'R' or 'C'?"
    db        10
    db        9
    db        "char"
    db        9
    db        "suffix"
    db        9
    db        9
    db        "! Tc (0)   0 or 'B' or 'H' or c"
    db        10
    db        9
    db        "char"
    db        9
    db        "usigned"
    db        9
    db        9
    db        "! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)"
    db        10
    db        9
    db        "char"
    db        9
    db        "charmode"
    db        9
    db        "! C,M (0)  0 or 'C' or 'M'"
    db        9
    db        "o/p int as int or single char or multi-char"
    db        10
    db        9
    db        "char"
    db        9
    db        "heapmode"
    db        9
    db        "! D (0)  'D' for str-functions, return ptr to heap string"
    db        10
    db        9
    db        "char"
    db        9
    db        "param"
    db        9
    db        9
    db        "! Use int value for <fmtparam>"
    db        10
    db        9
    db        "byte"
    db        9
    db        "spare : (showtype:1, newline:1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "int fmtparam"
    db        9
    db        9
    db        9
    db        "!as set with :'V'"
    db        10
    db        10
    db        "enumdata ="
    db        10
    db        9
    db        "std_io,file_io,str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "const comma = ','"
    db        10
    db        10
    db        "export int $cmdskip"
    db        9
    db        9
    db        9
    db        "!0 unless set by READMCX/etc"
    db        10
    db        10
    db        "export int needgap"
    db        9
    db        9
    db        9
    db        "= 0"
    db        10
    db        "int outdev"
    db        9
    db        9
    db        9
    db        "= std_io"
    db        10
    db        "filehandle outchan"
    db        9
    db        "= nil"
    db        10
    db        "ref char fmtstr "
    db        9
    db        "= nil"
    db        10
    db        10
    db        "const maxiostack=10"
    db        10
    db        "[maxiostack]filehandle"
    db        9
    db        "outchan_stack"
    db        10
    db        "[maxiostack]int"
    db        9
    db        9
    db        9
    db        "outdev_stack"
    db        10
    db        "[maxiostack]ref char"
    db        9
    db        "fmtstr_stack"
    db        10
    db        "[maxiostack]byte"
    db        9
    db        9
    db        "needgap_stack"
    db        10
    db        10
    db        "[maxiostack]ref char"
    db        9
    db        "ptr_stack"
    db        9
    db        9
    db        "!this one doesn't need pushing, as each is pointed to from outchan"
    db        10
    db        "int niostack=0"
    db        10
    db        10
    db        "[0:]char digits=s"
    db        34
    db        "0123456789ABCDEF"
    db        34
    db        10
    db        "const onesixty=360"
    db        10
    db        "fmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)"
    db        10
    db        10
    db        "!Read buffer vars"
    db        10
    db        "export const rd_buffersize = 16384"
    db        9
    db        "!total capacity of line buffer"
    db        10
    db        10
    db        "export ref char rd_buffer"
    db        9
    db        9
    db        "! point to start of read buffer"
    db        10
    db        "export int rd_length"
    db        9
    db        9
    db        9
    db        "! length of this line (as read by readln)"
    db        10
    db        "export ref char rd_pos"
    db        9
    db        9
    db        9
    db        "! current position it's up to (next read starts here)"
    db        10
    db        "export ref char rd_lastpos"
    db        9
    db        9
    db        "! set by sread() just before reading used for reread()"
    db        10
    db        10
    db        "int termchar"
    db        9
    db        9
    db        9
    db        "! terminator char set by readxxx()"
    db        10
    db        "int itemerror"
    db        9
    db        9
    db        9
    db        "!"
    db        9
    db        "set by some read functions, eg for reals"
    db        10
    db        10
    db        "[4096]char printbuffer"
    db        10
    db        "ichar printptr"
    db        10
    db        "int printlen"
    db        10
    db        10
    db        "!------------------------------------------"
    db        10
    db        10
    db        "const maxparam=128"
    db        10
    db        "export int nsysparams"
    db        10
    db        "export int ncmdparams"
    db        10
    db        "export int nenvstrings"
    db        10
    db        "export [maxparam]ichar sysparams"
    db        10
    db        "!export ref[]ichar cmdparams"
    db        10
    db        "export ref[0:]ichar cmdparams"
    db        10
    db        "export ref[]ichar envstrings"
    db        10
    db        "!export [maxparam]ichar envstrings"
    db        10
    db        10
    db        "proc start="
    db        10
    db        9
    db        "i32 nargs"
    db        10
    db        9
    db        "int nargs64"
    db        10
    db        9
    db        "ref[]ichar args"
    db        10
    db        9
    db        "static [128]byte startupinfo"
    db        9
    db        9
    db        9
    db        "! 68 or 104 bytes"
    db        10
    db        9
    db        "int res"
    db        10
    db        10
    db        "!res:=1234567"
    db        10
    db        "!res:=0x1234567"
    db        10
    db        "!"
    db        10
    db        "!CPL "
    db        34
    db        "MSYS/START"
    db        34
    db        10
    db        10
    db        9
    db        "res:=__getmainargs(&nargs,cast(&args),cast(&envstrings),0,cast(&startupinfo))"
    db        10
    db        "!"
    db        9
    db        "res:=__getmainargs(&nargs,cast(&args),nil,0,cast(&startupinfo))"
    db        10
    db        9
    db        10
    db        9
    db        "nsysparams:=nargs"
    db        10
    db        10
    db        9
    db        "if nsysparams>maxparam then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Too many params"
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "stop 50"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "nargs64:=nargs"
    db        9
    db        9
    db        9
    db        "!bug when using 32-bit limit when compiled with mm"
    db        10
    db        9
    db        "for i:=1 to nargs64 do"
    db        10
    db        9
    db        9
    db        "sysparams[i]:=args[i]"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        10
    db        "!assume nsysparams is >=1, since first is always the program name"
    db        10
    db        9
    db        "ncmdparams:=nsysparams-($cmdskip+1)"
    db        10
    db        9
    db        "cmdparams:=cast(&sysparams[$cmdskip+1])"
    db        10
    db        10
    db        9
    db        "int j:=1"
    db        10
    db        9
    db        "nenvstrings:=0"
    db        10
    db        9
    db        "while envstrings[j] do"
    db        10
    db        9
    db        9
    db        "++nenvstrings"
    db        10
    db        9
    db        9
    db        "++j"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc pushio="
    db        10
    db        9
    db        "if niostack>=maxiostack then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Too many io levels"
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "stop 53"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "++niostack"
    db        10
    db        9
    db        "outchan_stack[niostack]"
    db        9
    db        ":= outchan"
    db        10
    db        9
    db        "outdev_stack[niostack]"
    db        9
    db        ":= outdev"
    db        10
    db        9
    db        "fmtstr_stack[niostack]"
    db        9
    db        ":= fmtstr"
    db        10
    db        9
    db        "needgap_stack[niostack]"
    db        9
    db        ":= needgap"
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "fmtstr:=nil"
    db        10
    db        9
    db        "outchan:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startfile(ref void dev)="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        9
    db        "outchan:=cast(dev)"
    db        10
    db        9
    db        "if dev then"
    db        10
    db        9
    db        9
    db        "outdev:=file_io"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "outdev:=std_io"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startstr(ref char s)="
    db        10
    db        9
    db        "ref ref char p"
    db        10
    db        9
    db        "pushio()"
    db        10
    db        10
    db        9
    db        "ptr_stack[niostack]:=s"
    db        10
    db        9
    db        "p:=&ptr_stack[niostack]"
    db        10
    db        10
    db        9
    db        "outchan:=cast(p)"
    db        10
    db        9
    db        "outdev:=str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startptr(ref ref char p)="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        10
    db        9
    db        "outchan:=cast(p)"
    db        10
    db        9
    db        "outdev:=str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startcon="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        9
    db        "outdev:=std_io"
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_setfmt(ref char format)="
    db        10
    db        9
    db        "fmtstr:=format"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_end="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "nextfmtchars(1)"
    db        10
    db        9
    db        "if niostack=1 and outdev in [std_io,file_io] then"
    db        10
    db        9
    db        9
    db        "dumpprintbuffer()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if niostack=0 then return fi"
    db        10
    db        9
    db        "outchan"
    db        9
    db        ":= outchan_stack[niostack]"
    db        10
    db        9
    db        "outdev"
    db        9
    db        ":= outdev_stack[niostack]"
    db        10
    db        9
    db        "fmtstr"
    db        9
    db        ":= fmtstr_stack[niostack]"
    db        10
    db        9
    db        "needgap"
    db        9
    db        ":= needgap_stack[niostack]"
    db        10
    db        10
    db        9
    db        "--niostack"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_ptr(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "fmtstyle:="
    db        34
    db        "z8H"
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "m$print_u64(a,fmtstyle)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_ptr_nf(u64 a)="
    db        10
    db        9
    db        "m$print_ptr(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_i64(i64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[40]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "if a>=0 then"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(a,&.s,10,0)"
    db        10
    db        9
    db        9
    db        "elsif a=i64.min then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt:=defaultfmt"
    db        10
    db        9
    db        9
    db        9
    db        "dofmt"
    db        10
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "s[1]:='-'"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(-a,&s[2],10,0)+1"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "printstr_n(&.s,n)"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "if fmt.param='V' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmtparam:=a"
    db        10
    db        9
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        "dofmt:"
    db        10
    db        9
    db        9
    db        9
    db        "tostr_i64(a,&fmt)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_i64_nf(i64 a)="
    db        10
    db        9
    db        "m$print_i64(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_bool(i64 a, ichar fmtstyle=nil)="
    db        10
    db        9
    db        "if a then"
    db        10
    db        9
    db        9
    db        "m$print_str("
    db        34
    db        "True"
    db        34
    db        ",fmtstyle)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "m$print_str("
    db        34
    db        "False"
    db        34
    db        ",fmtstyle)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_u64(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[40]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "sprintf(&.s,"
    db        34
    db        "%llu"
    db        34
    db        ",a)"
    db        10
    db        9
    db        9
    db        "printstr(&.s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_u64(a,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_r64(real x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[360]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "sprintf(&.s,"
    db        34
    db        "%f"
    db        34
    db        ",x)"
    db        10
    db        9
    db        9
    db        "printstr(&.s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_r64(x,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_r32(r32 x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "m$print_r64(x,fmtstyle)"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_c8(i64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[32]char s"
    db        10
    db        "!"
    db        9
    db        "int cc@s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "byte charmode:=0"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if fmtstyle then"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1, &fmt)"
    db        10
    db        9
    db        9
    db        "charmode:=fmt.charmode"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if charmode='M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a), 8, &.s, &fmt)"
    db        10
    db        "!"
    db        9
    db        9
    db        "n:=domultichar(ref char(&a), 8, &.str, fmt)"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!assume 'C'"
    db        10
    db        9
    db        9
    db        "(ref int(&s)^):=a"
    db        9
    db        10
    db        9
    db        9
    db        "s[9]:=0"
    db        10
    db        10
    db        9
    db        9
    db        "n:=getutfsize(s)"
    db        9
    db        9
    db        9
    db        "!isolate size of next char"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "printstr_n(s,n)"
    db        10
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_str(ichar s, fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if s=nil then"
    db        10
    db        9
    db        9
    db        "printstr("
    db        34
    db        "<null>"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "printstr(s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_str(s,-1,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if s=nil then"
    db        10
    db        9
    db        9
    db        "printstr("
    db        34
    db        "<null>"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "printstr_n(s,length)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_str(s,length,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_str_nf(ichar s)="
    db        10
    db        9
    db        "m$print_str(s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)="
    db        10
    db        "ABORTPROGRAM("
    db        34
    db        "PRTSL"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        10
    db        "!!"
    db        9
    db        "fmtrec fmt"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        "!"
    db        9
    db        9
    db        "printstr_n(cast(s.sliceptr),s.len)"
    db        10
    db        "!!"
    db        9
    db        9
    db        "printstr_n(cast(ss.str),ss.length)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        "!"
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "FORMATED PRINT SLICE NOT READY"
    db        34
    db        ")"
    db        10
    db        "!!"
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        "!!"
    db        9
    db        9
    db        "tostr_str(s,s.len,&fmt)"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_newline="
    db        10
    db        "!PUTS("
    db        34
    db        "<NEWLINE>"
    db        34
    db        ")"
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "nextfmtchars(1)"
    db        10
    db        9
    db        "printstr("
    db        34
    db        92
    db        "w"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_nogap="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_space="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "printstr("
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstr(ichar s)="
    db        10
    db        9
    db        "printstr_n(s,strlen(s))"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstr_n(ichar s,int n)="
    db        10
    db        10
    db        "!"
    db        9
    db        "return when n=0"
    db        10
    db        10
    db        "!"
    db        9
    db        "if niostack=1 and outdev in [std_io,file_io] then"
    db        10
    db        "!!puts("
    db        34
    db        "ADDTO BUFF"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "addtobuffer(s,n)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        "!printf("
    db        34
    db        "DUMPSTR %lld"
    db        92
    db        "n"
    db        34
    db        ", n)"
    db        10
    db        9
    db        9
    db        "dumpstr(s,n)"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstrn_app(ichar s, int length, filehandle f=nil)="
    db        10
    db        "if length then"
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "%.*s"
    db        34
    db        ",length,s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "fprintf(f,"
    db        34
    db        "%.*s"
    db        34
    db        ",length,s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc printchar(int ch)="
    db        10
    db        9
    db        "[4]char str"
    db        10
    db        10
    db        9
    db        "str[1]:=ch"
    db        10
    db        9
    db        "str[2]:=0"
    db        10
    db        9
    db        "printstr_n(str,1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc nextfmtchars(int lastx=0)="
    db        10
    db        9
    db        "char c"
    db        10
    db        9
    db        "ref char pstart"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "if not fmtstr then"
    db        9
    db        9
    db        9
    db        "!format not in use"
    db        10
    db        9
    db        9
    db        "if needgap then"
    db        10
    db        9
    db        9
    db        9
    db        "printchar(' ')"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "pstart:=fmtstr"
    db        10
    db        9
    db        "n:=0"
    db        10
    db        10
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        "c:=fmtstr^"
    db        10
    db        9
    db        9
    db        "case c"
    db        10
    db        9
    db        9
    db        "when '#' then"
    db        10
    db        9
    db        9
    db        9
    db        "if lastx then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "goto skip"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        "elsif not lastx then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n("
    db        34
    db        "|"
    db        34
    db        ",1)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "when '~' then"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "n:=0"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        "c:=fmtstr^"
    db        10
    db        9
    db        9
    db        9
    db        "if c then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printchar(c)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "pstart:=fmtstr"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        "skip:"
    db        10
    db        9
    db        9
    db        9
    db        "++n"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc strtofmt(ref char s,int slen,ref fmtrec fmt) ="
    db        9
    db        9
    db        "!PC_STRTOFMT"
    db        10
    db        "!convert format code string in s, to fmtrec at fmt^"
    db        10
    db        "!Format code is a string containing the following char codes (upper or lower when mostly)"
    db        10
    db        "!n"
    db        9
    db        "Width"
    db        10
    db        "!.n"
    db        9
    db        "Max width/precision"
    db        10
    db        "!A"
    db        9
    db        "Convert to upper case"
    db        10
    db        "!a"
    db        9
    db        "Convert to lower case"
    db        10
    db        "!B"
    db        9
    db        "Binary"
    db        10
    db        "!C"
    db        9
    db        "Show int as single n-bit (unicode) character"
    db        10
    db        "!D"
    db        9
    db        "Duplicate string returned via STRINT etc on heap"
    db        10
    db        "!E,F,G"
    db        9
    db        "Specify format for double (corresponds to C format codes)"
    db        10
    db        "!F"
    db        10
    db        "!G"
    db        10
    db        "!H"
    db        9
    db        "Hex"
    db        10
    db        "!JC"
    db        9
    db        "Justify centre"
    db        10
    db        "!JL"
    db        9
    db        "Justify left"
    db        10
    db        "!JR"
    db        9
    db        "Justify right"
    db        10
    db        "!M"
    db        9
    db        "Show int as multi-bit (unicode) character"
    db        10
    db        "!M"
    db        9
    db        "HEAPMODE???"
    db        10
    db        "!O"
    db        9
    db        "Octal"
    db        10
    db        "!Pc"
    db        9
    db        "Use padding char c"
    db        10
    db        "!Q"
    db        9
    db        "Add double quotes around string (and deal with embedded quotes)"
    db        10
    db        "!'"
    db        9
    db        "Add single quotes around string (and deal with embedded quotes)"
    db        10
    db        "!Sc"
    db        9
    db        "Use separator char c between every 3 or 4 digits"
    db        10
    db        "!Tc"
    db        9
    db        "Use terminator char c (typically B or H)"
    db        10
    db        "!U"
    db        9
    db        "Show ints as unsigned"
    db        10
    db        "!V"
    db        9
    db        "For ints, don't display: store value as parameter for subsequent '*'"
    db        10
    db        "!W"
    db        9
    db        "Unsigned"
    db        10
    db        "!Xn"
    db        9
    db        "Use base n (n is hex 0 to F)"
    db        10
    db        "!Z"
    db        9
    db        "Use "
    db        34
    db        "0"
    db        34
    db        " padding"
    db        10
    db        "!+"
    db        9
    db        "Always have + or - in front of integers"
    db        10
    db        "!~"
    db        9
    db        "Quote char is ~"
    db        10
    db        "!*"
    db        9
    db        "Same as n but uses parameter set with :'V' on previous int"
    db        10
    db        10
    db        9
    db        "int c, base"
    db        10
    db        9
    db        "byte wset"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "[0:100]char str"
    db        10
    db        10
    db        9
    db        "fmt^:=defaultfmt"
    db        10
    db        10
    db        9
    db        "if s=nil then return fi"
    db        10
    db        10
    db        9
    db        "if slen=-1 then slen:=strlen(s) fi"
    db        10
    db        10
    db        9
    db        "memcpy(&.str,s,slen)"
    db        9
    db        9
    db        "!convert s/slen to zero-terminated string"
    db        10
    db        9
    db        "str[slen]:=0"
    db        10
    db        9
    db        "s:=&.str"
    db        10
    db        10
    db        9
    db        "wset:=0"
    db        10
    db        9
    db        "while s^ do"
    db        10
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        "if c='A' then fmt.lettercase:='A'"
    db        10
    db        9
    db        9
    db        "elsif c='a' then fmt.lettercase:='a'"
    db        10
    db        9
    db        9
    db        "elseswitch toupper(c)"
    db        10
    db        9
    db        9
    db        "when 'B' then fmt.base:=2"
    db        10
    db        9
    db        9
    db        "when 'H' then fmt.base:=16"
    db        10
    db        9
    db        9
    db        "when 'O' then fmt.base:=8"
    db        10
    db        9
    db        9
    db        "when 'X' then"
    db        10
    db        9
    db        9
    db        9
    db        "base:=0"
    db        10
    db        9
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if c in '0'..'9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "base:=base*10+c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "if base in 2..16 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fmt.base:=base"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "when 'Q' then fmt.quotechar:='"
    db        34
    db        "'"
    db        10
    db        9
    db        9
    db        "when 'J' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.justify:=toupper(s^)"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'Z' then fmt.padchar:='0'"
    db        10
    db        9
    db        9
    db        "when 'S' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.sepchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'P' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.padchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'T' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.suffix:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'U' then fmt.usigned:='W'"
    db        10
    db        9
    db        9
    db        "when 'E' then fmt.realfmt:='e'"
    db        10
    db        9
    db        9
    db        "when 'F' then fmt.realfmt:='f'"
    db        10
    db        9
    db        9
    db        "when 'G' then fmt.realfmt:='g'"
    db        10
    db        9
    db        9
    db        "when 'D' then fmt.heapmode:='D'"
    db        10
    db        9
    db        9
    db        "when 'C' then fmt.charmode:='C'"
    db        10
    db        9
    db        9
    db        "when 'M' then fmt.charmode:='M'"
    db        10
    db        9
    db        9
    db        "when 'V' then fmt.param:='V'"
    db        10
    db        9
    db        9
    db        "when 'Y' then fmt.showtype:=1"
    db        10
    db        9
    db        9
    db        "when 'N' then fmt.newline:=1"
    db        10
    db        9
    db        9
    db        "elsecase c"
    db        10
    db        9
    db        9
    db        "when '.' then"
    db        10
    db        9
    db        9
    db        9
    db        "wset:=1"
    db        10
    db        9
    db        9
    db        "when comma,'_' then fmt.sepchar:=c"
    db        10
    db        9
    db        9
    db        "when '+' then fmt.plus:='+'"
    db        10
    db        9
    db        9
    db        "when '~' then fmt.quotechar:='~'"
    db        10
    db        9
    db        9
    db        "when '*' then"
    db        10
    db        9
    db        9
    db        9
    db        "n:=fmtparam"
    db        10
    db        9
    db        9
    db        9
    db        "goto gotwidth"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "if c>='0' and c<='9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "n:=c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if c>='0' and c<='9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "n:=n*10+c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        "gotwidth:"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if not wset then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fmt.minwidth:=n"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "wset:=1"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fmt.precision:=n"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "function domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int ="
    db        10
    db        "!there are n (4 or 8) chars at p.!"
    db        10
    db        "!There could be 0 to 4 or 8 printable chars converted to string at dest"
    db        10
    db        9
    db        "[0:20]char str"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "int nchars"
    db        10
    db        10
    db        9
    db        "q:=&.str"
    db        10
    db        10
    db        9
    db        "nchars:=n"
    db        10
    db        10
    db        9
    db        "to n do"
    db        10
    db        9
    db        9
    db        "if p^=0 then exit fi"
    db        10
    db        9
    db        9
    db        "q^:=p^"
    db        10
    db        9
    db        9
    db        "++q"
    db        10
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "q^:=0"
    db        10
    db        10
    db        9
    db        "return expandstr(&.str,dest,strlen(&.str),fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int ="
    db        9
    db        9
    db        "!EXPANDSTR"
    db        10
    db        "!s contains a partly stringified value."
    db        10
    db        "!widen s if necessary, according to fmt, and copy result to t"
    db        10
    db        "!n is current length of s"
    db        10
    db        "!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving"
    db        10
    db        "!a leading +/- when right-justifying with '0' padding."
    db        10
    db        "!t MUST be big enough for the expanded string; caller must take care of this"
    db        10
    db        "!result will be zero-terminated, for use in this module"
    db        10
    db        10
    db        9
    db        "int i,w,m"
    db        10
    db        10
    db        "!check to see if result is acceptable as it is"
    db        10
    db        9
    db        "w:=fmt.minwidth"
    db        10
    db        9
    db        "if w=0 or w<=n then"
    db        9
    db        9
    db        "! allow str to be longer than minwidth"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "(t+n)^:=0"
    db        10
    db        9
    db        9
    db        "return n"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if fmt.justify='L' then"
    db        9
    db        "! left-justify"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "t+:=n"
    db        10
    db        9
    db        9
    db        "for i:=1 to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "t^:=0"
    db        10
    db        9
    db        "elsif fmt.justify='R' then"
    db        10
    db        9
    db        9
    db        "if fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside "
    db        10
    db        9
    db        9
    db        9
    db        "t^:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "strncpy(t,s+1,n-1)"
    db        10
    db        9
    db        9
    db        9
    db        "(t+n-1)^:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "(t+n)^:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        "! centre-justify?"
    db        10
    db        10
    db        9
    db        9
    db        "m:=(w-n+1)/2"
    db        10
    db        9
    db        9
    db        "to m do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "t+:=n"
    db        10
    db        9
    db        9
    db        "to w-n-m do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "t^:=0"
    db        10
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return w"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function u64tostr(u64 aa,ref char s,word base,int sep)int ="
    db        9
    db        9
    db        "!U64TOSTR"
    db        10
    db        "!convert 64-bit int a to string in s^"
    db        10
    db        "!base is number base, usually 10 but can be 2 or 16. Other bases allowed"
    db        10
    db        "!result when a=minint (will give "
    db        34
    db        "<minint>"
    db        34
    db        ")"
    db        10
    db        9
    db        "[0:onesixty]char t"
    db        10
    db        9
    db        "u64 dd"
    db        10
    db        9
    db        "int i,j,k,g"
    db        10
    db        9
    db        "ref char s0"
    db        10
    db        10
    db        9
    db        "i:=0"
    db        10
    db        9
    db        "k:=0"
    db        10
    db        9
    db        "g:=(base=10|3|4)"
    db        10
    db        10
    db        9
    db        "repeat"
    db        10
    db        "!"
    db        9
    db        9
    db        "if base=10 then"
    db        9
    db        9
    db        9
    db        "!BUGGY FOR AA OVER I64.MAX"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "assem"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rcx, [aa]"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rax, rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rdx, 7378697629483820647"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "imul"
    db        9
    db        "rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rax, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rdx, rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sar"
    db        9
    db        9
    db        "rdx, 63"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sar"
    db        9
    db        9
    db        "rax, 2"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sub"
    db        9
    db        9
    db        "rax, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "lea"
    db        9
    db        9
    db        "rdx, [rax+rax*4]"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "add"
    db        9
    db        9
    db        "rdx, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sub"
    db        9
    db        9
    db        "rcx, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "[dd], rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "[aa], rax"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "end"
    db        10
    db        "!"
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "dd:=aa rem base"
    db        10
    db        9
    db        9
    db        9
    db        "aa:=aa/base"
    db        10
    db        "!"
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "t[++i]:=digits[dd]"
    db        10
    db        10
    db        "!BUG in separator logic, doesn't work when leading zeros used, eg. printing"
    db        10
    db        "!out a full length binary"
    db        10
    db        "!so perhaps move this out to expandstr"
    db        10
    db        9
    db        9
    db        "++k"
    db        10
    db        9
    db        9
    db        "if sep and aa<>0 and k=g then"
    db        10
    db        9
    db        9
    db        9
    db        "t[++i]:=sep"
    db        10
    db        9
    db        9
    db        9
    db        "k:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "until aa=0"
    db        10
    db        10
    db        9
    db        "j:=i"
    db        10
    db        9
    db        "s0:=s"
    db        10
    db        9
    db        "while i do"
    db        10
    db        9
    db        9
    db        "s^:=t[i--]"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "s^:=0"
    db        10
    db        10
    db        9
    db        "return j"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int ="
    db        10
    db        "!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec"
    db        10
    db        "!convert a to a string in s, according to fmt"
    db        10
    db        "!a basic conversion is done first,: the field manipulation is done"
    db        10
    db        "!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)"
    db        10
    db        "!returns length of s"
    db        10
    db        9
    db        "[0:onesixty]char str"
    db        9
    db        9
    db        9
    db        9
    db        "! allow for binary with separators!"
    db        10
    db        9
    db        "int n, usigned"
    db        10
    db        9
    db        "const i64 mindint=0x8000'0000'0000'0000"
    db        10
    db        10
    db        9
    db        "usigned:=0"
    db        10
    db        9
    db        "if fmt.usigned then"
    db        10
    db        9
    db        9
    db        "usigned:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if aa=mindint and not usigned then"
    db        9
    db        9
    db        "! minint"
    db        10
    db        10
    db        9
    db        9
    db        "str[0]:='-'"
    db        10
    db        9
    db        9
    db        "n:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if (not usigned and aa<0) or fmt.plus then"
    db        10
    db        9
    db        9
    db        9
    db        "if aa<0 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "aa:=-aa"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "str[0]:='-'"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "str[0]:='+'"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if fmt.suffix then"
    db        10
    db        9
    db        9
    db        "str[n]:=fmt.suffix"
    db        10
    db        9
    db        9
    db        "str[++n]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!str uses upper cases for hex/etc see if lc needed"
    db        10
    db        9
    db        "if (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'"
    db        9
    db        "then"
    db        9
    db        "! need lower when"
    db        10
    db        9
    db        9
    db        "convlcstring(&.str)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        9
    db        "return expandstr(&.str,s,n,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int ="
    db        9
    db        9
    db        "!U64TOSTRFMT"
    db        10
    db        "!see i64tostrfmt"
    db        10
    db        9
    db        "[0:onesixty]char str"
    db        9
    db        9
    db        9
    db        9
    db        "! allow for binary with separators!"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "n:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)"
    db        10
    db        10
    db        9
    db        "if fmt.suffix then"
    db        10
    db        9
    db        9
    db        "str[n]:=fmt.suffix"
    db        10
    db        9
    db        9
    db        "str[++n]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!str uses upper cases for hex/etc see if lc needed"
    db        10
    db        9
    db        "if fmt.base>10 or fmt.suffix and fmt.lettercase='a'"
    db        9
    db        "then"
    db        9
    db        "! need lower when"
    db        10
    db        "!"
    db        9
    db        9
    db        "convlcstring(&.str)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        9
    db        "return expandstr(&.str,s,n,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function i64mintostr(ref char s,int base,int sep)int ="
    db        9
    db        9
    db        "!I64MINTOSTR"
    db        10
    db        "!convert minint to string in s do not include minus sign"
    db        10
    db        "!return number of chars in string"
    db        10
    db        9
    db        "[0:onesixty]char t"
    db        10
    db        9
    db        "int i,j,k,g"
    db        10
    db        10
    db        9
    db        "case base"
    db        10
    db        9
    db        "when 10 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "9223372036854775808"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=3"
    db        10
    db        9
    db        "when 16 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "8000000000000000"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=1"
    db        10
    db        9
    db        "when 2 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "1000000000000000000000000000000000000000000000000000000000000000"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=7"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "<mindint>"
    db        34
    db        ")"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "i:=strlen(&t[0])"
    db        10
    db        9
    db        "s+:=i"
    db        10
    db        9
    db        "if sep then"
    db        10
    db        9
    db        9
    db        "s+:=j"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "s^:=0"
    db        10
    db        10
    db        9
    db        "k:=0"
    db        10
    db        9
    db        "g:=(base=10|3|4)"
    db        10
    db        10
    db        9
    db        "while i do"
    db        10
    db        9
    db        9
    db        "--s"
    db        10
    db        9
    db        9
    db        "s^:=t[i-- -1]"
    db        10
    db        9
    db        9
    db        "if sep and i and ++k=g then"
    db        10
    db        9
    db        9
    db        9
    db        "--s"
    db        10
    db        9
    db        9
    db        9
    db        "s^:=sep"
    db        10
    db        9
    db        9
    db        9
    db        "k:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return strlen(s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int ="
    db        10
    db        "!s is a string process according to fmtrec fmt^, and return result in t"
    db        10
    db        "!caller should check whether any changes are required to s (now it can just use s), but this"
    db        10
    db        "!check is done here anyway (with a simple copy to t)"
    db        10
    db        "!n is current length of s"
    db        10
    db        "!return length of t"
    db        10
    db        "!Three processing stages:"
    db        10
    db        "!1 Basic input string s"
    db        10
    db        "!2 Additions or mods: quotes, suffix, when conversion"
    db        10
    db        "!3 Width adjustment"
    db        10
    db        "!1 is detected here, 2 is done here, 3 is done by expandstr"
    db        10
    db        9
    db        "ref char u,v"
    db        10
    db        9
    db        "[256]char str"
    db        10
    db        9
    db        "int w,nheap"
    db        9
    db        9
    db        "! whether any heap storage is used  bytes allocated"
    db        10
    db        10
    db        9
    db        "nheap:=0"
    db        10
    db        10
    db        9
    db        "if fmt.quotechar or fmt.lettercase then"
    db        9
    db        9
    db        "! need local copy"
    db        10
    db        9
    db        9
    db        "if n<256 then"
    db        10
    db        9
    db        9
    db        9
    db        "u:=&.str"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "nheap:=n+3"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "! allow for quotes+terminator"
    db        10
    db        9
    db        9
    db        9
    db        "u:=pcm_alloc(nheap)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if fmt.quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        "v:=u"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=fmt.quotechar"
    db        10
    db        9
    db        9
    db        9
    db        "++v"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "strcpy(v,s)"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "v+:=n"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=fmt.quotechar"
    db        10
    db        9
    db        9
    db        9
    db        "++v"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "n+:=2"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(u,s,n)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "case fmt.lettercase"
    db        10
    db        9
    db        9
    db        "when 'a' then"
    db        9
    db        "! need lower when"
    db        10
    db        9
    db        9
    db        9
    db        "convlcstring(u)"
    db        10
    db        9
    db        9
    db        "when 'A' then"
    db        10
    db        9
    db        9
    db        9
    db        "convucstring(u)"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        "s:=u"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "w:=fmt.minwidth"
    db        10
    db        9
    db        "if w>n then"
    db        10
    db        9
    db        9
    db        "n:=expandstr(s,t,n,fmt)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "memcpy(t,s,n)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if nheap then"
    db        10
    db        9
    db        9
    db        "pcm_free(u,nheap)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return n"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_i64(i64 a, ref fmtrec fmt)="
    db        10
    db        9
    db        "[360]char str"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "case fmt.charmode"
    db        10
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        "n:=i64tostrfmt(a,&.str,fmt)"
    db        10
    db        9
    db        "when 'M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a),8,&.str,fmt)"
    db        10
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!assume 'C'"
    db        10
    db        9
    db        9
    db        "m$print_c8(a, nil)"
    db        10
    db        "!"
    db        9
    db        9
    db        "printchar(a)"
    db        9
    db        9
    db        9
    db        "!no other formatting allowed"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_u64(u64 a, ref fmtrec fmt)="
    db        10
    db        9
    db        "[360]char str"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "case fmt.charmode"
    db        10
    db        9
    db        "when 'M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a),8,&.str,fmt)"
    db        10
    db        10
    db        9
    db        "when 'C' then"
    db        10
    db        9
    db        9
    db        "m$print_c8(a, nil)"
    db        10
    db        "!"
    db        9
    db        9
    db        "printchar(a)"
    db        9
    db        9
    db        9
    db        "!no other formatting allowed"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "n:=u64tostrfmt(a,&.str,fmt)"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_r64(real x,ref fmtrec fmt) ="
    db        10
    db        9
    db        "[360]char str,str2"
    db        10
    db        9
    db        "[0:10]char cfmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "cfmt[0]:='%'"
    db        10
    db        10
    db        9
    db        "if fmt.precision then"
    db        10
    db        9
    db        9
    db        "cfmt[1]:='.'"
    db        10
    db        9
    db        9
    db        "cfmt[2]:='*'"
    db        10
    db        9
    db        9
    db        "cfmt[3]:=fmt.realfmt"
    db        10
    db        9
    db        9
    db        "cfmt[4]:=0"
    db        10
    db        9
    db        9
    db        "sprintf(&.str,&.cfmt,fmt.precision,x)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "cfmt[1]:=fmt.realfmt"
    db        10
    db        9
    db        9
    db        "cfmt[2]:=0"
    db        10
    db        9
    db        9
    db        "sprintf(&.str,&.cfmt,x)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        10
    db        9
    db        "n:=strlen(&.str)"
    db        9
    db        9
    db        "! current length"
    db        10
    db        10
    db        9
    db        "if n<fmt.minwidth then"
    db        10
    db        9
    db        9
    db        "n:=expandstr(&.str,&.str2,n,fmt)"
    db        10
    db        9
    db        9
    db        "strcpy(&.str,&.str2)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_str(ref char s, int oldlen, ref fmtrec fmt) ="
    db        10
    db        9
    db        "int newlen,n"
    db        10
    db        9
    db        "ref char t"
    db        10
    db        10
    db        "!try and work out size of formatted string"
    db        10
    db        9
    db        "if oldlen=-1 then"
    db        10
    db        9
    db        9
    db        "oldlen:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "newlen:=oldlen"
    db        10
    db        10
    db        9
    db        "if fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then"
    db        10
    db        9
    db        9
    db        "if fmt.quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        "newlen+:=2"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if fmt.minwidth>newlen then"
    db        10
    db        9
    db        9
    db        9
    db        "newlen:=fmt.minwidth"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "t:=pcm_alloc(newlen+1)"
    db        10
    db        9
    db        9
    db        "n:=strtostrfmt(s,t,oldlen,fmt)"
    db        10
    db        9
    db        9
    db        "if fmt.precision then"
    db        10
    db        9
    db        9
    db        9
    db        "n min:=fmt.precision"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "printstr_n(t,n)"
    db        10
    db        9
    db        9
    db        "pcm_free(t,newlen+1)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "printstr_n(s,oldlen)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "function getfmt(ichar fmtstyle)ref fmtrec="
    db        10
    db        9
    db        "static fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle then"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "return &fmt"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return &defaultfmt"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strint(i64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [100]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_i64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc getstrint(i64 a, ichar dest)="
    db        10
    db        9
    db        "m$print_startstr(dest)"
    db        10
    db        9
    db        "tostr_i64(a,getfmt(nil))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strword(u64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [100]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_u64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strreal(real a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [320]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_r64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function getstr(ichar s, ref fmtrec fmt)ichar="
    db        10
    db        9
    db        "if fmt.heapmode then"
    db        10
    db        9
    db        9
    db        "return pcm_copyheapstring(s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc initreadbuffer="
    db        10
    db        9
    db        "if rd_buffer then return fi"
    db        10
    db        9
    db        "rd_buffer:=pcm_alloc(rd_buffersize)"
    db        10
    db        9
    db        "rd_buffer^:=0"
    db        10
    db        9
    db        "rd_pos:=rd_lastpos:=rd_buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_conline="
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        10
    db        9
    db        "readlinen(nil,rd_buffer,rd_buffersize)"
    db        10
    db        10
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_fileline(filehandle f)="
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        10
    db        9
    db        "if f=filehandle(1) then"
    db        10
    db        "ABORTPROGRAM("
    db        34
    db        "READ CMDLINE"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_buffer^:=0"
    db        10
    db        "!"
    db        9
    db        9
    db        "p:=getcommandlinea()"
    db        10
    db        "!"
    db        9
    db        9
    db        "repeat"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        "!"
    db        9
    db        9
    db        "until p^ in [' ','"
    db        92
    db        "t',0]"
    db        10
    db        "!"
    db        9
    db        9
    db        "strcpy(rd_buffer, p)"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "readlinen(f,rd_buffer,rd_buffersize)"
    db        10
    db        10
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_strline(ichar s)="
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "n:=strlen(s)"
    db        10
    db        10
    db        9
    db        "if n<rd_buffersize then"
    db        10
    db        9
    db        9
    db        "strcpy(rd_buffer,s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "memcpy(rd_buffer,s,rd_buffersize-1)"
    db        10
    db        9
    db        9
    db        "(rd_buffer+rd_buffersize-1)^:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "rd_length:=n"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "function readitem(int &itemlength)ref char ="
    db        10
    db        "!read next item from rd_buffer"
    db        10
    db        "!identify a substring that can contain a name, int, real, string or filename"
    db        10
    db        "!return updated position of s that points past the item and past the immediate"
    db        10
    db        "!terminator "
    db        10
    db        "!information about the read item is returned in itemstr, which points to"
    db        10
    db        "!the start of the item, and in itemlength. Item excludes any surrounding whitespace"
    db        10
    db        "!Item can be quoted, then the item points inside the quotes"
    db        10
    db        "!Any embedded quotes are removed, and the characters moved up. The item will"
    db        10
    db        "!be that reduced subsequence"
    db        10
    db        "!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different."
    db        10
    db        "!I can mitigate this by adding spaces between the end of the item, and the next item,"
    db        10
    db        "!overwriting also the terminator. But this won't restore the line if one of the next"
    db        10
    db        "!reads is literal, using 'L' or 'C' codes."
    db        10
    db        9
    db        "ref char p,s,itemstr"
    db        10
    db        9
    db        "char quotechar, c"
    db        10
    db        10
    db        9
    db        "unless rd_buffer then "
    db        10
    db        9
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "end unless"
    db        10
    db        10
    db        9
    db        "s:=rd_pos"
    db        10
    db        10
    db        "!scan string, eliminating leading white space"
    db        10
    db        9
    db        "while s^=' ' or s^=9 do"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "itemstr:=s"
    db        10
    db        9
    db        "rd_lastpos:=rd_pos:=s"
    db        10
    db        10
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        "termchar:=0"
    db        10
    db        9
    db        9
    db        "itemlength:=0"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "quotechar:=0"
    db        10
    db        9
    db        "if s^='"
    db        34
    db        "' then"
    db        10
    db        9
    db        9
    db        "quotechar:='"
    db        34
    db        "'"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "elsif s^='"
    db        92
    db        "'' then"
    db        10
    db        9
    db        9
    db        "quotechar:='"
    db        92
    db        "''"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!loop reading characters until separator or end reached"
    db        10
    db        9
    db        "p:=itemstr:=s"
    db        10
    db        10
    db        9
    db        "while s^ do"
    db        10
    db        9
    db        9
    db        "c:=s++^"
    db        10
    db        9
    db        9
    db        "case c"
    db        10
    db        9
    db        9
    db        "when ' ', 9, comma, '=' then"
    db        9
    db        9
    db        "! separator"
    db        10
    db        9
    db        9
    db        9
    db        "if quotechar or p=s then"
    db        9
    db        9
    db        9
    db        "!can be considered part of name if inside quotes, or is only char"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "goto normalchar"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "termchar:=c"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        "normalchar:"
    db        10
    db        9
    db        9
    db        9
    db        "if c=quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if s^=quotechar then"
    db        9
    db        "! embedded quote"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "p^:=c"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "! end of name"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "termchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if termchar in [',', '='] then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "termchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "p^:=c"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        "termchar:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "itemlength:=p-itemstr"
    db        9
    db        9
    db        9
    db        9
    db        "! actual length of token"
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        10
    db        9
    db        "return itemstr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strtoint(ichar s,int length=-1, word base=10)i64="
    db        10
    db        "!return point to next char after terminator (which can be just off length of string)"
    db        10
    db        9
    db        "byte signd"
    db        10
    db        9
    db        "u64 aa"
    db        10
    db        9
    db        "word c,d"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        10
    db        9
    db        "if length=-1 then"
    db        10
    db        9
    db        9
    db        "length:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "!check for sign"
    db        10
    db        9
    db        "signd:=0"
    db        10
    db        9
    db        "if length and s^='-' then"
    db        10
    db        9
    db        9
    db        "signd:=1; ++s; --length"
    db        10
    db        9
    db        "elsif length and s^='+' then"
    db        10
    db        9
    db        9
    db        "++s; --length"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "aa:=0"
    db        10
    db        9
    db        "while length do"
    db        10
    db        9
    db        9
    db        "c:=s++^"
    db        10
    db        9
    db        9
    db        "--length"
    db        10
    db        9
    db        9
    db        "if c in 'A'..'F' then d:=c-'A'+10"
    db        10
    db        9
    db        9
    db        "elsif c in 'a'..'f' then d:=c-'a'+10"
    db        10
    db        9
    db        9
    db        "elsif c in '0'..'9' then d:=c-'0'"
    db        10
    db        9
    db        9
    db        "elsif c in ['_', '"
    db        92
    db        "''] then"
    db        10
    db        9
    db        9
    db        9
    db        "nextloop"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "if d>=base then"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "aa:=aa*base+d"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "if signd then"
    db        10
    db        9
    db        9
    db        "return -aa"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return aa"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$read_i64(int fmt=0)i64="
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        10
    db        9
    db        "fmt:=toupper(fmt)"
    db        10
    db        10
    db        9
    db        "case fmt"
    db        10
    db        9
    db        "when 'C' then"
    db        10
    db        9
    db        9
    db        "rd_lastpos:=rd_pos"
    db        10
    db        9
    db        9
    db        "if rd_pos^ then"
    db        10
    db        9
    db        9
    db        9
    db        "return rd_pos++^"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "when 'T' then"
    db        10
    db        9
    db        9
    db        "return termchar"
    db        10
    db        9
    db        "when 'E' then"
    db        10
    db        9
    db        9
    db        "return itemerror"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        "case fmt"
    db        10
    db        9
    db        "when 0,'I' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length)"
    db        10
    db        9
    db        "when 'B' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length,2)"
    db        10
    db        9
    db        "when 'H' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length,16)"
    db        10
    db        9
    db        "esac"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$read_r64(int fmt=0)real="
    db        10
    db        9
    db        "[512]char str"
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        9
    db        "i32 numlength"
    db        10
    db        9
    db        "real x"
    db        10
    db        10
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        "if length=0 or length>=str.len then"
    db        9
    db        9
    db        "!assume not a real"
    db        10
    db        9
    db        9
    db        "return 0.0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(&.str,s,length)"
    db        10
    db        9
    db        "str[length+1]:=0"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        10
    db        9
    db        "if sscanf(&.str,"
    db        34
    db        "%lf%n"
    db        34
    db        ", &x, &numlength)=0 or numlength<>length then"
    db        10
    db        9
    db        9
    db        "x:=0.0"
    db        10
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_str(ref char dest, int destlen=0,fmt=0)="
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        9
    db        "if fmt in ['L','l'] then"
    db        10
    db        9
    db        9
    db        "s:=rd_pos"
    db        10
    db        9
    db        9
    db        "length:=rd_buffer+rd_length-rd_pos"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        9
    db        "if fmt in ['N','n'] then"
    db        10
    db        9
    db        9
    db        9
    db        "iconvlcn(s,length)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if destlen>0 then"
    db        10
    db        9
    db        9
    db        "if length>=destlen then"
    db        10
    db        9
    db        9
    db        9
    db        "length:=destlen-1"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(dest,s,length)"
    db        10
    db        9
    db        "(dest+length)^:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc readstr(ref char dest, int fmt=0,destlen=0)="
    db        10
    db        9
    db        "m$read_str(dest,destlen,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc rereadln="
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=rd_pos"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc reread="
    db        10
    db        9
    db        "rd_pos:=rd_lastpos"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function valint(ichar s, int fmt=0)i64="
    db        10
    db        9
    db        "ref char old_pos, old_lastpos"
    db        10
    db        9
    db        "i64 aa"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "old_pos:=rd_pos"
    db        10
    db        9
    db        "old_lastpos:=rd_lastpos"
    db        10
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        9
    db        "aa:=m$read_i64(fmt)"
    db        10
    db        9
    db        "rd_pos:=old_pos"
    db        10
    db        9
    db        "rd_lastpos:=old_lastpos"
    db        10
    db        9
    db        "return aa"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function valreal(ichar s)real="
    db        10
    db        9
    db        "ref char old_pos, old_lastpos"
    db        10
    db        9
    db        "real x"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "old_pos:=rd_pos"
    db        10
    db        9
    db        "old_lastpos:=rd_lastpos"
    db        10
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        9
    db        "x:=m$read_r64()"
    db        10
    db        9
    db        "rd_pos:=old_pos"
    db        10
    db        9
    db        "rd_lastpos:=old_lastpos"
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc mclunimpl(ichar mess)="
    db        10
    db        9
    db        "printf("
    db        34
    db        "MCL-UNIMPL: %s"
    db        92
    db        "n"
    db        34
    db        ",mess)"
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc dumpstr(ichar s, int n, fbuffer=0)="
    db        10
    db        "!fbuffer=1 when outputting contents of buffer"
    db        10
    db        10
    db        9
    db        "ref ref char p"
    db        10
    db        10
    db        9
    db        "if outdev=str_io then"
    db        10
    db        9
    db        9
    db        "p:=cast(outchan)"
    db        10
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(p^,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "p^+:=n"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "p^^:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return when n=0"
    db        10
    db        9
    db        "if fbuffer and n>=2 and outdev=std_io then"
    db        10
    db        9
    db        9
    db        "--printptr"
    db        9
    db        9
    db        9
    db        9
    db        "!point to last char"
    db        10
    db        9
    db        9
    db        "if printptr^=10 then"
    db        10
    db        9
    db        9
    db        9
    db        "if (printptr-1)^=13 then"
    db        9
    db        9
    db        "!crlf"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "(printptr-1)^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!lf only"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printptr^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "puts(printbuffer)"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "case outdev"
    db        10
    db        9
    db        "when std_io then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "%.*s"
    db        34
    db        ",n,s)"
    db        10
    db        9
    db        "when file_io then"
    db        10
    db        9
    db        9
    db        "fprintf(outchan,"
    db        34
    db        "%.*s"
    db        34
    db        ",n,s)"
    db        10
    db        9
    db        "esac"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc dumpprintbuffer="
    db        10
    db        9
    db        "if printlen then"
    db        10
    db        9
    db        9
    db        "dumpstr(&.printbuffer,printlen,1)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc resetprintbuffer="
    db        10
    db        9
    db        "printptr:=&.printbuffer"
    db        10
    db        9
    db        "printlen:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc addtobuffer(ichar s, int n)="
    db        10
    db        9
    db        "if printlen+n>=(printbuffer.len-8) then"
    db        10
    db        9
    db        9
    db        "dumpprintbuffer()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if n<printbuffer.len then"
    db        10
    db        9
    db        9
    db        "memcpy(printptr,s,n)"
    db        10
    db        9
    db        9
    db        "printptr+:=n"
    db        10
    db        9
    db        9
    db        "printlen+:=n"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "dumpstr(s, n)"
    db        9
    db        9
    db        9
    db        "!don't bother with buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$power_i64(i64 a,n)i64="
    db        10
    db        9
    db        "if n<0 then"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "elsif n=0 then"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "elsif n=1 then"
    db        10
    db        9
    db        9
    db        "return a"
    db        10
    db        9
    db        "elsif (n iand 1)=0 then"
    db        10
    db        9
    db        9
    db        "return m$power_i64(sqr a,n/2)"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        "!assume odd"
    db        10
    db        9
    db        9
    db        "return m$power_i64(sqr a,(n-1)/2)*a"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "func getutfsize(ref char s)int ="
    db        10
    db        "!work out the size in bytes of the ascii or utf8 character that s points to"
    db        10
    db        9
    db        "int a"
    db        10
    db        10
    db        9
    db        "a:=s++^"
    db        10
    db        10
    db        9
    db        "if a=0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!end of string"
    db        10
    db        9
    db        9
    db        "0"
    db        10
    db        9
    db        "elsif a.[7]=0 then"
    db        9
    db        9
    db        9
    db        9
    db        "!ascii"
    db        10
    db        9
    db        9
    db        "1"
    db        10
    db        9
    db        "elsif a.[7..5]=2x110 then"
    db        10
    db        9
    db        9
    db        "2"
    db        10
    db        9
    db        "elsif a.[7..4]=2x1110 then"
    db        10
    db        9
    db        9
    db        "3"
    db        10
    db        9
    db        "elsif a.[7..3]=2x11110 then"
    db        10
    db        9
    db        9
    db        "4"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!error: just assume a byte of random binary"
    db        10
    db        9
    db        9
    db        "1"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "!export fun `fract(real x)real = fmod(x,1.0)"
    db        10
    db        "!export fun fraction(real x)real = fmod(x,1.0)"
    db        10
    db        10
    db        "export fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))"
    db        10
    db        "export func m$sign_r64(real x)real ="
    db        10
    db        9
    db        "if x<0 then return -1 fi"
    db        10
    db        9
    db        "if x>0 then return 1 fi"
    db        10
    db        9
    db        "0"
    db        10
    db        "end"
    db        10
    db        0
L11477:
    db        "module msysc"
    db        10
    db        "module mlib"
    db        10
    db        "module mclib"
    db        10
    db        "module mlinux"
    db        10
    db        "module mwindllc"
    db        10
    db        0
L11476:
    db        "module msys"
    db        10
    db        "module mlib"
    db        10
    db        "module mclib"
    db        10
    db        "module mwindows"
    db        10
    db        "module mwindllc"
    db        10
    db        0
L11475:
    db        "module msysc"
    db        10
    db        "module mlib"
    db        10
    db        "module mclib"
    db        10
    db        "module mwindows"
    db        10
    db        "module mwindllc"
    db        10
    db        0
L11474:
    db        "module msys"
    db        10
    db        "module mlib"
    db        10
    db        "module mclib"
    db        10
    db        "module mwindows"
    db        10
    db        "module mwindll"
    db        10
    db        10
    db        "!proc start="
    db        10
    db        "!"
    db        9
    db        "CPL "
    db        34
    db        "MSYSWIN/START"
    db        34
    db        10
    db        "!END"
    db        10
    db        0
L11473:
    db        "mwindllc.m"
    db        0
L11472:
    db        "mwindll.m"
    db        0
L11471:
    db        "mlinux.m"
    db        0
L11470:
    db        "mwindows.m"
    db        0
L11469:
    db        "mclib.m"
    db        0
L11468:
    db        "mlib.m"
    db        0
L11467:
    db        "msysmin.m"
    db        0
L11466:
    db        "msysc.m"
    db        0
L11465:
    db        "msys.m"
    db        0
L11464:
    db        "msyslinc.m"
    db        0
L11463:
    db        "msyswini.m"
    db        0
L11462:
    db        "msyswinc.m"
    db        0
L11461:
    db        "msyswin.m"
    db        0
L11460:
    db        "18446744073709551615"
    db        0
L11459:
    db        "    "
    db        0
L11458:
    db        9
    db        0
L11457:
    db        "dsptr"
    db        0
L11456:
    db        "dprog"
    db        0
L11455:
    db        "dstack"
    db        0
L11454:
    db        "astack"
    db        0
L11453:
    db        "dframe"
    db        0
L11452:
    db        "aframe"
    db        0
L11451:
    db        0
L11450:
    db        "himem"
    db        0
L11449:
    db        "norip"
    db        0
L11448:
    db        "unused"
    db        0
L11447:
    db        "outpath"
    db        0
L11446:
    db        "o"
    db        0
L11445:
    db        "ext"
    db        0
L11444:
    db        "help"
    db        0
L11443:
    db        "h"
    db        0
L11442:
    db        "ss"
    db        0
L11441:
    db        "cs"
    db        0
L11440:
    db        "q"
    db        0
L11439:
    db        "vv"
    db        0
L11438:
    db        "v"
    db        0
L11437:
    db        "time"
    db        0
L11436:
    db        "pst"
    db        0
L11435:
    db        "shortnames"
    db        0
L11434:
    db        "modules"
    db        0
L11433:
    db        "showss"
    db        0
L11432:
    db        "types"
    db        0
L11431:
    db        "stflat"
    db        0
L11430:
    db        "st"
    db        0
L11429:
    db        "showasm"
    db        0
L11428:
    db        "showpcl"
    db        0
L11427:
    db        "showc"
    db        0
L11426:
    db        "ast3"
    db        0
L11425:
    db        "ast2"
    db        0
L11424:
    db        "ast1"
    db        0
L11423:
    db        "noregs"
    db        0
L11422:
    db        "nopeep"
    db        0
L11421:
    db        "no"
    db        0
L11420:
    db        "linux"
    db        0
L11419:
    db        "nosys"
    db        0
L11418:
    db        "min"
    db        0
L11417:
    db        "sys"
    db        0
L11416:
    db        "dss"
    db        0
L11415:
    db        "dmcl"
    db        0
L11414:
    db        "dpcl"
    db        0
L11413:
    db        "dtype"
    db        0
L11412:
    db        "dname"
    db        0
L11411:
    db        "dfixup"
    db        0
L11410:
    db        "dparse"
    db        0
L11409:
    db        "dload"
    db        0
L11408:
    db        "r"
    db        0
L11407:
    db        "mx"
    db        0
L11406:
    db        "exe"
    db        0
L11405:
    db        "d"
    db        0
L11404:
    db        "dll"
    db        0
L11403:
    db        "obj"
    db        0
L11402:
    db        "nasm"
    db        0
L11401:
    db        "a"
    db        0
L11400:
    db        "i"
    db        0
L11399:
    db        "p"
    db        0
L11398:
    db        "getproj"
    db        0
L11397:
    db        "getst"
    db        0
L11396:
    db        "ma"
    db        0
L11395:
    db        "dss_pass"
    db        0
L11394:
    db        "dmcl_pass"
    db        0
L11393:
    db        "dpcl_pass"
    db        0
L11392:
    db        "dtype_pass"
    db        0
L11391:
    db        "dname_pass"
    db        0
L11390:
    db        "dfixup_pass"
    db        0
L11389:
    db        "dparse_pass"
    db        0
L11388:
    db        "dload_pass"
    db        0
L11387:
    db        "(run)"
    db        0
L11386:
    db        "mx"
    db        0
L11385:
    db        "exe"
    db        0
L11384:
    db        "dll"
    db        0
L11383:
    db        "obj"
    db        0
L11382:
    db        "asm"
    db        0
L11381:
    db        "(int)"
    db        0
L11380:
    db        "pcl"
    db        0
L11379:
    db        "proj"
    db        0
L11378:
    db        "list"
    db        0
L11377:
    db        "ma"
    db        0
L11376:
    db        0
L11375:
    db        "impdata_rseg"
    db        0
L11374:
    db        "rodata_rseg"
    db        0
L11373:
    db        "zdata_rseg"
    db        0
L11372:
    db        "idata_rseg"
    db        0
L11371:
    db        "code_rseg"
    db        0
L11370:
    db        "no_seg"
    db        0
L11369:
    db        "imprel32"
    db        0
L11368:
    db        "impabs64"
    db        0
L11367:
    db        "impabs32"
    db        0
L11366:
    db        "locabs64"
    db        0
L11365:
    db        "locabs32"
    db        0
L11364:
    db        "no_rel"
    db        0
L11363:
    db        "end_dir"
    db        0
L11362:
    db        "entry_dir"
    db        0
L11361:
    db        "exportoffsets_dir"
    db        0
L11360:
    db        "exportsegs_dir"
    db        0
L11359:
    db        "exportsymbols_dir"
    db        0
L11358:
    db        "importsymbols_dir"
    db        0
L11357:
    db        "libs_dir"
    db        0
L11356:
    db        "dlls_dir"
    db        0
L11355:
    db        "reloc_dir"
    db        0
L11354:
    db        "zdata_dir"
    db        0
L11353:
    db        "idata_dir"
    db        0
L11352:
    db        "code_dir"
    db        0
L11351:
    db        "version_dir"
    db        0
L11350:
    db        "pad_dir"
    db        0
L11349:
    db        "rel8_rel"
    db        0
L11348:
    db        "rel321_rel"
    db        0
L11347:
    db        "rel32_rel"
    db        0
L11346:
    db        "addr32nb_rel"
    db        0
L11345:
    db        "addr32_rel"
    db        0
L11344:
    db        "addr64_rel"
    db        0
L11343:
    db        "abs_rel"
    db        0
L11342:
    db        "xmm15"
    db        0
L11341:
    db        "xmm13"
    db        0
L11340:
    db        "xmm12"
    db        0
L11339:
    db        "xmm11"
    db        0
L11338:
    db        "xmm10"
    db        0
L11337:
    db        "xmm9"
    db        0
L11336:
    db        "xmm8"
    db        0
L11335:
    db        "xmm7"
    db        0
L11334:
    db        "xmm6"
    db        0
L11333:
    db        "xmm5"
    db        0
L11332:
    db        "xmm4"
    db        0
L11331:
    db        "xmm3"
    db        0
L11330:
    db        "xmm2"
    db        0
L11329:
    db        "xmm1"
    db        0
L11328:
    db        "xmm0"
    db        0
L11327:
    db        "-"
    db        0
L11326:
    db        "temp"
    db        0
L11325:
    db        "regvar"
    db        0
L11324:
    db        "reg"
    db        0
L11323:
    db        "pend"
    db        0
L11322:
    db        "a_xreg"
    db        0
L11321:
    db        "a_cond"
    db        0
L11320:
    db        "a_mem"
    db        0
L11319:
    db        "a_imm"
    db        0
L11318:
    db        "a_reg"
    db        0
L11317:
    db        "a_none"
    db        0
L11316:
    db        "back_ref"
    db        0
L11315:
    db        "fwd_ref"
    db        0
L11314:
    db        "extern_ref"
    db        0
L11313:
    db        "impdata_seg"
    db        0
L11312:
    db        "rodata_seg"
    db        0
L11311:
    db        "zdata_seg"
    db        0
L11310:
    db        "idata_seg"
    db        0
L11309:
    db        "code_seg"
    db        0
L11308:
    db        "no_seg"
    db        0
L11307:
    db        "cmovg"
    db        0
L11306:
    db        "cmovle"
    db        0
L11305:
    db        "cmovge"
    db        0
L11304:
    db        "cmovl"
    db        0
L11303:
    db        "cmovnp"
    db        0
L11302:
    db        "cmovp"
    db        0
L11301:
    db        "cmovns"
    db        0
L11300:
    db        "cmovs"
    db        0
L11299:
    db        "cmova"
    db        0
L11298:
    db        "cmovbe"
    db        0
L11297:
    db        "cmovnz"
    db        0
L11296:
    db        "cmovz"
    db        0
L11295:
    db        "cmovae"
    db        0
L11294:
    db        "cmovb"
    db        0
L11293:
    db        "cmovno"
    db        0
L11292:
    db        "cmovo"
    db        0
L11291:
    db        "setg"
    db        0
L11290:
    db        "setle"
    db        0
L11289:
    db        "setge"
    db        0
L11288:
    db        "setl"
    db        0
L11287:
    db        "setnp"
    db        0
L11286:
    db        "setp"
    db        0
L11285:
    db        "setns"
    db        0
L11284:
    db        "sets"
    db        0
L11283:
    db        "seta"
    db        0
L11282:
    db        "setbe"
    db        0
L11281:
    db        "setnz"
    db        0
L11280:
    db        "setz"
    db        0
L11279:
    db        "setae"
    db        0
L11278:
    db        "setb"
    db        0
L11277:
    db        "setno"
    db        0
L11276:
    db        "seto"
    db        0
L11275:
    db        "jnc"
    db        0
L11274:
    db        "jc"
    db        0
L11273:
    db        "jg"
    db        0
L11272:
    db        "jle"
    db        0
L11271:
    db        "jge"
    db        0
L11270:
    db        "jl"
    db        0
L11269:
    db        "jnp"
    db        0
L11268:
    db        "jp"
    db        0
L11267:
    db        "jns"
    db        0
L11266:
    db        "js"
    db        0
L11265:
    db        "ja"
    db        0
L11264:
    db        "jbe"
    db        0
L11263:
    db        "jnz"
    db        0
L11262:
    db        "jz"
    db        0
L11261:
    db        "jae"
    db        0
L11260:
    db        "jb"
    db        0
L11259:
    db        "jno"
    db        0
L11258:
    db        "jo"
    db        0
L11257:
    db        "mmx7"
    db        0
L11256:
    db        "mmx6"
    db        0
L11255:
    db        "mmx5"
    db        0
L11254:
    db        "mmx4"
    db        0
L11253:
    db        "mmx3"
    db        0
L11252:
    db        "mmx2"
    db        0
L11251:
    db        "mmx1"
    db        0
L11250:
    db        "mmx0"
    db        0
L11249:
    db        "st7"
    db        0
L11248:
    db        "st6"
    db        0
L11247:
    db        "st5"
    db        0
L11246:
    db        "st4"
    db        0
L11245:
    db        "st3"
    db        0
L11244:
    db        "st2"
    db        0
L11243:
    db        "st1"
    db        0
L11242:
    db        "st0"
    db        0
L11241:
    db        "xmm15"
    db        0
L11240:
    db        "xmm14"
    db        0
L11239:
    db        "xmm13"
    db        0
L11238:
    db        "xmm12"
    db        0
L11237:
    db        "xmm11"
    db        0
L11236:
    db        "xmm10"
    db        0
L11235:
    db        "xmm9"
    db        0
L11234:
    db        "xmm8"
    db        0
L11233:
    db        "xmm7"
    db        0
L11232:
    db        "xmm6"
    db        0
L11231:
    db        "xmm5"
    db        0
L11230:
    db        "xmm4"
    db        0
L11229:
    db        "xmm3"
    db        0
L11228:
    db        "xmm2"
    db        0
L11227:
    db        "xmm1"
    db        0
L11226:
    db        "xmm0"
    db        0
L11225:
    db        "r15b"
    db        0
L11224:
    db        "r14b"
    db        0
L11223:
    db        "r13b"
    db        0
L11222:
    db        "r12b"
    db        0
L11221:
    db        "r11b"
    db        0
L11220:
    db        "r10b"
    db        0
L11219:
    db        "r9b"
    db        0
L11218:
    db        "r8b"
    db        0
L11217:
    db        "spl"
    db        0
L11216:
    db        "bpl"
    db        0
L11215:
    db        "dil"
    db        0
L11214:
    db        "sil"
    db        0
L11213:
    db        "dh"
    db        0
L11212:
    db        "ch"
    db        0
L11211:
    db        "bh"
    db        0
L11210:
    db        "ah"
    db        0
L11209:
    db        "dl"
    db        0
L11208:
    db        "cl"
    db        0
L11207:
    db        "bl"
    db        0
L11206:
    db        "al"
    db        0
L11205:
    db        "r15w"
    db        0
L11204:
    db        "r14w"
    db        0
L11203:
    db        "r13w"
    db        0
L11202:
    db        "r12w"
    db        0
L11201:
    db        "r11w"
    db        0
L11200:
    db        "r10w"
    db        0
L11199:
    db        "r9w"
    db        0
L11198:
    db        "r8w"
    db        0
L11197:
    db        "sp"
    db        0
L11196:
    db        "bp"
    db        0
L11195:
    db        "di"
    db        0
L11194:
    db        "si"
    db        0
L11193:
    db        "dx"
    db        0
L11192:
    db        "cx"
    db        0
L11191:
    db        "bx"
    db        0
L11190:
    db        "ax"
    db        0
L11189:
    db        "r15d"
    db        0
L11188:
    db        "r14d"
    db        0
L11187:
    db        "r13d"
    db        0
L11186:
    db        "r12d"
    db        0
L11185:
    db        "r11d"
    db        0
L11184:
    db        "r10d"
    db        0
L11183:
    db        "r9d"
    db        0
L11182:
    db        "r8d"
    db        0
L11181:
    db        "esp"
    db        0
L11180:
    db        "ebp"
    db        0
L11179:
    db        "edi"
    db        0
L11178:
    db        "esi"
    db        0
L11177:
    db        "edx"
    db        0
L11176:
    db        "ecx"
    db        0
L11175:
    db        "ebx"
    db        0
L11174:
    db        "eax"
    db        0
L11173:
    db        "r15"
    db        0
L11172:
    db        "r14"
    db        0
L11171:
    db        "r13"
    db        0
L11170:
    db        "r12"
    db        0
L11169:
    db        "r11"
    db        0
L11168:
    db        "r10"
    db        0
L11167:
    db        "r9"
    db        0
L11166:
    db        "r8"
    db        0
L11165:
    db        "rsp"
    db        0
L11164:
    db        "rbp"
    db        0
L11163:
    db        "rdi"
    db        0
L11162:
    db        "rsi"
    db        0
L11161:
    db        "rdx"
    db        0
L11160:
    db        "rcx"
    db        0
L11159:
    db        "rbx"
    db        0
L11158:
    db        "rax"
    db        0
L11157:
    db        "_b20"
    db        0
L11156:
    db        "b19"
    db        0
L11155:
    db        "b18"
    db        0
L11154:
    db        "b17"
    db        0
L11153:
    db        "b16"
    db        0
L11152:
    db        "b15"
    db        0
L11151:
    db        "b14"
    db        0
L11150:
    db        "b13"
    db        0
L11149:
    db        "b12"
    db        0
L11148:
    db        "b11"
    db        0
L11147:
    db        "b10"
    db        0
L11146:
    db        "b9"
    db        0
L11145:
    db        "b8"
    db        0
L11144:
    db        "b7"
    db        0
L11143:
    db        "b6"
    db        0
L11142:
    db        "b5"
    db        0
L11141:
    db        "b4"
    db        0
L11140:
    db        "b3"
    db        0
L11139:
    db        "b2"
    db        0
L11138:
    db        "b1"
    db        0
L11137:
    db        "b0"
    db        0
L11136:
    db        "w15"
    db        0
L11135:
    db        "w14"
    db        0
L11134:
    db        "w13"
    db        0
L11133:
    db        "w12"
    db        0
L11132:
    db        "w11"
    db        0
L11131:
    db        "w10"
    db        0
L11130:
    db        "w9"
    db        0
L11129:
    db        "w8"
    db        0
L11128:
    db        "w7"
    db        0
L11127:
    db        "w6"
    db        0
L11126:
    db        "w5"
    db        0
L11125:
    db        "w4"
    db        0
L11124:
    db        "w3"
    db        0
L11123:
    db        "w2"
    db        0
L11122:
    db        "w1"
    db        0
L11121:
    db        "w0"
    db        0
L11120:
    db        "a15"
    db        0
L11119:
    db        "a14"
    db        0
L11118:
    db        "a13"
    db        0
L11117:
    db        "a12"
    db        0
L11116:
    db        "a11"
    db        0
L11115:
    db        "a10"
    db        0
L11114:
    db        "a9"
    db        0
L11113:
    db        "a8"
    db        0
L11112:
    db        "a7"
    db        0
L11111:
    db        "a6"
    db        0
L11110:
    db        "a5"
    db        0
L11109:
    db        "a4"
    db        0
L11108:
    db        "a3"
    db        0
L11107:
    db        "a2"
    db        0
L11106:
    db        "a1"
    db        0
L11105:
    db        "a0"
    db        0
L11104:
    db        "d15"
    db        0
L11103:
    db        "d14"
    db        0
L11102:
    db        "d13"
    db        0
L11101:
    db        "d12"
    db        0
L11100:
    db        "d11"
    db        0
L11099:
    db        "d10"
    db        0
L11098:
    db        "d9"
    db        0
L11097:
    db        "d8"
    db        0
L11096:
    db        "d7"
    db        0
L11095:
    db        "d6"
    db        0
L11094:
    db        "d5"
    db        0
L11093:
    db        "d4"
    db        0
L11092:
    db        "d3"
    db        0
L11091:
    db        "d2"
    db        0
L11090:
    db        "d1"
    db        0
L11089:
    db        "d0"
    db        0
L11088:
    db        "a"
    db        0
L11087:
    db        "be"
    db        0
L11086:
    db        "ae"
    db        0
L11085:
    db        "b"
    db        0
L11084:
    db        "g"
    db        0
L11083:
    db        "le"
    db        0
L11082:
    db        "ge"
    db        0
L11081:
    db        "l"
    db        0
L11080:
    db        "np"
    db        0
L11079:
    db        "p"
    db        0
L11078:
    db        "ns"
    db        0
L11077:
    db        "s"
    db        0
L11076:
    db        "a"
    db        0
L11075:
    db        "be"
    db        0
L11074:
    db        "nz"
    db        0
L11073:
    db        "z"
    db        0
L11072:
    db        "ae"
    db        0
L11071:
    db        "b"
    db        0
L11070:
    db        "no"
    db        0
L11069:
    db        "o"
    db        0
L11068:
    db        "fgt"
    db        0
L11067:
    db        "fle"
    db        0
L11066:
    db        "fge"
    db        0
L11065:
    db        "flt"
    db        0
L11064:
    db        "gt"
    db        0
L11063:
    db        "le"
    db        0
L11062:
    db        "ge"
    db        0
L11061:
    db        "lt"
    db        0
L11060:
    db        "np"
    db        0
L11059:
    db        "p"
    db        0
L11058:
    db        "ns"
    db        0
L11057:
    db        "s"
    db        0
L11056:
    db        "gtu"
    db        0
L11055:
    db        "leu"
    db        0
L11054:
    db        "ne"
    db        0
L11053:
    db        "eq"
    db        0
L11052:
    db        "geu"
    db        0
L11051:
    db        "ltu"
    db        0
L11050:
    db        "nov"
    db        0
L11049:
    db        "ov"
    db        0
L11048:
    db        "r19"
    db        0
L11047:
    db        "r18"
    db        0
L11046:
    db        "r17"
    db        0
L11045:
    db        "r16"
    db        0
L11044:
    db        "r15"
    db        0
L11043:
    db        "r14"
    db        0
L11042:
    db        "r13"
    db        0
L11041:
    db        "r12"
    db        0
L11040:
    db        "r11"
    db        0
L11039:
    db        "r10"
    db        0
L11038:
    db        "r9"
    db        0
L11037:
    db        "r8"
    db        0
L11036:
    db        "r7"
    db        0
L11035:
    db        "r6"
    db        0
L11034:
    db        "r5"
    db        0
L11033:
    db        "r4"
    db        0
L11032:
    db        "r3"
    db        0
L11031:
    db        "r2"
    db        0
L11030:
    db        "r1"
    db        0
L11029:
    db        "r0"
    db        0
L11028:
    db        "rnone"
    db        0
L11027:
    db        "m_halt"
    db        0
L11026:
    db        "m_xxxx"
    db        0
L11025:
    db        "m_cpuid"
    db        0
L11024:
    db        "m_fldln2"
    db        0
L11023:
    db        "m_fldlg2"
    db        0
L11022:
    db        "m_fld2e"
    db        0
L11021:
    db        "m_fld2t"
    db        0
L11020:
    db        "m_fldpi"
    db        0
L11019:
    db        "m_fld1"
    db        0
L11018:
    db        "m_fldz"
    db        0
L11017:
    db        "m_finit"
    db        0
L11016:
    db        "m_bswap"
    db        0
L11015:
    db        "m_popcnt"
    db        0
L11014:
    db        "m_rdtsc"
    db        0
L11013:
    db        "m_cmpsq"
    db        0
L11012:
    db        "m_cmpsd"
    db        0
L11011:
    db        "m_cmpsw"
    db        0
L11010:
    db        "m_cmpsb"
    db        0
L11009:
    db        "m_jrcxz"
    db        0
L11008:
    db        "m_jecxz"
    db        0
L11007:
    db        "m_loopcx"
    db        0
L11006:
    db        "m_loopz"
    db        0
L11005:
    db        "m_loopnz"
    db        0
L11004:
    db        "m_xlat"
    db        0
L11003:
    db        "m_resq"
    db        0
L11002:
    db        "m_resd"
    db        0
L11001:
    db        "m_resw"
    db        0
L11000:
    db        "m_resb"
    db        0
L10999:
    db        "m_align"
    db        0
L10998:
    db        "m_csegment"
    db        0
L10997:
    db        "m_zsegment"
    db        0
L10996:
    db        "m_isegment"
    db        0
L10995:
    db        "m_dq"
    db        0
L10994:
    db        "m_dd"
    db        0
L10993:
    db        "m_dw"
    db        0
L10992:
    db        "m_db"
    db        0
L10991:
    db        "m_maxsd"
    db        0
L10990:
    db        "m_minsd"
    db        0
L10989:
    db        "m_maxss"
    db        0
L10988:
    db        "m_minss"
    db        0
L10987:
    db        "m_fchs"
    db        0
L10986:
    db        "m_fabs"
    db        0
L10985:
    db        "m_fpatan"
    db        0
L10984:
    db        "m_fptan"
    db        0
L10983:
    db        "m_fsincos"
    db        0
L10982:
    db        "m_fcos"
    db        0
L10981:
    db        "m_fsin"
    db        0
L10980:
    db        "m_fsqrt"
    db        0
L10979:
    db        "m_fdiv"
    db        0
L10978:
    db        "m_fmul"
    db        0
L10977:
    db        "m_fsub"
    db        0
L10976:
    db        "m_fadd"
    db        0
L10975:
    db        "m_fistp"
    db        0
L10974:
    db        "m_fist"
    db        0
L10973:
    db        "m_fild"
    db        0
L10972:
    db        "m_fstp"
    db        0
L10971:
    db        "m_fst"
    db        0
L10970:
    db        "m_fld"
    db        0
L10969:
    db        "m_pcmpistrm"
    db        0
L10968:
    db        "m_pcmpistri"
    db        0
L10967:
    db        "m_movdqu"
    db        0
L10966:
    db        "m_movdqa"
    db        0
L10965:
    db        "m_cvtss2sd"
    db        0
L10964:
    db        "m_cvtsd2ss"
    db        0
L10963:
    db        "m_cvtsi2sd"
    db        0
L10962:
    db        "m_cvtsi2ss"
    db        0
L10961:
    db        "m_cvttsd2si"
    db        0
L10960:
    db        "m_cvttss2si"
    db        0
L10959:
    db        "m_cvtsd2si"
    db        0
L10958:
    db        "m_cvtss2si"
    db        0
L10957:
    db        "m_pand"
    db        0
L10956:
    db        "m_pxor"
    db        0
L10955:
    db        "m_andpd"
    db        0
L10954:
    db        "m_andps"
    db        0
L10953:
    db        "m_xorpd"
    db        0
L10952:
    db        "m_xorps"
    db        0
L10951:
    db        "m_ucomisd"
    db        0
L10950:
    db        "m_comisd"
    db        0
L10949:
    db        "m_comiss"
    db        0
L10948:
    db        "m_divsd"
    db        0
L10947:
    db        "m_divss"
    db        0
L10946:
    db        "m_mulsd"
    db        0
L10945:
    db        "m_mulss"
    db        0
L10944:
    db        "m_subsd"
    db        0
L10943:
    db        "m_subss"
    db        0
L10942:
    db        "m_addsd"
    db        0
L10941:
    db        "m_addss"
    db        0
L10940:
    db        "m_sqrtsd"
    db        0
L10939:
    db        "m_sqrtss"
    db        0
L10938:
    db        "m_shrd"
    db        0
L10937:
    db        "m_shld"
    db        0
L10936:
    db        "m_bsr"
    db        0
L10935:
    db        "m_bsf"
    db        0
L10934:
    db        "m_setcc"
    db        0
L10933:
    db        "m_cqo"
    db        0
L10932:
    db        "m_cdq"
    db        0
L10931:
    db        "m_cwd"
    db        0
L10930:
    db        "m_cbw"
    db        0
L10929:
    db        "m_dec"
    db        0
L10928:
    db        "m_inc"
    db        0
L10927:
    db        "m_notx"
    db        0
L10926:
    db        "m_neg"
    db        0
L10925:
    db        "m_rcr"
    db        0
L10924:
    db        "m_rcl"
    db        0
L10923:
    db        "m_ror"
    db        0
L10922:
    db        "m_rol"
    db        0
L10921:
    db        "m_shr"
    db        0
L10920:
    db        "m_sar"
    db        0
L10919:
    db        "m_shl"
    db        0
L10918:
    db        "m_cmp"
    db        0
L10917:
    db        "m_test"
    db        0
L10916:
    db        "m_xorx"
    db        0
L10915:
    db        "m_orx"
    db        0
L10914:
    db        "m_andx"
    db        0
L10913:
    db        "m_div"
    db        0
L10912:
    db        "m_idiv"
    db        0
L10911:
    db        "m_imul3"
    db        0
L10910:
    db        "m_imul2"
    db        0
L10909:
    db        "m_mul"
    db        0
L10908:
    db        "m_imul"
    db        0
L10907:
    db        "m_sbb"
    db        0
L10906:
    db        "m_adc"
    db        0
L10905:
    db        "m_sub"
    db        0
L10904:
    db        "m_add"
    db        0
L10903:
    db        "m_xchg"
    db        0
L10902:
    db        "m_jmpcc"
    db        0
L10901:
    db        "m_jmp"
    db        0
L10900:
    db        "m_retn"
    db        0
L10899:
    db        "m_leave"
    db        0
L10898:
    db        "m_ret"
    db        0
L10897:
    db        "m_call"
    db        0
L10896:
    db        "m_movsxd"
    db        0
L10895:
    db        "m_movzx"
    db        0
L10894:
    db        "m_movsx"
    db        0
L10893:
    db        "m_movq"
    db        0
L10892:
    db        "m_movd"
    db        0
L10891:
    db        "m_cmovcc"
    db        0
L10890:
    db        "m_lea"
    db        0
L10889:
    db        "m_pop"
    db        0
L10888:
    db        "m_push"
    db        0
L10887:
    db        "m_mov"
    db        0
L10886:
    db        "m_nop"
    db        0
L10885:
    db        "m_labelx"
    db        0
L10884:
    db        "m_endx"
    db        0
L10883:
    db        "m_trace"
    db        0
L10882:
    db        "m_definereg"
    db        0
L10881:
    db        "m_define"
    db        0
L10880:
    db        "m_labelname"
    db        0
L10879:
    db        "m_comment"
    db        0
L10878:
    db        "m_procend"
    db        0
L10877:
    db        "m_procstart"
    db        0
L10876:
    db        "temp_val"
    db        0
L10875:
    db        "name_val"
    db        0
L10874:
    db        "label_val"
    db        0
L10873:
    db        "def_val"
    db        0
L10872:
    db        "stringimm_val"
    db        0
L10871:
    db        "realmem_val"
    db        0
L10870:
    db        "realimm_val"
    db        0
L10869:
    db        "intimm_val"
    db        0
L10868:
    db        "no_val"
    db        0
L10867:
    db        "Program"
    db        0
L10866:
    db        "Misc"
    db        0
L10865:
    db        "Export"
    db        0
L10864:
    db        "Label"
    db        0
L10863:
    db        "Param"
    db        0
L10862:
    db        "Local"
    db        0
L10861:
    db        "Static"
    db        0
L10860:
    db        "Proc"
    db        0
L10859:
    db        "Import"
    db        0
L10858:
    db        "--"
    db        0
L10857:
    db        "gt"
    db        0
L10856:
    db        "ge"
    db        0
L10855:
    db        "le"
    db        0
L10854:
    db        "lt"
    db        0
L10853:
    db        "ne"
    db        0
L10852:
    db        "eq"
    db        0
L10851:
    db        "xx"
    db        0
L10850:
    db        "extproc"
    db        0
L10849:
    db        "addlib"
    db        0
L10848:
    db        "variadic"
    db        0
L10847:
    db        "rettype"
    db        0
L10846:
    db        "local"
    db        0
L10845:
    db        "param"
    db        0
L10844:
    db        "endprog"
    db        0
L10843:
    db        "comment"
    db        0
L10842:
    db        "eval"
    db        0
L10841:
    db        "loadall"
    db        0
L10840:
    db        "setarg"
    db        0
L10839:
    db        "setcall"
    db        0
L10838:
    db        "longjmp"
    db        0
L10837:
    db        "setjmp"
    db        0
L10836:
    db        "labeldef"
    db        0
L10835:
    db        "label"
    db        0
L10834:
    db        "initdswx"
    db        0
L10833:
    db        "data"
    db        0
L10832:
    db        "zstatic"
    db        0
L10831:
    db        "istatic"
    db        0
L10830:
    db        "endproc"
    db        0
L10829:
    db        "tcproc"
    db        0
L10828:
    db        "proc"
    db        0
L10827:
    db        "endmx"
    db        0
L10826:
    db        "resetmx"
    db        0
L10825:
    db        "startmx"
    db        0
L10824:
    db        "fnarrow"
    db        0
L10823:
    db        "fwiden"
    db        0
L10822:
    db        "widen"
    db        0
L10821:
    db        "truncate"
    db        0
L10820:
    db        "fix"
    db        0
L10819:
    db        "float"
    db        0
L10818:
    db        "typepun"
    db        0
L10817:
    db        "toboolto"
    db        0
L10816:
    db        "notto"
    db        0
L10815:
    db        "bitnotto"
    db        0
L10814:
    db        "absto"
    db        0
L10813:
    db        "negto"
    db        0
L10812:
    db        "subpxto"
    db        0
L10811:
    db        "addpxto"
    db        0
L10810:
    db        "maxto"
    db        0
L10809:
    db        "minto"
    db        0
L10808:
    db        "shrto"
    db        0
L10807:
    db        "shlto"
    db        0
L10806:
    db        "bitxorto"
    db        0
L10805:
    db        "bitorto"
    db        0
L10804:
    db        "bitandto"
    db        0
L10803:
    db        "iremto"
    db        0
L10802:
    db        "idivto"
    db        0
L10801:
    db        "divto"
    db        0
L10800:
    db        "multo"
    db        0
L10799:
    db        "subto"
    db        0
L10798:
    db        "addto"
    db        0
L10797:
    db        "loaddecr"
    db        0
L10796:
    db        "loadincr"
    db        0
L10795:
    db        "decrload"
    db        0
L10794:
    db        "incrload"
    db        0
L10793:
    db        "decrto"
    db        0
L10792:
    db        "incrto"
    db        0
L10791:
    db        "fmod"
    db        0
L10790:
    db        "power"
    db        0
L10789:
    db        "atan2"
    db        0
L10788:
    db        "sign"
    db        0
L10787:
    db        "ceil"
    db        0
L10786:
    db        "floor"
    db        0
L10785:
    db        "round"
    db        0
L10784:
    db        "exp"
    db        0
L10783:
    db        "log10"
    db        0
L10782:
    db        "log"
    db        0
L10781:
    db        "atan"
    db        0
L10780:
    db        "acos"
    db        0
L10779:
    db        "asin"
    db        0
L10778:
    db        "tan"
    db        0
L10777:
    db        "cos"
    db        0
L10776:
    db        "sin"
    db        0
L10775:
    db        "sqrt"
    db        0
L10774:
    db        "sqr"
    db        0
L10773:
    db        "toboolf"
    db        0
L10772:
    db        "toboolt"
    db        0
L10771:
    db        "not"
    db        0
L10770:
    db        "bitnot"
    db        0
L10769:
    db        "abs"
    db        0
L10768:
    db        "neg"
    db        0
L10767:
    db        "subp"
    db        0
L10766:
    db        "subpx"
    db        0
L10765:
    db        "addpx"
    db        0
L10764:
    db        "max"
    db        0
L10763:
    db        "min"
    db        0
L10762:
    db        "shr"
    db        0
L10761:
    db        "shl"
    db        0
L10760:
    db        "bitxor"
    db        0
L10759:
    db        "bitor"
    db        0
L10758:
    db        "bitand"
    db        0
L10757:
    db        "idivrem"
    db        0
L10756:
    db        "irem"
    db        0
L10755:
    db        "idiv"
    db        0
L10754:
    db        "div"
    db        0
L10753:
    db        "mul"
    db        0
L10752:
    db        "sub"
    db        0
L10751:
    db        "add"
    db        0
L10750:
    db        "assem"
    db        0
L10749:
    db        "clear"
    db        0
L10748:
    db        "endsw"
    db        0
L10747:
    db        "swlabel"
    db        0
L10746:
    db        "switchu"
    db        0
L10745:
    db        "switch"
    db        0
L10744:
    db        "iswap"
    db        0
L10743:
    db        "fordown"
    db        0
L10742:
    db        "forup"
    db        0
L10741:
    db        "to"
    db        0
L10740:
    db        "stop"
    db        0
L10739:
    db        "setcc"
    db        0
L10738:
    db        "jumpretm"
    db        0
L10737:
    db        "jumpret"
    db        0
L10736:
    db        "jumpf"
    db        0
L10735:
    db        "jumpt"
    db        0
L10734:
    db        "jumpcc"
    db        0
L10733:
    db        "ijump"
    db        0
L10732:
    db        "jump"
    db        0
L10731:
    db        "retfn"
    db        0
L10730:
    db        "icallf"
    db        0
L10729:
    db        "callf"
    db        0
L10728:
    db        "retproc"
    db        0
L10727:
    db        "icallp"
    db        0
L10726:
    db        "callp"
    db        0
L10725:
    db        "storebf"
    db        0
L10724:
    db        "storebit"
    db        0
L10723:
    db        "loadbf"
    db        0
L10722:
    db        "loadbit"
    db        0
L10721:
    db        "type"
    db        0
L10720:
    db        "opnd"
    db        0
L10719:
    db        "unload"
    db        0
L10718:
    db        "swapstk"
    db        0
L10717:
    db        "double"
    db        0
L10716:
    db        "dupl"
    db        0
L10715:
    db        "storem"
    db        0
L10714:
    db        "istorex"
    db        0
L10713:
    db        "istore"
    db        0
L10712:
    db        "store"
    db        0
L10711:
    db        "iloadx"
    db        0
L10710:
    db        "iload"
    db        0
L10709:
    db        "load"
    db        0
L10708:
    db        "nop"
    db        0
L10707:
    db        "any_opnd"
    db        0
L10706:
    db        "data_opnd"
    db        0
L10705:
    db        "realimm32_opnd"
    db        0
L10704:
    db        "realimm_opnd"
    db        0
L10703:
    db        "assem_opnd"
    db        0
L10702:
    db        "strimm_opnd"
    db        0
L10701:
    db        "string_opnd"
    db        0
L10700:
    db        "r32_opnd"
    db        0
L10699:
    db        "real_opnd"
    db        0
L10698:
    db        "int_opnd"
    db        0
L10697:
    db        "label_opnd"
    db        0
L10696:
    db        "memaddr_opnd"
    db        0
L10695:
    db        "mem_opnd"
    db        0
L10694:
    db        "no_opnd"
    db        0
L10693:
    db        "$last"
    db        0
L10692:
    db        "vec"
    db        0
L10691:
    db        "mem"
    db        0
L10690:
    db        "i64"
    db        0
L10689:
    db        "i32"
    db        0
L10688:
    db        "i16"
    db        0
L10687:
    db        "i8"
    db        0
L10686:
    db        "u64"
    db        0
L10685:
    db        "u32"
    db        0
L10684:
    db        "u16"
    db        0
L10683:
    db        "u8"
    db        0
L10682:
    db        "r64"
    db        0
L10681:
    db        "r32"
    db        0
L10680:
    db        "void"
    db        0
L10679:
    db        "pm_extra"
    db        0
L10678:
    db        "pm_colon"
    db        0
L10677:
    db        "pm_libfile"
    db        0
L10676:
    db        "pm_sourcefile"
    db        0
L10675:
    db        "pm_option"
    db        0
L10674:
    db        "pm_end"
    db        0



