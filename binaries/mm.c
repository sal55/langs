// Generated C
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void mm_main();
void (*entrypoint)(void) = mm_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u32 a[5];};   // mem:20;
struct $B18 {u64 a[4];};   // mem:32;
struct $B19 {u64 a[50];};   // mem:400;
struct $B20 {u64 a[143];};   // mem:1144;
struct $B21 {u64 a[64];};   // mem:512;
struct $B22 {u64 a[16];};   // mem:128;
struct $B23 {u64 a[14];};   // mem:112;
struct $B24 {u16 a[7];};   // mem:14;
struct $B25 {u8 a[143];};   // mem:143;
struct $B26 {u64 a[7];};   // mem:56;
struct $B27 {u16 a[3];};   // mem:6;
struct $B28 {u16 a[1];};   // mem:2;
struct $B29 {u64 a[12];};   // mem:96;
struct $B30 {u64 a[20];};   // mem:160;
struct $B31 {u64 a[8];};   // mem:64;
struct $B32 {u64 a[151];};   // mem:1208;
struct $B33 {u8 a[151];};   // mem:151;
struct $B34 {u64 a[21];};   // mem:168;
struct $B35 {u8 a[21];};   // mem:21;
struct $B36 {u64 a[137];};   // mem:1096;
struct $B37 {u8 a[137];};   // mem:137;
struct $B38 {u64 a[18];};   // mem:144;
struct $B39 {u16 a[9];};   // mem:18;
struct $B40 {u64 a[17];};   // mem:136;
struct $B41 {u64 a[128];};   // mem:1024;
struct $B42 {u64 a[193];};   // mem:1544;
struct $B43 {u64 a[1];};   // mem:8;
struct $B44 {u64 a[500];};   // mem:4000;
struct $B45 {u64 a[250];};   // mem:2000;
struct $B46 {u32 a[125];};   // mem:500;
struct $B47 {u64 a[90];};   // mem:720;
struct $B48 {u64 a[18006];};   // mem:144048;
struct $B49 {u64 a[2000];};   // mem:16000;
struct $B50 {u64 a[300];};   // mem:2400;
struct $B51 {u16 a[117009];};   // mem:234018;
struct $B52 {u64 a[5000];};   // mem:40000;
struct $B53 {u64 a[3000];};   // mem:24000;
struct $B54 {u64 a[375];};   // mem:3000;
struct $B55 {u64 a[750];};   // mem:6000;
struct $B56 {u64 a[11];};   // mem:88;
struct $B57 {u64 a[55];};   // mem:440;
struct $B58 {u8 a[55];};   // mem:55;
struct $B59 {u64 a[200];};   // mem:1600;
struct $B60 {u8 a[65];};   // mem:65;
struct $B61 {u8 a[301];};   // mem:301;
struct $B62 {u64 a[31];};   // mem:248;
struct $B63 {u8 a[31];};   // mem:31;
struct $B64 {u64 a[51];};   // mem:408;
struct $B65 {u64 a[16001];};   // mem:128008;
struct $B66 {u32 a[16001];};   // mem:64004;
struct $B67 {u8 a[16001];};   // mem:16001;
struct $B68 {u64 a[152004];};   // mem:1216032;
struct $B69 {u32 a[38001];};   // mem:152004;
struct $B70 {u64 a[1000];};   // mem:8000;
struct $B71 {u64 a[5];};   // mem:40;
struct $B72 {u64 a[65536];};   // mem:524288;
struct $B73 {u64 a[13];};   // mem:104;
struct $B74 {u64 a[33];};   // mem:264;
struct $B75 {u8 a[33];};   // mem:33;
struct $B76 {u64 a[123];};   // mem:984;
struct $B77 {u8 a[123];};   // mem:123;
struct $B78 {u64 a[136];};   // mem:1088;
struct $B79 {u64 a[174];};   // mem:1392;
struct $B80 {u16 a[87];};   // mem:174;
struct $B81 {u32 a[87];};   // mem:348;
struct $B82 {u16 a[25];};   // mem:50;
struct $B83 {u64 a[30];};   // mem:240;
struct $B84 {u64 a[27];};   // mem:216;
struct $B85 {u64 a[22];};   // mem:176;
struct $B86 {u64 a[130];};   // mem:1040;
struct $B87 {u64 a[2048];};   // mem:16384;
struct $B88 {u64 a[208];};   // mem:1664;
struct $B89 {u64 a[45];};   // mem:360;
struct $B90 {u64 a[320];};   // mem:2560;
struct $B91 {u64 a[41];};   // mem:328;
struct $B92 {u64 a[10000];};   // mem:80000;
struct $B93 {u64 a[100];};   // mem:800;
struct $B94 {u64 a[157];};   // mem:1256;
struct $B95 {u64 a[1001];};   // mem:8008;
struct $B96 {u64 a[256];};   // mem:2048;

// Function Ptr Types:
typedef i64 (*F1)(u64);
typedef i64 (*F2)();
typedef i64 (*F3)(i64);
typedef i64 (*F4)(i64, i64);
typedef i64 (*F5)(i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F13)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F14)();
typedef r64 (*F15)(i64);
typedef r64 (*F16)(i64, i64);
typedef i64 (*F17)(i64, u64, u64);
typedef void (*F18)(u64);
typedef u64 (*F19)(i64);
typedef void (*F20)();

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u64 mwindows_hconsole;
static u64 mwindows_hconsolein;
static struct $B17 mwindows_lastkey;
static struct $B17 mwindows_pendkey;
static i64 mwindows_keypending;
static i64 mwindows_hpfreq;
static u64 mwindows_wndproc_callbackfn;
static i64 mwindows_init_flag;
static u8 mwindows_os_gxregisterclass_registered;
static struct $B15 mwindows_os_gethostname_name;
static i64 mwindows_os_gethostname_n;
static i64 mwindows_os_peek_lastticks;
static u8 pcl_pc_userunpcl;
static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc;
static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B18 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest;
static struct $B19 pc_decls_plibfiles;
static struct $B19 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype;
static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole;
static u8 pc_decls_fregoptim;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B20 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest;
static i64 pc_diags_destlinestart;
static struct $B21 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static i64 pc_run_dotrace;
static i64 pc_run_dostep;
static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B22 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B23 pc_tables_pstdnames;
static struct $B24 pc_tables_psize;
static struct $B24 pc_tables_psigned;
static struct $B24 pc_tables_pint;
static struct $B24 pc_tables_pfloat;
static struct $B24 pc_tables_pmin;
static struct $B24 pc_tables_piwrb;
static struct $B23 pc_tables_opndnames;
static struct $B20 pc_tables_pclnames;
static struct $B25 pc_tables_pclhastype;
static struct $B25 pc_tables_pclextra;
static struct $B25 pc_tables_pclhasopnd;
static struct $B25 pc_tables_pclargs;
static struct $B26 pc_tables_ccnames;
static struct $B1 pc_tables_idnames;
static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B20 mc_genmcl_px_handlertable;
static struct $B27 mc_genmcl_scondcodes;
static struct $B27 mc_genmcl_ucondcodes;
static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B29 mc_libmcl_smallinttable;
static struct $B30 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B30 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B21 mc_stackmcl_stropndstack_str;
static u8 mc_genss_rex;
static u8 mc_genss_sizeoverride;
static u8 mc_genss_addroverride;
static u8 mc_genss_f2override;
static u8 mc_genss_f3override;
static u8 mc_genss_nowmask;
static u8 mc_genss_usesizeb;
static u64 mc_genss_extraparam;
static i64 mc_genss_currseg;
static u64 mc_genss_currdata;
static u64 mc_genss_currrelocs;
static i64 mc_genss_nrelocs;
static struct $B3 mc_genss_ishighreg;
static u64 mc_genss_currmcl;
static u64 mc_genss_ripentry;
static struct $B11 mc_decls_valtypenames;
static struct $B32 mc_decls_mclnames;
static struct $B33 mc_decls_mclnopnds;
static struct $B33 mc_decls_mclcodes;
static struct $B34 mc_decls_regnames;
static struct $B35 mc_decls_regcodes;
static struct $B30 mc_decls_condnames;
static struct $B30 mc_decls_asmcondnames;
static struct $B30 mc_decls_asmrevcond;
static struct $B36 mc_decls_dregnames;
static struct $B37 mc_decls_regsizes;
static struct $B37 mc_decls_regindices;
static struct $B22 mc_decls_xmmregnames;
static struct $B31 mc_decls_fregnames;
static struct $B31 mc_decls_mregnames;
static struct $B38 mc_decls_jmpccnames;
static struct $B39 mc_decls_jmpcccodes;
static struct $B22 mc_decls_setccnames;
static struct $B3 mc_decls_setcccodes;
static struct $B22 mc_decls_cmovccnames;
static struct $B3 mc_decls_cmovcccodes;
static struct $B12 mc_decls_segmentnames;
static struct $B8 mc_decls_reftypenames;
static struct $B12 mc_decls_opndnames_ma;
static struct $B30 mc_decls_pclopnd;
static struct $B17 mc_decls_pclreg;
static struct $B17 mc_decls_pclmode;
static struct $B17 mc_decls_pclcount;
static struct $B17 mc_decls_pclloc;
static struct $B17 mc_decls_pcltempflags;
static struct $B30 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B18 mc_decls_locnames;
static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames;
static struct $B18 mc_decls_callalign;
static struct $B18 mc_decls_callblockret;
static struct $B22 mc_decls_callblocksize;
static struct $B21 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used;
static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment;
static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B41 mc_decls_regtable;
static struct $B42 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static u64 mc_decls_regmodes;
static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B19 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs;
static struct $B12 mc_decls_multxregs;
static struct $B24 mc_decls_ploadopx;
static struct $B24 mc_decls_ploadop;
static struct $B26 mc_objdecls_relocnames;
static struct $B41 mc_writenasm_nregnames;
static u8 mc_writenasm_currseg;
static struct $B21 mc_writenasm_strmcl_str;
static struct $B21 mc_writenasm_mstropnd_str;
static struct $B21 mc_writenasm_strvalue_str;
static struct $B18 mc_writenasm_getxregname_str;
static struct $B16 mc_writenasm_getdispname_str;
static struct $B22 mc_writenasm_gettempname_str;
static struct $B19 mc_writeexe_libinsttable;
static struct $B19 mc_writeexe_libinstnames;
static struct $B19 mc_writeexe_libnotable;
static u64 mc_writeexe_basereloclist;
static i64 mc_writeexe_nbaserelocs;
static i64 mc_writeexe_maxrelocaddr;
static struct $B44 mc_writeexe_blockbases;
static struct $B45 mc_writeexe_blockcounts;
static struct $B45 mc_writeexe_blockbytes;
static struct $B46 mc_writeexe_blockpadding;
static i64 mc_writeexe_nbaseblocks;
static i64 mc_writeexe_basetablesize;
static i64 mc_writeexe_imagebase;
static i64 mc_writeexe_imagesize;
static i64 mc_writeexe_filesize;
static u64 mc_writeexe_thunktable;
static i64 mc_writeexe_fileiatoffset;
static i64 mc_writeexe_fileiatsize;
static u64 mc_writeexe_stentrypoint;
static u64 mc_writeexe_stentrypoint2;
static u64 mc_writeexe_stentrypoint3;
static struct $B47 mc_writeexe_sectiontable;
static i64 mc_writeexe_nsections;
static u64 mc_writeexe_importdir;
static struct $B48 mc_writeexe_importtable;
static i64 mc_writeexe_nimports;
static struct $B49 mc_writeexe_exporttable;
static i64 mc_writeexe_nexports;
static u64 mc_writeexe_dllfilename;
static i64 mc_writeexe_isdll;
static struct $B50 mc_writeexe_dlltable;
static i64 mc_writeexe_ndlls;
static u64 mc_writeexe_datastart;
static u64 mc_writeexe_dataptr;
static u64 mc_writeexe_userentrypoint;
static i64 mc_writeexe_exportdirvirtaddr;
static i64 mc_writeexe_exportdirvirtsize;
static i64 mc_writeexe_exportdiroffset;
static i64 mc_writeexe_blockdirvirtaddr;
static i64 mc_writeexe_blockdirvirtsize;
static i64 mc_writeexe_blockdiroffset;
static i64 mc_writeobj_symtaboffset;
static u64 mc_writeobj_datastart;
static u64 mc_writeobj_dataptr;
static struct $B51 mc_writeobj_symboltable;
static i64 mc_writeobj_nsymbols;
static i64 mc_writeobj_stoffset;
static struct $B52 mc_writeobj_stringtable;
static struct $B52 mc_writeobj_stringlengths;
static i64 mc_writeobj_nextstringoffset;
static i64 mc_writeobj_nstrings;
static struct $B2 mc_writeobj_writerelocs_s;
static struct $B39 mc_writeobj_makesymbol_r;
static struct $B39 mc_writeobj_strtoaux_r;
static struct $B39 mc_writeobj_sectiontoaux_r;
static struct $B23 mx_decls_mcxdirnames;
static struct $B12 mx_decls_mcxrelocnames;
static struct $B30 mx_decls_dllnametable;
static struct $B30 mx_decls_dllinsttable;
static i64 mx_decls_ndlllibs;
static struct $B30 mx_decls_libnametable;
static struct $B30 mx_decls_libtable;
static struct $B17 mx_decls_librelocated;
static struct $B17 mx_decls_libinitdone;
static i64 mx_decls_nlibs;
static struct $B53 mx_decls_symbolnametable;
static struct $B54 mx_decls_symboldefined;
static struct $B53 mx_decls_symboladdress;
static struct $B55 mx_decls_symbollibindex;
static struct $B54 mx_decls_symboldllindex;
static i64 mx_decls_nsymbols;
static i64 mx_decls_nsymimports;
static i64 mx_decls_nsymexports;
static struct $B12 mx_lib_rsegmentnames;
static u64 mx_write_dest;
static u64 mx_write_entrypoint;
static u64 mm_cli_syslibname;
static struct $B56 mm_cli_passnames;
static struct $B31 mm_cli_dpassnames;
static struct $B57 mm_cli_optionnames;
static struct $B58 mm_cli_optionvalues;
static u8 mm_cli_msfile;
static u64 mm_cli_outext;
static i64 mm_cli_startclock;
static i64 mm_cli_endclock;
static i64 mm_cli_cmdskip;
static u64 mm_cli_inputfile;
static i64 mm_cli_loadtime;
static i64 mm_cli_parsetime;
static i64 mm_cli_resolvetime;
static i64 mm_cli_typetime;
static i64 mm_cli_ctime;
static i64 mm_cli_pcltime;
static i64 mm_cli_compiletime;
static u8 mm_cli_do_option_outused;
static u8 mm_cli_do_option_outpathused;
static i64 mm_genpcl_retindex;
static i64 mm_genpcl_initstaticsindex;
static u64 mm_genpcl_pcldoswx;
static struct $B59 mm_genpcl_loopstack;
static i64 mm_genpcl_loopindex;
static struct $B60 mm_genpcl_zero_unit;
static u64 mm_genpcl_pzero;
static i64 mm_genpcl_nvarlocals;
static i64 mm_genpcl_nvarparams;
static i64 mm_blockpcl_nnn;
static struct $B30 mm_blockpcl_casestmt;
static struct $B30 mm_blockpcl_caseelse;
static i64 mm_blockpcl_casedepth;
static u64 mm_blockpcl_sw_labeltable;
static u64 mm_blockpcl_sw_valuetable;
static i64 mm_blockpcl_sw_lower;
static i64 mm_blockpcl_sw_ncases;
static u8 mm_blockpcl_sw_defaultseen;
static i64 mm_blockpcl_sw_defaultlabel;
static i64 mm_blockpcl_sw_breaklabel;
static i64 mm_blockpcl_maxreg;
static u64 mm_blockpcl_pnprocs;
static u64 mm_blockpcl_pprocname;
static u64 mm_blockpcl_pprocaddr;
static struct $B7 mm_decls_modules;
static struct $B61 mm_decls_moduletosub;
static struct $B62 mm_decls_subprogs;
static struct $B7 mm_decls_sources;
static struct $B63 mm_decls_subproghasstart;
static i64 mm_decls_nmodules;
static i64 mm_decls_nsubprogs;
static i64 mm_decls_nsourcefiles;
static i64 mm_decls_nlibfiles;
static u64 mm_decls_stprogram;
static u64 mm_decls_stmodule;
static i64 mm_decls_currmoduleno;
static u8 mm_decls_loadedfromma;
static struct $B3 mm_decls_lx;
static struct $B3 mm_decls_nextlx;
static struct $B64 mm_decls_libfiles;
static i64 mm_decls_mainsubprogno;
static i64 mm_decls_ntypes;
static struct $B65 mm_decls_ttnamedef;
static struct $B65 mm_decls_ttowner;
static struct $B66 mm_decls_ttbasetype;
static struct $B65 mm_decls_ttname;
static struct $B66 mm_decls_ttsize;
static struct $B67 mm_decls_ttsizeset;
static struct $B66 mm_decls_ttlower;
static struct $B66 mm_decls_ttlength;
static struct $B65 mm_decls_ttmult;
static struct $B65 mm_decls_ttdimexpr;
static struct $B66 mm_decls_tttarget;
static struct $B67 mm_decls_ttusercat;
static struct $B66 mm_decls_ttlineno;
static struct $B67 mm_decls_ttsigned;
static struct $B67 mm_decls_ttisreal;
static struct $B67 mm_decls_ttisinteger;
static struct $B67 mm_decls_ttisshort;
static struct $B67 mm_decls_ttisref;
static struct $B67 mm_decls_ttisblock;
static struct $B68 mm_decls_typenames;
static struct $B69 mm_decls_typenamepos;
static i64 mm_decls_ntypenames;
static struct $B37 mm_decls_typestarterset;
static u64 mm_decls_currproc;
static i64 mm_decls_assemmode;
static i64 mm_decls_headermode;
static u64 mm_decls_proclist;
static u64 mm_decls_proclistx;
static u64 mm_decls_staticlist;
static u64 mm_decls_staticlistx;
static u64 mm_decls_constlist;
static u64 mm_decls_constlistx;
static u64 mm_decls_nullunit;
static i64 mm_decls_ndllproctable;
static struct $B70 mm_decls_dllproctable;
static i64 mm_decls_fverbose;
static u8 mm_decls_msyslevel;
static u8 mm_decls_mvarlib;
static u8 mm_decls_fvarnames;
static u8 mm_decls_fshowtiming;
static u8 mm_decls_fshowss;
static u8 mm_decls_fshowc;
static u8 mm_decls_fshowpcl;
static u8 mm_decls_fshowasm;
static u8 mm_decls_fshowast1;
static u8 mm_decls_fshowast2;
static u8 mm_decls_fshowast3;
static u8 mm_decls_fshowst;
static u8 mm_decls_fshowpst;
static u8 mm_decls_fshowstflat;
static u8 mm_decls_fshowtypes;
static u8 mm_decls_fshowmodules;
static u8 mm_decls_fcheckunusedlocals;
static u8 mm_decls_highmem;
static u8 mm_decls_clinux;
static u8 mm_decls_dointlibs;
static i64 mm_decls_passlevel;
static i64 mm_decls_dpasslevel;
static i64 mm_decls_prodmode;
static i64 mm_decls_debugmode;
static i64 mm_decls_libmode;
static i64 mm_decls_fshortnames;
static u64 mm_decls_outfile;
static u64 mm_decls_destfilename;
static u64 mm_decls_destfilepath;
static i64 mm_decls_nunits;
static i64 mm_decls_nunitsmem;
static i64 mm_diags_currlineno;
static i64 mm_diags_currfileno;
static struct $B3 mm_diags_sbuffer;
static u64 mm_diags_dest;
static struct $B41 mm_diags_getprefix_str;
static struct $B71 mm_diags_getlineinfok_str;
static struct $B30 mm_lex_lxstart_stack;
static struct $B30 mm_lex_lxsource_stack;
static struct $B30 mm_lex_lxsptr_stack;
static struct $B30 mm_lex_lxfileno_stack;
static struct $B6 mm_lex_lxnextlx_stack;
static struct $B17 mm_lex_lximport_stack;
static i64 mm_lex_sourcelevel;
static i64 mm_lex_lximport;
static u64 mm_lex_lxsource;
static u64 mm_lex_lxstart;
static u64 mm_lex_lxsptr;
static i64 mm_lex_lxifcond;
static i64 mm_lex_lxfileno;
static struct $B72 mm_lex_hashtable;
static struct $B16 mm_lex_namemap;
static u64 mm_lex_u64maxstr;
static i64 mm_lib_autotypeno;
static i64 mm_lib_nextavindex;
static i64 mm_lib_nextsvindex;
static struct $B3 mm_lib_exprstrvar;
static u64 mm_lib_exprstr;
static u64 mm_lib_unitheapptr;
static i64 mm_lib_remainingunits;
static struct $B3 mm_lib_sbuffer;
static u64 mm_lib_dest;
static u64 mm_lib_jdest;
static u64 mm_lib_framevarname;
static struct $B18 mm_lib_nextautotype_str;
static struct $B16 mm_lib_getdottedname_str;
static struct $B4 mm_lib_strmode_str;
static struct $B4 mm_lib_strmode2_str;
static struct $B73 mm_libsources_syslibnames;
static struct $B73 mm_libsources_syslibtext;
static u64 mm_modules_fileext;
static struct $B15 mm_modules_getmodulefilename_str;
static u64 mm_name_currstproc;
static i64 mm_name_allowmodname;
static i64 mm_name_noexpand;
static i64 mm_name_noassem;
static i64 mm_name_macrolevels;
static struct $B19 mm_name_macroparams;
static struct $B19 mm_name_macroparamsgen;
static struct $B19 mm_name_macroargs;
static i64 mm_name_nmacroparams;
static i64 mm_name_nmacroargs;
static i64 mm_parse_intabledata;
static i64 mm_parse_inreadprint;
static i64 mm_parse_inparamlist;
static i64 mm_parse_inrecordbody;
static i64 mm_parse_inimportmodule;
static i64 mm_parse_labelseen;
static u64 mm_parse_tabledataname;
static struct $B1 mm_parse_procstack;
static i64 mm_parse_nprocstack;
static u64 mm_parse_unionstring;
static u64 mm_parse_unionpend;
static u64 mm_parse_unionlastvar;
static u64 mm_parse_dretvar;
static i64 mm_parse_varattribs;
static struct $B1 mm_parse_dollarstack;
static i64 mm_parse_ndollar;
static i64 mm_parse_insiderecord;
static i64 mm_parse_insidedllimport;
static struct $B1 mm_parse_forindexvars;
static i64 mm_parse_nforloops;
static u64 mm_support_bytemasks;
static struct $B16 mm_tables_stdnames;
static struct $B18 mm_tables_stdsize;
static struct $B18 mm_tables_stdpcl;
static i64 mm_tables_trefproc;
static i64 mm_tables_treflabel;
static struct $B74 mm_tables_sysfnnames;
static struct $B75 mm_tables_sysfnparams;
static struct $B75 mm_tables_sysfnres;
static struct $B74 mm_tables_sysfnhandlers;
static struct $B76 mm_tables_jtagnames;
static struct $B77 mm_tables_jsubs;
static struct $B77 mm_tables_jisexpr;
static struct $B77 mm_tables_jsolo;
static struct $B31 mm_tables_bitfieldnames;
static struct $B18 mm_tables_optypenames;
static struct $B78 mm_tables_symbolnames;
static struct $B40 mm_tables_symboloptypes;
static struct $B40 mm_tables_symbolgenops;
static struct $B40 mm_tables_symbolgentoops;
static struct $B40 mm_tables_symbolopprios;
static struct $B40 mm_tables_exprstarter;
static struct $B18 mm_tables_headerdirnames;
static struct $B18 mm_tables_scopenames;
static struct $B3 mm_tables_parammodenames;
static struct $B38 mm_tables_namenames;
static struct $B39 mm_tables_name2pid;
static struct $B1 mm_tables_propnames;
static struct $B79 mm_tables_stnames;
static struct $B80 mm_tables_stsymbols;
static struct $B81 mm_tables_stsubcodes;
static struct $B23 mm_tables_convnames;
static struct $B24 mm_tables_convtopcl;
static struct $B12 mm_tables_d_typestarterset;
static struct $B82 mm_tables_softconvtable;
static struct $B40 mm_tables_endsexpr;
static struct $B9 mm_tables_exprendsymbols;
static struct $B77 mm_tables_isbooltag;
static i64 mm_type_countedfields;
static i64 mm_type_inassem;
static i64 mm_type_inidata;
static i64 mm_type_tpass_depth;
static i64 mm_type_setrecordsize_depth;
static i64 mm_type_tx_assign_nn;
static i64 $nprocs;
static struct $B86 $procname;
static struct $B86 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);
extern u64 GetStdHandle(u32 $1);
extern i64 GetConsoleScreenBufferInfo(u64 $1, u64 $2);
extern i64 SetConsoleCtrlHandler(u64 $1, i64 $2);
extern i64 SetConsoleMode(u64 $1, u32 $2);
extern i64 CreateProcessA(u64 $1, u64 $2, u64 $3, u64 $4, i64 $5, u32 $6, u64 $7, u64 $8, u64 $9, u64 $10);
extern u32 GetLastError();
extern u32 WaitForSingleObject(u64 $1, u32 $2);
extern i64 GetExitCodeProcess(u64 $1, u64 $2);
extern i64 CloseHandle(u64 $1);
extern i64 GetNumberOfConsoleInputEvents(u64 $1, u64 $2);
extern i64 FlushConsoleInputBuffer(u64 $1);
extern u64 LoadLibraryA(u64 $1);
extern u64 GetProcAddress(u64 $1, u64 $2);
extern u64 LoadCursorA(u64 $1, u64 $2);
extern u32 RegisterClassExA(u64 $1);
extern i64 DefWindowProcA(u64 $1, u32 $2, u64 $3, u64 $4);
extern i64 ReadConsoleInputA(u64 $1, u64 $2, u32 $3, u64 $4);
extern void Sleep(u32 $1);
extern u32 GetModuleFileNameA(u64 $1, u64 $2, u32 $3);
extern void ExitProcess(u32 $1);
extern void PostQuitMessage(i32 $1);
extern void MessageBoxA(i32 x, u64 message, u64 caption, i32 y);
extern u32 QueryPerformanceCounter(u64 $1);
extern u32 QueryPerformanceFrequency(u64 $1);
extern u64 CreateFileA(u64 $1, u32 $2, u32 $3, u64 $4, u32 $5, u32 $6, u64 $7);
extern u32 GetFileTime(u64 $1, u64 $2, u64 $3, u64 $4);
extern void GetSystemTime(u64 $1);
extern void GetLocalTime(u64 $1);
extern u64 GetTickCount64();
extern u32 PeekMessageA(u64 $1, u64 $2, u32 $3, u32 $4, u32 $5);
extern u64 GetCommandLineA();
extern u64 VirtualAlloc(u64 $1, u32 $2, u32 $3, u32 $4);
extern u32 VirtualProtect(u64 $1, u32 $2, u32 $3, u64 $4);
extern u32 WriteConsoleA(u64 $1, u64 $2, i32 $3, u64 $4, u64 $5);
extern u64 FindFirstFileA(u64 $1, u64 $2);
extern u32 FindNextFileA(u64 $1, u64 $2);
extern u32 FindClose(u64 $1);
extern u32 MessageBeep(i32 $1);
extern u32 Beep(i32 freq, i32 dur);

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static void mwindows_os_gxregisterclass(u64 classname);
static i64 mwindows_mainwndproc(u64 hwnd, u32 message, u64 wparam, u64 lparam);
static u64 mwindows_os_gethostname();
static void mwindows_os_peek();
static u64 pc_api_strpmode(i64 mode, i64 size);
static u64 pc_api_getfullname(u64 d, i64 backtick);
static u64 pc_api_addstr(u64 s, u64 t);
static u64 pc_diags_stropnd(u64 p);
static void mc_genmcl_inithandlers();
static u64 mc_libmcl_mgenextname(u64 s);
static u64 mc_stackmcl_stropndstack(i64 indent);
static u64 mc_genss_genrm(i64 reg, i64 opc, u64 b, i64 isxreg);
static void mc_writenasm_strmcl(u64 mcl);
static u64 mc_writenasm_mstropnd(u64 a, i64 sizeprefix, i64 opcode);
static u64 mc_writenasm_strvalue(u64 a);
static u64 mc_writenasm_getxregname(i64 reg, i64 size);
static u64 mc_writenasm_getdispname(u64 d);
static u64 mc_writenasm_gettempname(u64 d, i64 n);
static void mc_writeexe_writedosstub();
static void mc_writeobj_writerelocs(u64 r, i64 nrelocs);
static u64 mc_writeobj_makesymbol(u64 name, i64 value, i64 sectionno, i64 symtype, i64 storage, i64 naux);
static u64 mc_writeobj_strtoaux(u64 s);
static u64 mc_writeobj_sectiontoaux(u64 data, i64 nrelocs);
static void mm_cli_do_option(i64 sw, u64 value, i64 paramno);
static void mm_assem_initassemsymbols();
static void mm_diags_printunit(u64 p, i64 level, u64 prefix, u64 dev);
static u64 mm_diags_getprefix(i64 level, u64 prefix, u64 p);
static u64 mm_diags_getlineinfok();
static void mm_diags_printmodelist(u64 f);
static void mm_diags_showprojectinfo(u64 dev);
static u64 mm_lib_nextautotype();
static u64 mm_lib_getdottedname(u64 p);
static u64 mm_lib_strmode(i64 m, i64 expand);
static u64 mm_lib_strmode2(i64 m, i64 expand);
static u64 mm_modules_getmodulefilename(u64 path, u64 name, i64 issyslib);
static u64 mm_parse_readcompilervar();
static void mm_type_tpass(u64 p, i64 t, i64 lv);
static void mm_type_setrecordsize(i64 m);
static void mm_type_tx_assign(u64 p, u64 a, u64 b, i64 t);
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_startcon();
static void msysc_m$print_setfmt(u64 format);
static void msysc_m$print_end();
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_newline();
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mwindows_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mwindows_os_init();
static i64 mwindows_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mwindows_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mwindows_os_getch();
static i64 mwindows_os_getchx();
static i64 mwindows_os_kbhit();
static u64 mwindows_os_getdllinst(u64 name);
static u64 mwindows_os_getdllprocaddr(i64 hinst, u64 name);
static void mwindows_os_initwindows();
static void mwindows_os_setmesshandler(u64 addr);
static u64 mwindows_os_getos();
static i64 mwindows_os_gethostsize();
static i64 mwindows_os_shellexec(u64 opc, u64 file);
static void mwindows_os_sleep(i64 a);
static u64 mwindows_os_getstdout();
static u64 mwindows_os_getmpath();
static i64 mwindows_os_clock();
static i64 mwindows_os_hpcounter();
static i64 mwindows_os_ticks();
static i64 mwindows_os_iswindows();
static void mwindows_os_getsystime(u64 tm);
static u64 mwindows_os_allocexecmem(i64 n);
static i64 mwindows_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static i64 mwindows_os_hpfreq();
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
static u64 pc_api_pcl_start(u64 name, i64 nunits);
static void pc_api_pclerror(u64 mess);
static u64 pc_api_pc_makesymbol(u64 s, i64 id);
static void pc_api_pcl_end();
static void pc_api_pc_gen(i64 opcode, u64 p);
static u64 pc_api_pcl_writepcl(u64 filename);
static u64 pc_diags_writeallpcl();
static u64 pc_api_pcl_writepst(u64 filename);
static u64 pc_diags_writepst();
static void pc_api_pcl_genmcl();
static void mc_genmcl_genmcl(u64 dummy);
static void pc_api_pcl_genss(i64 obj);
static void mc_genss_genss(i64 obj);
static u64 pc_api_pcl_writess(u64 filename, i64 obj);
static u64 mc_writess_dummy_writessdata(i64 fexe);
static u64 pc_api_pcl_writeasm(u64 filename, i64 atype);
static u64 mc_writenasm_getassemstr();
static void pc_api_pcl_writeobj(u64 filename);
static void mc_writeobj_writecoff(u64 outfile);
static void pc_api_pcl_writedll(u64 filename);
static void mc_writeexe_writeexe(u64 outfile, i64 dodll, u64 entrypoint);
static void pc_api_pcl_writeexe(u64 filename);
static void pc_api_pcl_writemx(u64 filename);
static void mx_write_writemcx(u64 filename);
static void pc_api_pcl_exec();
static void mx_run_runlibfile(u64 filename, i64 cmdskip);
static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames);
static void pc_api_extendpclblock();
static u64 pc_api_newpcl();
static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset);
static void pc_api_pc_genx(i64 opcode, i64 x, u64 p);
static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p);
static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p);
static u64 pc_api_genint(i64 a);
static u64 pc_api_genreal(r64 x, i64 mode);
static u64 pc_api_genrealimm(r64 x, i64 mode);
static u64 pc_api_genstring(u64 s);
static u64 pc_api_genpcstrimm(u64 s);
static u64 pc_api_genlabel(i64 a);
static u64 pc_api_genmem(u64 d);
static u64 pc_api_genmemaddr(u64 d);
static u64 pc_api_gendata(u64 s, i64 length);
static void pc_api_gencomment(u64 s);
static u64 pc_api_genname(u64 s);
static u64 pc_api_gennameaddr(u64 s);
static u64 pc_api_genassem(u64 code);
static void pc_api_pc_setmode(i64 m, i64 size);
static void pc_api_pc_setmode2(i64 m);
static void pc_api_pc_setxy(i64 x, i64 y);
static void pc_api_pc_setscaleoff(i64 scale, i64 offset);
static void pc_api_pc_setoffset(i64 offset);
static void pc_api_pc_addoffset(i64 offset);
static void pc_api_pc_setincr(i64 n);
static void pc_api_pc_setnargs(i64 n);
static void pc_api_pc_setnvariadics(i64 n);
static void pc_api_pc_setalign(i64 n);
static void pc_api_perror(u64 mess);
static void pc_api_perror_s(u64 mess, u64 param);
static u64 pc_api_getbasename(u64 s);
static void pc_api_pc_addsymbol(u64 d);
static void pc_api_pcerrorstop(u64 filename, i64 lineno);
static void pc_api_pc_addplib(u64 name);
static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded);
static void pc_api_pc_setimport(u64 d);
static void pc_api_pc_addparam(u64 d);
static void pc_api_pc_addlocal(u64 d);
static void pc_api_pc_endproc();
static void pc_api_merror(u64 mess, u64 param);
static u64 pc_api_pc_duplpst(u64 d);
static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip);
static i64 pc_api_convertstring(u64 s, u64 t);
static void pc_diags_strpcl(u64 p);
static void pc_diags_strlabel(i64 labelno, i64 colon);
static void pc_diags_psstr(u64 s);
static void pc_diags_psname(u64 d);
static void pc_diags_psline();
static void pc_diags_psstrline(u64 s);
static void pc_diags_psdata(u64 p);
static void pc_diags_pstabto(i64 n);
static u64 pc_diags_strpclstr(u64 p, i64 buffsize);
static void pc_diags_writepcl(u64 p);
static void pc_diags_psint(i64 a);
static void pc_diags_psopnd(u64 p);
static void pc_diags_writepsymbol(u64 d, u64 fmt);
static void pc_diags_showprocinfo(u64 d);
static void pc_reduce_pcl_reducetest();
static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain);
static i64 pc_runaux_pci_getopnd(u64 p, u64 locals);
static i64 pc_runaux_pci_loadptr(u64 p, i64 mode);
static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size);
static void pc_runaux_pcusopnd(u64 p);
static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j);
static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x);
static i64 pc_run_getlineno(u64 pc);
static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param);
static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode);
static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y);
static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y);
static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y);
static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals);
static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode);
static void pc_run_fixuppcl();
static u64 pc_runaux_getdllfnptr(u64 d);
static void pc_run_pcl_runpcl();
static void pc_runaux_loadlibs();
static void pc_runaux_docmdskip();
static void mc_libmcl_mclinit(i64 bypass);
static void mc_genmcl_convertpcl(u64 p);
static void mc_stackmcl_showopndstack();
static void mc_auxmcl_genrealtable();
static void mc_auxmcl_genabsneg();
static void mc_auxmcl_genstringtable();
static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b);
static void mc_optim_peephole();
static void mc_genmcl_unimpl(u64 p);
static void mc_genmcl_doshowpcl(u64 p);
static void mc_libmcl_mgencomment(u64 s);
static void mc_genmcl_px_nop(u64 p);
static void mc_genmcl_px_dupl(u64 p);
static void mc_stackmcl_duplpcl();
static void mc_genmcl_px_double(u64 p);
static void mc_genmcl_px_opnd(u64 p);
static void mc_genmcl_px_type(u64 p);
static void mc_genmcl_px_comment(u64 p);
static void mc_genmcl_px_proc(u64 p);
static void mc_libmcl_setsegment(i64 seg, i64 align);
static u64 mc_libmcl_mgenmemaddr(u64 d);
static void mc_auxmcl_initproc(u64 d);
static void mc_auxmcl_fixmain();
static void mc_genmcl_px_endproc(u64 p);
static void mc_genmcl_px_endprog(u64 p);
static void mc_genmcl_px_istatic(u64 p);
static void mc_genmcl_px_zstatic(u64 p);
static u64 mc_libmcl_mgenint(i64 x, i64 mode);
static void mc_genmcl_px_data(u64 p);
static void mc_auxmcl_do_blockdata(u64 p);
static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode);
static i64 mc_libmcl_getstringindex(u64 s);
static u64 mc_libmcl_mgenlabel(i64 x);
static void mc_genmcl_px_label(u64 p);
static void mc_genmcl_px_load(u64 p);
static void mc_stackmcl_pushpcl(u64 p);
static void mc_genmcl_px_store(u64 p);
static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg);
static u64 mc_libmcl_mgenmem(u64 d, i64 mode);
static u64 mc_stackmcl_getworkregm(i64 mode);
static u64 mc_stackmcl_makeopndind(u64 a, i64 mode);
static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest);
static void mc_stackmcl_poppcl();
static void mc_genmcl_px_add(u64 p);
static u64 mc_stackmcl_isimmload(i64 n);
static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_sub(u64 p);
static void mc_genmcl_px_mul(u64 p);
static void mc_auxmcl_mulimm(u64 ax, i64 n);
static void mc_genmcl_px_div(u64 p);
static void mc_genmcl_px_eval(u64 p);
static void mc_genmcl_px_widen(u64 p);
static void mc_stackmcl_setnewzz(i64 reg, i64 mode);
static void mc_genmcl_px_jump(u64 p);
static void mc_genmcl_px_ijump(u64 p);
static void mc_genmcl_px_neg(u64 p);
static void mc_auxmcl_do_negreal(u64 ax, i64 mode);
static void mc_genmcl_px_abs(u64 p);
static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b);
static void mc_auxmcl_do_absreal(u64 ax, i64 mode);
static void mc_genmcl_px_bitnot(u64 p);
static void mc_genmcl_px_not(u64 p);
static u64 mc_libmcl_changeopndsize(u64 a, i64 size);
static void mc_genmcl_px_toboolt(u64 p);
static void mc_genmcl_px_sqr(u64 p);
static void mc_genmcl_px_sqrt(u64 p);
static void mc_genmcl_px_jumpcc(u64 p);
static void mc_genmcl_px_jumpt(u64 p);
static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond);
static void mc_genmcl_px_jumpf(u64 p);
static void mc_genmcl_px_bitand(u64 p);
static void mc_auxmcl_do_bitwise(u64 p, i64 opc);
static void mc_genmcl_px_bitor(u64 p);
static void mc_genmcl_px_bitxor(u64 p);
static void mc_genmcl_px_shl(u64 p);
static void mc_auxmcl_do_shift(u64 p, i64 opc);
static void mc_genmcl_px_shr(u64 p);
static void mc_genmcl_px_retproc(u64 p);
static void mc_auxmcl_do_procentry(u64 p);
static void mc_auxmcl_do_procexit();
static void mc_genmcl_px_retfn(u64 p);
static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset);
static u64 mc_libmcl_mgenreg(i64 reg, i64 mode);
static void mc_genmcl_px_setcall(u64 p);
static void mc_stackmcl_saveopnds(i64 n);
static void mc_libmcl_pushslots(i64 nslots);
static void mc_genmcl_px_setarg(u64 p);
static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno);
static void mc_stackmcl_pushopnd(i64 n, i64 mode);
static void mc_genmcl_px_callp(u64 p);
static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr);
static void mc_libmcl_popslots(i64 nslots);
static void mc_auxmcl_do_getretvalue(u64 p);
static void mc_genmcl_px_jumpret(u64 p);
static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_jumpretm(u64 p);
static void mc_stackmcl_movetoreg(i64 newreg);
static void mc_genmcl_px_startmx(u64 p);
static void mc_genmcl_px_resetmx(u64 p);
static void mc_genmcl_px_stop(u64 p);
static void mc_genmcl_px_incrto(u64 p);
static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrto(u64 p);
static void mc_genmcl_px_incrload(u64 p);
static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrload(u64 p);
static void mc_genmcl_px_loadincr(u64 p);
static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_loaddecr(u64 p);
static void mc_genmcl_px_forup(u64 p);
static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond);
static void mc_genmcl_px_fordown(u64 p);
static void mc_genmcl_px_iload(u64 p);
static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode);
static i64 mc_genmcl_getsharereg(u64 ax, i64 mode);
static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode);
static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode);
static void mc_auxmcl_dolea(u64 ax, u64 px);
static void mc_genmcl_px_iloadx(u64 p);
static u64 mc_auxmcl_do_addrmode(u64 p);
static void mc_genmcl_px_istore(u64 p);
static u64 mc_stackmcl_makesimpleaddr(u64 ax);
static void mc_genmcl_px_istorex(u64 p);
static void mc_genmcl_px_storem(u64 p);
static u64 mc_libmcl_newblocktemp(i64 size);
static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size);
static void mc_genmcl_px_addpx(u64 p);
static void mc_genmcl_px_subpx(u64 p);
static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale);
static void mc_genmcl_px_to(u64 p);
static void mc_genmcl_px_iswap(u64 p);
static void mc_genmcl_px_swapstk(u64 p);
static void mc_stackmcl_swapopnds(i64 m, i64 n);
static void mc_genmcl_px_labeldef(u64 p);
static void mc_genmcl_px_addto(u64 p);
static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc);
static void mc_genmcl_px_subto(u64 p);
static void mc_genmcl_px_multo(u64 p);
static void mc_auxmcl_do_binto_float(u64 p, i64 opc);
static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg);
static void mc_genmcl_px_bitandto(u64 p);
static void mc_genmcl_px_bitorto(u64 p);
static void mc_genmcl_px_bitxorto(u64 p);
static void mc_genmcl_px_shlto(u64 p);
static void mc_auxmcl_do_shiftnto(u64 p, i64 opc);
static void mc_genmcl_px_shrto(u64 p);
static void mc_genmcl_px_fix(u64 p);
static void mc_genmcl_px_float(u64 p);
static i64 mc_libmcl_mcreatefwdlabel();
static void mc_libmcl_mdefinefwdlabel(i64 lab);
static u64 mc_libmcl_mgenlabelmem(i64 x);
static void mc_genmcl_px_idiv(u64 p);
static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv);
static void mc_genmcl_px_irem(u64 p);
static void mc_genmcl_px_idivrem(u64 p);
static void mc_genmcl_px_clear(u64 p);
static void mc_auxmcl_clearblock(u64 ax, i64 n);
static void mc_genmcl_px_subp(u64 p);
static i64 mc_libmcl_ispoweroftwo(i64 x);
static void mc_genmcl_px_switch(u64 p);
static i64 mc_stackmcl_getworkireg();
static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def);
static void mc_genmcl_px_switchu(u64 p);
static void mc_genmcl_px_swlabel(u64 p);
static void mc_genmcl_px_endsw(u64 p);
static void mc_genmcl_px_fwiden(u64 p);
static void mc_genmcl_px_fnarrow(u64 p);
static void mc_genmcl_px_truncate(u64 p);
static void mc_genmcl_px_typepun(u64 p);
static void mc_genmcl_px_unload(u64 p);
static void mc_genmcl_px_loadbit(u64 p);
static void mc_genmcl_px_assem(u64 p);
static void mc_genmcl_px_sin(u64 p);
static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs);
static void mc_genmcl_px_cos(u64 p);
static void mc_genmcl_px_tan(u64 p);
static void mc_genmcl_px_asin(u64 p);
static void mc_genmcl_px_acos(u64 p);
static void mc_genmcl_px_atan(u64 p);
static void mc_genmcl_px_log(u64 p);
static void mc_genmcl_px_log10(u64 p);
static void mc_genmcl_px_exp(u64 p);
static void mc_genmcl_px_round(u64 p);
static void mc_genmcl_px_floor(u64 p);
static void mc_genmcl_px_ceil(u64 p);
static void mc_genmcl_px_atan2(u64 p);
static void mc_genmcl_px_fmod(u64 p);
static void mc_genmcl_px_setcc(u64 p);
static void mc_genmcl_px_min(u64 p);
static void mc_auxmcl_do_max_int(i64 cond);
static void mc_auxmcl_do_max_float(i64 opc);
static void mc_genmcl_px_max(u64 p);
static void mc_genmcl_px_power(u64 p);
static u64 mc_auxmcl_gethostfn(i64 opc);
static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs);
static void mc_genmcl_px_minto(u64 p);
static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode);
static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode);
static void mc_genmcl_px_maxto(u64 p);
static void mc_genmcl_px_negto(u64 p);
static void mc_genmcl_px_absto(u64 p);
static void mc_genmcl_px_addpxto(u64 p);
static void mc_genmcl_px_subpxto(u64 p);
static void mc_genmcl_px_divto(u64 p);
static void mc_genmcl_px_bitnotto(u64 p);
static void mc_genmcl_px_notto(u64 p);
static void mc_genmcl_px_toboolto(u64 p);
static void mc_genmcl_px_sign(u64 p);
static void mc_libmcl_clearreg(u64 ax);
static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode);
static void mc_genmcl_px_loadbf(u64 p);
static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j);
static void mc_auxmcl_do_loadbf_var(u64 p);
static void mc_genmcl_px_storebit(u64 p);
static void mc_auxmcl_do_storebit(u64 p);
static void mc_genmcl_px_storebf(u64 p);
static void mc_auxmcl_do_storebf(u64 p);
static void mc_genmcl_px_loadall(u64 p);
static void mc_stackmcl_checkallloaded();
static void mc_genmcl_px_setjmp(u64 p);
static void mc_stackmcl_freeworkregs(u64 p);
static void mc_genmcl_px_longjmp(u64 p);
static void mc_stackmcl_swapopndregs(i64 reg2);
static void mc_genmcl_px_initdswx(u64 p);
static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf);
static void mc_auxmcl_setmclentry(u64 p);
static u64 mc_libmcl_mgenname(u64 s);
static i64 mc_libmcl_roundsizetg(i64 size);
static u64 mc_auxmcl_resetmclentry();
static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size);
static void mc_auxmcl_spillparams();
static void mc_auxmcl_setmclentryf(u64 p);
static void mc_libmcl_pushstack(i64 n);
static u64 mc_auxmcl_resetmclentryf();
static void mc_libmcl_popstack(i64 n);
static i64 mc_auxmcl_ismemaddr(i64 n);
static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n);
static void mc_auxmcl_saverdx();
static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz);
static void mc_auxmcl_restorerdx();
static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype);
static void mc_auxmcl_gendb(i64 a);
static void mc_auxmcl_gendbstring(u64 s, i64 length);
static u64 mc_libmcl_mgenstring(u64 s, i64 length);
static void mc_auxmcl_gendq(i64 a);
static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs);
static u64 mc_libmcl_mgenreg0(i64 reg, i64 size);
static u64 mc_libmcl_newmclopnd();
static void mc_libmcl_initmcdest();
static u64 mc_libmcl_mgenint0(i64 x, i64 size);
static void mc_libmcl_genmc_str(i64 opcode, u64 s);
static u64 mc_libmcl_duplopnd(u64 a);
static i64 mc_libmcl_getrealindex(r64 x);
static i64 mc_libmcl_getr32index(r64 x);
static u64 mc_libmcl_mgenxregvar(u64 d);
static u64 mc_libmcl_mgenregvar(u64 d, i64 mode);
static u64 mc_libmcl_mgenregi(i64 reg, i64 mode);
static u64 mc_libmcl_mgentemp(i64 n, i64 mode);
static void mc_libmcl_merroropnd(u64 mess, i64 opndtype);
static u64 mc_libmcl_findnamesym(u64 s);
static void mc_libmcl_addnamesym(u64 d);
static i64 mc_libmcl_getprimreg(u64 ax);
static i64 mc_libmcl_addconst(u64 clist, i64 value);
static void mc_libmcl_axerror(u64 mess);
static void mc_libmcl_callproc(u64 cpname, u64 name, i64 lineno);
static u64 mc_libmcl_mgenstringx(u64 s);
static i64 mc_stackmcl_getworkreg(i64 mode);
static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg);
static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg);
static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax);
static void mc_stackmcl_savenextopnd();
static i64 mc_stackmcl_getworkxreg();
static void mc_stackmcl_saveopnd(i64 n, i64 allregs);
static void mc_stackmcl_savenextxopnd();
static i64 mc_optim_isreg0(u64 a);
static i64 mc_optim_endr0(u64 m);
static i64 mc_optim_isreg10(u64 a);
static i64 mc_optim_isreg(u64 a);
static u64 mc_optim_deletemcl(u64 p);
static i64 mc_optim_isconst(u64 a);
static i64 mc_optim_isreg00(u64 m);
static i64 mc_optim_sameoperand(u64 a, u64 b);
static i64 mc_optim_sameregopnd(u64 a, u64 b);
static void mc_genss_initlib(i64 nlabels);
static u64 mc_genss_buffercreate(i64 size);
static void mc_genss_switchseg(i64 newseg);
static void mc_genss_doinstr(u64 m, i64 index);
static i64 mc_genss_bufferlength(u64 a);
static u64 mc_genss_bufferelemptr(u64 a, i64 offset);
static void mc_genss_bufferexpand(u64 a);
static i64 mc_genss_getcurrdatalen(i64 id);
static i64 mc_genss_getstindex(u64 d);
static void mc_genss_dofwdrefs(u64 d);
static void mc_genss_do_call(u64 a);
static void mc_genss_do_jmp(u64 a, u64 m);
static u64 mc_genss_getdef(u64 a, i64 dneeded);
static i64 mc_genss_getrel32(u64 d, i64 offset);
static void mc_genss_gendword(i64 x);
static i64 mc_genss_checkshortjump(u64 m, u64 d);
static void mc_genss_genrel32(u64 a);
static void mc_genss_genrel8(u64 a);
static void mc_genss_genopnd(u64 a, i64 size);
static void mc_genss_genword(i64 x);
static void mc_genss_do_push(u64 a);
static void mc_genss_do_pop(u64 a);
static void mc_genss_do_inc(u64 a, i64 code);
static void mc_genss_do_neg(u64 a, i64 code);
static void mc_genss_do_arith(u64 a, u64 b, i64 code);
static void mc_genss_do_mov(u64 a, u64 b);
static void mc_genss_do_lea(u64 a, u64 b);
static void mc_genss_do_movsx(u64 a, u64 b, i64 opc);
static void mc_genss_do_movsxd(u64 a, u64 b);
static void mc_genss_do_exch(u64 a, u64 b);
static void mc_genss_do_imul2(u64 a, u64 b);
static void mc_genss_buffercheck(u64 a, i64 n);
static void mc_genss_do_shift(u64 a, u64 b, i64 code);
static void mc_genss_do_test(u64 a, u64 b);
static void mc_genss_do_loop(u64 a, i64 opc);
static void mc_genss_do_jcxz(u64 a, i64 opsize);
static void mc_genss_do_setcc(i64 cond, u64 b);
static void mc_genss_do_movxmm(u64 a, u64 b, i64 size);
static void mc_genss_do_arithxmm(u64 a, u64 b, i64 prefix, i64 opc);
static void mc_genss_do_logicxmm(u64 a, u64 b, i64 opc, i64 size);
static void mc_genss_do_convertfloat(u64 a, u64 b, i64 prefix);
static void mc_genss_do_fix(u64 a, u64 b, i64 prefix, i64 opc);
static void mc_genss_do_float(u64 a, u64 b, i64 prefix);
static void mc_genss_do_cmovcc(i64 cond, u64 a, u64 b);
static void mc_genss_do_fmem(u64 a, i64 freal, i64 code);
static void mc_genss_do_movdqx(u64 a, u64 b, i64 prefix);
static void mc_genss_do_popcnt(u64 a, u64 b);
static void mc_genss_do_bsf(u64 a, u64 b, i64 opc);
static void mc_genss_do_bswap(u64 a);
static void mc_genss_do_dshift(u64 a, u64 b, i64 c, i64 opc);
static void mc_genss_start();
static void mc_genss_addword(u64 a, i64 x);
static void mc_genss_adddword(u64 a, i64 x);
static void mc_genss_genqword(i64 x);
static void mc_genss_addqword(u64 a, i64 x);
static void mc_genss_genabs32(u64 a);
static void mc_genss_genabs64(u64 a);
static void mc_genss_addrelocitem(i64 reloctype, u64 d);
static void mc_genss_extendsymboltable();
static u64 mc_genss_addfwdref(u64 p, i64 offset, i64 reltype, i64 seg);
static void mc_genss_genrex();
static i64 mc_genss_isbytesized(i64 x);
static i64 mc_genss_isdwordsized(i64 x);
static void mc_genss_genamode(u64 a, u64 am);
static void mc_genss_setopsize(u64 a);
static i64 mc_genss_getdispsize(u64 a, u64 offset);
static void mc_genss_checkhighreg(u64 a);
static void mc_genss_genxrm(i64 opcode, i64 code, u64 b);
static void mc_genss_genrrm(i64 opcode, u64 a, u64 b);
static i64 mc_genss_getregcode(i64 reg, i64 mask, i64 isxreg);
static void mc_genss_checkimmrange(i64 value, i64 size);
static u64 mc_writenasm_strmclstr(u64 m);
static void mc_genss_fixrip(i64 dispsize);
static void mc_genss_checksize(u64 a, i64 size1, i64 size2);
static void mc_decls_start();
static void mc_writenasm_asmstr(u64 s);
static void mc_writenasm_writemcl(i64 index, u64 mcl);
static void mc_writenasm_start();
static void mc_writenasm_asmchar(i64 c);
static void mc_writenasm_asmopnd(u64 a, i64 sizeprefix, i64 opcode);
static u64 mc_writenasm_strreg(i64 reg, i64 size);
static u64 mc_writenasm_strxreg(i64 reg, i64 size);
static i64 mc_writenasm_needsizeprefix(i64 opcode, u64 a, u64 b);
static u64 mc_writenasm_getsizeprefix(i64 size, i64 enable);
static u64 mc_writenasm_checkregvar(i64 reg, i64 ispfloat);
static void mc_writeexe_genexe1(u64 entrypoint, u64 outfile, i64 dodll);
static void mc_writeexe_genexe2(u64 outfile, i64 dodll);
static void mc_writeexe_initsectiontable();
static void mc_writeexe_loadlibs();
static void mc_writeexe_scanst();
static void mc_writeexe_getoffsets();
static void mc_writeexe_relocdata(u64 s);
static i64 mc_writeexe_getripoffset(i64 addr, i64 dest, i64 extra);
static void mc_writeexe_writepesig();
static void mc_writeexe_writefileheader();
static void mc_writeexe_writeoptheader();
static void mc_writeexe_writesectionheader(u64 s);
static void mc_writeexe_writepadding(i64 offset);
static void mc_writeexe_writesectiondata(u64 s);
static u64 mc_writeexe_extractlibname(u64 name, u64 libno, i64 moduleno);
static void mc_writeexe_getbaserelocs(u64 s);
static void mc_writeexe_newbasereloc(i64 addr, i64 reltype);
static void mc_writeexe_writerecordx(u64 r, i64 length);
static void mc_writeexe_writeexporttable(u64 pstart);
static void mc_writeexe_sortexports(u64 sortindex);
static i64 mc_writeexe_getsectionno(i64 segment);
static i64 mc_writeexe_getexporttablesize();
static void mc_writeexe_scanbaserelocs();
static void mc_writeexe_writebasereloctable(u64 pstart);
static void mc_writeobj_initsymboltable(u64 filename);
static void mc_writeobj_convertsymboltable();
static void mc_writeobj_writerecord(u64 r, i64 length);
static void mc_writeobj_writedata(u64 data);
static void mc_writeobj_writesymboltable();
static void mc_writeobj_writestringtable();
static i64 mc_writeobj_addstringentry(u64 s, i64 length);
static void mc_writeobj_addsymbol(u64 r);
static u64 mx_run_writememlib(u64 filename);
static void mx_run_roundsegment(u64 p, i64 align, i64 value);
static void mx_run_countsymbols();
static void mx_run_writerelocs(u64 lib);
static void mx_run_addsymbols(u64 lib);
static void mx_lib_loadmemmcu(u64 lib);
static void mx_lib_fixuplib(u64 lib);
static void mx_lib_runprogram(u64 lib, i64 cmdskip);
static u64 mx_lib_readlibfile(u64 filespec, u64 p);
static u64 mx_lib_readu32(u64 p);
static i64 mx_lib_readbyte(u64 p);
static u64 mx_lib_readstring(u64 p);
static void mx_lib_alloclibdata(u64 lib);
static void mx_lib_error(u64 mess, u64 param);
static void mx_lib_checknew(u64 name, u64 filename);
static i64 mx_lib_mxaddlib(u64 name);
static void mx_lib_loadimports(u64 plib);
static i64 mx_lib_findlib(u64 name);
static void mx_lib_loaddlls();
static void mx_lib_checksymbols();
static void mx_lib_dorelocations();
static u64 mx_lib_finddllsymbol(u64 name, u64 dllindex);
static void mx_lib_reloclib(u64 lib);
static void mx_lib_dosublib(u64 name);
static void mx_lib_dosymbols(u64 lib);
static u64 mx_lib_loadlibfile(u64 filename, i64 libno);
static u64 mx_lib_readmxfile(u64 filename);
static void mx_lib_adddll(u64 name);
static i64 mx_lib_addsymbol(u64 name);
static void mx_lib_setspecialglobals(i64 cmdskip);
static void mx_lib_calllibinit(u64 lib);
static u64 mx_lib_findsymbol(u64 name);
static u64 mx_lib_loadmx(u64 filename);
static u64 mx_lib_loadmemmcb(u64 filename, u64 p);
static void mx_write_roundsegment(u64 p, i64 align, i64 value);
static void mx_write_genu32(i64 x);
static void mx_write_genbyte(i64 x);
static void mx_write_genstring(u64 s);
static void mx_write_writerelocs();
static void mx_write_genblock(u64 p, i64 length);
static void mx_write_writesymbols();
void mm_main();
static void pcl_start();
static void mm_start();
static void mm_cli_main2();
static void mm_cli_initdata();
static void mm_cli_getinputoptions();
static void mm_cli_production_compiler();
static void mm_cli_debug_compiler();
static void mm_modules_loadproject(u64 file);
static void mm_cli_do_parse(i64 flog);
static void mm_cli_do_name(i64 flog);
static void mm_cli_do_type(i64 flog);
static void mm_cli_do_genpcl(i64 flog);
static void mm_cli_do_genmcl(i64 flog);
static void mm_diags_showtimings();
static void mm_diags_showlogfile();
static void mm_cli_showcompilemess();
static void mm_support_do_writema(u64 inpfile);
static void mm_support_do_getinfo(u64 filename);
static void mm_cli_do_writeexports();
static i64 mm_parse_parsemodule(u64 pm);
static void mm_name_fixusertypes();
static void mm_cli_fixstartprocs();
static void mm_diags_showast(u64 filename);
static void mm_name_rx_typetable();
static i64 mm_name_rx_module(i64 n);
static void mm_type_tx_typetable();
static i64 mm_type_tx_module(i64 n);
static void mm_type_tx_allprocs();
static void mm_genpcl_codegen_il(u64 dummy);
static void mm_lex_lexsetup();
static void mm_support_init_tt_tables();
static void mm_support_initbblib();
static u64 mm_lex_addnamestr(u64 name);
static u64 mm_lib_createdupldef(u64 owner, u64 symptr, i64 id);
static i64 mm_support_mgetsourceinfo(i64 pos, u64 filename, u64 sourceline);
static void mm_assemaux_domcl_assem(u64 pcode);
static u64 mm_genpcl_findhostfn(i64 opc);
static i64 mm_assemaux_checkasmlabel(u64 p);
static void mm_support_loaderror(u64 mess, u64 mess2, u64 mess3);
static void mm_cli_showcaption();
static void mm_cli_showhelp();
static void mm_export_dummy_writeexports(u64 basefile, u64 modulename);
static u64 mm_cli_getoutfilename(u64 file, u64 ext);
static u64 mm_cli_addstartproc(u64 owner, u64 name, i64 scope, i64 moduleno);
static u64 mm_lib_getduplnameptr(u64 owner, u64 symptr, i64 id);
static u64 mm_parse_makeblock(u64 p);
static void mm_lib_adddef(u64 owner, u64 p);
static void mm_lib_addtoproclist(u64 d);
static void mm_genpcl_dolibs();
static void mm_genpcl_dostaticvar(u64 d);
static void mm_genpcl_gendllproc(u64 p);
static void mm_genpcl_genprocdef(u64 p);
static void mm_genpcl_scanprocs();
static void mm_genpcl_genmaindef(u64 p);
static void mm_genpcl_genstartdef(u64 p);
static void mm_genpcl_doprocdef(u64 d, i64 ismain);
static i64 mm_genpcl_createfwdlabel();
static void mm_blockpcl_evalunit(u64 p);
static void mm_genpcl_definefwdlabel(i64 lab);
static void mm_genpcl_genreturn();
static u64 mm_libpcl_getpsymbol(u64 d);
static u64 mm_genpcl_genmem_d(u64 d);
static void mm_libpcl_setmode(i64 mode);
static i64 mm_lib_getalignment(i64 m);
static void mm_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset);
static void mm_support_gerror(u64 mess, u64 p);
static i64 mm_lib_getpclmode(i64 t);
static void mm_libpcl_setmode_u(u64 p);
static u64 mm_genpcl_genmemaddr_d(u64 d);
static void mm_support_gerror_s(u64 mess, u64 s, u64 p);
static u64 mm_genpcl_genmem_u(u64 p);
static void mm_genpcl_genpushmem_d(u64 d);
static void mm_genpcl_genpushmemaddr_d(u64 d);
static i64 mm_genpcl_definelabel();
static i64 mm_genpcl_reversecond(i64 cc);
static i64 mm_genpcl_reversecond_order(i64 cc);
static void mm_genpcl_stacklooplabels(i64 a, i64 b, i64 c);
static i64 mm_genpcl_findlooplabel(i64 k, i64 n);
static void mm_genpcl_genpc_sysfn(i64 fnindex, u64 a, u64 b, u64 c);
static void mm_genpcl_genpc_sysproc(i64 fnindex, u64 a, u64 b, u64 c, i64 asfunc);
static void mm_genpcl_pushsysarg(u64 p, i64 n, u64 nargs);
static u64 mm_genpcl_getsysfnhandler(i64 fn);
static void mm_genpcl_start();
static void mm_genpcl_genpushint(i64 a);
static void mm_genpcl_genpushreal(r64 x, i64 mode);
static void mm_genpcl_genpushstring(u64 s);
static void mm_genpcl_docallproc(u64 d);
static void mm_genpcl_initstaticvar(u64 d);
static void mm_genpcl_setfunctab();
static u64 mm_libpcl_getequivdef(u64 d);
static void mm_libpcl_setmode2(i64 mode);
static void mm_blockpcl_do_const(u64 p);
static void mm_blockpcl_do_name(u64 p);
static void mm_blockpcl_do_block(u64 p);
static void mm_blockpcl_do_callproc(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_return(u64 p, u64 a);
static void mm_blockpcl_do_returnmult(u64 p, u64 a);
static void mm_blockpcl_do_assign(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_assignms(u64 a, u64 b);
static void mm_blockpcl_do_assignmm(u64 a, u64 b);
static void mm_blockpcl_do_assignmdrem(u64 a, u64 b);
static void mm_blockpcl_do_to(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 isref);
static void mm_blockpcl_do_for(u64 p, u64 pindex, u64 pfrom, u64 pbody, i64 down);
static void mm_blockpcl_do_forall(u64 p, u64 pindex, u64 plist, u64 pbody, i64 down);
static void mm_blockpcl_do_while(u64 p, u64 pcond, u64 pbody, u64 pincr);
static void mm_blockpcl_do_repeat(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_goto(u64 a);
static void mm_blockpcl_do_labeldef(u64 p);
static void mm_blockpcl_do_exit(u64 p, i64 k);
static void mm_blockpcl_do_do(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_case(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 loopsw, i64 isref);
static void mm_blockpcl_do_switch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 isref);
static void mm_blockpcl_do_recase(u64 p, u64 a);
static void mm_blockpcl_do_swap(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_select(u64 p, u64 a, u64 b, u64 c, i64 isref);
static void mm_blockpcl_do_print(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_read(u64 p, u64 a);
static void mm_blockpcl_do_readln(u64 a);
static void mm_blockpcl_do_stop(u64 p, u64 a);
static void mm_blockpcl_do_andl(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_orl(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_setcc(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_setccchain(u64 p, u64 q);
static void mm_blockpcl_do_bin(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_index(u64 p, u64 parray, u64 pindex);
static void mm_blockpcl_do_dotindex(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_dotslice(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_dot(u64 pdot);
static void mm_blockpcl_do_ptr(u64 p, u64 a);
static void mm_blockpcl_evalref(u64 p, u64 q);
static void mm_blockpcl_do_convert(u64 p, u64 a);
static void mm_blockpcl_do_typepun(u64 p, u64 a);
static void mm_blockpcl_do_shorten(u64 p, u64 a);
static void mm_blockpcl_do_typeconst(u64 p);
static void mm_blockpcl_do_unary(u64 p, u64 a);
static void mm_blockpcl_do_notl(u64 p, u64 a);
static void mm_blockpcl_do_istruel(u64 p, u64 a);
static void mm_blockpcl_do_isfalsel(u64 p, u64 a);
static void mm_blockpcl_do_incr(u64 p, u64 a);
static void mm_blockpcl_do_incrload(u64 p, u64 a);
static void mm_blockpcl_do_binto(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_unaryto(u64 p, u64 a);
static void mm_blockpcl_do_syscall(u64 p, u64 a);
static void mm_blockpcl_do_empty(u64 p, u64 a);
static void mm_blockpcl_do_slice(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_indexref(u64 parray, u64 pindex);
static void mm_blockpcl_do_dotref(u64 pdot);
static void mm_blockpcl_evalarray(u64 p);
static void mm_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab);
static void mm_blockpcl_gcomparejump(i64 jumpopc, i64 cond, u64 lhs, u64 rhs, i64 lab);
static void mm_blockpcl_genjumpl(i64 lab);
static void mm_blockpcl_unimpl(u64 mess);
static void mm_blockpcl_do_assignblock(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_storeindex(u64 p, u64 parray, u64 pindex, u64 rhs);
static void mm_blockpcl_do_storedot(u64 pdot, u64 pfield, u64 rhs);
static void mm_blockpcl_do_setinplace();
static void mm_blockpcl_docond(i64 opc, u64 p, i64 lab);
static void mm_blockpcl_setincrstep(i64 m);
static u64 mm_lib_getavname(u64 owner, i64 id);
static u64 mm_lib_createname(u64 p);
static i64 mm_blockpcl_checkdotchain(u64 p, u64 pname);
static i64 mm_lib_createrefmode(u64 owner, i64 target, i64 typedefx);
static i64 mm_blockpcl_getindexoffset(u64 parray, u64 pindex);
static u64 mm_lib_strexpr(u64 p);
static void mm_blockpcl_do_assignarray(u64 a, u64 b);
static void mm_blockpcl_do_assignrecord(u64 a, u64 b);
static u64 mm_lib_createconstunit(u64 a, i64 t);
static u64 mm_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 mm_lib_createunit0(i64 tag);
static void mm_blockpcl_pushrhs(u64 a);
static void mm_blockpcl_poptomult(u64 a);
static u64 mm_lib_getprocretmodes(u64 p);
static u64 mm_assem_readassemline();
static void mm_lex_lex();
static u64 mm_assem_assembleline(i64 oneline);
static u64 mm_assem_readassemblock();
static void mm_support_serror(u64 mess);
static void mm_parse_checkend(i64 endsym, i64 endkwd1, i64 endkwd2, i64 startline);
static void mm_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static void mm_parse_lexchecksymbol(i64 symbol);
static u64 mm_parse_readunit();
static void mm_lex_ps(u64 caption);
static u64 mm_assem_readassemopnd();
static void mm_parse_checksymbol(i64 symbol);
static u64 mm_lib_createunit1(i64 tag, u64 p);
static void mm_lex_addreservedword(u64 name, i64 symbol, i64 subcode, i64 regsize);
static u64 mm_assemaux_genasmopnd(u64 p);
static i64 mm_assemaux_fixasmlabel(u64 d);
static void mm_diags_printst(u64 f, u64 p, i64 level);
static void mm_diags_printstrec(u64 f, u64 p, i64 level);
static void mm_diags_printstflat(u64 f);
static void mm_diags_printcode(u64 f, u64 caption);
static i64 mm_support_getlineno(u64 pos);
static u64 mm_lib_typename(i64 m);
static void mm_diags_printunitlist(u64 dev, u64 p, i64 level, u64 prefix);
static void mm_lib_addtolog(u64 filename, u64 logdest);
static void mm_diags_showsttree(u64 caption, u64 f);
static void mm_diags_showstflat(u64 caption, u64 f);
static void mm_diags_printsymbol(u64 lp);
static void mm_lex_printstrn(u64 s, i64 length);
static void mm_diags_showtime(u64 caption, i64 t);
static void mm_lex_lexreadtoken();
static void mm_lex_doinclude();
static void mm_support_lxerror(u64 mess);
static i64 mm_lex_setinttype(u64 a);
static void mm_lex_readrawstring();
static void mm_lex_readarraystring(i64 prefix);
static void mm_lex_lookup(u64 name, i64 length, i64 hashindex);
static void mm_lex_readhex();
static void mm_lex_readbin();
static void mm_lex_readdec();
static void mm_lex_lxreadstring(i64 termchar);
static void mm_lex_readrawxname();
static void mm_lex_unstacksource();
static void mm_lex_inithashtable();
static i64 mm_lex_lookupsys(u64 name);
static i64 mm_lex_gethashvaluez(u64 s);
static void mm_lex_printhashtable();
static u64 mm_support_getsupportfile(u64 filename, u64 ext, u64 path);
static void mm_lex_stacksource(i64 fileno, i64 isimport);
static void mm_lex_startlex(u64 file);
static void mm_lex_psnext(u64 caption);
static void mm_lex_psx(u64 caption);
static void mm_lex_lxerror_s(u64 mess, u64 s);
static i64 mm_lex_readhexcode(u64 s, i64 n, i64 sp);
static i64 mm_lex_getutf8(i64 c, u64 s);
static void mm_lex_readreal();
static void mm_lex_nodecimal();
static void mm_lex_start();
static u64 mm_lib_newstrec();
static u64 mm_lib_allocunitrec();
static u64 mm_lib_createunit3(i64 tag, u64 p, u64 q, u64 r);
static void mm_lib_insertunit(u64 p, i64 tag);
static void mm_lib_deleteunit(u64 p, u64 q);
static u64 mm_lib_createstringconstunit(u64 s, i64 length);
static i64 mm_lib_newtypename(u64 a, u64 b);
static i64 mm_lib_createusertype(u64 stname);
static i64 mm_lib_createusertypefromstr(u64 name);
static u64 mm_lib_getrangelwbunit(u64 p);
static u64 mm_lib_getrangeupbunit(u64 p);
static i64 mm_lib_createarraymode(u64 owner, i64 target, u64 dimexpr, i64 typedefx);
static i64 mm_lib_storemode(u64 owner, i64 m, u64 pmode);
static i64 mm_lib_sameunit(u64 p, u64 q, u64 powner, u64 qowner);
static i64 mm_lib_createarraymodek(u64 owner, i64 target, i64 lower, i64 length, i64 typedefx);
static i64 mm_lib_createslicemode(u64 owner, i64 slicetype, i64 target, u64 dimexpr, i64 typedefx);
static i64 mm_lib_createslicemodek(u64 owner, i64 target, i64 lower, i64 typedefx);
static i64 mm_lib_createrefprocmode(u64 owner, u64 stproc, u64 paramlist, i64 kwd, i64 prettype, i64 typedefx);
static void mm_lib_copyttvalues(i64 dest, i64 source);
static void mm_lib_unionstr_clear(u64 u);
static void mm_lib_unionstr_append(u64 u, i64 c);
static void mm_lib_unionstr_concat(u64 u, u64 v);
static i64 mm_lib_unionstr_last(u64 u);
static void mm_lib_unionstr_copy(u64 u, u64 v);
static i64 mm_lib_createrecordmode(u64 owner, i64 typedefx);
static i64 mm_lib_createtuplemode(u64 owner, u64 elements, i64 elementslen, i64 typedefx);
static void mm_lib_jevalx2(u64 dest, u64 p);
static void mm_lib_jevalx(u64 p);
static void mm_lib_jadditem(u64 s);
static void mm_lib_jaddstr(u64 s);
static void mm_support_gs_additem(u64 dest, u64 s);
static void mm_lib_istrmode(i64 m, i64 expand, u64 dest);
static void mm_support_gs_copytostr(u64 source, u64 s);
static void mm_support_mcerror(u64 mess);
static void mm_lib_addstatic(u64 d);
static void mm_lib_addexpconst(u64 d);
static u64 mm_lib_createnewmoduledef(u64 owner, u64 symptr, i64 id);
static u64 mm_lib_duplunit(u64 p, i64 lineno);
static i64 mm_lib_isconstunit(u64 a);
static void mm_lib_getownername(u64 d, u64 dest);
static i64 mm_lib_gettypebase(i64 m);
static void mm_lib_writegsfile(u64 filename, u64 d);
static void mm_support_txerror(u64 mess, u64 p);
static void mm_libsources_loadbuiltins();
static u64 mm_support_newsourcefile();
static u64 mm_modules_loadsp(u64 filename, i64 mainsub);
static u64 mm_modules_loadmodule(u64 filespec, i64 issyslib);
static void mm_parse_skipsemi();
static void mm_modules_addlib(u64 libname);
static void mm_support_serror_s(u64 mess, u64 a);
static u64 mm_modules_loadsourcefile(u64 filespec, i64 issyslib);
static void mm_modules_loadsyslib();
static void mm_modules_loadmafile(u64 filespec, u64 builtinstr);
static u64 mm_modules_readfileline(u64 s);
static u64 mm_modules_findnextlineheader(u64 s);
static void mm_name_do_baseclass(u64 p);
static void mm_name_rx_unit(u64 owner, u64 p);
static void mm_name_resolvename(u64 owner, u64 p);
static void mm_name_expandmacro(u64 p, u64 a, u64 b);
static void mm_name_resolvedot(u64 owner, u64 p);
static void mm_name_rx_unitlist(u64 owner, u64 p);
static void mm_name_rx_passdef(u64 owner, u64 p);
static void mm_name_rx_deflist(u64 owner, u64 p);
static u64 mm_name_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod);
static void mm_support_rxerror_s(u64 mess, u64 a, u64 p);
static u64 mm_name_addframevar(u64 owner, u64 d, i64 moduleno, i64 mode);
static u64 mm_name_finddupl(u64 d, u64 pdupl);
static u64 mm_name_finddupl_sub(u64 d, u64 pdupl);
static void mm_support_rxerror(u64 mess, u64 p);
static void mm_name_fixmode(u64 p);
static u64 mm_name_copylistunit(u64 p);
static u64 mm_name_copyunit(u64 p);
static void mm_name_replaceunit(u64 p, u64 q);
static void mm_name_duplfield(u64 owner, u64 p, u64 q);
static void mm_parse_initparser();
static void mm_parse_readmoduledefs(u64 owner);
static void mm_parse_readprocdef(u64 procowner, i64 scope);
static u64 mm_parse_readvardef(u64 owner, i64 scope, i64 isstatic, i64 varid, i64 k);
static void mm_parse_readimportmodule(u64 owner);
static void mm_parse_readtypedef(u64 owner, i64 scope);
static void mm_parse_readconstdef(u64 owner, i64 scope);
static void mm_parse_readclassdef(u64 owner, i64 scope);
static void mm_parse_readtabledef(u64 owner, i64 scope);
static void mm_parse_readmacrodef(u64 owner, i64 scope);
static i64 mm_parse_istypestarter();
static void mm_parse_checkequals();
static i64 mm_parse_getcurrline();
static i64 mm_parse_checkbegin(i64 fbrack);
static void mm_parse_checkbeginend(i64 closesym, i64 kwd, i64 startline);
static void mm_parse_checksymbollex(i64 symbol);
static i64 mm_parse_readtypespec(u64 owner, i64 typedefx);
static u64 mm_parse_readconstexpr(i64 needconst);
static u64 mm_parse_readlbrack();
static u64 mm_parse_readsunit(i64 inwhile);
static u64 mm_parse_fixcond(u64 p);
static void mm_parse_addlistparam(u64 ulist, u64 ulistx, u64 p);
static u64 mm_parse_readcast();
static u64 mm_parse_readopc();
static u64 mm_parse_readterm2();
static u64 mm_parse_readcastx();
static i64 mm_parse_readrefproc(u64 owner, i64 typedefx);
static i64 mm_parse_readslicetype(u64 owner, i64 slicetype, i64 typedefx);
static u64 mm_parse_readslist(i64 iscall, i64 donulls);
static u64 mm_parse_readindex(u64 p, i64 dot);
static u64 mm_parse_readdotsuffix(u64 p);
static i64 mm_parse_readconstint();
static u64 mm_parse_readprocdecl(u64 procowner, i64 scope);
static void mm_parse_pushproc(u64 p);
static void mm_parse_popproc();
static u64 mm_parse_readparams(u64 procowner, u64 owner, u64 varparams, u64 nparams);
static i64 mm_parse_readreturntype(u64 owner, u64 retmodes);
static u64 mm_parse_readcondsuffix(u64 p);
static u64 mm_parse_readif();
static u64 mm_parse_readswitchcase();
static u64 mm_parse_readgoto(i64 gototag);
static u64 mm_parse_readunless();
static u64 mm_parse_readstop();
static u64 mm_parse_readreturn();
static u64 mm_parse_readdo();
static u64 mm_parse_readto();
static u64 mm_parse_readwhile();
static u64 mm_parse_readrepeat();
static u64 mm_parse_readloopcontrol();
static u64 mm_parse_readprint();
static u64 mm_parse_readread();
static u64 mm_parse_readfor();
static u64 mm_parse_readname();
static void mm_parse_readrecordfields(u64 owner, i64 m);
static u64 mm_parse_readequivfield(u64 owner);
static void mm_parse_readclassbody(u64 owner, i64 classkwd);
static void mm_parse_readimportbody(u64 owner);
static u64 mm_parse_readset();
static u64 mm_parse_readassignment(u64 pt);
static u64 mm_parse_readorterms(u64 pt);
static u64 mm_parse_readandterms(u64 pt);
static u64 mm_parse_readcmpterms(u64 pt);
static u64 mm_parse_readinterms(u64 pt);
static u64 mm_parse_readrangeterm(u64 pt);
static u64 mm_parse_readaddterms(u64 pt);
static u64 mm_parse_readmulterms(u64 pt);
static u64 mm_parse_readpowerterms(u64 p);
static u64 mm_parse_readterm();
static u64 mm_parse_readrecase();
static void mm_parse_checknotempty(u64 p);
static u64 mm_parse_readbxdata();
static void mm_support_serror_gen(u64 mess);
static void mm_support_showdivider(u64 ch);
static void mm_support_showerrorsource(i64 pos, u64 stproc);
static void mm_support_stopcompiler(u64 filename, i64 lineno);
static i64 mm_support_getfileno(u64 pos);
static u64 mm_support_getsourceline(u64 pos);
static u64 mm_support_getsourcepos(u64 pos);
static void mm_support_error_gen(i64 pass, u64 mess, u64 p);
static void mm_support_txerror_s(u64 mess, u64 a, u64 p);
static void mm_support_txerror_ss(u64 mess, u64 a, u64 b);
static void mm_support_lxerror_gen(u64 mess);
static i64 mm_support_isalphanum(i64 c);
static i64 mm_support_isabspath(u64 filespec);
static u64 mm_support_getsourcestart(u64 pos);
static void mm_support_getst(u64 f, u64 d);
static void mm_support_getstrec(u64 f, u64 d);
static void mm_tables_start();
static void mm_type_tx_name(u64 p, i64 t, i64 lv);
static void mm_type_tx_bin(u64 p, u64 a, u64 b);
static i64 mm_type_tx_in(u64 p, u64 a, u64 b);
static void mm_type_tx_unary(u64 p, u64 a);
static void mm_type_tx_prop(u64 p, u64 a);
static void mm_type_tx_binto(u64 p, u64 a, u64 b);
static void mm_type_tx_unaryto(u64 p, u64 a);
static void mm_type_tpasslv(u64 p, i64 t);
static void mm_type_tx_addroffirst(u64 p, u64 a, i64 t);
static void mm_type_tx_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 t, i64 lv);
static void mm_type_tx_index(u64 p, u64 a, u64 b, i64 t, i64 lv);
static void mm_type_tx_ptr(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_callproc(u64 p, u64 a, u64 pargs, i64 t);
static void mm_type_tx_dot(u64 p, u64 a, u64 b, i64 lv);
static void mm_type_tx_andl(u64 p, u64 a, u64 b);
static void mm_type_tx_notl(u64 p, u64 a);
static void mm_type_tx_convert(u64 p, u64 a, i64 hard);
static void mm_type_tx_typepun(u64 p, u64 a);
static void mm_type_tx_incrto(u64 p, u64 a, i64 t);
static void mm_type_tx_makerange(u64 p, u64 a, u64 b);
static void mm_type_tx_swap(u64 p, u64 a, u64 b);
static void mm_type_tx_select(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_switch(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_case(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_dotindex(u64 p, u64 a, u64 b, i64 lv);
static void mm_type_tx_slice(u64 p, u64 a, u64 b);
static void mm_type_tx_block(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_return(u64 p, u64 a, i64 t);
static void mm_type_tx_unitlist(u64 p, i64 t, i64 lv);
static void mm_type_fixchararray(u64 a);
static void mm_type_tx_for(u64 pindex, u64 pfrom, u64 pbody);
static void mm_type_tx_forall(u64 pindex, u64 plist, u64 pbody);
static void mm_type_coerceunit(u64 p, i64 t, i64 hard);
static void mm_type_tx_makelist(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_exit(u64 p, u64 a);
static void mm_type_tx_goto(u64 p, u64 a);
static i64 mm_type_iscondtrue(u64 p);
static i64 mm_type_iscondfalse(u64 p);
static void mm_type_tx_bitfield(u64 p, u64 a, i64 lv);
static void mm_type_tx_cmpchain(u64 p, u64 a);
static void mm_type_tx_strinclude(u64 p, u64 a);
static void mm_type_tx_makeslice(u64 p, u64 a, u64 b, i64 t);
static void mm_type_tx_makeset(u64 p, u64 a, i64 t);
static void mm_type_tevaluate(u64 p);
static void mm_type_tx_passdef(u64 p);
static void mm_type_setmodesize(i64 m);
static void mm_type_setarraysize(i64 m);
static void mm_type_setslicesize(i64 m);
static i64 mm_type_getconstint(u64 q);
static void mm_type_checkblocktype(i64 m);
static void mm_type_tx_namedconst(u64 d);
static void mm_type_tx_namedef(u64 d);
static void mm_type_checkconstexpr(u64 p);
static void mm_type_makenewconst(u64 p, i64 x, i64 t);
static void mm_type_twiden(u64 p, i64 lv);
static i64 mm_type_dobinnumx(u64 p, u64 a, u64 b);
static void mm_type_combinestrings(u64 p);
static i64 mm_type_comparemodes(i64 s, i64 t);
static void mm_type_mulstrings(u64 p);
static i64 mm_type_dobinnumf(u64 p, u64 a, u64 b);
static i64 mm_type_dobinnumi(u64 p, u64 a, u64 b);
static i64 mm_type_getdominantmode(i64 amode, i64 bmode);
static void mm_type_tmethodcall(u64 p, u64 pdot, u64 pargs);
static void mm_type_do_bounds(u64 p, u64 a);
static void mm_type_deref(u64 a, i64 needres);
static void mm_type_scanrecord(i64 state, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign);
static i64 mm_type_roundoffset(i64 offset, i64 alignment);
static void mm_type_tx_makeslicefromlist(u64 p, u64 a, i64 t);
static u64 mm_type_resolvefield(u64 d, i64 m);
static void mm_type_convintconst(u64 p, i64 x);
static void mm_type_tx_sliceptr(u64 p, u64 a);
static void mm_type_tstringslice(u64 p, i64 slicemode);
static void mm_type_addnotl(u64 p);
static void mm_type_tevalbinop(u64 p);
static void mm_type_tevalmonop(u64 p);
static u64 mm_type_addrdotindex(u64 p, u64 offset);
static void mm_type_applyconversion(u64 p, i64 s, i64 t, i64 opc);
static i64 mm_type_tevalconvert(u64 p, i64 s, i64 t, i64 opc);
static void mm_type_checkmodes(i64 s, i64 t);
static void mm_type_tx_assignmultmult(u64 pp, u64 a, u64 b);
static void mm_type_tx_assignmultscalar(u64 pp, u64 a, u64 b, i64 t);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    mm_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u64 mwindows_hconsole;
static u64 mwindows_hconsolein;
static struct $B17 mwindows_lastkey;
static struct $B17 mwindows_pendkey;
static i64 mwindows_keypending;
static i64 mwindows_hpfreq;
static u64 mwindows_wndproc_callbackfn = 0;

static i64 mwindows_init_flag = 0;

static u8 mwindows_os_gxregisterclass_registered;
// Istatic skipped:mwindows.mainwndproc.count

static struct $B15 mwindows_os_gethostname_name;
static i64 mwindows_os_gethostname_n;
static i64 mwindows_os_peek_lastticks;
static u8 pcl_pc_userunpcl = 0;

static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc = 65536;

static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B18 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest = (u64)&pc_decls_sbuffer;

static struct $B19 pc_decls_plibfiles;
static struct $B19 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype = 16705;

static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole = 1;

static u8 pc_decls_fregoptim = 1;

static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B20 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest = (u64)&pc_diags_sbuffer;

static i64 pc_diags_destlinestart;
static struct $B21 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static i64 pc_run_dotrace = 0;

static i64 pc_run_dostep = 1;

static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B22 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B23 pc_tables_pstdnames = {{
(u64)"void",
(u64)"r32",
(u64)"r64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"mem",
(u64)"vec",
(u64)"$last"}};

static struct $B24 pc_tables_psize = {{
1024,
264,
1026,
264,
1026,
8,
0}};

static struct $B24 pc_tables_psigned = {{
0,
0,
0,
256,
257,
1,
0}};

static struct $B24 pc_tables_pint = {{
0,
256,
257,
257,
257,
1,
0}};

static struct $B24 pc_tables_pfloat = {{
256,
1,
0,
0,
0,
0,
0}};

static struct $B24 pc_tables_pmin = {{
256,
1282,
1285,
2310,
2313,
2826,
12}};

static struct $B24 pc_tables_piwrb = {{
256,
1538,
1542,
2566,
2570,
10,
0}};

static struct $B23 pc_tables_opndnames = {{
(u64)"no_opnd",
(u64)"mem_opnd",
(u64)"memaddr_opnd",
(u64)"label_opnd",
(u64)"int_opnd",
(u64)"real_opnd",
(u64)"r32_opnd",
(u64)"string_opnd",
(u64)"strimm_opnd",
(u64)"assem_opnd",
(u64)"realimm_opnd",
(u64)"realimm32_opnd",
(u64)"data_opnd",
(u64)"any_opnd"}};

static struct $B20 pc_tables_pclnames = {{
(u64)"nop",
(u64)"load",
(u64)"iload",
(u64)"iloadx",
(u64)"store",
(u64)"istore",
(u64)"istorex",
(u64)"storem",
(u64)"dupl",
(u64)"double",
(u64)"swapstk",
(u64)"unload",
(u64)"opnd",
(u64)"type",
(u64)"loadbit",
(u64)"loadbf",
(u64)"storebit",
(u64)"storebf",
(u64)"callp",
(u64)"icallp",
(u64)"retproc",
(u64)"callf",
(u64)"icallf",
(u64)"retfn",
(u64)"jump",
(u64)"ijump",
(u64)"jumpcc",
(u64)"jumpt",
(u64)"jumpf",
(u64)"jumpret",
(u64)"jumpretm",
(u64)"setcc",
(u64)"stop",
(u64)"to",
(u64)"forup",
(u64)"fordown",
(u64)"iswap",
(u64)"switch",
(u64)"switchu",
(u64)"swlabel",
(u64)"endsw",
(u64)"clear",
(u64)"assem",
(u64)"add",
(u64)"sub",
(u64)"mul",
(u64)"div",
(u64)"idiv",
(u64)"irem",
(u64)"idivrem",
(u64)"bitand",
(u64)"bitor",
(u64)"bitxor",
(u64)"shl",
(u64)"shr",
(u64)"min",
(u64)"max",
(u64)"addpx",
(u64)"subpx",
(u64)"subp",
(u64)"neg",
(u64)"abs",
(u64)"bitnot",
(u64)"not",
(u64)"toboolt",
(u64)"toboolf",
(u64)"sqr",
(u64)"sqrt",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"sign",
(u64)"atan2",
(u64)"power",
(u64)"fmod",
(u64)"incrto",
(u64)"decrto",
(u64)"incrload",
(u64)"decrload",
(u64)"loadincr",
(u64)"loaddecr",
(u64)"addto",
(u64)"subto",
(u64)"multo",
(u64)"divto",
(u64)"idivto",
(u64)"iremto",
(u64)"bitandto",
(u64)"bitorto",
(u64)"bitxorto",
(u64)"shlto",
(u64)"shrto",
(u64)"minto",
(u64)"maxto",
(u64)"addpxto",
(u64)"subpxto",
(u64)"negto",
(u64)"absto",
(u64)"bitnotto",
(u64)"notto",
(u64)"toboolto",
(u64)"typepun",
(u64)"float",
(u64)"fix",
(u64)"truncate",
(u64)"widen",
(u64)"fwiden",
(u64)"fnarrow",
(u64)"startmx",
(u64)"resetmx",
(u64)"endmx",
(u64)"proc",
(u64)"tcproc",
(u64)"endproc",
(u64)"istatic",
(u64)"zstatic",
(u64)"data",
(u64)"initdswx",
(u64)"label",
(u64)"labeldef",
(u64)"setjmp",
(u64)"longjmp",
(u64)"setcall",
(u64)"setarg",
(u64)"loadall",
(u64)"eval",
(u64)"comment",
(u64)"endprog",
(u64)"param",
(u64)"local",
(u64)"rettype",
(u64)"variadic",
(u64)"addlib",
(u64)"extproc"}};

static struct $B25 pc_tables_pclhastype = {{
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
2,
2,
2,
2,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0}};

static struct $B25 pc_tables_pclextra = {{
0,
1,
0,
2,
0,
0,
2,
0,
0,
0,
2,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
2,
2,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B25 pc_tables_pclhasopnd = {{
0,
13,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
13,
0,
0,
0,
0,
0,
2,
0,
0,
2,
0,
0,
3,
0,
3,
3,
3,
3,
3,
0,
0,
3,
3,
3,
0,
3,
3,
3,
0,
0,
13,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
1,
1,
13,
0,
3,
2,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
7,
1}};

static struct $B25 pc_tables_pclargs = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
9,
9,
0,
9,
9,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B26 pc_tables_ccnames = {{
(u64)"xx",
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B1 pc_tables_idnames = {{
(u64)"--",
(u64)"Import",
(u64)"Proc",
(u64)"Static",
(u64)"Local",
(u64)"Param",
(u64)"Label",
(u64)"Export",
(u64)"Misc",
(u64)"Program"}};

static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B20 mc_genmcl_px_handlertable;
static struct $B27 mc_genmcl_scondcodes = {{
1284,
3596,
3853}};

static struct $B27 mc_genmcl_ucondcodes = {{
1284,
1538,
1795}};

// Istatic skipped:mc_genmcl.inithandlers.initdone

// Istatic skipped:mc_genmcl.inithandlers.dupltable

static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B29 mc_libmcl_smallinttable;
static struct $B30 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B30 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B21 mc_stackmcl_stropndstack_str;
static u8 mc_genss_rex;
static u8 mc_genss_sizeoverride;
static u8 mc_genss_addroverride;
static u8 mc_genss_f2override;
static u8 mc_genss_f3override;
static u8 mc_genss_nowmask;
static u8 mc_genss_usesizeb;
static u64 mc_genss_extraparam;
static i64 mc_genss_currseg = 0;

static u64 mc_genss_currdata;
static u64 mc_genss_currrelocs;
static i64 mc_genss_nrelocs;
static struct $B3 mc_genss_ishighreg;
static u64 mc_genss_currmcl;
static u64 mc_genss_ripentry;
// Istatic skipped:mc_genss.genrm.scaletable

static struct $B11 mc_decls_valtypenames = {{
(u64)"no_val",
(u64)"intimm_val",
(u64)"realimm_val",
(u64)"realmem_val",
(u64)"stringimm_val",
(u64)"def_val",
(u64)"label_val",
(u64)"name_val",
(u64)"temp_val"}};

static struct $B32 mc_decls_mclnames = {{
(u64)"m_procstart",
(u64)"m_procend",
(u64)"m_comment",
(u64)"m_labelname",
(u64)"m_define",
(u64)"m_definereg",
(u64)"m_trace",
(u64)"m_endx",
(u64)"m_labelx",
(u64)"m_nop",
(u64)"m_mov",
(u64)"m_push",
(u64)"m_pop",
(u64)"m_lea",
(u64)"m_cmovcc",
(u64)"m_movd",
(u64)"m_movq",
(u64)"m_movsx",
(u64)"m_movzx",
(u64)"m_movsxd",
(u64)"m_call",
(u64)"m_ret",
(u64)"m_leave",
(u64)"m_retn",
(u64)"m_jmp",
(u64)"m_jmpcc",
(u64)"m_xchg",
(u64)"m_add",
(u64)"m_sub",
(u64)"m_adc",
(u64)"m_sbb",
(u64)"m_imul",
(u64)"m_mul",
(u64)"m_imul2",
(u64)"m_imul3",
(u64)"m_idiv",
(u64)"m_div",
(u64)"m_andx",
(u64)"m_orx",
(u64)"m_xorx",
(u64)"m_test",
(u64)"m_cmp",
(u64)"m_shl",
(u64)"m_sar",
(u64)"m_shr",
(u64)"m_rol",
(u64)"m_ror",
(u64)"m_rcl",
(u64)"m_rcr",
(u64)"m_neg",
(u64)"m_notx",
(u64)"m_inc",
(u64)"m_dec",
(u64)"m_cbw",
(u64)"m_cwd",
(u64)"m_cdq",
(u64)"m_cqo",
(u64)"m_setcc",
(u64)"m_bsf",
(u64)"m_bsr",
(u64)"m_shld",
(u64)"m_shrd",
(u64)"m_sqrtss",
(u64)"m_sqrtsd",
(u64)"m_addss",
(u64)"m_addsd",
(u64)"m_subss",
(u64)"m_subsd",
(u64)"m_mulss",
(u64)"m_mulsd",
(u64)"m_divss",
(u64)"m_divsd",
(u64)"m_comiss",
(u64)"m_comisd",
(u64)"m_ucomisd",
(u64)"m_xorps",
(u64)"m_xorpd",
(u64)"m_andps",
(u64)"m_andpd",
(u64)"m_pxor",
(u64)"m_pand",
(u64)"m_cvtss2si",
(u64)"m_cvtsd2si",
(u64)"m_cvttss2si",
(u64)"m_cvttsd2si",
(u64)"m_cvtsi2ss",
(u64)"m_cvtsi2sd",
(u64)"m_cvtsd2ss",
(u64)"m_cvtss2sd",
(u64)"m_movdqa",
(u64)"m_movdqu",
(u64)"m_pcmpistri",
(u64)"m_pcmpistrm",
(u64)"m_fld",
(u64)"m_fst",
(u64)"m_fstp",
(u64)"m_fild",
(u64)"m_fist",
(u64)"m_fistp",
(u64)"m_fadd",
(u64)"m_fsub",
(u64)"m_fmul",
(u64)"m_fdiv",
(u64)"m_fsqrt",
(u64)"m_fsin",
(u64)"m_fcos",
(u64)"m_fsincos",
(u64)"m_fptan",
(u64)"m_fpatan",
(u64)"m_fabs",
(u64)"m_fchs",
(u64)"m_minss",
(u64)"m_maxss",
(u64)"m_minsd",
(u64)"m_maxsd",
(u64)"m_db",
(u64)"m_dw",
(u64)"m_dd",
(u64)"m_dq",
(u64)"m_isegment",
(u64)"m_zsegment",
(u64)"m_csegment",
(u64)"m_align",
(u64)"m_resb",
(u64)"m_resw",
(u64)"m_resd",
(u64)"m_resq",
(u64)"m_xlat",
(u64)"m_loopnz",
(u64)"m_loopz",
(u64)"m_loopcx",
(u64)"m_jecxz",
(u64)"m_jrcxz",
(u64)"m_cmpsb",
(u64)"m_cmpsw",
(u64)"m_cmpsd",
(u64)"m_cmpsq",
(u64)"m_rdtsc",
(u64)"m_popcnt",
(u64)"m_bswap",
(u64)"m_finit",
(u64)"m_fldz",
(u64)"m_fld1",
(u64)"m_fldpi",
(u64)"m_fld2t",
(u64)"m_fld2e",
(u64)"m_fldlg2",
(u64)"m_fldln2",
(u64)"m_cpuid",
(u64)"m_xxxx",
(u64)"m_halt"}};

static struct $B33 mc_decls_mclnopnds = {{
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
2,
1,
1,
2,
2,
2,
2,
2,
2,
2,
1,
0,
0,
1,
1,
1,
2,
2,
2,
2,
2,
1,
1,
2,
3,
1,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
0,
0,
0,
0,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
3,
3,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B33 mc_decls_mclcodes = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
144,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
232,
195,
201,
0,
233,
0,
0,
0,
5,
2,
3,
5,
4,
0,
0,
7,
6,
4,
1,
6,
0,
7,
4,
7,
5,
0,
1,
2,
3,
3,
2,
0,
1,
0,
0,
0,
0,
0,
188,
189,
164,
172,
81,
81,
88,
88,
92,
92,
89,
89,
94,
94,
0,
47,
46,
87,
87,
84,
84,
239,
219,
0,
0,
0,
0,
0,
0,
0,
0,
102,
243,
99,
98,
0,
2,
3,
0,
2,
3,
193,
233,
201,
249,
250,
254,
255,
251,
242,
243,
225,
224,
93,
95,
93,
95,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
4,
8,
215,
224,
225,
226,
227,
227,
0,
0,
0,
0,
49,
0,
0,
0,
238,
232,
235,
233,
234,
236,
237,
0,
244,
244}};

static struct $B34 mc_decls_regnames = {{
(u64)"rnone",
(u64)"r0",
(u64)"r1",
(u64)"r2",
(u64)"r3",
(u64)"r4",
(u64)"r5",
(u64)"r6",
(u64)"r7",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"r16",
(u64)"r17",
(u64)"r18",
(u64)"r19"}};

static struct $B35 mc_decls_regcodes = {{
0,
0,
10,
11,
7,
3,
6,
12,
13,
14,
15,
1,
2,
8,
9,
5,
4,
4,
7,
5,
6}};

static struct $B30 mc_decls_condnames = {{
(u64)"ov",
(u64)"nov",
(u64)"ltu",
(u64)"geu",
(u64)"eq",
(u64)"ne",
(u64)"leu",
(u64)"gtu",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"lt",
(u64)"ge",
(u64)"le",
(u64)"gt",
(u64)"flt",
(u64)"fge",
(u64)"fle",
(u64)"fgt"}};

static struct $B30 mc_decls_asmcondnames = {{
(u64)"o",
(u64)"no",
(u64)"b",
(u64)"ae",
(u64)"z",
(u64)"nz",
(u64)"be",
(u64)"a",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"l",
(u64)"ge",
(u64)"le",
(u64)"g",
(u64)"b",
(u64)"ae",
(u64)"be",
(u64)"a"}};

static struct $B30 mc_decls_asmrevcond = {{
1,
0,
3,
2,
5,
4,
7,
6,
9,
8,
11,
10,
13,
12,
15,
14,
17,
16,
19,
18}};

static struct $B36 mc_decls_dregnames = {{
(u64)"d0",
(u64)"d1",
(u64)"d2",
(u64)"d3",
(u64)"d4",
(u64)"d5",
(u64)"d6",
(u64)"d7",
(u64)"d8",
(u64)"d9",
(u64)"d10",
(u64)"d11",
(u64)"d12",
(u64)"d13",
(u64)"d14",
(u64)"d15",
(u64)"a0",
(u64)"a1",
(u64)"a2",
(u64)"a3",
(u64)"a4",
(u64)"a5",
(u64)"a6",
(u64)"a7",
(u64)"a8",
(u64)"a9",
(u64)"a10",
(u64)"a11",
(u64)"a12",
(u64)"a13",
(u64)"a14",
(u64)"a15",
(u64)"w0",
(u64)"w1",
(u64)"w2",
(u64)"w3",
(u64)"w4",
(u64)"w5",
(u64)"w6",
(u64)"w7",
(u64)"w8",
(u64)"w9",
(u64)"w10",
(u64)"w11",
(u64)"w12",
(u64)"w13",
(u64)"w14",
(u64)"w15",
(u64)"b0",
(u64)"b1",
(u64)"b2",
(u64)"b3",
(u64)"b4",
(u64)"b5",
(u64)"b6",
(u64)"b7",
(u64)"b8",
(u64)"b9",
(u64)"b10",
(u64)"b11",
(u64)"b12",
(u64)"b13",
(u64)"b14",
(u64)"b15",
(u64)"b16",
(u64)"b17",
(u64)"b18",
(u64)"b19",
(u64)"_b20",
(u64)"rax",
(u64)"rbx",
(u64)"rcx",
(u64)"rdx",
(u64)"rsi",
(u64)"rdi",
(u64)"rbp",
(u64)"rsp",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"eax",
(u64)"ebx",
(u64)"ecx",
(u64)"edx",
(u64)"esi",
(u64)"edi",
(u64)"ebp",
(u64)"esp",
(u64)"r8d",
(u64)"r9d",
(u64)"r10d",
(u64)"r11d",
(u64)"r12d",
(u64)"r13d",
(u64)"r14d",
(u64)"r15d",
(u64)"ax",
(u64)"bx",
(u64)"cx",
(u64)"dx",
(u64)"si",
(u64)"di",
(u64)"bp",
(u64)"sp",
(u64)"r8w",
(u64)"r9w",
(u64)"r10w",
(u64)"r11w",
(u64)"r12w",
(u64)"r13w",
(u64)"r14w",
(u64)"r15w",
(u64)"al",
(u64)"bl",
(u64)"cl",
(u64)"dl",
(u64)"ah",
(u64)"bh",
(u64)"ch",
(u64)"dh",
(u64)"sil",
(u64)"dil",
(u64)"bpl",
(u64)"spl",
(u64)"r8b",
(u64)"r9b",
(u64)"r10b",
(u64)"r11b",
(u64)"r12b",
(u64)"r13b",
(u64)"r14b",
(u64)"r15b"}};

static struct $B37 mc_decls_regsizes = {{
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1}};

static struct $B37 mc_decls_regindices = {{
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
0,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
17,
18,
19,
20,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10}};

static struct $B22 mc_decls_xmmregnames = {{
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm14",
(u64)"xmm15"}};

static struct $B31 mc_decls_fregnames = {{
(u64)"st0",
(u64)"st1",
(u64)"st2",
(u64)"st3",
(u64)"st4",
(u64)"st5",
(u64)"st6",
(u64)"st7"}};

static struct $B31 mc_decls_mregnames = {{
(u64)"mmx0",
(u64)"mmx1",
(u64)"mmx2",
(u64)"mmx3",
(u64)"mmx4",
(u64)"mmx5",
(u64)"mmx6",
(u64)"mmx7"}};

static struct $B38 mc_decls_jmpccnames = {{
(u64)"jo",
(u64)"jno",
(u64)"jb",
(u64)"jae",
(u64)"jz",
(u64)"jnz",
(u64)"jbe",
(u64)"ja",
(u64)"js",
(u64)"jns",
(u64)"jp",
(u64)"jnp",
(u64)"jl",
(u64)"jge",
(u64)"jle",
(u64)"jg",
(u64)"jc",
(u64)"jnc"}};

static struct $B39 mc_decls_jmpcccodes = {{
256,
770,
1284,
1798,
2312,
2826,
3340,
3854,
770}};

static struct $B22 mc_decls_setccnames = {{
(u64)"seto",
(u64)"setno",
(u64)"setb",
(u64)"setae",
(u64)"setz",
(u64)"setnz",
(u64)"setbe",
(u64)"seta",
(u64)"sets",
(u64)"setns",
(u64)"setp",
(u64)"setnp",
(u64)"setl",
(u64)"setge",
(u64)"setle",
(u64)"setg"}};

static struct $B3 mc_decls_setcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B22 mc_decls_cmovccnames = {{
(u64)"cmovo",
(u64)"cmovno",
(u64)"cmovb",
(u64)"cmovae",
(u64)"cmovz",
(u64)"cmovnz",
(u64)"cmovbe",
(u64)"cmova",
(u64)"cmovs",
(u64)"cmovns",
(u64)"cmovp",
(u64)"cmovnp",
(u64)"cmovl",
(u64)"cmovge",
(u64)"cmovle",
(u64)"cmovg"}};

static struct $B3 mc_decls_cmovcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B12 mc_decls_segmentnames = {{
(u64)"no_seg",
(u64)"code_seg",
(u64)"idata_seg",
(u64)"zdata_seg",
(u64)"rodata_seg",
(u64)"impdata_seg"}};

static struct $B8 mc_decls_reftypenames = {{
(u64)"extern_ref",
(u64)"fwd_ref",
(u64)"back_ref"}};

static struct $B12 mc_decls_opndnames_ma = {{
(u64)"a_none",
(u64)"a_reg",
(u64)"a_imm",
(u64)"a_mem",
(u64)"a_cond",
(u64)"a_xreg"}};

static struct $B30 mc_decls_pclopnd;
static struct $B17 mc_decls_pclreg;
static struct $B17 mc_decls_pclmode;
static struct $B17 mc_decls_pclcount;
static struct $B17 mc_decls_pclloc;
static struct $B17 mc_decls_pcltempflags;
static struct $B30 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B18 mc_decls_locnames = {{
(u64)"pend",
(u64)"reg",
(u64)"regvar",
(u64)"temp"}};

static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames = {{
(u64)"-",
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm15",
(u64)"xmm15"}};

static struct $B18 mc_decls_callalign;
static struct $B18 mc_decls_callblockret;
static struct $B22 mc_decls_callblocksize;
static struct $B21 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used = 0;

static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment = 0;

static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B41 mc_decls_regtable;
static struct $B42 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static u64 mc_decls_regmodes = 432345564311454723;

static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B19 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs = {{
1,
2,
3,
11,
12,
13}};

static struct $B12 mc_decls_multxregs = {{
1,
2,
3,
4,
5,
6}};

static struct $B24 mc_decls_ploadopx;
static struct $B24 mc_decls_ploadop;
static struct $B26 mc_objdecls_relocnames = {{
(u64)"abs_rel",
(u64)"addr64_rel",
(u64)"addr32_rel",
(u64)"addr32nb_rel",
(u64)"rel32_rel",
(u64)"rel321_rel",
(u64)"rel8_rel"}};

static struct $B41 mc_writenasm_nregnames;
static u8 mc_writenasm_currseg;
static struct $B21 mc_writenasm_strmcl_str;
static struct $B21 mc_writenasm_mstropnd_str;
static struct $B21 mc_writenasm_strvalue_str;
static struct $B18 mc_writenasm_getxregname_str;
static struct $B16 mc_writenasm_getdispname_str;
static struct $B22 mc_writenasm_gettempname_str;
static struct $B19 mc_writeexe_libinsttable;
static struct $B19 mc_writeexe_libinstnames;
static struct $B19 mc_writeexe_libnotable;
static u64 mc_writeexe_basereloclist;
static i64 mc_writeexe_nbaserelocs;
static i64 mc_writeexe_maxrelocaddr;
static struct $B44 mc_writeexe_blockbases;
static struct $B45 mc_writeexe_blockcounts;
static struct $B45 mc_writeexe_blockbytes;
static struct $B46 mc_writeexe_blockpadding;
static i64 mc_writeexe_nbaseblocks;
static i64 mc_writeexe_basetablesize;
static i64 mc_writeexe_imagebase;
static i64 mc_writeexe_imagesize;
static i64 mc_writeexe_filesize;
static u64 mc_writeexe_thunktable;
static i64 mc_writeexe_fileiatoffset;
static i64 mc_writeexe_fileiatsize;
static u64 mc_writeexe_stentrypoint;
static u64 mc_writeexe_stentrypoint2;
static u64 mc_writeexe_stentrypoint3;
static struct $B47 mc_writeexe_sectiontable;
static i64 mc_writeexe_nsections;
static u64 mc_writeexe_importdir;
static struct $B48 mc_writeexe_importtable;
static i64 mc_writeexe_nimports;
static struct $B49 mc_writeexe_exporttable;
static i64 mc_writeexe_nexports;
static u64 mc_writeexe_dllfilename;
static i64 mc_writeexe_isdll;
static struct $B50 mc_writeexe_dlltable;
static i64 mc_writeexe_ndlls;
static u64 mc_writeexe_datastart;
static u64 mc_writeexe_dataptr;
static u64 mc_writeexe_userentrypoint;
static i64 mc_writeexe_exportdirvirtaddr;
static i64 mc_writeexe_exportdirvirtsize;
static i64 mc_writeexe_exportdiroffset;
static i64 mc_writeexe_blockdirvirtaddr;
static i64 mc_writeexe_blockdirvirtsize;
static i64 mc_writeexe_blockdiroffset;
// Istatic skipped:mc_writeexe.writedosstub.stubdata

static i64 mc_writeobj_symtaboffset;
static u64 mc_writeobj_datastart;
static u64 mc_writeobj_dataptr;
static struct $B51 mc_writeobj_symboltable;
static i64 mc_writeobj_nsymbols;
static i64 mc_writeobj_stoffset = 0;

static struct $B52 mc_writeobj_stringtable;
static struct $B52 mc_writeobj_stringlengths;
static i64 mc_writeobj_nextstringoffset = 0;

static i64 mc_writeobj_nstrings = 0;

static struct $B2 mc_writeobj_writerelocs_s;
static struct $B39 mc_writeobj_makesymbol_r;
static struct $B39 mc_writeobj_strtoaux_r;
static struct $B39 mc_writeobj_sectiontoaux_r;
static struct $B23 mx_decls_mcxdirnames = {{
(u64)"pad_dir",
(u64)"version_dir",
(u64)"code_dir",
(u64)"idata_dir",
(u64)"zdata_dir",
(u64)"reloc_dir",
(u64)"dlls_dir",
(u64)"libs_dir",
(u64)"importsymbols_dir",
(u64)"exportsymbols_dir",
(u64)"exportsegs_dir",
(u64)"exportoffsets_dir",
(u64)"entry_dir",
(u64)"end_dir"}};

static struct $B12 mx_decls_mcxrelocnames = {{
(u64)"no_rel",
(u64)"locabs32",
(u64)"locabs64",
(u64)"impabs32",
(u64)"impabs64",
(u64)"imprel32"}};

static struct $B30 mx_decls_dllnametable;
static struct $B30 mx_decls_dllinsttable;
static i64 mx_decls_ndlllibs;
static struct $B30 mx_decls_libnametable;
static struct $B30 mx_decls_libtable;
static struct $B17 mx_decls_librelocated;
static struct $B17 mx_decls_libinitdone;
static i64 mx_decls_nlibs;
static struct $B53 mx_decls_symbolnametable;
static struct $B54 mx_decls_symboldefined;
static struct $B53 mx_decls_symboladdress;
static struct $B55 mx_decls_symbollibindex;
static struct $B54 mx_decls_symboldllindex;
static i64 mx_decls_nsymbols;
static i64 mx_decls_nsymimports = 0;

static i64 mx_decls_nsymexports = 0;

static struct $B12 mx_lib_rsegmentnames = {{
(u64)"no_seg",
(u64)"code_rseg",
(u64)"idata_rseg",
(u64)"zdata_rseg",
(u64)"rodata_rseg",
(u64)"impdata_rseg"}};

static u64 mx_write_dest;
static u64 mx_write_entrypoint;
static u64 mm_cli_syslibname = (u64)"";

static struct $B56 mm_cli_passnames = {{
(u64)"ma",
(u64)"list",
(u64)"proj",
(u64)"pcl",
(u64)"(int)",
(u64)"asm",
(u64)"obj",
(u64)"dll",
(u64)"exe",
(u64)"mx",
(u64)"(run)"}};

static struct $B31 mm_cli_dpassnames = {{
(u64)"dload_pass",
(u64)"dparse_pass",
(u64)"dfixup_pass",
(u64)"dname_pass",
(u64)"dtype_pass",
(u64)"dpcl_pass",
(u64)"dmcl_pass",
(u64)"dss_pass"}};

static struct $B57 mm_cli_optionnames = {{
(u64)"ma",
(u64)"getst",
(u64)"getproj",
(u64)"p",
(u64)"i",
(u64)"a",
(u64)"nasm",
(u64)"obj",
(u64)"dll",
(u64)"d",
(u64)"exe",
(u64)"mx",
(u64)"r",
(u64)"dload",
(u64)"dparse",
(u64)"dfixup",
(u64)"dname",
(u64)"dtype",
(u64)"dpcl",
(u64)"dmcl",
(u64)"dss",
(u64)"sys",
(u64)"min",
(u64)"nosys",
(u64)"linux",
(u64)"no",
(u64)"nopeep",
(u64)"noregs",
(u64)"ast1",
(u64)"ast2",
(u64)"ast3",
(u64)"showc",
(u64)"showpcl",
(u64)"showasm",
(u64)"st",
(u64)"stflat",
(u64)"types",
(u64)"showss",
(u64)"modules",
(u64)"shortnames",
(u64)"pst",
(u64)"time",
(u64)"v",
(u64)"vv",
(u64)"q",
(u64)"cs",
(u64)"ss",
(u64)"h",
(u64)"help",
(u64)"ext",
(u64)"o",
(u64)"outpath",
(u64)"unused",
(u64)"norip",
(u64)"himem"}};

static struct $B58 mm_cli_optionvalues = {{
1,
2,
3,
4,
5,
6,
6,
7,
8,
8,
9,
10,
11,
1,
2,
3,
4,
5,
6,
7,
8,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
3,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
2}};

static u8 mm_cli_msfile;
static u64 mm_cli_outext = (u64)"";

static i64 mm_cli_startclock;
static i64 mm_cli_endclock;
static i64 mm_cli_cmdskip;
static u64 mm_cli_inputfile;
static i64 mm_cli_loadtime;
static i64 mm_cli_parsetime;
static i64 mm_cli_resolvetime;
static i64 mm_cli_typetime;
static i64 mm_cli_ctime;
static i64 mm_cli_pcltime;
static i64 mm_cli_compiletime;
static u8 mm_cli_do_option_outused;
static u8 mm_cli_do_option_outpathused;
static i64 mm_genpcl_retindex;
static i64 mm_genpcl_initstaticsindex;
static u64 mm_genpcl_pcldoswx;
static struct $B59 mm_genpcl_loopstack;
static i64 mm_genpcl_loopindex;
static struct $B60 mm_genpcl_zero_unit;
static u64 mm_genpcl_pzero = (u64)&mm_genpcl_zero_unit;

static i64 mm_genpcl_nvarlocals;
static i64 mm_genpcl_nvarparams;
static i64 mm_blockpcl_nnn;
static struct $B30 mm_blockpcl_casestmt;
static struct $B30 mm_blockpcl_caseelse;
static i64 mm_blockpcl_casedepth;
static u64 mm_blockpcl_sw_labeltable;
static u64 mm_blockpcl_sw_valuetable;
static i64 mm_blockpcl_sw_lower;
static i64 mm_blockpcl_sw_ncases;
static u8 mm_blockpcl_sw_defaultseen;
static i64 mm_blockpcl_sw_defaultlabel;
static i64 mm_blockpcl_sw_breaklabel;
static i64 mm_blockpcl_maxreg = 0;

static u64 mm_blockpcl_pnprocs;
static u64 mm_blockpcl_pprocname;
static u64 mm_blockpcl_pprocaddr;
// Istatic skipped:mm_assem.initassemsymbols.regnames

// Istatic skipped:mm_assem.initassemsymbols.regnos

// Istatic skipped:mm_assem.initassemsymbols.sizes

static struct $B7 mm_decls_modules;
static struct $B61 mm_decls_moduletosub;
static struct $B62 mm_decls_subprogs;
static struct $B7 mm_decls_sources;
static struct $B63 mm_decls_subproghasstart;
static i64 mm_decls_nmodules;
static i64 mm_decls_nsubprogs;
static i64 mm_decls_nsourcefiles;
static i64 mm_decls_nlibfiles;
static u64 mm_decls_stprogram;
static u64 mm_decls_stmodule;
static i64 mm_decls_currmoduleno;
static u8 mm_decls_loadedfromma;
static struct $B3 mm_decls_lx;
static struct $B3 mm_decls_nextlx;
static struct $B64 mm_decls_libfiles;
static i64 mm_decls_mainsubprogno;
static i64 mm_decls_ntypes;
static struct $B65 mm_decls_ttnamedef;
static struct $B65 mm_decls_ttowner;
static struct $B66 mm_decls_ttbasetype;
static struct $B65 mm_decls_ttname;
static struct $B66 mm_decls_ttsize;
static struct $B67 mm_decls_ttsizeset;
static struct $B66 mm_decls_ttlower;
static struct $B66 mm_decls_ttlength;
static struct $B65 mm_decls_ttmult;
static struct $B65 mm_decls_ttdimexpr;
static struct $B66 mm_decls_tttarget;
static struct $B67 mm_decls_ttusercat;
static struct $B66 mm_decls_ttlineno;
static struct $B67 mm_decls_ttsigned;
static struct $B67 mm_decls_ttisreal;
static struct $B67 mm_decls_ttisinteger;
static struct $B67 mm_decls_ttisshort;
static struct $B67 mm_decls_ttisref;
static struct $B67 mm_decls_ttisblock;
static struct $B68 mm_decls_typenames;
static struct $B69 mm_decls_typenamepos;
static i64 mm_decls_ntypenames;
static struct $B37 mm_decls_typestarterset;
static u64 mm_decls_currproc;
static i64 mm_decls_assemmode = 0;

static i64 mm_decls_headermode = 0;

static u64 mm_decls_proclist;
static u64 mm_decls_proclistx;
static u64 mm_decls_staticlist;
static u64 mm_decls_staticlistx;
static u64 mm_decls_constlist;
static u64 mm_decls_constlistx;
static u64 mm_decls_nullunit;
static i64 mm_decls_ndllproctable;
static struct $B70 mm_decls_dllproctable;
static i64 mm_decls_fverbose = 1;

static u8 mm_decls_msyslevel = 2;

static u8 mm_decls_mvarlib = 0;

static u8 mm_decls_fvarnames = 0;

static u8 mm_decls_fshowtiming;
static u8 mm_decls_fshowss;
static u8 mm_decls_fshowc;
static u8 mm_decls_fshowpcl;
static u8 mm_decls_fshowasm;
static u8 mm_decls_fshowast1;
static u8 mm_decls_fshowast2;
static u8 mm_decls_fshowast3;
static u8 mm_decls_fshowst;
static u8 mm_decls_fshowpst;
static u8 mm_decls_fshowstflat;
static u8 mm_decls_fshowtypes;
static u8 mm_decls_fshowmodules;
static u8 mm_decls_fcheckunusedlocals = 0;

static u8 mm_decls_highmem = 1;

static u8 mm_decls_clinux;
static u8 mm_decls_dointlibs = 1;

static i64 mm_decls_passlevel = 0;

static i64 mm_decls_dpasslevel = 0;

static i64 mm_decls_prodmode = 0;

static i64 mm_decls_debugmode = 0;

static i64 mm_decls_libmode = 0;

static i64 mm_decls_fshortnames;
static u64 mm_decls_outfile;
static u64 mm_decls_destfilename;
static u64 mm_decls_destfilepath;
static i64 mm_decls_nunits;
static i64 mm_decls_nunitsmem;
static i64 mm_diags_currlineno;
static i64 mm_diags_currfileno;
static struct $B3 mm_diags_sbuffer;
static u64 mm_diags_dest = (u64)&mm_diags_sbuffer;

// Istatic skipped:mm_diags.printunit.cmpchain

static struct $B41 mm_diags_getprefix_str;
static struct $B71 mm_diags_getlineinfok_str;
// Istatic skipped:mm_diags.printmodelist.tab

// Istatic skipped:mm_diags.showprojectinfo.tab

static struct $B30 mm_lex_lxstart_stack;
static struct $B30 mm_lex_lxsource_stack;
static struct $B30 mm_lex_lxsptr_stack;
static struct $B30 mm_lex_lxfileno_stack;
static struct $B6 mm_lex_lxnextlx_stack;
static struct $B17 mm_lex_lximport_stack;
static i64 mm_lex_sourcelevel = 0;

static i64 mm_lex_lximport;
static u64 mm_lex_lxsource;
static u64 mm_lex_lxstart;
static u64 mm_lex_lxsptr;
static i64 mm_lex_lxifcond;
static i64 mm_lex_lxfileno;
static struct $B72 mm_lex_hashtable;
static struct $B16 mm_lex_namemap;
static u64 mm_lex_u64maxstr = (u64)"18446744073709551615";

static i64 mm_lib_autotypeno = 0;

static i64 mm_lib_nextavindex = 0;

static i64 mm_lib_nextsvindex = 0;

static struct $B3 mm_lib_exprstrvar;
static u64 mm_lib_exprstr = (u64)&mm_lib_exprstrvar;

static u64 mm_lib_unitheapptr = 0;

static i64 mm_lib_remainingunits = 0;

static struct $B3 mm_lib_sbuffer;
static u64 mm_lib_dest = (u64)&mm_lib_sbuffer;

static u64 mm_lib_jdest;
static u64 mm_lib_framevarname;
static struct $B18 mm_lib_nextautotype_str;
static struct $B16 mm_lib_getdottedname_str;
static struct $B4 mm_lib_strmode_str;
static struct $B4 mm_lib_strmode2_str;
static struct $B73 mm_libsources_syslibnames = {{
(u64)"msyswin.m",
(u64)"msyswinc.m",
(u64)"msyswini.m",
(u64)"msyslinc.m",
(u64)"msys.m",
(u64)"msysc.m",
(u64)"msysmin.m",
(u64)"mlib.m",
(u64)"mclib.m",
(u64)"mwindows.m",
(u64)"mlinux.m",
(u64)"mwindll.m",
(u64)"mwindllc.m"}};

static struct $B73 mm_libsources_syslibtext = {{
(u64)"module msys\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindll\n\n!proc start=\n!\tCPL \"MSYSWIN/START\"\n!END\n",
(u64)"module msysc\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindllc\n",
(u64)"module msys\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindllc\n",
(u64)"module msysc\nmodule mlib\nmodule mclib\nmodule mlinux\nmodule mwindllc\n",
(u64)"global record procinforec=\n\tu16\t\t\tfnindex\n\tbyte\t\trettype\n\tbyte\t\tnparams\n\t[12]byte\tparamlist\nend\n\n!for print/read routines\n!------------------------------------------\nexport record fmtrec=\t! (default)\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\n\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\n\tchar\tpadchar\t\t! Pc, Z (' ')\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\n\n\tchar\tplus\t\t! (0)   0 or '+'\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\n\tchar\tcharmode\t! C,M (0)  0 or 'C' or 'M'\to/p int as int or single char or multi-char\n\tchar\theapmode\t! D (0)  'D' for str-functions, return ptr to heap string\n\tchar\tparam\t\t! Use int value for <fmtparam>\n\tbyte\tspare : (showtype:1, newline:1)\nend\n\nint fmtparam\t\t\t!as set with :'V'\n\nenumdata =\n\tstd_io,file_io,str_io\nend\n\nconst comma = ','\n\nexport int $cmdskip\t\t\t!0 unless set by READMCX/etc\n\nexport int needgap\t\t\t= 0\nint outdev\t\t\t= std_io\nfilehandle outchan\t= nil\nref char fmtstr \t= nil\n\nconst maxiostack=10\n[maxiostack]filehandle\toutchan_stack\n[maxiostack]int\t\t\toutdev_stack\n[maxiostack]ref char\tfmtstr_stack\n[maxiostack]byte\t\tneedgap_stack\n\n[maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\nint niostack=0\n\n[0:]char digits=s\"0123456789ABCDEF\"\nconst onesixty=360\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\n\n!Read buffer vars\nexport const rd_buffersize = 16384\t!total capacity of line buffer\n\nexport ref char rd_buffer\t\t! point to start of read buffer\nexport int rd_length\t\t\t! length of this line (as read by readln)\nexport ref char rd_pos\t\t\t! current position it's up to (next read starts here)\nexport ref char rd_lastpos\t\t! set by sread() just before reading used for reread()\n\nint termchar\t\t\t! terminator char set by readxxx()\nint itemerror\t\t\t!\tset by some read functions, eg for reals\n\n[4096]char printbuffer\nichar printptr\nint printlen\n\n!------------------------------------------\n\nconst maxparam=128\nexport int nsysparams\nexport int ncmdparams\nexport int nenvstrings\nexport [maxparam]ichar sysparams\n!export ref[]ichar cmdparams\nexport ref[0:]ichar cmdparams\nexport ref[]ichar envstrings\n!export [maxparam]ichar envstrings\n\nproc start=\n\ti32 nargs\n\tint nargs64\n\tref[]ichar args\n\tstatic [128]byte startupinfo\t\t\t! 68 or 104 bytes\n\tint res\n\n!res:=1234567\n!res:=0x1234567\n!\n!CPL \"MSYS/START\"\n\n\tres:=__getmainargs(&nargs,cast(&args),cast(&envstrings),0,cast(&startupinfo))\n!\tres:=__getmainargs(&nargs,cast(&args),nil,0,cast(&startupinfo))\n\t\n\tnsysparams:=nargs\n\n\tif nsysparams>maxparam then\n\t\tprintf(\"Too many params\\n\")\n\t\tstop 50\n\tfi\n\n\tnargs64:=nargs\t\t\t!bug when using 32-bit limit when compiled with mm\n\tfor i:=1 to nargs64 do\n\t\tsysparams[i]:=args[i]\n\tod\n\t\n!assume nsysparams is >=1, since first is always the program name\n\tncmdparams:=nsysparams-($cmdskip+1)\n\tcmdparams:=cast(&sysparams[$cmdskip+1])\n\n\tint j:=1\n\tnenvstrings:=0\n\twhile envstrings[j] do\n\t\t++nenvstrings\n\t\t++j\n\tod\nend\n\nproc pushio=\n\tif niostack>=maxiostack then\n\t\tprintf(\"Too many io levels\\n\")\n\t\tstop 53\n\tfi\n\t++niostack\n\toutchan_stack[niostack]\t:= outchan\n\toutdev_stack[niostack]\t:= outdev\n\tfmtstr_stack[niostack]\t:= fmtstr\n\tneedgap_stack[niostack]\t:= needgap\n\tneedgap:=0\n\tfmtstr:=nil\n\toutchan:=nil\nend\n\nexport proc m$print_startfile(ref void dev)=\n\tpushio()\n\toutchan:=cast(dev)\n\tif dev then\n\t\toutdev:=file_io\n\telse\n\t\toutdev:=std_io\n\tfi\n\tresetprintbuffer()\nend\n\nexport proc m$print_startstr(ref char s)=\n\tref ref char p\n\tpushio()\n\n\tptr_stack[niostack]:=s\n\tp:=&ptr_stack[niostack]\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startptr(ref ref char p)=\n\tpushio()\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startcon=\n\tpushio()\n\toutdev:=std_io\n\tresetprintbuffer()\nend\n\nexport proc m$print_setfmt(ref char format)=\n\tfmtstr:=format\nend\n\nexport proc m$print_end=\n\tneedgap:=0\n\tnextfmtchars(1)\n\tif niostack=1 and outdev in [std_io,file_io] then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif niostack=0 then return fi\n\toutchan\t:= outchan_stack[niostack]\n\toutdev\t:= outdev_stack[niostack]\n\tfmtstr\t:= fmtstr_stack[niostack]\n\tneedgap\t:= needgap_stack[niostack]\n\n\t--niostack\nend\n\nexport proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n\tif fmtstyle=nil then\n\t\tfmtstyle:=\"z8H\"\n\tfi\n\tm$print_u64(a,fmtstyle)\nend\n\nexport proc m$print_ptr_nf(u64 a)=\n\tm$print_ptr(a)\nend\n\nexport proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\tint n\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tif a>=0 then\n\t\t\tn:=u64tostr(a,&.s,10,0)\n\t\telsif a=i64.min then\n\t\t\tfmt:=defaultfmt\n\t\t\tdofmt\n\n\t\telse\n\t\t\ts[1]:='-'\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\n\t\tfi\n\n\t\tprintstr_n(&.s,n)\n\n\telse\n\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\tif fmt.param='V' then\n\t\t\tfmtparam:=a\n\t\t\tneedgap:=0\n\t\telse\ndofmt:\n\t\t\ttostr_i64(a,&fmt)\n\t\tfi\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_i64_nf(i64 a)=\n\tm$print_i64(a)\nend\n\nexport proc m$print_bool(i64 a, ichar fmtstyle=nil)=\n\tif a then\n\t\tm$print_str(\"True\",fmtstyle)\n\telse\n\t\tm$print_str(\"False\",fmtstyle)\n\tfi\nend\n\nexport proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%llu\",a)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_u64(a,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_r64(real x,ichar fmtstyle=nil)=\n\t[360]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%f\",x)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_r64(x,&fmt)\n\tfi\n\n\tneedgap:=1\nend\n\nexport proc m$print_r32(r32 x,ichar fmtstyle=nil)=\n\tm$print_r64(x,fmtstyle)\nend\n\nglobal proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n\t[32]char s\n!\tint cc@s\n\tfmtrec fmt\n\tint n\n\tbyte charmode:=0\n\n\tnextfmtchars()\n\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1, &fmt)\n\t\tcharmode:=fmt.charmode\n\tfi\n\n\tif charmode='M' then\n\t\tn:=domultichar(ref char(&a), 8, &.s, &fmt)\n!\t\tn:=domultichar(ref char(&a), 8, &.str, fmt)\n\telse\t\t\t\t\t\t!assume 'C'\n\t\t(ref int(&s)^):=a\t\n\t\ts[9]:=0\n\n\t\tn:=getutfsize(s)\t\t\t!isolate size of next char\n\tfi\n\n\tprintstr_n(s,n)\n\n\tneedgap:=1\nend\n\nexport proc m$print_str(ichar s, fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr(s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,-1,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr_n(s,length)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,length,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_str_nf(ichar s)=\n\tm$print_str(s)\nend\n\nexport proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\nABORTPROGRAM(\"PRTSL\")\n!\tnextfmtchars()\n!\n!!\tfmtrec fmt\n!\n!\tif fmtstyle=nil then\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\n!!\t\tprintstr_n(cast(ss.str),ss.length)\n!\telse\n!\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\n!!\t\tstrtofmt(fmtstyle,-1,&fmt)\n!!\t\ttostr_str(s,s.len,&fmt)\n!\tfi\n!\tneedgap:=1\nend\n\nexport proc m$print_newline=\n!PUTS(\"<NEWLINE>\")\n\tneedgap:=0\n\tnextfmtchars(1)\n\tprintstr(\"\\w\")\nend\n\nexport proc m$print_nogap=\n\tneedgap:=0\nend\n\nexport proc m$print_space=\n\tneedgap:=0\n\tprintstr(\" \")\nend\n\nexport proc printstr(ichar s)=\n\tprintstr_n(s,strlen(s))\nend\n\nexport proc printstr_n(ichar s,int n)=\n\n!\treturn when n=0\n\n!\tif niostack=1 and outdev in [std_io,file_io] then\n!!puts(\"ADDTO BUFF\")\n!\t\taddtobuffer(s,n)\n!\telse\n!printf(\"DUMPSTR %lld\\n\", n)\n\t\tdumpstr(s,n)\n!\tfi\nend\n\nexport proc printstrn_app(ichar s, int length, filehandle f=nil)=\nif length then\n\tif f=nil then\n\t\tprintf(\"%.*s\",length,s)\n\telse\n\t\tfprintf(f,\"%.*s\",length,s)\n\tfi\nfi\nend\n\nproc printchar(int ch)=\n\t[4]char str\n\n\tstr[1]:=ch\n\tstr[2]:=0\n\tprintstr_n(str,1)\nend\n\nglobal proc nextfmtchars(int lastx=0)=\n\tchar c\n\tref char pstart\n\tint n\n\tif not fmtstr then\t\t\t!format not in use\n\t\tif needgap then\n\t\t\tprintchar(' ')\n\t\tfi\n\t\tneedgap:=0\n\t\treturn\n\tfi\n\n\tpstart:=fmtstr\n\tn:=0\n\n\tdo\n\t\tc:=fmtstr^\n\t\tcase c\n\t\twhen '#' then\n\t\t\tif lastx then\n\t\t\t\tgoto skip\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\tfi\n\t\t\treturn\n\t\twhen 0 then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\telsif not lastx then\n\t\t\t\tprintstr_n(\"|\",1)\n\t\t\tfi\n\t\t\treturn\n\t\twhen '~' then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\t\tn:=0\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tc:=fmtstr^\n\t\t\tif c then\n\t\t\t\t++fmtstr\n\t\t\t\tprintchar(c)\n\t\t\tfi\n\t\t\tpstart:=fmtstr\n\t\telse\n\tskip:\n\t\t\t++n\n\t\t\t++fmtstr\n\t\tesac\n\tod\nend\n\nexport proc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\n!convert format code string in s, to fmtrec at fmt^\n!Format code is a string containing the following char codes (upper or lower when mostly)\n!n\tWidth\n!.n\tMax width/precision\n!A\tConvert to upper case\n!a\tConvert to lower case\n!B\tBinary\n!C\tShow int as single n-bit (unicode) character\n!D\tDuplicate string returned via STRINT etc on heap\n!E,F,G\tSpecify format for double (corresponds to C format codes)\n!F\n!G\n!H\tHex\n!JC\tJustify centre\n!JL\tJustify left\n!JR\tJustify right\n!M\tShow int as multi-bit (unicode) character\n!M\tHEAPMODE???\n!O\tOctal\n!Pc\tUse padding char c\n!Q\tAdd double quotes around string (and deal with embedded quotes)\n!'\tAdd single quotes around string (and deal with embedded quotes)\n!Sc\tUse separator char c between every 3 or 4 digits\n!Tc\tUse terminator char c (typically B or H)\n!U\tShow ints as unsigned\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\n!W\tUnsigned\n!Xn\tUse base n (n is hex 0 to F)\n!Z\tUse \"0\" padding\n!+\tAlways have + or - in front of integers\n!~\tQuote char is ~\n!*\tSame as n but uses parameter set with :'V' on previous int\n\n\tint c, base\n\tbyte wset\n\tint n\n\t[0:100]char str\n\n\tfmt^:=defaultfmt\n\n\tif s=nil then return fi\n\n\tif slen=-1 then slen:=strlen(s) fi\n\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\n\tstr[slen]:=0\n\ts:=&.str\n\n\twset:=0\n\twhile s^ do\n\t\tc:=s^\n\t\t++s\n\t\tif c='A' then fmt.lettercase:='A'\n\t\telsif c='a' then fmt.lettercase:='a'\n\t\telseswitch toupper(c)\n\t\twhen 'B' then fmt.base:=2\n\t\twhen 'H' then fmt.base:=16\n\t\twhen 'O' then fmt.base:=8\n\t\twhen 'X' then\n\t\t\tbase:=0\n\t\t\tdo\n\t\t\t\tc:=s^\n\t\t\t\tif c in '0'..'9' then\n\t\t\t\t\tbase:=base*10+c-'0'\n\t\t\t\t\t++s\n\t\t\t\telse\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\tod\n\t\t\tif base in 2..16 then\n\t\t\t\tfmt.base:=base\n\t\t\tfi\n\n\t\twhen 'Q' then fmt.quotechar:='\"'\n\t\twhen 'J' then\n\t\t\tfmt.justify:=toupper(s^)\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'Z' then fmt.padchar:='0'\n\t\twhen 'S' then\n\t\t\tfmt.sepchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'P' then\n\t\t\tfmt.padchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'T' then\n\t\t\tfmt.suffix:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'U' then fmt.usigned:='W'\n\t\twhen 'E' then fmt.realfmt:='e'\n\t\twhen 'F' then fmt.realfmt:='f'\n\t\twhen 'G' then fmt.realfmt:='g'\n\t\twhen 'D' then fmt.heapmode:='D'\n\t\twhen 'C' then fmt.charmode:='C'\n\t\twhen 'M' then fmt.charmode:='M'\n\t\twhen 'V' then fmt.param:='V'\n\t\twhen 'Y' then fmt.showtype:=1\n\t\twhen 'N' then fmt.newline:=1\n\t\telsecase c\n\t\twhen '.' then\n\t\t\twset:=1\n\t\twhen comma,'_' then fmt.sepchar:=c\n\t\twhen '+' then fmt.plus:='+'\n\t\twhen '~' then fmt.quotechar:='~'\n\t\twhen '*' then\n\t\t\tn:=fmtparam\n\t\t\tgoto gotwidth\n\t\telse\n\t\t\tif c>='0' and c<='9' then\n\t\t\t\tn:=c-'0'\n\t\t\t\tdo\n\t\t\t\t\tc:=s^\n\t\t\t\t\tif s^=0 then\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tif c>='0' and c<='9' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\tn:=n*10+c-'0'\n\t\t\t\t\telse\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\tod\ngotwidth:\n\t\t\t\tif not wset then\n\t\t\t\t\tfmt.minwidth:=n\n\t\t\t\t\twset:=1\n\t\t\t\telse\n\t\t\t\t\tfmt.precision:=n\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tod\nend\n\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\n!there are n (4 or 8) chars at p.!\n!There could be 0 to 4 or 8 printable chars converted to string at dest\n\t[0:20]char str\n\tref char q\n\tint nchars\n\n\tq:=&.str\n\n\tnchars:=n\n\n\tto n do\n\t\tif p^=0 then exit fi\n\t\tq^:=p^\n\t\t++q\n\t\t++p\n\tod\n\tq^:=0\n\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\nend\n\nexport function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\n!s contains a partly stringified value.\n!widen s if necessary, according to fmt, and copy result to t\n!n is current length of s\n!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving\n!a leading +/- when right-justifying with '0' padding.\n!t MUST be big enough for the expanded string; caller must take care of this\n!result will be zero-terminated, for use in this module\n\n\tint i,w,m\n\n!check to see if result is acceptable as it is\n\tw:=fmt.minwidth\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\n\t\tstrncpy(t,s,n)\n\t\t(t+n)^:=0\n\t\treturn n\n\tfi\n\n\tif fmt.justify='L' then\t! left-justify\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tfor i:=1 to w-n do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\telsif fmt.justify='R' then\n\t\tif fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside \n\t\t\tt^:=s^\n\t\t\t++t\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s+1,n-1)\n\t\t\t(t+n-1)^:=0\n\t\telse\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s,n)\n\t\t\t(t+n)^:=0\n\t\tfi\n\n\telse\t\t\t\t! centre-justify?\n\n\t\tm:=(w-n+1)/2\n\t\tto m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tto w-n-m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\n\tfi\n\treturn w\nend\n\nexport function u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\n!convert 64-bit int a to string in s^\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\n!result when a=minint (will give \"<minint>\")\n\t[0:onesixty]char t\n\tu64 dd\n\tint i,j,k,g\n\tref char s0\n\n\ti:=0\n\tk:=0\n\tg:=(base=10|3|4)\n\n\trepeat\n!\t\tif base=10 then\t\t\t!BUGGY FOR AA OVER I64.MAX\n!\t\t\tassem\n!\t\t\t\tmov\t\trcx, [aa]\n!\t\t\t\tmov\t\trax, rcx\n!\t\t\t\tmov\t\trdx, 7378697629483820647\n!\t\t\t\timul\trdx\n!\t\t\t\tmov\t\trax, rdx\n!\t\t\t\tmov\t\trdx, rcx\n!\t\t\t\tsar\t\trdx, 63\n!\t\t\t\tsar\t\trax, 2\n!\t\t\t\tsub\t\trax, rdx\n!\t\t\t\tlea\t\trdx, [rax+rax*4]\n!\t\t\t\tadd\t\trdx, rdx\n!\t\t\t\tsub\t\trcx, rdx\n!\t\t\t\tmov\t\t[dd], rcx\n!\t\t\t\tmov\t\t[aa], rax\n!\t\t\tend\n!\t\telse\n\t\t\tdd:=aa rem base\n\t\t\taa:=aa/base\n!\t\tfi\n\n\t\tt[++i]:=digits[dd]\n\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\n!out a full length binary\n!so perhaps move this out to expandstr\n\t\t++k\n\t\tif sep and aa<>0 and k=g then\n\t\t\tt[++i]:=sep\n\t\t\tk:=0\n\t\tfi\n\tuntil aa=0\n\n\tj:=i\n\ts0:=s\n\twhile i do\n\t\ts^:=t[i--]\n\t\t++s\n\tod\n\ts^:=0\n\n\treturn j\nend\n\nexport function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\n!convert a to a string in s, according to fmt\n!a basic conversion is done first,: the field manipulation is done\n!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)\n!returns length of s\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n, usigned\n\tconst i64 mindint=0x8000'0000'0000'0000\n\n\tusigned:=0\n\tif fmt.usigned then\n\t\tusigned:=1\n\tfi\n\tif aa=mindint and not usigned then\t\t! minint\n\n\t\tstr[0]:='-'\n\t\tn:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1\n\n\telse\n\t\tif (not usigned and aa<0) or fmt.plus then\n\t\t\tif aa<0 then\n\t\t\t\taa:=-aa\n\t\t\t\tstr[0]:='-'\n\t\t\telse\n\t\t\t\tstr[0]:='+'\n\t\t\tfi\n\t\t\tn:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1\n\t\telse\n\t\t\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\t\tfi\n\tfi\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'\tthen\t! need lower when\n\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\n!see i64tostrfmt\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n\n\n\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif fmt.base>10 or fmt.suffix and fmt.lettercase='a'\tthen\t! need lower when\n!\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\n!convert minint to string in s do not include minus sign\n!return number of chars in string\n\t[0:onesixty]char t\n\tint i,j,k,g\n\n\tcase base\n\twhen 10 then\n\t\tstrcpy(&t[0],\"9223372036854775808\")\n\t\tj:=3\n\twhen 16 then\n\t\tstrcpy(&t[0],\"8000000000000000\")\n\t\tj:=1\n\twhen 2 then\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\n\t\tj:=7\n\telse\n\t\tstrcpy(&t[0],\"<mindint>\")\n\tesac\n\n\ti:=strlen(&t[0])\n\ts+:=i\n\tif sep then\n\t\ts+:=j\n\tfi\n\ts^:=0\n\n\tk:=0\n\tg:=(base=10|3|4)\n\n\twhile i do\n\t\t--s\n\t\ts^:=t[i-- -1]\n\t\tif sep and i and ++k=g then\n\t\t\t--s\n\t\t\ts^:=sep\n\t\t\tk:=0\n\t\tfi\n\tod\n\treturn strlen(s)\nend\n\nexport function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\n!s is a string process according to fmtrec fmt^, and return result in t\n!caller should check whether any changes are required to s (now it can just use s), but this\n!check is done here anyway (with a simple copy to t)\n!n is current length of s\n!return length of t\n!Three processing stages:\n!1 Basic input string s\n!2 Additions or mods: quotes, suffix, when conversion\n!3 Width adjustment\n!1 is detected here, 2 is done here, 3 is done by expandstr\n\tref char u,v\n\t[256]char str\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\n\n\tnheap:=0\n\n\tif fmt.quotechar or fmt.lettercase then\t\t! need local copy\n\t\tif n<256 then\n\t\t\tu:=&.str\n\t\telse\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\n\t\t\tu:=pcm_alloc(nheap)\n\t\tfi\n\t\tif fmt.quotechar then\n\t\t\tv:=u\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tif n then\n\t\t\t\tstrcpy(v,s)\n\t\t\t\tv+:=n\n\t\t\tfi\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tv^:=0\n\t\t\tn+:=2\n\t\telse\n\t\t\tmemcpy(u,s,n)\n\t\tfi\n\t\tcase fmt.lettercase\n\t\twhen 'a' then\t! need lower when\n\t\t\tconvlcstring(u)\n\t\twhen 'A' then\n\t\t\tconvucstring(u)\n\t\tesac\n\t\ts:=u\n\tfi\n\n\tw:=fmt.minwidth\n\tif w>n then\n\t\tn:=expandstr(s,t,n,fmt)\n\telse\n\t\tmemcpy(t,s,n)\n\tfi\n\tif nheap then\n\t\tpcm_free(u,nheap)\n\tfi\n\treturn n\nend\n\nproc tostr_i64(i64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 0 then\n\t\tn:=i64tostrfmt(a,&.str,fmt)\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\telse\t\t\t\t\t\t!assume 'C'\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_u64(u64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\twhen 'C' then\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\n\telse\n\t\tn:=u64tostrfmt(a,&.str,fmt)\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_r64(real x,ref fmtrec fmt) =\n\t[360]char str,str2\n\t[0:10]char cfmt\n\tint n\n\n\tcfmt[0]:='%'\n\n\tif fmt.precision then\n\t\tcfmt[1]:='.'\n\t\tcfmt[2]:='*'\n\t\tcfmt[3]:=fmt.realfmt\n\t\tcfmt[4]:=0\n\t\tsprintf(&.str,&.cfmt,fmt.precision,x)\n\telse\n\t\tcfmt[1]:=fmt.realfmt\n\t\tcfmt[2]:=0\n\t\tsprintf(&.str,&.cfmt,x)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\n\tn:=strlen(&.str)\t\t! current length\n\n\tif n<fmt.minwidth then\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\n\t\tstrcpy(&.str,&.str2)\n\tfi\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_str(ref char s, int oldlen, ref fmtrec fmt) =\n\tint newlen,n\n\tref char t\n\n!try and work out size of formatted string\n\tif oldlen=-1 then\n\t\toldlen:=strlen(s)\n\tfi\n\tnewlen:=oldlen\n\n\tif fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then\n\t\tif fmt.quotechar then\n\t\t\tnewlen+:=2\n\t\tfi\n\t\tif fmt.minwidth>newlen then\n\t\t\tnewlen:=fmt.minwidth\n\t\tfi\n\t\tt:=pcm_alloc(newlen+1)\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\n\t\tif fmt.precision then\n\t\t\tn min:=fmt.precision\n\t\tfi\n\n\t\tprintstr_n(t,n)\n\t\tpcm_free(t,newlen+1)\n\telse\n\t\tprintstr_n(s,oldlen)\n\tfi\nend\n\nfunction getfmt(ichar fmtstyle)ref fmtrec=\n\tstatic fmtrec fmt\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\treturn &fmt\n\telse\n\t\treturn &defaultfmt\n\tfi\nend\n\nexport function strint(i64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport proc getstrint(i64 a, ichar dest)=\n\tm$print_startstr(dest)\n\ttostr_i64(a,getfmt(nil))\n\tm$print_end()\nend\n\nexport function strword(u64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function strreal(real a, ichar fmtstyle=nil)ichar=\n\tstatic [320]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function getstr(ichar s, ref fmtrec fmt)ichar=\n\tif fmt.heapmode then\n\t\treturn pcm_copyheapstring(s)\n\telse\n\t\treturn s\n\tfi\nend\n\nproc initreadbuffer=\n\tif rd_buffer then return fi\n\trd_buffer:=pcm_alloc(rd_buffersize)\n\trd_buffer^:=0\n\trd_pos:=rd_lastpos:=rd_buffer\nend\n\nglobal proc m$read_conline=\n\tinitreadbuffer()\n\n\treadlinen(nil,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_fileline(filehandle f)=\n\tinitreadbuffer()\n\n\tif f=filehandle(1) then\nABORTPROGRAM(\"READ CMDLINE\")\n!\t\trd_buffer^:=0\n!\t\tp:=getcommandlinea()\n!\t\trepeat\n!\t\t\t++p\n!\t\tuntil p^ in [' ','\\t',0]\n!\t\tstrcpy(rd_buffer, p)\n!\t\trd_length:=strlen(rd_buffer)\n!\t\trd_pos:=rd_buffer\n!\t\trd_lastpos:=nil\n\t\treturn\n\tfi\n\n\treadlinen(f,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_strline(ichar s)=\n\tint n\n\n\tinitreadbuffer()\n\tn:=strlen(s)\n\n\tif n<rd_buffersize then\n\t\tstrcpy(rd_buffer,s)\n\telse\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\n\t\t(rd_buffer+rd_buffersize-1)^:=0\n\tfi\n\trd_length:=n\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nfunction readitem(int &itemlength)ref char =\n!read next item from rd_buffer\n!identify a substring that can contain a name, int, real, string or filename\n!return updated position of s that points past the item and past the immediate\n!terminator \n!information about the read item is returned in itemstr, which points to\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\n!Item can be quoted, then the item points inside the quotes\n!Any embedded quotes are removed, and the characters moved up. The item will\n!be that reduced subsequence\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\n!I can mitigate this by adding spaces between the end of the item, and the next item,\n!overwriting also the terminator. But this won't restore the line if one of the next\n!reads is literal, using 'L' or 'C' codes.\n\tref char p,s,itemstr\n\tchar quotechar, c\n\n\tunless rd_buffer then \n\t\tinitreadbuffer()\n\tend unless\n\n\ts:=rd_pos\n\n!scan string, eliminating leading white space\n\twhile s^=' ' or s^=9 do\n\t\t++s\n\tod\n\n\titemstr:=s\n\trd_lastpos:=rd_pos:=s\n\n\tif s^=0 then\n\t\ttermchar:=0\n\t\titemlength:=0\n\t\treturn s\n\tfi\n\n\tquotechar:=0\n\tif s^='\"' then\n\t\tquotechar:='\"'\n\t\t++s\n\telsif s^='\\'' then\n\t\tquotechar:='\\''\n\t\t++s\n\tfi\n\n!loop reading characters until separator or end reached\n\tp:=itemstr:=s\n\n\twhile s^ do\n\t\tc:=s++^\n\t\tcase c\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\n\t\t\t\tgoto normalchar\n\t\t\tfi\n\t\t\ttermchar:=c\n\t\t\texit\n\t\telse\n\tnormalchar:\n\t\t\tif c=quotechar then\n\t\t\t\tif s^=quotechar then\t! embedded quote\n\t\t\t\t\tp^:=c\n\t\t\t\t\t++s\n\t\t\t\t\t++p\n\t\t\t\telse\t\t\t\t\t! end of name\n\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tif termchar in [',', '='] then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tfi\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tp^:=c\n\t\t\t\t++p\n\t\t\tfi\n\t\tesac\n\tod\n\n\tif s^=0 then\n\t\ttermchar:=0\n\tfi\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\n\trd_pos:=s\n\n\treturn itemstr\nend\n\nexport function strtoint(ichar s,int length=-1, word base=10)i64=\n!return point to next char after terminator (which can be just off length of string)\n\tbyte signd\n\tu64 aa\n\tword c,d\n\n\titemerror:=0\n\n\tif length=-1 then\n\t\tlength:=strlen(s)\n\tfi\n!check for sign\n\tsignd:=0\n\tif length and s^='-' then\n\t\tsignd:=1; ++s; --length\n\telsif length and s^='+' then\n\t\t++s; --length\n\tfi\n\n\taa:=0\n\twhile length do\n\t\tc:=s++^\n\t\t--length\n\t\tif c in 'A'..'F' then d:=c-'A'+10\n\t\telsif c in 'a'..'f' then d:=c-'a'+10\n\t\telsif c in '0'..'9' then d:=c-'0'\n\t\telsif c in ['_', '\\''] then\n\t\t\tnextloop\n\t\telse\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\n\t\tif d>=base then\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\t\taa:=aa*base+d\n\tod\n\n\tif signd then\n\t\treturn -aa\n\telse\n\t\treturn aa\n\tfi\nend\n\nglobal function m$read_i64(int fmt=0)i64=\n\tref char s\n\tint length\n\n\tfmt:=toupper(fmt)\n\n\tcase fmt\n\twhen 'C' then\n\t\trd_lastpos:=rd_pos\n\t\tif rd_pos^ then\n\t\t\treturn rd_pos++^\n\t\telse\n\t\t\treturn 0\n\t\tfi\n\twhen 'T' then\n\t\treturn termchar\n\twhen 'E' then\n\t\treturn itemerror\n\tesac\n\n\ts:=readitem(length)\n\n\tcase fmt\n\twhen 0,'I' then\n\t\treturn strtoint(s,length)\n\twhen 'B' then\n\t\treturn strtoint(s,length,2)\n\twhen 'H' then\n\t\treturn strtoint(s,length,16)\n\tesac\n\treturn 0\nend\n\nglobal function m$read_r64(int fmt=0)real=\n\t[512]char str\n\tref char s\n\tint length\n\ti32 numlength\n\treal x\n\n\ts:=readitem(length)\n\n\tif length=0 or length>=str.len then\t\t!assume not a real\n\t\treturn 0.0\n\tfi\n\tmemcpy(&.str,s,length)\n\tstr[length+1]:=0\n\n\titemerror:=0\n\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\n\t\tx:=0.0\n\t\titemerror:=1\n\tfi\n\n\treturn x\nend\n\nglobal proc m$read_str(ref char dest, int destlen=0,fmt=0)=\n\tref char s\n\tint length\n\n\titemerror:=0\n\tif fmt in ['L','l'] then\n\t\ts:=rd_pos\n\t\tlength:=rd_buffer+rd_length-rd_pos\n\n\telse\n\t\ts:=readitem(length)\n\n\t\tif fmt in ['N','n'] then\n\t\t\ticonvlcn(s,length)\n\t\tfi\n\tfi\n\n\tif destlen>0 then\n\t\tif length>=destlen then\n\t\t\tlength:=destlen-1\n\t\t\titemerror:=1\n\t\tfi\n\tfi\n\tmemcpy(dest,s,length)\n\t(dest+length)^:=0\nend\n\nexport proc readstr(ref char dest, int fmt=0,destlen=0)=\n\tm$read_str(dest,destlen,fmt)\nend\n\nexport proc rereadln=\n\trd_pos:=rd_buffer\n\trd_lastpos:=rd_pos\nend\n\nexport proc reread=\n\trd_pos:=rd_lastpos\nend\n\nexport function valint(ichar s, int fmt=0)i64=\n\tref char old_pos, old_lastpos\n\ti64 aa\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\taa:=m$read_i64(fmt)\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn aa\nend\n\nexport function valreal(ichar s)real=\n\tref char old_pos, old_lastpos\n\treal x\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\tx:=m$read_r64()\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn x\nend\n\nproc mclunimpl(ichar mess)=\n\tprintf(\"MCL-UNIMPL: %s\\n\",mess)\n\tstop 1\nend\n\nproc dumpstr(ichar s, int n, fbuffer=0)=\n!fbuffer=1 when outputting contents of buffer\n\n\tref ref char p\n\n\tif outdev=str_io then\n\t\tp:=cast(outchan)\n\t\tif n then\n\t\t\tmemcpy(p^,s,n)\n\t\t\tp^+:=n\n\t\tfi\n\t\tp^^:=0\n\t\treturn\n\tfi\n\n\treturn when n=0\n\tif fbuffer and n>=2 and outdev=std_io then\n\t\t--printptr\t\t\t\t!point to last char\n\t\tif printptr^=10 then\n\t\t\tif (printptr-1)^=13 then\t\t!crlf\n\t\t\t\t(printptr-1)^:=0\n\t\t\telse\t\t\t\t\t\t\t!lf only\n\t\t\t\tprintptr^:=0\n\t\t\tfi\n\t\t\tputs(printbuffer)\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\tesac\nend\n\nproc dumpprintbuffer=\n\tif printlen then\n\t\tdumpstr(&.printbuffer,printlen,1)\n\tfi\n\n\tresetprintbuffer()\nend\n\nproc resetprintbuffer=\n\tprintptr:=&.printbuffer\n\tprintlen:=0\nend\n\nproc addtobuffer(ichar s, int n)=\n\tif printlen+n>=(printbuffer.len-8) then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif n<printbuffer.len then\n\t\tmemcpy(printptr,s,n)\n\t\tprintptr+:=n\n\t\tprintlen+:=n\n\t\treturn\n\tfi\n\n\tdumpstr(s, n)\t\t\t!don't bother with buffer\nend\n\nglobal function m$power_i64(i64 a,n)i64=\n\tif n<0 then\n\t\treturn 0\n\telsif n=0 then\n\t\treturn 1\n\telsif n=1 then\n\t\treturn a\n\telsif (n iand 1)=0 then\n\t\treturn m$power_i64(sqr a,n/2)\n\telse\t\t\t!assume odd\n\t\treturn m$power_i64(sqr a,(n-1)/2)*a\n\tfi\nend\n\nfunc getutfsize(ref char s)int =\n!work out the size in bytes of the ascii or utf8 character that s points to\n\tint a\n\n\ta:=s++^\n\n\tif a=0 then\t\t\t\t\t\t!end of string\n\t\t0\n\telsif a.[7]=0 then\t\t\t\t!ascii\n\t\t1\n\telsif a.[7..5]=2x110 then\n\t\t2\n\telsif a.[7..4]=2x1110 then\n\t\t3\n\telsif a.[7..3]=2x11110 then\n\t\t4\n\telse\t\t\t\t\t\t\t!error: just assume a byte of random binary\n\t\t1\n\tfi\nend\n\n!export fun `fract(real x)real = fmod(x,1.0)\n!export fun fraction(real x)real = fmod(x,1.0)\n\nexport fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))\nexport func m$sign_r64(real x)real =\n\tif x<0 then return -1 fi\n\tif x>0 then return 1 fi\n\t0\nend\n",
(u64)"global record procinforec=\n\tu16\t\tfnindex\n\tbyte\t\trettype\n\tbyte\t\tnparams\n\t[12]byte\tparamlist\nend\n\n!for print/read routines\n!------------------------------------------\nexport record fmtrec=\t! (default)\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\n\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\n\tchar\tpadchar\t\t! Pc, Z (' ')\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\n\n\tchar\tplus\t\t! (0)   0 or '+'\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\n\tchar\tcharmode\t! C,M (0)  0 or 'C' or 'M'\to/p int as int or single char or multi-char\n\tchar\theapmode\t! D (0)  'D' for str-functions, return ptr to heap string\n\tchar\tparam\t\t! Use int value for <fmtparam>\n\tbyte\tspare : (showtype:1, newline:1)\nend\n\nint fmtparam\t\t\t!as set with :'V'\n\nenumdata =\n\tstd_io,file_io,str_io\nend\n\nconst comma = ','\n\nexport int $cmdskip\t\t\t!0 unless set by READMCX/etc\n\nexport int needgap\t\t\t= 0\nint outdev\t\t\t= std_io\nfilehandle outchan\t= nil\nref char fmtstr \t= nil\n\nconst maxiostack=10\n[maxiostack]filehandle\toutchan_stack\n[maxiostack]int\t\t\toutdev_stack\n[maxiostack]ref char\tfmtstr_stack\n[maxiostack]byte\t\tneedgap_stack\n\n[maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\nint niostack=0\n\n[0:]char digits=A\"0123456789ABCDEF\"\nconst onesixty=360\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\n\n!Read buffer vars\nexport const rd_buffersize = 16384\t!total capacity of line buffer\n\nexport ref char rd_buffer\t\t! point to start of read buffer\nexport int rd_length\t\t\t! length of this line (as read by readln)\nexport ref char rd_pos\t\t\t! current position it's up to (next read starts here)\nexport ref char rd_lastpos\t\t! set by sread() just before reading used for reread()\n\nint termchar\t\t\t! terminator char set by readxxx()\nint itemerror\t\t\t!\tset by some read functions, eg for reals\n\n[4096]char printbuffer\nichar printptr\nint printlen\n\n!------------------------------------------\n\nexport int ncmdparams\n!export ref[]ichar cmdparams\nexport ref[0:]ichar cmdparams\n\nproc $getcommands(int ncmd, ref[0:]ichar cmds, int cmdskipL)=\n!CPL =$CMDSKIP\n!CPL =CMDSKIPL\n\tncmdparams:=ncmd-1\n\tcmdparams:=cmds\nend\n\n!export proc m$init(int nargs, ref[]ichar args)=\n!\tnsysparams:=nargs\n!\n!\tif nsysparams>maxparam then\n!\t\tprintf(\"Too many params\\n\")\n!\t\tstop 1\n!\tfi\n!\n!\tfor i:=1 to nargs do\n!\t\tsysparams[i]:=args[i]\n!\tod\n!\n!!assume nsysparams is >=1, since first is always the program name\n!\tncmdparams:=nsysparams-($cmdskip+1)\n!\tcmdparams:=cast(&sysparams[$cmdskip+1])\n!\n!\tint j:=1\n!\tnenvstrings:=0\n!!\twhile envstrings[j] do\n!!\t\t++nenvstrings\n!!\t\t++j\n!!\tod\n!\n!end\n\nproc pushio=\n\tif niostack>=maxiostack then\n\t\tprintf(\"Too many io levels\\n\")\n\t\tstop 53\n\tfi\n\t++niostack\n\toutchan_stack[niostack]\t:= outchan\n\toutdev_stack[niostack]\t:= outdev\n\tfmtstr_stack[niostack]\t:= fmtstr\n\tneedgap_stack[niostack]\t:= needgap\n\tneedgap:=0\n\tfmtstr:=nil\n\toutchan:=nil\nend\n\nexport proc m$print_startfile(ref void dev)=\n\tpushio()\n\toutchan:=cast(dev)\n\tif dev then\n\t\toutdev:=file_io\n\telse\n\t\toutdev:=std_io\n\tfi\n\tresetprintbuffer()\nend\n\nexport proc m$print_startstr(ref char s)=\n\tref ref char p\n\tpushio()\n\n\tptr_stack[niostack]:=s\n\tp:=&ptr_stack[niostack]\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startptr(ref ref char p)=\n\tpushio()\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startcon=\n\tpushio()\n\toutdev:=std_io\n\tresetprintbuffer()\nend\n\nexport proc m$print_setfmt(ref char format)=\n\tfmtstr:=format\nend\n\nexport proc m$print_end=\n\tneedgap:=0\n\tnextfmtchars(1)\n\tif niostack=1 and outdev in [std_io,file_io] then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif niostack=0 then return fi\n\toutchan\t:= outchan_stack[niostack]\n\toutdev\t:= outdev_stack[niostack]\n\tfmtstr\t:= fmtstr_stack[niostack]\n\tneedgap\t:= needgap_stack[niostack]\n\n\t--niostack\nend\n\nexport proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n\tif fmtstyle=nil then\n\t\tfmtstyle:=\"z8H\"\n\tfi\n\tm$print_u64(a,fmtstyle)\nend\n\nexport proc m$print_ptr_nf(u64 a)=\n\tm$print_ptr(a)\nend\n\nexport proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\tint n\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tif a>=0 then\n\t\t\tn:=u64tostr(a,&.s,10,0)\n\t\telsif a=i64.min then\n\t\t\tfmt:=defaultfmt\n\t\t\tdofmt\n\n\t\telse\n\t\t\ts[1]:='-'\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\n\t\tfi\n\n\t\tprintstr_n(&.s,n)\n\n\telse\n\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\tif fmt.param='V' then\n\t\t\tfmtparam:=a\n\t\t\tneedgap:=0\n\t\telse\ndofmt:\n\t\t\ttostr_i64(a,&fmt)\n\t\tfi\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_i64_nf(i64 a)=\n\tm$print_i64(a)\nend\n\nexport proc m$print_bool(i64 a, ichar fmtstyle=nil)=\n\tif a then\n\t\tm$print_str(\"True\",fmtstyle)\n\telse\n\t\tm$print_str(\"False\",fmtstyle)\n\tfi\nend\n\nexport proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%llu\",a)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_u64(a,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_r64(real x,ichar fmtstyle=nil)=\n\t[360]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%f\",x)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_r64(x,&fmt)\n\tfi\n\n\tneedgap:=1\nend\n\nexport proc m$print_r32(r32 x,ichar fmtstyle=nil)=\n\tm$print_r64(x,fmtstyle)\nend\n\nglobal proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n\t[32]char s\n!\tint cc@s\n\tfmtrec fmt\n\tint n\n\tbyte charmode:=0\n\n\tnextfmtchars()\n\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1, &fmt)\n\t\tcharmode:=fmt.charmode\n\tfi\n\n\tif charmode='M' then\n\t\tn:=domultichar(ref char(&a), 8, &.s, &fmt)\n!\t\tn:=domultichar(ref char(&a), 8, &.str, fmt)\n\telse\t\t\t\t\t\t!assume 'C'\n\t\t(ref int(&s)^):=a\t\n!\t\tcc:=a\t\n\t\ts[9]:=0\n\n\t\tn:=getutfsize(s)\t\t\t!isolate size of next char\n\tfi\n\n\tprintstr_n(s,n)\n\n\tneedgap:=1\nend\n\nexport proc m$print_str(ichar s, fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr(s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,-1,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr_n(s,length)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,length,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_str_nf(ichar s)=\n\tm$print_str(s)\nend\n\nexport proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\nABORTPROGRAM(\"PRTSL\")\n!\tnextfmtchars()\n!\n!!\tfmtrec fmt\n!\n!\tif fmtstyle=nil then\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\n!!\t\tprintstr_n(cast(ss.str),ss.length)\n!\telse\n!\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\n!!\t\tstrtofmt(fmtstyle,-1,&fmt)\n!!\t\ttostr_str(s,s.len,&fmt)\n!\tfi\n!\tneedgap:=1\nend\n\nexport proc m$print_newline=\n!PUTS(\"<NEWLINE>\")\n\tneedgap:=0\n\tnextfmtchars(1)\n\tprintstr(\"\\w\")\nend\n\nexport proc m$print_nogap=\n\tneedgap:=0\nend\n\nexport proc m$print_space=\n\tneedgap:=0\n\tprintstr(\" \")\nend\n\nexport proc printstr(ichar s)=\n\tprintstr_n(s,strlen(s))\nend\n\nexport proc printstr_n(ichar s,int n)=\n\n!\treturn when n=0\n\n!\tif niostack=1 and outdev in [std_io,file_io] then\n!!puts(\"ADDTO BUFF\")\n!\t\taddtobuffer(s,n)\n!\telse\n!printf(\"DUMPSTR %lld\\n\", n)\n\t\tdumpstr(s,n)\n!\tfi\nend\n\nexport proc printstrn_app(ichar s, int length, filehandle f=nil)=\nif length then\n\tif f=nil then\n\t\tprintf(\"%.*s\",length,s)\n\telse\n\t\tfprintf(f,\"%.*s\",length,s)\n\tfi\nfi\nend\n\nproc printchar(int ch)=\n\t[4]char str\n\n\tstr[1]:=ch\n\tstr[2]:=0\n\tprintstr_n(str,1)\nend\n\nglobal proc nextfmtchars(int lastx=0)=\n\tchar c\n\tref char pstart\n\tint n\n\tif not fmtstr then\t\t\t!format not in use\n\t\tif needgap then\n\t\t\tprintchar(' ')\n\t\tfi\n\t\tneedgap:=0\n\t\treturn\n\tfi\n\n\tpstart:=fmtstr\n\tn:=0\n\n\tdo\n\t\tc:=fmtstr^\n\t\tcase c\n\t\twhen '#' then\n\t\t\tif lastx then\n\t\t\t\tgoto skip\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\tfi\n\t\t\treturn\n\t\twhen 0 then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\telsif not lastx then\n\t\t\t\tprintstr_n(\"|\",1)\n\t\t\tfi\n\t\t\treturn\n\t\twhen '~' then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\t\tn:=0\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tc:=fmtstr^\n\t\t\tif c then\n\t\t\t\t++fmtstr\n\t\t\t\tprintchar(c)\n\t\t\tfi\n\t\t\tpstart:=fmtstr\n\t\telse\n\tskip:\n\t\t\t++n\n\t\t\t++fmtstr\n\t\tesac\n\tod\nend\n\nexport proc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\n!convert format code string in s, to fmtrec at fmt^\n!Format code is a string containing the following char codes (upper or lower when mostly)\n!n\tWidth\n!.n\tMax width/precision\n!A\tConvert to upper case\n!a\tConvert to lower case\n!B\tBinary\n!C\tShow int as single n-bit (unicode) character\n!D\tDuplicate string returned via STRINT etc on heap\n!E,F,G\tSpecify format for double (corresponds to C format codes)\n!F\n!G\n!H\tHex\n!JC\tJustify centre\n!JL\tJustify left\n!JR\tJustify right\n!M\tShow int as multi-bit (unicode) character\n!M\tHEAPMODE???\n!O\tOctal\n!Pc\tUse padding char c\n!Q\tAdd double quotes around string (and deal with embedded quotes)\n!'\tAdd single quotes around string (and deal with embedded quotes)\n!Sc\tUse separator char c between every 3 or 4 digits\n!Tc\tUse terminator char c (typically B or H)\n!U\tShow ints as unsigned\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\n!W\tUnsigned\n!Xn\tUse base n (n is hex 0 to F)\n!Z\tUse \"0\" padding\n!+\tAlways have + or - in front of integers\n!~\tQuote char is ~\n!*\tSame as n but uses parameter set with :'V' on previous int\n\n\tint c, base\n\tbyte wset\n\tint n\n\t[0:100]char str\n\n\tfmt^:=defaultfmt\n\n\tif s=nil then return fi\n\n\tif slen=-1 then slen:=strlen(s) fi\n\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\n\tstr[slen]:=0\n\ts:=&.str\n\n\twset:=0\n\twhile s^ do\n\t\tc:=s^\n\t\t++s\n\t\tif c='A' then fmt.lettercase:='A'\n\t\telsif c='a' then fmt.lettercase:='a'\n\t\telseswitch toupper(c)\n\t\twhen 'B' then fmt.base:=2\n\t\twhen 'H' then fmt.base:=16\n\t\twhen 'O' then fmt.base:=8\n\t\twhen 'X' then\n\t\t\tbase:=0\n\t\t\tdo\n\t\t\t\tc:=s^\n\t\t\t\tif c in '0'..'9' then\n\t\t\t\t\tbase:=base*10+c-'0'\n\t\t\t\t\t++s\n\t\t\t\telse\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\tod\n\t\t\tif base in 2..16 then\n\t\t\t\tfmt.base:=base\n\t\t\tfi\n\n\t\twhen 'Q' then fmt.quotechar:='\"'\n\t\twhen 'J' then\n\t\t\tfmt.justify:=toupper(s^)\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'Z' then fmt.padchar:='0'\n\t\twhen 'S' then\n\t\t\tfmt.sepchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'P' then\n\t\t\tfmt.padchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'T' then\n\t\t\tfmt.suffix:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'U' then fmt.usigned:='W'\n\t\twhen 'E' then fmt.realfmt:='e'\n\t\twhen 'F' then fmt.realfmt:='f'\n\t\twhen 'G' then fmt.realfmt:='g'\n\t\twhen 'D' then fmt.heapmode:='D'\n\t\twhen 'C' then fmt.charmode:='C'\n\t\twhen 'M' then fmt.charmode:='M'\n\t\twhen 'V' then fmt.param:='V'\n\t\twhen 'Y' then fmt.showtype:=1\n\t\twhen 'N' then fmt.newline:=1\n\t\telsecase c\n\t\twhen '.' then\n\t\t\twset:=1\n\t\twhen comma,'_' then fmt.sepchar:=c\n\t\twhen '+' then fmt.plus:='+'\n\t\twhen '~' then fmt.quotechar:='~'\n\t\twhen '*' then\n\t\t\tn:=fmtparam\n\t\t\tgoto gotwidth\n\t\telse\n\t\t\tif c>='0' and c<='9' then\n\t\t\t\tn:=c-'0'\n\t\t\t\tdo\n\t\t\t\t\tc:=s^\n\t\t\t\t\tif s^=0 then\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tif c>='0' and c<='9' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\tn:=n*10+c-'0'\n\t\t\t\t\telse\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\tod\ngotwidth:\n\t\t\t\tif not wset then\n\t\t\t\t\tfmt.minwidth:=n\n\t\t\t\t\twset:=1\n\t\t\t\telse\n\t\t\t\t\tfmt.precision:=n\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tod\nend\n\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\n!there are n (4 or 8) chars at p.!\n!There could be 0 to 4 or 8 printable chars converted to string at dest\n\t[0:20]char str\n\tref char q\n\tint nchars\n\n\tq:=&.str\n\n\tnchars:=n\n\n\tto n do\n\t\tif p^=0 then exit fi\n\t\tq^:=p^\n\t\t++q\n\t\t++p\n\tod\n\tq^:=0\n\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\nend\n\nexport function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\n!s contains a partly stringified value.\n!widen s if necessary, according to fmt, and copy result to t\n!n is current length of s\n!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving\n!a leading +/- when right-justifying with '0' padding.\n!t MUST be big enough for the expanded string; caller must take care of this\n!result will be zero-terminated, for use in this module\n\n\tint i,w,m\n\n!check to see if result is acceptable as it is\n\tw:=fmt.minwidth\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\n\t\tstrncpy(t,s,n)\n\t\t(t+n)^:=0\n\t\treturn n\n\tfi\n\n\tif fmt.justify='L' then\t! left-justify\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tfor i:=1 to w-n do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\telsif fmt.justify='R' then\n\t\tif fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside \n\t\t\tt^:=s^\n\t\t\t++t\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s+1,n-1)\n\t\t\t(t+n-1)^:=0\n\t\telse\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s,n)\n\t\t\t(t+n)^:=0\n\t\tfi\n\n\telse\t\t\t\t! centre-justify?\n\n\t\tm:=(w-n+1)/2\n\t\tto m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tto w-n-m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\n\tfi\n\treturn w\nend\n\nexport function u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\n!convert 64-bit int a to string in s^\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\n!result when a=minint (will give \"<minint>\")\n\t[0:onesixty]char t\n\tu64 dd\n\tint i,j,k,g\n\tref char s0\n\n\ti:=0\n\tk:=0\n\tg:=(base=10|3|4)\n\n\trepeat\n!\t\tif base=10 then\t\t\t!BUGGY FOR AA OVER I64.MAX\n!\t\t\tassem\n!\t\t\t\tmov\t\trcx, [aa]\n!\t\t\t\tmov\t\trax, rcx\n!\t\t\t\tmov\t\trdx, 7378697629483820647\n!\t\t\t\timul\trdx\n!\t\t\t\tmov\t\trax, rdx\n!\t\t\t\tmov\t\trdx, rcx\n!\t\t\t\tsar\t\trdx, 63\n!\t\t\t\tsar\t\trax, 2\n!\t\t\t\tsub\t\trax, rdx\n!\t\t\t\tlea\t\trdx, [rax+rax*4]\n!\t\t\t\tadd\t\trdx, rdx\n!\t\t\t\tsub\t\trcx, rdx\n!\t\t\t\tmov\t\t[dd], rcx\n!\t\t\t\tmov\t\t[aa], rax\n!\t\t\tend\n!\t\telse\n\t\t\tdd:=aa rem base\n\t\t\taa:=aa/base\n!\t\tfi\n\n\t\tt[++i]:=digits[dd]\n\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\n!out a full length binary\n!so perhaps move this out to expandstr\n\t\t++k\n\t\tif sep and aa<>0 and k=g then\n\t\t\tt[++i]:=sep\n\t\t\tk:=0\n\t\tfi\n\tuntil aa=0\n\n\tj:=i\n\ts0:=s\n\twhile i do\n\t\ts^:=t[i--]\n\t\t++s\n\tod\n\ts^:=0\n\n\treturn j\nend\n\nexport function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\n!convert a to a string in s, according to fmt\n!a basic conversion is done first,: the field manipulation is done\n!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)\n!returns length of s\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n, usigned\n\tconst i64 mindint=0x8000'0000'0000'0000\n\n\tusigned:=0\n\tif fmt.usigned then\n\t\tusigned:=1\n\tfi\n\tif aa=mindint and not usigned then\t\t! minint\n\n\t\tstr[0]:='-'\n\t\tn:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1\n\n\telse\n\t\tif (not usigned and aa<0) or fmt.plus then\n\t\t\tif aa<0 then\n\t\t\t\taa:=-aa\n\t\t\t\tstr[0]:='-'\n\t\t\telse\n\t\t\t\tstr[0]:='+'\n\t\t\tfi\n\t\t\tn:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1\n\t\telse\n\t\t\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\t\tfi\n\tfi\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'\tthen\t! need lower when\n\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\n!see i64tostrfmt\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n\n\n\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif fmt.base>10 or fmt.suffix and fmt.lettercase='a'\tthen\t! need lower when\n!\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\n!convert minint to string in s do not include minus sign\n!return number of chars in string\n\t[0:onesixty]char t\n\tint i,j,k,g\n\n\tcase base\n\twhen 10 then\n\t\tstrcpy(&t[0],\"9223372036854775808\")\n\t\tj:=3\n\twhen 16 then\n\t\tstrcpy(&t[0],\"8000000000000000\")\n\t\tj:=1\n\twhen 2 then\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\n\t\tj:=7\n\telse\n\t\tstrcpy(&t[0],\"<mindint>\")\n\tesac\n\n\ti:=strlen(&t[0])\n\ts+:=i\n\tif sep then\n\t\ts+:=j\n\tfi\n\ts^:=0\n\n\tk:=0\n\tg:=(base=10|3|4)\n\n\twhile i do\n\t\t--s\n\t\ts^:=t[i-- -1]\n\t\tif sep and i and ++k=g then\n\t\t\t--s\n\t\t\ts^:=sep\n\t\t\tk:=0\n\t\tfi\n\tod\n\treturn strlen(s)\nend\n\nexport function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\n!s is a string process according to fmtrec fmt^, and return result in t\n!caller should check whether any changes are required to s (now it can just use s), but this\n!check is done here anyway (with a simple copy to t)\n!n is current length of s\n!return length of t\n!Three processing stages:\n!1 Basic input string s\n!2 Additions or mods: quotes, suffix, when conversion\n!3 Width adjustment\n!1 is detected here, 2 is done here, 3 is done by expandstr\n\tref char u,v\n\t[256]char str\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\n\n\tnheap:=0\n\n\tif fmt.quotechar or fmt.lettercase then\t\t! need local copy\n\t\tif n<256 then\n\t\t\tu:=&.str\n\t\telse\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\n\t\t\tu:=pcm_alloc(nheap)\n\t\tfi\n\t\tif fmt.quotechar then\n\t\t\tv:=u\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tif n then\n\t\t\t\tstrcpy(v,s)\n\t\t\t\tv+:=n\n\t\t\tfi\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tv^:=0\n\t\t\tn+:=2\n\t\telse\n\t\t\tmemcpy(u,s,n)\n\t\tfi\n\t\tcase fmt.lettercase\n\t\twhen 'a' then\t! need lower when\n\t\t\tconvlcstring(u)\n\t\twhen 'A' then\n\t\t\tconvucstring(u)\n\t\tesac\n\t\ts:=u\n\tfi\n\n\tw:=fmt.minwidth\n\tif w>n then\n\t\tn:=expandstr(s,t,n,fmt)\n\telse\n\t\tmemcpy(t,s,n)\n\tfi\n\tif nheap then\n\t\tpcm_free(u,nheap)\n\tfi\n\treturn n\nend\n\nproc tostr_i64(i64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 0 then\n\t\tn:=i64tostrfmt(a,&.str,fmt)\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\telse\t\t\t\t\t\t!assume 'C'\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_u64(u64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\twhen 'C' then\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\n\telse\n\t\tn:=u64tostrfmt(a,&.str,fmt)\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_r64(real x,ref fmtrec fmt) =\n\t[360]char str,str2\n\t[0:10]char cfmt\n\tint n\n\n\tcfmt[0]:='%'\n\n\tif fmt.precision then\n\t\tcfmt[1]:='.'\n\t\tcfmt[2]:='*'\n\t\tcfmt[3]:=fmt.realfmt\n\t\tcfmt[4]:=0\n\t\tsprintf(&.str,&.cfmt,fmt.precision,x)\n\telse\n\t\tcfmt[1]:=fmt.realfmt\n\t\tcfmt[2]:=0\n\t\tsprintf(&.str,&.cfmt,x)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\n\tn:=strlen(&.str)\t\t! current length\n\n\tif n<fmt.minwidth then\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\n\t\tstrcpy(&.str,&.str2)\n\tfi\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_str(ref char s, int oldlen, ref fmtrec fmt) =\n\tint newlen,n\n\tref char t\n\n!try and work out size of formatted string\n\tif oldlen=-1 then\n\t\toldlen:=strlen(s)\n\tfi\n\tnewlen:=oldlen\n\n\tif fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then\n\t\tif fmt.quotechar then\n\t\t\tnewlen+:=2\n\t\tfi\n\t\tif fmt.minwidth>newlen then\n\t\t\tnewlen:=fmt.minwidth\n\t\tfi\n\t\tt:=pcm_alloc(newlen+1)\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\n\t\tif fmt.precision then\n\t\t\tn min:=fmt.precision\n\t\tfi\n\n\t\tprintstr_n(t,n)\n\t\tpcm_free(t,newlen+1)\n\telse\n\t\tprintstr_n(s,oldlen)\n\tfi\nend\n\nfunction getfmt(ichar fmtstyle)ref fmtrec=\n\tstatic fmtrec fmt\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\treturn &fmt\n\telse\n\t\treturn &defaultfmt\n\tfi\nend\n\nexport function strint(i64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport proc getstrint(i64 a, ichar dest)=\n\tm$print_startstr(dest)\n\ttostr_i64(a,getfmt(nil))\n\tm$print_end()\nend\n\nexport function strword(u64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function strreal(real a, ichar fmtstyle=nil)ichar=\n\tstatic [320]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function getstr(ichar s, ref fmtrec fmt)ichar=\n\tif fmt.heapmode then\n\t\treturn pcm_copyheapstring(s)\n\telse\n\t\treturn s\n\tfi\nend\n\nproc initreadbuffer=\n\tif rd_buffer then return fi\n\trd_buffer:=pcm_alloc(rd_buffersize)\n\trd_buffer^:=0\n\trd_pos:=rd_lastpos:=rd_buffer\nend\n\nglobal proc m$read_conline=\n\tinitreadbuffer()\n\n\treadlinen(nil,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_fileline(filehandle f)=\n\tinitreadbuffer()\n\n\tif f=filehandle(1) then\nABORTPROGRAM(\"READ CMDLINE\")\n!\t\trd_buffer^:=0\n!\t\tp:=getcommandlinea()\n!\t\trepeat\n!\t\t\t++p\n!\t\tuntil p^ in [' ','\\t',0]\n!\t\tstrcpy(rd_buffer, p)\n!\t\trd_length:=strlen(rd_buffer)\n!\t\trd_pos:=rd_buffer\n!\t\trd_lastpos:=nil\n\t\treturn\n\tfi\n\n\treadlinen(f,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_strline(ichar s)=\n\tint n\n\n\tinitreadbuffer()\n\tn:=strlen(s)\n\n\tif n<rd_buffersize then\n\t\tstrcpy(rd_buffer,s)\n\telse\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\n\t\t(rd_buffer+rd_buffersize-1)^:=0\n\tfi\n\trd_length:=n\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nfunction readitem(int &itemlength)ref char =\n!read next item from rd_buffer\n!identify a substring that can contain a name, int, real, string or filename\n!return updated position of s that points past the item and past the immediate\n!terminator \n!information about the read item is returned in itemstr, which points to\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\n!Item can be quoted, then the item points inside the quotes\n!Any embedded quotes are removed, and the characters moved up. The item will\n!be that reduced subsequence\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\n!I can mitigate this by adding spaces between the end of the item, and the next item,\n!overwriting also the terminator. But this won't restore the line if one of the next\n!reads is literal, using 'L' or 'C' codes.\n\tref char p,s,itemstr\n\tchar quotechar, c\n\n\tunless rd_buffer then \n\t\tinitreadbuffer()\n\tend unless\n\n\ts:=rd_pos\n\n!scan string, eliminating leading white space\n\twhile s^=' ' or s^=9 do\n\t\t++s\n\tod\n\n\titemstr:=s\n\trd_lastpos:=rd_pos:=s\n\n\tif s^=0 then\n\t\ttermchar:=0\n\t\titemlength:=0\n\t\treturn s\n\tfi\n\n\tquotechar:=0\n\tif s^='\"' then\n\t\tquotechar:='\"'\n\t\t++s\n\telsif s^='\\'' then\n\t\tquotechar:='\\''\n\t\t++s\n\tfi\n\n!loop reading characters until separator or end reached\n\tp:=itemstr:=s\n\n\twhile s^ do\n\t\tc:=s++^\n\t\tcase c\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\n\t\t\t\tgoto normalchar\n\t\t\tfi\n\t\t\ttermchar:=c\n\t\t\texit\n\t\telse\n\tnormalchar:\n\t\t\tif c=quotechar then\n\t\t\t\tif s^=quotechar then\t! embedded quote\n\t\t\t\t\tp^:=c\n\t\t\t\t\t++s\n\t\t\t\t\t++p\n\t\t\t\telse\t\t\t\t\t! end of name\n\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tif termchar in [',', '='] then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tfi\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tp^:=c\n\t\t\t\t++p\n\t\t\tfi\n\t\tesac\n\tod\n\n\tif s^=0 then\n\t\ttermchar:=0\n\tfi\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\n\trd_pos:=s\n\n\treturn itemstr\nend\n\nexport function strtoint(ichar s,int length=-1, word base=10)i64=\n!return point to next char after terminator (which can be just off length of string)\n\tbyte signd\n\tu64 aa\n\tword c,d\n\n\titemerror:=0\n\n\tif length=-1 then\n\t\tlength:=strlen(s)\n\tfi\n!check for sign\n\tsignd:=0\n\tif length and s^='-' then\n\t\tsignd:=1; ++s; --length\n\telsif length and s^='+' then\n\t\t++s; --length\n\tfi\n\n\taa:=0\n\twhile length do\n\t\tc:=s++^\n\t\t--length\n\t\tif c in 'A'..'F' then d:=c-'A'+10\n\t\telsif c in 'a'..'f' then d:=c-'a'+10\n\t\telsif c in '0'..'9' then d:=c-'0'\n\t\telsif c in ['_', '\\''] then\n\t\t\tnextloop\n\t\telse\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\n\t\tif d>=base then\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\t\taa:=aa*base+d\n\tod\n\n\tif signd then\n\t\treturn -aa\n\telse\n\t\treturn aa\n\tfi\nend\n\nglobal function m$read_i64(int fmt=0)i64=\n\tref char s\n\tint length\n\n\tfmt:=toupper(fmt)\n\n\tcase fmt\n\twhen 'C' then\n\t\trd_lastpos:=rd_pos\n\t\tif rd_pos^ then\n\t\t\treturn rd_pos++^\n\t\telse\n\t\t\treturn 0\n\t\tfi\n\twhen 'T' then\n\t\treturn termchar\n\twhen 'E' then\n\t\treturn itemerror\n\tesac\n\n\ts:=readitem(length)\n\n\tcase fmt\n\twhen 0,'I' then\n\t\treturn strtoint(s,length)\n\twhen 'B' then\n\t\treturn strtoint(s,length,2)\n\twhen 'H' then\n\t\treturn strtoint(s,length,16)\n\tesac\n\treturn 0\nend\n\nglobal function m$read_r64(int fmt=0)real=\n\t[512]char str\n\tref char s\n\tint length\n\ti32 numlength\n\treal x\n\n\ts:=readitem(length)\n\n\tif length=0 or length>=str.len then\t\t!assume not a real\n\t\treturn 0.0\n\tfi\n\tmemcpy(&.str,s,length)\n\tstr[length+1]:=0\n\n\titemerror:=0\n\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\n\t\tx:=0.0\n\t\titemerror:=1\n\tfi\n\n\treturn x\nend\n\nglobal proc m$read_str(ref char dest, int destlen=0,fmt=0)=\n\tref char s\n\tint length\n\n\titemerror:=0\n\tif fmt in ['L','l'] then\n\t\ts:=rd_pos\n\t\tlength:=rd_buffer+rd_length-rd_pos\n\n\telse\n\t\ts:=readitem(length)\n\n\t\tif fmt in ['N','n'] then\n\t\t\ticonvlcn(s,length)\n\t\tfi\n\tfi\n\n\tif destlen>0 then\n\t\tif length>=destlen then\n\t\t\tlength:=destlen-1\n\t\t\titemerror:=1\n\t\tfi\n\tfi\n\tmemcpy(dest,s,length)\n\t(dest+length)^:=0\nend\n\nexport proc readstr(ref char dest, int fmt=0,destlen=0)=\n\tm$read_str(dest,destlen,fmt)\nend\n\nexport proc rereadln=\n\trd_pos:=rd_buffer\n\trd_lastpos:=rd_pos\nend\n\nexport proc reread=\n\trd_pos:=rd_lastpos\nend\n\nexport function valint(ichar s, int fmt=0)i64=\n\tref char old_pos, old_lastpos\n\ti64 aa\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\taa:=m$read_i64(fmt)\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn aa\nend\n\nexport function valreal(ichar s)real=\n\tref char old_pos, old_lastpos\n\treal x\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\tx:=m$read_r64()\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn x\nend\n\nproc mclunimpl(ichar mess)=\n\tprintf(\"MCL-UNIMPL: %s\\n\",mess)\n\tstop 1\nend\n\nproc dumpstr(ichar s, int n, fbuffer=0)=\n!fbuffer=1 when outputting contents of buffer\n\n\tref ref char p\n\n\tif outdev=str_io then\n\t\tp:=cast(outchan)\n\t\tif n then\n\t\t\tmemcpy(p^,s,n)\n\t\t\tp^+:=n\n\t\tfi\n\t\tp^^:=0\n\t\treturn\n\tfi\n\n\treturn when n=0\n\tif fbuffer and n>=2 and outdev=std_io then\n\t\t--printptr\t\t\t\t!point to last char\n\t\tif printptr^=10 then\n\t\t\tif (printptr-1)^=13 then\t\t!crlf\n\t\t\t\t(printptr-1)^:=0\n\t\t\telse\t\t\t\t\t\t\t!lf only\n\t\t\t\tprintptr^:=0\n\t\t\tfi\n\t\t\tputs(printbuffer)\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\tesac\nend\n\nproc dumpprintbuffer=\n\tif printlen then\n\t\tdumpstr(&.printbuffer,printlen,1)\n\tfi\n\n\tresetprintbuffer()\nend\n\nproc resetprintbuffer=\n\tprintptr:=&.printbuffer\n\tprintlen:=0\nend\n\nproc addtobuffer(ichar s, int n)=\n\tif printlen+n>=(printbuffer.len-8) then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif n<printbuffer.len then\n\t\tmemcpy(printptr,s,n)\n\t\tprintptr+:=n\n\t\tprintlen+:=n\n\t\treturn\n\tfi\n\n\tdumpstr(s, n)\t\t\t!don't bother with buffer\nend\n\nfunc getutfsize(ref char s)int =\n!work out the size in bytes of the ascii or utf8 character that s points to\n\tint a\n\n\ta:=s++^\n\n\tif a=0 then\t\t\t\t\t\t!end of string\n\t\t0\n\telsif a.[7]=0 then\t\t\t\t!ascii\n\t\t1\n\telsif a.[7..5]=2x110 then\n\t\t2\n\telsif a.[7..4]=2x1110 then\n\t\t3\n\telsif a.[7..3]=2x11110 then\n\t\t4\n\telse\t\t\t\t\t\t\t!error: just assume a byte of random binary\n\t\t1\n\tfi\nend\n\n!export fun fraction(real x)real = fmod(x,1.0)\n\nexport fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))\n\nexport func m$sign_r64(real x)real =\n\tif x<0 then return -1 fi\n\tif x>0 then return 1 fi\n\t0\nend\n",
(u64)"!import clib\n!export type filehandle=ref void\n\n!importdll $cstd=\nimportdll msvcrt=\n\tfunc malloc\t(u64)ref void\n\tproc free\t\t(ref void)\n!\tfunc pow\t\t(real,real)real\n!\n\tfunc printf (ref char,...)i32\n!\tfunc fprintf (ref void,ref char,...)i32\n\tfunc puts (ref char)i32\n\tproc `exit(i32)\n\tfunc getchar\t:i32\n\tproc memcpy\t\t(ref void, ref void, word)\n\tproc memset\t\t(ref void, i32, u64)\n\tfunc strlen\t\t(ichar)u64\n\tfunc strcpy\t\t(ichar,ichar)ichar\n\tfunc strcat\t\t(ichar,ichar)ichar\n\tfunc strcmp\t\t(ichar,ichar)i32\n\n\tfunc _strdup\t(ichar)ichar\nend\n\nexport macro strdup=_strdup\n\n!export proc free(ref void) = end\n\n\nint needgap\n\n!proc start=\n!\tCPL \"MIN/START\"\n!end\n\n\nglobal proc m$print_startcon=\nend\n\nglobal proc m$print_end=\n\tneedgap:=0\nend\n\n!global proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n!!\tnextfmtchars()\n!\tprintf(\"%p\",a)\n!\tneedgap:=1\n!end\n\nglobal proc m$print_ptr_nf(u64 a)=\n\tnextfmtchars()\n\tprintf(\"%p\",a)\n\tneedgap:=1\nend\n!\n!global proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%lld\",a)\n!\tneedgap:=1\n!end\n\n!global proc m$print_i128(i64 a,ichar fmtstyle=nil)=\n!\tputs(\"<128>\")\n!!\tnextfmtchars()\n!!\tprintf(\"%lld\",a)\n!!\tneedgap:=1\n!end\n\nglobal proc m$print_i64_nf(i64 a)=\n!puts(\"PRINTI64_nf\")\n\tnextfmtchars()\n\tprintf(\"%lld\",a)\n\tneedgap:=1\nend\n\nglobal proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%llu\",a)\n\tneedgap:=1\nend\n\nglobal proc m$print_r64(real x,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%f\",x)\n\tneedgap:=1\nend\n\nglobal proc m$print_r32(real x,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%f\",x)\n\tneedgap:=1\nend\n\n!global proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%c\",a)\n!\tneedgap:=1\n!end\n!\n!global proc m$print_str(ichar s, fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%s\",s)\n!\tneedgap:=1\n!end\n\nglobal proc m$print_str_nf(ichar s)=\n\tnextfmtchars()\n\tprintf(\"%s\",s)\n\tneedgap:=1\nend\n\nglobal proc m$print_space=\n\tneedgap:=0\n\tprintf(\" \")\nend\n\nglobal proc m$print_newline=\n\tneedgap:=0\n\tprintf(\"\\n\")\nend\n\nglobal proc m$unimpl=\n\tputs(\"Sysfn unimpl\")\n\tstop 1\nend\n\nglobal proc m$print_nogap=\n\tneedgap:=0\nend\n\n!global proc nextfmtchars(int lastx=0)=\nglobal proc nextfmtchars=\n\tif needgap then\n\t\tprintf(\" \")\n\t\tneedgap:=0\n\tfi\nend\n\n!global proc m$stop(int stopcode)=\n!\t`exit(stopcode)\n!end\n!\n!global func strint(i64 a, ichar fmtstyle=nil)ichar=\n!\treturn \"?\"\n!end\n!\n\n!global function m$power_i64(i64 a,n)i64=\n!\tif n<0 then\n!\t\treturn 0\n!\telsif n=0 then\n!\t\treturn 1\n!\telsif n=1 then\n!\t\treturn a\n!\telsif (n iand 1)=0 then\n!\t\treturn m$power_i64(sqr a,n/2)\n!\telse\t\t\t!assume odd\n!\t\treturn m$power_i64(sqr a,(n-1)/2)*a\n!\tfi\n!end\n!\n!\n",
(u64)"!const mem_check=1\nconst mem_check=0\n\nglobal [0..300]u64 allocupper\nglobal int alloccode\t\t\t\t!set by heapalloc\nexport int allocbytes\t\t\t\t!set by heapalloc\nexport int fdebug=0\nexport int rfsize\n\nconst threshold=1<<25\nconst alloc_step=1<<25\nword maxmemory\nint  maxalloccode\n\n!GLOBAL REF VOID ALLOCBASE\n\nbyte pcm_setup=0\n\nint show=0\n\nglobal int memtotal=0\nexport i64 smallmemtotal=0\nglobal int smallmemobjs=0\nglobal int maxmemtotal=0\n\n!store all allocated pointers\nconst int maxmemalloc=(mem_check|500000|2)\n[maxmemalloc+1]ref i32 memalloctable\n[maxmemalloc+1]i32 memallocsize\n\nconst pcheapsize=1048576*2\nref byte pcheapstart\nref byte pcheapend\t\t\t!points to first address past heap\nref byte pcheapptr\n\nconst int maxblockindex = 8 \t\t!2048\nexport const int maxblocksize = 2048\nexport const int $maxblocksizexx = 2048\n\n[0:maxblocksize+1]byte sizeindextable\t!convert byte size to block index 1..maxblockindex\n\nconst int size16   = 1\t\t\t!the various index codes\nconst int size32   = 2\nconst int size64   = 3\nconst int size128  = 4\nconst int size256  = 5\nconst int size512  = 6\nconst int size1024 = 7\nconst int size2048 = 8\n\nexport [0:9]ref word freelist\n\nexport record strbuffer =\n\tichar strptr\n\ti32 length\n\ti32 allocated\nend\n\nexport enumdata [0:]ichar pmnames=\n\t(pm_end=0,\t\t$),\n\t(pm_option,\t\t$),\n\t(pm_sourcefile,\t$),\n\t(pm_libfile,\t$),\n\t(pm_colon,\t\t$),\n\t(pm_extra,\t\t$),\nend\n\n[2]int seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)\n\n!PROC START=\n!CPL \"MLIB START\"\n!END\n\n\nexport function pcm_alloc(int n)ref void =\n\tref byte p\n\n\n\tif not pcm_setup then\n\t\tpcm_init()\n\tfi\n\n!GOTO DOLARGE\n\n\tif n>maxblocksize then\t\t\t!large block allocation\n!DOLARGE:\n\t\talloccode:=pcm_getac(n)\n\t\tallocbytes:=allocupper[alloccode]\n\n\t\tp:=allocmem(allocbytes)\n\t\tif not p then\n\t\t\tabortprogram(\"pcm_alloc failure\")\n\t\tfi\n\n\t\treturn p\n\tfi\n\n!CPL \"DOSMALL\"\n\n\talloccode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\tallocbytes:=allocupper[alloccode]\n!\tsmallmemtotal+:=allocbytes\n\n\tif p:=ref byte(freelist[alloccode]) then\t\t!Items of this block size available\n\t\tfreelist[alloccode]:=ref word(int((freelist[alloccode])^))\n\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\tp:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\n\tpcheapptr+:=allocbytes\t\t\t!Shrink remaining pool\n\n\tif pcheapptr>=pcheapend then\t\t!Overflows?\n\t\tp:=pcm_newblock(allocbytes)\t\t!Create new heap block, and allocate from start of that\n\t\treturn p\n\tfi\n\n\treturn p\nend\n\nexport proc pcm_free(ref void p,int n) =\n!n can be the actual size requested it does not need to be the allocated size\n\tint acode\n\n\treturn when n=0 or p=nil\n\n\tif n>maxblocksize then\t\t!large block\n\t\tfree(p)\n\telse\n\t\tacode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\t\tcast(p,ref word)^:=word(int(freelist[acode]))\n\t\tfreelist[acode]:=p\n\tfi\nend\n\nexport proc pcm_freeac(ref void p,int alloc) =\n\tpcm_free(p,allocupper[alloc])\nend\n\nexport proc pcm_clearmem(ref void p,int n) =\n\tmemset(p,0,n)\nend\n\nexport proc pcm_init =\n!set up sizeindextable too\n\tint j, k\n\ti64 size\n\tconst limit=1<<33\n\n\talloccode:=0\n\tif pcm_setup then\n\t\treturn\n\tfi\n\n\tpcm_newblock(0)\n\n\tfor i to maxblocksize do\t!table converts eg. 78 to 4 (4th of 16,32,64,128)\n\t\tj:=1\n\t\tk:=16\n\t\twhile i>k do\n\t\t\tk:=k<<1\n\t\t\t++j\n\t\tod\n\t\tsizeindextable[i]:=j\n\tod\n\n\tallocupper[1]:=16\n\tsize:=16\n\n\tfor i:=2 to 27 do\n\t\tsize*:=2\n\t\tallocupper[i]:=size\n\t\tif size>=threshold then\n\t\t\t\tk:=i\n\t\t\texit\n\t\tfi\n\tod\n\n\tfor i:=k+1 to allocupper.upb do\n\t\tsize+:=alloc_step\n\t\tif size<limit then\n\t\t\tallocupper[i]:=size\n\t\t\tmaxmemory:=size\n\t\telse\n\t\t\tmaxalloccode:=i-1\n\t\t\texit\n\t\tfi\n\t\t\n\tod\n\tpcm_setup:=1\nend\n\nexport function pcm_getac(int size)int =\n! convert linear blocksize from 0..approx 2GB to 8-bit allocation code\n\n!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]\t\t!size 0 to 2KB\n\tfi\n\n\tsize:=(size+255)>>8\t\t\t\t\t!scale by 256\n\n!now same sizetable can be used for 2KB to 512KB (288 to 2KB)\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+8\n\tfi\n\n!sizetable now used for 512KB to 128MB (to 2KB)\n\tsize:=(size+63)>>6\t\t\t\t\t!scale by 256\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+14\n\tfi\n\n!size>2048, which means it had been over 128MB.\n\tsize:=(size-2048+2047)/2048+22\n\treturn size\nend\n\nexport function pcm_newblock(int itemsize)ref void=\n!create new heap block (can be first)\n!also optionally allocate small item at start\n!return pointer to this item (and to the heap block)\n\tstatic int totalheapsize\n\tref byte p\n\n\ttotalheapsize+:=pcheapsize\n\talloccode:=0\n\tp:=allocmem(pcheapsize)\t!can't free this block until appl terminates\n\tif p=nil then\n\t\tabortprogram(\"Can't alloc pc heap\")\n\tfi\n\tmemset(p,0,pcheapsize)\n\n\tpcheapptr:=p\n\tpcheapend:=p+pcheapsize\n\n\tif pcheapstart=nil then\t\t!this is first block\n\t\tpcheapstart:=p\n\tfi\n\tpcheapptr+:=itemsize\n\treturn ref u32(p)\nend\n\nexport function pcm_round(int n)int =\n!for any size n, return actual number of bytes that would be allocated\n\tstatic [0:maxblockindex+1]i32 allocbytes=(0,16,32,64,128,256,512,1024,2048)\n\n\tif n>maxblocksize then\n\t\treturn n\n\telse\n\t\treturn allocbytes[sizeindextable[n]]\n\tfi\nend\n\nexport function pcm_allocz(int n)ref void =\n\tref void p\n\tp:=pcm_alloc(n)\n\n\tmemset(p,0,n)\n\treturn p\nend\n\nexport function pcm_copyheapstring(ref char s)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tint n\n\tif s=nil then return nil fi\n\n\tn:=strlen(s)+1\n\tq:=pcm_alloc(n)\n\tmemcpy(q,s,n)\n\treturn q\nend\n\nexport function pcm_copyheapstringn(ref char s,int n)ref char =\n\tref char q\n\tif s=nil then return nil fi\n\n\tq:=pcm_alloc(n+1)\n\tmemcpy(q,s,n)\n\t(q+n)^:=0\n\treturn q\nend\n\nexport function pcm_copyheapblock(ref char s, int length)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tif length=0 then return nil fi\n\n\tq:=pcm_alloc(length)\n\tmemcpy(q,s,length)\n\treturn q\nend\n\nexport function allocmem(int n)ref void =\n\tref void p\n\n\tp:=malloc(n)\n\tif p then\n\t\treturn p\n\tfi\n\tprintln n,memtotal\n\tabortprogram(\"Alloc mem failure\")\n\treturn nil\nend\n\nglobal function reallocmem(ref void p,int n)ref void =\n\tp:=realloc(p,n)\n\treturn p when p\n\tprintln n\n\tabortprogram(\"Realloc mem failure\")\n\treturn nil\nend\n\nexport proc abortprogram(ref char s) =\n\tprintln s\n\tprint   \"ABORTING: Press key...\"\n!os_getch()\n\tstop 5\nend\n\nexport function getfilesize(filehandle handlex)int=\n\tu32 p,size\n\n\tp:=ftell(handlex)\t\t!current position\n\tfseek(handlex,0,2)\t\t!get to eof\n\tsize:=ftell(handlex)\t\t!size in bytes\n\tfseek(handlex,p,seek_set)\t!restore position\n\treturn size\nend\n\nexport proc readrandom(filehandle handlex, ref byte memx, int offset, size) =\n\tint a\n\tfseek(handlex,offset,seek_set)\n\ta:=fread(memx,1,size,handlex)\t\t\t!assign so as to remove gcc warning\nend\n\nexport function writerandom(filehandle handlex, ref byte memx, int offset,size)int =\n\tfseek(handlex,offset,seek_set)\n\treturn fwrite(memx,1,size,handlex)\nend\n\nexport function setfilepos(filehandle file,int offset)int=\n\treturn fseek(file,offset,0)\nend\n\nexport function getfilepos(filehandle file)int=\n\treturn ftell(file)\nend\n\nexport function readfile(ref char filename)ref byte =\n\tfilehandle f\n\tint size\n\tref byte m,p\n\n\tf:=fopen(filename,\"rb\")\n\tif f=nil then\n\t\treturn nil\n\tfi\n\trfsize:=size:=getfilesize(f)\n\n\tm:=malloc(size+2)\t\t!allow space for etx/zeof etc\n\n\tif m=nil then\n\t\treturn nil\n\tfi\n\n\treadrandom(f,m,0,size)\n\tp:=m+size\t\t\t!point to following byte\n\t(ref u16(p)^:=0)\t!add two zero bytes\n\n\tfclose(f)\n\treturn m\nend\n\nexport function writefile(ref char filename,ref byte data,int size)int =\n\tfilehandle f\n\tint n\n\n\tf:=fopen(filename,\"wb\")\n\tif f=nil then\n\t\treturn 0\n\tfi\n\n\tn:=writerandom(f,data,0,size)\n\tfclose(f)\n\treturn n\nend\n\nexport function checkfile(ref char file)int=\n\tfilehandle f\n\tif f:=fopen(file,\"rb\") then\n\t\tfclose(f)\n\t\treturn 1\n\tfi\n\treturn 0\nend\n\nexport proc readlinen(filehandle handlex,ref char buffer,int size) =\n!size>2\n\tint ch\n\tref char p\n\tint n\n\tbyte crseen\n\n\tif handlex=nil then\n\t\thandlex:=filehandle(os_getstdin())\n\tfi\n\tif handlex=nil then\n\t\tn:=0\n\t\tp:=buffer\n\t\tdo\n\t\t\tch:=getchar()\n\t\t\tif ch=13 or ch=10 or ch=-1 then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\t\tp++^:=ch\n\t\t\t++n\n\t\t\tif n>=(size-2) then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\tod\n\tfi\n\n\tbuffer^:=0\n\tif fgets(buffer,size-2,handlex)=nil then\n\t\treturn\n\tfi\n\n\tn:=strlen(buffer)\n\tif n=0 then\n\t\treturn\n\tfi\n\n\tp:=buffer+n-1\t\t!point to last char\n\tcrseen:=0\n\twhile (p>=buffer and (p^=13 or p^=10)) do\n\t\tif p^=13 or p^=10 then crseen:=1 fi\n\t\tp--^ :=0\n\tod\n\n!NOTE: this check doesn't work when a line simply doesn't end with cr-lf\n\n\tif not crseen and (n+4>size) then\n\t\tcpl size,n\n\t\tabortprogram(\"line too long\")\n\tfi\nend\n\nexport proc iconvlcn(ref char s,int n) =\n\tto n do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\nend\n\nexport proc iconvucn(ref char s,int n) =\n\tto n do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\nend\n\nexport function convlcstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function convucstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function changeext(ref char s,newext)ichar=\n!whether filespec has an extension or not, change it to newext\n!newext should start with \".\"\n!return new string (locally stored static string, so must be used before calling again)\n\tstatic [260]char newfile\n\t[32]char newext2\n\tref char sext\n\tint n\n\n\tstrcpy(&newfile[1],s)\n\n\tcase newext^\n\twhen 0 then\n\t\tnewext2[1]:=0\n\t\tnewext2[2]:=0\n\twhen '.' then\n\t\tstrcpy(&newext2[1],newext)\n\telse\n\t\tstrcpy(&newext2[1],\".\")\n\t\tstrcat(&newext2[1],newext)\n\tesac\n\n\n\tsext:=extractext(s,1)\t\t\t!include \".\" when it is only extension\n\n\tcase sext^\n\twhen 0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[1])\n\twhen '.' then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[2])\n\telse\t\t\t\t\t\t\t!has extension\n\t\tn:=sext-s-2\t\t\t!n is number of chars before the \".\"\n\t\tstrcpy(&newfile[1]+n+1,&newext2[1])\n\tesac\n\n\treturn &newfile[1]\nend\n\nexport function extractext(ref char s,int period=0)ichar=\n!if filespec s has an extension, then return pointer to it otherwise return \"\"\n!if s ends with \".\", then returns \".\"\n\tref char t,u\n\n\tt:=extractfile(s)\n\n\tif t^=0 then\t\t\t!s contains no filename\n\t\treturn \"\"\n\tfi\n\n!t contains filename+ext\n\tu:=t+strlen(t)-1\t\t!u points to last char of t\n\n\twhile u>=t do\n\t\tif u^='.' then\t\t!start extension found\n\t\t\tif (u+1)^=0 then\t\t!null extension\n\t\t\t\treturn (period|\".\"|\"\")\n\t\t\tfi\n\t\t\treturn u+1\t\t\t!return last part of filename as extension exclude the dot\n\t\tfi\n\t\t--u\n\tod\n\treturn \"\"\t\t\t!no extension seen\nend\n\nexport function extractpath(ref char s)ichar=\n\tstatic [0:260]char str\n\tref char t\n\tint n\n\n\tt:=s+strlen(s)-1\t\t!t points to last char\n\n\twhile (t>=s) do\n\t\tcase t^\n\t\twhen '\\\\','/',':' then\t\t!path separator or drive letter terminator assume no extension\n\t\t\tn:=t-s+1\t\t\t!n is number of chars in path, which includes rightmost / or \\ or :\n\t\t\tmemcpy(&.str,s,n)\n\t\t\tstr[n]:=0\n\t\t\treturn &.str\n\t\tesac\n\t\t--t\n\tod\n\treturn \"\"\t\t\t!no path found\nend\n\nexport function extractfile(ref char s)ichar=\n\tref char t\n\n\tt:=extractpath(s)\n\n\tif t^=0 then\t\t\t!s contains no path\n\t\treturn s\n\tfi\n\n\treturn s+strlen(t)\t\t!point to last part of s that contains the file\n\tend\n\nexport function extractbasefile(ref char s)ichar=\n\tstatic [0:100]char str\n\tref char f,e\n\tint n,flen\n\n\tf:=extractfile(s)\n\tflen:=strlen(f)\n\tif flen=0 then\t\t!s contains no path\n\t\treturn \"\"\n\tfi\n\te:=extractext(f,0)\n\n\tif e^ then\t\t\t!not null extension\n\t\tn:=flen-strlen(e)-1\n\t\tmemcpy(&str,f,n)\n\t\tstr[n]:=0\n\t\treturn &.str\n\tfi\n\tif (f+flen-1)^='.' then\n\t\tmemcpy(&str,f,flen-1)\n\t\tstr[flen-1]:=0\n\t\treturn &.str\n\tfi\n\treturn f\nend\n\nexport function addext(ref char s,ref char newext)ichar=\n!when filespec has no extension of its own, add newext\n\tref char sext\n\n\tsext:=extractext(s,1)\n\n\tif sext^=0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\treturn changeext(s,newext)\n\tfi\n\n\treturn s\t\t\t\t\t\t\t!has own extension; use that\nend\n\nexport function pcm_alloc32:ref void =\n\tref byte p\n\n\tallocbytes:=32\n!\tsmallmemtotal+:=32\n\n\tif p:=ref byte(freelist[2]) then\t\t!Items of this block size available\n\t\tfreelist[2]:=ref word(int((freelist[2])^))\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\treturn pcm_alloc(32)\nend\n\nexport proc pcm_free32(ref void p) =\n!n can be the actual size requested it does not need to be the allocated size\n\n!\tsmallmemtotal-:=32\n\n\tcast(p,ref word)^:=word(int(freelist[2]))\n\tfreelist[2]:=p\nend\n\nexport proc outbyte(filehandle f,int x)=\n\tfwrite(&x,1,1,f)\nend\n\nexport proc outu16(filehandle f,word x)=\n\tfwrite(&x,2,1,f)\nend\n\nexport proc outu32(filehandle f,word x)=\n\tfwrite(&x,4,1,f)\nend\n\nexport proc outu64(filehandle f,u64 x)=\n\tfwrite(&x,8,1,f)\nend\n\nexport proc outstring(filehandle f, ichar s)=\n\tfwrite(s,strlen(s)+1,1,f)\nend\n\nexport proc outblock(filehandle f, ref void p, int n)=\n\tfwrite(p,n,1,f)\nend\n\nexport function myeof(filehandle f)int=\n\tint c\n\n\tc:=fgetc(f)\n\tif c=c_eof then return 1 fi\n\tungetc(c,f)\n\treturn 0\nend\n\nexport proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)=\n\tint newlen,oldlen\n\tichar newptr\n\n!\tIF N=0 THEN CPL \"N=0\" FI\n\n\tif n=-1 then\n\t\tn:=strlen(s)\n\tfi\n\n\toldlen:=dest.length\n\n\tif oldlen=0 then\t\t\t\t!first string\n\t\tdest.strptr:=pcm_alloc(n+1)\n\t\tdest.allocated:=allocbytes\n\t\tdest.length:=n\t\t\t\t!length always excludes terminator\n\t\tmemcpy(dest.strptr,s,n)\n\t\t(dest.strptr+n)^:=0\n\t\treturn\n\tfi\n\n\tnewlen:=oldlen+n\n\tif newlen+1>dest.allocated then\n\t\tnewptr:=pcm_alloc(newlen+1)\n\t\tmemcpy(newptr,dest.strptr,oldlen)\n\t\tdest.strptr:=newptr\n\t\tdest.allocated:=allocbytes\n\tfi\n\n\tmemcpy(dest.strptr+oldlen,s,n)\n\t(dest.strptr+newlen)^:=0\n\n\tdest.length:=newlen\nend\n\nexport proc gs_init(ref strbuffer dest)=\n\tpcm_clearmem(dest,strbuffer.bytes)\nend\n\nexport proc gs_free(ref strbuffer dest)=\n\tif dest.allocated then\n\t\tpcm_free(dest.strptr,dest.allocated)\n\tfi\nend\n\nexport proc gs_str(ref strbuffer dest,ichar s)=\n\tstrbuffer_add(dest,s)\nend\n\nexport proc gs_char(ref strbuffer dest,int c)=\n\t[16]char s\n\n\ts[1]:=c\n\ts[2]:=0\n\n\tstrbuffer_add(dest,&.s,1)\nend\n\nexport proc gs_strn(ref strbuffer dest,ichar s,int length)=\n\tstrbuffer_add(dest,s,length)\nend\n\nexport proc gs_strvar(ref strbuffer dest,s)=\n\tstrbuffer_add(dest,s.strptr)\nend\n\nexport proc gs_strint(ref strbuffer dest,i64 a)=\n\tstrbuffer_add(dest,strint(a))\nend\n\nexport proc gs_strln(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_line(dest)\nend\n\nexport proc gs_strsp(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_str(dest,\" \")\nend\n\nexport proc gs_line(ref strbuffer dest)=\n!\tstrbuffer_add(dest,\"\\w\")\n\tstrbuffer_add(dest,\"\\n\")\nend\n\nexport function gs_getcol(ref strbuffer dest)int=\n\treturn dest.length\nend\n\nexport proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')=\n\tint col,i,n,slen\n\t[2560]char str\n\tcol:=dest.length\n\tstrcpy(&.str,s)\n\tslen:=strlen(s)\n\tn:=w-slen\n\tif n>0 then\n\t\tfor i:=1 to n do\n\t\t\tstr[slen+i]:=padch\n\t\tod\n\t\tstr[slen+n+1]:=0\n\tfi\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')=\n\tgs_leftstr(dest,strint(a),w,padch)\nend\n\nexport proc gs_padto(ref strbuffer dest,int col, ch=' ')=\n\tint n\n\t[2560]char str\n\n\tn:=col-dest.length\n\tif n<=0 then return fi\n\tfor i:=1 to n do\n\t\tstr[i]:=ch\n\tod\n\tstr[n+1]:=0\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_println(ref strbuffer dest,filehandle f=nil)=\n\tif dest.length=0 then return fi\n\t(dest.strptr+dest.length)^:=0\n\n\tif f=nil then\n\t\tprintln dest.strptr,,\"\\c\"\n\telse\n\t\tprintln @f,dest.strptr,,\"\\c\"\n\tfi\nend\n\nexport function nextcmdparamnew(int &paramno, ichar &name, &value, ichar defext=nil)int=\n\tstatic int infile=0\n\tstatic ichar filestart=nil\n\tstatic ichar fileptr=nil\n\tstatic byte colonseen=0\n\tref char q\n\tichar item,fileext\n\tint length\n\tstatic [300]char str\n\n\treenter:\n\tvalue:=nil\n\tname:=nil\n\n\tif infile then\n\t\tif readnextfileitem(fileptr,item)=0 then\t\t!eof\n\t\t\tfree(filestart)\t\t\t\t\t\t\t\t!file allocated via malloc\n\t\t\tinfile:=0\n\t\t\tgoto reenter\n\t\tfi\n\telse\n\t\tif paramno>ncmdparams then\n\t\t\treturn pm_end\n\t\tfi\n\t\titem:=cmdparams[paramno]\n\t\t++paramno\n\n\t\tlength:=strlen(item)\n\n\t\tif item^='@' then\t\t!@ file\n\t\t\tfilestart:=fileptr:=readfile(item+1)\n\t\t\tif filestart=nil then\n\t\t\t\tprintln \"Can't open\",item\n\t\t\t\tstop 7\n\t\t\tfi\n\t\t\tinfile:=1\n\t\t\tgoto reenter\n\t\tfi\n\n\t\tif item^=':' then\n\t\t\tcolonseen:=1\n\t\t\treturn pm_colon\n\t\tfi\n\tfi\n\n\tvalue:=nil\n\tif item^='-' then\n\t\tname:=item+(colonseen|0|1)\n\t\tq:=strchr(item,':')\n\t\tif not q then\n\t\t\tq:=strchr(item,'=')\n\t\tfi\n\t\tif q then\n\t\t\tvalue:=q+1\n\t\t\tq^:=0\n\t\tfi\n\t\treturn (colonseen|pm_extra|pm_option)\n\tfi\n\n\tfileext:=extractext(item,0)\n\tname:=item\n\n\tif fileext^=0 then\t\t\t\t\t\t\t!no extension\n\t\tstrcpy(&.str,name)\n\t\tif defext and not colonseen then\n\t\t\tname:=addext(&.str,defext)\t\t\t\t!try .c\n\t\tfi\n!\telsif eqstring(fileext,\"dll\") then\n\telsif eqstring(fileext,\"dll\") or eqstring(fileext,\"mcx\") then\n\t\treturn (colonseen|pm_extra|pm_libfile)\n\tfi\n\treturn (colonseen|pm_extra|pm_sourcefile)\nend\n\nfunction readnextfileitem(ichar &fileptr,&item)int=\n\tref char p,pstart,pend\n\tint n\n\tstatic [256]char str\n\n\tp:=fileptr\n\n\treenter:\n\tdo\n\t\tcase p^\n\t\twhen ' ','\\t',13,10 then\t!skip white space\n\t\t\t++p\n\t\twhen 26,0 then\t\t\t\t!eof\n\t\t\treturn 0\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\n\tcase p^\n\twhen '!', '#' then\t\t\t!comment\n\t\t++p\n\t\tdocase p++^\n\t\twhen 10 then\n\t\t\tgoto reenter\n\t\twhen 26,0 then\n\t\t\tfileptr:=p-1\n\t\t\treturn 0\n\t\telse\n\n\t\tend docase\n\tesac\n\n\n\tcase p^\n\twhen '\"' then\t\t\t\t!read until closing \"\n\t\tpstart:=++p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tprintln \"Unexpected EOF in @file\"\n\t\t\t\tstop 8\n\t\t\twhen '\"' then\n\t\t\t\tpend:=p++\n\t\t\t\tif p^=',' then ++p fi\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\telse\n\t\tpstart:=p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tpend:=p\n\t\t\t\texit\n\t\t\twhen ' ','\\t',',',13,10 then\n\t\t\t\tpend:=p++\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\tesac\n\n\tn:=pend-pstart\n\tif n>=str.len then\n\t\tprintln \"@file item too long\"\n\t\tstop 9\n\tfi\n\tmemcpy(&.str,pstart,n)\n\tstr[n+1]:=0\n\titem:=&.str\n\tfileptr:=p\n\n\treturn 1\nend\n\nexport proc ipadstr(ref char s,int width,ref char padchar=\" \")=\n\tint n\n\n\tn:=strlen(s)\n\tto width-n do\n\t\tstrcat(s,padchar)\n\tod\nend\n\nexport function padstr(ref char s,int width,ref char padchar=\" \")ichar=\n\tstatic [256]char str\n\n\tstrcpy(&.str,s)\n\tipadstr(&.str,width,padchar)\n\treturn &.str\nend\n\nexport function chr(int c)ichar=\n\tstatic [8]char str\n\n\tstr[1]:=c\n\tstr[2]:=0\n\treturn &.str\nend\n\nexport function cmpstring(ichar s,t)int=\n\tint res\n\tif (res:=strcmp(s,t))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function cmpstringn(ichar s,t,int n)int=\n\tint res\n\tif (res:=strncmp(s,t,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqstring(ichar s,t)int=\n\treturn strcmp(s,t)=0\nend\n\nexport function cmpbytes(ref void p,q,int n)int=\n\tint res\n\tif (res:=memcmp(p,q,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqbytes(ref void p,q,int n)int=\n\treturn memcmp(p,q,n)=0\nend\n\nexport proc mseed(u64 a,b=0)=\n\tseed[1]:=a\n\tif b then\n\t\tseed[2]:=b\n\telse\n\t\tseed[2] ixor:=a\n\tfi\nend\n\nexport function mrandom:word =\n!return pure 64-bit word value, 0 to 2**64-1\n!(cast result for signed value)\n!\tu64 x,y\n\tint x,y\n\tx:=seed[1]\n\ty:=seed[2]\n\tseed[1]:=y\n\tx ixor:=(x<<23)\n\tseed[2]:= x ixor y ixor (x>>17) ixor (y>>26)\n\treturn seed[2]+y\nend\n\nexport function mrandomp:int =\n!pure 64-bit int value, positive only, 0 to 2**63-1\n\treturn mrandom() iand 0x7FFF'FFFF'FFFF'FFFF\nend\n\nexport function mrandomint(int n)int=\n!positive random int value from 0 to n-1\n\treturn mrandomp() rem n\nend\n\nexport function mrandomrange(int a,b)int=\n!random int value from a to b inclusive\n!span extent must be 1 to 2**63-1\n\tint span\n\tspan:=b-a+1\n\tif span<=0 then\n\t\treturn 0\n\tfi\n\treturn (mrandomp() rem span)+a\nend\n\nexport function mrandomreal:real x=\n!positive random real value from 0 to just under (but not including) 1.0\n\trepeat x:=mrandomp()/9223372036854775808.0 until x<>1.0\n\treturn x\nend\n\nexport function mrandomreal1:real=\n!positive random real value from 0 to 1.0 inclusive\n\treturn mrandomp()/9223372036854775807.0\nend\n\nexport function readline:ichar=\n\treadln\n\treturn rd_buffer\nend\n\nexport function findfunction(ichar name)ref void=\n\tfor i to $getnprocs() do\n\t\tif eqstring($getprocname(i),name) then\n\t\t\treturn $getprocaddr(i)\n\t\tfi\n\tod\n\treturn nil\nend\n\nexport function roundtoblock(int n,align)int=\n!round up n until it is a multiple of filealign (which is a power of two)\n!return aligned value. Returns original if already aligned\n\tif n iand (align-1)=0 then return n fi\n\treturn n+(align-(n iand (align-1)))\nend\n\nexport function pcm_allocnfz(int n)ref void =\n!non-freeing allocator for small objects\n!n should be a multiple of 8 bytes, but is rounded up here if needed\n\tref byte p\n\n!make n a multiple of 8\n\tif n iand 7 then\n\t\tn:=n+(8-(n iand 7))\n\tfi\n\n\tp:=pcheapptr\t\t\t\t\t!Create item at start of remaining pool in heap block\n\tpcheapptr+:=n\t\t\t\t\t!Shrink remaining pool\n\n\tif pcheapptr>=pcheapend then\t!Overflows?\n\t\tp:=pcm_newblock(n)\t\t\t!Create new heap block, and allocate from start of that\n\tfi\n\n\treturn p\nend\n\n!export proc freddy=\n!\tPRINTLN \"FREDDY\"\n!end\n",
(u64)"export type filehandle=ref void\n\nimportdll $cstd=\n\tfunc malloc\t\t(u64)ref void\n\tfunc realloc\t(ref void, word)ref void\n\tproc free\t\t(ref void)\n\tproc memset\t\t(ref void, i32, word)\n\tproc memcpy\t\t(ref void, ref void, word)\n\tproc memmove\t\t(ref void, ref void, word)\n\tfunc clock\t\t:i32\n\tfunc ftell\t\t(filehandle)i32\n\tfunc fseek\t\t(filehandle, i32, i32)i32\n\tfunc fread\t\t(ref void, word, word, filehandle)word\n\tfunc fwrite\t\t(ref void, word, word, filehandle)word\n\tfunc getc\t\t(filehandle)i32\n\tfunc ungetc\t\t(i32, filehandle)i32\n\tfunc fopen\t\t(ichar a, b=\"rb\")filehandle\n\tfunc fclose\t\t(filehandle)i32\n\tfunc fgets\t\t(ichar, int, filehandle)ichar\n\tfunc remove\t\t(ichar)i32\n\tfunc rename\t\t(ichar, ichar)i32\n\tfunc getchar\t:i32\n\tproc putchar\t(i32)\n\tproc setbuf\t\t(filehandle, ref byte)\n\n\tfunc strlen\t\t(ichar)int\n\tfunc strcpy\t\t(ichar, ichar)ichar\n\tfunc strcmp\t\t(ichar, ichar)i32\n\tfunc strncmp\t(ichar, ichar, word)i32\n\tfunc strncpy\t(ichar, ichar, word)word\n\tfunc memcmp\t\t(ref void, ref void, word)i32\n\tfunc strcat\t\t(ichar, ichar)ichar\n\tfunc tolower\t(i32)i32\n\tfunc toupper\t(i32)i32\n\tfunc isalpha\t(i32)i32\n\tfunc isupper\t(i32)i32\n\tfunc islower\t(i32)i32\n\tfunc isalnum\t(i32)i32\n\tfunc isspace\t(i32)i32\n\tfunc strstr\t\t(ichar, ichar)ichar\n\tfunc atol\t\t(ichar)int\n\tfunc atoi\t\t(ichar)i32\n\tfunc strtod\t\t(ichar,ref ref char)r64\n\tfunc _strdup\t(ichar)ichar\n\n\tfunc puts\t\t(ichar)i32\n\tfunc printf\t\t(ichar, ...)i32\n\n\tfunc sprintf\t(ichar, ichar, ...)i32\n\n\tfunc sscanf\t\t(ichar, ichar, ...)i32\n\tfunc scanf\t\t(ichar, ...)i32\n\n\tfunc rand\t\t:i32\n\tproc srand\t\t(u32)\n\tfunc system\t\t(ichar)i32\n\n\tfunc fgetc\t\t(filehandle)i32\n\tfunc fputc\t\t(i32,  filehandle)i32\n\tfunc fprintf\t(filehandle, ichar, ...)i32\n\tfunc fputs\t\t(ichar,  filehandle)i32\n\tfunc feof\t\t(filehandle)i32\n\tfunc getch\t\t:i32\n\tfunc _getch\t\t:i32\n\tfunc kbhit\t\t:i32\n\tfunc _mkdir\t\t(ichar)i32\n\tfunc mkdir\t\t(ichar)i32\n\tfunc strchr\t\t(ichar,i32)ichar\n\n\tfunc _setmode\t(i32,i32)i32\n\n\tproc _exit\t\t(i32)\n\tproc \"exit\"\t\t(i32)\n!\tproc `exit\t\t(i32)\n\tfunc pow\t\t(real,real)real\n\n\tfunc `sin \t\t(real)real\n\tfunc `cos\t\t(real)real\n\tfunc `tan\t\t(real)real\n\tfunc `asin\t\t(real)real\n\tfunc `acos\t\t(real)real\n\tfunc `atan \t\t(real)real\n\tfunc `log\t\t(real)real\n\tfunc `log10\t\t(real)real\n\tfunc `exp\t\t(real)real\n\tfunc `floor\t\t(real)real\n\tfunc `ceil\t\t(real)real\n\n\tproc  qsort   \t(ref void, u64, u64, ref proc)\n\nend\n\nexport macro strdup=_strdup\n\nimportdll $cstdextra=\n\tfunc __getmainargs\t(ref i32, ref void, ref void, int, ref void)i32\nend\n\nexport const c_eof\t\t=-1\nexport const seek_set\t= 0\nexport const seek_curr\t= 1\nexport const seek_end\t= 2\n",
(u64)"const wm_destroy=2\n\nexport type wt_word\t= u16\nexport type wt_wordpm\t= u32\nexport type wt_bool\t= u32\nexport type wt_dword\t= u32\nexport type wt_wchar\t= u16\nexport type wt_wcharpm\t= u32\nexport type wt_char\t= byte\nexport type wt_ichar\t= ref char\nexport type wt_ptr\t\t= ref void\nexport type wt_wndproc\t= ref proc\nexport type wt_handle\t= ref void\nexport type wt_int\t\t= i32\nexport type wt_uint\t= u32\nexport type wt_long\t= i32\nexport type wt_wparam\t= word\nexport type wt_lparam\t= word\nexport type wt_point\t= rpoint\n\nexport record rsystemtime =\n\twt_word year\n\twt_word month\n\twt_word dayofweek\n\twt_word day\n\twt_word hour\n\twt_word minute\n\twt_word second\n\twt_word milliseconds\nend\n\nimportdll $windowsdlls=\n!\tfunc \"VirtualAlloc\"(wt_ptr, dint,wt_dword,wt_dword)wt_ptr\n\tfunc \"GetStdHandle\"(wt_dword)wt_handle\n\tfunc \"GetConsoleScreenBufferInfo\"(wt_handle,wt_ptr)int\n\tfunc \"SetConsoleCtrlHandler\"(wt_wndproc,int)int\n\tfunc \"SetConsoleMode\"(wt_handle,wt_dword)int\n\tfunc \"CreateProcessA\"(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,\n\t\t\t\t\t\twt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int\n\tfunc \"GetLastError\":wt_dword\n\tfunc \"WaitForSingleObject\"(wt_handle,wt_dword)wt_dword\n\tfunc \"GetExitCodeProcess\"(wt_handle,wt_ptr)int\n\tfunc \"CloseHandle\"(wt_handle)int\n\tfunc \"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)int\n\tfunc \"FlushConsoleInputBuffer\"(wt_handle)int\n\tfunc \"LoadLibraryA\"(wt_ichar)wt_handle\n!\tfunc \"GetProcAddress\"(wt_handle,wt_ichar)wt_wndproc\n\tfunc \"GetProcAddress\"(wt_handle,wt_ichar)ref void\n\tfunc \"LoadCursorA\"(wt_handle,wt_ichar)wt_handle\n\tfunc \"RegisterClassExA\"(wt_ptr)wt_wordpm\n\tfunc \"DefWindowProcA\"(wt_handle,wt_uint,wt_wparam,wt_lparam)int\n\tfunc \"ReadConsoleInputA\"(wt_handle,wt_ptr,wt_dword,wt_ptr)int\n\tproc \"Sleep\"(wt_dword)\n\tfunc \"GetModuleFileNameA\"(wt_handle,wt_ichar,wt_dword)wt_dword\n\n\tproc \"ExitProcess\"(wt_uint)\n\tproc \"PostQuitMessage\"(wt_int)\n\n\tproc \"MessageBoxA\"(wt_int x=0,wt_ichar message, caption=\"Caption\",wt_int y=0)\n\n\tfunc \"QueryPerformanceCounter\"(ref i64)wt_bool\n\tfunc \"QueryPerformanceFrequency\"(ref i64)wt_bool\n\n\tfunc \"CreateFileA\"(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle\n\tfunc \"GetFileTime\"(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool\n\n\tproc \"GetSystemTime\"(ref rsystemtime)\n\tproc \"GetLocalTime\"(ref rsystemtime)\n\n\tfunc \"GetTickCount64\":u64\n\tfunc \"PeekMessageA\"\t\t(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool\n\n\tfunc \"GetCommandLineA\":ichar\n\n\tfunc \"VirtualAlloc\" (ref void, wt_dword, wt_dword, wt_dword)ref void\n\tfunc \"VirtualProtect\" (ref void, wt_dword, wt_dword, ref wt_dword)wt_bool\n\n\tfunc \"WriteConsoleA\" (ref void, ref void, i32, ref i32, ref void)wt_bool\n\n\tfunc \"FindFirstFileA\" (wt_ichar,ref rfinddata)wt_handle\n\tfunc \"FindNextFileA\"  (wt_handle, ref rfinddata)wt_bool\n\tfunc \"FindClose\"      (wt_handle)wt_bool\n\n\tfunc \"MessageBeep\"    (i32)wt_bool\n\tfunc \"Beep\"    (i32 freq, dur)wt_bool\nend\n\nrecord input_record = $caligned\n\twt_word\teventtype\n!\tu16\tpadding\n\t\twt_bool\tkeydown\t\t\t!key event record (was inside 'Event' union in win32)\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nrecord rspoint=(i16 x,y)\n\nrecord rsrect=\n\ti16 leftx,top,rightx,bottom\nend\n\nglobal record rpoint =\n\twt_long x,y\nend\n\nrecord rconsole=\n\trspoint size,pos\n\tu16 attributes\n\trsrect window\n\trspoint maxwindowsize\nend\n\nrecord rstartupinfo =\n\twt_dword\tsize\n\tu32 dummy1\n\twt_ichar\treserved\n\twt_ichar\tdesktop\n\twt_ichar\ttitle\n\twt_dword\tx\n\twt_dword\ty\n\twt_dword\txsize\n\twt_dword\tysize\n\twt_dword\txcountchars\n\twt_dword\tycountchars\n\twt_dword\tfillattribute\n\twt_dword\tflags\n\twt_word\t\tshowwindow\n\twt_word\t\treserved2\n\tu32 dummy2\n\twt_ptr\t\treserved4\n\twt_handle\tstdinput\n\twt_handle\tstdoutput\n\twt_handle\tstderror\nend\n\nrecord rprocess_information =\n\twt_handle process\n\twt_handle thread\n\twt_dword processid\n\twt_dword threadid\nend\n\nrecord rwndclassex =\n\twt_uint\t\tsize\n\twt_uint\t\tstyle\n\twt_wndproc\twndproc\n\twt_int\t\tclsextra\n\twt_int\t\twndextra\n\twt_handle\tinstance\n\twt_handle\ticon\n\twt_handle\tcursor\n\twt_handle\tbackground\n\twt_ichar\tmenuname\n\twt_ichar\tclassname\n\twt_handle\ticonsm\nend\n\nglobal record rmsg =\n\twt_handle\thwnd\n\twt_uint\t\tmessage\n\tu32\t\tdummy1\n\twt_wparam\twParam\n\twt_lparam\tlParam\n\twt_dword\ttime\n\tu32\t\tdummy2\n\twt_point\tpt\nend\n\nrecord rfiletime =\n\twt_dword lowdatetime\n\twt_dword highdatetime\nend\n\nrecord rfinddata =\n\twt_dword\tfileattributes\n\trfiletime\tcreationtime\n\trfiletime\tlastaccesstime\n\trfiletime\tlastwritetime\n\twt_dword\tfilesizehigh\n\twt_dword\tfilesizelow\n\twt_dword\treserved0\n\twt_dword\treserved1\n\t[260]char\tfilename\n\t[14]char\t\taltfilename\n\twt_dword\tobs1, obs2\n\twt_word\t\tobs3\nend\n\nconst NORMAL_PRIORITY_CLASS=32\nconst CREATE_NEW_CONSOLE=16\nconst DETACHED_PROCESS=16\n\nconst MEM_COMMIT\t\t\t\t= 4096\nconst MEM_RESERVE\t\t\t\t= 8192\nconst PAGE_EXECUTE\t\t\t\t= 16\nconst PAGE_EXECUTE_READ\t\t\t= 32\nconst PAGE_EXECUTE_READWRITE\t= 64\nconst PAGE_NOACCESS\t\t\t\t= 1\n\n\nexport wt_handle hconsole, hconsolein\n\ninput_record lastkey, pendkey\nint keypending\t\t\t!whether pendkey contains a new key event detected by flushkbd\n\nint hpfreq\t\t\t\t!counts per msec\n\n\nref func (ref void)int wndproc_callbackfn=nil\t!windows call-back: address of handler\n\nint init_flag=0\n\nexport proc os_init=\n!general initialisation\n\thconsole:=GetStdHandle(u32(-11))\n\thconsolein:=GetStdHandle(u32(-10))\n\n\tlastkey.repeatcount:=0\n\tkeypending:=0\n\n\tSetConsoleCtrlHandler(nil,1)\n\n\tSetConsoleMode(hconsole,1 ior 2)\n\n\tinit_flag:=1\n\nend\n\nexport func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\n\twt_dword exitcode\n\tint status\n\tint cflags:=0\n\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tcase newconsole\n\twhen 0 then cflags := NORMAL_PRIORITY_CLASS\n\twhen 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE\n\twhen 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS\n\tesac\n\n\tsi.size := rstartupinfo.bytes\n\n\tstatus:=CreateProcessA(\n\t\tnil,\n\t\tcmdline,\n\t\tnil,\n\n\t\tnil,\n\t\t1,\n\t\tcflags,\n\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tif status=0 then\t\t!fails\n\t\tstatus:=GetLastError()\n\t\tprintf(\"Winexec error: %lld\\n\",status)\n\t\treturn -1\n\tfi\n\n\tWaitForSingleObject(xpi.process, 0xFFFF'FFFF)\n\tGetExitCodeProcess(xpi.process,&exitcode)\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn exitcode\nend\n\nexport func os_execcmd(ichar cmdline, int newconsole=0)int =\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tsi.size := rstartupinfo.bytes\n\n\tCreateProcessA( nil,\n\t\tcmdline,\n\t\tnil,\n\t\tnil,\n\t\t1,\n\t\tNORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn 1\nend\n\nexport func os_getch:int=\n\tint k\n\n\tk:=os_getchx() iand 255\n\n\treturn k\nend\n\nexport func os_kbhit:int=\n\twt_dword count\n\n\tunless init_flag then os_init() end\n\n\tGetNumberOfConsoleInputEvents(hconsolein,&count)\n\treturn count>1\nend\n\nexport func os_getdllinst(ichar name)u64=\n\twt_handle hinst\n\n\thinst:=LoadLibraryA(name)\n\treturn cast(hinst)\nend\n\nexport func os_getdllprocaddr(int hinst,ichar name)ref void=\n\treturn GetProcAddress(cast(hinst),name)\nend\n\nexport proc os_initwindows=\n\tos_init()\n\tos_gxregisterclass(\"pcc001\")\nend\n\nexport proc os_gxregisterclass(ichar classname)=\n\tconst idcarrow=32512\n\trwndclassex r\n\tstatic byte registered\n\n\tif registered then\n\t\treturn\n\tfi\n\n\tclear r\n\n\tr.size:=r.bytes\n\tr.style:=8 ior 32\n\tr.wndproc:=cast(&mainwndproc)\n\tr.instance:=nil\n\n\tr.icon:=nil\n\tr.cursor:=LoadCursorA(nil,ref void(idcarrow))\n\tr.background:=cast(15+1)\n\tr.menuname:=nil\n\tr.classname:=classname\n\tr.iconsm:=nil\n\n\tif RegisterClassExA(&r)=0 then\n\t\tprintf(\"Regclass error: %lld %lld\\n\",classname,GetLastError())\n\t\tstop 1\n\tend\n\tregistered:=1\nend\n\nglobal function mainwndproc (\n\t\twt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)int=\n\trmsg m\n\tint result\n\tstatic int count=0\n\n!CPL \"MAINWNDPROC\",HWND\n\n\tm.hwnd:=hwnd\n\tm.message:=message\n\tm.wParam:=wParam\n\tm.lParam:=lParam\n\tm.pt.x:=0\n\tm.pt.y:=0\n\t\n\tif (wndproc_callbackfn) then\n\t\tresult:=(wndproc_callbackfn^)(&m)\n\telse\n\t\tresult:=0\n\tfi\n\n\tif m.message=wm_destroy then\n\t\treturn 0\n\tfi\n\n\tif not result then\n\t\treturn DefWindowProcA(hwnd,message,wParam,lParam)\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport proc os_setmesshandler(ref void addr)=\n\twndproc_callbackfn:=addr\nend\n\nexport func os_getchx:int=\n!Q! function  os_getchx_c:int\n!return a 32-bit value containing:\n! 15..B0:\tchar code\n! 23..16\tvirtual keycode\n! 31..24\tshift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)\n\tconst rightaltmask\t= 1\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\tint count\n\tint charcode,keyshift,keycode\n\tint altdown,ctrldown,shiftdown,capslock\n\n!os_init() unless init_flag\n\tunless init_flag then os_init() end\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\tReadConsoleInputA(hconsolein,&lastkey,1,&count)\n\t\t\tuntil (lastkey.eventtype=1 and lastkey.keydown=1)\n\t\tfi\n\tfi\n\n!set shift flags\n\n\taltdown\t\t:= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)\n\tctrldown\t:= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)\n\tshiftdown\t:= ((lastkey.controlkeystate iand shiftmask)|1|0)\n\tcapslock\t:= ((lastkey.controlkeystate iand capsmask)|1|0)\n\n\t--lastkey.repeatcount\t\t!count this key out\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n\tif charcode<0 then\n\t\tif charcode<-128 then\n\t\t\tcharcode:=0\n\t\telse\n\t\t\tcharcode+:=256\n\t\tfi\n\tfi\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!....\n\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\treturn keyshift<<24 ior keycode<<16 ior charcode\nend\n\nexport func os_getos=>ichar=\n\treturn \"W64\"\nend\n\nexport func os_gethostsize=>int=\n\treturn 64\nend\n\nexport func os_shellexec(ichar opc, file)int=\n\treturn system(file)\nend\n\nexport proc os_sleep(int a)=\n\tSleep(a)\nend\n\nexport func os_getstdin:filehandle =\n\treturn fopen(\"con\",\"rb\")\nend\n\nexport func os_getstdout:filehandle =\n\treturn fopen(\"con\",\"wb\")\nend\n\nexport func os_gethostname:ichar=\n\tstatic [300]char name\n\tstatic int n\n\n\tGetModuleFileNameA(nil,&.name,name.bytes)\n\treturn &.name\nend\n\nexport func os_getmpath:ichar=\n!BART\n!\treturn \"C:\\\\m\\\\\"\n\treturn F\"C:@@@@\\m\\\" !ABC\n!\treturn \"C:@@@@\\\\m\\\\\" !ABC\nend\n\nexport func os_clock:i64=\n!\treturn clock()\n\treturn os_hpcounter()\nend\n\nexport func os_ticks:i64=\n\treturn GetTickCount64()\nend\n\nexport func os_iswindows:int=\n\treturn 1\nend\n\nexport proc os_getsystime(ref rsystemtime tm)=\n\tGetLocalTime(tm)\nend\n\nexport proc os_peek=\n\tint ticks\n\tstatic int lastticks\n\t[100]byte m\n\tticks:=GetTickCount64()\n\tif ticks-lastticks>=1000 then\n\t\tlastticks:=ticks\n\t\tPeekMessageA(&m,nil,0,0,0)\n\tfi\nend\n\nexport func os_allocexecmem(int n)ref byte=\n\tref byte p\n\tu32 oldprot\n\tint status\n\n\tp := VirtualAlloc(nil, n, MEM_RESERVE ior MEM_COMMIT, PAGE_NOACCESS)\n\tif p = nil then return nil fi\n\n\tstatus := VirtualProtect(p, n, PAGE_EXECUTE_READWRITE, &oldprot)\n\tif status = 0 then return nil fi\n\n\treturn p\nend\n\nexport func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int=\n!filespec is a filename (eg. \"*.dwg\") with possible drive/path; scan\n!directory for all matching files:\n! Store each file in dest array up to capacity\n! Return:\n!  -1:\tcapacity exceeded\n!   N:  number of files found including 0 for no matching files\n\n!t has this value\n! +1  Include normal files only, no sub-directory names\n! +2  Include directories\n! +3  (+1 +2) Include all files including directories\n! +4  Convert to lower case\n\tref void hfind\n\trfinddata file\n\tint nfiles:=0\n\t[300]char path\n\t[300]char fullfilename\n\n\tstrcpy(path, extractpath(filespec))\n\n\n\tif (hfind:=findfirstfilea(filespec,&file))<>ref void(-1) then\t!at least one file\n\t\trepeat\n\t\t\tif (file.fileattributes iand 16) then\t\t!this is a directory\n\t\t\t\tif (t iand 2)=0 then nextloop fi\t\t!no directories\n\t\t\telse\t\t\t\t\t\t!this is a file\n\t\t\t\tif (t iand 1)=0 then nextloop fi\n\t\t\tfi\n\t\t\tif nfiles>=capacity then\n\t\t\t\tnfiles:=-1\n\t\t\t\texit\n\t\t\tfi\n\n\t\t\tif (t iand 4) then\t\t\t\t!to lower case\n\t\t\t\tconvlcstring(file.filename)\n!\t\t\t\tconvlcstring(&.file.filename)\n\t\t\tfi\n\t\t\tstrcpy(fullfilename, path)\n\t\t\tstrcat(fullfilename, file.filename)\n\n\t\t\tdest[++nfiles]:=pcm_copyheapstring(fullfilename)\n\n\t\tuntil not findnextfilea(hfind,&file)\n\t\tfindclose(hfind)\n\tfi\n\treturn nfiles\nend\n\nexport func os_hpcounter:int a =\n!return counter such that successive calls indicate duration in msec\n\n\tif hpfreq=0 then\n\t\thpfreq:=os_hpfreq()/1000\t\t!counts per msec\n\tfi\n\n\tQueryPerformanceCounter(&a)\n\ta/hpfreq\nend\n\nexport func os_hpfreq:int a =\n\tQueryPerformanceFrequency(&a)\n\ta\nend\n\n",
(u64)"!import clib\n!import mlib\n!\n!importlib cstd=\n!\tclang proc     sleep\t(word32)\n!end\n\nrecord termios =\n\ti32 c_iflag\n\ti32 c_oflag\n\ti32 c_cflag\n\ti32 c_lflag\n\tchar c_line\n\t[32]char c_cc\t\t\t\t!at offset 17\n\t[3]byte filler\n\ti32 c_ispeed\t\t\t\t!at offset 52\n\ti32 c_ospeed\nend\n\n!importdll dlstuff=\nimportdll msvcrt=\n\tfunc dlopen\t\t\t(ichar, i32)ref void\n\tfunc dlsym\t\t\t(ref void, ichar)ref void\n\tfunc tcgetattr\t\t(i32, ref termios) i32\n\tfunc tcsetattr\t\t(i32, i32, ref termios) i32\n\tfunc gettimeofday\t(ref timeval, ref void) i32\n\tfunc gmtime_r  \t   (ref i64, ref tm_rec) ref void\n\tproc stdin\n\tproc stdout\nend\n \nrecord timeval =\n\ti64 tv_sec\n\ti64 tv_usec\nend\n\nrecord tm_rec =\n\ti32 tm_sec\n\ti32 tm_min\n\ti32 tm_hour\n\ti32 tm_mday\n\n\ti32 tm_mon\n\ti32 tm_year\n\ti32 tm_wday\n\ti32 tm_yday\n\ti32 tm_isdst\n\t[20]byte padding\nend\n\n!this record is used by some apps, so these fields must be present\nexport record rsystemtime =\n\ti32 year\n\ti32 month\n\ti32 dayofweek\n\ti32 day\n\ti32 hour\n\ti32 minute\n\ti32 second\n\tint milliseconds\nend\n\nint init_flag=0\n\n\nexport proc os_init=\n\tinit_flag:=1\nend\n\nexport func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\n\treturn system(cmdline)\nend\n\nexport func os_execcmd(ichar cmdline, int newconsole)int =\n\treturn system(cmdline)\nend\n\nexport func os_getch:int=\n\tconst ICANON  = 2\n\tconst ECHO    = 8\n\tconst TCSANOW = 0\n\tconst ISIG    = 1\n\n\ttermios old,new\n\tchar ch\n\n\ttcgetattr(0,&old)\n\tnew:=old\n\tnew.c_lflag iand:=inot ICANON\n\tnew.c_lflag iand:=inot ECHO\n\tnew.c_lflag iand:=inot ISIG\n\n\ttcsetattr(0,TCSANOW,&new)\n\n\tch:=getchar()\n\n\ttcsetattr(0,TCSANOW,&old)\n\n\treturn ch\nend\n\nexport func os_kbhit:int=\n\tabortprogram(\"kbhit\")\n\treturn 0\nend\n\nexport proc os_flushkeys=\n\tabortprogram(\"flushkeys\")\nend\n\nexport func os_getconsolein:ref void=\n\treturn nil\nend\n\nexport func os_getconsoleout:ref void=\n\treturn nil\nend\n\nexport func os_proginstance:ref void=\n\tabortprogram(\"PROGINST\")\n\treturn nil\nend\n\nexport func os_getdllinst(ichar name)u64=\n\tconst RTLD_LAZY=1\n\tref void h\n\n\th:=dlopen(name,RTLD_LAZY)\n\n\tif h=nil then\n\t\tif strcmp(name,\"msvcrt\")=0 then\t\t\t!might be linux\n\t\t\th:=dlopen(\"libc.so.6\",RTLD_LAZY);\n\t\tfi\n\tfi\n\n\treturn cast(h)\nend\n\nexport func os_getdllprocaddr(int hlib,ichar name)ref void=\n\tref void fnaddr\n\n\tif hlib=0 then\n\t\treturn nil\n\tfi\n\n\tfnaddr:=dlsym(cast(int(hlib)), name)\n\treturn fnaddr\nend\n\nexport proc os_initwindows=\nend\n\nexport func os_getchx:int=\n\tabortprogram(\"getchx\")\n\treturn 0\nend\n\nexport func os_getos=>ichar=\n!\tif $targetbits=32 then\n!\t\treturn \"L32\"\n!\telse\n\t\treturn \"L64\"\n!\tfi\nend\n\nexport func os_gethostsize=>int=\n\treturn 64\nend\n\nexport func os_iswindows:int=\n\treturn 0\nend\n\nexport func os_shellexec(ichar opc, file)int=\n\tabortprogram(\"SHELL EXEC\")\n\treturn 0\nend\n\nexport proc  os_sleep(int a)=\n!*!\tsleep(a)\nend\n\nexport func os_getstdin:filehandle =\n\tref filehandle pf:=cast(stdin)\n\treturn pf^\nend\n\nexport func os_getstdout:filehandle =\n\tref filehandle pf:=cast(stdout)\n\treturn pf^\nend\n\nexport func os_gethostname:ichar=\n!\tabortprogram(\"gethostname\")\n\treturn \"\"\nend\n\nexport func os_getmpath:ichar=\n!\tabortprogram(\"getmpath\")\n\treturn \"\"\nend\n\nexport proc os_exitprocess(int x)=\n\tstop\n!\t_exit(0)\n!\tExitProcess(x)\nend\n\nexport func os_clock:i64=\n\tif os_iswindows() then\n\t\treturn clock()\n\telse\n\t\treturn clock()/1000\n\tfi\nend\n\nexport func os_ticks:i64=\n\treturn clock()\nend\n\nexport func os_getclockspersec:i64=\n\treturn (os_iswindows()|1000|1000'000)\nend\n\nexport proc os_setmesshandler(ref void addr)=\n\tabortprogram(\"SETMESSHANDLER\")\n!\twndproc_callbackfn:=addr\nend\n\nexport func os_hpcounter:i64=\n\treturn 1\nend\n\nexport func os_hpfrequency:i64=\n\treturn 1\nend\n\nexport func os_filelastwritetime(ichar filename)i64=\n\treturn 0\nend\n\nexport proc os_getsystime(ref rsystemtime tm)=\n\ttimeval tv\n\ttm_rec tmr\n\n\n\tgettimeofday(&tv, nil)\n\tgmtime_r(&tv.tv_sec, &tmr)\n\n\ttm.year := tmr.tm_year + 1900\n\ttm.month := tmr.tm_mon + 1\n\ttm.dayofweek := tmr.tm_wday + 1\n\ttm.day := tmr.tm_mday\n\ttm.hour := tmr.tm_hour\n\ttm.minute := tmr.tm_min\n\ttm.second := tmr.tm_sec\n\ttm.milliseconds := tv.tv_usec/1000\ntm.month:=1\t\t\t!avoid crashing the M compiler\nend\n\nexport proc os_peek=\nend\n\nexport func  os_allocexecmem(int n)ref byte=\n\tabortprogram(\"No allocexec\")\n\tnil\nend\n\nexport func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int=\n\t0\nend\n",
(u64)"export function os_calldllfunction(\n\tref proc fnaddr,\n\tint retcode, nargs,\n\tref[]i64 args,\n\tref[]byte argcodes)u64 =\n\n\tu64 a\n\tr64 x\n\tint nextra := 0, pushedbytes\n\n!Stack is 16-byte aligned at this point\n\n\tif nargs<4 then\n\t\tnextra:=4-nargs\t\t\t!need at least 4 slots for shadow space\n\telsif nargs.odd then\t\t!need one more for a 16-byte-aligned stack\n\t\tnextra:=1\n\tfi\n\n\tpushedbytes:=(nextra+nargs)*8\n\n\tto nextra do\n\t\tasm push 0\n\tod\n\n\tfor i:=nargs downto 1 do\n\t\ta:=args[i]\t\t\t\t!get generic 64-bit value to push\n\t\tasm push u64 [a]\n\tod\n\n! blindly load first 4 args to both int/float regs, whether used or not,\n! and assuming calling a variadic function whether it is or not\n\n\tassem\n\t\tmov D10,   [Dstack]\n\t\tmovq XMM0, [Dstack]\n\t\tmov D11,   [Dstack+8]\n\t\tmovq XMM1, [Dstack+8]\n\t\tmov D12,   [Dstack+16]\n\t\tmovq XMM2, [Dstack+16]\n\t\tmov D13,   [Dstack+24]\n\t\tmovq XMM3, [Dstack+24]\n\tend\n\n\tif retcode='I' then\n\t\ta:=(ref func:i64(fnaddr))^()\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn a\n\n\telse\n\t\tx:=(ref func:r64(fnaddr))^()\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn u64@(x)\t\t\t!(type-punning cast)\n\n\tfi\nend\t\n",
(u64)"type dll0_int=ref function:int\ntype dll1_int=ref function(int)int\ntype dll2_int=ref function(int,int)int\ntype dll3_int=ref function(int,int,int)int\ntype dll4_int=ref function(int,int,int,int)int\ntype dll5_int=ref function(int,int,int,int,int)int\ntype dll6_int=ref function(int,int,int,int,int,int)int\ntype dll8_int=ref function(int,int,int,int, int,int,int,int)int\ntype dll9_int=ref function(int,int,int,int, int,int,int,int, int)int\ntype dll10_int=ref function(int,int,int,int, int,int,int,int, int,int)int\ntype dll11_int=ref function(int,int,int,int, int,int,int,int, int,int,int)int\ntype dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int\ntype dll14_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int, int,int)int\n\ntype dll0_r64=ref function:r64\ntype dll1_r64=ref function(int)r64\ntype dll2_r64=ref function(int,int)r64\n\ntype dll0_r64x=ref function:r64\ntype dll1_r64x=ref function(real)r64\ntype dll2_r64x=ref function(real,real)r64\n\ntype m_dll0_int=ref function:int\ntype m_dll1_int=ref function(int)int\ntype m_dll2_int=ref function(int,int)int\ntype m_dll3_int=ref function(int,int,int)int\ntype m_dll4_int=ref function(int,int,int,int)int\ntype m_dll5_int=ref function(int,int,int,int,int)int\ntype m_dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int\n\ntype m_dll0_r64=ref function:r64\ntype m_dll1_r64=ref function(int)r64\ntype m_dll2_r64=ref function(int,int)r64\n\n\nexport function os_calldllfunction(ref proc fnaddr,\n\t\tint retcode, nargs, ref[]i64 args, ref[]byte argcodes)u64 =\n!retcode is 'R' or 'I'\n!each argcodes element is 'R' or 'I' too\n!The x64 version can work with any combination.\n!Here, for C, only some combinations are dealt with:\n! I result, params all I (not all param counts)\n! R result, params all I (not all param counts)\n!Mixed params, for arbitrary return type, not handled (not really detected either)\n\n\tu64 a\n\tr64 x\n\tint oddstack, nextra, pushedbytes\n\n!CPL \"/////CCCCCCCCCCCCCCCCCC\"\n\n\tif retcode='I' then\n\t\treturn calldll_cint(fnaddr,args,nargs)\n\telse\n\t\treturn calldll_creal(fnaddr,args,nargs)\n\tfi\nend\t\n\nglobal function os_pushargs(ref[]u64 args, int nargs, nextra,\n\t\t\t\t\tref proc fnaddr, int isfloat)u64=\n\tu64 a\n\tr64 x\n!ABORTPROGRAM(\"PUSHARGS/C NOT READY\")\n\n\treturn os_calldllfunction(fnaddr, (isfloat|0|'I'), nargs, cast(args), nil)\n\n\n!\treturn a\nend\n\nfunction calldll_cint (ref proc fnaddr,ref[]i64 params,int nparams)i64=\nswitch nparams\nwhen 0 then\n\treturn dll0_int(fnaddr)^()\nwhen 1 then\n\treturn dll1_int(fnaddr)^(params^[1])\nwhen 2 then\n\treturn dll2_int(fnaddr)^(params^[1],params^[2])\nwhen 3 then\n\treturn dll3_int(fnaddr)^(params^[1],params^[2],params^[3])\nwhen 4 then\n\treturn dll4_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4])\nwhen 5 then\n\treturn dll5_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4], params^[5])\nwhen 6 then\n\treturn dll6_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4], params^[5],params^[6])\nwhen 8 then \n\treturn (dll8_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8])\nwhen 9 then \n\treturn (dll9_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9])\nwhen 10 then \n\treturn (dll10_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10])\nwhen 11 then \n\treturn (dll11_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11])\n\nwhen 12 then \n\treturn (dll12_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11],params^[12])\n\n!when 14 then \n!\treturn (dll14_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n!\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11],params^[12],\n!\t\t\t\tparams^[13],params^[14])\n!\nelse\n\tcpl nparams\n\tprintln \"calldll/c/int unsupported # of params\", nparams\n\tstop 1\nend switch\nreturn 0\nend\n\nfunction calldll_creal (ref proc fnaddr,ref[]i64 params,int nparams)i64=\nr64 x\n\nswitch nparams\nwhen 0 then\n\treturn dll0_r64(fnaddr)^()\nwhen 1 then\n\tos_dummycall(params^[1],params^[2],params^[3],params^[4])\n\tx:=dll1_r64(fnaddr)^(params^[1])\nwhen 2 then\n\tx:=dll2_r64(fnaddr)^(params^[1],params^[2])\nelse\n\tprintln \"calldll/c/real too many params\"\n\tstop 1\nend switch\nreturn i64@(x)\nend\n\n\nglobal proc os_dummycall(r64 a,b,c,d)=\nend\n"}};

static u64 mm_modules_fileext = (u64)"m";

static struct $B15 mm_modules_getmodulefilename_str;
static u64 mm_name_currstproc;
static i64 mm_name_allowmodname = 0;

static i64 mm_name_noexpand;
static i64 mm_name_noassem;
static i64 mm_name_macrolevels;
static struct $B19 mm_name_macroparams;
static struct $B19 mm_name_macroparamsgen;
static struct $B19 mm_name_macroargs;
static i64 mm_name_nmacroparams;
static i64 mm_name_nmacroargs;
static i64 mm_parse_intabledata = 0;

static i64 mm_parse_inreadprint = 0;

static i64 mm_parse_inparamlist = 0;

static i64 mm_parse_inrecordbody = 0;

static i64 mm_parse_inimportmodule = 0;

static i64 mm_parse_labelseen = 0;

static u64 mm_parse_tabledataname = 0;

static struct $B1 mm_parse_procstack;
static i64 mm_parse_nprocstack = 0;

static u64 mm_parse_unionstring;
static u64 mm_parse_unionpend;
static u64 mm_parse_unionlastvar = 0;

static u64 mm_parse_dretvar;
static i64 mm_parse_varattribs = 0;

static struct $B1 mm_parse_dollarstack;
static i64 mm_parse_ndollar = 0;

static i64 mm_parse_insiderecord = 0;

static i64 mm_parse_insidedllimport = 0;

static struct $B1 mm_parse_forindexvars;
static i64 mm_parse_nforloops;
// Istatic skipped:mm_parse.readcompilervar.monthnames

static u64 mm_support_bytemasks = -9205322385119247871;

static struct $B16 mm_tables_stdnames = {{
(u64)"void",
(u64)"r64",
(u64)"r32",
(u64)"i64",
(u64)"u64",
(u64)"c64",
(u64)"bool64",
(u64)"ref",
(u64)"rec",
(u64)"range",
(u64)"array",
(u64)"slice",
(u64)"c8",
(u64)"b8",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"ichar",
(u64)"refbit",
(u64)"auto",
(u64)"any",
(u64)"proc",
(u64)"label",
(u64)"type",
(u64)"bitfl",
(u64)"tuple",
(u64)"pend",
(u64)"block",
(u64)"last "}};

static struct $B18 mm_tables_stdsize = {{
578721382704351232,
144397767127601152,
17626613022980,
2251799948427264}};

static struct $B18 mm_tables_stdpcl = {{
433478087141818880,
578434388745456395,
434041037011550985,
3102847684445702}};

static i64 mm_tables_trefproc;
static i64 mm_tables_treflabel;
static struct $B74 mm_tables_sysfnnames = {{
(u64)"sf_init",
(u64)"sf_print_startfile",
(u64)"sf_print_startstr",
(u64)"sf_print_startptr",
(u64)"sf_print_startcon",
(u64)"sf_print_setfmt",
(u64)"sf_print_nogap",
(u64)"sf_print_space",
(u64)"sf_print_i64",
(u64)"sf_print_i64_nf",
(u64)"sf_print_u64",
(u64)"sf_print_r64",
(u64)"sf_print_r32",
(u64)"sf_print_str",
(u64)"sf_print_str_nf",
(u64)"sf_print_strsl",
(u64)"sf_print_ptr",
(u64)"sf_print_ptr_nf",
(u64)"sf_print_c8",
(u64)"sf_print_bool",
(u64)"sf_print_newline",
(u64)"sf_print_end",
(u64)"sf_read_i64",
(u64)"sf_read_r64",
(u64)"sf_read_str",
(u64)"sf_read_fileline",
(u64)"sf_read_strline",
(u64)"sf_read_conline",
(u64)"sf_getnprocs",
(u64)"sf_getprocname",
(u64)"sf_getprocaddr",
(u64)"sf_power_i64",
(u64)"sf_unimpl"}};

static struct $B75 mm_tables_sysfnparams = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B75 mm_tables_sysfnres = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1}};

static struct $B74 mm_tables_sysfnhandlers;
static struct $B76 mm_tables_jtagnames = {{
(u64)"jnone",
(u64)"jconst",
(u64)"jnull",
(u64)"jvoidvar",
(u64)"jname",
(u64)"jnamelv",
(u64)"jblock",
(u64)"jdecimal",
(u64)"jassem",
(u64)"jassemmacro",
(u64)"jassemreg",
(u64)"jassemxreg",
(u64)"jassemmem",
(u64)"jstrinclude",
(u64)"jsourceline",
(u64)"jandl",
(u64)"jorl",
(u64)"jnotl",
(u64)"jistruel",
(u64)"jisfalsel",
(u64)"jmakelist",
(u64)"jmakerange",
(u64)"jmakeset",
(u64)"jmakedict",
(u64)"jmakeslice",
(u64)"jreturnmult",
(u64)"jkeyword",
(u64)"jkeyvalue",
(u64)"jassign",
(u64)"jassignmm",
(u64)"jassignms",
(u64)"jassignmdrem",
(u64)"jcall",
(u64)"jcmp",
(u64)"jcmpchain",
(u64)"jbin",
(u64)"junary",
(u64)"jprop",
(u64)"jbinto",
(u64)"junaryto",
(u64)"jincr",
(u64)"jin",
(u64)"jinrev",
(u64)"jinrange",
(u64)"jinset",
(u64)"jstringz",
(u64)"jindex",
(u64)"jindexlv",
(u64)"jslice",
(u64)"jdot",
(u64)"jdotlv",
(u64)"jdotindex",
(u64)"jdotslice",
(u64)"jptr",
(u64)"jptrlv",
(u64)"jaddrof",
(u64)"jaddroffirst",
(u64)"jdaddrvv",
(u64)"jconvert",
(u64)"jshorten",
(u64)"jautocast",
(u64)"jtypepun",
(u64)"jtypeconst",
(u64)"joperator",
(u64)"jupper",
(u64)"jbitwidth",
(u64)"jbytesize",
(u64)"jtypestr",
(u64)"jbitfield",
(u64)"jminvalue",
(u64)"jmaxvalue",
(u64)"jcvlineno",
(u64)"jcvstrlineno",
(u64)"jcvmodulename",
(u64)"jcvfilename",
(u64)"jcvfunction",
(u64)"jcvdate",
(u64)"jcvtime",
(u64)"jcvversion",
(u64)"jcvtypename",
(u64)"jcvnil",
(u64)"jcvpi",
(u64)"jcvinfinity",
(u64)"jcvtrue",
(u64)"jcvfalse",
(u64)"jwhenthen",
(u64)"jfmtitem",
(u64)"jnogap",
(u64)"jspace",
(u64)"jreturn",
(u64)"jsyscall",
(u64)"jto",
(u64)"jif",
(u64)"jforup",
(u64)"jfordown",
(u64)"jforall",
(u64)"jforallrev",
(u64)"jwhile",
(u64)"jrepeat",
(u64)"jgoto",
(u64)"jlabeldef",
(u64)"jredo",
(u64)"jnext",
(u64)"jexit",
(u64)"jdo",
(u64)"jcase",
(u64)"jdocase",
(u64)"jswitch",
(u64)"jdoswitch",
(u64)"jdoswitchu",
(u64)"jdoswitchx",
(u64)"jswap",
(u64)"jselect",
(u64)"jrecase",
(u64)"jprint",
(u64)"jprintln",
(u64)"jfprint",
(u64)"jfprintln",
(u64)"jread",
(u64)"jreadln",
(u64)"jstop",
(u64)"jeval",
(u64)"jclear"}};

static struct $B77 mm_tables_jsubs = {{
0,
0,
0,
0,
0,
0,
1,
0,
3,
0,
0,
0,
1,
1,
1,
2,
2,
1,
1,
1,
2,
2,
1,
1,
2,
0,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
2,
2,
2,
2,
0,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
0,
1,
1,
3,
3,
3,
3,
3,
3,
3,
2,
1,
0,
0,
0,
0,
1,
3,
3,
3,
3,
3,
3,
2,
3,
1,
2,
2,
3,
3,
2,
2,
1,
1,
1}};

static struct $B77 mm_tables_jisexpr = {{
0,
3,
3,
3,
3,
3,
0,
3,
0,
0,
0,
0,
0,
3,
3,
2,
2,
1,
1,
1,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
2,
1,
2,
1,
1,
2,
1,
3,
2,
2,
2,
2,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
1,
1,
1,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
0,
3,
3,
3,
0,
3,
0,
3,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
3,
0,
3,
0,
0,
0,
0,
3,
0,
0,
0,
0,
0,
0,
0,
0,
3,
1}};

static struct $B77 mm_tables_jsolo = {{
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
0,
1,
1}};

static struct $B31 mm_tables_bitfieldnames = {{
(u64)"bf_msb",
(u64)"bf_lsb",
(u64)"bf_msbit",
(u64)"bf_lsbit",
(u64)"bf_msw",
(u64)"bf_lsw",
(u64)"bf_odd",
(u64)"bf_even"}};

static struct $B18 mm_tables_optypenames = {{
(u64)"no_op",
(u64)"bin_op",
(u64)"mon_op",
(u64)"prop_op"}};

static struct $B78 mm_tables_symbolnames = {{
(u64)".",
(u64)"&.",
(u64)",",
(u64)";",
(u64)":",
(u64)":=",
(u64)"=>",
(u64)"->",
(u64)"(",
(u64)")",
(u64)"[",
(u64)"]",
(u64)"{",
(u64)"}",
(u64)"^",
(u64)"|",
(u64)"@",
(u64)"?",
(u64)"&",
(u64)"&&",
(u64)"..",
(u64)"...",
(u64)"#",
(u64)"+",
(u64)"-",
(u64)"*",
(u64)"/",
(u64)"%",
(u64)"rem",
(u64)"divrem",
(u64)"iand",
(u64)"ior",
(u64)"ixor",
(u64)"<<",
(u64)">>",
(u64)"min",
(u64)"max",
(u64)"and",
(u64)"or",
(u64)"xor",
(u64)"=",
(u64)"cmp",
(u64)"**",
(u64)"in",
(u64)"notin",
(u64)"inrev",
(u64)"not",
(u64)"istrue",
(u64)"inot",
(u64)"abs",
(u64)"sign",
(u64)"sqrt",
(u64)"sqr",
(u64)"propsym",
(u64)"mathsopsym",
(u64)"maths2opsym",
(u64)"bitfieldsym",
(u64)"eolsym",
(u64)"eofsym",
(u64)"rawxnamesym",
(u64)"incrsym",
(u64)"intconstsym",
(u64)"realconstsym",
(u64)"charconstsym",
(u64)"stringconstsym",
(u64)"unitnamesym",
(u64)"namesym",
(u64)"kincludesym",
(u64)"kstrincludesym",
(u64)"regsym",
(u64)"xregsym",
(u64)"fregsym",
(u64)"mregsym",
(u64)"jmpccsym",
(u64)"setccsym",
(u64)"movccsym",
(u64)"segnamesym",
(u64)"asmopcodesym",
(u64)"stdtypesym",
(u64)"kicharsym",
(u64)"kifsym",
(u64)"kthensym",
(u64)"kelsifsym",
(u64)"kelsesym",
(u64)"kelsecasesym",
(u64)"kelseswitchsym",
(u64)"kendsym",
(u64)"kunlesssym",
(u64)"kcasesym",
(u64)"kdocasesym",
(u64)"krecasesym",
(u64)"kwhensym",
(u64)"kforsym",
(u64)"ktosym",
(u64)"kbysym",
(u64)"kdosym",
(u64)"kwhilesym",
(u64)"krepeatsym",
(u64)"kuntilsym",
(u64)"kreturnsym",
(u64)"kstopsym",
(u64)"kloopsym",
(u64)"kgotosym",
(u64)"kswitchsym",
(u64)"kdoswitchsym",
(u64)"kprintsym",
(u64)"kreadsym",
(u64)"kprocsym",
(u64)"kfunctionsym",
(u64)"klabelsym",
(u64)"krecordsym",
(u64)"kstructsym",
(u64)"kunionsym",
(u64)"kimportmodulesym",
(u64)"kprojectsym",
(u64)"ktypesym",
(u64)"krefsym",
(u64)"kvoidsym",
(u64)"kvarsym",
(u64)"kletsym",
(u64)"kslicesym",
(u64)"kmacrosym",
(u64)"kconstsym",
(u64)"kclearsym",
(u64)"kheadersym",
(u64)"kglobalsym",
(u64)"kstaticsym",
(u64)"kcastsym",
(u64)"compilervarsym",
(u64)"dollarsym",
(u64)"kevalsym",
(u64)"ktabledatasym",
(u64)"kclampsym",
(u64)"kswapsym",
(u64)"kassemsym",
(u64)"ksyscallsym"}};

static struct $B40 mm_tables_symboloptypes = {{
1099511627776,
0,
72057598332895232,
72340172838076673,
72340172838076673,
144678142341087489,
3307158503938,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B40 mm_tables_symbolgenops = {{
0,
0,
3098476543630901248,
3689065127789604140,
241444468020,
17732923538145280,
284597173566,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B40 mm_tables_symbolgentoops = {{
0,
0,
6485183463413514240,
7016608629048302683,
439787742050,
30399297484750848,
27243,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B40 mm_tables_symbolopprios = {{
1099511627776,
0,
288230397626548224,
289359587528868612,
578720265945678596,
25870599686,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B40 mm_tables_exprstarter = {{
256,
281474976776193,
72057594037993472,
1,
4311744512,
72339069014638849,
72339073326448897,
72340172821233664,
4295032833,
72339069014638592,
1,
1,
0,
0,
1103806595072,
72057594037927936,
72057598332895489}};

static struct $B18 mm_tables_headerdirnames = {{
(u64)"hdr_module",
(u64)"hdr_import",
(u64)"hdr_sourcepath",
(u64)"hdr_linkdll"}};

static struct $B18 mm_tables_scopenames = {{
(u64)"Local",
(u64)"Global",
(u64)"Program",
(u64)"Export"}};

static struct $B3 mm_tables_parammodenames = {{
(u64)"Byval ",
(u64)"Byref "}};

static struct $B38 mm_tables_namenames = {{
(u64)"nullid",
(u64)"programid",
(u64)"subprogid",
(u64)"moduleid",
(u64)"dllmoduleid",
(u64)"typeid",
(u64)"procid",
(u64)"dllprocid",
(u64)"dllvarid",
(u64)"constid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"fieldid",
(u64)"labelid",
(u64)"macroid",
(u64)"macroparamid",
(u64)"linkid"}};

static struct $B39 mm_tables_name2pid = {{
0,
2304,
0,
258,
0,
1027,
5,
6,
0}};

static struct $B1 mm_tables_propnames = {{
(u64)"kksliceptr",
(u64)"kklen",
(u64)"kklwb",
(u64)"kkupb",
(u64)"kkbounds",
(u64)"kkbitwidth",
(u64)"kkbytesize",
(u64)"kktypestr",
(u64)"kkminval",
(u64)"kkmaxval"}};

static struct $B79 mm_tables_stnames = {{
(u64)"if",
(u64)"then",
(u64)"elsif",
(u64)"else",
(u64)"dummyelse",
(u64)"elsecase",
(u64)"elseswitch",
(u64)"case",
(u64)"docase",
(u64)"recase",
(u64)"when",
(u64)"for",
(u64)"to",
(u64)"downto",
(u64)"by",
(u64)"do",
(u64)"end",
(u64)"while",
(u64)"repeat",
(u64)"until",
(u64)"return",
(u64)"stop",
(u64)"redoloop",
(u64)"nextloop",
(u64)"exit",
(u64)"goto",
(u64)"switch",
(u64)"doswitch",
(u64)"doswitchu",
(u64)"doswitchx",
(u64)"tabledata",
(u64)"enumdata",
(u64)"clamp",
(u64)"eval",
(u64)"print",
(u64)"println",
(u64)"fprint",
(u64)"fprintln",
(u64)"cp",
(u64)"cpl",
(u64)"read",
(u64)"readln",
(u64)"cast",
(u64)"function",
(u64)"func",
(u64)"proc",
(u64)"fun",
(u64)"threadedproc",
(u64)"type",
(u64)"record",
(u64)"struct",
(u64)"union",
(u64)"ref",
(u64)"var",
(u64)"let",
(u64)"include",
(u64)"binclude",
(u64)"sinclude",
(u64)"strinclude",
(u64)"macro",
(u64)"assem",
(u64)"asm",
(u64)"static",
(u64)"const",
(u64)"$getnprocs",
(u64)"$getprocname",
(u64)"$getprocaddr",
(u64)"importdll",
(u64)"project",
(u64)"unless",
(u64)"global",
(u64)"export",
(u64)"swap",
(u64)"void",
(u64)"int",
(u64)"word",
(u64)"real",
(u64)"ichar",
(u64)"ivoid",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"r32",
(u64)"r64",
(u64)"byte",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"char",
(u64)"c8",
(u64)"c64",
(u64)"bool64",
(u64)"bool",
(u64)"bool8",
(u64)"label",
(u64)"slice",
(u64)"million",
(u64)"billion",
(u64)"$lineno",
(u64)"$strlineno",
(u64)"$filename",
(u64)"$modulename",
(u64)"$function",
(u64)"$date",
(u64)"$time",
(u64)"$version",
(u64)"$typename",
(u64)"nil",
(u64)"pi",
(u64)"true",
(u64)"false",
(u64)"infinity",
(u64)"$",
(u64)"and",
(u64)"or",
(u64)"xor",
(u64)"iand",
(u64)"ior",
(u64)"ixor",
(u64)"in",
(u64)"notin",
(u64)"inrev",
(u64)"rem",
(u64)"divrem",
(u64)"min",
(u64)"max",
(u64)"not",
(u64)"inot",
(u64)"istrue",
(u64)"abs",
(u64)"sqr",
(u64)"sqrt",
(u64)"sign",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"atan2",
(u64)"fmod",
(u64)"sliceptr",
(u64)"len",
(u64)"lwb",
(u64)"upb",
(u64)"bounds",
(u64)"bitwidth",
(u64)"bytes",
(u64)"typestr",
(u64)"msb",
(u64)"lsb",
(u64)"msbit",
(u64)"lsbit",
(u64)"msw",
(u64)"lsw",
(u64)"odd",
(u64)"even",
(u64)"fi",
(u64)"esac",
(u64)"od",
(u64)"$caligned",
(u64)"clear",
(u64)"module",
(u64)"import",
(u64)"$sourcepath",
(u64)"linkdll"}};

static struct $B80 mm_tables_stsymbols = {{
21073,
21587,
21844,
22870,
23386,
23900,
24158,
24671,
24919,
25442,
25956,
26214,
26470,
26984,
26985,
33924,
33669,
27242,
27242,
27242,
27499,
28032,
27757,
27757,
28532,
29040,
30581,
17528,
17733,
31301,
34695,
31615,
34952,
29320,
22643,
32382,
30342,
20303,
20559,
20304,
20303,
20303,
20303,
20303,
20303,
20303,
20303,
20303,
31055,
16962,
33153,
33153,
33153,
33153,
33153,
33153,
33153,
9858,
10279,
8223,
11297,
11821,
7709,
9508,
12591,
12848,
13365,
14131,
14135,
14135,
14135,
14135,
14135,
14391,
13880,
13878,
13878,
13878,
14646,
14649,
14649,
14649,
22329,
22359,
31761,
32125,
32125}};

static struct $B81 mm_tables_stsubcodes = {{
92,
92,
6881281,
6881387,
7405674,
0,
65536,
0,
0,
0,
0,
6684773,
103,
7077995,
7209069,
65536,
0,
7536754,
7667828,
7536754,
7798902,
58,
0,
131073,
0,
0,
0,
0,
5439554,
83,
1,
0,
1966109,
31,
0,
196609,
0,
262147,
786433,
917504,
1048591,
131075,
1114113,
1179665,
262163,
786444,
393221,
851974,
720921,
131073,
4718663,
4784202,
4980811,
5111885,
5242959,
5439569,
5374036,
0,
0,
0,
0,
1,
0,
0,
0,
3997696,
0,
4456448,
4587589,
4718663,
4849737,
4980811,
5111885,
5308495,
65619,
196610,
327684,
458758,
65544,
196610,
327684,
458758,
5308424,
6291545,
1,
131073,
262147}};

static struct $B23 mm_tables_convnames = {{
(u64)"kkerror",
(u64)"kkfloat",
(u64)"kkfix",
(u64)"kktruncate",
(u64)"kkwiden",
(u64)"kkfwiden",
(u64)"kkfnarrow",
(u64)"kksoftconv",
(u64)"kktoboolt",
(u64)"kkharderr",
(u64)"kksofttrun",
(u64)"kkichar2sl",
(u64)"kkax2slice",
(u64)"kkcx2ichar"}};

static struct $B24 mm_tables_convtopcl = {{
28416,
29040,
29554,
116,
64,
0,
0}};

static struct $B12 mm_tables_d_typestarterset = {{
79,
11,
117,
111,
80,
121}};

static struct $B82 mm_tables_softconvtable = {{
7,
6,
2,
2,
2,
5,
7,
2,
2,
2,
1,
1,
7,
7,
7,
1,
1,
7,
7,
7,
1,
1,
7,
7,
7}};

static struct $B40 mm_tables_endsexpr;
static struct $B9 mm_tables_exprendsymbols = {{
1397885962,
1465934676,
1577324547}};

static struct $B77 mm_tables_isbooltag;
static i64 mm_type_countedfields;
static i64 mm_type_inassem;
static i64 mm_type_inidata;
static i64 mm_type_tpass_depth;
static i64 mm_type_setrecordsize_depth;
static i64 mm_type_tx_assign_nn;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B71 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B71 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B89 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B18 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B17 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B89 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B89 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	struct $B89 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B21 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L447;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L446;
L447:
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L449;
	asu64(R1) = p;
	free(asu64(R1));
	goto L448;
L449:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L448:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L454;
	goto L452;
L454:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L455:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L459;
L458:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L459:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L458;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L455;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L461:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L465;
	asi64(R1) = i;
	k = asi64(R1);
	goto L463;
L465:
	i += 1; if (i <= 27) goto L461;
L463:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L468;
L466:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L470;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L469;
L470:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L468;
L469:
	i += 1; if (i <= av_1) goto L466;
L468:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L452:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L473;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L471;
L473:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L475;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L471;
L475:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L477;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L471;
L477:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L471;
L471:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L480;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L480:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L482;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L482:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L478;
L478:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L485;
	asi64(R1) = n;
	goto L484;
L485:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L484:
	goto L483;
L483:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L486;
L486:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L489;
	R1 = 0;
	goto L487;
L489:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L492;
	R1 = 0;
	goto L490;
L492:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L490;
L490:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L495;
	R1 = 0;
	goto L493;
L495:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L493;
L493:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L498;
	asu64(R1) = p;
	goto L496;
L498:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L496;
L496:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L501;
	asu64(R1) = p;
	goto L499;
L501:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L499;
L499:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L503;
L503:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L505;
L505:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L510;
	R1 = 0;
	goto L508;
L510:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L512;
	R1 = 0;
	goto L508;
L512:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L508;
L508:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L515;
	R1 = 0;
	goto L513;
L515:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L513;
L513:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L518;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L516;
L518:
	R1 = 0;
	goto L516;
L516:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L521;
	asu64(R1) = mwindows_os_getstdin();
	handlex = asu64(R1);
L521:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L523;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L524:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L527;
L528:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L527:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L530;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L530:
	goto L524;
L523:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L532;
	goto L519;
L532:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L534;
	goto L519;
L534:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L536;
L535:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L540;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L539;
L540:
	R1 = 1;
	crseen = asu8(R1);
L539:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L536:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L535;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L535;
L541:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L543;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L543;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L543:
L519:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L547;
L545:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L545;
L547:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L551;
L549:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L549;
L551:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L554;
L553:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L553;
	asu64(R1) = s0;
	goto L552;
L552:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L558;
L557:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L557;
	asu64(R1) = s0;
	goto L556;
L556:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B18 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L562;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L563;
	goto L564;
L562:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L561;
L563:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L561;
L564:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L561:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L566;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L567;
	goto L568;
L566:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L567:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L568:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L565:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L560;
L560:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L571;
	R1 = tou64("");
	goto L569;
L571:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L573;
L572:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L576;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L578;
	asi64(R1) = period;
	if (!asi64(R1)) goto L580;
	R1 = tou64(".");
	goto L579;
L580:
	R1 = tou64("");
L579:
	goto L569;
L578:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L569;
L576:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L573:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L572;
	R1 = tou64("");
	goto L569;
L569:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L583;
L582:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L586;
	goto L587;
L586:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L581;
	goto L585;
L587:
L585:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L583:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L582;
	R1 = tou64("");
	goto L581;
L581:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L590;
	asu64(R1) = s;
	goto L588;
L590:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L588;
L588:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L593;
	R1 = tou64("");
	goto L591;
L593:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L595;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L595:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L597;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L597:
	asu64(R1) = f;
	goto L591;
L591:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L600;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L598;
L600:
	asu64(R1) = s;
	goto L598;
L598:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L603;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L601;
L603:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L601;
L601:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L613;
	R1 = 1;
	goto L611;
L613:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L611;
L611:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L616;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L616:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L618;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L614;
L618:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L620;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L620:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L614:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L624;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L624:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L633;
L633:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B90 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L636;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L639;
L637:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L637;
L639:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L636:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B90 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L643;
	goto L641;
L643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L646;
L644:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L644;
L646:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L641:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L649;
	goto L647;
L649:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L651;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L650;
L651:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L650:
L647:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L653:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L655;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L657;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L657:
	goto L654;
L655:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L659;
	R1 = 0;
	goto L652;
L659:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L661;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L663;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L663:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L661:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L665;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L652;
L665:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L667;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L669;
	R2 = 0;
	goto L668;
L669:
	R2 = 1;
L668:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L671;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L671:
	asu64(R1) = q;
	if (!asu64(R1)) goto L673;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L673:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L675;
	R1 = 5;
	goto L674;
L675:
	R1 = 1;
L674:
	goto L652;
L667:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L677;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L679;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L679;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L679:
	goto L676;
L677:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L681;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L680;
L681:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L683;
	R1 = 5;
	goto L682;
L683:
	R1 = 3;
L682:
	goto L652;
L680:
L676:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L685;
	R1 = 5;
	goto L684;
L685:
	R1 = 2;
L684:
	goto L652;
L652:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L687:
L688:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L692;
	goto L693;
L691:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L690;
L692:
	R1 = 0;
	goto L686;
	goto L690;
L693:
	goto L689;
L690:
	goto L688;
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L695;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L695;
	goto L696;
L695:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L697:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L699;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L700;
	goto L701;
L699:
	goto L687;
	goto L697;
L700:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L686;
	goto L697;
L701:
	goto L697;
	goto L694;
L696:
L694:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L703;
	goto L704;
L703:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L705:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L709;
	goto L710;
L708:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L707;
L709:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L712;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L712:
	goto L706;
	goto L707;
L710:
L707:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L705;
L706:
	goto L702;
L704:
	asu64(R1) = p;
	pstart = asu64(R1);
L713:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L717;
	goto L718;
L716:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L714;
	goto L715;
L717:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L714;
	goto L715;
L718:
L715:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L713;
L714:
L702:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L720;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L720:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L686;
L686:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L724;
L722:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L722;
L724:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L725;
L725:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L726;
L726:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L729;
	R1 = -1;
	goto L728;
L729:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L730;
	R1 = 1;
	goto L728;
L730:
	R1 = 0;
L728:
	goto L727;
L727:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L733;
	R1 = -1;
	goto L732;
L733:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L734;
	R1 = 1;
	goto L732;
L734:
	R1 = 0;
L732:
	goto L731;
L731:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L735;
L735:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L738;
	R1 = -1;
	goto L737;
L738:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L739;
	R1 = 1;
	goto L737;
L739:
	R1 = 0;
L737:
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L740;
L740:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L743;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L742;
L743:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L742:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L744;
L744:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L745;
L745:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L749;
	R1 = 0;
	goto L747;
L749:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L751:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L751;
	asr64(R1) = x;
	goto L750;
L750:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L754;
L754:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L755;
L755:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L759;
L757:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L761;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L756;
L761:
	i += 1; if (i <= av_1) goto L757;
L759:
	R1 = 0;
	goto L756;
L756:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L764;
	asi64(R1) = n;
	goto L762;
L764:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L762;
L762:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L767;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L767:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L769;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L769:
	asu64(R1) = p;
	goto L765;
L765:
	return asu64(R1);
}

static void mwindows_os_init() {
    u64 R1, R2, R3; 
	R1 = -11;
	asi64(R1) = toi64(tou32(R1));
	asu64(R1) = GetStdHandle(asu32(R1));
	mwindows_hconsole = asu64(R1);
	R1 = -10;
	asi64(R1) = toi64(tou32(R1));
	asu64(R1) = GetStdHandle(asu32(R1));
	mwindows_hconsolein = asu64(R1);
	R1 = 0;
	R2 = (u64)&mwindows_lastkey;
	R3 = 8;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 0;
	mwindows_keypending = asi64(R1);
	R1 = 1;
	R2 = 0;
	asi64(R1) = SetConsoleCtrlHandler(asu64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = mwindows_hconsole;
	asi64(R1) = SetConsoleMode(asu64(R2), asu32(R1));
	R1 = 1;
	mwindows_init_flag = asi64(R1);
	return;
}

static i64 mwindows_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10; 
	u32 exitcode;
	i64 status;
	i64 cflags;
	struct $B73 si;
	struct $B8 xpi;
	R1 = 0;
	cflags = asi64(R1);
	R1 = (u64)&si;
	memset(R1, 0, 104);
	R1 = (u64)&xpi;
	memset(R1, 0, 24);
	asi64(R1) = newconsole;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L773;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L774;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L775;
	goto L776;
L773:
	R1 = 32;
	cflags = asi64(R1);
	goto L772;
L774:
	R1 = 48;
	cflags = asi64(R1);
	goto L772;
L775:
	R1 = 48;
	cflags = asi64(R1);
	goto L772;
L776:
L772:
	R1 = 104;
	R2 = (u64)&si;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&xpi;
	R2 = (u64)&si;
	R3 = 0;
	R4 = 0;
	asi64(R5) = cflags;
	R6 = 1;
	R7 = 0;
	R8 = 0;
	asu64(R9) = cmdline;
	R10 = 0;
	asi64(R1) = CreateProcessA(asu64(R10), asu64(R9), asu64(R8), asu64(R7), asi64(R6), asu32(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L778;
	asu32(R1) = GetLastError();
	R1 = toi64(tou32(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = tou64("Winexec error: %lld\n");
	asi32(R1) = printf(asu64(R2), asi64(R1));
	R1 = -1;
	goto L771;
L778:
	R1 = 4294967295;
	R2 = (u64)&xpi;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu32(R1) = WaitForSingleObject(asu64(R2), asu32(R1));
	R1 = (u64)&exitcode;
	R2 = (u64)&xpi;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = GetExitCodeProcess(asu64(R2), asu64(R1));
	R1 = (u64)&xpi;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = (u64)&xpi;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	asu32(R1) = exitcode;
	R1 = toi64(tou32(R1));
	goto L771;
L771:
	return asi64(R1);
}

static i64 mwindows_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10; 
	struct $B73 si;
	struct $B8 xpi;
	R1 = (u64)&si;
	memset(R1, 0, 104);
	R1 = (u64)&xpi;
	memset(R1, 0, 24);
	R1 = 104;
	R2 = (u64)&si;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&xpi;
	R2 = (u64)&si;
	R3 = 0;
	R4 = 0;
	R5 = 32;
	asi64(R6) = newconsole;
	if (!asi64(R6)) goto L781;
	R6 = 16;
	goto L780;
L781:
	R6 = 0;
L780:
	asi64(R5) |= asi64(R6);
	R6 = 1;
	R7 = 0;
	R8 = 0;
	asu64(R9) = cmdline;
	R10 = 0;
	asi64(R1) = CreateProcessA(asu64(R10), asu64(R9), asu64(R8), asu64(R7), asi64(R6), asu32(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&xpi;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = (u64)&xpi;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = 1;
	goto L779;
L779:
	return asi64(R1);
}

static i64 mwindows_os_getch() {
    u64 R1, R2; 
	i64 k;
	asi64(R1) = mwindows_os_getchx();
	R2 = 255;
	asi64(R1) &= asi64(R2);
	k = asi64(R1);
	asi64(R1) = k;
	goto L782;
L782:
	return asi64(R1);
}

static i64 mwindows_os_kbhit() {
    u64 R1, R2; 
	u32 count;
	asi64(R1) = mwindows_init_flag;
	if (asi64(R1)) goto L785;
	mwindows_os_init();
L785:
	R1 = (u64)&count;
	asu64(R2) = mwindows_hconsolein;
	asi64(R1) = GetNumberOfConsoleInputEvents(asu64(R2), asu64(R1));
	asu32(R1) = count;
	R1 = toi64(tou32(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	goto L783;
L783:
	return asi64(R1);
}

static u64 mwindows_os_getdllinst(u64 name) {
    u64 R1; 
	u64 hinst;
	asu64(R1) = name;
	asu64(R1) = LoadLibraryA(asu64(R1));
	hinst = asu64(R1);
	asu64(R1) = hinst;
	goto L786;
L786:
	return asu64(R1);
}

static u64 mwindows_os_getdllprocaddr(i64 hinst, u64 name) {
    u64 R1, R2; 
	asu64(R1) = name;
	asi64(R2) = hinst;
	asu64(R1) = GetProcAddress(asu64(R2), asu64(R1));
	goto L787;
L787:
	return asu64(R1);
}

static void mwindows_os_initwindows() {
    u64 R1; 
	mwindows_os_init();
	R1 = tou64("pcc001");
	mwindows_os_gxregisterclass(asu64(R1));
	return;
}

static void mwindows_os_gxregisterclass(u64 classname) {
    u64 R1, R2, R3; 
	struct $B1 r;
	asu8(R1) = mwindows_os_gxregisterclass_registered;
	if (!asu8(R1)) goto L791;
	goto L789;
L791:
	R1 = (u64)&r;
	memset(R1, 0, 80);
	R1 = 80;
	R2 = (u64)&r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 40;
	R2 = (u64)&r;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mwindows_mainwndproc;
	R2 = (u64)&r;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 32512;
	R2 = 0;
	asu64(R1) = LoadCursorA(asu64(R2), asu64(R1));
	R2 = (u64)&r;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 16;
	R2 = (u64)&r;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = classname;
	R2 = (u64)&r;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&r;
	asu32(R1) = RegisterClassExA(asu64(R1));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L793;
	asu32(R1) = GetLastError();
	R1 = toi64(tou32(R1));
	asu64(R2) = classname;
	R3 = tou64("Regclass error: %lld %lld\n");
	asi32(R1) = printf(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	exit(R1);
L793:
	R1 = 1;
	mwindows_os_gxregisterclass_registered = asu8(R1);
L789:
	return;
}

static i64 mwindows_mainwndproc(u64 hwnd, u32 message, u64 wparam, u64 lparam) {
    u64 R1, R2, R3, R4; 
	struct $B12 m;
	i64 result;
// PROC LOCAL STATICS GO HERE
	static i64 mwindows_mainwndproc_count = 0;
	asu64(R1) = hwnd;
	R2 = (u64)&m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu32(R1) = message;
	R2 = (u64)&m;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = wparam;
	R2 = (u64)&m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lparam;
	R2 = (u64)&m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&m;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&m;
	R3 = 44;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = mwindows_wndproc_callbackfn;
	if (!asu64(R1)) goto L796;
	R1 = (u64)&m;
	asu64(R2) = mwindows_wndproc_callbackfn;
	asi64(R1) = ((F1)R2)(asu64(R1));
	result = asi64(R1);
	goto L795;
L796:
	R1 = 0;
	result = asi64(R1);
L795:
	R1 = (u64)&m;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L798;
	R1 = 0;
	goto L794;
L798:
	asi64(R1) = result;
	if (asi64(R1)) goto L800;
	asu64(R1) = lparam;
	asu64(R2) = wparam;
	asu32(R3) = message;
	R3 = toi64(tou32(R3));
	asu64(R4) = hwnd;
	asi64(R1) = DefWindowProcA(asu64(R4), asu32(R3), asu64(R2), asu64(R1));
	goto L799;
L800:
	R1 = 0;
L799:
	goto L794;
L794:
	return asi64(R1);
}

static void mwindows_os_setmesshandler(u64 addr) {
    u64 R1; 
	asu64(R1) = addr;
	mwindows_wndproc_callbackfn = asu64(R1);
	return;
}

static i64 mwindows_os_getchx() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 count;
	i64 charcode;
	i64 keyshift;
	i64 keycode;
	i64 altdown;
	i64 ctrldown;
	i64 shiftdown;
	i64 capslock;
	asi64(R1) = mwindows_init_flag;
	if (asi64(R1)) goto L804;
	mwindows_os_init();
L804:
	asi64(R1) = mwindows_keypending;
	if (!asi64(R1)) goto L806;
	(R1_B17) = mwindows_pendkey;
	mwindows_lastkey = (R1_B17);
	R1 = 0;
	mwindows_keypending = asi64(R1);
	goto L805;
L806:
	R1 = (u64)&mwindows_lastkey;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L808;
L809:
	R1 = 0;
	count = asi64(R1);
	R1 = (u64)&count;
	R2 = 1;
	R3 = (u64)&mwindows_lastkey;
	asu64(R4) = mwindows_hconsolein;
	asi64(R1) = ReadConsoleInputA(asu64(R4), asu64(R3), asu32(R2), asu64(R1));
	R1 = (u64)&mwindows_lastkey;
	R2 = 0;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L809;
	R1 = (u64)&mwindows_lastkey;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L809;
L808:
L805:
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L813;
	R1 = 1;
	goto L812;
L813:
	R1 = 0;
L812:
	altdown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 12;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L815;
	R1 = 1;
	goto L814;
L815:
	R1 = 0;
L814:
	ctrldown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L817;
	R1 = 1;
	goto L816;
L817:
	R1 = 0;
L816:
	shiftdown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 128;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L819;
	R1 = 1;
	goto L818;
L819:
	R1 = 0;
L818:
	capslock = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 8;
	R1 += (i64)R2;
	(*tou16p(R1)) -=1;
	R1 = (u64)&mwindows_lastkey;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	charcode = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 10;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 255;
	asi64(R1) &= asi64(R2);
	keycode = asi64(R1);
	asi64(R1) = charcode;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L821;
	asi64(R1) = charcode;
	R2 = -128;
	if (asi64(R1) >= asi64(R2)) goto L823;
	R1 = 0;
	charcode = asi64(R1);
	goto L822;
L823:
	R1 = 256;
	R2 = (u64)&charcode;
	*toi64p(R2) += asi64(R1);
L822:
L821:
	asi64(R1) = altdown;
	if (!asi64(R1)) goto L825;
	asi64(R1) = ctrldown;
	if (!asi64(R1)) goto L825;
	asi64(R1) = charcode;
	R2 = 166;
	if (asi64(R1) != asi64(R2)) goto L825;
	R1 = 0;
	R2 = R1;
	ctrldown = asi64(R2);
	altdown = asi64(R1);
	goto L824;
L825:
	asi64(R1) = altdown;
	if (asi64(R1)) goto L828;
	asi64(R1) = ctrldown;
	if (!asi64(R1)) goto L827;
L828:
	R1 = 0;
	charcode = asi64(R1);
	asi64(R1) = keycode;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L830;
	asi64(R1) = keycode;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L830;
	asi64(R1) = keycode;
	R2 = 64;
	asi64(R1) -= asi64(R2);
	charcode = asi64(R1);
L830:
L827:
L824:
	asi64(R1) = capslock;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = altdown;
	R3 = 2;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = ctrldown;
	R3 = 1;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = shiftdown;
	asi64(R1) |= asi64(R2);
	keyshift = asi64(R1);
	asi64(R1) = keyshift;
	R2 = 24;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = keycode;
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = charcode;
	asi64(R1) |= asi64(R2);
	goto L802;
L802:
	return asi64(R1);
}

static u64 mwindows_os_getos() {
    u64 R1; 
	R1 = tou64("W64");
	goto L831;
L831:
	return asu64(R1);
}

static i64 mwindows_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L832;
L832:
	return asi64(R1);
}

static i64 mwindows_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L833;
L833:
	return asi64(R1);
}

static void mwindows_os_sleep(i64 a) {
    u64 R1; 
	asi64(R1) = a;
	Sleep(asu32(R1));
	return;
}

static u64 mwindows_os_getstdin() {
    u64 R1, R2; 
	R1 = tou64("rb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L835;
L835:
	return asu64(R1);
}

static u64 mwindows_os_getstdout() {
    u64 R1, R2; 
	R1 = tou64("wb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L836;
L836:
	return asu64(R1);
}

static u64 mwindows_os_gethostname() {
    u64 R1, R2, R3; 
	R1 = 300;
	R2 = (u64)&mwindows_os_gethostname_name;
	R3 = 0;
	asu32(R1) = GetModuleFileNameA(asu64(R3), asu64(R2), asu32(R1));
	R1 = (u64)&mwindows_os_gethostname_name;
	goto L837;
L837:
	return asu64(R1);
}

static u64 mwindows_os_getmpath() {
    u64 R1; 
	R1 = tou64("C:@@@@\\m\\\"");
	goto L838;
L838:
	return asu64(R1);
}

static i64 mwindows_os_clock() {
    u64 R1; 
	asi64(R1) = mwindows_os_hpcounter();
	goto L839;
L839:
	return asi64(R1);
}

static i64 mwindows_os_ticks() {
    u64 R1; 
	asi64(R1) = GetTickCount64();
	goto L840;
L840:
	return asi64(R1);
}

static i64 mwindows_os_iswindows() {
    u64 R1; 
	R1 = 1;
	goto L841;
L841:
	return asi64(R1);
}

static void mwindows_os_getsystime(u64 tm) {
    u64 R1; 
	asu64(R1) = tm;
	GetLocalTime(asu64(R1));
	return;
}

static void mwindows_os_peek() {
    u64 R1, R2, R3, R4, R5; 
	i64 ticks;
	struct $B5 m;
	asi64(R1) = GetTickCount64();
	ticks = asi64(R1);
	asi64(R1) = ticks;
	asi64(R2) = mwindows_os_peek_lastticks;
	asi64(R1) -= asi64(R2);
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L845;
	asi64(R1) = ticks;
	mwindows_os_peek_lastticks = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = (u64)&m;
	asu32(R1) = PeekMessageA(asu64(R5), asu64(R4), asu32(R3), asu32(R2), asu32(R1));
L845:
	return;
}

static u64 mwindows_os_allocexecmem(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u32 oldprot;
	i64 status;
	R1 = 1;
	R2 = 12288;
	asi64(R3) = n;
	R4 = 0;
	asu64(R1) = VirtualAlloc(asu64(R4), asu32(R3), asu32(R2), asu32(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L848;
	R1 = 0;
	goto L846;
L848:
	R1 = (u64)&oldprot;
	R2 = 64;
	asi64(R3) = n;
	asu64(R4) = p;
	asu32(R1) = VirtualProtect(asu64(R4), asu32(R3), asu32(R2), asu64(R1));
	R1 = toi64(tou32(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L850;
	R1 = 0;
	goto L846;
L850:
	asu64(R1) = p;
	goto L846;
L846:
	return asu64(R1);
}

static i64 mwindows_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1, R2, R3; 
	u64 hfind;
	struct $B91 file;
	i64 nfiles;
	struct $B15 path;
	struct $B15 fullfilename;
	R1 = 0;
	nfiles = asi64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&file;
	asu64(R2) = filespec;
	asu64(R1) = FindFirstFileA(asu64(R2), asu64(R1));
	R2 = R1;
	hfind = asu64(R2);
	R2 = -1;
	if (asu64(R1) == asu64(R2)) goto L853;
L854:
	R1 = (u64)&file;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L858;
	asi64(R1) = t;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L860;
	goto L855;
L860:
	goto L857;
L858:
	asi64(R1) = t;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L862;
	goto L855;
L862:
L857:
	asi64(R1) = nfiles;
	asi64(R2) = capacity;
	if (asi64(R1) < asi64(R2)) goto L864;
	R1 = -1;
	nfiles = asi64(R1);
	goto L856;
L864:
	asi64(R1) = t;
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L866;
	R1 = (u64)&file;
	R2 = 44;
	R1 += (i64)R2;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L866:
	R1 = (u64)&path;
	R2 = (u64)&fullfilename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&file;
	R2 = 44;
	R1 += (i64)R2;
	R2 = (u64)&fullfilename;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&fullfilename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = dest;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L855:
	R1 = (u64)&file;
	asu64(R2) = hfind;
	asu32(R1) = FindNextFileA(asu64(R2), asu64(R1));
	if (asu32(R1)) goto L854;
L856:
	asu64(R1) = hfind;
	asu32(R1) = FindClose(asu64(R1));
L853:
	asi64(R1) = nfiles;
	goto L851;
L851:
	return asi64(R1);
}

static i64 mwindows_os_hpcounter() {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = mwindows_hpfreq;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L869;
	asi64(R1) = mwindows_os_hpfreq();
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	mwindows_hpfreq = asi64(R1);
L869:
	R1 = (u64)&a;
	asu32(R1) = QueryPerformanceCounter(asu64(R1));
	asi64(R1) = a;
	asi64(R2) = mwindows_hpfreq;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	goto L867;
L867:
	return asi64(R1);
}

static i64 mwindows_os_hpfreq() {
    u64 R1; 
	i64 a;
	R1 = (u64)&a;
	asu32(R1) = QueryPerformanceFrequency(asu64(R1));
	asi64(R1) = a;
	goto L870;
L870:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L873;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L872;
L873:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L872:
	goto L871;
L871:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L876;
	R4 = 0;
	goto L875;
L876:
	R4 = 73;
L875:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L874;
L874:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L881;
	case 1: goto L882;
	case 2: goto L883;
	case 3: goto L884;
	case 4: goto L885;
	case 5: goto L886;
	case 6: goto L887;
	case 7: goto L880;
	case 8: goto L888;
	case 9: goto L889;
	case 10: goto L890;
	case 11: goto L891;
	case 12: goto L892;
	default: goto L880;
    };
// SWITCH
L881:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F2)R1)();
	goto L877;
	goto L878;
L882:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F3)R2)(asi64(R1));
	goto L877;
	goto L878;
L883:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F4)R3)(asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L884:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F5)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L885:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F6)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L886:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F7)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L887:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F8)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L888:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F9)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L889:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F10)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L890:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F11)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L891:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F12)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L892:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F13)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L880:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L878:
	R1 = 0;
	goto L877;
L877:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L895;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L896;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L897;
	goto L898;
L895:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F14)R1)();
	R1 = toi64(asr64(R1));
	goto L893;
	goto L894;
L896:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F15)R2)(asi64(R1));
	x = asr64(R1);
	goto L894;
L897:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F16)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L894;
L898:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L894:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L893;
L893:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

static u64 pc_api_pcl_start(u64 name, i64 nunits) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_pcldone;
	if (!asu8(R1)) goto L902;
	R1 = tou64("PCL start?");
	pc_api_pclerror(asu64(R1));
L902:
	asu64(R1) = name;
	if (!asu64(R1)) goto L904;
	R1 = 9;
	asu64(R2) = name;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	pc_decls_currprog = asu64(R1);
L904:
	asi64(R1) = pc_api_initpcalloc;
	pc_api_pcalloc = asi64(R1);
	asi64(R1) = nunits;
	if (!asi64(R1)) goto L906;
	asi64(R1) = nunits;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nunits = asi64(R1);
	goto L908;
L907:
	R1 = 2;
	R2 = (u64)&pc_api_pcalloc;
	*toi64p(R2) *= asi64(R1);
L908:
	asi64(R1) = pc_api_pcalloc;
	asi64(R2) = nunits;
	if (asi64(R1) < asi64(R2)) goto L907;
L906:
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pc_api_pcstart = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	asi64(R2) = pc_api_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	R1 = 0;
	pc_api_pcfixed = asu8(R1);
	R1 = 0;
	pc_api_pcseqno = asi64(R1);
	R1 = 0;
	pc_api_pcneedfntable = asi64(R1);
	R1 = 0;
	pc_api_mlabelno = asi64(R1);
	asu64(R1) = pc_decls_currprog;
	goto L900;
L900:
	return asu64(R1);
}

static void pc_api_pcl_end() {
    u64 R1, R2; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) < asu64(R2)) goto L912;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L912;
	R1 = 0;
	R2 = 136;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L912:
	R1 = 1;
	pc_decls_pcldone = asu8(R1);
	return;
}

static u64 pc_api_pcl_writepcl(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writeallpcl();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L915;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L917;
	msysc_m$print_startcon();
	R1 = tou64("Writing PCL");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L917:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L914;
L915:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L914:
	goto L913;
L913:
	return asu64(R1);
}

static u64 pc_api_pcl_writepst(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writepst();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L920;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L922;
	msysc_m$print_startcon();
	R1 = tou64("Writing PST");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L922:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L919;
L920:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L919:
	goto L918;
L918:
	return asu64(R1);
}

static void pc_api_pcl_genmcl() {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	return;
}

static void pc_api_pcl_genss(i64 obj) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_genss(asi64(R1));
	return;
}

static u64 pc_api_pcl_writess(u64 filename, i64 obj) {
    u64 R1, R2; 
	u64 ssstr;
	u64 f;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_genss(asi64(R1));
	asi64(R1) = obj;
	asi64(R1) = !asi64(R1);
	asu64(R1) = mc_writess_dummy_writessdata(asi64(R1));
	ssstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L927;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = ssstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = ssstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L926;
L927:
	asu64(R1) = ssstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L926:
	goto L925;
L925:
	return asu64(R1);
}

static u64 pc_api_pcl_writeasm(u64 filename, i64 atype) {
    u64 R1, R2; 
	u64 asmstr;
	u64 f;
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L930;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
L930:
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asu64(R1) = mc_writenasm_getassemstr();
	asmstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L932;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L934;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L934:
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = asmstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = asmstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L931;
L932:
	asu64(R1) = asmstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L931:
	goto L928;
L928:
	return asu64(R1);
}

static void pc_api_pcl_writeobj(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 1;
	mc_genss_genss(asi64(R1));
	R1 = 0;
	pc_api_phighmem = asu8(R1);
	msysc_m$print_startcon();
	R1 = tou64("PHIGHMEM=");
	msysc_m$print_str_nf(asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	asu64(R1) = filename;
	mc_writeobj_writecoff(asu64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_objtime = asi64(R1);
	return;
}

static void pc_api_pcl_writedll(u64 filename) {
    u64 R1, R2, R3; 
	i64 tt;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = filename;
	mc_writeexe_writeexe(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writeexe(u64 filename) {
    u64 R1, R2, R3; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	R1 = 0;
	R2 = 0;
	asu64(R3) = filename;
	mc_writeexe_writeexe(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writemx(u64 filename) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asu64(R1) = filename;
	mx_write_writemcx(asu64(R1));
	return;
}

static void pc_api_pcl_exec() {
    u64 R1, R2; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	R2 = tou64("dummy");
	mx_run_runlibfile(asu64(R2), asi64(R1));
	return;
}

static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames) {
    u64 R1, R2; 
	asi64(R1) = highmem;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L942;
	asi64(R1) = highmem;
	pc_api_phighmem = asu8(R1);
L942:
	asi64(R1) = verbose;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L944;
	asi64(R1) = verbose;
	pc_decls_pverbose = asu8(R1);
L944:
	asi64(R1) = shortnames;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L946;
	asi64(R1) = shortnames;
	pc_api_fpshortnames = asu8(R1);
L946:
	return;
}

static void pc_api_extendpclblock() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	i64 lengthused;
	u64 newpcstart;
	asi64(R1) = pc_api_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	lengthused = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	asi64(R1) = lengthused;
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pc_api_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newpcalloc;
	asi64(R2) = lengthused;
	asi64(R1) -= asi64(R2);
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newpcstart;
	asi64(R3) = lengthused;
	R2 += (i64)R3*32;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = pc_api_pccurr;
	asu64(R3) = pc_api_pcstart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 32;
	R1 += (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	pc_api_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	pc_api_pcalloc = asi64(R1);
	return;
}

static u64 pc_api_newpcl() {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcend;
	if (asu64(R1) < asu64(R2)) goto L950;
	pc_api_extendpclblock();
L950:
	R1 = (u64)&pc_api_pccurr;
	(*tou64p(R1)) += 32;
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = pc_api_pccurr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc_api_pclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = pc_api_pccurr;
	goto L948;
L948:
	return asu64(R1);
}

static void pc_api_pc_gen(i64 opcode, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L953;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L953:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genx(i64 opcode, i64 x, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L957;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L957:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L960;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L960:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L963;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L963:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cond;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 pc_api_genint(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L964;
L964:
	return asu64(R1);
}

static u64 pc_api_genreal(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L967;
	R1 = 5;
	goto L966;
L967:
	R1 = 6;
L966:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L965;
L965:
	return asu64(R1);
}

static u64 pc_api_genrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L970;
	R1 = 10;
	goto L969;
L970:
	R1 = 11;
L969:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L968;
L968:
	return asu64(R1);
}

static u64 pc_api_genstring(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L971;
L971:
	return asu64(R1);
}

static u64 pc_api_genpcstrimm(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L972;
L972:
	return asu64(R1);
}

static u64 pc_api_genlabel(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L973;
L973:
	return asu64(R1);
}

static u64 pc_api_genmem(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L974;
L974:
	return asu64(R1);
}

static u64 pc_api_genmemaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L975;
L975:
	return asu64(R1);
}

static u64 pc_api_gendata(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 12;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L976;
L976:
	return asu64(R1);
}

static void pc_api_gencomment(u64 s) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L980;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L979;
L980:
	goto L977;
L979:
	asu64(R1) = s;
	asu64(R1) = pc_api_genpcstrimm(asu64(R1));
	R2 = 135;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L977:
	return;
}

static u64 pc_api_genname(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L981;
L981:
	return asu64(R1);
}

static u64 pc_api_gennameaddr(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L982;
L982:
	return asu64(R1);
}

static u64 pc_api_genassem(u64 code) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = code;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 9;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L983;
L983:
	return asu64(R1);
}

static u64 pc_api_strpmode(i64 mode, i64 size) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L986;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L987;
	goto L988;
L986:
	R1 = tou64("mem:");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = size;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_strpmode_str;
	goto L985;
L987:
	R1 = tou64("---");
	goto L985;
L988:
	R1 = (u64)&pc_tables_pstdnames;
	asi64(R2) = mode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L985:
	goto L984;
L984:
	return asu64(R1);
}

static void pc_api_pc_setmode(i64 m, i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L991;
	asi64(R1) = size;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L990;
L991:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L990:
	R1 = (u64)&pc_tables_pclhastype;
	asu64(R2) = pc_api_pccurr;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L993;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L993:
	return;
}

static void pc_api_pc_setmode2(i64 m) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void pc_api_pc_setxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setscaleoff(i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = scale;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_addoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	return;
}

static void pc_api_pc_setincr(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnargs(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnvariadics(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setalign(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_perror(u64 mess) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = mess;
	pc_api_perror_s(asu64(R2), asu64(R1));
	return;
}

static void pc_api_perror_s(u64 mess, u64 param) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = param;
	if (!asu64(R1)) goto L1006;
	msysc_m$print_startcon();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L1006:
	R1 = 1;
	exit(R1);
	return;
}

static u64 pc_api_getbasename(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L1009;
L1008:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L1009:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) <= asu64(R2)) goto L1011;
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L1008;
L1011:
	asu64(R1) = t;
	goto L1007;
L1007:
	return asu64(R1);
}

static void pc_api_pclerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addsymbol(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_psymboltable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1015;
	asu64(R1) = d;
	R2 = R1;
	pc_decls_psymboltablex = asu64(R2);
	pc_decls_psymboltable = asu64(R1);
	goto L1014;
L1015:
	asu64(R1) = d;
	asu64(R2) = pc_decls_psymboltablex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	pc_decls_psymboltablex = asu64(R1);
L1014:
	return;
}

static u64 pc_api_pc_makesymbol(u64 s, i64 id) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = id;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1018;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1019;
	goto L1020;
L1018:
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1017;
L1019:
	R1 = 1;
	asu64(R2) = d;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	id = asi64(R1);
	goto L1017;
L1020:
L1017:
	asi64(R1) = id;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1023;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1022;
L1023:
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1021;
L1022:
	asi64(R1) = id;
	if (!asi64(R1)) goto L1024;
	asu64(R1) = d;
	pc_api_pc_addsymbol(asu64(R1));
L1024:
L1021:
	asu64(R1) = d;
	goto L1016;
L1016:
	return asu64(R1);
}

static u64 pc_api_getfullname(u64 d, i64 backtick) {
    u64 R1, R2, R3; 
	i64 n;
	u64 e;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	R2 = (u64)&pc_api_getfullname_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1027;
	R1 = tou64("`");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L1027:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1029;
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1031;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1030;
L1031:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1030:
	R1 = (u64)&pc_api_getfullname_str;
	goto L1025;
L1029:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1034;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1033;
L1034:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_getfullname_str;
	goto L1025;
L1033:
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1036;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1035;
L1036:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L1035:
	goto L1025;
L1025:
	return asu64(R1);
}

static void pc_api_pcerrorstop(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addplib(u64 name) {
    u64 R1, R2, R3; 
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L1040;
	R1 = tou64("Too many libs");
	pc_api_perror(asu64(R1));
L1040:
	R1 = tou64("");
	asu64(R2) = name;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&pc_decls_plibfiles;
	R3 = (u64)&pc_decls_nplibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1043;
	R1 = tou64("Nested proc");
	pc_api_pclerror(asu64(R1));
L1043:
	asu64(R1) = d;
	asu64(R1) = pc_api_genmem(asu64(R1));
	asi64(R2) = threaded;
	if (!asi64(R2)) goto L1045;
	R2 = 121;
	goto L1044;
L1045:
	R2 = 120;
L1044:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1047;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L1047:
	R1 = 0;
	asi64(R2) = mode;
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1049;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl proc:");
	asu64(R1) = pc_api_addstr(asu64(R2), asu64(R1));
	pc_api_pclerror(asu64(R1));
L1049:
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1051;
	asi64(R1) = isentry;
	if (!asi64(R1)) goto L1051;
	asu64(R1) = d;
	pc_decls_entryproc = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 83;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1051:
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_setimport(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_addparam(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1055;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1055:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1057;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1056;
L1057:
	goto L1059;
L1058:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1059:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1058;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1056:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1062;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1062:
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	return;
}

static void pc_api_pc_addlocal(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1065;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1065:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1067;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1066;
L1067:
	goto L1069;
L1068:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1069:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1068;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1066:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1072;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1072:
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	return;
}

static void pc_api_pc_endproc() {
    u64 R1, R2; 
	asu64(R1) = pc_decls_currfunc;
	if (asu64(R1)) goto L1075;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1075:
	R1 = 0;
	R2 = 122;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_decls_currfunc = asu64(R1);
	return;
}

static u64 pc_api_addstr(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = t;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_addstr_str;
	goto L1076;
L1076:
	return asu64(R1);
}

static void pc_api_merror(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1079;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F17)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L1078;
L1079:
	R1 = 0;
	lineno = asi64(R1);
	R1 = tou64("?");
	filename = asu64(R1);
L1078:
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1081;
	msysc_m$print_startcon();
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1081:
	msysc_m$print_startcon();
	R1 = tou64("MCL Error: # (#) on Line: # in #, PCL:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pc_decls_ppseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	asu64(R2) = filename;
	pc_api_pcerrorstop(asu64(R2), asi64(R1));
	return;
}

static u64 pc_api_pc_duplpst(u64 d) {
    u64 R1, R2, R3; struct $B22 R1_B22; 
	u64 e;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	(R1_B22) = *(struct $B22*)(R1);
	asu64(R2) = e;
	*(struct $B22*)(R2) = (R1_B22);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = e;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L1082;
L1082:
	return asu64(R1);
}

static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip) {
    u64 R1; 
	asi64(R1) = cmdskip;
	pc_decls_pcmdskip = asi64(R1);
	return;
}

static i64 pc_api_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	asu64(R1) = t;
	t0 = asu64(R1);
	goto L1086;
L1085:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1089;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1090;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1091;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1092;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1093;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1094;
	goto L1095;
L1089:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1090:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1091:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1092:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1093:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1094:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1095:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1097;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1097;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1096;
L1097:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 120;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2h");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1096:
L1088:
L1086:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L1085;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1084;
L1084:
	return asi64(R1);
}

static void pc_diags_strpcl(u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	i64 opcode;
	i64 n;
	i64 x;
	i64 y;
	u64 d;
	u64 e;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asi64(R1) = opcode;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1100;
	R2 = 128;
	if (asi64(R1) == asi64(R2)) goto L1101;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1102;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1103;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1103;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1104;
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L1105;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1106;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1107;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1107;
	goto L1108;
L1100:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	pc_diags_strlabel(asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1110;
	R1 = tou64(" NOT USED");
	pc_diags_psstr(asu64(R1));
L1110:
	goto L1098;
	goto L1099;
L1101:
	R1 = tou64("! ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
	goto L1098;
	goto L1099;
L1102:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L1112;
	R1 = tou64("!");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	goto L1111;
L1112:
	R1 = tou64("! - - -");
	pc_diags_psstr(asu64(R1));
L1111:
	goto L1098;
	goto L1099;
L1103:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = opcode;
	R2 = 121;
	if (asi64(R1) != asi64(R2)) goto L1114;
	R1 = tou64("tcproc");
	pc_diags_psstr(asu64(R1));
	goto L1113;
L1114:
	R1 = tou64("proc");
	pc_diags_psstr(asu64(R1));
L1113:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	pc_diags_psname(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1116;
	R1 = tou64("::");
	goto L1115;
L1116:
	R1 = tou64(":");
L1115:
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1118;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1118:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1122;
L1119:
	R1 = tou64("    param    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1122:
	asu64(R1) = e;
	if (asu64(R1)) goto L1119;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1126;
L1123:
	R1 = tou64("    local    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1126:
	asu64(R1) = e;
	if (asu64(R1)) goto L1123;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1128;
	R1 = tou64("    rettype  ");
	pc_diags_psstr(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
L1128:
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1130;
	R1 = tou64("    variadic");
	pc_diags_psstrline(asu64(R1));
L1130:
	goto L1098;
	goto L1099;
L1104:
	R1 = tou64("endproc");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	goto L1098;
	goto L1099;
L1105:
	R1 = tou64("endprog");
	pc_diags_psstr(asu64(R1));
	goto L1098;
	goto L1099;
L1106:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1132;
	asu64(R1) = p;
	pc_diags_psdata(asu64(R1));
	goto L1098;
L1132:
	goto L1099;
L1107:
	goto L1133;
	goto L1099;
L1108:
L1099:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
// pc_diags.strpcl.skiptab:
L1133:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1135;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L1136;
	goto L1137;
L1135:
	R1 = tou64("jump");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1134;
L1136:
	R1 = tou64("set");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1134;
L1137:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L1134:
	R1 = 32;
	R2 = 9;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1139;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pclhastype;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1141;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1141:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1139:
	R1 = 32;
	R2 = 4;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_pclextra;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L1143;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	x = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L1146;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1145;
L1146:
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1145:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1148;
	asi64(R1) = y;
	if (!asi64(R1)) goto L1148;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = y;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1148:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1143:
	R1 = 32;
	R2 = 5;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1150;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	pc_diags_psstr(asu64(R1));
L1150:
	R1 = 40;
	pc_diags_pstabto(asi64(R1));
L1098:
	return;
}

static u64 pc_diags_stropnd(u64 p) {
    u64 R1, R2, R3; 
	i64 length;
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1153;
	R1 = tou64("");
	goto L1151;
L1153:
	R1 = 0;
	R2 = (u64)&pc_diags_stropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1155;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1156;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1156;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1156;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1156;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1157;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1158;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1159;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1160;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1161;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1162;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1163;
	goto L1164;
L1155:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1151;
	goto L1154;
L1156:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L1166;
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("infinity");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L1165;
L1166:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e16.16");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L1165:
	goto L1154;
L1157:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	length = asi64(R2);
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L1168;
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_diags_stropnd_str;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1167;
L1168:
	asu64(R1) = pc_diags_stropnd_longstring;
	if (!asu64(R1)) goto L1170;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_diags_stropnd_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1170:
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	pc_api_longstringlen = asi64(R1);
	asi64(R1) = pc_api_longstringlen;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_diags_stropnd_longstring = asu64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	length = asi64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+2)) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	goto L1151;
L1167:
	goto L1154;
L1158:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1173;
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L1172;
L1173:
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1175;
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1175:
L1172:
	goto L1154;
L1159:
	R1 = tou64("&");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L1158;
	goto L1154;
L1160:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L1154;
L1161:
	R1 = tou64("");
	goto L1151;
	goto L1154;
L1162:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1151;
	goto L1154;
L1163:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<Data * # (#)>");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L1154;
L1164:
	msysc_m$print_startcon();
	R1 = tou64("---------");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<PCLOPND?>");
	goto L1151;
L1154:
	R1 = (u64)&pc_diags_stropnd_str;
	goto L1151;
L1151:
	return asu64(R1);
}

static u64 pc_diags_strpclstr(u64 p, i64 buffsize) {
    u64 R1, R2; 
	asu64(R1) = pc_diags_dest;
	mlib_gs_free(asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	pc_diags_destlinestart = asi64(R1);
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	R1 = 0;
	asu64(R2) = pc_diags_dest;
	mlib_gs_char(asu64(R2), asi64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = buffsize;
	if (asi64(R1) < asi64(R2)) goto L1178;
	R1 = tou64("<BIGSTR>");
	goto L1176;
L1178:
	asu64(R1) = pc_diags_dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1176;
L1176:
	return asu64(R1);
}

static void pc_diags_writepcl(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1181;
	goto L1182;
L1181:
	goto L1180;
L1182:
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
L1180:
	return;
}

static u64 pc_diags_writeallpcl() {
    u64 R1, R2; 
	u64 p;
	u64 d;
	i64 i;
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = tou64("!PROC PCL");
	asu64(R2) = pc_diags_dest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1186;
L1184:
	R1 = tou64("addlib    \"");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("\"");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	i += 1; if (i <= pc_decls_nplibfiles) goto L1184;
L1186:
	asi64(R1) = pc_decls_nplibfiles;
	if (!asi64(R1)) goto L1188;
	pc_diags_psline();
L1188:
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1192;
L1189:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1194;
	R1 = tou64("extproc    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1196;
	R1 = tou64(" 1");
	pc_diags_psstr(asu64(R1));
L1196:
	pc_diags_psline();
L1194:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1192:
	asu64(R1) = d;
	if (asu64(R1)) goto L1189;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1198;
L1197:
	asu64(R1) = p;
	pc_diags_writepcl(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1198:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1197;
	pc_diags_psline();
	asu64(R1) = pc_api_longstring;
	if (!asu64(R1)) goto L1201;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_api_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1201:
	asu64(R1) = pc_diags_dest;
	goto L1183;
L1183:
	return asu64(R1);
}

static void pc_diags_psstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psstrline(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void pc_diags_psline() {
    u64 R1, R2; 
	R1 = tou64("\n");
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psint(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psname(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_pstabto(i64 n) {
    u64 R1, R2; 
	i64 col;
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = pc_diags_destlinestart;
	asi64(R1) -= asi64(R2);
	col = asi64(R1);
	goto L1209;
L1208:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&col;
	(*toi64p(R1)) += 1;
L1209:
	asi64(R1) = n;
	asi64(R2) = col;
	if (asi64(R1) > asi64(R2)) goto L1208;
	return;
}

static void pc_diags_strlabel(i64 labelno, i64 colon) {
    u64 R1; 
	R1 = tou64("#");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = labelno;
	pc_diags_psint(asi64(R1));
	asi64(R1) = colon;
	if (!asi64(R1)) goto L1213;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1213:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	return;
}

static void pc_diags_psopnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	pc_diags_psstr(asu64(R1));
	return;
}

static void pc_diags_psdata(u64 p) {
    u64 R1, R2; 
	i64 n;
	i64 m;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1217;
	goto L1215;
L1217:
	goto L1219;
L1218:
	asi64(R1) = n;
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L1222;
	R1 = 20;
	m = asi64(R1);
L1222:
	asi64(R1) = m;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = tou64("    data mem:");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	pc_diags_psint(asi64(R1));
	R1 = tou64("  ");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L1224;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
L1224:
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1227;
L1225:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L1225;
L1227:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1229;
	pc_diags_psline();
L1229:
L1219:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1218;
L1215:
	return;
}

static u64 pc_diags_writepst() {
    u64 R1, R2; 
	u8 localfile;
	i64 i;
	i64 j;
	u64 d;
	u64 e;
	R1 = 0;
	localfile = asu8(R1);
	R1 = 0;
	i = asi64(R1);
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("PROC PC Symbol table");
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1234;
L1231:
	R1 = tou64("H");
	asu64(R2) = d;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("25jl");
	asu64(R2) = d;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1237;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1236;
L1237:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1241;
L1238:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1241:
	asu64(R1) = e;
	if (asu64(R1)) goto L1238;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1245;
L1242:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1245:
	asu64(R1) = e;
	if (asu64(R1)) goto L1242;
L1236:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1234:
	asu64(R1) = d;
	if (asu64(R1)) goto L1231;
	pc_diags_psline();
	asu64(R1) = pc_diags_dest;
	goto L1230;
L1230:
	return asu64(R1);
}

static void pc_diags_writepsymbol(u64 d, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u8 localfile;
	struct $B16 str;
	i64 av_1;
	R1 = 0;
	localfile = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("4");
	asu64(R2) = d;
	R3 = 120;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = (u64)&pc_tables_idnames;
	asu64(R2) = d;
	R3 = 72;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	R1 = 8;
	R2 = (u64)&pc_tables_idnames;
	asu64(R3) = d;
	R4 = 72;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1249;
L1247:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	if (--asi64(av_1)) goto L1247;
L1249:
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmt;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1251;
	R1 = tou64(" Pm:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" Loc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	pc_diags_psint(asi64(R1));
L1251:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1253;
	R1 = tou64(" Exp");
	pc_diags_psstr(asu64(R1));
L1253:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1255;
	R1 = tou64(" Imp");
	pc_diags_psstr(asu64(R1));
L1255:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1257;
	R1 = tou64(" Var:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
L1257:
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1259;
	R1 = tou64(" TC");
	pc_diags_psstr(asu64(R1));
L1259:
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1261;
	R1 = tou64(" Dot");
	pc_diags_psstr(asu64(R1));
L1261:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1263;
	R1 = tou64(" ENTRY PT");
	pc_diags_psstr(asu64(R1));
L1263:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1265;
	R1 = tou64(" .PCADDR =");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
L1265:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1267;
	R1 = tou64(" (");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1267:
	R1 = 0;
	if (!asu16(R1)) goto L1269;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1269;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1269;
	R1 = tou64(" (Proc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(") (D:");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1269:
	R1 = 0;
	if (!asu16(R1)) goto L1271;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1271;
	asu64(R1) = d;
	R2 = 104;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1271;
	R1 = tou64(" Has statics");
	pc_diags_psstr(asu64(R1));
L1271:
	pc_diags_psline();
	return;
}

static void pc_diags_showprocinfo(u64 d) {
    u64 R1, R2; 
	struct $B16 str;
	u64 p;
	u64 e;
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1274;
	goto L1272;
L1274:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("PROC INFO FOR: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Params:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Locals:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Leaf:     #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Nmaxargs: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Assem:    #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  MCLdone:  #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Hasblocks:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1278;
L1275:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Pm: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1278:
	asu64(R1) = e;
	if (asu64(R1)) goto L1275;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1282;
L1279:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Loc: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1282:
	asu64(R1) = e;
	if (asu64(R1)) goto L1279;
	pc_diags_psline();
L1272:
	return;
}

static void pc_reduce_pcl_reducetest() {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	i64 nn;
	i64 seqno;
	i64 lab;
	i64 lab2;
	i64 nargs;
	u64 pc;
	u64 newpc;
	u64 pcnext;
	u64 pcnext2;
	u64 pcproc;
	u64 labelmap;
	u64 pdef;
	struct $B16 callstack;
	i64 ncall;
	i64 nprocs;
	i64 nleaf;
	i64 nallparams;
	i64 nalllocals;
	i64 offset;
	i64 av_1;
	R1 = 0;
	nprocs = asi64(R1);
	R1 = 0;
	nleaf = asi64(R1);
	R1 = 0;
	nallparams = asi64(R1);
	R1 = 0;
	nalllocals = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nn = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	goto L1287;
L1284:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1289;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1290;
	goto L1291;
L1289:
	goto L1288;
L1290:
	asu64(R1) = pc_api_icheckasmlabel;
	if (!asu64(R1)) goto L1293;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_icheckasmlabel;
	asi64(R1) = ((F1)R2)(asu64(R1));
	lab = asi64(R1);
	asi64(R1) = lab;
	if (!asi64(R1)) goto L1295;
	asu64(R1) = labelmap;
	asi64(R2) = lab;
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1295:
L1293:
	goto L1288;
L1291:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1297;
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1297:
L1288:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1287:
	asu64(R1) = pc;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1284;
// pc_reduce.pcl_reducetest.skip:
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	newpc = asu64(R1);
	R1 = 0;
	seqno = asi64(R1);
	asi64(R1) = nn;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1301;
L1299:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcnext = asu64(R1);
	R1 = (u64)&pc_tables_pclargs;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	nargs = asi64(R2);
	if (!asi64(R1)) goto L1303;
	asi64(R1) = nargs;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L1305;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	nargs = asi64(R1);
L1305:
	asu64(R1) = pc_decls_pinfo;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = nargs;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1303:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1307;
	asu64(R1) = pc_decls_pinfo;
	if (!asu64(R1)) goto L1307;
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1307;
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1307:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1309;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1310;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1311;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1311;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L1312;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L1312;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1312;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1312;
	R2 = 131;
	if (asi64(R1) == asi64(R2)) goto L1313;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1314;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1315;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1316;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1316;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L1317;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L1318;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1319;
	goto L1320;
L1309:
	goto L1308;
L1310:
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu16(R1) = *tou16p(((i64)R1+(i64)R2*2-2));
	if (!asu16(R1)) goto L1322;
	goto L1320;
	goto L1320;
L1322:
	goto L1308;
L1311:
	R1 = (u64)&nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdef = asu64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pdef;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	asu64(R2) = pdef;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&nallparams;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&nalllocals;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	ncall = asi64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcproc = asu64(R1);
	goto L1320;
	goto L1320;
	goto L1308;
L1312:
	R1 = 0;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&ncall;
	(*toi64p(R1)) -=1;
	goto L1320;
	goto L1320;
	goto L1308;
L1313:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = newpc;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = (u64)&callstack;
	R3 = (u64)&ncall;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1308;
L1314:
	asu64(R1) = pc_decls_pinfo;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1324;
	R1 = (u64)&nleaf;
	(*toi64p(R1)) += 1;
L1324:
	R1 = 0;
	pc_decls_pinfo = asu64(R1);
	goto L1320;
	goto L1320;
	goto L1308;
L1315:
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1320;
	goto L1320;
	goto L1308;
L1316:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1326;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1326;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = newpc;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1328;
	R1 = 3;
	goto L1327;
L1328:
	R1 = 6;
L1327:
	asu64(R2) = newpc;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1325;
L1326:
	goto L1320;
	goto L1320;
L1325:
	goto L1308;
L1317:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) != asi64(R2)) goto L1330;
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L1330;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1329;
L1330:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1332;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1331;
L1332:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1329;
L1331:
	goto L1320;
	goto L1320;
L1329:
	goto L1308;
L1318:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1335;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1335;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1334;
L1335:
	asu64(R1) = newpc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) != asi64(R2)) goto L1334;
	goto L1333;
L1334:
	goto L1320;
	goto L1320;
L1333:
	goto L1308;
L1319:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1337;
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = newpc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1338;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1338;
	R1 = 1;
	goto L1339;
L1338:
	R1 = 0;
L1339:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L1337;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pcnext;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = pcnext;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = newpc;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1336;
L1337:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1340;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1336;
L1340:
	goto L1320;
	goto L1320;
L1336:
	goto L1308;
L1320:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = newpc;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1342;
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1345;
	asu64(R1) = newpc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1344;
L1345:
	R1 = 1;
	asu64(R2) = newpc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1344:
L1342:
L1308:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	if (--asi64(av_1)) goto L1299;
L1301:
	asu64(R1) = newpc;
	pc_api_pccurr = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 stack;
	u64 pc;
	i64 sp;
	i64 fp;
	i64 a;
	u64 ptr;
	i64 b;
	u64 ptrb;
	i64 n;
	u64 d;
	struct $B52 callstack;
	struct $B92 callstackst;
	i64 callsp;
	struct $B16 str;
	i64 mag;
	i64 oldsp;
	i64 ncmd;
	u64 cmd;
	i64 lastpos;
	i64 count;
	i64 av_1;
	i64 av_2;
	asu64(R1) = pcentry;
	pc = asu64(R1);
	R1 = 0;
	sp = asi64(R1);
	R1 = 0;
	fp = asi64(R1);
	R1 = 0;
	callsp = asi64(R1);
	R1 = 560000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	stack = asu64(R1);
	asi64(R1) = cmain;
	if (!asi64(R1)) goto L1348;
	asi64(R1) = msysc_ncmdparams;
	ncmd = asi64(R1);
	asu64(R1) = msysc_cmdparams;
	cmd = asu64(R1);
	asi64(R1) = ncmd;
	asi64(R2) = pc_decls_pcmdskip;
	asi64(R1) -= asi64(R2);
	ncmd = asi64(R1);
	asu64(R1) = cmd;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	cmd = asu64(R1);
	asu64(R1) = cmd;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1348:
	R1 = 0;
	lastpos = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1350;
	R1 = tou64("<Fn ptr>");
	R2 = (u64)&pc_run_emptyst;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1350:
L1351:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L1355;
	case 1: goto L1356;
	case 2: goto L1359;
	case 3: goto L1360;
	case 4: goto L1361;
	case 5: goto L1368;
	case 6: goto L1369;
	case 7: goto L1354;
	case 8: case 9: goto L1370;
	case 10: goto L1371;
	case 11: goto L1372;
	case 12: goto L1373;
	case 13: goto L1375;
	case 14: goto L1376;
	case 15: goto L1377;
	case 16: goto L1378;
	case 17: goto L1381;
	case 18: case 21: goto L1382;
	case 19: goto L1407;
	case 20: goto L1397;
	case 22: goto L1415;
	case 23: goto L1402;
	case 24: goto L1420;
	case 25: goto L1421;
	case 26: goto L1422;
	case 27: goto L1430;
	case 28: goto L1433;
	case 29: goto L1436;
	case 30: goto L1437;
	case 31: goto L1438;
	case 32: goto L1445;
	case 33: goto L1446;
	case 34: goto L1449;
	case 35: goto L1452;
	case 36: goto L1455;
	case 37: case 38: goto L1458;
	case 39: goto L1461;
	case 40: goto L1462;
	case 41: goto L1463;
	case 42: goto L1464;
	case 43: goto L1465;
	case 44: goto L1468;
	case 45: goto L1471;
	case 46: goto L1474;
	case 47: goto L1475;
	case 48: goto L1478;
	case 49: goto L1481;
	case 50: goto L1482;
	case 51: goto L1483;
	case 52: goto L1484;
	case 53: goto L1485;
	case 54: goto L1486;
	case 55: goto L1489;
	case 56: goto L1493;
	case 57: goto L1497;
	case 58: goto L1498;
	case 59: goto L1499;
	case 60: goto L1500;
	case 61: goto L1503;
	case 62: goto L1506;
	case 63: goto L1507;
	case 64: goto L1508;
	case 65: goto L1509;
	case 66: goto L1510;
	case 67: goto L1513;
	case 68: goto L1514;
	case 69: goto L1515;
	case 70: goto L1516;
	case 71: goto L1517;
	case 72: goto L1518;
	case 73: goto L1519;
	case 74: goto L1520;
	case 75: goto L1521;
	case 76: goto L1522;
	case 77: goto L1523;
	case 78: goto L1524;
	case 79: goto L1525;
	case 80: goto L1526;
	case 81: goto L1527;
	case 82: goto L1528;
	case 83: goto L1531;
	case 84: goto L1532;
	case 85: goto L1533;
	case 86: goto L1534;
	case 87: goto L1535;
	case 88: goto L1536;
	case 89: goto L1537;
	case 90: goto L1538;
	case 91: goto L1541;
	case 92: goto L1544;
	case 93: case 94: goto L1547;
	case 95: goto L1550;
	case 96: goto L1551;
	case 97: goto L1552;
	case 98: goto L1553;
	case 99: goto L1554;
	case 100: goto L1555;
	case 101: goto L1558;
	case 102: goto L1562;
	case 103: goto L1566;
	case 104: goto L1567;
	case 105: goto L1568;
	case 106: goto L1569;
	case 107: goto L1570;
	case 108: goto L1571;
	case 109: goto L1572;
	case 110: goto L1573;
	case 111: goto L1574;
	case 112: goto L1577;
	case 113: goto L1578;
	case 114: goto L1579;
	case 115: goto L1580;
	case 116: goto L1581;
	case 117: goto L1582;
	case 118: goto L1583;
	case 119: goto L1584;
	case 120: goto L1585;
	case 121: goto L1591;
	case 122: goto L1592;
	case 123: goto L1593;
	case 124: goto L1594;
	case 125: goto L1595;
	case 126: goto L1606;
	case 127: goto L1596;
	case 128: goto L1597;
	case 129: goto L1598;
	case 130: goto L1599;
	case 131: goto L1600;
	case 132: goto L1601;
	case 133: goto L1602;
	case 134: goto L1603;
	case 135: goto L1604;
	case 136: goto L1605;
	default: goto L1354;
    };
// SWITCH
L1355:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1356:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1358;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1357;
L1358:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1357:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1359:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1360:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1361:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1363;
	goto L1364;
L1363:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1366;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1365;
L1366:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1367;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1367;
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	goto L1365;
L1367:
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	R1 += (i64)R2*8-8;
	ptr = asu64(R1);
L1365:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1362;
L1364:
	asu64(R1) = pc;
	pc_runaux_pcusopnd(asu64(R1));
L1362:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1368:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1369:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1370:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1371:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asi64(R2) -= asi64(R3);
	R1 += (i64)R2*8-8;
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R4) = pc;
	R5 = 20;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) -= asi64(R4);
	R2 += (i64)R3*8-8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1372:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1373:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1375:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1376:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1377:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-24));
	asi64(R1) = pc_runaux_pci_loadbf(asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1378:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-24));
	if (!asi64(R1)) goto L1380;
	R1 = 1;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L1379;
L1380:
	R1 = 0;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L1379:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1381:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-24));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-32));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-16));
	asi64(R4) = a;
	asi64(R1) = pc_runaux_pci_storebf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1382:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1384;
	asi64(R1) = callsp;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1387;
L1385:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L1385;
L1387:
	msysc_m$print_startcon();
	R1 = tou64("# Call:   # # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_run_seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	asi64(R1) = pc_run_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1384:
	asi64(R1) = sp;
	R2 = 69900;
	if (asi64(R1) <= asi64(R2)) goto L1389;
	R1 = tou64("");
	R2 = tou64("Stack overflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1389:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1391;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	R5 = 0;
	asu64(R6) = d;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L1393;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1392;
L1393:
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1392:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1390;
L1391:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1394;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Proc not defined:");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1390;
L1394:
	asi64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 21;
	if (asi64(R2) != asi64(R3)) goto L1396;
	R2 = 1;
	goto L1395;
L1396:
	R2 = 0;
L1395:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	asu64(R1) = d;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L1390:
	goto L1351;
L1397:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1399;
	R1 = tou64("");
	R2 = tou64("retp/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1399:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1401;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETP/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1401:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1351;
L1402:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1404;
	R1 = tou64("");
	R2 = tou64("ref/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1404:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1406;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETF/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1406:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1351;
L1407:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1409;
	R1 = tou64("");
	R2 = tou64("ICALLP NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1409:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1411;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1411;
// pc_run.dispatch_loop.icallp:
L1412:
	asi64(R1) = sp;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 22;
	if (asi64(R2) != asi64(R3)) goto L1414;
	R2 = 1;
	goto L1413;
L1414:
	R2 = 0;
L1413:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&pc_run_emptyst;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = ptr;
	pc = asu64(R1);
	goto L1410;
L1411:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1410:
	goto L1351;
L1415:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1417;
	R1 = tou64("");
	R2 = tou64("ICALLF NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1417:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1419;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1419;
	goto L1412;
	goto L1418;
L1419:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1418:
	goto L1351;
L1420:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1351;
L1421:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1351;
L1422:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1424;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpreal(asi64(R3), asr64(R2), asr64(R1));
	n = asi64(R1);
	goto L1423;
L1424:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1425;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1423;
L1425:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1423:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1427;
	asi64(R1) = n;
	if (asi64(R1)) goto L1427;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1426;
L1427:
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
L1426:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1429;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1428;
L1429:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1428:
	goto L1351;
L1430:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L1432;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1431;
L1432:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1431:
	goto L1351;
L1433:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1435;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1434;
L1435:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1434:
	goto L1351;
L1436:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1351;
L1437:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1438:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1440;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1441;
	goto L1442;
L1440:
	R1 = tou64("");
	R2 = tou64("setcc/r64");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1439;
L1441:
	R1 = tou64("");
	R2 = tou64("setcc/r32");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1439;
L1442:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1444;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1443;
L1444:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1443:
L1439:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1445:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L1346;
	goto L1351;
L1446:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	(*toi64p(R1)) -=1;
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L1448;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1447;
L1448:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1447:
	goto L1351;
L1449:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L1451;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1450;
L1451:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1450:
	goto L1351;
L1452:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L1454;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1453;
L1454:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1453:
	goto L1351;
L1455:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1457;
	R1 = tou64("");
	R2 = tou64("swap/block");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1457:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptrb = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptrb;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	b = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = b;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptrb;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1458:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) < asi64(R2)) goto L1460;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) > asi64(R2)) goto L1460;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2*32;
	asi64(R2) = a;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 -= (i64)R2*32;
	pc = asu64(R1);
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1459;
L1460:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
L1459:
	goto L1351;
L1461:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1462:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1463:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = 0;
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1464:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1465:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1467;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) += asr64(R1);
	goto L1466;
L1467:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) += asi64(R1);
L1466:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1468:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1470;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) -= asr64(R1);
	goto L1469;
L1470:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) -= asi64(R1);
L1469:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1471:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1473;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) *= asr64(R1);
	goto L1472;
L1473:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) *= asi64(R1);
L1472:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1474:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) /= asr64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1475:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1477;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1476;
L1477:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1476:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1478:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1480;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) %= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1479;
L1480:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) %= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1479:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1481:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1482:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1483:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) |= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1484:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) ^= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1485:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) <<= asu64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1486:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1488;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) >>= asi64(R1);
	goto L1487;
L1488:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) >>= asu64(R1);
L1487:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1489:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1491;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Min(*tor64p(R2), asr64(R1));
	goto L1490;
L1491:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1492;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1490;
L1492:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1490:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1493:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1495;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Max(*tor64p(R2), asr64(R1));
	goto L1494;
L1495:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1496;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1494;
L1496:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1494:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1497:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1498:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1499:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1500:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1502;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1501;
L1502:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1501:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1503:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1505;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1504;
L1505:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1504:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1506:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = ~asu64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1507:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) ^= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1508:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !!asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1509:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1510:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1512;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	*tor64p(R2) *= asr64(R1);
	goto L1511;
L1512:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) *= asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1511:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1513:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = sqrt(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1514:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1515:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1516:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1517:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1518:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1519:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1520:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1521:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1522:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1523:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1524:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1525:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1526:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1527:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1528:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1530;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) = pow(asr64(R1), asr64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	goto L1529;
L1530:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
L1529:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1531:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1532:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1533:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1534:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1535:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1536:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1537:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1538:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1540;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) += asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1539;
L1540:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) += asi64(R1);
L1539:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1541:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1543;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) -= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1542;
L1543:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) -= asi64(R1);
L1542:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1544:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1546;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) *= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1545;
L1546:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) *= asi64(R1);
L1545:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1547:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1549;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) /= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1548;
L1549:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	a = asi64(R1);
L1548:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1550:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) %= asi64(R2);
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1551:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1552:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) |= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1553:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) ^= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1554:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1555:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1557;
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) >>= asi64(R1);
	goto L1556;
L1557:
	asu64(R1) = b;
	R2 = (u64)&a;
	*tou64p(R2) >>= asu64(R1);
L1556:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1558:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1560;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Min(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1559;
L1560:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1561;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1559;
L1561:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1559:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1562:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1564;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Max(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1563;
L1564:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1565;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1563;
L1565:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1563:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1566:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1567:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) -= asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1568:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1569:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1570:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1571:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1572:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1573:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1574:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1576;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1575;
L1576:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asu64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
L1575:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1577:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	R1 = toi64(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1578:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1579:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1580:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1581:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1582:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1583:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1584:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1585:
	asi64(R1) = fp;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = sp;
	fp = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1587;
	asi64(R1) = callsp;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1590;
L1588:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_2)) goto L1588;
L1590:
	msysc_m$print_startcon();
	R1 = tou64("# Enter:  # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = pc_run_seqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = fp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1587:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1591:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1592:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1593:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1594:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1595:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1596:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1597:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1598:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = ptr;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = sp;
	asu64(R2) = ptr;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = fp;
	asu64(R2) = ptr;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1599:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	pc = asu64(R1);
	asu64(R1) = ptr;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	sp = asi64(R1);
	asu64(R1) = ptr;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	fp = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1351;
L1600:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1601:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1602:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1603:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1604:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1605:
	goto L1374;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1351;
L1606:
	goto L1351;
L1354:
// pc_run.dispatch_loop.unimpl:
L1374:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("GETOPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Unimpl: # at seq: #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	goto L1351;
	R1 = 0;
	goto L1346;
L1346:
	return asi64(R1);
}

static void pc_run_fixuppcl() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 d;
	u64 e;
	u64 dproc;
	u64 pdata;
	i64 parambytes;
	i64 framebytes;
	i64 paramslots;
	i64 localslots;
	u64 a;
	asi64(R1) = pc_api_mlabelno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_run_labeltable = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1611;
L1608:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1613;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1613;
	goto L1614;
L1613:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1612;
L1614:
L1612:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1611:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1608;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1618;
L1615:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1620;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1620;
	goto L1621;
L1620:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1619;
L1621:
L1619:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1618:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1615;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1625;
L1622:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1627;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1627;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1628;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1629;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1630;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1631;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1631;
	goto L1632;
L1627:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdata = asu64(R1);
	goto L1626;
L1628:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1634;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1636;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1637;
	goto L1638;
L1636:
	R1 = tou64("");
	R2 = tou64("FIX/DATA/MEM");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1635;
L1637:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1640;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1641;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1642;
	goto L1643;
L1640:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1639;
L1641:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1639;
L1642:
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asu64(R1);
	goto L1639;
L1643:
	R1 = tou64("");
	R2 = tou64("data &mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1639:
	asu64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1645;
	R1 = tou64("");
	R2 = tou64("data &mem = nil");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1645:
	goto L1635;
L1638:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L1635:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = (u64)&a;
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1633;
L1634:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1633:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pdata;
	*tou64p(R2) += asu64(R1);
	goto L1626;
L1629:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	dproc = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	parambytes = asi64(R1);
	goto L1649;
L1646:
	R1 = 8;
	R2 = (u64)&parambytes;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1649:
	asu64(R1) = e;
	if (asu64(R1)) goto L1646;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	framebytes = asi64(R1);
	goto L1653;
L1650:
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 8;
	asu64(R2) = e;
	R3 = 84;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&framebytes;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1653:
	asu64(R1) = e;
	if (asu64(R1)) goto L1650;
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	paramslots = asi64(R2);
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	localslots = asi64(R2);
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1626;
L1630:
	asu64(R1) = p;
	asu64(R2) = pc_run_labeltable;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1626;
L1631:
	asi64(R1) = paramslots;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = localslots;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1626;
L1632:
L1626:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1625:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1622;
	return;
}

static void pc_run_pcl_runpcl() {
    u64 R1, R2, R3; 
	i64 stopcode;
	pc_runaux_loadlibs();
	pc_run_fixuppcl();
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1656;
	R1 = tou64("");
	R2 = tou64("No 'main' entry point");
	asu64(R3) = pc_api_pcstart;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1656:
	pc_runaux_docmdskip();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1658;
	msysc_m$print_startcon();
	R1 = tou64("Run PCL:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1658:
	asu64(R1) = pc_decls_entryproc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = pc_decls_entryproc;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_run_dispatch_loop(asu64(R2), asi64(R1));
	stopcode = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1660;
	msysc_m$print_startcon();
	R1 = tou64("Stopped");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = stopcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L1660:
	asi64(R1) = stopcode;
	exit(R1);
	return;
}

static i64 pc_run_getlineno(u64 pc) {
    u64 R1, R2, R3, R4; 
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1663;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asu64(R3) = pc;
	R4 = 24;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F17)R4)(asi64(R3), asu64(R2), asu64(R1));
	goto L1662;
L1663:
	R1 = 0;
L1662:
	goto L1661;
L1661:
	return asi64(R1);
}

static i64 pc_runaux_pci_getopnd(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	i64 a;
	u64 d;
	u64 ptr;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1666;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1667;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1668;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1669;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1670;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1670;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1671;
	goto L1672;
L1666:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1665;
L1667:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1674;
	goto L1675;
L1674:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1673;
L1675:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	ptr = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1677;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1677;
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	ptr = asu64(R1);
L1677:
L1673:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	goto L1665;
L1668:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1679;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1680;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1681;
	goto L1682;
L1679:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	goto L1678;
L1680:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1684;
	asi64(R1) = a;
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	a = asi64(R1);
L1684:
	goto L1678;
L1681:
	asu64(R1) = d;
	asi64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asi64(R1);
	goto L1678;
L1682:
	asu64(R1) = d;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
L1678:
	goto L1665;
L1669:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1665;
L1670:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1665;
L1671:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	goto L1665;
L1672:
	asu64(R1) = p;
	pc_runaux_pcusopnd(asu64(R1));
L1665:
	asi64(R1) = a;
	goto L1664;
L1664:
	return asi64(R1);
}

static i64 pc_runaux_pci_loadptr(u64 p, i64 mode) {
    u64 R1, R2; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1687;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1687:
	asi64(R1) = mode;
	switch (asi64(R1)) {
	case 1: goto L1693;
	case 2: goto L1692;
	case 3: goto L1701;
	case 4: goto L1700;
	case 5: goto L1699;
	case 6: goto L1698;
	case 7: goto L1697;
	case 8: goto L1696;
	case 9: goto L1695;
	case 10: goto L1694;
	case 11: goto L1691;
	default: goto L1690;
    };
// SWITCH
L1691:
	asu64(R1) = p;
	goto L1688;
L1692:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1688;
L1693:
	asu64(R1) = p;
	asr32(R1) = *tor32p(R1);
    asr64(R1) = tor64(asr32(R1));
	x = asr64(R1);
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L1688;
L1694:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1688;
L1695:
	asu64(R1) = p;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	goto L1688;
L1696:
	asu64(R1) = p;
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	goto L1688;
L1697:
	asu64(R1) = p;
	asi8(R1) = *toi8p(R1);
	R1 = toi64(toi8(R1));
	goto L1688;
L1698:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1688;
L1699:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	goto L1688;
L1700:
	asu64(R1) = p;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	goto L1688;
L1701:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L1688;
L1690:
	R1 = 0;
L1688:
	goto L1685;
L1685:
	return asi64(R1);
}

static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size) {
    u64 R1, R2, R3; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1704;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1704:
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1706;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1707;
	goto L1708;
L1706:
	asi64(R1) = size;
	asi64(R2) = a;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1705;
L1707:
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	x = asr64(R1);
	asr64(R1) = x;
    asr32(R1) = tor32(asr64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L1705;
L1708:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1710;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1711;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1712;
	goto L1713;
L1710:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L1709;
L1711:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L1709;
L1712:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	goto L1709;
L1713:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi8p(R2) = asi8(R1);
L1709:
L1705:
	return;
}

static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1716;
	R1 = tou64("");
	R2 = tou64("Not mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1716:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1718;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1717;
L1718:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
L1717:
	goto L1714;
L1714:
	return asu64(R1);
}

static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("PC Exec error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("seq:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	if (!asu64(R2)) goto L1721;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	goto L1720;
L1721:
	R2 = 0;
L1720:
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_runaux_pcusopnd(u64 p) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("Unsupported operand:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode) {
    u64 R1, R2, R3, R4, R5; 
	struct $B93 args;
	i64 retval;
	i64 i;
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1725;
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	fnaddr = asu64(R1);
L1725:
	asi64(R1) = nargs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1728;
L1726:
	asu64(R1) = revargs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = i;
	asi64(R3) -= asi64(R4);
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	i += -1; if (i >= 1) goto L1726;
L1728:
	R1 = 0;
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = retmode;
	R5 = 1;
	if (asi64(R4) == asi64(R5)) goto L1731;
	R5 = 2;
	if (asi64(R4) != asi64(R5)) goto L1730;
L1731:
	R4 = 82;
	goto L1729;
L1730:
	R4 = 73;
L1729:
	asu64(R5) = fnaddr;
	asi64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	retval = asi64(R1);
	asi64(R1) = retval;
	goto L1723;
L1723:
	return asi64(R1);
}

static u64 pc_runaux_getdllfnptr(u64 d) {
    u64 R1, R2, R3; 
	u64 fnaddr;
	i64 libindex;
	u64 dllinst;
	u64 procname;
	u64 libname;
	i64 i;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1734;
	asu64(R1) = fnaddr;
	goto L1732;
L1734:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	procname = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1738;
L1735:
	asu64(R1) = procname;
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mwindows_os_getdllprocaddr(asi64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1740;
	goto L1737;
L1740:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1735;
L1738:
	asu64(R1) = procname;
	R2 = tou64("Can't find DLL func:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1737:
	asu64(R1) = fnaddr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fnaddr;
	goto L1732;
L1732:
	return asu64(R1);
}

static void pc_runaux_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1744;
L1742:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mwindows_os_getdllinst(asu64(R1));
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc_decls_plibinst;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L1746;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't load lib:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1746:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1742;
L1744:
	return;
}

static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1749;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1750;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1751;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1752;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1753;
	goto L1754;
L1749:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  ==  asr64(R2);
	goto L1748;
L1750:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  !=  asr64(R2);
	goto L1748;
L1751:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <  asr64(R2);
	goto L1748;
L1752:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <=  asr64(R2);
	goto L1748;
L1753:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >=  asr64(R2);
	goto L1748;
L1754:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >  asr64(R2);
L1748:
	goto L1747;
L1747:
	return asi64(R1);
}

static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1757;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1758;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1759;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1760;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1761;
	goto L1762;
L1757:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1756;
L1758:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L1756;
L1759:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	goto L1756;
L1760:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L1756;
L1761:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	goto L1756;
L1762:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
L1756:
	goto L1755;
L1755:
	return asi64(R1);
}

static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1765;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1766;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1767;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1768;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1769;
	goto L1770;
L1765:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  ==  asu64(R2);
	goto L1764;
L1766:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	goto L1764;
L1767:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	goto L1764;
L1768:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	goto L1764;
L1769:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	goto L1764;
L1770:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >  asu64(R2);
L1764:
	goto L1763;
L1763:
	return asi64(R1);
}

static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1773;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1774;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1775;
	goto L1776;
L1773:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou64p(R2) += asu64(R1);
	goto L1772;
L1774:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou32p(R2) += asu32(R1);
	goto L1772;
L1775:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou16p(R2) += asu16(R1);
	goto L1772;
L1776:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou8p(R2) += asu8(R1);
L1772:
	return;
}

static void pc_runaux_docmdskip() {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1781;
L1778:
	R1 = tou64("$cmdskip");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1783;
	asi64(R1) = pc_decls_pcmdskip;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) = asu8(R1);
	goto L1780;
L1783:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1781:
	asu64(R1) = d;
	if (asu64(R1)) goto L1778;
L1780:
	return;
}

static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j) {
    u64 R1, R2; 
	u64 mask;
	i64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1786;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1786:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	R1 = -1;
	asi64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	asu64(R2) = i;
	asu64(R1) >>= asu64(R2);
	goto L1784;
L1784:
	return asu64(R1);
}

static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x) {
    u64 R1, R2; 
	u64 mask;
	u64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1789;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1789:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asu64(R1) += asu64(R2);
	n = asu64(R1);
	R1 = -1;
	asu64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = x;
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	x = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R2) = ~asu64(R2);
	asu64(R1) &= asu64(R2);
	asu64(R2) = x;
	asu64(R1) |= asu64(R2);
	goto L1787;
L1787:
	return asu64(R1);
}

static void mc_genmcl_genmcl(u64 dummy) {
    u64 R1, R2, R3; 
	i64 tt;
	i64 i;
	asu8(R1) = pc_decls_mcldone;
	if (!asu8(R1)) goto L1792;
	goto L1790;
L1792:
	R1 = 0;
	if (asu16(R1)) goto L1795;
	R1 = 0;
	if (!asu16(R1)) goto L1794;
L1795:
	msysc_m$print_startcon();
	R1 = tou64("********* ASM HAS PCL INFO *********");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1794:
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	mc_genmcl_inithandlers();
	R1 = 0;
	mc_libmcl_mclinit(asi64(R1));
	asu64(R1) = pc_api_pcstart;
	mc_decls_currpcl = asu64(R1);
	R1 = 0;
	i = asi64(R1);
L1796:
	asu64(R1) = mc_decls_currpcl;
	mc_genmcl_convertpcl(asu64(R1));
	R1 = 0;
	if (!asu16(R1)) goto L1800;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1800;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1800;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1800;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1800;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1800;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1800;
	mc_stackmcl_showopndstack();
L1800:
	R1 = (u64)&mc_decls_currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = mc_decls_currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1801;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) != asi64(R2)) goto L1796;
L1801:
	mc_auxmcl_genrealtable();
	mc_auxmcl_genabsneg();
	mc_auxmcl_genstringtable();
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L1803;
	mc_optim_peephole();
L1803:
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
L1790:
	return;
}

static void mc_genmcl_convertpcl(u64 p) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 oldregset;
	i64 reg;
	i64 i;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	mc_decls_pmode = asu8(R1);
	asu64(R1) = p;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pc_decls_ppseqno = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	((F18)R2)(asu64(R1));
	(R1_B3) = mc_decls_regset;
	oldregset = (R1_B3);
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1807;
L1805:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L1809;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1811;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1810;
L1811:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1810:
L1809:
	i += 1; if (i <= mc_decls_noperands) goto L1805;
L1807:
	R1 = (u64)&oldregset;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 48;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	R1 = (u64)&oldregset;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 56;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	return;
}

static void mc_genmcl_inithandlers() {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	i64 n;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	i64 k;
// PROC LOCAL STATICS GO HERE
	static u8 mc_genmcl_inithandlers_initdone = 0;
	static struct $B3 mc_genmcl_inithandlers_dupltable = {{
1303249015287398465,
	3485556719402710647    }};
	asu8(R1) = mc_genmcl_inithandlers_initdone;
	if (!asu8(R1)) goto L1814;
	goto L1812;
L1814:
	asi64(R1) = $nprocs;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1817;
L1815:
	R1 = (u64)&$procname;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 3;
	R2 = tou64("px_");
	asu64(R3) = name;
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L1819;
	R1 = 0;
	k = asi64(R1);
	R1 = 142;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1823;
L1820:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	s = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) != asu64(R2)) goto L1825;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L1825:
	asu64(R1) = name;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1827;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L1822;
L1827:
	k += 1; if (k <= av_1) goto L1820;
L1823:
	asu64(R1) = name;
	R2 = tou64("Invalid handler name:");
	pc_api_merror(asu64(R2), asu64(R1));
L1822:
L1819:
	i += 1; if (i <= n) goto L1815;
L1817:
	R1 = 1;
	i = asi64(R1);
	R1 = 8;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1830;
L1828:
	R1 = (u64)&mc_genmcl_px_handlertable;
	R2 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R3) = i;
	R2 += (i64)R3*2-2;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	R3 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R4) = i;
	R3 += (i64)R4*2-2;
	R4 = 1;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L1828;
L1830:
	R1 = 0;
	i = asi64(R1);
	R1 = 142;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1833;
L1831:
	R1 = (u64)&mc_genmcl_px_handlertable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (asu64(R1)) goto L1835;
	R1 = (u64)&mc_genmcl_unimpl;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L1835:
	i += 1; if (i <= av_3) goto L1831;
L1833:
	R1 = 1;
	mc_genmcl_inithandlers_initdone = asu8(R1);
L1812:
	return;
}

static void mc_genmcl_doshowpcl(u64 p) {
    u64 R1, R2; 
	struct $B94 str;
	goto L1836;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1838;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1838;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1838;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1838;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1838;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1838;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1838;
	goto L1839;
L1838:
	goto L1837;
L1839:
	R1 = tou64("                       ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1256;
	asu64(R2) = p;
	asu64(R1) = pc_diags_strpclstr(asu64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
L1837:
L1836:
	return;
}

static void mc_genmcl_unimpl(u64 p) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Unimpl: # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_nop(u64 p) {
	return;
}

static void mc_genmcl_px_dupl(u64 p) {
	mc_stackmcl_duplpcl();
	return;
}

static void mc_genmcl_px_double(u64 p) {
    u64 R1, R2; 
	asi64(R1) = mc_decls_ncalldepth;
	if (!asi64(R1)) goto L1845;
	mc_stackmcl_duplpcl();
	goto L1844;
L1845:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L1844:
	return;
}

static void mc_genmcl_px_opnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_type(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_comment(u64 p) {
	return;
}

static void mc_genmcl_px_proc(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_currfunc = asu64(R1);
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 1;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	mc_auxmcl_initproc(asu64(R1));
	R1 = tou64("?>>");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mclprocentry = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1851;
	asu64(R1) = pc_decls_currfunc;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1851;
	mc_auxmcl_fixmain();
L1851:
	return;
}

static void mc_genmcl_px_endproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1854;
	msysc_m$print_startcon();
	R1 = tou64("PCL STACK NOT EMPTY");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PCL STACK NOT EMPTY");
	mc_libmcl_mgencomment(asu64(R1));
L1854:
	R1 = 0;
	R2 = 0;
	R3 = 2;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endprog(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_istatic(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_zstatic(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_data(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 opc;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1860;
	asu64(R1) = p;
	mc_auxmcl_do_blockdata(asu64(R1));
	goto L1858;
L1860:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1862;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1863;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1864;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1865;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1866;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1867;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1868;
	goto L1869;
L1862:
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1861;
L1863:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1861;
L1864:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1861;
L1865:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1861;
L1866:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1861;
L1867:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1861;
L1868:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1861;
L1869:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("db/dq optype? #");
	pc_api_merror(asu64(R2), asu64(R1));
L1861:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1871;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1872;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1873;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1874;
	goto L1875;
L1871:
	R1 = 116;
	opc = asi64(R1);
	goto L1870;
L1872:
	R1 = 117;
	opc = asi64(R1);
	goto L1870;
L1873:
	R1 = 118;
	opc = asi64(R1);
	goto L1870;
L1874:
	R1 = 119;
	opc = asi64(R1);
	goto L1870;
L1875:
	msysc_m$print_startcon();
	R1 = tou64("P.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STRPMODE(P.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("DATA/not 1248");
	pc_api_merror(asu64(R2), asu64(R1));
L1870:
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1858:
	return;
}

static void mc_genmcl_px_label(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_load(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_stackmcl_pushpcl(asu64(R1));
	return;
}

static void mc_genmcl_px_store(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1880;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1879;
L1880:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L1879:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_add(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1883;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1885;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1885;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 52;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1884;
L1885:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1884:
	goto L1882;
L1883:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 65;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1882:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_sub(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1888;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1890;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1890;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1889;
L1890:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1889:
	goto L1887;
L1888:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 67;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1887:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_mul(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	i64 x;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1893;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1895;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1894;
L1895:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1894:
	goto L1892;
L1893:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 69;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1892:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_div(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 71;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_eval(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_widen(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1900;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1900;
	R1 = 0;
	R2 = 5;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1902;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1902:
	goto L1899;
L1900:
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = (u64)&pc_tables_psigned;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	if (!asu8(R3)) goto L1904;
	R3 = 18;
	goto L1903;
L1904:
	R3 = 19;
L1903:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1899:
	return;
}

static void mc_genmcl_px_jump(u64 p) {
    u64 R1, R2, R3; 
	i64 labno;
	u64 q;
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	goto L1907;
L1906:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
L1907:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1906;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1910;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1911;
	goto L1912;
L1910:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1914;
	goto L1905;
L1914:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) != asi64(R2)) goto L1916;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1916;
	goto L1905;
L1916:
	goto L1909;
L1911:
	R1 = 0;
	asu64(R2) = q;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1909;
L1912:
L1909:
	R1 = 0;
	asi64(R2) = labno;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1905:
	return;
}

static void mc_genmcl_px_ijump(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_neg(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1920;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1919;
L1920:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
L1919:
	return;
}

static void mc_genmcl_px_abs(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 lx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1923;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1922;
L1923:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L1922:
	return;
}

static void mc_genmcl_px_bitnot(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_not(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 cx;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1928;
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = cx;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1930;
	R3 = 5;
	goto L1929;
L1930:
	R3 = 4;
L1929:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1927;
L1928:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1932;
	R3 = 5;
	goto L1931;
L1932:
	R3 = 4;
L1931:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-3)) = asu8(R1);
L1927:
	return;
}

static void mc_genmcl_px_sqr(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1935;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1934;
L1935:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 69;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1934:
	return;
}

static void mc_genmcl_px_sqrt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 63;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_jumpcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 mcond;
	u64 ax;
	u64 bx;
	u64 lx;
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	lx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1939;
	R1 = tou64("");
	R2 = tou64("JUMPCC/BLOCK");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1938;
L1939:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1941;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1943;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1943;
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1944;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1943;
L1944:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1942;
L1943:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1946;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
L1946:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1942:
	goto L1940;
L1941:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1940:
	R1 = 0;
	asu64(R2) = lx;
	asi64(R3) = mcond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1948;
	mc_stackmcl_poppcl();
L1948:
L1938:
	return;
}

static void mc_genmcl_px_jumpt(u64 p) {
    u64 R1, R2; 
	R1 = 5;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_jumpf(u64 p) {
    u64 R1, R2; 
	R1 = 4;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitand(u64 p) {
    u64 R1, R2; 
	R1 = 38;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitor(u64 p) {
    u64 R1, R2; 
	R1 = 39;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxor(u64 p) {
    u64 R1, R2; 
	R1 = 40;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shl(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shr(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1957;
	R1 = 44;
	goto L1956;
L1957:
	R1 = 45;
L1956:
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_retproc(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mclprocentry;
	asu64(R2) = mc_decls_mccodex;
	if (asu64(R1) != asu64(R2)) goto L1960;
	R1 = tou64("---");
	mc_libmcl_mgencomment(asu64(R1));
L1960:
	asu64(R1) = p;
	mc_auxmcl_do_procentry(asu64(R1));
	mc_auxmcl_do_procexit();
	return;
}

static void mc_genmcl_px_retfn(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1963;
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 6;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1963:
	asu64(R1) = p;
	mc_genmcl_px_retproc(asu64(R1));
	return;
}

static void mc_genmcl_px_setcall(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	asi64(R1) = mc_decls_ncalldepth;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1966;
	R1 = tou64("");
	R2 = tou64("Too many nested calls");
	pc_api_merror(asu64(R2), asu64(R1));
L1966:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1968;
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1967;
L1968:
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asi64(R2) = mc_decls_mstackdepth;
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1967:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callblocksize;
	asi64(R3) = mc_decls_ncalldepth;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1970;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
L1970:
	return;
}

static void mc_genmcl_px_setarg(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L1973;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1975;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 0;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
L1975:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	mc_stackmcl_pushopnd(asi64(R2), asi64(R1));
	goto L1972;
L1973:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1976;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*16-16;
	asi64(R3) = n;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
L1976:
L1972:
	return;
}

static void mc_genmcl_px_callp(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 nargs;
	i64 nregargs;
	i64 slots;
	i64 isptr;
	i64 shadow;
	i64 blockret;
	i64 av_1;
	R1 = 0;
	isptr = asi64(R1);
	R1 = 0;
	shadow = asi64(R1);
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	nargs = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nregargs = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1980;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L1979;
L1980:
	R1 = 1;
	isptr = asi64(R1);
L1979:
	asi64(R1) = isptr;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = nregargs;
	mc_auxmcl_do_pushlowargs(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1982;
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L1984;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	goto L1983;
L1984:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L1983:
	goto L1981;
L1982:
	asi64(R1) = nargs;
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	slots = asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
L1981:
	asi64(R1) = isptr;
	if (!asi64(R1)) goto L1986;
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L1985;
L1986:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1985:
	asi64(R1) = nregargs;
	asi64(R2) = blockret;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1989;
L1987:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L1987;
L1989:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L1991;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L1991:
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1993;
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
L1993:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mc_genmcl_px_jumpret(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1996;
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1998;
	R1 = 1;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
L1998:
L1996:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_jumpretm(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	i64 reg;
	i64 av_1;
	i64 av_2;
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2002;
L2000:
	R1 = 0;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L2000;
L2002:
	R1 = 1;
	reg = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2005;
L2003:
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2007;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2007;
	R1 = 11;
	reg = asi64(R1);
L2007:
	asi64(R1) = reg;
	mc_stackmcl_movetoreg(asi64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	if (--asi64(av_2)) goto L2003;
L2005:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_startmx(u64 p) {
    u64 R1; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	return;
}

static void mc_genmcl_px_resetmx(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L2011;
	mc_stackmcl_poppcl();
L2011:
	return;
}

static void mc_genmcl_px_stop(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 11;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = tou64("exit*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_incrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_incrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadincr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loaddecr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_forup(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 14;
	R2 = 28;
	R3 = 52;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fordown(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 13;
	R2 = 29;
	R3 = 53;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_iload(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 px;
	u64 nextpcl;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2023;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2025;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L2024;
L2025:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L2024:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L2027;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L2026;
L2027:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L2026:
	goto L2022;
L2023:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
L2022:
	return;
}

static i64 mc_genmcl_getsharereg(u64 ax, i64 mode) {
    u64 R1, R2; 
	u8 reg;
	u8 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	reg = asu8(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	regix = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2030;
	R1 = 0;
	goto L2028;
L2030:
	asu8(R1) = reg;
	if (!asu8(R1)) goto L2032;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = reg;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2033;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2032;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2032;
L2033:
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	goto L2028;
	goto L2031;
L2032:
	asu8(R1) = regix;
	if (!asu8(R1)) goto L2034;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = regix;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2035;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2034;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2034;
L2035:
	asu8(R1) = regix;
	R1 = toi64(tou8(R1));
	goto L2028;
L2034:
L2031:
	R1 = 0;
	goto L2028;
L2028:
	return asi64(R1);
}

static void mc_genmcl_px_iloadx(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 z;
	u64 nextpcl;
	u64 ax;
	u64 bx;
	u64 px;
	u64 fx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2038;
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L2037;
L2038:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L2040;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L2039;
L2040:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L2039:
L2037:
	return;
}

static void mc_genmcl_px_istore(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 bx;
	u64 px;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2043;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L2042;
L2043:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L2042:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2045;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L2044;
L2045:
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2044:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_istorex(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 px;
	u64 z;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2048;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	cx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = cx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L2047;
L2048:
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2047:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_storem(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 z;
	u64 dblock;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2051;
	R1 = tou64("");
	R2 = tou64("Storem not 16");
	pc_api_merror(asu64(R2), asu64(R1));
L2051:
	R1 = 16;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	R2 = 0;
	R3 = 8;
	asu64(R4) = px;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = px;
	R2 = 6;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_addpx(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 cx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	cx = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subpx(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 scale;
	i64 extra;
	i64 offset;
	u64 ax;
	u64 bx;
	u64 z;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2055;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R3) = extra;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2054;
L2055:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = scale;
	asu64(R2) = bx;
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2057;
	asi64(R1) = scale;
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
L2057:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = extra;
	if (!asi64(R1)) goto L2059;
	msysc_m$print_startcon();
	R1 = tou64("EXTRA=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = extra;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUBREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L2059:
L2054:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_to(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 ax;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	q = asu64(R1);
	R1 = 6;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_iswap(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 qx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	qx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2063;
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qx;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = qx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2062;
L2063:
	R1 = tou64("");
	R2 = tou64("swap/block");
	pc_api_merror(asu64(R2), asu64(R1));
L2062:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swapstk(u64 p) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_noperands;
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_labeldef(u64 p) {
    u64 R1, R2; 
	struct $B5 str;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(":");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_addto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 65;
	R2 = 28;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 67;
	R2 = 29;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_multo(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 cx;
	u64 x;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2070;
	R1 = 69;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2068;
L2070:
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2072;
	R1 = tou64("");
	R2 = tou64("multo/byte");
	pc_api_merror(asu64(R2), asu64(R1));
L2072:
	R1 = 0;
	R2 = 10;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	x = asu64(R2);
	if (!asu64(R1)) goto L2074;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = cx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L2073;
L2074:
	asu64(R1) = bx;
	asu64(R2) = cx;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2073:
	asu64(R1) = cx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2068:
	return;
}

static void mc_genmcl_px_bitandto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 38;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 39;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 40;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shlto(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shrto(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2081;
	R1 = 44;
	goto L2080;
L2081:
	R1 = 45;
L2080:
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fix(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 fx;
	u64 ax;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&pc_tables_pmin;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = fx;
	asu64(R2) = ax;
	R3 = 84;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_float(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 fx;
	i64 lab;
	i64 lab2;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2085;
	R1 = tou64("");
	R2 = tou64("float/short");
	pc_api_merror(asu64(R2), asu64(R1));
L2085:
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2087;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 86;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2086;
L2087:
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L2088;
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab2 = asi64(R1);
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 12;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab2;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	asi64(R1) = mc_decls_labmask63;
	if (asi64(R1)) goto L2090;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_labmask63 = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_laboffset64 = asi64(R1);
L2090:
	asi64(R1) = mc_decls_labmask63;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_laboffset64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = fx;
	R3 = 66;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab2;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
// mc_genmcl.px_float.reduce:
L2091:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2093;
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2093:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2086;
L2088:
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2091;
L2086:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_idiv(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_irem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_idivrem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 2;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_clear(u64 p) {
    u64 R1, R2; 
	u64 ax;
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = ax;
	mc_auxmcl_clearblock(asu64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 n;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2100;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L2102;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2101;
L2102:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUB/REF NOT POWER OF xx");
	pc_api_merror(asu64(R2), asu64(R1));
L2101:
L2100:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_switch(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 elselab;
	i64 reg;
	u64 ax;
	u64 bx;
	u64 ax2;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = mc_decls_currpcl;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	elselab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L2105;
	asu64(R1) = ax;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	ax2 = asu64(R3);
	R3 = 18;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax2;
	ax = asu64(R1);
L2105:
	asi64(R1) = minlab;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2107;
	R1 = 10;
	asi64(R2) = minlab;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2107:
	R1 = 10;
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = elselab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 3;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2109;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	R1 = 6;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2108;
L2109:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2108:
	mc_stackmcl_poppcl();
	R1 = 1;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_switchu(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 reg;
	u64 ax;
	u64 bx;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2112;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2111;
L2112:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2111:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swlabel(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endsw(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fwiden(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 8;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 89;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_fnarrow(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_truncate(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = pmode2;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2119;
	asu64(R1) = ax;
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = (u64)&mc_decls_ploadop;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2119:
	return;
}

static void mc_genmcl_px_typepun(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_unload(u64 p) {
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_loadbit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 z;
	i64 i;
	i64 m;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2124;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2126;
	R2 = 31;
	if (asi64(R1) > asi64(R2)) goto L2126;
	R1 = 5;
	goto L2125;
L2126:
	R1 = 6;
L2125:
	m = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = i;
	if (!asi64(R1)) goto L2128;
	asi64(R1) = m;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2130;
	goto L2131;
L2130:
L2128:
	goto L2123;
L2124:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2133;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2133:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2135;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2135:
L2123:
	R1 = 5;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
// mc_genmcl.px_loadbit.skip:
L2131:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_assem(u64 p) {
    u64 R1, R2; 
	asu64(R1) = pc_api_idomcl_assem;
	if (!asu64(R1)) goto L2138;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_idomcl_assem;
	((F18)R2)(asu64(R1));
	goto L2137;
L2138:
	R1 = tou64("");
	R2 = tou64("No Assem handler");
	pc_api_merror(asu64(R2), asu64(R1));
L2137:
	return;
}

static void mc_genmcl_px_sin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("sin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_cos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("cos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_tan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("tan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_asin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("asin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_acos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("acos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("atan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log10(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log10*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_exp(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("exp*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_round(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("round*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_floor(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("floor*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_ceil(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("ceil*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan2(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("atan2*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fmod(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("fmod*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_setcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 cond;
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2155;
	R1 = tou64("");
	R2 = tou64("setcc/block");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2154;
L2155:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2156;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2158;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
L2158:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	cx = asu64(R1);
	goto L2154;
L2156:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	R1 = 10;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
L2154:
	R1 = 0;
	asu64(R2) = cx;
	asi64(R3) = cond;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_min(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2161;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2163;
	R1 = 15;
	goto L2162;
L2163:
	R1 = 7;
L2162:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L2160;
L2161:
	R1 = 112;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L2160:
	return;
}

static void mc_genmcl_px_max(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2166;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2168;
	R1 = 12;
	goto L2167;
L2168:
	R1 = 2;
L2167:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L2165;
L2166:
	R1 = 113;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L2165:
	return;
}

static void mc_genmcl_px_power(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 d;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2171;
	R1 = 82;
	asu64(R1) = mc_auxmcl_gethostfn(asi64(R1));
	d = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	asu64(R2) = d;
	asu64(R3) = p;
	mc_auxmcl_do_host(asu64(R3), asu64(R2), asi64(R1));
	goto L2170;
L2171:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("pow*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
L2170:
	return;
}

static void mc_genmcl_px_minto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2174;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2176;
	R2 = 14;
	goto L2175;
L2176:
	R2 = 6;
L2175:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L2173;
L2174:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L2173:
	return;
}

static void mc_genmcl_px_maxto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2179;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2181;
	R2 = 13;
	goto L2180;
L2181:
	R2 = 3;
L2180:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L2178;
L2179:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L2178:
	return;
}

static void mc_genmcl_px_negto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2184;
	R1 = 0;
	asu64(R2) = px;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2183;
L2184:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	fx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = fx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = fx;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
	asu64(R1) = fx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2183:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_absto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 lx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2187;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2186;
L2187:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L2186:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_addpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2190;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2189;
L2190:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2189:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2193;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2192;
L2193:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L2195;
	R1 = tou64("");
	R2 = tou64("SUBTOREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L2195:
L2192:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_divto(u64 p) {
    u64 R1, R2; 
	R1 = 71;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitnotto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu64(R2) = px;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_notto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = px;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	R3 = 5;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_sign(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 lx1;
	u64 lx2;
	u64 lx3;
	u8 gtop;
	u8 ltop;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2202;
	R1 = 7;
	gtop = asu8(R1);
	R1 = 2;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asr64(R2) = 0.000000000000000000e+000;
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2201;
L2202:
	R1 = 15;
	gtop = asu8(R1);
	R1 = 12;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2201:
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx1 = asu64(R3);
	asu8(R3) = gtop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx2 = asu64(R3);
	asu8(R3) = ltop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx3 = asu64(R3);
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx1;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = bx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx2;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = bx;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadbf(u64 p) {
    u64 R1, R2, R3; 
	u64 y;
	u64 z;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	y = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	z = asu64(R1);
	asu64(R1) = y;
	if (!asu64(R1)) goto L2205;
	asu64(R1) = z;
	if (!asu64(R1)) goto L2205;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	mc_auxmcl_do_loadbf_const(asu64(R3), asi64(R2), asi64(R1));
	goto L2204;
L2205:
	asu64(R1) = p;
	mc_auxmcl_do_loadbf_var(asu64(R1));
L2204:
	return;
}

static void mc_genmcl_px_storebit(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebit(asu64(R1));
	return;
}

static void mc_genmcl_px_storebf(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebf(asu64(R1));
	return;
}

static void mc_genmcl_px_loadall(u64 p) {
	mc_stackmcl_checkallloaded();
	return;
}

static void mc_genmcl_px_setjmp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 lab;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = lab;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	R2 = 0;
	R3 = 8;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dframeopnd;
	R2 = 0;
	R3 = 16;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	asu64(R1) = p;
	mc_stackmcl_freeworkregs(asu64(R1));
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	return;
}

static void mc_genmcl_px_longjmp(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 16;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	R1 = 1;
	mc_stackmcl_swapopndregs(asi64(R1));
	R1 = 0;
	asu64(R2) = cx;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_initdswx(u64 p) {
	return;
}

static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf) {
    u64 R1, R2, R3; 
	struct $B18 params;
	struct $B18 xparams;
	struct $B18 leafparams;
	struct $B18 xleafparams;
	u32 leafparamno;
	u32 xleafparamno;
	struct $B16 locals;
	struct $B16 xlocals;
	i64 nparams;
	i64 nxparams;
	i64 nleafparams;
	i64 nxleafparams;
	i64 nlocals;
	i64 nxlocals;
	i64 n;
	i64 reg;
	i64 xreg;
	i64 nl;
	i64 np;
	i64 nlx;
	i64 npx;
	u64 d;
	i64 i;
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nxparams = asi64(R1);
	R1 = 0;
	nleafparams = asi64(R1);
	R1 = 0;
	nxleafparams = asi64(R1);
	R1 = 0;
	nlocals = asi64(R1);
	R1 = 0;
	nxlocals = asi64(R1);
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = mc_decls_maxxregvars;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2214;
	goto L2212;
L2214:
	asi64(R1) = skipparams;
	if (asi64(R1)) goto L2216;
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L2220;
L2217:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2222;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2222;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2222;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2222;
	asi64(R1) = isleaf;
	if (asi64(R1)) goto L2224;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2226;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2228;
	asu64(R1) = d;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2228:
	goto L2225;
L2226:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2229;
	asi64(R1) = nxparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2231;
	asu64(R1) = d;
	R2 = (u64)&xparams;
	R3 = (u64)&nxparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2231:
L2229:
L2225:
	goto L2223;
L2224:
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2233;
	asi64(R1) = nleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2235;
	asu64(R1) = d;
	R2 = (u64)&leafparams;
	R3 = (u64)&nleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&leafparamno;
	asi64(R3) = nleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2235:
	goto L2232;
L2233:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2236;
	asi64(R1) = nxleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2238;
	asu64(R1) = d;
	R2 = (u64)&xleafparams;
	R3 = (u64)&nxleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&xleafparamno;
	asi64(R3) = nxleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2238:
L2236:
L2232:
L2223:
L2222:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2220:
	asu64(R1) = d;
	if (asu64(R1)) goto L2217;
L2216:
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2242;
L2239:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2244;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2244;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2244;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2246;
	asi64(R1) = nlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L2248;
	asu64(R1) = d;
	R2 = (u64)&locals;
	R3 = (u64)&nlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2248:
	goto L2245;
L2246:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2249;
	asi64(R1) = nxlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L2249;
	asu64(R1) = d;
	R2 = (u64)&xlocals;
	R3 = (u64)&nxlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2249:
L2245:
L2244:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2242:
	asu64(R1) = d;
	if (asu64(R1)) goto L2239;
	asi64(R1) = nlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2251;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	np = asi64(R1);
	R1 = 0;
	nl = asi64(R1);
	goto L2250;
L2251:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2252;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nl = asi64(R1);
	R1 = 0;
	np = asi64(R1);
	goto L2250;
L2252:
	asi64(R1) = nlocals;
	nl = asi64(R1);
	asi64(R1) = nparams;
	np = asi64(R1);
	asi64(R1) = np;
	asi64(R2) = nl;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2254;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2256;
	asi64(R1) = np;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2256;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2256:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2258;
	asi64(R1) = n;
	R2 = (u64)&nl;
	*toi64p(R2) -= asi64(R1);
L2258:
L2254:
L2250:
	R1 = 4;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nl;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2261;
L2259:
	R1 = (u64)&locals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= nl) goto L2259;
L2261:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = np;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2264;
L2262:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= np) goto L2262;
L2264:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2267;
L2265:
	R1 = (u64)&leafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&leafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2269;
	R1 = 1;
	pc_decls_r10used = asu8(R1);
L2269:
	asi64(R1) = reg;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2271;
	R1 = 1;
	pc_decls_r11used = asu8(R1);
L2271:
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nleafparams) goto L2265;
L2267:
	asi64(R1) = nxlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2273;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npx = asi64(R1);
	R1 = 0;
	nlx = asi64(R1);
	goto L2272;
L2273:
	asi64(R1) = nxparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2274;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nlx = asi64(R1);
	R1 = 0;
	npx = asi64(R1);
	goto L2272;
L2274:
	asi64(R1) = nxlocals;
	nlx = asi64(R1);
	asi64(R1) = nxparams;
	npx = asi64(R1);
	asi64(R1) = npx;
	asi64(R2) = nlx;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2276;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2278;
	asi64(R1) = npx;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2278;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2278:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2280;
	asi64(R1) = n;
	R2 = (u64)&nlx;
	*toi64p(R2) -= asi64(R1);
L2280:
L2276:
L2272:
	R1 = 16;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2283;
L2281:
	R1 = (u64)&xlocals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= nlx) goto L2281;
L2283:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = npx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2286;
L2284:
	R1 = (u64)&xparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= npx) goto L2284;
L2286:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nxleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2289;
L2287:
	R1 = (u64)&xleafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&xleafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nxleafparams) goto L2287;
L2289:
L2212:
	return;
}

static void mc_auxmcl_initproc(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 e;
	u64 pinfi;
	i64 reg;
	i64 xreg;
	i64 n;
	i64 r;
	i64 npregs;
	i64 av_1;
	i64 av_2;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isregvar;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isxregvar;
	memset(R1, 0, 16);
	R1 = 3;
	mc_decls_nworkregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	mc_decls_maxxregvars = asi64(R2);
	mc_decls_maxregvars = asi64(R1);
	R1 = 0;
	npregs = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2292;
	R1 = 10;
	mc_decls_nworkregs = asi64(R1);
	R1 = 12;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 4;
	r = asi64(R1);
L2293:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 10) goto L2293;
	R1 = 7;
	r = asi64(R1);
L2296:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 16) goto L2296;
	goto L2291;
L2292:
	R1 = 4;
	asu64(R2) = pc_decls_currfunc;
	R3 = 112;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = pc_decls_pinfo;
	R4 = 4;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) = Max(asi64(R2), asi64(R3));
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npregs = asi64(R1);
	R1 = 4;
	mc_decls_nworkregs = asi64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2300;
	R1 = (u64)&mc_decls_nworkregs;
	(*toi64p(R1)) += 1;
L2300:
	R1 = 5;
	mc_decls_nworkxregs = asi64(R1);
	asi64(R1) = mc_decls_nworkregs;
	R2 = 3;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = npregs;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L2302;
	asi64(R1) = n;
	if (!asi64(R1)) goto L2302;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = npregs;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2304;
	asi64(R1) = n;
	if (!asi64(R1)) goto L2304;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2304:
L2302:
	R1 = 10;
	r = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2307;
L2305:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_1)) goto L2305;
L2307:
	R1 = 7;
	r = asi64(R1);
	asi64(R1) = mc_decls_nworkxregs;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2310;
L2308:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_2)) goto L2308;
L2310:
L2291:
	R1 = 4;
	r = asi64(R1);
L2311:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2315;
	R1 = (u64)&mc_decls_maxregvars;
	(*toi64p(R1)) += 1;
L2315:
	r += 1; if (r <= 10) goto L2311;
	R1 = 7;
	r = asi64(R1);
L2316:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2320;
	R1 = (u64)&mc_decls_maxxregvars;
	(*toi64p(R1)) += 1;
L2320:
	r += 1; if (r <= 16) goto L2316;
	R1 = (u64)&mc_decls_usedregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_usedxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_pcltempflags;
	memset(R1, 0, 20);
	R1 = 0;
	R2 = R1;
	pc_decls_r11used = asu8(R2);
	pc_decls_r10used = asu8(R1);
	R1 = 0;
	mc_decls_mstackdepth = asi64(R1);
	R1 = 0;
	mc_decls_noperands = asi64(R1);
	R1 = 0;
	R2 = R1;
	mc_genmcl_framebytes = asi64(R2);
	R2 = R1;
	mc_genmcl_paramoffset = asi64(R2);
	mc_genmcl_frameoffset = asi64(R1);
	R1 = 0;
	pc_decls_localshadow = asu8(R1);
	R1 = 0;
	mc_decls_nblocktemps = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2322;
	R1 = 8;
	R2 = tou64("$1x");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	asu64(R2) = e;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = e;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = pc_decls_currfunc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	pc_decls_blockretname = asu64(R1);
L2322:
	asu8(R1) = pc_decls_fregoptim;
	if (!asu8(R1)) goto L2325;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2324;
L2325:
	goto L2290;
L2324:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2327;
	goto L2290;
L2327:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_decls_currfunc;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (asu8(R2)) goto L2328;
	asu64(R2) = pc_decls_currfunc;
	R3 = 113;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2329;
L2328:
	R2 = 1;
	goto L2330;
L2329:
	R2 = 0;
L2330:
	mc_auxmcl_allocregvars(asi64(R2), asi64(R1));
L2290:
	return;
}

static void mc_auxmcl_do_procentry(u64 p) {
    u64 R1, R2, R3; 
	i64 retmode;
	i64 ntemps;
	i64 hasequiv;
	i64 offset;
	i64 size;
	i64 reg;
	u64 ax;
	u64 d;
	struct $B5 str;
	struct $B5 newname;
	i64 rr;
	i64 ff;
	i64 r;
	i64 i;
	asu64(R1) = mc_decls_mclprocentry;
	mc_auxmcl_setmclentry(asu64(R1));
	R1 = 0;
	R2 = R1;
	pc_decls_bxspill = asi64(R2);
	pc_decls_bspill = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2334;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2333;
L2334:
	R1 = 4;
	r = asi64(R1);
L2335:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2340;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2339;
L2340:
	R1 = (u64)&pc_decls_bspill;
	(*toi64p(R1)) += 1;
L2339:
	r += 1; if (r <= 10) goto L2335;
	R1 = 7;
	r = asi64(R1);
L2341:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2346;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2345;
L2346:
	R1 = (u64)&pc_decls_bxspill;
	(*toi64p(R1)) += 1;
L2345:
	r += 1; if (r <= 16) goto L2341;
L2333:
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2350;
L2347:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2352;
	R1 = tou64("");
	R2 = tou64("@PARAM");
	pc_api_merror(asu64(R2), asu64(R1));
L2352:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2354;
	asi64(R1) = mc_genmcl_paramoffset;
	R2 = 16;
	asi64(R1) += asi64(R2);
	asi64(R2) = pc_decls_bspill;
	asi64(R3) = pc_decls_bxspill;
	asi64(R2) += asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writenasm_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2353;
L2354:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2353:
	R1 = 8;
	R2 = (u64)&mc_genmcl_paramoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2350:
	asu64(R1) = d;
	if (asu64(R1)) goto L2347;
	asu64(R1) = pc_decls_currfunc;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	retmode = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2358;
L2355:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2360;
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	size = asi64(R1);
L2360:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2362;
	goto L2356;
L2362:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2364;
	R1 = 1;
	hasequiv = asi64(R1);
	goto L2363;
L2364:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2365;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2363;
L2365:
	asi64(R1) = size;
	asi64(R1) = mc_libmcl_roundsizetg(asi64(R1));
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writenasm_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2363:
L2356:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2358:
	asu64(R1) = d;
	if (asu64(R1)) goto L2355;
	R1 = 0;
	ntemps = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L2366:
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2370;
	R1 = (u64)&ntemps;
	(*toi64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&mc_decls_pcltempopnds;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ax = asu64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = ax;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asi64(R2) = i;
	asu64(R3) = pc_decls_currfunc;
	asu64(R2) = mc_writenasm_gettempname(asu64(R3), asi64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2370:
	i += 1; if (i <= 20) goto L2366;
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2372;
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (asi16(R1)) goto L2375;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2374;
L2375:
	R1 = tou64("");
	R2 = tou64("Threaded proc has locals/params");
	pc_api_merror(asu64(R2), asu64(R1));
L2374:
	asi64(R1) = ntemps;
	if (!asi64(R1)) goto L2377;
	R1 = tou64("");
	R2 = tou64("Threaded proc has temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2377:
	asu64(R1) = mc_auxmcl_resetmclentry();
	goto L2331;
L2372:
	asi64(R1) = mc_genmcl_frameoffset;
	asi64(R1) = -asi64(R1);
	mc_genmcl_framebytes = asi64(R1);
	asi64(R1) = pc_decls_bspill;
	asi64(R2) = pc_decls_bxspill;
	asi64(R1) += asi64(R2);
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2379;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L2381;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2381:
	goto L2378;
L2379:
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2383;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2383:
L2378:
	asu8(R1) = pc_decls_localshadow;
	if (!asu8(R1)) goto L2385;
	R1 = 32;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2385:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L2387;
	R1 = 4;
	r = asi64(R1);
L2388:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2393;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2392;
L2393:
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2392:
	r += 1; if (r <= 10) goto L2388;
L2387:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L2395;
	R1 = 6;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 7;
	r = asi64(R1);
L2396:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2401;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2400;
L2401:
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2400:
	r += 1; if (r <= 16) goto L2396;
L2395:
	R1 = tou64("?]]");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_auxmcl_mclframesetup = asu64(R1);
	mc_auxmcl_spillparams();
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_auxmcl_resetmclentry();
L2331:
	return;
}

static void mc_auxmcl_do_procexit() {
    u64 R1, R2, R3; 
	u64 ax;
	i64 offset;
	i64 r;
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2404;
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2402;
L2404:
	asu64(R1) = mc_auxmcl_mclframesetup;
	mc_auxmcl_setmclentryf(asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L2407;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2406;
L2407:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2409;
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_pushstack(asi64(R1));
	goto L2408;
L2409:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L2411;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
L2411:
L2408:
L2406:
	asu64(R1) = mc_auxmcl_resetmclentryf();
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L2414;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2413;
L2414:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2416;
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_popstack(asi64(R1));
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2415;
L2416:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L2418;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_popstack(asi64(R1));
L2418:
L2415:
L2413:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L2420;
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 16;
	r = asi64(R1);
L2421:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2425;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	R2 = 8;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2425:
	r += -1; if (r >= 7) goto L2421;
L2420:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L2427;
	R1 = 10;
	r = asi64(R1);
L2428:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2432;
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2432:
	r += -1; if (r >= 4) goto L2428;
L2427:
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2402:
	return;
}

static void mc_auxmcl_spillparams() {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 d;
	u64 ax;
	i64 offset;
	i64 regoffset;
	i64 xregoffset;
	i64 firstoffset;
	i64 i;
	R1 = 16;
	offset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2435;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	firstoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L2438;
L2436:
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asi64(R4) = i;
	R5 = 8;
	asi64(R4) *= asi64(R5);
	asi64(R5) = firstoffset;
	asi64(R4) += asi64(R5);
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = i;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	i += 1; if (i <= 3) goto L2436;
L2438:
L2435:
	goto L2442;
L2439:
	asi64(R1) = regoffset;
	R2 = 3;
	if (asi64(R1) <= asi64(R2)) goto L2444;
	goto L2441;
L2444:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2446;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2448;
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asu64(R4) = d;
	R5 = 76;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2450;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2451;
	goto L2452;
L2450:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2449;
L2451:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 16;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2449;
L2452:
	R1 = 10;
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2449:
	goto L2447;
L2448:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2453;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2455;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L2457;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 8;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2457:
	goto L2454;
L2455:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2458;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2458:
L2454:
L2453:
L2447:
L2446:
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&regoffset;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2442:
	asu64(R1) = d;
	if (asu64(R1)) goto L2439;
L2441:
	return;
}

static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2461;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2460;
L2461:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2460:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_bitwise(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shift(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 y;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	y = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2465;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2465;
	R1 = 10;
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2464;
L2465:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2467;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2467:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2469;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2469:
L2464:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_setmclentry(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mce_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentry() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mce_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mce_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mce_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L2471;
L2471:
	return asu64(R1);
}

static void mc_auxmcl_setmclentryf(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mcf_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentryf() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mcf_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mcf_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mcf_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L2473;
L2473:
	return asu64(R1);
}

static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 j;
	i64 k;
	i64 nextireg;
	i64 nextxreg;
	i64 mode;
	i64 imode;
	i64 blockret;
	u64 dblock;
	i64 av_1;
	i64 i;
	asi64(R1) = nargs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2476;
	goto L2474;
L2476:
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	R1 = 11;
	nextireg = asi64(R1);
	R1 = 1;
	nextxreg = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = nargs;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) < asi64(R2)) goto L2479;
L2477:
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = k;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2481;
	asi64(R1) = blockret;
	if (!asi64(R1)) goto L2481;
	R1 = (u64)&mc_decls_callblocksize;
	asi64(R2) = mc_decls_ncalldepth;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2480;
L2481:
	asi64(R1) = i;
	asi64(R2) = isptr;
	asi64(R1) -= asi64(R2);
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = j;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2483;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2484;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2484;
	goto L2485;
L2483:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = k;
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*16-16;
	asi64(R3) = k;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(tou32(R2));
	asu64(R3) = ax;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
	goto L2482;
L2484:
	asi64(R1) = nextxreg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L2487;
	asi64(R1) = k;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L2487;
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2489;
	R1 = 5;
	goto L2488;
L2489:
	R1 = 6;
L2488:
	imode = asi64(R1);
	asi64(R1) = mode;
	asi64(R2) = nextxreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = imode;
	asi64(R3) = nextireg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2487:
	goto L2482;
L2485:
// mc_auxmcl.do_pushlowargs.doint:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
L2482:
L2480:
	R1 = (u64)&nextireg;
	(*toi64p(R1)) += 1;
	R1 = (u64)&nextxreg;
	(*toi64p(R1)) += 1;
	i += -1; if (i >= av_1) goto L2477;
L2479:
L2474:
	return;
}

static void mc_auxmcl_do_getretvalue(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 xreg;
	i64 i;
	i64 n;
	i64 m;
	struct $B1 modes;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L2493;
	R1 = 0;
	n = asi64(R1);
	goto L2495;
L2494:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&modes;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L2495:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2494;
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2499;
L2497:
	R1 = (u64)&modes;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2501;
	R1 = (u64)&mc_decls_multxregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L2500;
L2501:
	R1 = (u64)&mc_decls_multregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
L2500:
	asi64(R2) = m;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	i += -1; if (i >= 1) goto L2497;
L2499:
	goto L2492;
L2493:
	R1 = 1;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
L2492:
	return;
}

static i64 mc_auxmcl_ismemaddr(i64 n) {
    u64 R1, R2; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2504;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2504;
	R1 = 1;
	goto L2502;
L2504:
	R1 = 0;
	goto L2502;
L2502:
	return asi64(R1);
}

static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 mx;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2507;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2506;
L2507:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2506:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2510;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2509;
L2510:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2509:
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2513;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2512;
L2513:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2512:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 r;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 mx;
	i64 reg;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	r = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2516;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2518;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2517;
L2518:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2517:
	asu64(R1) = mx;
	ax = asu64(R1);
	goto L2515;
L2516:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2520;
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2519;
L2520:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2519:
	asu64(R1) = ax;
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2515:
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2522;
	R1 = 10;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	goto L2521;
L2522:
	R1 = 6;
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	bx = asu64(R1);
L2521:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale) {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2525;
L2526:
	asi64(R1) = scale;
	goto L2523;
L2525:
	asi64(R1) = scale;
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	goto L2523;
L2523:
	return asi64(R1);
}

static void mc_auxmcl_mulimm(u64 ax, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 shifts;
	i64 m;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2529;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2530;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L2531;
	goto L2532;
L2529:
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	goto L2527;
	goto L2528;
L2530:
	goto L2527;
	goto L2528;
L2531:
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2527;
	goto L2528;
L2532:
L2528:
	R1 = 0;
	shifts = asi64(R1);
	asi64(R1) = n;
	m = asi64(R1);
	goto L2534;
L2533:
	R1 = 1;
	R2 = (u64)&m;
	*toi64p(R2) >>= asi64(R1);
	R1 = (u64)&shifts;
	(*toi64p(R1)) += 1;
L2534:
	asi64(R1) = m;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2533;
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2537;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2537:
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2539;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2540;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2540;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2540;
	goto L2541;
L2539:
	goto L2527;
	goto L2538;
L2540:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = m;
	R6 = 1;
	asi64(R5) -= asi64(R6);
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2538;
L2541:
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2543;
	R1 = 34;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_mccodex;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2542;
L2543:
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2542:
L2538:
L2527:
	return;
}

static u64 mc_auxmcl_do_addrmode(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 px;
	u64 ax;
	u64 bx;
	i64 scale;
	i64 extra;
	i64 offset;
	i64 reg;
	i64 regix;
	u64 d;
	u64 q;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2546;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
L2546:
	R1 = 0;
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2548;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2550;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2549;
L2550:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2551;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2549;
L2551:
	asi64(R1) = scale;
	R2 = 0;
	R3 = (u64)&mc_decls_pclmode;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2549:
	goto L2547;
L2548:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R1) = mc_auxmcl_ismemaddr(asi64(R1));
	if (!asi64(R1)) goto L2552;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2556;
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2555;
L2556:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2554;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2554;
L2555:
	goto L2557;
L2554:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2559;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2558;
L2559:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2560;
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2558;
L2560:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 10;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2558:
	goto L2547;
L2552:
// mc_auxmcl.do_addrmode.skip:
L2557:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2562;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2561;
L2562:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2563;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2561;
L2563:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2561:
L2547:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = px;
	goto L2544;
L2544:
	return asu64(R1);
}

static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	i64 regix;
	u64 ax;
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2567;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2567;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2567;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2566;
L2567:
	asi64(R1) = reg;
	goto L2564;
L2566:
	asi64(R1) = mc_stackmcl_getworkireg();
	regix = asi64(R1);
	R1 = 10;
	asi64(R2) = regix;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2569;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 1;
	asi64(R6) = reg;
	asi64(R7) = reg;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
	goto L2568;
L2569:
	R1 = 10;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
L2568:
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = regix;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 10;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = regix;
	goto L2564;
L2564:
	return asi64(R1);
}

static void mc_auxmcl_dolea(u64 ax, u64 px) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = px;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2574;
	asu64(R2) = px;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2574;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2574;
	R1 = 1;
	goto L2575;
L2574:
	R1 = 0;
L2575:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2573;
	asu64(R1) = px;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2572;
L2573:
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2572:
	return;
}

static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 rx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2578;
	asi64(R1) = fopc;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2576;
L2578:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2576:
	return;
}

static void mc_auxmcl_do_binto_float(u64 p, i64 opc) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = cx;
	asi64(R3) = opc;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shiftnto(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 cx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2582;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2582;
	R1 = 10;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2581;
L2582:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2584;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2584:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2586;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2586:
L2581:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 q;
	i64 opc;
	i64 n;
	i64 shifts;
	u8 fdivto;
	i64 locyy;
	i64 loczz;
	R1 = 0;
	fdivto = asu8(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	locyy = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	loczz = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L2590;
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L2589;
L2590:
	R1 = (u64)&locyy;
	R2 = (u64)&loczz;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	fdivto = asu8(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2588;
L2589:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
L2588:
	asi64(R1) = loczz;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2592;
	asi64(R1) = isdiv;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2592;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2594;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2595;
	goto L2596;
L2594:
	R1 = tou64("");
	R2 = tou64("Divide by zero");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2593;
L2595:
	mc_stackmcl_poppcl();
	goto L2587;
	goto L2593;
L2596:
	asi64(R1) = n;
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	shifts = asi64(R1);
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2598;
	asu8(R1) = fdivto;
	if (asu8(R1)) goto L2598;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = issigned;
	if (!asi64(R3)) goto L2600;
	R3 = 44;
	goto L2599;
L2600:
	R3 = 45;
L2599:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L2587;
L2598:
L2593:
L2592:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	mc_auxmcl_saverdx();
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_auxmcl_fixdivopnds(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = issigned;
	if (!asi64(R1)) goto L2602;
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2604;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2605;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2606;
	goto L2607;
L2604:
	R1 = 57;
	goto L2603;
L2605:
	R1 = 56;
	goto L2603;
L2606:
	R1 = 55;
	goto L2603;
L2607:
	R1 = tou64("");
	R2 = tou64("div/u8");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
L2603:
	opc = asi64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 36;
	opc = asi64(R1);
	goto L2601;
L2602:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 37;
	opc = asi64(R1);
L2601:
	R1 = 0;
	asu64(R2) = bx;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = isdiv;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2609;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2610;
	goto L2611;
L2609:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2608;
L2610:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	mc_stackmcl_swapopndregs(asi64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2608;
L2611:
L2608:
	mc_auxmcl_restorerdx();
	asu8(R1) = fdivto;
	if (!asu8(R1)) goto L2613;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu64(R2) = bx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = bx;
	asu64(R2) = mc_stackmcl_makeopndind(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
L2613:
	asi64(R1) = isdiv;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2615;
	mc_stackmcl_poppcl();
L2615:
L2587:
	return;
}

static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz) {
    u64 R1, R2, R3; 
	i64 regx;
	i64 regy;
	i64 zop;
	u64 bx;
	u64 ax;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regx = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = loczz;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regy = asi64(R1);
	asi64(R1) = regx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2618;
	goto L2616;
L2618:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = regy;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2620;
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2616;
L2620:
	R1 = (u64)&mc_decls_regset;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2622;
	asu64(R1) = bx;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = regx;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = locyy;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2616;
L2622:
	asi64(R1) = mc_decls_noperands;
	zop = asi64(R1);
	asi64(R1) = zop;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2626;
L2623:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2628;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2628;
	goto L2625;
L2628:
	zop += -1; if (zop >= 1) goto L2623;
L2626:
	goto L2616;
L2625:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = zop;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
L2616:
	return;
}

static void mc_auxmcl_saverdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2631;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2631:
	return;
}

static void mc_auxmcl_restorerdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2634;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2634:
	return;
}

static void mc_auxmcl_clearblock(u64 ax, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 av_1;
	i64 i;
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2637;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L2637;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2640;
L2638:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2638;
L2640:
	goto L2636;
L2637:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2641;
	asi64(R1) = nwords;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2643;
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	goto L2642;
L2643:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	R3 = 4;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
L2644:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= 4) goto L2644;
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2642:
L2641:
L2636:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2648;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2650;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2650:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2652;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2652:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2654;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2654:
L2648:
	return;
}

static void mc_auxmcl_do_blockdata(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 d;
	i64 n;
	i64 nqwords;
	i64 nwords;
	i64 r;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2657;
	goto L2655;
L2657:
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2660;
L2658:
	R1 = 0;
	R2 = 10;
	R3 = (u64)&d;
	asu64(R4) = *tou64p(R3); *(tou64p(R3)) += 8; asu64(R3) = asu64(R4);
	asi64(R3) = *toi64p(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L2658;
L2660:
	asi64(R1) = n;
	asi64(R2) = nwords;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) -= asi64(R2);
	r = asi64(R1);
	asi64(R1) = r;
	if (!asi64(R1)) goto L2662;
	R1 = 66;
	asi64(R2) = r;
	asu64(R3) = d;
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
L2662:
	R1 = tou64("ENDDATA");
	mc_libmcl_mgencomment(asu64(R1));
L2655:
	return;
}

static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 axreg;
	u8 saved;
	i64 av_1;
	R1 = 0;
	saved = asu8(R1);
	asi64(R1) = n;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2665;
	R1 = 2;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2663;
L2665:
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2667;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2667;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 8;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2670;
L2668:
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2668;
L2670:
	goto L2666;
L2667:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2671;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asi64(R1) = savedest;
	if (!asi64(R1)) goto L2673;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	axreg = asi64(R1);
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	saved = asu8(R1);
L2673:
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	bx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2671:
L2666:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2675;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2677;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 4;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2677:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2679;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 2;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2679:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2681;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 1;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2681:
L2675:
	asu8(R1) = saved;
	if (!asu8(R1)) goto L2683;
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2683:
L2663:
	return;
}

static void mc_auxmcl_genstringtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_cstringlist;
	if (asu64(R1)) goto L2686;
	goto L2684;
L2686:
	R1 = tou64("String Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_kk0used;
	if (!asi64(R1)) goto L2688;
	R1 = 0;
	asi64(R2) = mc_decls_kk0used;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2688:
	asu64(R1) = mc_decls_cstringlist;
	p = asu64(R1);
	goto L2692;
L2689:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = -1;
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2692:
	asu64(R1) = p;
	if (asu64(R1)) goto L2689;
L2684:
	return;
}

static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype) {
    u64 R1, R2; 
	i64 i;
	i64 c;
	i64 seqlen;
	u64 seq;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L2695;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2695:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2697;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
	goto L2693;
L2697:
	R1 = 0;
	seqlen = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2700;
L2698:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L2703;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) >= asi64(R2)) goto L2703;
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2704;
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L2702;
L2704:
L2703:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2706;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
	R1 = 0;
	seqlen = asi64(R1);
L2706:
	asi64(R1) = c;
	mc_auxmcl_gendb(asi64(R1));
	goto L2701;
L2702:
	asi64(R1) = seqlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2708;
	R1 = 1;
	seqlen = asi64(R1);
	asu64(R1) = s;
	R2 = 1;
	R1 -= (i64)R2;
	seq = asu64(R1);
	goto L2707;
L2708:
	R1 = (u64)&seqlen;
	(*toi64p(R1)) += 1;
L2707:
L2701:
	if (--asi64(av_1)) goto L2698;
L2700:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2710;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
L2710:
	asi64(R1) = strtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2712;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2712:
L2693:
	return;
}

static void mc_auxmcl_gendb(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendbstring(u64 s, i64 length) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendq(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_genrealtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_creallist;
	if (asu64(R1)) goto L2718;
	asu64(R1) = mc_decls_cr32list;
	if (asu64(R1)) goto L2718;
	goto L2716;
L2718:
	R1 = tou64("Real Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = mc_decls_creallist;
	p = asu64(R1);
	goto L2722;
L2719:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2724;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2723;
L2724:
	R1 = 0;
	R2 = 2;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2723:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2722:
	asu64(R1) = p;
	if (asu64(R1)) goto L2719;
	R1 = tou64("Real32 Table");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_cr32list;
	p = asu64(R1);
	goto L2728;
L2725:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2730;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
    asr32(R3) = tor32(asr64(R3));
	asi64(R3) = asi64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2729;
L2730:
	R1 = 0;
	R2 = 1;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2729:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2728:
	asu64(R1) = p;
	if (asu64(R1)) goto L2725;
L2716:
	return;
}

static void mc_auxmcl_genabsneg() {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_lababs32;
	asi64(R2) = mc_decls_lababs64;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg32;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg64;
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L2733;
	R1 = 16;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
L2733:
	asi64(R1) = mc_decls_lababs32;
	if (!asi64(R1)) goto L2735;
	R1 = tou64("lababs32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
L2735:
	asi64(R1) = mc_decls_lababs64;
	if (!asi64(R1)) goto L2737;
	R1 = tou64("lababs64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
L2737:
	asi64(R1) = mc_decls_labneg32;
	if (!asi64(R1)) goto L2739;
	R1 = tou64("labneg32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
L2739:
	asi64(R1) = mc_decls_labneg64;
	if (!asi64(R1)) goto L2741;
	R1 = tou64("labneg64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
L2741:
	asi64(R1) = mc_decls_labzero;
	if (!asi64(R1)) goto L2743;
	R1 = tou64("labzero");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labzero;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendq(asi64(R1));
L2743:
	asi64(R1) = mc_decls_labmask63;
	if (!asi64(R1)) goto L2745;
	R1 = tou64("mask63/offset64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labmask63;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_laboffset64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4890909195324358656;
	mc_auxmcl_gendq(asi64(R1));
L2745:
	return;
}

static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	R2 = 0;
	asu64(R3) = opname;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	asu64(R2) = d;
	R3 = 0;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs) {
    u64 R1, R2, R3; 
	i64 slots;
	i64 av_1;
	asi64(R1) = nargs;
	mc_stackmcl_saveopnds(asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2750;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
	R1 = 1;
	slots = asi64(R1);
L2750:
	R1 = 0;
	R2 = 0;
	asi64(R3) = nargs;
	mc_auxmcl_do_pushlowargs(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L2752;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	goto L2751;
L2752:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L2751:
	asu64(R1) = opname;
	if (!asu64(R1)) goto L2754;
	R1 = 0;
	asu64(R2) = opname;
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2753;
L2754:
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2753:
	asi64(R1) = nargs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2757;
L2755:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L2755;
L2757:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L2759;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L2759:
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
	return;
}

static void mc_auxmcl_do_max_int(i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = cond;
	R4 = 15;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_max_float(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asi64(R1) = mode;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asi64(R4) = mode;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_negreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2766;
	asi64(R1) = mc_decls_labneg64;
	if (asi64(R1)) goto L2768;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg64 = asi64(R1);
L2768:
	asi64(R1) = mc_decls_labneg64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 77;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2765;
L2766:
	asi64(R1) = mc_decls_labneg32;
	if (asi64(R1)) goto L2770;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg32 = asi64(R1);
L2770:
	asi64(R1) = mc_decls_labneg32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 76;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2765:
	return;
}

static void mc_auxmcl_do_absreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2773;
	asi64(R1) = mc_decls_lababs64;
	if (asi64(R1)) goto L2775;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs64 = asi64(R1);
L2775:
	asi64(R1) = mc_decls_lababs64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 79;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2772;
L2773:
	asi64(R1) = mc_decls_lababs32;
	if (asi64(R1)) goto L2777;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs32 = asi64(R1);
L2777:
	asi64(R1) = mc_decls_lababs32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 78;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2772:
	return;
}

static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 mx;
	u64 mask;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2780;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 44;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2779;
L2780:
	asi64(R1) = i;
	if (!asi64(R1)) goto L2782;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2782:
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	asu64(R1) = mask;
	R2 = 2147483647;
	if (asu64(R1) > asu64(R2)) goto L2784;
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2783;
L2784:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2783:
L2779:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_loadbf_var(u64 p) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = tou64("LOADBF_VAR");
	pc_api_merror(asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_do_storebit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 cx;
	u64 ix;
	u64 q;
	u64 r;
	i64 i;
	i64 offset;
	u8 mask1s;
	u8 mask0s;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2788;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	offset = asi64(R1);
	R1 = 7;
	R2 = (u64)&i;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = px;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	mask0s = asu8(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	mask1s = asu8(R1);
	asu64(R1) = r;
	if (!asu64(R1)) goto L2790;
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2792;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2791;
L2792:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask0s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2791:
	goto L2789;
L2790:
	R1 = 0;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2794;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2794:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2789:
	goto L2787;
L2788:
	asu64(R1) = r;
	if (!asu64(R1)) goto L2795;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2797;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2799;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2799:
	R1 = 11;
	R2 = 10;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ix = asu64(R1);
	R1 = 1;
	asu64(R2) = cx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2801;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2801:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2803;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2802;
L2803:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2802:
	goto L2796;
L2797:
	R1 = tou64("");
	R2 = tou64("STOREBIT/VAR");
	pc_api_merror(asu64(R2), asu64(R1));
L2796:
	goto L2787;
L2795:
	R1 = tou64("");
	R2 = tou64("Storebit: both vars");
	pc_api_merror(asu64(R2), asu64(R1));
L2787:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_storebf(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 rx;
	u64 mx;
	u64 mx4;
	u64 dx;
	i64 i;
	i64 j;
	u64 q;
	u64 r;
	u64 mask;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = r;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2806;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2806;
	R1 = tou64("");
	R2 = tou64("storebf not imm");
	pc_api_merror(asu64(R2), asu64(R1));
L2806:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 3;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	dx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	j = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	asi64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2808;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = dx;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2808:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = mx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dx;
	asu64(R2) = rx;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static u64 mc_auxmcl_gethostfn(i64 opc) {
    u64 R1, R2; 
	u64 d;
	u64 name;
	u64 namec;
	u64 ps;
	asu64(R1) = pc_api_igethostfn;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2811;
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2813;
	goto L2814;
L2813:
	R1 = tou64("msys.m$power_i64");
	name = asu64(R1);
	R1 = tou64("msysc.m$power_i64");
	namec = asu64(R1);
	goto L2812;
L2814:
	R1 = 0;
	name = asu64(R1);
L2812:
	asu64(R1) = name;
	if (!asu64(R1)) goto L2816;
	asu64(R1) = pc_decls_psymboltable;
	ps = asu64(R1);
	goto L2820;
L2817:
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L2823;
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = namec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2822;
L2823:
	asu64(R1) = ps;
	goto L2809;
L2822:
	asu64(R1) = ps;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ps = asu64(R1);
L2820:
	asu64(R1) = ps;
	if (asu64(R1)) goto L2817;
L2816:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("gethostfn?");
	pc_api_merror(asu64(R2), asu64(R1));
L2811:
	asi64(R1) = opc;
	asu64(R2) = pc_api_igethostfn;
	asu64(R1) = ((F19)R2)(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2825;
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("No host fn:");
	pc_api_merror(asu64(R2), asu64(R1));
L2825:
	asu64(R1) = d;
	goto L2809;
L2809:
	return asu64(R1);
}

static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 dblock;
	u64 ax;
	u64 bx;
	u64 axi;
	u64 bxi;
	asu64(R1) = px;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2828;
	msysc_m$print_startcon();
	R1 = tou64("High block arg not copied in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("()");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L2826;
L2828:
	asi64(R1) = size;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = px;
	if (!asu64(R1)) goto L2830;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2829;
L2830:
	R1 = 0;
	R2 = 11;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
L2829:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = size;
	R3 = 0;
	R4 = 10;
	asu64(R5) = bx;
	R6 = 10;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asu64(R3) = mc_libmcl_mgenireg(asi64(R5), asi64(R4), asi64(R3));
	R4 = 0;
	R5 = 10;
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R4) = mc_libmcl_mgenireg(asi64(R6), asi64(R5), asi64(R4));
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = px;
	if (!asu64(R1)) goto L2832;
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2832:
	R1 = 0;
	mc_stackmcl_freeworkregs(asu64(R1));
L2826:
	return;
}

static void mc_auxmcl_fixmain() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 dn;
	u64 dargs;
	u64 denv;
	u64 dinfo;
	u64 ax;
	asu64(R1) = pc_decls_currfunc;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dn = asu64(R1);
	asu64(R1) = dn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dargs = asu64(R1);
	R1 = 3;
	R2 = tou64("$env");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	denv = asu64(R1);
	R1 = 6;
	asu64(R2) = denv;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = denv;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = tou64("$info");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	dinfo = asu64(R1);
	R1 = 11;
	asu64(R2) = dinfo;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 128;
	asu64(R2) = dinfo;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 8;
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = dinfo;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 128;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = denv;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 8;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = denv;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dinfo;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = R1;
	asu64(R3) = d;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = dargs;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = dn;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dn;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = dn;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = dargs;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dn;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = R2;
	ax = asu64(R3);
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dinfo;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dinfo;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dn;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dn;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dargs;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dargs;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = denv;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 13;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = denv;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	R2 = 14;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	R2 = tou64("__getmainargs*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 48;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	if (!asi64(R1)) goto L2835;
	R1 = 9;
	asi64(R2) = pc_decls_pcmdskip;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dn;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dargs;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2835:
	return;
}

static void mc_libmcl_mclinit(i64 bypass) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 r;
	i64 s;
	i64 av_1;
	i64 av_2;
	i64 i;
	R1 = 64;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2838;
	R1 = tou64("MCLREC>64B");
	mlib_abortprogram(asu64(R1));
L2838:
	R1 = 1;
	r = asi64(R1);
L2839:
	R1 = 1;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 2;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 4;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 4;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	r += 1; if (r <= 16) goto L2839;
	R1 = -128;
	i = asi64(R1);
	R1 = 64;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L2844;
L2842:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = i;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_frameregtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+1024)) = asu64(R1);
	i += 1; if (i <= av_1) goto L2842;
L2844:
	R1 = 6;
	R2 = 15;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dframeopnd = asu64(R1);
	R1 = 6;
	R2 = 16;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dstackopnd = asu64(R1);
	mc_libmcl_initmcdest();
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	mc_decls_lab_funcnametable = asi64(R1);
	R1 = 0;
	mc_decls_lab_funcaddrtable = asi64(R1);
	R1 = -1;
	i = asi64(R1);
	R1 = 10;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2847;
L2845:
	R1 = 8;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_libmcl_smallinttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L2845;
L2847:
	asi64(R1) = bypass;
	if (!asi64(R1)) goto L2849;
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
L2849:
	return;
}

static void mc_libmcl_initmcdest() {
    u64 R1, R2; 
	R1 = 0;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
	return;
}

static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 m;
	u64 oldm;
	i64 labno;
	R1 = 64;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	m = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_libmcl_mclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = m;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opcode;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2853;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2854;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2855;
	goto L2856;
L2853:
	asu64(R1) = b;
	if (!asu64(R1)) goto L2858;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2858;
	R1 = 1;
	asu64(R2) = b;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2858:
	goto L2852;
L2854:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	goto L2852;
L2855:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2861;
	asu64(R1) = b;
	if (!asu64(R1)) goto L2860;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2860;
L2861:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2863;
	R1 = 17;
	goto L2862;
L2863:
	R1 = 16;
L2862:
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2860:
	goto L2852;
L2856:
L2852:
	asu64(R1) = mc_decls_mccode;
	if (!asu64(R1)) goto L2865;
	asu64(R1) = mc_decls_mccodex;
	asu64(R2) = m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	mc_decls_mccodex = asu64(R1);
	goto L2864;
L2865:
	asu64(R1) = m;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
L2864:
	return;
}

static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = mc_decls_mccodex;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mc_libmcl_genmc_str(i64 opcode, u64 s) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = -1;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_newmclopnd() {
    u64 R1; 
	u64 a;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	a = asu64(R1);
	R1 = (u64)&mc_libmcl_nmclopnd;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	goto L2868;
L2868:
	return asu64(R1);
}

static u64 mc_libmcl_duplopnd(u64 a) {
    u64 R1, R2; struct $B3 R1_B3; 
	u64 b;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	b = asu64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = b;
	goto L2869;
L2869:
	return asu64(R1);
}

static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = areg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = areg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2873;
	asi64(R1) = ireg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2872;
L2873:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2872:
	asi64(R1) = ireg;
	asu64(R2) = a;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 5;
	R4 = 8;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = labno;
	if (!asi64(R1)) goto L2875;
	asi64(R1) = labno;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2874;
L2875:
	asu64(R1) = def;
	if (!asu64(R1)) goto L2876;
	asu64(R1) = def;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = def;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = def;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2879;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2878;
L2879:
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2878:
L2876:
L2874:
	asu64(R1) = a;
	goto L2870;
L2870:
	return asu64(R1);
}

static void mc_libmcl_mgencomment(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = 3;
	mc_libmcl_genmc_str(asi64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenstring(u64 s, i64 length) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2883;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2883:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = a;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2881;
L2881:
	return asu64(R1);
}

static u64 mc_libmcl_mgenname(u64 s) {
    u64 R1, R2, R3, R4; 
	struct $B31 str;
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2884;
L2884:
	return asu64(R1);
}

static void mc_libmcl_setsegment(i64 seg, i64 align) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 oldalign;
	asi64(R1) = seg;
	asi64(R2) = mc_decls_currsegment;
	if (asi64(R1) == asi64(R2)) goto L2887;
	asi64(R1) = seg;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L2889;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L2890;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L2891;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2892;
	goto L2893;
L2889:
	R1 = 120;
	opc = asi64(R1);
	goto L2888;
L2890:
	R1 = 121;
	opc = asi64(R1);
	goto L2888;
L2891:
	R1 = 122;
	opc = asi64(R1);
	goto L2888;
L2892:
	R1 = tou64("");
	R2 = tou64("CAN'T DO RODATA SEG");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2888;
L2893:
	R1 = tou64("");
	R2 = tou64("BAD SEG CODE");
	pc_api_merror(asu64(R2), asu64(R1));
L2888:
	asu64(R1) = mc_decls_mccodex;
	if (!asu64(R1)) goto L2895;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L2896;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2896;
	R2 = 122;
	if (asi64(R1) != asi64(R2)) goto L2895;
L2896:
	asi64(R1) = opc;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2894;
L2895:
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2894:
	asi64(R1) = seg;
	mc_decls_currsegment = asi64(R1);
L2887:
	asi64(R1) = align;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2898;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) != asi64(R2)) goto L2900;
	asu64(R1) = mc_decls_mccodex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldalign = asi64(R1);
	asi64(R1) = oldalign;
	asi64(R2) = align;
	if (asi64(R1) < asi64(R2)) goto L2902;
	goto L2885;
L2902:
L2900:
	R1 = 0;
	R2 = 10;
	asi64(R3) = align;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 123;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2898:
L2885:
	return;
}

static u64 mc_libmcl_changeopndsize(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L2905;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2907;
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	b = asu64(R1);
	goto L2906;
L2907:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2906:
	asu64(R1) = b;
	goto L2903;
L2905:
	asu64(R1) = a;
	goto L2903;
L2903:
	return asu64(R1);
}

static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2910;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2910;
	asu64(R1) = a;
	goto L2908;
L2910:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = b;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L2912;
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2912:
	asu64(R1) = b;
	goto L2908;
L2908:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint(i64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = x;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2915;
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2915;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2915;
	R1 = (u64)&mc_libmcl_smallinttable;
	asi64(R2) = x;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8+8));
	goto L2913;
L2915:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2913;
L2913:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint0(i64 x, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2916;
L2916:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2919;
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getrealindex(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2918;
L2919:
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getr32index(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2918:
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2917;
L2917:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asr64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2920;
L2920:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabel(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2923;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	x = asi64(R1);
L2923:
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2921;
L2921:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabelmem(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asi64(R1) = x;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2924;
L2924:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmem(u64 d, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2927;
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2929;
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenxregvar(asu64(R1));
	goto L2925;
	goto L2928;
L2929:
	asi64(R1) = mode;
	asu64(R2) = d;
	asu64(R1) = mc_libmcl_mgenregvar(asu64(R2), asi64(R1));
	goto L2925;
L2928:
L2927:
	R1 = 0;
	reg = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2932;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2931;
L2932:
	R1 = 15;
	reg = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2931:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	if (!asi64(R1)) goto L2934;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2933;
L2934:
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asu64(R1) = Min(asu64(R1), asu64(R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2933:
	asu64(R1) = a;
	goto L2925;
L2925:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmemaddr(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2935;
L2935:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg0(i64 reg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2938;
	R1 = tou64("");
	R2 = tou64("1:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2938:
	asu64(R1) = a;
	goto L2936;
L2936:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = xreg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2941;
	R1 = tou64("");
	R2 = tou64("2:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2941:
	asu64(R1) = a;
	goto L2939;
L2939:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg(i64 reg, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2944;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedxregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2943;
L2944:
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2946;
	R1 = 8;
	size = asi64(R1);
L2946:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2948;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2948;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2948:
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2942;
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
L2943:
	goto L2942;
L2942:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregi(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	R2 = (u64)&pc_tables_psize;
	asi64(R3) = mode;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2949;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	goto L2949;
L2949:
	return asu64(R1);
}

static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	goto L2950;
L2950:
	return asu64(R1);
}

static u64 mc_libmcl_mgentemp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	i64 size;
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2953;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	goto L2951;
L2953:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pcltempflags;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2951;
L2951:
	return asu64(R1);
}

static i64 mc_libmcl_roundsizetg(i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2956;
	asi64(R1) = size;
	goto L2954;
L2956:
	asi64(R1) = size;
	R2 = 8;
	asi64(R3) = size;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L2954;
L2954:
	return asi64(R1);
}

static void mc_libmcl_merroropnd(u64 mess, i64 opndtype) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MCL Opnd not supported: # (#) [#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asi64(R2) = opndtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 mc_libmcl_mcreatefwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L2958;
L2958:
	return asi64(R1);
}

static void mc_libmcl_mdefinefwdlabel(i64 lab) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenextname(u64 s) {
    u64 R1, R2, R3; 
	struct $B31 str;
	u64 d;
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mc_libmcl_findnamesym(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L2962;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	mc_libmcl_addnamesym(asu64(R1));
L2962:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	goto L2960;
L2960:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregvar(u64 d, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	goto L2963;
L2963:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxregvar(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 8;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2964;
L2964:
	return asu64(R1);
}

static i64 mc_libmcl_getprimreg(u64 ax) {
    u64 R1, R2; 
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2967;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L2966;
L2967:
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
L2966:
	goto L2965;
L2965:
	return asi64(R1);
}

static void mc_libmcl_pushslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) += asi64(R1);
	return;
}

static void mc_libmcl_popslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_popstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) -= asi64(R1);
	return;
}

static void mc_libmcl_pushstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2972;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2972:
	return;
}

static void mc_libmcl_popstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2975;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2975:
	return;
}

static i64 mc_libmcl_getstringindex(u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2978;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_kk0used = asi64(R1);
	asi64(R1) = mc_decls_kk0used;
	goto L2976;
L2978:
	asu64(R1) = mc_decls_cstringlist;
	if (!asu64(R1)) goto L2980;
	asu64(R1) = s;
	asu64(R2) = mc_decls_cstringlist;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2980;
	asu64(R1) = mc_decls_cstringlist;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2976;
L2980:
	asu64(R1) = s;
	R2 = (u64)&mc_decls_cstringlist;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2976;
L2976:
	return asi64(R1);
}

static i64 mc_libmcl_addconst(u64 clist, i64 value) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 24;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = clist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = clist;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	goto L2981;
L2981:
	return asi64(R1);
}

static i64 mc_libmcl_getrealindex(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	R2 = (u64)&mc_decls_creallist;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2982;
L2982:
	return asi64(R1);
}

static i64 mc_libmcl_getr32index(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	R2 = (u64)&mc_decls_cr32list;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2983;
L2983:
	return asi64(R1);
}

static i64 mc_libmcl_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L2985:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L2989;
	asi64(R1) = n;
	goto L2984;
L2989:
	if (--asi64(av_1)) goto L2985;
	R1 = 0;
	goto L2984;
L2984:
	return asi64(R1);
}

static void mc_libmcl_axerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("AX ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("AASEQ:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static u64 mc_libmcl_newblocktemp(i64 size) {
    u64 R1, R2, R3; 
	struct $B3 str;
	u64 d;
	asi64(R1) = mc_decls_nblocktemps;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L2993;
	R1 = tou64("");
	R2 = tou64("Too many block temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2993:
	R1 = (u64)&mc_decls_nblocktemps;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$B#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_nblocktemps;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 8;
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 11;
	asu64(R2) = d;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = d;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pc_decls_currfunc;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_decls_blockdefs;
	asi64(R3) = mc_decls_nblocktemps;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	goto L2991;
L2991:
	return asu64(R1);
}

static u64 mc_libmcl_findnamesym(u64 s) {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2997;
L2995:
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2999;
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2994;
L2999:
	i += 1; if (i <= mc_libmcl_nnametable) goto L2995;
L2997:
	R1 = 0;
	goto L2994;
L2994:
	return asu64(R1);
}

static void mc_libmcl_addnamesym(u64 d) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 20;
	if (asi64(R1) >= asi64(R2)) goto L3002;
	asu64(R1) = d;
	R2 = (u64)&mc_libmcl_nametable;
	R3 = (u64)&mc_libmcl_nnametable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L3001;
L3002:
	R1 = tou64("");
	R2 = tou64("Ext nametab overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3001:
	return;
}

static void mc_libmcl_callproc(u64 cpname, u64 name, i64 lineno) {
	goto L3003;
L3003:
	return;
}

static u64 mc_libmcl_mgenstringx(u64 s) {
    u64 R1; 
	asu64(R1) = s;
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	goto L3004;
L3004:
	return asu64(R1);
}

static void mc_libmcl_clearreg(u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3007;
	R1 = 4;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
L3007:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3010;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3010;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3011;
	goto L3012;
L3010:
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L3008;
	goto L3009;
L3011:
	asi64(R1) = mode;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgentemp(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	goto L3008;
	goto L3009;
L3012:
L3009:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3014;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3015;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3016;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3017;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3017;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3018;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3019;
	goto L3020;
L3014:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3022;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3022;
	R1 = 6;
	mode = asi64(R1);
	goto L3015;
	goto L3021;
L3022:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
L3021:
	goto L3013;
L3015:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3024;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3024;
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3023;
L3024:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3023:
	goto L3013;
L3016:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3026;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3027;
	goto L3028;
L3026:
	R1 = 65535;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L3025;
L3027:
	R1 = 4294967295;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L3025;
L3028:
L3025:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L3030;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L3030;
	asu64(R1) = bx;
	ax = asu64(R1);
	goto L3029;
L3030:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3029:
	goto L3013;
L3017:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3013;
L3018:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L3013;
L3019:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L3013;
L3020:
// mc_stackmcl.getopnd.error:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = a;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("getopnd");
	pc_api_merror(asu64(R2), asu64(R1));
L3013:
	asu64(R1) = ax;
	goto L3008;
L3008:
	return asu64(R1);
}

static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3034;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3036;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L3036:
L3034:
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	goto L3032;
L3032:
	return asu64(R1);
}

static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg_m(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	goto L3037;
L3037:
	return asu64(R1);
}

static void mc_stackmcl_pushopnd(i64 n, i64 mode) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3040;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L3040:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3042;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3044;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3045;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3046;
	goto L3047;
L3044:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3049;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3050;
L3049:
	goto L3043;
L3045:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L3052;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L3052;
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3050;
L3052:
	goto L3043;
L3046:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3050;
	goto L3043;
L3047:
L3043:
L3042:
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3054;
	asu64(R1) = ax;
	bx = asu64(R1);
	asi64(R1) = mode;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3056;
	R1 = 5;
	goto L3055;
L3056:
	R1 = 6;
L3055:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3054:
// mc_stackmcl.pushopnd.pushit:
L3050:
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&mc_decls_mstackdepth;
	(*toi64p(R1)) += 1;
	return;
}

static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3060;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3059;
L3060:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3063;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L3062;
L3063:
	asu64(R1) = ax;
	goto L3057;
L3062:
L3059:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3057;
L3057:
	return asu64(R1);
}

static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3067;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3066;
L3067:
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L3069;
	asu64(R1) = ax;
	goto L3064;
L3069:
L3066:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3064;
L3064:
	return asu64(R1);
}

static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3072;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3072;
	asu64(R1) = ax;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3072;
	R1 = 4;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	goto L3071;
L3072:
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3071:
	return;
}

static void mc_stackmcl_pushpcl(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L3075;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3075:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3077;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3077;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3077:
	return;
}

static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L3080;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3080:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3082;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L3082:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3084;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3083;
L3084:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3083:
	return;
}

static void mc_stackmcl_poppcl() {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L3087;
	R1 = tou64("");
	R2 = tou64("poppcl/underflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3087:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3089;
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	R1 += (i64)R2-1;
	(*tou8p(R1)) -=1;
	goto L3085;
L3089:
	R1 = (u64)&mc_decls_noperands;
	(*toi64p(R1)) -=1;
L3085:
	return;
}

static void mc_stackmcl_duplpcl() {
    u64 R1, R2, R3, R4; 
	i64 mode;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 0;
	asi64(R3) = mode;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_stackmcl_getworkireg() {
    u64 R1, R2, R3; 
	i64 r;
	i64 av_1;
	R1 = 10;
	av_1 = asi64(R1);
L3092:
	R1 = 1;
	r = asi64(R1);
L3095:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3099;
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3099;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L3091;
L3099:
	r += 1; if (r <= 14) goto L3095;
	mc_stackmcl_savenextopnd();
	if (--asi64(av_1)) goto L3092;
	R1 = tou64("");
	R2 = tou64("No more work regs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3091;
L3091:
	return asi64(R1);
}

static i64 mc_stackmcl_getworkxreg() {
    u64 R1, R2, R3; 
	i64 r;
	R1 = 5;
	r = asi64(R1);
L3101:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3105;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3105;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L3100;
L3105:
	r += 1; if (r <= 16) goto L3101;
	R1 = tou64("");
	R2 = tou64("No more work xregs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3100;
L3100:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkregm(i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R2) = mode;
	asi64(R2) = mc_stackmcl_getworkreg(asi64(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L3106;
L3106:
	return asu64(R1);
}

static i64 mc_stackmcl_getworkreg(i64 mode) {
    u64 R1, R2; 
	i64 reg;
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3109;
	asi64(R1) = mc_stackmcl_getworkxreg();
	goto L3108;
L3109:
	asi64(R1) = mc_stackmcl_getworkireg();
L3108:
	goto L3107;
L3107:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3113;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3112;
L3113:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L3110;
L3112:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3117;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L3116;
L3117:
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3115;
L3116:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L3110;
L3115:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L3110;
L3110:
	return asu64(R1);
}

static void mc_stackmcl_saveopnd(i64 n, i64 allregs) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 mode;
	u64 tx;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3120;
	goto L3118;
L3120:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3122;
	asi64(R1) = allregs;
	if (asi64(R1)) goto L3125;
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L3126;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L3124;
L3126:
L3125:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3124:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3121;
L3122:
	asi64(R1) = allregs;
	if (asi64(R1)) goto L3129;
	asi64(R1) = reg;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3128;
	R2 = 6;
	if (asi64(R1) > asi64(R2)) goto L3128;
L3129:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3128:
	R1 = 0;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3121:
	R1 = 3;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3118:
	return;
}

static void mc_stackmcl_saveopnds(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3133;
L3131:
	R1 = 0;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L3131;
L3133:
	return;
}

static void mc_stackmcl_savenextopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3137;
L3135:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3139;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3139;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L3134;
L3139:
	i += 1; if (i <= mc_decls_noperands) goto L3135;
L3137:
L3134:
	return;
}

static void mc_stackmcl_savenextxopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3143;
L3141:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3145;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3145;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L3140;
L3145:
	i += 1; if (i <= mc_decls_noperands) goto L3141;
L3143:
L3140:
	return;
}

static void mc_stackmcl_movetoreg(i64 newreg) {
    u64 R1, R2, R3; 
	i64 oldreg;
	i64 mode;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
// mc_stackmcl.movetoreg.retry:
L3147:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	oldreg = asi64(R1);
	asi64(R1) = oldreg;
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L3149;
	goto L3146;
L3149:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3151;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3153;
	R1 = tou64("");
	R2 = tou64("MOVE TO REG: XREG IN USE");
	pc_api_merror(asu64(R2), asu64(R1));
L3153:
	goto L3150;
L3151:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3155;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3158;
L3156:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3160;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L3160;
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 6;
	asi64(R2) = newreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asi64(R3) = oldreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L3147;
L3160:
	i += 1; if (i <= mc_decls_noperands) goto L3156;
L3158:
L3155:
L3150:
	asi64(R1) = mode;
	asi64(R2) = oldreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newreg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3162;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3161;
L3162:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3161:
L3146:
	return;
}

static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3165;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3167;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3170;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3169;
L3170:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	goto L3163;
L3169:
L3167:
L3165:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3172;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3172:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3163;
L3163:
	return asu64(R1);
}

static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3175;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3175:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3173;
L3173:
	return asu64(R1);
}

static void mc_stackmcl_swapopnds(i64 m, i64 n) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = m;
	R1 += (i64)R2*8-8;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	R2 += (i64)R3*8-8;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	return;
}

static u64 mc_stackmcl_isimmload(i64 n) {
    u64 R1, R2; 
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3179;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3179;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3179;
	asu64(R1) = p;
	goto L3178;
L3179:
	R1 = 0;
L3178:
	goto L3177;
L3177:
	return asu64(R1);
}

static void mc_stackmcl_setnewzz(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_stackmcl_freeworkregs(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 i;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3184;
L3182:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3186;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3188;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3187;
L3188:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3187:
L3186:
	i += 1; if (i <= mc_decls_noperands) goto L3182;
L3184:
	return;
}

static void mc_stackmcl_swapopndregs(i64 reg2) {
    u64 R1, R2, R3; 
	i64 reg1;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3191;
	R1 = tou64("");
	R2 = tou64("SOR1");
	pc_api_merror(asu64(R2), asu64(R1));
L3191:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg1 = asi64(R1);
	asi64(R1) = reg1;
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L3193;
	goto L3189;
L3193:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3197;
L3194:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3199;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L3199;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	goto L3189;
L3199:
	i += -1; if (i >= 1) goto L3194;
L3197:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg2;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3189:
	return;
}

static u64 mc_stackmcl_makeopndind(u64 a, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3202;
	R1 = tou64("");
	R2 = tou64("makeopndind");
	pc_api_merror(asu64(R2), asu64(R1));
L3202:
	R1 = 0;
	asi64(R2) = mode;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3200;
L3200:
	return asu64(R1);
}

static u64 mc_stackmcl_makesimpleaddr(u64 ax) {
    u64 R1, R2, R3; 
	u64 bx;
	i64 newreg;
	i64 reg;
	i64 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3205;
	R1 = 0;
	reg = asi64(R1);
L3205:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3207;
	R1 = tou64("");
	R2 = tou64("MSA");
	pc_api_merror(asu64(R2), asu64(R1));
L3207:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3209;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3209;
	asi64(R1) = mc_stackmcl_getworkireg();
	newreg = asi64(R1);
	goto L3208;
L3209:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3210;
	asu64(R1) = ax;
	goto L3203;
	goto L3208;
L3210:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3211;
	asi64(R1) = regix;
	newreg = asi64(R1);
	goto L3208;
L3211:
	asi64(R1) = regix;
	newreg = asi64(R1);
L3208:
	R1 = 0;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3203;
L3203:
	return asu64(R1);
}

static void mc_stackmcl_checkallloaded() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3215;
L3213:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3217;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3217;
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = i;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3217:
	i += 1; if (i <= mc_decls_noperands) goto L3213;
L3215:
	return;
}

static u64 mc_stackmcl_stropndstack(i64 indent) {
    u64 R1, R2, R3; 
	struct $B21 str2;
	u64 s;
	u64 t;
	i64 fs;
	i64 i;
	i64 r;
	R1 = (u64)&mc_stackmcl_stropndstack_str;
	s = asu64(R1);
	asi64(R1) = indent;
	if (!asi64(R1)) goto L3220;
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("========================================#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L3219;
L3220:
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3219:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3223;
L3221:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L3227;
	case 2: goto L3228;
	case 3: goto L3229;
	case 4: goto L3230;
	default: goto L3226;
    };
// SWITCH
L3227:
	R1 = tou64("Z:");
	goto L3224;
L3228:
	R1 = tou64("Y:");
	goto L3224;
L3229:
	R1 = tou64("X:");
	goto L3224;
L3230:
	R1 = tou64("W:");
	goto L3224;
L3226:
	R1 = tou64("");
L3224:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3232;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3232;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3233;
	goto L3234;
L3232:
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3236;
	R1 = (u64)&mc_decls_xregnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3235;
L3236:
	R1 = (u64)&mc_decls_regnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3235:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3238;
	R1 = tou64("*");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3238:
	goto L3231;
L3233:
	R1 = tou64("T");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = i;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3231;
L3234:
	R1 = tou64("(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu8(R1) = pc_api_fpshortnames;
	R1 = toi64(tou8(R1));
	fs = asi64(R1);
	R1 = 1;
	pc_api_fpshortnames = asu8(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = fs;
	pc_api_fpshortnames = asu8(R1);
	R1 = tou64(")");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3231:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3240;
	R1 = tou64("@");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3240:
	R1 = tou64("<");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pstdnames;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(">");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = mc_decls_noperands;
	if (asi64(R1) >= asi64(R2)) goto L3242;
	R1 = tou64(", ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3242:
	i += 1; if (i <= mc_decls_noperands) goto L3221;
L3223:
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 50;
	R3 = (u64)&mc_stackmcl_stropndstack_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("WR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
L3243:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3247;
	R1 = tou64("1 ");
	goto L3246;
L3247:
	R1 = tou64("0 ");
L3246:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= 10) goto L3243;
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("XWR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
	asi64(R1) = mc_decls_xregmax;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3250;
L3248:
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3252;
	R1 = tou64("1 ");
	goto L3251;
L3252:
	R1 = tou64("0 ");
L3251:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= mc_decls_xregmax) goto L3248;
L3250:
	R1 = tou64(") hwstack:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_mstackdepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" noperands:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ncalldepth:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_ncalldepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = s;
	goto L3218;
L3218:
	return asu64(R1);
}

static void mc_stackmcl_showopndstack() {
    u64 R1; 
	R1 = 1;
	asu64(R1) = mc_stackmcl_stropndstack(asi64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_optim_peephole() {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 m;
	u64 m2;
	u64 m3;
	i64 lab1;
	i64 lab2;
	asu8(R1) = pc_decls_fpeephole;
	if (asu8(R1)) goto L3256;
	goto L3254;
L3256:
	asu64(R1) = mc_decls_mccode;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L3260;
L3257:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m2 = asu64(R1);
	asu64(R1) = m2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m3 = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3262;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3263;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L3264;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3265;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L3266;
	goto L3267;
L3262:
	goto L3259;
	goto L3261;
L3263:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3269;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3270;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L3271;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L3272;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L3272;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L3273;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L3273;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L3274;
	goto L3275;
L3269:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3277;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3277;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3277;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L3279;
	goto L3278;
L3279:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (asi64(R1)) goto L3281;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3280;
L3281:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3280:
L3278:
	goto L3276;
L3277:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3282;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3282;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L3282;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L3282;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3282;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3282:
L3276:
	goto L3268;
L3270:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3284;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L3285;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3285;
	R1 = 1;
	goto L3286;
L3285:
	R1 = 0;
L3286:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3284;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3284;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3284;
	R1 = 41;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3284:
	goto L3268;
L3271:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3288;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3288;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3288;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3288;
	R1 = 42;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3288:
	goto L3268;
L3272:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3290;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3290;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3290;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isconst(asu64(R1));
	if (!asi64(R1)) goto L3290;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 28;
	if (asi64(R4) != asi64(R5)) goto L3292;
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	goto L3291;
L3292:
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	asi64(R4) = -asi64(R4);
L3291:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3290:
	goto L3268;
L3273:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3294;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3294;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3294;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 52;
	if (asi64(R4) != asi64(R5)) goto L3296;
	R4 = 1;
	goto L3295;
L3296:
	R4 = -1;
L3295:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3294:
	goto L3268;
L3274:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3298;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3298;
	R1 = 25;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3298:
	goto L3268;
L3275:
L3268:
	goto L3261;
L3264:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L3300;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3302;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L3303;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3303;
	R1 = 1;
	goto L3304;
L3303:
	R1 = 0;
L3304:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3302;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3302;
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3302:
L3300:
	goto L3261;
L3265:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3306;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3308;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3308;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3308;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3308;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3308;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = m;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3308:
L3306:
	goto L3261;
L3266:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L3310;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L3310;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = m3;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L3310;
	asu64(R1) = m;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3310;
	R1 = (u64)&mc_decls_asmrevcond;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = m;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3310:
	goto L3261;
L3267:
L3261:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3260:
	asu64(R1) = m;
	if (asu64(R1)) goto L3257;
L3259:
L3254:
	return;
}

static i64 mc_optim_isreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3311;
L3311:
	return asi64(R1);
}

static i64 mc_optim_isreg0(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3314;
	R1 = 0;
	goto L3312;
L3314:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3316;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3316;
	R1 = 1;
	goto L3312;
L3316:
	R1 = 0;
	goto L3312;
L3312:
	return asi64(R1);
}

static i64 mc_optim_isreg10(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3319;
	R1 = 0;
	goto L3317;
L3319:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3321;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3321;
	R1 = 1;
	goto L3317;
L3321:
	R1 = 0;
	goto L3317;
L3317:
	return asi64(R1);
}

static i64 mc_optim_isreg00(u64 m) {
    u64 R1, R2, R3; 
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3324;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3324;
	R1 = 1;
	goto L3322;
L3324:
	R1 = 0;
	goto L3322;
L3322:
	return asi64(R1);
}

static i64 mc_optim_isconst(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3327;
	R1 = 0;
	goto L3325;
L3327:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3329;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3329;
	R1 = 1;
	goto L3325;
L3329:
	R1 = 0;
	goto L3325;
L3325:
	return asi64(R1);
}

static i64 mc_optim_sameoperand(u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 16;
	asu64(R2) = b;
	asu64(R3) = a;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3330;
L3330:
	return asi64(R1);
}

static i64 mc_optim_sameregopnd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3334;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3333;
L3334:
	R1 = 0;
	goto L3331;
L3333:
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3331;
L3331:
	return asi64(R1);
}

static u64 mc_optim_deletemcl(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3338;
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3337;
L3338:
	R1 = tou64("");
	R2 = tou64("delmcl?");
	pc_api_merror(asu64(R2), asu64(R1));
L3337:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	goto L3335;
L3335:
	return asu64(R1);
}

static i64 mc_optim_endr0(u64 m) {
    u64 R1, R2; 
	asu64(R1) = m;
	R2 = 48;
	R1 += (i64)R2;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L3339;
L3339:
	return asi64(R1);
}

static void mc_genss_genss(i64 obj) {
    u64 R1, R2, R3; 
	i64 index;
	u64 m;
	u64 pr;
	u64 codeaddr;
	u64 offsetptr;
	asu8(R1) = pc_decls_ssdone;
	if (!asu8(R1)) goto L3342;
	goto L3340;
L3342:
	asi64(R1) = mwindows_os_clock();
	pc_decls_sstime = asi64(R1);
	asi64(R1) = pc_api_mlabelno;
	mc_genss_initlib(asi64(R1));
	R1 = 0;
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_zdata = asu64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_idata = asu64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_code = asu64(R1);
	R1 = 0;
	mc_decls_ss_idatarelocs = asu64(R1);
	R1 = 0;
	mc_decls_ss_coderelocs = asu64(R1);
	R1 = 0;
	mc_decls_ss_nsymbols = asi64(R1);
	R1 = 1;
	mc_genss_switchseg(asi64(R1));
	R1 = 9999;
	mc_decls_aaseqno = asi64(R1);
	R1 = 0;
	mc_genss_extraparam = asu64(R1);
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 0;
	index = asi64(R1);
	goto L3344;
L3343:
	R1 = (u64)&index;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	mc_genss_doinstr(asu64(R2), asi64(R1));
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3344:
	asu64(R1) = m;
	if (asu64(R1)) goto L3343;
	R1 = 0;
	mc_genss_switchseg(asi64(R1));
	asu64(R1) = mc_decls_ss_zdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	if (!asi64(R1)) goto L3347;
	R1 = tou64("Zdata contains code or data");
	mc_libmcl_axerror(asu64(R1));
L3347:
	asi64(R1) = obj;
	if (!asi64(R1)) goto L3349;
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codeaddr = asu64(R1);
	asu64(R1) = mc_decls_riplist;
	pr = asu64(R1);
	goto L3353;
L3350:
	asu64(R1) = codeaddr;
	asu64(R2) = pr;
	R3 = 8;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	offsetptr = asu64(R1);
	asu64(R1) = pr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offsetptr;
	*tou32p(R2) -= asu32(R1);
	asu64(R1) = pr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pr = asu64(R1);
L3353:
	asu64(R1) = pr;
	if (asu64(R1)) goto L3350;
L3349:
	R1 = 1;
	pc_decls_ssdone = asu8(R1);
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = pc_decls_sstime;
	asi64(R1) -= asi64(R2);
	pc_decls_sstime = asi64(R1);
L3340:
	return;
}

static void mc_genss_doinstr(u64 m, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	u64 d;
	u64 e;
	i64 x;
	i64 offset;
	i64 shortjmp;
	i64 n;
	i64 av_1;
	i64 av_2;
	asu64(R1) = mc_genss_currdata;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1024;
	if (asi64(R1) >= asi64(R2)) goto L3356;
	asu64(R1) = mc_genss_currdata;
	mc_genss_bufferexpand(asu64(R1));
L3356:
	R1 = 0;
	R2 = R1;
	mc_genss_usesizeb = asu8(R2);
	R2 = R1;
	mc_genss_nowmask = asu8(R2);
	R2 = R1;
	mc_genss_f3override = asu8(R2);
	R2 = R1;
	mc_genss_f2override = asu8(R2);
	R2 = R1;
	mc_genss_addroverride = asu8(R2);
	R2 = R1;
	mc_genss_sizeoverride = asu8(R2);
	mc_genss_rex = asu8(R1);
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = m;
	R2 = 36;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	mc_decls_aaseqno = asi64(R1);
	R1 = 0;
	mc_genss_ripentry = asu64(R1);
	asu64(R1) = m;
	mc_genss_currmcl = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L3360;
	case 2: goto L3361;
	case 3: case 8: goto L3483;
	case 4: goto L3364;
	case 5: goto L3362;
	case 6: goto L3363;
	case 7: case 23: case 35: case 92: case 93: case 150: goto L3359;
	case 9: goto L3371;
	case 10: case 151: goto L3392;
	case 11: goto L3406;
	case 12: goto L3401;
	case 13: goto L3402;
	case 14: goto L3407;
	case 15: goto L3465;
	case 16: goto L3449;
	case 17: goto L3450;
	case 18: goto L3408;
	case 19: goto L3409;
	case 20: goto L3410;
	case 21: goto L3376;
	case 22: goto L3397;
	case 24: goto L3398;
	case 25: goto L3377;
	case 26: goto L3378;
	case 27: goto L3411;
	case 28: case 29: case 30: case 31: case 38: case 39: case 40: case 42: goto L3405;
	case 32: case 33: case 36: case 37: case 50: case 51: goto L3404;
	case 34: goto L3412;
	case 41: goto L3443;
	case 43: case 44: case 45: case 46: case 47: case 48: case 49: goto L3442;
	case 52: case 53: goto L3403;
	case 54: goto L3393;
	case 55: goto L3394;
	case 56: goto L3395;
	case 57: goto L3396;
	case 58: goto L3448;
	case 59: case 60: goto L3479;
	case 61: case 62: goto L3482;
	case 63: case 65: case 67: case 69: case 71: case 112: case 113: goto L3451;
	case 64: case 66: case 68: case 70: case 72: case 114: case 115: goto L3452;
	case 73: goto L3455;
	case 74: case 75: goto L3456;
	case 76: case 78: goto L3453;
	case 77: case 79: case 80: case 81: goto L3454;
	case 82: goto L3459;
	case 83: goto L3460;
	case 84: goto L3461;
	case 85: goto L3462;
	case 86: goto L3463;
	case 87: goto L3464;
	case 88: goto L3458;
	case 89: goto L3457;
	case 90: case 91: goto L3475;
	case 94: case 95: case 96: goto L3467;
	case 97: case 98: case 99: goto L3468;
	case 100: case 101: case 102: case 103: goto L3469;
	case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: goto L3466;
	case 116: goto L3385;
	case 117: goto L3386;
	case 118: goto L3387;
	case 119: goto L3388;
	case 120: goto L3390;
	case 121: goto L3391;
	case 122: goto L3389;
	case 123: goto L3426;
	case 124: case 125: case 126: case 127: goto L3413;
	case 128: goto L3447;
	case 129: case 130: case 131: goto L3444;
	case 132: goto L3445;
	case 133: goto L3446;
	case 134: goto L3470;
	case 135: goto L3471;
	case 136: goto L3472;
	case 137: goto L3473;
	case 138: goto L3474;
	case 139: goto L3478;
	case 140: goto L3481;
	case 141: goto L3476;
	case 142: case 143: case 144: case 145: case 146: case 147: case 148: goto L3477;
	case 149: goto L3480;
	default: goto L3359;
    };
// SWITCH
L3360:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	goto L3357;
L3361:
	goto L3357;
L3362:
	goto L3357;
L3363:
	goto L3357;
L3364:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3366;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3367;
	goto L3368;
L3366:
	goto L3365;
L3367:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 2;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mc_genss_currseg;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3370;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
L3370:
	asu64(R1) = d;
	mc_genss_dofwdrefs(asu64(R1));
	goto L3365;
L3368:
L3365:
	goto L3357;
L3371:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3373;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L3372;
L3373:
	asu64(R1) = mc_decls_labeldeftable;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
L3372:
	R1 = 2;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mc_genss_currseg;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3375;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
L3375:
	asu64(R1) = d;
	mc_genss_dofwdrefs(asu64(R1));
	goto L3357;
L3376:
	asu64(R1) = a;
	mc_genss_do_call(asu64(R1));
	goto L3357;
L3377:
	asu64(R1) = m;
	asu64(R2) = a;
	mc_genss_do_jmp(asu64(R2), asu64(R1));
	goto L3357;
L3378:
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 7;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3380;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3382;
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	R2 = 4;
	asi64(R1) -= asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3381;
L3382:
	R1 = 112;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3381:
	goto L3379;
L3380:
	asu64(R1) = d;
	asu64(R2) = m;
	asi64(R1) = mc_genss_checkshortjump(asu64(R2), asu64(R1));
	shortjmp = asi64(R1);
	asi64(R1) = shortjmp;
	if (asi64(R1)) goto L3384;
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3383;
L3384:
	R1 = 112;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel8(asu64(R1));
L3383:
L3379:
	goto L3357;
L3385:
	R1 = 1;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3357;
L3386:
	R1 = 2;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3357;
L3387:
	R1 = 4;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3357;
L3388:
	R1 = 8;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3357;
L3389:
	R1 = 1;
	mc_genss_switchseg(asi64(R1));
	goto L3357;
L3390:
	R1 = 2;
	mc_genss_switchseg(asi64(R1));
	goto L3357;
L3391:
	R1 = 3;
	mc_genss_switchseg(asi64(R1));
	goto L3357;
L3392:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3393:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 152;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3394:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3395:
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3396:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3397:
	R1 = 195;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3398:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3400;
	R1 = tou64("retn?");
	mc_libmcl_axerror(asu64(R1));
L3400:
	R1 = 194;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genword(asi64(R1));
	goto L3357;
L3401:
	asu64(R1) = a;
	mc_genss_do_push(asu64(R1));
	goto L3357;
L3402:
	asu64(R1) = a;
	mc_genss_do_pop(asu64(R1));
	goto L3357;
L3403:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_inc(asu64(R2), asi64(R1));
	goto L3357;
L3404:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_neg(asu64(R2), asi64(R1));
	goto L3357;
L3405:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_arith(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3406:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_mov(asu64(R2), asu64(R1));
	goto L3357;
L3407:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_lea(asu64(R2), asu64(R1));
	goto L3357;
L3408:
	R1 = 190;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movsx(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3409:
	R1 = 182;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movsx(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3410:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_movsxd(asu64(R2), asu64(R1));
	goto L3357;
L3411:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_exch(asu64(R2), asu64(R1));
	goto L3357;
L3412:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_imul2(asu64(R2), asu64(R1));
	goto L3357;
L3413:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3415;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	n = asi64(R1);
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3417;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3418;
	goto L3419;
L3417:
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3422;
L3420:
	R1 = 144;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L3420;
L3422:
	goto L3416;
L3418:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3425;
L3423:
	R1 = 0;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_2)) goto L3423;
L3425:
	goto L3416;
L3419:
	asi64(R1) = n;
	R2 = (u64)&mc_decls_ss_zdatalen;
	*toi64p(R2) += asi64(R1);
L3416:
	goto L3414;
L3415:
	R1 = tou64("resb?");
	mc_libmcl_axerror(asu64(R1));
L3414:
	goto L3357;
L3426:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3428;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	asi64(R1) = x;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3431;
	asi64(R1) = x;
	R2 = 16384;
	if (asi64(R1) <= asi64(R2)) goto L3430;
L3431:
	R1 = tou64("align2");
	mc_libmcl_axerror(asu64(R1));
L3430:
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = mc_genss_currseg;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3433;
	goto L3435;
L3434:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3438;
	R1 = 144;
	goto L3437;
L3438:
	R1 = 0;
L3437:
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3435:
	asu64(R1) = mc_genss_currdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	asi64(R2) = x;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L3434;
	goto L3432;
L3433:
	goto L3440;
L3439:
	R1 = (u64)&mc_decls_ss_zdatalen;
	(*toi64p(R1)) += 1;
L3440:
	asi64(R1) = mc_decls_ss_zdatalen;
	asi64(R2) = x;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L3439;
L3432:
	goto L3427;
L3428:
	R1 = tou64("align?");
	mc_libmcl_axerror(asu64(R1));
L3427:
	goto L3357;
L3442:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_shift(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3443:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_test(asu64(R2), asu64(R1));
	goto L3357;
L3444:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_loop(asu64(R2), asi64(R1));
	goto L3357;
L3445:
	R1 = 4;
	asu64(R2) = a;
	mc_genss_do_jcxz(asu64(R2), asi64(R1));
	goto L3357;
L3446:
	R1 = 8;
	asu64(R2) = a;
	mc_genss_do_jcxz(asu64(R2), asi64(R1));
	goto L3357;
L3447:
	R1 = 215;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3448:
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_genss_do_setcc(asi64(R2), asu64(R1));
	goto L3357;
L3449:
	R1 = 4;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movxmm(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3450:
	R1 = 8;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movxmm(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3451:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3452:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3453:
	R1 = 4;
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_logicxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3454:
	R1 = 8;
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_logicxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3455:
	R1 = 47;
	R2 = 0;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3456:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 102;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3457:
	R1 = 243;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_convertfloat(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3458:
	R1 = 242;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_convertfloat(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3459:
	R1 = 45;
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3460:
	R1 = 45;
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3461:
	R1 = 44;
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3462:
	R1 = 44;
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3463:
	R1 = 243;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_float(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3464:
	R1 = 242;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_float(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3465:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = m;
	R4 = 34;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_genss_do_cmovcc(asi64(R3), asu64(R2), asu64(R1));
	goto L3357;
L3466:
	R1 = 217;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3467:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asu64(R3) = a;
	mc_genss_do_fmem(asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3468:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R3) = a;
	mc_genss_do_fmem(asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3469:
	R1 = 222;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3470:
	R1 = 166;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3471:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3472:
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3473:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3474:
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3475:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movdqx(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3476:
	R1 = 219;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 227;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3477:
	R1 = 217;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3478:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_popcnt(asu64(R2), asu64(R1));
	goto L3357;
L3479:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_bsf(asu64(R3), asu64(R2), asi64(R1));
	goto L3357;
L3480:
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 162;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3357;
L3481:
	asu64(R1) = a;
	mc_genss_do_bswap(asu64(R1));
	goto L3357;
L3482:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = m;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_dshift(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3357;
L3483:
	goto L3357;
L3359:
	msysc_m$print_startcon();
	R1 = tou64("*** Can't do opcode");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mc_decls_mclnames;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M.OPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M_HALT=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 151;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("STOPPING");
	mc_libmcl_axerror(asu64(R1));
L3357:
	return;
}

static void mc_genss_start() {
    u64 R1, R2, R3; 
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genss_genword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_addword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_gendword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_adddword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_genqword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_addqword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_genopnd(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 s;
	i64 x;
	i64 length;
	r32 x32;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3490;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	size = asi64(R1);
L3490:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3492;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L3493;
	goto L3494;
L3492:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 100;
	if (asi64(R1) <= asi64(R2)) goto L3496;
	R1 = 1024;
	asi64(R2) = length;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = mc_genss_currdata;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
L3496:
	goto L3498;
L3497:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3498:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L3497;
	goto L3488;
	goto L3491;
L3493:
	msysc_m$print_startcon();
	R1 = tou64("GENSS/NAME OPND");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3491;
L3494:
L3491:
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3501;
	asi64(R1) = size;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3501;
	R1 = tou64("8/16-BIT RELOC");
	mc_libmcl_axerror(asu64(R1));
L3501:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3503;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3504;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3505;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3506;
	goto L3507;
L3503:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3502;
L3504:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genword(asi64(R1));
	goto L3502;
L3505:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3509;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3510;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3511;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3511;
	goto L3512;
L3509:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3508;
L3510:
	asu64(R1) = a;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	x32 = asr32(R1);
	asr32(R1) = x32;
	asi64(R1) = asi64(R1);
	mc_genss_gendword(asi64(R1));
	goto L3508;
L3511:
	asu64(R1) = a;
	mc_genss_genabs32(asu64(R1));
	goto L3508;
L3512:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("OPND/4/VALTYPE?");
	mc_libmcl_axerror(asu64(R1));
L3508:
	goto L3502;
L3506:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3514;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3515;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3516;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3516;
	goto L3517;
L3514:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genqword(asi64(R1));
	goto L3513;
L3515:
	asu64(R1) = a;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	mc_genss_genqword(asi64(R1));
	goto L3513;
L3516:
	asu64(R1) = a;
	mc_genss_genabs64(asu64(R1));
	goto L3513;
L3517:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("OPND/8/VALTYPE?");
	mc_libmcl_axerror(asu64(R1));
L3513:
	goto L3502;
L3507:
L3502:
L3488:
	return;
}

static void mc_genss_addrelocitem(i64 reloctype, u64 d) {
    u64 R1, R2, R3; 
	u64 r;
	i64 stindex;
	i64 adjust;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
	stindex = asi64(R1);
	R1 = 4;
	adjust = asi64(R1);
	asi64(R1) = reloctype;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3520;
	R1 = 8;
	adjust = asi64(R1);
L3520:
	R1 = 32;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	r = asu64(R1);
	asu64(R1) = mc_genss_currrelocs;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = reloctype;
	asu64(R2) = r;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asi64(R2) = adjust;
	asi64(R1) -= asi64(R2);
	asu64(R2) = r;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = stindex;
	asu64(R2) = r;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_genss_nrelocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	mc_genss_currrelocs = asu64(R1);
	return;
}

static i64 mc_genss_getstindex(u64 d) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = d;
	R2 = 96;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3523;
	asi64(R1) = mc_decls_ss_nsymbols;
	asi64(R2) = mc_decls_ss_symboltablesize;
	if (asi64(R1) < asi64(R2)) goto L3525;
	mc_genss_extendsymboltable();
L3525:
	R1 = (u64)&mc_decls_ss_nsymbols;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 96;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = d;
	asu64(R2) = mc_decls_ss_symboltable;
	asu64(R3) = d;
	R4 = 96;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3527;
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3529;
	R1 = 1;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3529:
L3527:
L3523:
	asu64(R1) = d;
	R2 = 96;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L3521;
L3521:
	return asi64(R1);
}

static void mc_genss_genrel32(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3532;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3530;
L3532:
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3534;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3535;
	goto L3536;
L3534:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) == asi64(R2)) goto L3538;
	R1 = tou64("Rel label across segments");
	mc_libmcl_axerror(asu64(R1));
L3538:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R2) = mc_genss_getcurrdatalen(asi64(R2));
	R3 = 4;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3533;
L3535:
	R1 = 0;
	R2 = 4;
	R3 = 3;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	goto L3533;
L3536:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 4;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3533:
L3530:
	return;
}

static u64 mc_genss_getdef(u64 a, i64 dneeded) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3542;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3541;
L3542:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3544;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3545;
	goto L3546;
L3544:
	asu64(R1) = mc_decls_labeldeftable;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L3539;
	goto L3543;
L3545:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3548;
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3550;
	R1 = 1;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3550:
L3548:
	asu64(R1) = d;
	goto L3539;
	goto L3543;
L3546:
L3543:
L3541:
	asi64(R1) = dneeded;
	if (!asi64(R1)) goto L3552;
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("getdef/no def");
	mc_libmcl_axerror(asu64(R1));
L3552:
	R1 = 0;
	goto L3539;
L3539:
	return asu64(R1);
}

static void mc_genss_genabs32(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3555;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3556;
	goto L3557;
L3555:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
	goto L3554;
L3556:
	asi64(R1) = mc_genss_currseg;
	R2 = 2;
	R3 = 4;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3560;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3559;
L3560:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3558;
L3559:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3558:
	goto L3554;
L3557:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3554:
	return;
}

static void mc_genss_genabs64(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3563;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3564;
	goto L3565;
L3563:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
	goto L3562;
L3564:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	R3 = 5;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3568;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3567;
L3568:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_genqword(asi64(R1));
	goto L3566;
L3567:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3566:
	goto L3562;
L3565:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3562:
	return;
}

static i64 mc_genss_getrel32(u64 d, i64 offset) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3571;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) == asi64(R2)) goto L3573;
	R1 = tou64("Rel label across segments2");
	mc_libmcl_axerror(asu64(R1));
L3573:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	goto L3570;
L3571:
	R1 = 2147483647;
L3570:
	goto L3569;
L3569:
	return asi64(R1);
}

static void mc_genss_dofwdrefs(u64 d) {
    u64 R1, R2, R3; 
	u64 f;
	i64 offset;
	i64 seg;
	u64 p8;
	u64 p32;
	u64 p64;
	u64 data;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3576;
	goto L3574;
L3576:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L3578;
L3577:
	asu64(R1) = f;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	asu64(R1) = f;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3581;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3582;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3582;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3583;
	goto L3584;
L3581:
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p32 = asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = 4;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p32;
	*toi32p(R2) = asi32(R1);
	goto L3580;
L3582:
	asu64(R1) = f;
	R2 = 14;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3586;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3587;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3588;
	goto L3589;
L3586:
	asu64(R1) = mc_decls_ss_code;
	data = asu64(R1);
	goto L3585;
L3587:
	R1 = tou64("Fwd ref in zdata");
	mc_libmcl_axerror(asu64(R1));
	goto L3585;
L3588:
	asu64(R1) = mc_decls_ss_idata;
	data = asu64(R1);
	goto L3585;
L3589:
L3585:
	asi64(R1) = offset;
	asu64(R2) = data;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p32 = asu64(R1);
	asu64(R1) = f;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3591;
	asu64(R1) = p32;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = p32;
	*toi32p(R2) = asi32(R1);
	goto L3590;
L3591:
	asu64(R1) = p32;
	p64 = asu64(R1);
	asu64(R1) = p64;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = p64;
	*toi64p(R2) = asi64(R1);
L3590:
	goto L3580;
L3583:
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p8 = asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p8;
	*tou8p(R2) = asu8(R1);
	goto L3580;
L3584:
	msysc_m$print_startcon();
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = f;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("DOFWDREFS/CAN'T DO RELTYPE");
	mc_libmcl_axerror(asu64(R1));
L3580:
	asu64(R1) = f;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
L3578:
	asu64(R1) = f;
	if (asu64(R1)) goto L3577;
L3574:
	return;
}

static void mc_genss_genrex() {
    u64 R1, R2, R3; 
	asu8(R1) = mc_genss_f2override;
	if (!asu8(R1)) goto L3594;
	R1 = 242;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3594:
	asu8(R1) = mc_genss_f3override;
	if (!asu8(R1)) goto L3596;
	R1 = 243;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3596:
	asu8(R1) = mc_genss_sizeoverride;
	if (!asu8(R1)) goto L3598;
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3598:
	asu8(R1) = mc_genss_addroverride;
	if (!asu8(R1)) goto L3600;
	R1 = 103;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3600:
	asu8(R1) = mc_genss_nowmask;
	if (!asu8(R1)) goto L3602;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L3602:
	asu8(R1) = mc_genss_rex;
	if (!asu8(R1)) goto L3604;
	asu8(R1) = mc_genss_rex;
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = 64;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3604:
	return;
}

static i64 mc_genss_isbytesized(i64 x) {
    u64 R1, R2; 
	R1 = -128;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3606;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3606;
	R1 = 1;
	goto L3607;
L3606:
	R1 = 0;
L3607:
	goto L3605;
L3605:
	return asi64(R1);
}

static i64 mc_genss_isdwordsized(i64 x) {
    u64 R1, R2; 
	R1 = -2147483648;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3609;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L3609;
	R1 = 1;
	goto L3610;
L3609:
	R1 = 0;
L3610:
	goto L3608;
L3608:
	return asi64(R1);
}

static void mc_genss_genamode(u64 a, u64 am) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 pr;
	R1 = (u64)&am;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&am;
	R2 = 2;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3613;
	R1 = (u64)&am;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3613:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3615;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3616;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3617;
	goto L3618;
L3615:
	goto L3614;
L3616:
	R1 = (u64)&am;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3614;
L3617:
	R1 = (u64)&am;
	R2 = 2;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L3620;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pr = asu64(R1);
	asu64(R1) = mc_decls_riplist;
	asu64(R2) = pr;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_genss_currdata;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pr;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pr;
	R2 = R1;
	mc_decls_riplist = asu64(R2);
	mc_genss_ripentry = asu64(R1);
L3620:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3622;
	goto L3623;
L3622:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3625;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3625;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3626;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3626;
	goto L3627;
L3625:
	asu64(R1) = a;
	mc_genss_genabs32(asu64(R1));
	goto L3624;
L3626:
	R1 = (u64)&am;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	goto L3624;
L3627:
	R1 = tou64("genam/3");
	mc_libmcl_axerror(asu64(R1));
L3624:
	goto L3621;
L3623:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("GENAMODE/MODE?");
	mc_libmcl_axerror(asu64(R1));
L3621:
	goto L3614;
L3618:
	R1 = tou64("genamode size 2/8");
	mc_libmcl_axerror(asu64(R1));
L3614:
	return;
}

static void mc_genss_setopsize(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3630;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3631;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3632;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3633;
	goto L3634;
L3630:
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	goto L3629;
L3631:
	goto L3629;
L3632:
	goto L3629;
L3633:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	goto L3629;
L3634:
	R1 = tou64("Operand size not set");
	mc_libmcl_axerror(asu64(R1));
L3629:
	return;
}

static i64 mc_genss_getdispsize(u64 a, u64 offset) {
    u64 R1, R2; 
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L3637;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3640;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3639;
L3640:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offset;
	*toi32p(R2) += asi32(R1);
	goto L3638;
L3639:
	R1 = 4;
	goto L3635;
L3638:
L3637:
	asu64(R1) = offset;
	asi32(R1) = *toi32p(R1);
	if (!asi32(R1)) goto L3642;
	asu64(R1) = offset;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_genss_isbytesized(asi64(R1));
	if (!asi64(R1)) goto L3644;
	R1 = 1;
	goto L3643;
L3644:
	R1 = 4;
L3643:
	goto L3641;
L3642:
	R1 = 0;
L3641:
	goto L3635;
L3635:
	return asi64(R1);
}

static void mc_genss_checkhighreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3647;
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3647:
	return;
}

static void mc_genss_do_loop(u64 a, i64 opc) {
    u64 R1, R2, R3; 
	i64 offset;
	R1 = 9;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asu64(R3) = a;
	asu64(R2) = mc_genss_getdef(asu64(R3), asi64(R2));
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3650;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3652;
	R1 = tou64("loop jmp out of range");
	mc_libmcl_axerror(asu64(R1));
L3652:
	asi64(R1) = opc;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3649;
L3650:
	R1 = tou64("Can't do loopxx fwd jump");
	mc_libmcl_axerror(asu64(R1));
L3649:
	return;
}

static void mc_genss_do_jcxz(u64 a, i64 opsize) {
    u64 R1, R2, R3; 
	i64 offset;
	R1 = 10;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asu64(R3) = a;
	asu64(R2) = mc_genss_getdef(asu64(R3), asi64(R2));
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3655;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3657;
	R1 = tou64("jcxz jmp out of range");
	mc_libmcl_axerror(asu64(R1));
L3657:
	asi64(R1) = opsize;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3659;
	R1 = 103;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3659:
	R1 = 227;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3654;
L3655:
	R1 = tou64("Can't do jcxz fwd jump");
	mc_libmcl_axerror(asu64(R1));
L3654:
	return;
}

static void mc_genss_do_call(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3662;
	goto L3663;
L3662:
	R1 = 232;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3661;
L3663:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3665;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3666;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3666;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3666;
	goto L3667;
L3665:
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L3664;
L3666:
	R1 = tou64("call[]size");
	mc_libmcl_axerror(asu64(R1));
	goto L3664;
L3667:
L3664:
	asu64(R1) = a;
	R2 = 2;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
L3661:
	return;
}

static void mc_genss_do_jmp(u64 a, u64 m) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	i64 offset;
	i64 shortjmp;
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3670;
	goto L3671;
L3670:
	R1 = 11;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3673;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) <= asi64(R2)) goto L3673;
	R1 = 235;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3672;
L3673:
	R1 = 0;
	shortjmp = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3675;
	asu64(R1) = d;
	asu64(R2) = m;
	asi64(R1) = mc_genss_checkshortjump(asu64(R2), asu64(R1));
	shortjmp = asi64(R1);
L3675:
	asi64(R1) = shortjmp;
	if (asi64(R1)) goto L3677;
	R1 = 233;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3676;
L3677:
	R1 = 235;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel8(asu64(R1));
L3676:
L3672:
	goto L3669;
L3671:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3679;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3680;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3680;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3680;
	goto L3681;
L3679:
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L3678;
L3680:
	R1 = tou64("jmp[]size");
	mc_libmcl_axerror(asu64(R1));
	goto L3678;
L3681:
L3678:
	asu64(R1) = a;
	R2 = 4;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
L3669:
	return;
}

static i64 mc_genss_getcurrdatalen(i64 id) {
    u64 R1, R2; 
	asi64(R1) = mc_genss_currseg;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3684;
	asi64(R1) = mc_decls_ss_zdatalen;
	goto L3682;
L3684:
	asu64(R1) = mc_genss_currdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	goto L3682;
L3682:
	return asi64(R1);
}

static void mc_genss_do_cmovcc(i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3687;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3687;
	R1 = tou64("1:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3687:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3689;
	R1 = tou64("cmov/byte");
	mc_libmcl_axerror(asu64(R1));
L3689:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3904;
	asi64(R4) = cond;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_fmem(u64 a, i64 freal, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	i64 am;
	i64 regcode;
	i64 mf;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3692;
	R1 = tou64("fmem/not mem");
	mc_libmcl_axerror(asu64(R1));
L3692:
	asi64(R1) = freal;
	if (!asi64(R1)) goto L3694;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3696;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3697;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3698;
	R2 = 16;
	if (asu64(R1) == asu64(R2)) goto L3698;
	goto L3699;
L3696:
	R1 = 0;
	mf = asi64(R1);
	goto L3695;
L3697:
	R1 = 2;
	mf = asi64(R1);
	goto L3695;
L3698:
	R1 = 1;
	mf = asi64(R1);
	asi64(R1) = code;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3701;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3702;
	goto L3703;
L3701:
	R1 = 5;
	code = asi64(R1);
	goto L3700;
L3702:
	R1 = 7;
	code = asi64(R1);
	goto L3700;
L3703:
	R1 = tou64("r80 not allowed");
	mc_libmcl_axerror(asu64(R1));
L3700:
	goto L3695;
L3699:
	msysc_m$print_startcon();
	R1 = tou64("SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("fmem size");
	mc_libmcl_axerror(asu64(R1));
L3695:
	goto L3693;
L3694:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3705;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3706;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3707;
	goto L3708;
L3705:
	R1 = 3;
	mf = asi64(R1);
	goto L3704;
L3706:
	R1 = 1;
	mf = asi64(R1);
	goto L3704;
L3707:
	R1 = 3;
	mf = asi64(R1);
	asi64(R1) = code;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3710;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3711;
	goto L3712;
L3710:
	R1 = 5;
	code = asi64(R1);
	goto L3709;
L3711:
	R1 = 7;
	code = asi64(R1);
	goto L3709;
L3712:
	R1 = tou64("fst i64?");
	mc_libmcl_axerror(asu64(R1));
L3709:
	goto L3704;
L3708:
	R1 = tou64("fmem int size");
	mc_libmcl_axerror(asu64(R1));
L3704:
L3693:
	asu64(R1) = a;
	asi64(R2) = code;
	R3 = 217;
	asi64(R4) = mf;
	R5 = 1;
	asi64(R4) <<= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void mc_genss_genrel8(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3715;
	R1 = 0;
	R2 = 6;
	R3 = 3;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3714;
L3715:
	R1 = tou64("genrel8");
	mc_libmcl_axerror(asu64(R1));
L3714:
	return;
}

static i64 mc_genss_checkshortjump(u64 m, u64 d) {
    u64 R1, R2, R3; 
	i64 n;
	u64 a;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L3718;
L3717:
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3721;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3722;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3722;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L3723;
	goto L3724;
L3721:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3726;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3727;
	goto L3728;
L3726:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 100;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L3730;
	R1 = 1;
	goto L3716;
L3730:
	goto L3725;
L3727:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L3732;
	R1 = 1;
	goto L3716;
L3732:
	goto L3725;
L3728:
L3725:
	goto L3720;
L3722:
	goto L3720;
L3723:
	R1 = 0;
	goto L3716;
	goto L3720;
L3724:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L3720:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3718:
	asu64(R1) = m;
	if (!asu64(R1)) goto L3733;
	asi64(R1) = n;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L3717;
L3733:
	R1 = 0;
	goto L3716;
L3716:
	return asi64(R1);
}

static u64 mc_genss_addfwdref(u64 p, i64 offset, i64 reltype, i64 seg) {
    u64 R1, R2, R3; 
	u64 q;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = q;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = reltype;
	asu64(R2) = q;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = seg;
	asu64(R2) = q;
	R3 = 14;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	goto L3734;
L3734:
	return asu64(R1);
}

static void mc_genss_switchseg(i64 newseg) {
    u64 R1, R2; 
	asi64(R1) = newseg;
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) != asi64(R2)) goto L3737;
	goto L3735;
L3737:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3739;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3740;
	goto L3741;
L3739:
	asu64(R1) = mc_genss_currrelocs;
	mc_decls_ss_coderelocs = asu64(R1);
	asi64(R1) = mc_genss_nrelocs;
	mc_decls_ss_ncoderelocs = asi64(R1);
	goto L3738;
L3740:
	asu64(R1) = mc_genss_currrelocs;
	mc_decls_ss_idatarelocs = asu64(R1);
	asi64(R1) = mc_genss_nrelocs;
	mc_decls_ss_nidatarelocs = asi64(R1);
	goto L3738;
L3741:
L3738:
	asi64(R1) = newseg;
	mc_genss_currseg = asi64(R1);
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3743;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3744;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3745;
	goto L3746;
L3743:
	asu64(R1) = mc_decls_ss_code;
	mc_genss_currdata = asu64(R1);
	asu64(R1) = mc_decls_ss_coderelocs;
	mc_genss_currrelocs = asu64(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	mc_genss_nrelocs = asi64(R1);
	goto L3742;
L3744:
	asu64(R1) = mc_decls_ss_idata;
	mc_genss_currdata = asu64(R1);
	asu64(R1) = mc_decls_ss_idatarelocs;
	mc_genss_currrelocs = asu64(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	mc_genss_nrelocs = asi64(R1);
	goto L3742;
L3745:
	asu64(R1) = mc_decls_ss_zdata;
	mc_genss_currdata = asu64(R1);
	goto L3742;
L3746:
L3742:
L3735:
	return;
}

static void mc_genss_do_popcnt(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3749;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3751;
	R1 = 8;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3751:
L3749:
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 4024;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_bsf(u64 a, u64 b, i64 opc) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3754;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3756;
	R1 = 8;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3756:
L3754:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3758;
	R1 = tou64("bsf size");
	mc_libmcl_axerror(asu64(R1));
L3758:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_extendsymboltable() {
    u64 R1, R2, R3; 
	u64 oldsymboltable;
	i64 oldsymboltablesize;
	i64 i;
	asi64(R1) = mc_decls_ss_symboltablesize;
	oldsymboltablesize = asi64(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	oldsymboltable = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_ss_symboltablesize;
	*toi64p(R2) *= asi64(R1);
	R1 = 8;
	asi64(R2) = mc_decls_ss_symboltablesize;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_ss_symboltable = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3762;
L3760:
	asu64(R1) = oldsymboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = mc_decls_ss_symboltable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L3760;
L3762:
	R1 = 8;
	asi64(R2) = oldsymboltablesize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = oldsymboltable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_initlib(i64 nlabels) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	u64 d;
	i64 i;
	R1 = 262144;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_ss_symboltable = asu64(R1);
	R1 = 32768;
	mc_decls_ss_symboltablesize = asi64(R1);
	R1 = 0;
	mc_decls_ss_nsymbols = asi64(R1);
	asi64(R1) = nlabels;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_labeldeftable = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlabels;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3766;
L3764:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	R2 = R1;
	asu64(R3) = mc_decls_labeldeftable;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	d = asu64(R1);
	asi64(R1) = i;
	asu64(R2) = d;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("l#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= nlabels) goto L3764;
L3766:
	return;
}

static u64 mc_genss_buffercreate(i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	a = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = a;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	goto L3767;
L3767:
	return asu64(R1);
}

static void mc_genss_bufferexpand(u64 a) {
    u64 R1, R2, R3; 
	i64 newalloc;
	i64 usedbytes;
	u64 p;
	asu64(R1) = a;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newalloc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	usedbytes = asi64(R1);
	asi64(R1) = usedbytes;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L3770;
	msysc_m$print_startcon();
	R1 = tou64("dbuffer error");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
L3770:
	asi64(R1) = newalloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = usedbytes;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asi64(R2) = usedbytes;
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newalloc;
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	asi64(R2) = newalloc;
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mc_genss_buffercheck(u64 a, i64 n) {
    u64 R1, R2, R3; 
	goto L3773;
L3772:
	asu64(R1) = a;
	mc_genss_bufferexpand(asu64(R1));
L3773:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L3772;
	return;
}

static i64 mc_genss_bufferlength(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	goto L3775;
L3775:
	return asi64(R1);
}

static u64 mc_genss_bufferelemptr(u64 a, i64 offset) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	R1 += (i64)R2;
	goto L3776;
L3776:
	return asu64(R1);
}

static void mc_genss_addword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou16p(R2) = asu16(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 2;
	return;
}

static void mc_genss_adddword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou32p(R2) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 4;
	return;
}

static void mc_genss_addqword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou64p(R2) = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 8;
	return;
}

static void mc_genss_genxrm(i64 opcode, i64 code, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 am;
	asu64(R1) = b;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	asi64(R3) = code;
	R4 = 0;
	asu64(R1) = mc_genss_genrm(asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	am = asu64(R1);
	asu64(R1) = mc_genss_currmcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3782;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3782;
	goto L3783;
L3782:
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L3781;
L3783:
L3781:
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3785;
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 24;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3785:
	mc_genss_genrex();
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3787;
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3787:
	asi64(R1) = opcode;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = am;
	asu64(R2) = b;
	mc_genss_genamode(asu64(R2), asu64(R1));
	return;
}

static void mc_genss_genrrm(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3790;
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3790:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu8(R1) = mc_genss_usesizeb;
	if (!asu8(R1)) goto L3792;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3794;
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3794:
L3792:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu64(R4) = a;
	R5 = 10;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R1) = mc_genss_genrm(asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	am = asu64(R1);
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3796;
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 24;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3796:
	mc_genss_genrex();
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3798;
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3798:
	asi64(R1) = opcode;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = am;
	asu64(R2) = b;
	mc_genss_genamode(asu64(R2), asu64(R1));
	return;
}

static i64 mc_genss_getregcode(i64 reg, i64 mask, i64 isxreg) {
    u64 R1, R2; 
	i64 regcode;
	asi64(R1) = isxreg;
	if (asi64(R1)) goto L3801;
	R1 = (u64)&mc_decls_regcodes;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regcode = asi64(R1);
	goto L3800;
L3801:
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	regcode = asi64(R1);
L3800:
	asi64(R1) = regcode;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L3803;
	R1 = 8;
	R2 = (u64)&regcode;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mask;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3803:
	asi64(R1) = regcode;
	goto L3799;
L3799:
	return asi64(R1);
}

static void mc_genss_checkimmrange(i64 value, i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3806;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3807;
	goto L3808;
L3806:
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3811;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3810;
L3811:
	R1 = tou64("exceeding byte value");
	mc_libmcl_axerror(asu64(R1));
L3810:
	goto L3805;
L3807:
	R1 = -32768;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3814;
	R2 = 65535;
	if (asi64(R1) <= asi64(R2)) goto L3813;
L3814:
	R1 = tou64("exceeding u16 value");
	mc_libmcl_axerror(asu64(R1));
L3813:
	goto L3805;
L3808:
	R1 = -2147483648;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3817;
	R2 = 4294967295;
	if (asi64(R1) <= asi64(R2)) goto L3816;
L3817:
	R1 = tou64("2:exceeding u32 value");
	mc_libmcl_axerror(asu64(R1));
L3816:
L3805:
	return;
}

static u64 mc_genss_genrm(i64 reg, i64 opc, u64 b, i64 isxreg) {
    u64 R1, R2, R3, R4; 
	i64 mode;
	i64 rm;
	i64 scale;
	i64 index;
	i64 base;
	i64 regix;
	i64 code;
	i64 ismem;
	u64 am;
// PROC LOCAL STATICS GO HERE
	static struct $B31 mc_genss_genrm_scaletable = {{
	0,
	1,
	0,
	2,
	0,
	0,
	0,
	3    }};
	R1 = (u64)&am;
	memset(R1, 0, 8);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3820;
	asi64(R1) = isxreg;
	R2 = 4;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	opc = asi64(R1);
L3820:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3822;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3822;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3823;
	goto L3824;
L3822:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = 1;
	asu64(R3) = b;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	rm = asi64(R1);
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	R1 = 192;
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = rm;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = am;
	goto L3818;
	goto L3821;
L3823:
	R1 = 1;
	ismem = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3826;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3827;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3828;
	goto L3829;
L3826:
	asu64(R1) = b;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3831;
	R1 = 2;
	ismem = asi64(R1);
L3831:
	goto L3825;
L3827:
	R1 = 2;
	ismem = asi64(R1);
	goto L3825;
L3828:
	R1 = 2;
	ismem = asi64(R1);
	goto L3825;
L3829:
L3825:
	goto L3821;
L3824:
	R1 = tou64("genrm not mem");
	mc_libmcl_axerror(asu64(R1));
L3821:
	R1 = 0;
	R2 = R1;
	rm = asi64(R2);
	mode = asi64(R1);
	R1 = 0;
	scale = asi64(R1);
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = b;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	asi64(R2) = regix;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3833;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3833;
	R1 = 0;
	mode = asi64(R1);
	R1 = 4;
	rm = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
	R1 = 4;
	index = asi64(R1);
	R1 = 5;
	base = asi64(R1);
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3832;
L3833:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L3834;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3834;
// mc_genss.genrm.simple:
L3835:
	R1 = (u64)&am;
	R2 = 4;
	R1 += (i64)R2;
	asu64(R2) = b;
	asi64(R1) = mc_genss_getdispsize(asu64(R2), asu64(R1));
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3837;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3839;
	R1 = 1;
	goto L3838;
L3839:
	R1 = 2;
L3838:
	mode = asi64(R1);
L3837:
	R1 = 0;
	R2 = 1;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	base = asi64(R2);
	rm = asi64(R1);
	asi64(R1) = rm;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3841;
	asi64(R1) = rm;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3843;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3843;
	R1 = 1;
	mode = asi64(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3843:
	R1 = 0;
	index = asi64(R1);
	goto L3840;
L3841:
	R1 = 4;
	index = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
L3840:
	goto L3832;
L3834:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3844;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3844;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L3846;
	R1 = (u64)&reg;
	R2 = (u64)&regix;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	goto L3835;
L3846:
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	mode = asi64(R1);
	R1 = 4;
	rm = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3848;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3847;
L3848:
	R1 = 1;
L3847:
	scale = asi64(R1);
	R1 = 5;
	base = asi64(R1);
	R1 = 0;
	R2 = 2;
	asi64(R3) = regix;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	index = asi64(R1);
	asi64(R1) = regix;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3850;
	R1 = tou64("Scaled rstack?");
	mc_libmcl_axerror(asu64(R1));
L3850:
	goto L3832;
L3844:
	R1 = (u64)&am;
	R2 = 4;
	R1 += (i64)R2;
	asu64(R2) = b;
	asi64(R1) = mc_genss_getdispsize(asu64(R2), asu64(R1));
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3852;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3854;
	R1 = 1;
	goto L3853;
L3854:
	R1 = 2;
L3853:
	mode = asi64(R1);
L3852:
	R1 = 4;
	rm = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3856;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3855;
L3856:
	R1 = 1;
L3855:
	scale = asi64(R1);
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3858;
	R1 = 5;
	base = asi64(R1);
	goto L3857;
L3858:
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3861;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3860;
L3861:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3860;
	R1 = 1;
	mode = asi64(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3860:
	R1 = 0;
	R2 = 1;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	base = asi64(R1);
L3857:
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3863;
	R1 = 4;
	index = asi64(R1);
	goto L3862;
L3863:
	R1 = 0;
	R2 = 2;
	asi64(R3) = regix;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	index = asi64(R1);
	asi64(R1) = reg;
	if (asi64(R1)) goto L3865;
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3865:
	asi64(R1) = regix;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3867;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3867;
	R1 = tou64("Can't scale rstack");
	mc_libmcl_axerror(asu64(R1));
L3867:
L3862:
L3832:
	asi64(R1) = scale;
	if (!asi64(R1)) goto L3869;
	R1 = (u64)&mc_genss_genrm_scaletable;
	asi64(R2) = scale;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 6;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = index;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = base;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 2;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L3869:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3871;
	asi64(R1) = ismem;
	if (!asi64(R1)) goto L3871;
	asi64(R1) = reg;
	if (asi64(R1)) goto L3874;
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3873;
L3874:
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3876;
	asi64(R1) = ismem;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3876;
	msysc_m$print_startcon();
	R1 = tou64("Addr32 can't use RIP, line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = mc_genss_currmcl;
	asu64(R1) = mc_writenasm_strmclstr(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3876:
	goto L3872;
L3873:
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L3877;
	R1 = -1;
	R2 = (u64)&am;
	R3 = 2;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
	R1 = 0;
	mode = asi64(R1);
	R1 = 5;
	rm = asi64(R1);
L3877:
L3872:
L3871:
	asi64(R1) = mode;
	R2 = 6;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = rm;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = am;
	goto L3818;
L3818:
	return asu64(R1);
}

static void mc_genss_do_arith(u64 a, u64 b, i64 code) {
    u64 R1, R2, R3, R4; 
	u64 d;
	i64 opc;
	i64 dispsize;
	i64 x;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3880;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3881;
	goto L3882;
L3880:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3884;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3884;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3885;
	goto L3886;
L3884:
	asi64(R1) = code;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R3 = 1;
	if (asi64(R2) != asi64(R3)) goto L3888;
	R2 = 2;
	goto L3887;
L3888:
	R2 = 3;
L3887:
	asi64(R1) |= asi64(R2);
	opc = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3883;
L3885:
// mc_genss.do_arith.doregimm:
L3889:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L3891;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L3893;
	R1 = tou64("add imm/size");
	mc_libmcl_axerror(asu64(R1));
L3893:
	asu64(R1) = a;
	asi64(R2) = code;
	R3 = 129;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3878;
L3891:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	R1 = 1;
	dispsize = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3895;
	R1 = 128;
	opc = asi64(R1);
	R1 = 1;
	asi64(R2) = x;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
	asi64(R1) = x;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L3898;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3897;
L3898:
	R1 = tou64("Exceeding i8/u8 range");
	mc_libmcl_axerror(asu64(R1));
L3897:
	goto L3894;
L3895:
	R1 = -128;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3899;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3899;
	R1 = 131;
	opc = asi64(R1);
	goto L3894;
L3899:
	R1 = 4;
	asi64(R2) = x;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
	R1 = 129;
	opc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3901;
	R1 = 2;
	goto L3900;
L3901:
	R1 = 4;
L3900:
	dispsize = asi64(R1);
L3894:
	asu64(R1) = a;
	asi64(R2) = code;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = dispsize;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3903;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3904;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3905;
	goto L3906;
L3903:
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3902;
L3904:
	asi64(R1) = x;
	mc_genss_genword(asi64(R1));
	goto L3902;
L3905:
	asi64(R1) = x;
	mc_genss_gendword(asi64(R1));
	goto L3902;
L3906:
L3902:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3883;
L3886:
	R1 = tou64("ADD reg,???");
	mc_libmcl_axerror(asu64(R1));
L3883:
	goto L3879;
L3881:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3908;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3909;
	goto L3910;
L3908:
	asi64(R1) = code;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R3 = 1;
	if (asi64(R2) != asi64(R3)) goto L3912;
	R2 = 0;
	goto L3911;
L3912:
	R2 = 1;
L3911:
	asi64(R1) |= asi64(R2);
	opc = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3907;
L3909:
	goto L3889;
	goto L3907;
L3910:
	R1 = tou64("ADD mem,???");
	mc_libmcl_axerror(asu64(R1));
L3907:
	goto L3879;
L3882:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asi64(R2) = code;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("CODE=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = code;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1:Can't add to this opnd");
	mc_libmcl_axerror(asu64(R1));
L3879:
L3878:
	return;
}

static void mc_genss_do_mov(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 regcode;
	i64 opc;
	i64 dispsize;
	i64 value;
	u64 d;
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3915;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3916;
	goto L3917;
L3915:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3919;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3919;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3920;
	goto L3921;
L3919:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3923;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3923;
	R1 = tou64("2:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3923:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3925;
	R3 = 138;
	goto L3924;
L3925:
	R3 = 139;
L3924:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3918;
L3920:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	regcode = asi64(R1);
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L3927;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3927;
	R1 = tou64("mov imm?");
	mc_libmcl_axerror(asu64(R1));
L3927:
	asu64(R1) = a;
	mc_genss_checkhighreg(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3929;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3930;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3931;
	goto L3932;
L3929:
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3935;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3934;
L3935:
	R1 = tou64("exceeding byte value");
	mc_libmcl_axerror(asu64(R1));
L3934:
	mc_genss_genrex();
	R1 = 176;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3928;
L3930:
	R1 = -32768;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3938;
	R2 = 65535;
	if (asi64(R1) <= asi64(R2)) goto L3937;
L3938:
	R1 = tou64("exceeding u16 value");
	mc_libmcl_axerror(asu64(R1));
L3937:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3928;
L3931:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3940;
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3939;
L3940:
	R1 = -2147483648;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3943;
	R2 = 4294967295;
	asi64(R2) = toi64(tou32(R2));
	if (asi64(R1) <= asi64(R2)) goto L3942;
L3943:
	msysc_m$print_startcon();
	asi64(R1) = value;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = value;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1:exceeding u32 value");
	mc_libmcl_axerror(asu64(R1));
L3942:
// mc_genss.do_mov.doreg32:
L3944:
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L3939:
	goto L3928;
L3932:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3946;
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 8;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3945;
L3946:
	asi64(R1) = value;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3948;
	asi64(R1) = value;
	R2 = 4294967295;
	if (asi64(R1) > asi64(R2)) goto L3948;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L3944;
L3948:
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genqword(asi64(R1));
L3945:
L3928:
	goto L3918;
L3921:
	R1 = tou64("MOV REG/??");
	mc_libmcl_axerror(asu64(R1));
L3918:
	goto L3914;
L3916:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3950;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3951;
	goto L3952;
L3950:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3954;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3954:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3956;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3956;
	R1 = tou64("3:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3956:
	asu64(R1) = a;
	asu64(R2) = b;
	asu64(R3) = b;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3958;
	R3 = 136;
	goto L3957;
L3958:
	R3 = 137;
L3957:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3949;
L3951:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3960;
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3960:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3962;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3962;
	R1 = tou64("mov imm?");
	mc_libmcl_axerror(asu64(R1));
L3962:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3964;
	R1 = 198;
	goto L3963;
L3964:
	R1 = 199;
L3963:
	opc = asi64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L3966;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = value;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
L3966:
	asu64(R1) = a;
	R2 = 0;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	dispsize = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3968;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3969;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3970;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3970;
	goto L3971;
L3968:
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3967;
L3969:
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3967;
L3970:
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	R1 = 4;
	dispsize = asi64(R1);
	goto L3967;
L3971:
L3967:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3949;
L3952:
	R1 = tou64("MOV MEM/?");
	mc_libmcl_axerror(asu64(R1));
L3949:
	goto L3914;
L3917:
	R1 = tou64("MOV ?/..");
	mc_libmcl_axerror(asu64(R1));
L3914:
	return;
}

static void mc_genss_do_push(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3974;
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3974:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3976;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3977;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3978;
	goto L3979;
L3976:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3981;
	R1 = tou64("pushreg not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3981:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	mc_genss_genrex();
	R1 = 80;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3975;
L3977:
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3983;
	R1 = 104;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3982;
L3983:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_genss_isbytesized(asi64(R1));
	if (!asi64(R1)) goto L3984;
	R1 = 106;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3982;
L3984:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_genss_isdwordsized(asi64(R1));
	if (!asi64(R1)) goto L3985;
	R1 = 104;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3982;
L3985:
	R1 = tou64("push imm value too large");
	mc_libmcl_axerror(asu64(R1));
L3982:
	goto L3975;
L3978:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3987;
	R1 = tou64("push not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3987:
	asu64(R1) = a;
	R2 = 6;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3975;
L3979:
	R1 = tou64("push opnd?");
	mc_libmcl_axerror(asu64(R1));
L3975:
	return;
}

static void mc_genss_do_pop(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3990;
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3990:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3992;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3993;
	goto L3994;
L3992:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3996;
	R1 = tou64("popreg not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3996:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	mc_genss_genrex();
	R1 = 88;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3991;
L3993:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3998;
	R1 = tou64("pop not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3998:
	asu64(R1) = a;
	R2 = 0;
	R3 = 143;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3991;
L3994:
	R1 = tou64("pop opnd?");
	mc_libmcl_axerror(asu64(R1));
L3991:
	return;
}

static void mc_genss_do_inc(u64 a, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4001;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4001;
	goto L4002;
L4001:
	asu64(R1) = a;
	asi64(R2) = code;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4004;
	R3 = 254;
	goto L4003;
L4004:
	R3 = 255;
L4003:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L4000;
L4002:
	R1 = tou64("inc/opnd?");
	mc_libmcl_axerror(asu64(R1));
L4000:
	return;
}

static void mc_genss_do_neg(u64 a, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4007;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4007;
	goto L4008;
L4007:
	asu64(R1) = a;
	asi64(R2) = code;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4010;
	R3 = 246;
	goto L4009;
L4010:
	R3 = 247;
L4009:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L4006;
L4008:
	R1 = tou64("neg/div/etc opnd?");
	mc_libmcl_axerror(asu64(R1));
L4006:
	return;
}

static void mc_genss_do_lea(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 regcode;
	i64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4014;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4013;
L4014:
	R1 = tou64("LEA not reg/mem");
	mc_libmcl_axerror(asu64(R1));
L4013:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L4016;
	R1 = tou64("LEA size error");
	mc_libmcl_axerror(asu64(R1));
L4016:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 141;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_movsx(u64 a, u64 b, i64 opc) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4019;
	R1 = tou64("movsx not reg");
	mc_libmcl_axerror(asu64(R1));
L4019:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4021;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4021;
	asi64(R1) = opc;
	R2 = 190;
	if (asi64(R1) != asi64(R2)) goto L4023;
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_movsxd(asu64(R2), asu64(R1));
	goto L4022;
L4023:
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	R2 = 4;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_mov(asu64(R2), asu64(R1));
L4022:
	goto L4017;
L4021:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4026;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) > asu64(R2)) goto L4025;
L4026:
	R1 = tou64("movsx size error");
	mc_libmcl_axerror(asu64(R1));
L4025:
	asi64(R1) = opc;
	R2 = 182;
	if (asi64(R1) != asi64(R2)) goto L4028;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4028;
	R1 = tou64("movsx 4=>8 bytes?");
	mc_libmcl_axerror(asu64(R1));
L4028:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4030;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4031;
	goto L4032;
L4030:
	goto L4029;
L4031:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4034;
	R1 = tou64("movsx need size prefix");
	mc_libmcl_axerror(asu64(R1));
L4034:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4036;
	R1 = tou64("movsx size 8");
	mc_libmcl_axerror(asu64(R1));
L4036:
	goto L4029;
L4032:
	R1 = tou64("movsx not reg/mem");
	mc_libmcl_axerror(asu64(R1));
L4029:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asu64(R4) = b;
	R5 = 8;
	asu16(R4) = *tou16p(((i64)R4+(i64)R5));
	R4 = toi64(tou16(R4));
	R5 = 0;
	R6 = 4;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	if (asi64(R4) != asi64(R5)) goto L4038;
	asi64(R4) = opc;
	goto L4037;
L4038:
	asi64(R4) = opc;
	R5 = 1;
	asi64(R4) += asi64(R5);
L4037:
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4017:
	return;
}

static void mc_genss_do_exch(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 regcode;
	i64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4041;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4041;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4042;
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4041;
L4042:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4041;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4044;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L4044:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L4046;
	R1 = tou64("exch size");
	mc_libmcl_axerror(asu64(R1));
L4046:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	regcode = asi64(R1);
	mc_genss_genrex();
	R1 = 144;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L4039;
L4041:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4048;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L4048:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4051;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4050;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4050;
L4051:
	R1 = tou64("exch opnds");
	mc_libmcl_axerror(asu64(R1));
L4050:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4053;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4053;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4053:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L4055;
	R1 = tou64("exch size");
	mc_libmcl_axerror(asu64(R1));
L4055:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4057;
	R3 = 134;
	goto L4056;
L4057:
	R3 = 135;
L4056:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4039:
	return;
}

static void mc_genss_do_movsxd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4060;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4060;
	R1 = 4;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4060:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4063;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L4062;
L4063:
	R1 = tou64("movsxd size");
	mc_libmcl_axerror(asu64(R1));
L4062:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4066;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4065;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4065;
L4066:
	R1 = tou64("movsxd opnds");
	mc_libmcl_axerror(asu64(R1));
L4065:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 99;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_imul2(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	i64 opc;
	i64 dispsize;
	i64 value;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4069;
	R1 = tou64("imul2 opnds");
	mc_libmcl_axerror(asu64(R1));
L4069:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4071;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4071:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4073;
	R1 = tou64("imul2 byte");
	mc_libmcl_axerror(asu64(R1));
L4073:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4075;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4075;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4076;
	goto L4077;
L4075:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L4079;
	R1 = tou64("imul2 size");
	mc_libmcl_axerror(asu64(R1));
L4079:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 4015;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4074;
L4076:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L4081;
	R1 = tou64("mul/label");
	mc_libmcl_axerror(asu64(R1));
L4081:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L4083;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L4083;
	R1 = 107;
	opc = asi64(R1);
	goto L4082;
L4083:
	R1 = 105;
	opc = asi64(R1);
L4082:
	asu64(R1) = a;
	asu64(R2) = a;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L4085;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L4085;
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	dispsize = asi64(R1);
	goto L4084;
L4085:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4086;
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	R1 = 2;
	dispsize = asi64(R1);
	goto L4084;
L4086:
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
	R1 = 4;
	dispsize = asi64(R1);
L4084:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L4074;
L4077:
	R1 = tou64("imul2 opnds");
	mc_libmcl_axerror(asu64(R1));
L4074:
	return;
}

static void mc_genss_do_shift(u64 a, u64 b, i64 code) {
    u64 R1, R2, R3; 
	i64 w;
	i64 opc;
	i64 needdisp;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4089;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4089;
	R1 = tou64("shift opnds1?");
	mc_libmcl_axerror(asu64(R1));
L4089:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L4091;
	R1 = tou64("shift/label");
	mc_libmcl_axerror(asu64(R1));
L4091:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4093;
	R1 = 0;
	goto L4092;
L4093:
	R1 = 1;
L4092:
	w = asi64(R1);
	R1 = 0;
	needdisp = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4095;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4096;
	goto L4097;
L4095:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4099;
	R1 = 208;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4098;
L4099:
	R1 = 192;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	R1 = 1;
	needdisp = asi64(R1);
L4098:
	goto L4094;
L4096:
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4102;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4101;
L4102:
	R1 = tou64("cl or b10 needed");
	mc_libmcl_axerror(asu64(R1));
L4101:
	R1 = 210;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4094;
L4097:
	R1 = tou64("shift opnds2?");
	mc_libmcl_axerror(asu64(R1));
L4094:
	asu64(R1) = a;
	asi64(R2) = code;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = needdisp;
	if (!asi64(R1)) goto L4104;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_fixrip(asi64(R1));
L4104:
	return;
}

static void mc_genss_do_test(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 value;
	i64 opc;
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4107;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4107;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4107;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4109;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4110;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4111;
	goto L4112;
L4109:
	R1 = 168;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L4108;
L4110:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L4108;
L4111:
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
	goto L4108;
L4112:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L4108:
	goto L4106;
L4107:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4114;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4113;
L4114:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4113;
	asu64(R1) = a;
	R2 = 0;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4116;
	R3 = 246;
	goto L4115;
L4116:
	R3 = 247;
L4115:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4118;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4119;
	goto L4120;
L4118:
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L4117;
L4119:
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L4117;
L4120:
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L4117:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	mc_genss_fixrip(asi64(R1));
	goto L4106;
L4113:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4122;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4121;
L4122:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4121;
// mc_genss.do_test.domemreg:
L4123:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4125;
	R3 = 132;
	goto L4124;
L4125:
	R3 = 133;
L4124:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4106;
L4121:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4126;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4126;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	goto L4123;
	goto L4106;
L4126:
	R1 = tou64("test opnds");
	mc_libmcl_axerror(asu64(R1));
L4106:
	return;
}

static void mc_genss_do_setcc(i64 cond, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4131;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4130;
L4131:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4129;
L4130:
	R1 = tou64("setcc opnd/size");
	mc_libmcl_axerror(asu64(R1));
L4129:
	asu64(R1) = b;
	R2 = 0;
	R3 = 3984;
	asi64(R4) = cond;
	asi64(R3) += asi64(R4);
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void mc_genss_checksize(u64 a, i64 size1, i64 size2) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4134;
	R1 = tou64("Need size");
	mc_libmcl_axerror(asu64(R1));
L4134:
	asi64(R1) = size1;
	if (!asi64(R1)) goto L4136;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size1;
	if (asi64(R1) == asi64(R2)) goto L4136;
	asi64(R2) = size2;
	if (asi64(R1) == asi64(R2)) goto L4136;
	msysc_m$print_startcon();
	R1 = tou64("A.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Wrong size");
	mc_libmcl_axerror(asu64(R1));
L4136:
	return;
}

static void mc_genss_do_arithxmm(u64 a, u64 b, i64 prefix, i64 opc) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4140;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4139;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4139;
L4140:
	R1 = tou64("arithxmm opnds");
	mc_libmcl_axerror(asu64(R1));
L4139:
	asi64(R1) = prefix;
	if (!asi64(R1)) goto L4142;
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4142:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_logicxmm(u64 a, u64 b, i64 opc, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4146;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4145;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4145;
L4146:
	R1 = tou64("logicxmm opnds");
	mc_libmcl_axerror(asu64(R1));
L4145:
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4148;
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4148:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_convertfloat(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4152;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4151;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4151;
L4152:
	R1 = tou64("convertfloat opnds");
	mc_libmcl_axerror(asu64(R1));
L4151:
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3930;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_fix(u64 a, u64 b, i64 prefix, i64 opc) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4156;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4155;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4155;
L4156:
	R1 = tou64("fix opnds");
	mc_libmcl_axerror(asu64(R1));
L4155:
	R1 = 8;
	R2 = 4;
	asu64(R3) = a;
	mc_genss_checksize(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = prefix;
	R2 = 243;
	if (asi64(R1) != asi64(R2)) goto L4158;
	R1 = 4;
	goto L4157;
L4158:
	R1 = 8;
L4157:
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_float(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4162;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4161;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4161;
L4162:
	R1 = tou64("float opnds");
	mc_libmcl_axerror(asu64(R1));
L4161:
	R1 = 8;
	R2 = 4;
	asu64(R3) = b;
	mc_genss_checksize(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = prefix;
	R2 = 243;
	if (asi64(R1) != asi64(R2)) goto L4164;
	R1 = 4;
	goto L4163;
L4164:
	R1 = 8;
L4163:
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_usesizeb = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3882;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_movxmm(u64 a, u64 b, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	i64 regcode1;
	i64 regcode2;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4167;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4168;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4169;
	goto L4170;
L4167:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4172;
	goto L4173;
L4172:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4175;
	R1 = tou64("1:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4175:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4171;
L4173:
	R1 = tou64("movdq reg,?");
	mc_libmcl_axerror(asu64(R1));
L4171:
	goto L4166;
L4168:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4177;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4178;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4179;
	goto L4180;
L4177:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4182;
	R1 = tou64("3:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4182:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3950;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4176;
L4178:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4176;
L4179:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4184;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4184:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4186;
	R1 = tou64("31:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4186:
	asi64(R1) = size;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4188;
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3950;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4187;
L4188:
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4187:
	goto L4176;
L4180:
	R1 = tou64("movdq xreg,?");
	mc_libmcl_axerror(asu64(R1));
L4176:
	goto L4166;
L4169:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4190;
	goto L4191;
L4190:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L4193;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4193;
	R1 = tou64("5:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4193:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = size;
	R4 = 4;
	if (asi64(R3) != asi64(R4)) goto L4195;
	R3 = 3966;
	goto L4194;
L4195:
	R3 = 4054;
L4194:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4189;
L4191:
	R1 = tou64("movdq mem,?");
	mc_libmcl_axerror(asu64(R1));
L4189:
	goto L4166;
L4170:
	R1 = tou64("movdq opnds");
	mc_libmcl_axerror(asu64(R1));
L4166:
	return;
}

static void mc_genss_fixrip(i64 dispsize) {
    u64 R1, R2, R3; 
	u64 codeaddr;
	u64 offsetptr;
	asu64(R1) = mc_genss_ripentry;
	if (asu64(R1)) goto L4198;
	goto L4196;
L4198:
	asi64(R1) = dispsize;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4200;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4201;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4201;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4201;
	goto L4202;
L4200:
	goto L4196;
	goto L4199;
L4201:
	goto L4199;
L4202:
	msysc_m$print_startcon();
	R1 = tou64("DISPSIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = dispsize;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("fixrip disp?");
	mc_libmcl_axerror(asu64(R1));
L4199:
	asi64(R1) = dispsize;
	asu64(R2) = mc_genss_ripentry;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4196:
	return;
}

static void mc_genss_do_bswap(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4206;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L4205;
L4206:
	R1 = tou64("bswap reg>");
	mc_libmcl_axerror(asu64(R1));
L4205:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	mc_genss_genrex();
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 200;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_genss_do_movdqx(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = prefix;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	R2 = 3840;
	asi64(R1) += asi64(R2);
	prefix = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4209;
	R1 = 16;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4209:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4211;
	R1 = 16;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4211:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4213;
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = prefix;
	R4 = 127;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4212;
L4213:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = prefix;
	R4 = 111;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4212:
	return;
}

static void mc_genss_do_dshift(u64 a, u64 b, i64 c, i64 opc) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4216;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4216:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L4219;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L4218;
L4219:
	R1 = tou64("dshift/size");
	mc_libmcl_axerror(asu64(R1));
L4218:
	R1 = 0;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = c;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_decls_start() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4223;
L4221:
	R1 = 10;
	R2 = (u64)&mc_decls_ploadop;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L4221;
L4223:
	R1 = 19;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 5;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 4;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 18;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 9;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 8;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 17;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 10;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mc_writenasm_getassemstr() {
    u64 R1, R2; 
	u64 d;
	u64 e;
	u64 m;
	struct $B18 str2;
	struct $B18 str3;
	i64 i;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	R1 = tou64(";NASM VERSION\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    default rel\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern fmod\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern sin\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern cos\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern tan\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern asin\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern acos\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern atan\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern log\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern log10\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern exp\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern floor\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern ceil\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern pow\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern exit\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern __getmainargs\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    global main\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L4228;
L4225:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4230;
	R1 = tou64("    extern ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
L4230:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4232;
	R1 = tou64("    global ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
L4232:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4228:
	asu64(R1) = d;
	if (asu64(R1)) goto L4225;
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L4234;
L4233:
	asu64(R1) = m;
	asi64(R2) = i;
	mc_writenasm_writemcl(asi64(R2), asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L4234:
	asu64(R1) = m;
	if (asu64(R1)) goto L4233;
	asu64(R1) = pc_decls_pdest;
	goto L4224;
L4224:
	return asu64(R1);
}

static void mc_writenasm_writemcl(i64 index, u64 mcl) {
    u64 R1; 
	asu64(R1) = mcl;
	mc_writenasm_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mc_writenasm_start() {
    u64 R1, R2, R3; 
	u8 flag;
	i64 av_1;
	i64 i;
	i64 r;
	i64 k;
	R1 = 1297301838;
	pc_decls_assemtype = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4238:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4243;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4243;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4243;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4242;
L4243:
	R1 = 1;
	r = asi64(R1);
L4244:
	R1 = 0;
	flag = asu8(R1);
	R1 = 1;
	k = asi64(R1);
	R1 = 137;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4249;
L4247:
	asu8(R1) = flag;
	if (!asu8(R1)) goto L4251;
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L4253;
	R1 = (u64)&mc_decls_regindices;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = r;
	if (asi64(R1) != asi64(R2)) goto L4253;
	R1 = (u64)&mc_decls_dregnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_writenasm_nregnames;
	asi64(R3) = i;
	R2 += (i64)R3*128-128;
	asi64(R3) = r;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4253:
	goto L4250;
L4251:
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4254;
	R1 = 1;
	flag = asu8(R1);
L4254:
L4250:
	k += 1; if (k <= av_1) goto L4247;
L4249:
	r += 1; if (r <= 16) goto L4244;
L4242:
	i += 1; if (i <= 8) goto L4238;
	return;
}

static void mc_writenasm_strmcl(u64 mcl) {
    u64 R1, R2, R3; 
	struct $B22 opcname;
	u64 a;
	u64 b;
	i64 opcode;
	i64 cond;
	i64 sizepref;
	u64 s;
	u64 comment;
	u64 d;
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asu64(R1) = mcl;
	R2 = 34;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu64(R1) = mcl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = mcl;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	comment = asu64(R1);
	asi64(R1) = opcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4257;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4258;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4259;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4260;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4261;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4262;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4263;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L4264;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L4265;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L4266;
	goto L4267;
L4257:
	R1 = tou64(";Proc ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	goto L4255;
	goto L4256;
L4258:
	R1 = tou64(";End ");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 0;
	mc_decls_currasmproc = asu64(R1);
	goto L4255;
	goto L4256;
L4259:
	R1 = 59;
	mc_writenasm_asmchar(asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	goto L4255;
	goto L4256;
L4260:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4269;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4270;
	goto L4271;
L4269:
	asu64(R1) = d;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	mc_writenasm_asmstr(asu64(R1));
	goto L4268;
L4270:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	goto L4255;
	goto L4268;
L4271:
	R1 = tou64("");
	R2 = tou64("strmcl/lab");
	pc_api_merror(asu64(R2), asu64(R1));
L4268:
	R1 = tou64(":");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4273;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4275;
	goto L4274;
L4275:
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64(":");
	mc_writenasm_asmstr(asu64(R1));
L4274:
L4273:
	goto L4255;
	goto L4256;
L4261:
	R1 = (u64)&mc_writenasm_strmcl_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("L#:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writenasm_strmcl_str;
	mc_writenasm_asmstr(asu64(R1));
	goto L4255;
	goto L4256;
L4262:
	R1 = tou64("    %define ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64(" ");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L4255;
	goto L4256;
L4263:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = tou64("   %define ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64(" ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4277;
	goto L4278;
L4277:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strreg(asi64(R2), asi64(R1));
	mc_writenasm_asmstr(asu64(R1));
	goto L4276;
L4278:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strxreg(asi64(R2), asi64(R1));
	mc_writenasm_asmstr(asu64(R1));
L4276:
	goto L4255;
	goto L4255;
	goto L4256;
L4264:
	R1 = tou64("    segment .text");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 1;
	mc_writenasm_currseg = asu8(R1);
	goto L4255;
	goto L4256;
L4265:
	R1 = tou64("    segment .data");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 2;
	mc_writenasm_currseg = asu8(R1);
	goto L4255;
	goto L4256;
L4266:
	R1 = tou64("    segment .bss");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 3;
	mc_writenasm_currseg = asu8(R1);
	goto L4255;
	goto L4256;
L4267:
L4256:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4280;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4281;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4282;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L4283;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4284;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4285;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L4286;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L4287;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4288;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L4289;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4290;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L4291;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4292;
	goto L4293;
L4280:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("j");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4279;
L4281:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("set");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4279;
L4282:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("cmov");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4279;
L4283:
	R1 = tou64("and");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4279;
L4284:
	R1 = tou64("or");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4279;
L4285:
	R1 = tou64("xor");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4279;
L4286:
	R1 = tou64("not");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4279;
L4287:
	R1 = tou64("imul");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4279;
L4288:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4295;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4295;
	R1 = 4;
	asu64(R2) = a;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	R2 = R1;
	a = asu64(R2);
	asu64(R2) = mcl;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 11;
	opcode = asi64(R1);
L4295:
	goto L4293;
	goto L4293;
	goto L4279;
L4289:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4297;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4297;
	R1 = tou64("movsxd");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4296;
L4297:
	goto L4293;
	goto L4293;
L4296:
	goto L4279;
L4290:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4299;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4299;
	R1 = 17;
	opcode = asi64(R1);
L4299:
	goto L4293;
	goto L4293;
	goto L4279;
L4291:
	asu8(R1) = mc_writenasm_currseg;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4301;
	R1 = tou64("alignb");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4300;
L4301:
	goto L4293;
	goto L4293;
L4300:
	goto L4279;
L4292:
	goto L4255;
	goto L4279;
L4293:
	asi64(R1) = opcode;
	R2 = 151;
	if (asi64(R1) <= asi64(R2)) goto L4303;
	R1 = 0;
	asi64(R2) = opcode;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4302;
L4303:
	R1 = (u64)&mc_decls_mclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 2;
	R1 += (i64)R2;
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L4302:
L4279:
	R1 = tou64(" ");
	asi64(R2) = opcode;
	R3 = 119;
	if (asi64(R2) != asi64(R3)) goto L4305;
	R2 = 4;
	goto L4304;
L4305:
	R2 = 10;
L4304:
	R3 = (u64)&opcname;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("  ");
	R2 = (u64)&mc_writenasm_strmcl_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 4;
	R3 = (u64)&mc_writenasm_strmcl_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&opcname;
	R2 = (u64)&mc_writenasm_strmcl_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writenasm_strmcl_str;
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L4307;
	asu64(R1) = b;
	if (!asu64(R1)) goto L4307;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	asi64(R1) = mc_writenasm_needsizeprefix(asi64(R3), asu64(R2), asu64(R1));
	sizepref = asi64(R1);
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = a;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64(",\t");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = b;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = mcl;
	R2 = 32;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4309;
	R1 = tou64(",");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 0;
	asu64(R2) = mcl;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	mc_writenasm_asmstr(asu64(R1));
L4309:
	goto L4306;
L4307:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4310;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L4310;
	asi64(R1) = opcode;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4312;
	asi64(R1) = opcode;
	R2 = 0;
	asu64(R3) = a;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L4311;
L4312:
	asi64(R1) = opcode;
	R2 = 1;
	asu64(R3) = a;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
L4311:
L4310:
L4306:
L4255:
	return;
}

static u64 mc_writenasm_strmclstr(u64 m) {
    u64 R1, R2; 
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = m;
	mc_writenasm_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4313;
L4313:
	return asu64(R1);
}

static u64 mc_writenasm_mstropnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3, R4; 
	struct $B22 str2;
	u64 plus;
	u64 t;
	i64 offset;
	i64 tc;
	R1 = 0;
	R2 = (u64)&mc_writenasm_mstropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4316;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4317;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4318;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4319;
	goto L4320;
L4316:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strreg(asi64(R2), asi64(R1));
	goto L4314;
	goto L4315;
L4317:
	asi64(R1) = opcode;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L4322;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4322;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4324;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L4324;
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4323;
L4324:
	R1 = tou64("0x");
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("H");
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4323:
	goto L4321;
L4322:
	asu64(R1) = a;
	asu64(R1) = mc_writenasm_strvalue(asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L4321:
	goto L4315;
L4318:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4326;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4327;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4328;
	goto L4329;
L4326:
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4325;
L4327:
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4325;
L4328:
	R1 = (u64)&mc_writenasm_mstropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("M#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L4325;
L4329:
L4325:
	asi64(R1) = sizeprefix;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = mc_writenasm_getsizeprefix(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("[");
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4331;
	R1 = 8;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
L4331:
	asu64(R1) = a;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4333;
	asu64(R1) = plus;
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = a;
	R3 = 11;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4335;
	R1 = tou64("*");
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 5;
	R4 = 8;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4335:
L4333:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4338;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4338;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4337;
L4338:
	asu64(R1) = plus;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L4340;
	asu64(R1) = plus;
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4340:
	asu64(R1) = a;
	asu64(R1) = mc_writenasm_strvalue(asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4336;
L4337:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L4341;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" + ");
	asi64(R2) = offset;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4341:
L4336:
	R1 = tou64("]");
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4315;
L4319:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strxreg(asi64(R2), asi64(R1));
	goto L4314;
	goto L4315;
L4320:
	msysc_m$print_startcon();
	R1 = tou64("BAD OPND");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<BAD OPND>");
	goto L4314;
L4315:
	R1 = (u64)&mc_writenasm_mstropnd_str;
	goto L4314;
L4314:
	return asu64(R1);
}

static u64 mc_writenasm_strvalue(u64 a) {
    u64 R1, R2, R3; 
	struct $B22 str2;
	u64 def;
	i64 value;
	i64 offset;
	i64 length;
	u64 ss;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	def = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4344;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4345;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4346;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4347;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4348;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L4349;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L4350;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L4351;
	goto L4352;
L4344:
	asu64(R1) = def;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
// mc_writenasm.strvalue.addoffset:
L4353:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L4355;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4357;
	R1 = tou64("+");
	goto L4356;
L4357:
	R1 = tou64("");
L4356:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = offset;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4355:
	goto L4343;
L4345:
	R1 = 0;
	asi64(R2) = value;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4343;
L4346:
	R1 = (u64)&mc_writenasm_strvalue_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("20.20");
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4343;
L4347:
	R1 = tou64("M");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4343;
L4348:
	R1 = tou64("\"");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4343;
L4349:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4343;
L4350:
	R1 = tou64("L");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4353;
	goto L4343;
L4351:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_currasmproc;
	asu64(R1) = mc_writenasm_gettempname(asu64(R2), asi64(R1));
	goto L4342;
	goto L4343;
L4352:
	R1 = tou64("");
	R2 = tou64("Stropnd?");
	pc_api_merror(asu64(R2), asu64(R1));
L4343:
	R1 = (u64)&mc_writenasm_strvalue_str;
	goto L4342;
L4342:
	return asu64(R1);
}

static void mc_writenasm_asmopnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	asi64(R2) = sizeprefix;
	asu64(R3) = a;
	asu64(R1) = mc_writenasm_mstropnd(asu64(R3), asi64(R2), asi64(R1));
	mc_writenasm_asmstr(asu64(R1));
	return;
}

static u64 mc_writenasm_getxregname(i64 reg, i64 size) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4361;
	R1 = tou64("-");
	goto L4359;
L4361:
	R1 = (u64)&mc_writenasm_getxregname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("XMM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writenasm_getxregname_str;
	goto L4359;
L4359:
	return asu64(R1);
}

static void mc_writenasm_asmstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mc_writenasm_asmchar(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_char(asu64(R2), asi64(R1));
	return;
}

static u64 mc_writenasm_getdispname(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4366;
	R1 = (u64)&mc_writenasm_getdispname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("R");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writenasm_getdispname_str;
	goto L4364;
L4366:
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4368;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4364;
L4368:
	R1 = 0;
	asu64(R2) = d;
	asu64(R1) = pc_api_getfullname(asu64(R2), asi64(R1));
	goto L4364;
L4364:
	return asu64(R1);
}

static u64 mc_writenasm_gettempname(u64 d, i64 n) {
    u64 R1; 
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4371;
	R1 = (u64)&mc_writenasm_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L4370;
L4371:
	R1 = (u64)&mc_writenasm_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.$T#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L4370:
	R1 = (u64)&mc_writenasm_gettempname_str;
	goto L4369;
L4369:
	return asu64(R1);
}

static u64 mc_writenasm_strreg(i64 reg, i64 size) {
    u64 R1, R2; 
	u64 d;
	R1 = (u64)&mc_writenasm_nregnames;
	asi64(R2) = size;
	R1 += (i64)R2*128-128;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L4372;
L4372:
	return asu64(R1);
}

static u64 mc_writenasm_strxreg(i64 reg, i64 size) {
    u64 R1, R2; 
	u64 d;
	R1 = 1;
	asi64(R2) = reg;
	asu64(R1) = mc_writenasm_checkregvar(asi64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4375;
	asu64(R1) = d;
	if (!asu64(R1)) goto L4375;
	asu64(R1) = d;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	goto L4374;
L4375:
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_writenasm_getxregname(asi64(R2), asi64(R1));
L4374:
	goto L4373;
L4373:
	return asu64(R1);
}

static i64 mc_writenasm_needsizeprefix(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L4378;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4378;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4378;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4378;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L4379;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4379;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4379;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4379;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4380;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4380;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4380;
	goto L4381;
L4378:
	R1 = 1;
	goto L4376;
	goto L4377;
L4379:
	R1 = 1;
	goto L4376;
	goto L4377;
L4380:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4383;
	R1 = 1;
	goto L4376;
L4383:
	R1 = 0;
	goto L4376;
	goto L4377;
L4381:
L4377:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4386;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4386;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4386;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4385;
L4386:
	R1 = 0;
	goto L4376;
L4385:
	R1 = 1;
	goto L4376;
L4376:
	return asi64(R1);
}

static u64 mc_writenasm_getsizeprefix(i64 size, i64 enable) {
    u64 R1, R2; 
	asi64(R1) = enable;
	if (asi64(R1)) goto L4389;
	R1 = tou64("");
	goto L4387;
L4389:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4391;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4392;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4393;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4394;
	goto L4395;
L4391:
	R1 = tou64("byte ");
	goto L4387;
	goto L4390;
L4392:
	R1 = tou64("word ");
	goto L4387;
	goto L4390;
L4393:
	R1 = tou64("dword ");
	goto L4387;
	goto L4390;
L4394:
	R1 = tou64("qword ");
	goto L4387;
	goto L4390;
L4395:
L4390:
	R1 = tou64("");
	goto L4387;
L4387:
	return asu64(R1);
}

static u64 mc_writenasm_checkregvar(i64 reg, i64 ispfloat) {
    u64 R1; 
	u64 d;
	R1 = 0;
	goto L4396;
L4396:
	return asu64(R1);
}

static void mc_writeexe_writeexe(u64 outfile, i64 dodll, u64 entrypoint) {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_exedone;
	if (!asu8(R1)) goto L4399;
	goto L4397;
L4399:
	asi64(R1) = dodll;
	asu64(R2) = outfile;
	asu64(R3) = entrypoint;
	mc_writeexe_genexe1(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = dodll;
	asu64(R2) = outfile;
	mc_writeexe_genexe2(asu64(R2), asi64(R1));
	R1 = 1;
	pc_decls_exedone = asu8(R1);
L4397:
	return;
}

static void mc_writeexe_genexe1(u64 entrypoint, u64 outfile, i64 dodll) {
    u64 R1, R2, R3, R4; 
	i64 offset;
	u64 codeaddr;
	u64 offsetptr;
	u64 pr;
	mc_writeexe_initsectiontable();
	asu64(R1) = outfile;
	asu64(R1) = mlib_extractfile(asu64(R1));
	mc_writeexe_dllfilename = asu64(R1);
	asi64(R1) = dodll;
	mc_writeexe_isdll = asi64(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4402;
	R1 = 268435456;
	goto L4401;
L4402:
	R1 = 4194304;
L4401:
	mc_writeexe_imagebase = asi64(R1);
	asu64(R1) = entrypoint;
	mc_writeexe_userentrypoint = asu64(R1);
	mc_writeexe_loadlibs();
	mc_writeexe_scanst();
	mc_writeexe_getoffsets();
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writeexe_relocdata(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writeexe_relocdata(asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codeaddr = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L4404;
	asu64(R1) = mc_decls_riplist;
	pr = asu64(R1);
	goto L4408;
L4405:
	asu64(R1) = codeaddr;
	asu64(R2) = pr;
	R3 = 8;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	offsetptr = asu64(R1);
	asu64(R1) = pr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offsetptr;
	asu32(R2) = *tou32p(R2);
	R2 = toi64(tou32(R2));
	asi64(R3) = mc_writeexe_imagebase;
	asi64(R2) -= asi64(R3);
	asu64(R3) = pr;
	R4 = 8;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asi64(R1) = mc_writeexe_getripoffset(asi64(R3), asi64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	asu64(R2) = offsetptr;
	*tou32p(R2) = asu32(R1);
	asu64(R1) = pr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pr = asu64(R1);
L4408:
	asu64(R1) = pr;
	if (asu64(R1)) goto L4405;
L4404:
	return;
}

static void mc_writeexe_genexe2(u64 outfile, i64 dodll) {
    u64 R1, R2, R3; 
	struct $B17 header;
	struct $B83 optheader;
	i64 offset;
	i64 i;
	i64 aa;
	asu64(R1) = outfile;
	asu64(R1) = mlib_extractfile(asu64(R1));
	mc_writeexe_dllfilename = asu64(R1);
	asi64(R1) = dodll;
	mc_writeexe_isdll = asi64(R1);
	asi64(R1) = mc_writeexe_filesize;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	R2 = R1;
	mc_writeexe_dataptr = asu64(R2);
	mc_writeexe_datastart = asu64(R1);
	mc_writeexe_writedosstub();
	mc_writeexe_writepesig();
	mc_writeexe_writefileheader();
	mc_writeexe_writeoptheader();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4412;
L4410:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	mc_writeexe_writesectionheader(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4410;
L4412:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_writeexe_writepadding(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4415;
L4413:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	mc_writeexe_writesectiondata(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4413;
L4415:
	asu8(R1) = pc_decls_pverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4417;
	msysc_m$print_startcon();
	R1 = tou64("EXE size:  ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_writeexe_dataptr;
	asu64(R3) = mc_writeexe_datastart;
	asi64(R2) -= asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L4417:
	asu64(R1) = mc_writeexe_dataptr;
	asu64(R2) = mc_writeexe_datastart;
	asi64(R1) -= asi64(R2);
	asu64(R2) = mc_writeexe_datastart;
	asu64(R3) = outfile;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4419;
	msysc_m$print_startcon();
	R1 = tou64("Error writing exe file (possibly still running)");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L4419:
	return;
}

static void mc_writeexe_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	i64 hinst;
	u64 file;
	struct $B15 filename;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4423;
L4421:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4425;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filename;
	asi64(R1) = mwindows_os_getdllinst(asu64(R1));
	hinst = asi64(R1);
	asi64(R1) = hinst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4427;
	msysc_m$print_startcon();
	R1 = tou64("File:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't load search lib");
	mc_libmcl_axerror(asu64(R1));
L4427:
	asi64(R1) = hinst;
	R2 = (u64)&mc_writeexe_libinsttable;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&filename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_libinstnames;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4425:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4421;
L4423:
	return;
}

static void mc_writeexe_initsectiontable() {
    u64 R1, R2, R3; 
	R1 = tou64(".text");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_code;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L4430;
	msysc_m$print_startcon();
	R1 = tou64("Code size: ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_code;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("bytes");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = pc_decls_pverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4432;
	msysc_m$print_startcon();
	R1 = tou64("Idata size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_idata;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Code+Idata:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_code;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	asu64(R3) = mc_decls_ss_idata;
	asi64(R3) = mc_genss_bufferlength(asu64(R3));
	asi64(R2) += asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Zdata size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asi64(R2) = mc_decls_ss_zdatalen;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4432:
L4430:
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4434;
	R1 = 0;
	asu64(R2) = mc_decls_ss_idata;
	mc_genss_addqword(asu64(R2), asi64(R1));
L4434:
	R1 = tou64(".data");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idata;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idatarelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4436;
	R1 = 16;
	mc_decls_ss_zdatalen = asi64(R1);
L4436:
	R1 = tou64(".bss");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 3;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_coderelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64(".idata");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 5;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	mc_writeexe_nsections = asi64(R1);
	return;
}

static u64 mc_writeexe_extractlibname(u64 name, u64 libno, i64 moduleno) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 name2;
	struct $B16 str;
	struct $B16 str2;
	i64 i;
	i64 n;
	R1 = 0;
	name2 = asu64(R1);
// mc_writeexe.extractlibname.reenter:
	asu64(R1) = name;
	s = asu64(R1);
	R1 = 0;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	goto L4440;
L4439:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L4443;
	asu64(R1) = s;
	asu64(R2) = name;
	asu64(R1) -= asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asu64(R4) = name;
	asi64(R3) -= asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = tou64(".dll");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4446;
L4444:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4448;
	asi64(R1) = i;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asu64(R2) = libno;
	asi64(R2) = *toi64p(R2);
	R1 += (i64)R2*48-40;
	(*toi64p(R1)) += 1;
	asu64(R1) = name2;
	if (!asu64(R1)) goto L4450;
	asu64(R1) = name2;
	goto L4449;
L4450:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
L4449:
	goto L4437;
L4448:
	i += 1; if (i <= mc_writeexe_ndlls) goto L4444;
L4446:
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4452;
	R1 = tou64("Too many libs");
	mc_libmcl_axerror(asu64(R1));
L4452:
	R1 = (u64)&mc_writeexe_ndlls;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = name2;
	if (!asu64(R1)) goto L4454;
	asu64(R1) = name2;
	goto L4453;
L4454:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
L4453:
	goto L4437;
L4443:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L4440:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L4439;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4458;
L4455:
	R1 = (u64)&mc_writeexe_libinsttable;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L4460;
	asu64(R1) = name;
	R2 = (u64)&mc_writeexe_libinsttable;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mwindows_os_getdllprocaddr(asi64(R2), asu64(R1));
	if (!asu64(R1)) goto L4462;
	asi64(R1) = i;
	n = asi64(R1);
	goto L4457;
L4462:
L4460:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4455;
L4458:
	msysc_m$print_startcon();
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find external function");
	mc_libmcl_axerror(asu64(R1));
L4457:
	R1 = (u64)&mc_writeexe_libnotable;
	asi64(R2) = n;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	asu64(R3) = libno;
	*toi64p(R3) = asi64(R2);
	if (!asi64(R1)) goto L4464;
	R1 = (u64)&mc_writeexe_dlltable;
	asu64(R2) = libno;
	asi64(R2) = *toi64p(R2);
	R1 += (i64)R2*48-40;
	(*toi64p(R1)) += 1;
	asu64(R1) = name;
	goto L4437;
L4464:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".dll");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4466;
	R1 = tou64("2:Too many libs");
	mc_libmcl_axerror(asu64(R1));
L4466:
	R1 = (u64)&mc_writeexe_ndlls;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = libno;
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&mc_writeexe_libnotable;
	asi64(R3) = n;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = name;
	goto L4437;
L4437:
	return asu64(R1);
}

static void mc_writeexe_scanst() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 libno;
	u64 d;
	u64 name;
	u64 libname;
	u64 basename;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4470;
L4468:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4472;
	asi64(R1) = mc_writeexe_nimports;
	R2 = 3000;
	if (asi64(R1) < asi64(R2)) goto L4474;
	R1 = tou64("genexe: Too many imports");
	mc_libmcl_axerror(asu64(R1));
L4474:
	R1 = (u64)&mc_writeexe_nimports;
	(*toi64p(R1)) += 1;
	R1 = 1;
	R2 = (u64)&libno;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mc_writeexe_extractlibname(asu64(R3), asu64(R2), asi64(R1));
	name = asu64(R1);
	asi64(R1) = libno;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = name;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mc_writeexe_nimports;
	asu64(R2) = d;
	R3 = 98;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L4471;
L4472:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4475;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	basename = asu64(R1);
	asu64(R1) = mc_writeexe_userentrypoint;
	if (!asu64(R1)) goto L4477;
	asu64(R1) = mc_writeexe_userentrypoint;
	asu64(R2) = basename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4479;
	asu64(R1) = d;
	mc_writeexe_stentrypoint = asu64(R1);
L4479:
	goto L4476;
L4477:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4481;
	asi64(R1) = mc_writeexe_isdll;
	if (asi64(R1)) goto L4481;
	asu64(R1) = d;
	mc_writeexe_stentrypoint = asu64(R1);
L4481:
L4476:
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L4483;
	R1 = tou64("gendll: Too many exports");
	mc_libmcl_axerror(asu64(R1));
L4483:
	R1 = (u64)&mc_writeexe_nexports;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = (u64)&mc_writeexe_exporttable;
	asi64(R3) = mc_writeexe_nexports;
	R2 += (i64)R3*16-16;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	R2 = (u64)&mc_writeexe_exporttable;
	asi64(R3) = mc_writeexe_nexports;
	R2 += (i64)R3*16-16;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4475:
L4471:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4468;
L4470:
	return;
}

static void mc_writeexe_relocdata(u64 s) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 r;
	u64 p;
	u64 p32;
	u64 p64;
	u64 d;
	i64 offset;
	i64 index;
	i64 thunkoffset;
	i64 iatoffset;
	R1 = 0;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = s;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L4486;
L4485:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 98;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = index;
	R1 += (i64)R2*48;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	thunkoffset = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4489;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4490;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4490;
	goto L4491;
L4489:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4493;
	R1 = tou64("rel32/not imported");
	mc_libmcl_axerror(asu64(R1));
L4493:
	asi64(R1) = thunkoffset;
	asu64(R2) = r;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 4;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4488;
L4490:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4495;
	asi64(R1) = mc_writeexe_imagebase;
	asi64(R2) = thunkoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4494;
L4495:
	R1 = 0;
	u = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4497;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4498;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4499;
	goto L4500;
L4497:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 144;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4496;
L4498:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4496;
L4499:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4496;
L4500:
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("RELOCDATA/SEG?");
	mc_libmcl_axerror(asu64(R1));
L4496:
	asu64(R1) = p;
	asu64(R2) = r;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	p32 = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4502;
	asu64(R1) = p32;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R2) = u;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_writeexe_imagebase;
	asi64(R1) += asi64(R2);
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	goto L4501;
L4502:
	asu64(R1) = p32;
	p64 = asu64(R1);
	asu64(R1) = p64;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = u;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_writeexe_imagebase;
	asu64(R1) += asu64(R2);
	asu64(R2) = p64;
	*tou64p(R2) = asu64(R1);
L4501:
L4494:
	goto L4488;
L4491:
	msysc_m$print_startcon();
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't do this rel type");
	mc_libmcl_axerror(asu64(R1));
L4488:
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4486:
	asu64(R1) = r;
	if (asu64(R1)) goto L4485;
	return;
}

static void mc_writeexe_getbaserelocs(u64 s) {
    u64 R1, R2, R3, R4; 
	u64 r;
	u64 p;
	u64 d;
	i64 index;
	R1 = 0;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = s;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L4505;
L4504:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4508;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4508;
	goto L4509;
L4508:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4511;
	goto L4510;
L4511:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4513;
	goto L4512;
L4513:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	mc_writeexe_newbasereloc(asi64(R2), asi64(R1));
L4512:
L4510:
	goto L4507;
L4509:
L4507:
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4505:
	asu64(R1) = r;
	if (asu64(R1)) goto L4504;
	return;
}

static void mc_writeexe_writerecordx(u64 r, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = r;
	asu64(R3) = mc_writeexe_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&mc_writeexe_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeexe_writedosstub() {
    u64 R1, R2; 
// PROC LOCAL STATICS GO HERE
	static struct $B22 mc_writeexe_writedosstub_stubdata = {{
12894362189,
	281470681743364,
	184,
	64,
	0,
	0,
	0,
	549755813888,
	-3672206108803850482,
	7517670843615393825,
	8243680180223112041,
	8029476550202125665,
	7959393399912669300,
	2329292586301155616,
	724249607997255533,
	36    }};
	R1 = 128;
	R2 = (u64)&mc_writeexe_writedosstub_stubdata;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writepesig() {
    u64 R1, R2, R3; 
	R1 = 80;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 69;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_writeexe_writepadding(i64 offset) {
    u64 R1, R2; 
	asu64(R1) = mc_writeexe_datastart;
	asi64(R2) = offset;
	R1 += (i64)R2;
	mc_writeexe_dataptr = asu64(R1);
	return;
}

static void mc_writeexe_writefileheader() {
    u64 R1, R2, R3; 
	struct $B17 header;
	R1 = (u64)&header;
	memset(R1, 0, 20);
	R1 = 34404;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = (u64)&header;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 240;
	R2 = (u64)&header;
	R3 = 16;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 559;
	R2 = (u64)&header;
	R3 = 18;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4520;
	R1 = 8750;
	R2 = (u64)&header;
	R3 = 18;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L4520:
	R1 = 20;
	R2 = (u64)&header;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writeoptheader() {
    u64 R1, R2, R3; 
	struct $B83 header;
	R1 = (u64)&header;
	memset(R1, 0, 240);
	R1 = 523;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&header;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&header;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 2;
	R1 += (i64)R2*72-72;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	R2 = (u64)&header;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&header;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = mc_writeexe_stentrypoint;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4523;
	asu64(R1) = mc_writeexe_stentrypoint2;
	mc_writeexe_stentrypoint = asu64(R1);
L4523:
	asu64(R1) = mc_writeexe_stentrypoint;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4525;
	asu64(R1) = mc_writeexe_userentrypoint;
	if (!asu64(R1)) goto L4527;
	msysc_m$print_startcon();
	asu64(R1) = mc_writeexe_userentrypoint;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("User entry point not found");
	mc_libmcl_axerror(asu64(R1));
	goto L4526;
L4527:
	asi64(R1) = mc_writeexe_isdll;
	if (asi64(R1)) goto L4529;
	R1 = tou64("Entry point not found: main");
	mc_libmcl_axerror(asu64(R1));
L4529:
L4526:
	goto L4524;
L4525:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_writeexe_stentrypoint;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = (u64)&header;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4524:
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&header;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 32;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 512;
	R2 = (u64)&header;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 4;
	R2 = (u64)&header;
	R3 = 40;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 0;
	R2 = (u64)&header;
	R3 = 42;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&header;
	R3 = 48;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 2;
	R2 = (u64)&header;
	R3 = 50;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_imagesize;
	R2 = (u64)&header;
	R3 = 56;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 60;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = (u64)&header;
	R3 = 68;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 4194304;
	R2 = (u64)&header;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2097152;
	R2 = (u64)&header;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1048576;
	R2 = (u64)&header;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 16;
	R2 = (u64)&header;
	R3 = 108;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeexe_exportdirvirtsize;
	asi64(R1) -= asi64(R2);
	asi64(R2) = mc_writeexe_blockdirvirtsize;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&header;
	R3 = 124;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4531;
	R1 = 64;
	R2 = (u64)&header;
	R3 = 70;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_exportdirvirtaddr;
	R2 = (u64)&header;
	R3 = 112;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_exportdirvirtsize;
	R2 = (u64)&header;
	R3 = 116;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_blockdirvirtaddr;
	R2 = (u64)&header;
	R3 = 152;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_blockdirvirtsize;
	R2 = (u64)&header;
	R3 = 156;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4531:
	asi64(R1) = mc_writeexe_fileiatoffset;
	R2 = (u64)&header;
	R3 = 208;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_fileiatsize;
	R2 = (u64)&header;
	R3 = 212;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 240;
	R2 = (u64)&header;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writesectionheader(u64 s) {
    u64 R1, R2, R3; 
	struct $B71 sheader;
	i64 aa;
	R1 = (u64)&sheader;
	memset(R1, 0, 40);
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4534;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4535;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4536;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4537;
	goto L4538;
L4534:
	R1 = 3226468480;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4533;
L4535:
	R1 = 3226468416;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4533;
L4536:
	R1 = 1615855648;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4533;
L4537:
	R1 = 3224371264;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4533;
L4538:
L4533:
	R1 = 40;
	R2 = (u64)&sheader;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writesectiondata(u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = s;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4541;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4542;
	goto L4543;
L4541:
	asu64(R1) = s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L4545;
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mc_writeexe_dataptr;
	*tou64p(R2) += asu64(R1);
L4545:
	goto L4540;
L4542:
	goto L4540;
L4543:
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R3) = s;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
L4540:
	return;
}

static void mc_writeexe_writeexporttable(u64 pstart) {
    u64 R1, R2, R3; 
	struct $B49 sortindex;
	u64 phdr;
	u64 paddrtable;
	u64 pnametable;
	u64 pordtable;
	u64 pdllname;
	u64 pnames;
	i64 addrtableoffset;
	i64 nametableoffset;
	i64 ordtableoffset;
	i64 dllnameoffset;
	i64 namesoffset;
	i64 virtoffset;
	i64 sectionno;
	u64 d;
	u64 basename;
	i64 i;
	asu64(R1) = pstart;
	phdr = asu64(R1);
	R1 = 1602876664;
	asu64(R2) = phdr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = phdr;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_nexports;
	asu64(R2) = phdr;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_nexports;
	asu64(R2) = phdr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 40;
	addrtableoffset = asi64(R1);
	asi64(R1) = addrtableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 4;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	nametableoffset = asi64(R1);
	asi64(R1) = nametableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 4;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	ordtableoffset = asi64(R1);
	asi64(R1) = ordtableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	dllnameoffset = asi64(R1);
	asi64(R1) = dllnameoffset;
	asu64(R2) = mc_writeexe_dllfilename;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	namesoffset = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeexe_exportdiroffset;
	asi64(R1) += asi64(R2);
	virtoffset = asi64(R1);
	asu64(R1) = pstart;
	asi64(R2) = addrtableoffset;
	R1 += (i64)R2;
	paddrtable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = nametableoffset;
	R1 += (i64)R2;
	pnametable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = ordtableoffset;
	R1 += (i64)R2;
	pordtable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = dllnameoffset;
	R1 += (i64)R2;
	pdllname = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = namesoffset;
	R1 += (i64)R2;
	pnames = asu64(R1);
	asi64(R1) = dllnameoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = addrtableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 28;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = nametableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 32;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = ordtableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = mc_writeexe_dllfilename;
	asu64(R2) = pdllname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mc_writeexe_nexports;
	R2 = 2000;
	if (asi64(R1) <= asi64(R2)) goto L4548;
	R1 = tou64("Too many exports - can't sort");
	mc_libmcl_axerror(asu64(R1));
L4548:
	R1 = (u64)&sortindex;
	mc_writeexe_sortexports(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4551;
L4549:
	R1 = (u64)&mc_writeexe_exporttable;
	R2 = (u64)&sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&mc_writeexe_exporttable;
	R2 = (u64)&sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	basename = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R1) = mc_writeexe_getsectionno(asi64(R1));
	sectionno = asi64(R1);
	asu64(R1) = basename;
	asu64(R2) = pnames;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = namesoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = pnametable;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&pnametable;
	(*tou64p(R1)) += 4;
	asu64(R1) = basename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&namesoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = basename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&pnames;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = sectionno;
	R2 += (i64)R3*72-72;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = paddrtable;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&paddrtable;
	(*tou64p(R1)) += 4;
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pordtable;
	*tou16p(R2) = asu16(R1);
	R1 = (u64)&pordtable;
	(*tou64p(R1)) += 2;
	i += 1; if (i <= mc_writeexe_nexports) goto L4549;
L4551:
	return;
}

static i64 mc_writeexe_getexporttablesize() {
    u64 R1, R2; 
	i64 size;
	i64 i;
	R1 = 40;
	size = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = mc_writeexe_dllfilename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4555;
L4553:
	R1 = (u64)&mc_writeexe_exporttable;
	asi64(R2) = i;
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_nexports) goto L4553;
L4555:
	asi64(R1) = size;
	goto L4552;
L4552:
	return asi64(R1);
}

static void mc_writeexe_newbasereloc(i64 addr, i64 reltype) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = addr;
	asu64(R2) = p;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = reltype;
	asu64(R2) = p;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	mc_writeexe_basereloclist = asu64(R1);
	R1 = (u64)&mc_writeexe_nbaserelocs;
	(*toi64p(R1)) += 1;
	asi64(R1) = addr;
	R2 = (u64)&mc_writeexe_maxrelocaddr;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	return;
}

static void mc_writeexe_scanbaserelocs() {
    u64 R1, R2, R3; 
	i64 baseaddr;
	i64 addr;
	i64 nextblock;
	u64 p;
	i64 i;
	R1 = 4096;
	baseaddr = asi64(R1);
	R1 = 0;
	mc_writeexe_nbaseblocks = asi64(R1);
L4558:
	asi64(R1) = baseaddr;
	R2 = 4096;
	asi64(R1) += asi64(R2);
	nextblock = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 500;
	if (asi64(R1) < asi64(R2)) goto L4562;
	R1 = tou64("Too many blocks");
	mc_libmcl_axerror(asu64(R1));
L4562:
	R1 = (u64)&mc_writeexe_nbaseblocks;
	(*toi64p(R1)) += 1;
	asi64(R1) = baseaddr;
	R2 = (u64)&mc_writeexe_blockbases;
	asi64(R3) = mc_writeexe_nbaseblocks;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_blockcounts;
	asi64(R3) = mc_writeexe_nbaseblocks;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	p = asu64(R1);
	goto L4564;
L4563:
	asu64(R1) = p;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	addr = asi64(R1);
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	if (asi64(R1) < asi64(R2)) goto L4567;
	asi64(R1) = addr;
	asi64(R2) = nextblock;
	if (asi64(R1) >= asi64(R2)) goto L4567;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = mc_writeexe_nbaseblocks;
	R1 += (i64)R2*4-4;
	(*toi32p(R1)) += 1;
L4567:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4564:
	asu64(R1) = p;
	if (asu64(R1)) goto L4563;
	asi64(R1) = nextblock;
	baseaddr = asi64(R1);
	asi64(R1) = baseaddr;
	asi64(R2) = mc_writeexe_maxrelocaddr;
	if (asi64(R1) <= asi64(R2)) goto L4558;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4570;
L4568:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	if (!asi32(R1)) goto L4572;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4574;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	R1 += (i64)R2*4-4;
	(*toi32p(R1)) += 1;
	R1 = (u64)&mc_writeexe_blockpadding;
	asi64(R2) = i;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L4574:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 8;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeexe_blockbytes;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&mc_writeexe_blockbytes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_writeexe_basetablesize;
	*toi64p(R2) += asi64(R1);
L4572:
	i += 1; if (i <= mc_writeexe_nbaseblocks) goto L4568;
L4570:
	return;
}

static void mc_writeexe_writebasereloctable(u64 pstart) {
    u64 R1, R2, R3; 
	u64 p32;
	u64 p16;
	i64 baseaddr;
	i64 addr;
	i64 nextblock;
	u64 q;
	i64 i;
	asu64(R1) = pstart;
	p32 = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4578;
L4576:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	if (!asi32(R1)) goto L4580;
	R1 = (u64)&mc_writeexe_blockbases;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&p32;
	(*tou64p(R1)) += 4;
	R1 = (u64)&mc_writeexe_blockbytes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&p32;
	(*tou64p(R1)) += 4;
	asu64(R1) = p32;
	p16 = asu64(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	q = asu64(R1);
	R1 = (u64)&mc_writeexe_blockbases;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	baseaddr = asi64(R1);
	asi64(R1) = baseaddr;
	R2 = 4096;
	asi64(R1) += asi64(R2);
	nextblock = asi64(R1);
	goto L4582;
L4581:
	asu64(R1) = q;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	addr = asi64(R1);
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	if (asi64(R1) < asi64(R2)) goto L4585;
	asi64(R1) = addr;
	asi64(R2) = nextblock;
	if (asi64(R1) >= asi64(R2)) goto L4585;
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = q;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 2;
	if (asi64(R2) != asi64(R3)) goto L4587;
	R2 = 3;
	goto L4586;
L4587:
	R2 = 10;
L4586:
	R3 = 12;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = p16;
	*tou16p(R2) = asu16(R1);
	R1 = (u64)&p16;
	(*tou64p(R1)) += 2;
L4585:
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L4582:
	asu64(R1) = q;
	if (asu64(R1)) goto L4581;
	R1 = (u64)&mc_writeexe_blockpadding;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4589;
	R1 = 0;
	R2 = (u64)&p16;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 2; asu64(R2) = asu64(R3);
	*tou16p(R2) = asu16(R1);
L4589:
	asu64(R1) = p16;
	p32 = asu64(R1);
L4580:
	i += 1; if (i <= mc_writeexe_nbaseblocks) goto L4576;
L4578:
	return;
}

static void mc_writeexe_sortexports(u64 sortindex) {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	i64 swapped;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4593;
L4591:
	asi64(R1) = i;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	i += 1; if (i <= mc_writeexe_nexports) goto L4591;
L4593:
L4594:
	R1 = 0;
	swapped = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4599;
L4597:
	R1 = (u64)&mc_writeexe_exporttable;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&mc_writeexe_exporttable;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4601;
	R1 = 1;
	swapped = asi64(R1);
	asu64(R1) = sortindex;
	asi64(R2) = i;
	R1 += (i64)R2*8-8;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	R2 += (i64)R3*8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L4601:
	i += 1; if (i <= av_1) goto L4597;
L4599:
	asi64(R1) = swapped;
	if (asi64(R1)) goto L4594;
	return;
}

static i64 mc_writeexe_getsectionno(i64 segment) {
    u64 R1, R2; 
	asi64(R1) = segment;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4604;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4605;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4606;
	goto L4607;
L4604:
	R1 = 3;
	goto L4603;
L4605:
	R1 = 2;
	goto L4603;
L4606:
	R1 = 1;
	goto L4603;
L4607:
	R1 = tou64("GSN");
	mc_libmcl_axerror(asu64(R1));
	R1 = 0;
L4603:
	goto L4602;
L4602:
	return asi64(R1);
}

static void mc_writeexe_getoffsets() {
    u64 R1, R2, R3, R4; 
	i64 fileoffset;
	i64 imageoffset;
	i64 i;
	i64 diroffset;
	i64 impdirno;
	i64 hinttableoffset;
	i64 j;
	i64 n;
	i64 codesize;
	i64 length;
	i64 thunkoffset;
	i64 offset;
	i64 dirstartoffset;
	u64 pcode;
	u64 pimpdir;
	u64 pdir;
	u64 paddr;
	u64 pname;
	i64 iatoffset;
	u64 phint;
	u64 pextra;
	i64 xxx;
	i64 av_1;
	u64 thunkptr;
	u64 codebase;
	i64 thunkaddr;
	R1 = 392;
	fileoffset = asi64(R1);
	R1 = 40;
	asi64(R2) = mc_writeexe_nsections;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&fileoffset;
	*toi64p(R2) += asi64(R1);
	R1 = 512;
	asi64(R2) = fileoffset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	fileoffset = asi64(R1);
	R1 = 4096;
	imageoffset = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	codesize = asi64(R1);
	asi64(R1) = codesize;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	pcode = asu64(R1);
	goto L4610;
L4609:
	R1 = 144;
	R2 = (u64)&pcode;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&codesize;
	(*toi64p(R1)) += 1;
L4610:
	asi64(R1) = codesize;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4609;
	asi64(R1) = codesize;
	thunkoffset = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&codesize;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = codesize;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = codesize;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = codesize;
	asi64(R2) = thunkoffset;
	asi64(R1) -= asi64(R2);
	R2 = 16;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_decls_ss_code;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4614;
L4612:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4616;
	asi64(R1) = fileoffset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = i;
	R2 += (i64)R3*72-72;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4616:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4618;
	R1 = 512;
	asi64(R2) = fileoffset;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = i;
	R3 += (i64)R4*72-72;
	R4 = 40;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	fileoffset = asi64(R1);
L4618:
	asi64(R1) = imageoffset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = i;
	R2 += (i64)R3*72-72;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4620;
	asi64(R1) = imageoffset;
	diroffset = asi64(R1);
	asi64(R1) = i;
	impdirno = asi64(R1);
L4620:
	R1 = 4096;
	asi64(R2) = imageoffset;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = i;
	R3 += (i64)R4*72-72;
	R4 = 40;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	imageoffset = asi64(R1);
	i += 1; if (i <= mc_writeexe_nsections) goto L4612;
L4614:
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4622;
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writeexe_getbaserelocs(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writeexe_getbaserelocs(asu64(R1));
L4622:
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 20;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4625;
L4623:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4623;
L4625:
	asi64(R1) = diroffset;
	mc_writeexe_fileiatoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4628;
L4626:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4626;
L4628:
	asi64(R1) = diroffset;
	asi64(R2) = mc_writeexe_fileiatoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_fileiatsize = asi64(R1);
	asi64(R1) = diroffset;
	hinttableoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4631;
L4629:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	R1 += (i64)R2*48;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 3;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4633;
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L4633:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_nimports) goto L4629;
L4631:
	R1 = 4;
	asi64(R2) = diroffset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	diroffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4636;
L4634:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4638;
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L4638:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4634;
L4636:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = impdirno;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	dirstartoffset = asi64(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4640;
	asi64(R1) = diroffset;
	mc_writeexe_exportdirvirtaddr = asi64(R1);
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_exportdiroffset = asi64(R1);
	asi64(R1) = mc_writeexe_getexporttablesize();
	mc_writeexe_exportdirvirtsize = asi64(R1);
	asi64(R1) = mc_writeexe_exportdirvirtsize;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	mc_writeexe_scanbaserelocs();
	asi64(R1) = diroffset;
	mc_writeexe_blockdirvirtaddr = asi64(R1);
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_blockdiroffset = asi64(R1);
	asi64(R1) = mc_writeexe_basetablesize;
	mc_writeexe_blockdirvirtsize = asi64(R1);
	asi64(R1) = mc_writeexe_blockdirvirtsize;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
L4640:
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = impdirno;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = offset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = impdirno;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = fileoffset;
	asi64(R3) = offset;
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_writeexe_filesize = asi64(R1);
	R1 = 4096;
	asi64(R2) = imageoffset;
	asi64(R3) = diroffset;
	asi64(R4) = dirstartoffset;
	asi64(R3) -= asi64(R4);
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_writeexe_imagesize = asi64(R1);
	asi64(R1) = offset;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	R2 = R1;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = impdirno;
	R3 += (i64)R4*72-72;
	R4 = 0;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	pimpdir = asu64(R1);
	asu64(R1) = pimpdir;
	pdir = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4643;
L4641:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pdir;
	(*tou64p(R1)) += 20;
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	iatoffset = asi64(R1);
	asu64(R1) = pimpdir;
	asi64(R2) = iatoffset;
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	paddr = asu64(R1);
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	pname = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4646;
L4644:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = j;
	R1 += (i64)R2*48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L4648;
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = j;
	R1 += (i64)R2*48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = paddr;
	*toi64p(R3) = asi64(R2);
	asu64(R2) = pname;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = iatoffset;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = j;
	R2 += (i64)R3*48;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	R2 = (u64)&iatoffset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&pname;
	(*tou64p(R1)) += 8;
	R1 = (u64)&paddr;
	(*tou64p(R1)) += 8;
L4648:
	j += 1; if (j <= mc_writeexe_nimports) goto L4644;
L4646:
	i += 1; if (i <= mc_writeexe_ndlls) goto L4641;
L4643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4651;
L4649:
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	phint = asu64(R1);
	R1 = 2;
	R2 = (u64)&phint;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	R1 += (i64)R2*48;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = phint;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_writeexe_nimports) goto L4649;
L4651:
	asi64(R1) = dirstartoffset;
	xxx = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4654;
L4652:
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	pextra = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4657;
L4655:
	asi64(R1) = xxx;
	asu64(R2) = pextra;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&pextra;
	(*tou64p(R1)) += 4;
	j += 1; if (j <= av_1) goto L4655;
L4657:
	R1 = 20;
	R2 = (u64)&xxx;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	phint = asu64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = phint;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_writeexe_ndlls) goto L4652;
L4654:
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4659;
	asu64(R1) = pimpdir;
	asi64(R2) = mc_writeexe_exportdiroffset;
	R1 += (i64)R2;
	mc_writeexe_writeexporttable(asu64(R1));
	asu64(R1) = pimpdir;
	asi64(R2) = mc_writeexe_blockdiroffset;
	R1 += (i64)R2;
	mc_writeexe_writebasereloctable(asu64(R1));
L4659:
	asi64(R1) = thunkoffset;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	thunkptr = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codebase = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4662;
L4660:
	asu64(R1) = thunkptr;
	asu64(R2) = codebase;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4664;
	R1 = 72;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 36;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	thunkaddr = asi64(R1);
	asi64(R1) = thunkaddr;
	asu64(R2) = thunkptr;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&thunkptr;
	*tou64p(R2) += asu64(R1);
	goto L4663;
L4664:
	R1 = 72;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	thunkaddr = asi64(R1);
	R1 = 0;
	asi64(R2) = thunkaddr;
	asi64(R3) = mc_writeexe_imagebase;
	asi64(R2) -= asi64(R3);
	asu64(R3) = thunkptr;
	asu64(R4) = codebase;
	asi64(R3) -= asi64(R4);
	asi64(R1) = mc_writeexe_getripoffset(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = thunkptr;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&thunkptr;
	*tou64p(R2) += asu64(R1);
	R1 = 144;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4663:
	i += 1; if (i <= mc_writeexe_nimports) goto L4660;
L4662:
	return;
}

static i64 mc_writeexe_getripoffset(i64 addr, i64 dest, i64 extra) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&addr;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = dest;
	asi64(R2) = addr;
	R3 = 4;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) -= asi64(R2);
	goto L4665;
L4665:
	return asi64(R1);
}

static void mc_writeobj_writecoff(u64 outfile) {
    u64 R1, R2, R3; 
	struct $B17 header;
	struct $B71 zsection;
	struct $B71 isection;
	struct $B71 csection;
	i64 offset;
	i64 aa;
	asu8(R1) = pc_decls_objdone;
	if (!asu8(R1)) goto L4668;
	goto L4666;
L4668:
	R1 = (u64)&header;
	memset(R1, 0, 20);
	R1 = (u64)&zsection;
	memset(R1, 0, 40);
	R1 = (u64)&isection;
	memset(R1, 0, 40);
	R1 = (u64)&csection;
	memset(R1, 0, 40);
	R1 = 34404;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3;
	R2 = (u64)&header;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = tou64(".bss");
	R2 = (u64)&zsection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&zsection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3225419904;
	R2 = (u64)&zsection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = 65536;
	if (asi64(R1) >= asi64(R2)) goto L4671;
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L4670;
L4671:
	R1 = tou64("Too many relocs (exceeds 16-bit field)");
	mc_libmcl_axerror(asu64(R1));
L4670:
	R1 = tou64(".data");
	R2 = (u64)&isection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&isection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = (u64)&isection;
	R3 = 32;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3226468416;
	R2 = (u64)&isection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = tou64(".text");
	R2 = (u64)&csection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&csection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = (u64)&csection;
	R3 = 32;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1615855648;
	R2 = (u64)&csection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = outfile;
	mc_writeobj_initsymboltable(asu64(R1));
	mc_writeobj_convertsymboltable();
	R1 = 20;
	offset = asi64(R1);
	R1 = 120;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&isection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L4673;
	asi64(R1) = offset;
	R2 = (u64)&isection;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&isection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4673:
	R1 = (u64)&csection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L4675;
	asi64(R1) = offset;
	R2 = (u64)&csection;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&csection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4675:
	asi64(R1) = offset;
	R2 = (u64)&isection;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&isection;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&csection;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&csection;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&header;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 18;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = (u64)&header;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeobj_nextstringoffset;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	asu64(R1) = malloc(asu64(R1));
	R2 = R1;
	mc_writeobj_dataptr = asu64(R2);
	mc_writeobj_datastart = asu64(R1);
	R1 = 20;
	R2 = (u64)&header;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&zsection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&isection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&csection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asu64(R2) = mc_decls_ss_idatarelocs;
	mc_writeobj_writerelocs(asu64(R2), asi64(R1));
	asi64(R1) = mc_decls_ss_ncoderelocs;
	asu64(R2) = mc_decls_ss_coderelocs;
	mc_writeobj_writerelocs(asu64(R2), asi64(R1));
	asu64(R1) = mc_decls_ss_idata;
	mc_writeobj_writedata(asu64(R1));
	asu64(R1) = mc_decls_ss_code;
	mc_writeobj_writedata(asu64(R1));
	mc_writeobj_writesymboltable();
	mc_writeobj_writestringtable();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L4677;
	msysc_m$print_startcon();
	R1 = tou64("Writing file:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4677:
	asu64(R1) = mc_writeobj_dataptr;
	asu64(R2) = mc_writeobj_datastart;
	asi64(R1) -= asi64(R2);
	asu64(R2) = mc_writeobj_datastart;
	asu64(R3) = outfile;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	pc_decls_objdone = asu8(R1);
L4666:
	return;
}

static void mc_writeobj_writerecord(u64 r, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = r;
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeobj_writerelocs(u64 r, i64 nrelocs) {
    u64 R1, R2, R3; 
	u64 d;
	asi64(R1) = nrelocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4681;
	goto L4679;
L4681:
	goto L4683;
L4682:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4686;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4686;
	goto L4687;
L4686:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4689;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4690;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4691;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4692;
	goto L4693;
L4689:
	R1 = 2;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4688;
L4690:
	R1 = 4;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4688;
L4691:
	R1 = 6;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4688;
L4692:
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeobj_stoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4688;
L4693:
	R1 = tou64("wrelocs/bad seg");
	mc_libmcl_axerror(asu64(R1));
L4688:
	goto L4685;
L4687:
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeobj_stoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4685:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4695;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4696;
	goto L4697;
L4695:
	goto L4694;
L4696:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4699;
	R1 = 4;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 4;
	asu64(R2) = r;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4699:
	goto L4694;
L4697:
	R1 = tou64("OBJ/phighmem 1?");
	mc_libmcl_axerror(asu64(R1));
L4694:
	asu64(R1) = r;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4683:
	asu64(R1) = r;
	if (asu64(R1)) goto L4682;
L4679:
	return;
}

static void mc_writeobj_writedata(u64 data) {
    u64 R1, R2, R3; 
	asu64(R1) = data;
	asu64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = 0;
	asu64(R3) = data;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = data;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeobj_writesymboltable() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4704;
L4702:
	R1 = 18;
	R2 = (u64)&mc_writeobj_symboltable;
	asi64(R3) = i;
	R2 += (i64)R3*18;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	i += 1; if (i <= mc_writeobj_nsymbols) goto L4702;
L4704:
	return;
}

static void mc_writeobj_writestringtable() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	i64 n;
	asu64(R1) = mc_writeobj_dataptr;
	p = asu64(R1);
	asi64(R1) = mc_writeobj_nextstringoffset;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeobj_nstrings;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4708;
L4706:
	R1 = (u64)&mc_writeobj_stringlengths;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = (u64)&mc_writeobj_stringtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	i += 1; if (i <= mc_writeobj_nstrings) goto L4706;
L4708:
	return;
}

static u64 mc_writeobj_makesymbol(u64 name, i64 value, i64 sectionno, i64 symtype, i64 storage, i64 naux) {
    u64 R1, R2, R3, R4; 
	i64 length;
	i64 namelen;
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	namelen = asi64(R1);
	asi64(R1) = namelen;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L4711;
	asu64(R1) = name;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4710;
L4711:
	asi64(R1) = namelen;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4712;
	asi64(R1) = namelen;
	asu64(R2) = name;
	R3 = (u64)&mc_writeobj_makesymbol_r;
	R4 = 0;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L4710;
L4712:
	R1 = 0;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = namelen;
	asu64(R2) = name;
	asi64(R1) = mc_writeobj_addstringentry(asu64(R2), asi64(R1));
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4710:
	asi64(R1) = value;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = sectionno;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = symtype;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 14;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = storage;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = naux;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_writeobj_makesymbol_r;
	goto L4709;
L4709:
	return asu64(R1);
}

static void mc_writeobj_addsymbol(u64 r) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 13000;
	if (asi64(R1) < asi64(R2)) goto L4715;
	R1 = tou64("as:Too many symbols");
	mc_libmcl_axerror(asu64(R1));
L4715:
	R1 = 18;
	asu64(R2) = r;
	R3 = (u64)&mc_writeobj_symboltable;
	R4 = (u64)&mc_writeobj_nsymbols;
	asi64(R4) = *(toi64p(R4)) += 1;
	R3 += (i64)R4*18;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_writeobj_initsymboltable(u64 filename) {
    u64 R1, R2, R3, R4, R5, R6; 
	R1 = 0;
	mc_writeobj_nsymbols = asi64(R1);
	R1 = 1;
	R2 = 103;
	R3 = 0;
	R4 = -2;
	R5 = 0;
	R6 = tou64(".file");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asu64(R1) = filename;
	asu64(R1) = mc_writeobj_strtoaux(asu64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 1;
	R5 = 0;
	R6 = tou64(".bss");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 2;
	R5 = 0;
	R6 = tou64(".data");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asu64(R2) = mc_decls_ss_idata;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 3;
	R5 = 0;
	R6 = tou64(".text");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asi64(R1) = mc_decls_ss_ncoderelocs;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	return;
}

static u64 mc_writeobj_strtoaux(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	i64 n;
	R1 = (u64)&mc_writeobj_strtoaux_r;
	p = asu64(R1);
	R1 = 18;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 0;
	n = asi64(R1);
	goto L4719;
L4718:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L4719:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4721;
	asi64(R1) = n;
	R2 = 18;
	if (asi64(R1) < asi64(R2)) goto L4718;
L4721:
	R1 = (u64)&mc_writeobj_strtoaux_r;
	goto L4717;
L4717:
	return asu64(R1);
}

static u64 mc_writeobj_sectiontoaux(u64 data, i64 nrelocs) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_writeobj_sectiontoaux_r;
	memset(R1, 0, 18);
	asu64(R1) = data;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4724;
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4723;
L4724:
	asu64(R1) = data;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4723:
	asi64(R1) = nrelocs;
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 4;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mc_writeobj_sectiontoaux_r;
	goto L4722;
L4722:
	return asu64(R1);
}

static i64 mc_writeobj_addstringentry(u64 s, i64 length) {
    u64 R1, R2, R3; 
	i64 offset;
	asi64(R1) = mc_writeobj_nextstringoffset;
	offset = asi64(R1);
	asi64(R1) = mc_writeobj_nstrings;
	R2 = 5000;
	if (asi64(R1) <= asi64(R2)) goto L4727;
	R1 = tou64("W:too many strings");
	mc_libmcl_axerror(asu64(R1));
L4727:
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeobj_stringtable;
	R3 = (u64)&mc_writeobj_nstrings;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = length;
	R2 = (u64)&mc_writeobj_stringlengths;
	asi64(R3) = mc_writeobj_nstrings;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_nextstringoffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	goto L4725;
L4725:
	return asi64(R1);
}

static void mc_writeobj_convertsymboltable() {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 s;
	u64 name;
	i64 i;
	i64 sect;
	i64 scope;
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mc_writeobj_stoffset = asi64(R1);
	R1 = 0;
	mc_writeobj_nstrings = asi64(R1);
	R1 = 4;
	mc_writeobj_nextstringoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4731;
L4729:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = s;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4733;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4734;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4735;
	goto L4736;
L4733:
	R1 = 1;
	sect = asi64(R1);
	goto L4732;
L4734:
	R1 = 2;
	sect = asi64(R1);
	goto L4732;
L4735:
	R1 = 3;
	sect = asi64(R1);
	goto L4732;
L4736:
	R1 = 0;
	sect = asi64(R1);
L4732:
	asu64(R1) = s;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4738;
	R1 = 0;
	sect = asi64(R1);
L4738:
	R1 = 0;
	scope = asi64(R1);
	asu64(R1) = s;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4741;
	asu64(R1) = s;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4740;
L4741:
	R1 = 2;
	scope = asi64(R1);
	goto L4739;
L4740:
	R1 = 3;
	scope = asi64(R1);
L4739:
	asu64(R1) = s;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4743;
	asu64(R1) = name;
	asu64(R1) = pc_api_getbasename(asu64(R1));
	name = asu64(R1);
L4743:
	R1 = 0;
	asi64(R2) = scope;
	R3 = 0;
	asi64(R4) = sect;
	asu64(R5) = s;
	R6 = 76;
	asi32(R5) = *toi32p(((i64)R5+(i64)R6));
	R5 = toi64(toi32(R5));
	asu64(R6) = name;
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4729;
L4731:
	return;
}

static u64 mc_writess_dummy_writessdata(i64 fexe) {
    u64 R1; 
	R1 = 0;
	goto L4744;
L4744:
	return asu64(R1);
}

static u64 mx_run_writememlib(u64 filename) {
    u64 R1, R2, R3; 
	u64 plib;
	i64 n;
	i64 k;
	struct $B84 lib;
	i64 ndlls;
	i64 nlibs;
	i64 i;
	R1 = (u64)&lib;
	memset(R1, 0, 216);
	R1 = 8;
	asi64(R2) = mc_decls_ss_zdatalen;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 144;
	R2 = 8;
	asu64(R3) = mc_decls_ss_code;
	mx_run_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	asu64(R3) = mc_decls_ss_idata;
	mx_run_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("0.1234");
	R2 = (u64)&lib;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&lib;
	R3 = 184;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 192;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&lib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	mx_run_countsymbols();
	R1 = (u64)&lib;
	mx_run_writerelocs(asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&lib;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&lib;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&lib;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = (u64)&lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_idata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = (u64)&lib;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	ndlls = asi64(R1);
	R1 = 0;
	nlibs = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4748;
L4746:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4750;
	R1 = (u64)&ndlls;
	(*toi64p(R1)) += 1;
L4750:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4746;
L4748:
	asi64(R1) = ndlls;
	R2 = (u64)&lib;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = nlibs;
	R2 = (u64)&lib;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = ndlls;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asi64(R2) = nlibs;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4753;
L4751:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4755;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&lib;
	R3 = 96;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4755:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4751;
L4753:
	R1 = (u64)&lib;
	mx_run_addsymbols(asu64(R1));
	R1 = 216;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	plib = asu64(R1);
	R1 = 216;
	R2 = (u64)&lib;
	asu64(R3) = plib;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = plib;
	goto L4745;
L4745:
	return asu64(R1);
}

static void mx_run_roundsegment(u64 p, i64 align, i64 value) {
    u64 R1, R2, R3; 
	i64 length;
	i64 newlength;
	i64 av_1;
	asu64(R1) = p;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	length = asi64(R1);
	asi64(R1) = align;
	asi64(R2) = length;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newlength = asi64(R1);
	asi64(R1) = align;
	asu64(R2) = p;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = newlength;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4759;
L4757:
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L4757;
L4759:
	return;
}

static void mx_run_writerelocs(u64 lib) {
    u64 R1, R2, R3; 
	u64 oldr;
	u64 newr;
	i64 n;
	i64 k;
	u64 d;
	u64 baseptr64;
	i64 i;
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asi64(R2) = mc_decls_ss_ncoderelocs;
	asi64(R1) += asi64(R2);
	asu64(R2) = lib;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4761:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4765;
	asu64(R1) = mc_decls_ss_idatarelocs;
	goto L4764;
L4765:
	asu64(R1) = mc_decls_ss_coderelocs;
L4764:
	oldr = asu64(R1);
	goto L4769;
L4766:
	R1 = (u64)&newr;
	memset(R1, 0, 8);
	asu64(R1) = oldr;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4771;
	R1 = 2;
	goto L4770;
L4771:
	R1 = 1;
L4770:
	R2 = (u64)&newr;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = oldr;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4773;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4774;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4774;
	goto L4775;
L4773:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4777;
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4776;
L4777:
	R1 = tou64("rel32/rel not imported");
	mc_libmcl_axerror(asu64(R1));
L4776:
	goto L4772;
L4774:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4779;
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4781;
	R1 = 3;
	goto L4780;
L4781:
	R1 = 4;
L4780:
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L4778;
L4779:
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4783;
	R1 = 1;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4782;
L4783:
	R1 = 2;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4782:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4778:
	goto L4772;
L4775:
	R1 = tou64("reloc?");
	mc_libmcl_axerror(asu64(R1));
L4772:
	asu64(R1) = newr;
	asu64(R2) = lib;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = oldr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	oldr = asu64(R1);
L4769:
	asu64(R1) = oldr;
	if (asu64(R1)) goto L4766;
	i += 1; if (i <= 2) goto L4761;
	return;
}

static void mx_run_addsymbols(u64 lib) {
    u64 R1, R2, R3; 
	u64 d;
	u64 stentry;
	u64 epoffset;
	i64 n;
	i64 k;
	u64 name;
	i64 i;
	R1 = 0;
	stentry = asu64(R1);
	R1 = -1;
	epoffset = asu64(R1);
	asi64(R1) = mx_decls_nsymimports;
	asu64(R2) = lib;
	R3 = 56;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mx_decls_nsymexports;
	asu64(R2) = lib;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mx_decls_nsymimports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 120;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4787;
L4785:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4789;
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 112;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4789:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4785;
L4787:
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4792;
L4790:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4794;
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4796;
	asu64(R1) = d;
	stentry = asu64(R1);
L4796:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 120;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 128;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = k;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4794:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4790;
L4792:
	asu64(R1) = stentry;
	if (!asu64(R1)) goto L4798;
	asu64(R1) = stentry;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4797;
L4798:
	msysc_m$print_startcon();
	R1 = tou64("NO MAIN FOUND");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = -1;
	asu64(R2) = lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4797:
	return;
}

static void mx_run_countsymbols() {
    u64 R1, R2, R3; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4802;
L4800:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4804;
	R1 = (u64)&mx_decls_nsymexports;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 118;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4804:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4806;
	R1 = (u64)&mx_decls_nsymimports;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4806:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4800;
L4802:
	return;
}

static void mx_run_runlibfile(u64 filename, i64 cmdskip) {
    u64 R1, R2; 
	u64 plib;
	asu64(R1) = filename;
	asu64(R1) = mx_run_writememlib(asu64(R1));
	plib = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadmemmcu(asu64(R1));
	asu64(R1) = plib;
	mx_lib_fixuplib(asu64(R1));
	asi64(R1) = cmdskip;
	asu64(R2) = plib;
	mx_lib_runprogram(asu64(R2), asi64(R1));
	return;
}

static u64 mx_lib_readlibfile(u64 filespec, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 plib;
	struct $B84 lib;
	u64 sig;
	i64 dir;
	i64 n;
	i64 tablesize;
	u64 q;
	i64 i;
	R1 = (u64)&lib;
	memset(R1, 0, 216);
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	sig = asu64(R1);
	asu64(R1) = sig;
	R2 = 441992013;
	if (asu64(R1) == asu64(R2)) goto L4810;
	msysc_m$print_startcon();
	R1 = tou64("Bad sig - not MCX file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L4810:
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 184;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 192;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4811:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readbyte(asu64(R1));
	R2 = R1;
	dir = asi64(R2);
	switch (asi64(R1)) {
	case 0: goto L4846;
	case 1: goto L4815;
	case 2: goto L4818;
	case 3: goto L4817;
	case 4: goto L4816;
	case 5: goto L4843;
	case 6: goto L4819;
	case 7: goto L4823;
	case 8: goto L4827;
	case 9: goto L4831;
	case 10: goto L4835;
	case 11: goto L4839;
	case 12: goto L4844;
	case 13: goto L4845;
	default: goto L4814;
    };
// SWITCH
L4815:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4811;
L4816:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4811;
L4817:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = (u64)&lib;
	R4 = 80;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4811;
L4818:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4811;
L4819:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4822;
L4820:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4820;
L4822:
	goto L4811;
L4823:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4826;
L4824:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4824;
L4826:
	goto L4811;
L4827:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 56;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4830;
L4828:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 112;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4828;
L4830:
	goto L4811;
L4831:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 120;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4834;
L4832:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 120;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4832;
L4834:
	goto L4811;
L4835:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4838;
L4836:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readbyte(asu64(R1));
	R2 = (u64)&lib;
	R3 = 128;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L4836;
L4838:
	goto L4811;
L4839:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	n = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4842;
L4840:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4840;
L4842:
	goto L4811;
L4843:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = (u64)&lib;
	R4 = 88;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4811;
L4844:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4811;
L4845:
	goto L4812;
	goto L4811;
L4846:
	goto L4811;
L4814:
	msysc_m$print_startcon();
	R1 = tou64("Unknown directive:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mx_decls_mcxdirnames;
	asi64(R2) = dir;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
	goto L4811;
L4812:
	R1 = 216;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	plib = asu64(R1);
	R1 = 216;
	R2 = (u64)&lib;
	asu64(R3) = plib;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = plib;
	goto L4808;
L4808:
	return asu64(R1);
}

static i64 mx_lib_readbyte(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L4847;
L4847:
	return asi64(R1);
}

static u64 mx_lib_readu32(u64 p) {
    u64 R1, R2; 
	u64 x;
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu32(R1) = *tou32p(R1);
	R1 = tou64(tou32(R1));
	x = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = x;
	goto L4848;
L4848:
	return asu64(R1);
}

static u64 mx_lib_readstring(u64 p) {
    u64 R1; 
	u64 s;
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	s = asu64(R1);
	goto L4851;
L4850:
L4851:
	asu64(R1) = p;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L4850;
	asu64(R1) = p;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	goto L4849;
L4849:
	return asu64(R1);
}

static void mx_lib_alloclibdata(u64 lib) {
    u64 R1, R2, R3, R4; 
	i64 tablesize;
	i64 n;
	u64 p;
	asu64(R1) = lib;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = lib;
	R3 = 152;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	tablesize = asi64(R1);
	asu64(R1) = lib;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = tablesize;
	asi64(R1) += asi64(R2);
	asu64(R1) = mwindows_os_allocexecmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4855;
	R1 = tou64("");
	R2 = tou64("Can't alloc code memory");
	mx_lib_error(asu64(R2), asu64(R1));
L4855:
	asi64(R1) = n;
	asu64(R2) = lib;
	R3 = 72;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = tablesize;
	R2 = 0;
	asu64(R3) = p;
	asi64(R4) = n;
	R3 += (i64)R4;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = tablesize;
	asu64(R2) = lib;
	R3 = 160;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asu64(R2) = lib;
	R3 = 64;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 168;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = lib;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 176;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 144;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4294967295;
	if (asi64(R1) == asi64(R2)) goto L4857;
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 144;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = lib;
	R3 = 200;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4857:
	return;
}

static void mx_lib_error(u64 mess, u64 param) {
    u64 R1; 
	asu64(R1) = param;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L4860;
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L4859;
L4860:
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4859:
	msysc_m$print_startcon();
	R1 = tou64("Aborting");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mx_lib_loadmemmcu(u64 lib) {
    u64 R1, R2, R3; 
	i64 newlib;
	u64 name;
	asu64(R1) = lib;
	R2 = 192;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = lib;
	R2 = 184;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asu64(R1) = lib;
	R2 = (u64)&mx_decls_libtable;
	asi64(R3) = newlib;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lib;
	mx_lib_loadimports(asu64(R1));
	return;
}

static void mx_lib_checknew(u64 name, u64 filename) {
    u64 R1, R2; 
	asu64(R1) = name;
	asi64(R1) = mx_lib_findlib(asu64(R1));
	if (!asi64(R1)) goto L4864;
	asu64(R1) = filename;
	R2 = tou64("Lib already exists:");
	mx_lib_error(asu64(R2), asu64(R1));
L4864:
	return;
}

static i64 mx_lib_findlib(u64 name) {
    u64 R1, R2; 
	i64 n;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4868;
L4866:
	R1 = (u64)&mx_decls_libnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4870;
	asi64(R1) = i;
	goto L4865;
L4870:
	i += 1; if (i <= mx_decls_nlibs) goto L4866;
L4868:
	R1 = 0;
	goto L4865;
L4865:
	return asi64(R1);
}

static i64 mx_lib_mxaddlib(u64 name) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mx_decls_nlibs;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4873;
	R1 = tou64("");
	R2 = tou64("Too many libs");
	mx_lib_error(asu64(R2), asu64(R1));
L4873:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_libnametable;
	R3 = (u64)&mx_decls_nlibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mx_decls_nlibs;
	goto L4871;
L4871:
	return asi64(R1);
}

static void mx_lib_fixuplib(u64 lib) {
	mx_lib_loaddlls();
	mx_lib_checksymbols();
	mx_lib_dorelocations();
	return;
}

static void mx_lib_loaddlls() {
    u64 R1, R2, R3; 
	u64 inst;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4878;
L4876:
	R1 = (u64)&mx_decls_dllinsttable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L4880;
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mwindows_os_getdllinst(asu64(R1));
	inst = asu64(R1);
	asu64(R1) = inst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4882;
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't find DLL: #");
	mx_lib_error(asu64(R2), asu64(R1));
L4882:
	asu64(R1) = inst;
	R2 = (u64)&mx_decls_dllinsttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4880:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4876;
L4878:
	return;
}

static u64 mx_lib_finddllsymbol(u64 name, u64 dllindex) {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	R1 = 0;
	asu64(R2) = dllindex;
	*toi64p(R2) = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4886;
L4884:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_dllinsttable;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mwindows_os_getdllprocaddr(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L4888;
	asi64(R1) = i;
	asu64(R2) = dllindex;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	goto L4883;
L4888:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4884;
L4886:
	R1 = 0;
	goto L4883;
L4883:
	return asu64(R1);
}

static void mx_lib_checksymbols() {
    u64 R1, R2, R3; 
	i64 dllindex;
	i64 undef;
	u64 p;
	i64 i;
	R1 = 0;
	undef = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4892;
L4890:
	R1 = (u64)&mx_decls_symboldefined;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4894;
	R1 = (u64)&dllindex;
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mx_lib_finddllsymbol(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L4896;
	asu64(R1) = p;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = dllindex;
	R2 = (u64)&mx_decls_symboldllindex;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mx_decls_symboldefined;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L4895;
L4896:
	msysc_m$print_startcon();
	R1 = tou64("Undef");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mx_decls_symbolnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&undef;
	(*toi64p(R1)) += 1;
L4895:
L4894:
	i += 1; if (i <= mx_decls_nsymbols) goto L4890;
L4892:
	asi64(R1) = undef;
	if (!asi64(R1)) goto L4898;
L4898:
	return;
}

static void mx_lib_dorelocations() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4902;
L4900:
	R1 = (u64)&mx_decls_librelocated;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4904;
	R1 = (u64)&mx_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_reloclib(asu64(R1));
L4904:
	i += 1; if (i <= mx_decls_nlibs) goto L4900;
L4902:
	return;
}

static void mx_lib_reloclib(u64 lib) {
    u64 R1, R2, R3, R4; 
	i64 index;
	i64 targetoffset;
	u64 name;
	u64 p;
	u64 q;
	u64 qaddr;
	u64 r;
	i64 av_1;
	i64 av_2;
	i64 i;
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = lib;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	qaddr = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4908;
L4906:
	asu64(R1) = lib;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 72;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 36;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = qaddr;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	R1 = 4;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&qaddr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*tou64p(R2) = asu64(R1);
	i += 1; if (i <= av_1) goto L4906;
L4908:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4911;
L4909:
	asu64(R1) = lib;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	r = asu64(R1);
	R1 = (u64)&r;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4913;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4914;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4915;
	goto L4916;
L4913:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4912;
L4914:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4912;
L4915:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4912;
L4916:
L4912:
	R1 = (u64)&r;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4918;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4919;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4920;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4921;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4922;
	goto L4923;
L4918:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	targetoffset = asi64(R1);
	R1 = (u64)&r;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4925;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4926;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4927;
	goto L4928;
L4925:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4924;
L4926:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4924;
L4927:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4924;
L4928:
L4924:
	goto L4917;
L4919:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	targetoffset = asi64(R1);
	R1 = (u64)&r;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4930;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4931;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4932;
	goto L4933;
L4930:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4929;
L4931:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4929;
L4932:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4929;
L4933:
L4929:
	goto L4917;
L4920:
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 4;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
	goto L4917;
L4921:
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 4;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	*tou32p(R2) += asu32(R1);
	goto L4917;
L4922:
	R1 = (u64)&r;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4935;
	R1 = tou64("");
	R2 = tou64("imprel32?");
	mx_lib_error(asu64(R2), asu64(R1));
L4935:
	R1 = (u64)&r;
	R2 = 4;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	index = asi64(R1);
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = index;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4917;
L4923:
L4917:
	i += 1; if (i <= av_2) goto L4909;
L4911:
	R1 = 1;
	R2 = (u64)&mx_decls_librelocated;
	asu64(R3) = lib;
	R4 = 208;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mx_lib_loadimports(u64 plib) {
    u64 R1, R2; 
	u64 qlib;
	u64 name;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = plib;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4939;
L4937:
	asu64(R1) = plib;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_dosublib(asu64(R1));
	i += 1; if (i <= av_1) goto L4937;
L4939:
	asu64(R1) = plib;
	mx_lib_alloclibdata(asu64(R1));
	asu64(R1) = plib;
	mx_lib_dosymbols(asu64(R1));
	return;
}

static void mx_lib_dosublib(u64 name) {
    u64 R1, R2, R3; 
	u64 qlib;
	i64 n;
	asu64(R1) = name;
	asi64(R1) = mx_lib_findlib(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (asi64(R1)) goto L4942;
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	n = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Loading sublib");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = n;
	R2 = tou64("ml");
	asu64(R3) = name;
	asu64(R2) = mlib_addext(asu64(R3), asu64(R2));
	asu64(R1) = mx_lib_loadlibfile(asu64(R2), asi64(R1));
	qlib = asu64(R1);
	asu64(R1) = qlib;
	mx_lib_loadimports(asu64(R1));
L4942:
	return;
}

static u64 mx_lib_loadlibfile(u64 filename, i64 libno) {
    u64 R1, R2, R3, R4; 
	u64 plib;
	u64 p;
	asu64(R1) = filename;
	asu64(R1) = mx_lib_readmxfile(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4945;
	asu64(R1) = filename;
	R2 = tou64("Can't find #");
	mx_lib_error(asu64(R2), asu64(R1));
L4945:
	asu64(R1) = p;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_readlibfile(asu64(R2), asu64(R1));
	plib = asu64(R1);
	asi64(R1) = libno;
	asu64(R2) = plib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = plib;
	R2 = R1;
	R3 = (u64)&mx_decls_libtable;
	asi64(R4) = libno;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	goto L4943;
L4943:
	return asu64(R1);
}

static void mx_lib_dosymbols(u64 lib) {
    u64 R1, R2, R3; 
	i64 ix;
	i64 libx;
	i64 dllx;
	u64 baseaddr;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4949;
L4947:
	asu64(R1) = lib;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_adddll(asu64(R1));
	i += 1; if (i <= av_1) goto L4947;
L4949:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4952;
L4950:
	asu64(R1) = lib;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mx_lib_addsymbol(asu64(R1));
	ix = asi64(R1);
	asi64(R1) = ix;
	asu64(R2) = lib;
	R3 = 176;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
	i += 1; if (i <= av_2) goto L4950;
L4952:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 64;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4955;
L4953:
	asu64(R1) = lib;
	R2 = 120;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mx_lib_addsymbol(asu64(R1));
	ix = asi64(R1);
	R1 = (u64)&mx_decls_symboldefined;
	asi64(R2) = ix;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4957;
	msysc_m$print_startcon();
	R1 = tou64("Dupl symbol:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = lib;
	R2 = 120;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L4954;
L4957:
	R1 = 1;
	R2 = (u64)&mx_decls_symboldefined;
	asi64(R3) = ix;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = lib;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4959;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4960;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4961;
	goto L4962;
L4959:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4958;
L4960:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4958;
L4961:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4958;
L4962:
	R1 = 0;
	baseaddr = asu64(R1);
L4958:
	asu64(R1) = baseaddr;
	asu64(R2) = lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = ix;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mx_decls_symbollibindex;
	asi64(R3) = ix;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
L4954:
	i += 1; if (i <= av_3) goto L4953;
L4955:
	return;
}

static u64 mx_lib_readmxfile(u64 filename) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = filename;
	asu64(R1) = mlib_readfile(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4965;
	R1 = 0;
	goto L4963;
L4965:
	R1 = 13;
	asu64(R2) = p;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L4963;
L4963:
	return asu64(R1);
}

static void mx_lib_adddll(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4969;
L4967:
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4971;
	goto L4966;
L4971:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4967;
L4969:
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4973;
	R1 = tou64("");
	R2 = tou64("Too many DLLs");
	mx_lib_error(asu64(R2), asu64(R1));
L4973:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_dllnametable;
	R3 = (u64)&mx_decls_ndlllibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4966:
	return;
}

static i64 mx_lib_addsymbol(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4977;
L4975:
	R1 = (u64)&mx_decls_symbolnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4979;
	asi64(R1) = i;
	goto L4974;
L4979:
	i += 1; if (i <= mx_decls_nsymbols) goto L4975;
L4977:
	asi64(R1) = mx_decls_nsymbols;
	R2 = 3000;
	if (asi64(R1) < asi64(R2)) goto L4981;
	R1 = tou64("");
	R2 = tou64("Too many Imports");
	mx_lib_error(asu64(R2), asu64(R1));
L4981:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_symbolnametable;
	R3 = (u64)&mx_decls_nsymbols;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mx_decls_nsymbols;
	goto L4974;
L4974:
	return asi64(R1);
}

static void mx_lib_setspecialglobals(i64 cmdskip) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4985;
L4983:
	R1 = tou64("msys.$cmdskip");
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L4988;
	R1 = tou64("$cmdskip");
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4987;
L4988:
	asi64(R1) = cmdskip;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	*tou8p(R2) = asu8(R1);
L4987:
	i += 1; if (i <= mx_decls_nsymbols) goto L4983;
L4985:
	return;
}

static void mx_lib_runprogram(u64 lib, i64 cmdskip) {
    u64 R1, R2, R3; 
	u64 fnptr;
	i64 libno;
	i64 i;
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	libno = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4992;
L4990:
	asi64(R1) = i;
	asi64(R2) = libno;
	if (asi64(R1) == asi64(R2)) goto L4994;
	R1 = (u64)&mx_decls_libinitdone;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4994;
	R1 = (u64)&mx_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_calllibinit(asu64(R1));
L4994:
	i += 1; if (i <= mx_decls_nlibs) goto L4990;
L4992:
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4996;
	R1 = tou64("");
	R2 = tou64("No entry point found");
	mx_lib_error(asu64(R2), asu64(R1));
L4996:
	asi64(R1) = cmdskip;
	mx_lib_setspecialglobals(asi64(R1));
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = fnptr;
	((F20)R1)();
	R1 = 1;
	R2 = (u64)&mx_decls_libinitdone;
	asi64(R3) = libno;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mx_lib_calllibinit(u64 lib) {
    u64 R1, R2, R3, R4; 
	u64 fnptr;
	i64 libno;
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	libno = asi64(R1);
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4999;
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = fnptr;
	((F20)R1)();
L4999:
	R1 = 1;
	R2 = (u64)&mx_decls_libinitdone;
	asu64(R3) = lib;
	R4 = 208;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static u64 mx_lib_findsymbol(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5003;
L5001:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5005;
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5000;
L5005:
	i += 1; if (i <= mx_decls_nsymbols) goto L5001;
L5003:
	R1 = 0;
	goto L5000;
L5000:
	return asu64(R1);
}

static u64 mx_lib_loadmx(u64 filename) {
    u64 R1, R2; 
	u64 plib;
	i64 newlib;
	u64 name;
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = filename;
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asi64(R1) = newlib;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_loadlibfile(asu64(R2), asi64(R1));
	plib = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadimports(asu64(R1));
	asu64(R1) = plib;
	goto L5006;
L5006:
	return asu64(R1);
}

static u64 mx_lib_loadmemmcb(u64 filename, u64 p) {
    u64 R1, R2, R3; 
	u64 plib;
	i64 newlib;
	u64 name;
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = filename;
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_readlibfile(asu64(R2), asu64(R1));
	plib = asu64(R1);
	asi64(R1) = newlib;
	asu64(R2) = plib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = plib;
	R2 = (u64)&mx_decls_libtable;
	asi64(R3) = newlib;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadimports(asu64(R1));
	asu64(R1) = plib;
	goto L5007;
L5007:
	return asu64(R1);
}

static void mx_write_writemcx(u64 filename) {
    u64 R1, R2, R3; 
	i64 n;
	i64 ndlls;
	i64 nlibs;
	i64 i;
	R1 = 8;
	asi64(R2) = mc_decls_ss_zdatalen;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 144;
	R2 = 8;
	asu64(R3) = mc_decls_ss_code;
	mx_write_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	asu64(R3) = mc_decls_ss_idata;
	mx_write_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mx_write_dest = asu64(R1);
	R1 = 441992013;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	mx_write_genbyte(asi64(R1));
	R1 = tou64("0.1234");
	mx_write_genstring(asu64(R1));
	mx_run_countsymbols();
	mx_write_writerelocs();
	R1 = 4;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	mx_write_genu32(asi64(R1));
	R1 = 2;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = mc_decls_ss_code;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mx_write_genblock(asu64(R2), asi64(R1));
	R1 = 3;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = mc_decls_ss_idata;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mx_write_genblock(asu64(R2), asi64(R1));
	R1 = 0;
	ndlls = asi64(R1);
	R1 = 0;
	nlibs = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5011;
L5009:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5013;
	R1 = (u64)&ndlls;
	(*toi64p(R1)) += 1;
L5013:
	i += 1; if (i <= pc_decls_nplibfiles) goto L5009;
L5011:
	R1 = 6;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = ndlls;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5016;
L5014:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5018;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_write_genstring(asu64(R1));
L5018:
	i += 1; if (i <= pc_decls_nplibfiles) goto L5014;
L5016:
	mx_write_writesymbols();
	R1 = 13;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mx_write_dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mx_write_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = mx_write_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mx_write_writerelocs() {
    u64 R1, R2, R3; 
	u64 oldr;
	u64 newr;
	i64 n;
	i64 count;
	u64 d;
	u64 baseptr64;
	i64 i;
	R1 = 5;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asi64(R2) = mc_decls_ss_ncoderelocs;
	asi64(R1) += asi64(R2);
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	R1 = 0;
	count = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L5020:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5024;
	asu64(R1) = mc_decls_ss_idatarelocs;
	goto L5023;
L5024:
	asu64(R1) = mc_decls_ss_coderelocs;
L5023:
	oldr = asu64(R1);
	goto L5028;
L5025:
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
	R1 = (u64)&newr;
	memset(R1, 0, 8);
	asu64(R1) = oldr;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5030;
	R1 = 2;
	goto L5029;
L5030:
	R1 = 1;
L5029:
	R2 = (u64)&newr;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = oldr;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5032;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5033;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5033;
	goto L5034;
L5032:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5036;
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5035;
L5036:
	R1 = tou64("rel32/rel not imported");
	mc_libmcl_axerror(asu64(R1));
L5035:
	goto L5031;
L5033:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5038;
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5040;
	R1 = 3;
	goto L5039;
L5040:
	R1 = 4;
L5039:
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L5037;
L5038:
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5042;
	R1 = 1;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5041;
L5042:
	R1 = 2;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5041:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5037:
	goto L5031;
L5034:
	R1 = tou64("reloc?");
	mc_libmcl_axerror(asu64(R1));
L5031:
	R1 = 8;
	R2 = (u64)&newr;
	mx_write_genblock(asu64(R2), asi64(R1));
	asu64(R1) = oldr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	oldr = asu64(R1);
L5028:
	asu64(R1) = oldr;
	if (asu64(R1)) goto L5025;
	i += 1; if (i <= 2) goto L5020;
	return;
}

static void mx_write_writesymbols() {
    u64 R1, R2; 
	u64 d;
	i64 n;
	u64 name;
	i64 i;
	R1 = 8;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymimports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5046;
L5044:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5048;
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mx_write_genstring(asu64(R1));
L5048:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5044;
L5046:
	R1 = 9;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5051;
L5049:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5053;
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5055;
	asu64(R1) = d;
	mx_write_entrypoint = asu64(R1);
L5055:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mx_write_genstring(asu64(R1));
L5053:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5049;
L5051:
	R1 = 10;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5058;
L5056:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5060;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mx_write_genbyte(asi64(R1));
L5060:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5056;
L5058:
	R1 = 11;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5063;
L5061:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5065;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mx_write_genu32(asi64(R1));
L5065:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5061;
L5063:
	R1 = 12;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mx_write_entrypoint;
	if (!asu64(R1)) goto L5067;
	asu64(R1) = mx_write_entrypoint;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mx_write_genu32(asi64(R1));
	goto L5066;
L5067:
	R1 = 4294967295;
	mx_write_genu32(asi64(R1));
L5066:
	return;
}

static void mx_write_roundsegment(u64 p, i64 align, i64 value) {
    u64 R1, R2, R3; 
	i64 length;
	i64 newlength;
	i64 av_1;
	asu64(R1) = p;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	length = asi64(R1);
	asi64(R1) = align;
	asi64(R2) = length;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newlength = asi64(R1);
	asi64(R1) = align;
	asu64(R2) = p;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = newlength;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5071;
L5069:
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L5069;
L5071:
	return;
}

static void mx_write_genbyte(i64 x) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = x;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mx_write_genu32(i64 x) {
    u64 R1, R2, R3; 
	R1 = 4;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = x;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 4; asu64(R2) = asu64(R3);
	*tou32p(R2) = asu32(R1);
	return;
}

static void mx_write_genstring(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = s;
	mx_write_genblock(asu64(R2), asi64(R1));
	return;
}

static void mx_write_genblock(u64 p, i64 length) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = length;
	asu64(R2) = p;
	asu64(R3) = mx_write_dest;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	return;
}

void mm_main() {
    u64 R1; 
	pcl_start();
	mm_start();
	mm_cli_main2();
	R1 = 0;
	exit(R1);
	return;
}

static void mm_cli_main2() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	u64 r;
	i64 m;
	i64 fileno;
	i64 ntokens;
	i64 t;
	i64 tt;
	asi64(R1) = mwindows_os_clock();
	mm_cli_startclock = asi64(R1);
	asi64(R1) = mm_cli_startclock;
	pc_decls_pstartclock = asi64(R1);
	mm_cli_initdata();
	mm_cli_getinputoptions();
	asi64(R1) = mm_decls_prodmode;
	if (!asi64(R1)) goto L5079;
	mm_cli_production_compiler();
	goto L5078;
L5079:
	mm_cli_debug_compiler();
L5078:
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5081;
	msysc_m$print_startcon();
	R1 = tou64("Finished.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5081:
	return;
}

static void mm_cli_debug_compiler() {
    u64 R1, R2; 
	asu64(R1) = mm_cli_inputfile;
	mm_modules_loadproject(asu64(R1));
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5084;
	R1 = 4;
	mm_decls_passlevel = asi64(R1);
	goto L5083;
L5084:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5085;
	R1 = 6;
	mm_decls_passlevel = asi64(R1);
L5085:
L5083:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L5087;
	asu8(R1) = mm_decls_fshowast1;
	R1 = toi64(tou8(R1));
	mm_cli_do_parse(asi64(R1));
L5087:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L5089;
	asu8(R1) = mm_decls_fshowast2;
	R1 = toi64(tou8(R1));
	mm_cli_do_name(asi64(R1));
L5089:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L5091;
	asu8(R1) = mm_decls_fshowast3;
	R1 = toi64(tou8(R1));
	mm_cli_do_type(asi64(R1));
L5091:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L5093;
	asu8(R1) = mm_decls_fshowpcl;
	if (asu8(R1)) goto L5094;
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L5095;
L5094:
	R1 = 1;
	goto L5096;
L5095:
	R1 = 0;
L5096:
	mm_cli_do_genpcl(asi64(R1));
L5093:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L5098;
	asu8(R1) = mm_decls_fshowasm;
	if (asu8(R1)) goto L5099;
	R1 = 0;
	if (!asu16(R1)) goto L5100;
L5099:
	R1 = 1;
	goto L5101;
L5100:
	R1 = 0;
L5101:
	mm_cli_do_genmcl(asi64(R1));
L5098:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L5103;
	R1 = 0;
	pc_api_pcl_genss(asi64(R1));
L5103:
	asu8(R1) = mm_decls_fshowtiming;
	if (!asu8(R1)) goto L5105;
	mm_diags_showtimings();
L5105:
	mm_diags_showlogfile();
	return;
}

static void mm_cli_production_compiler() {
    u64 R1, R2; 
	mm_cli_showcompilemess();
	asu64(R1) = mm_cli_inputfile;
	mm_modules_loadproject(asu64(R1));
	R1 = 0;
	mm_cli_do_parse(asi64(R1));
	R1 = 0;
	mm_cli_do_name(asi64(R1));
	R1 = 0;
	mm_cli_do_type(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5108;
	asu64(R1) = mm_cli_inputfile;
	mm_support_do_writema(asu64(R1));
L5108:
	asi64(R1) = mm_decls_passlevel;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5111;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5110;
L5111:
	asu64(R1) = mm_cli_inputfile;
	mm_support_do_getinfo(asu64(R1));
L5110:
	asi64(R1) = mm_decls_passlevel;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5113;
	mm_cli_do_writeexports();
L5113:
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	mm_cli_do_genpcl(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5115;
	pc_run_pcl_runpcl();
L5115:
	asi64(R1) = mm_decls_passlevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L5117;
	asi64(R1) = mm_decls_passlevel;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5118;
	R1 = 0;
	if (!asu16(R1)) goto L5119;
L5118:
	R1 = 1;
	goto L5120;
L5119:
	R1 = 0;
L5120:
	mm_cli_do_genmcl(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5122;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5123;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5124;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5125;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5126;
	goto L5127;
L5122:
	R1 = tou64("obj");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writeobj(asu64(R1));
	goto L5121;
L5123:
	R1 = tou64("exe");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writeexe(asu64(R1));
	goto L5121;
L5124:
	R1 = tou64("dll");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writedll(asu64(R1));
	goto L5121;
L5125:
	R1 = tou64("mx");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writemx(asu64(R1));
	goto L5121;
L5126:
	pc_api_pcl_exec();
	goto L5121;
L5127:
L5121:
L5117:
	asu8(R1) = mm_decls_fshowtiming;
	if (!asu8(R1)) goto L5129;
	mm_diags_showtimings();
L5129:
	return;
}

static void mm_cli_showcompilemess() {
    u64 R1, R2; 
	asi64(R1) = mm_decls_fverbose;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5132;
	asu8(R1) = mm_cli_msfile;
	if (asu8(R1)) goto L5132;
	msysc_m$print_startcon();
	R1 = tou64("Compiling # to #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mm_cli_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_cli_passnames;
	asi64(R2) = mm_decls_passlevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5132:
	return;
}

static void mm_cli_do_parse(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5136;
L5134:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R1) = mm_parse_parsemodule(asu64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L5134;
L5136:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_parsetime = asi64(R1);
	asi64(R1) = mm_decls_prodmode;
	if (asi64(R1)) goto L5139;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 3;
	if (asi64(R1) < asi64(R2)) goto L5138;
L5139:
	mm_name_fixusertypes();
L5138:
	mm_cli_fixstartprocs();
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5141;
	R1 = tou64("AST1");
	mm_diags_showast(asu64(R1));
L5141:
	return;
}

static void mm_cli_do_name(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	mm_name_rx_typetable();
	R1 = 2;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L5145;
L5143:
	asi64(R1) = i;
	asi64(R1) = mm_name_rx_module(asi64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L5143;
L5145:
	R1 = 1;
	asi64(R1) = mm_name_rx_module(asi64(R1));
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_resolvetime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5147;
	R1 = tou64("AST2");
	mm_diags_showast(asu64(R1));
L5147:
	return;
}

static void mm_cli_do_type(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	mm_type_tx_typetable();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5151;
L5149:
	asi64(R1) = i;
	asi64(R1) = mm_type_tx_module(asi64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L5149;
L5151:
	mm_type_tx_allprocs();
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_typetime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5153;
	R1 = tou64("AST3");
	mm_diags_showast(asu64(R1));
L5153:
	return;
}

static void mm_cli_do_genpcl(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	R1 = 0;
	mm_genpcl_codegen_il(asu64(R1));
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L5157;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L5156;
L5157:
	pc_reduce_pcl_reducetest();
L5156:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_pcltime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5159;
	asu8(R1) = mm_decls_fshowpcl;
	if (asu8(R1)) goto L5162;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5161;
L5162:
	R1 = tou64("pcl");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
L5161:
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L5164;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5164;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
L5164:
L5159:
	return;
}

static void mm_cli_do_genmcl(i64 flog) {
    u64 R1, R2, R3; 
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	pc_api_pcl_genmcl();
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5167;
	R1 = 16705;
	R2 = tou64("asm");
	asu64(R3) = mm_decls_outfile;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L5167:
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L5169;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L5169;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
L5169:
	return;
}

static void mm_cli_initdata() {
    u64 R1, R2, R3; 
	u64 pm;
	u64 pf;
	mlib_pcm_init();
	mm_lex_lexsetup();
	mm_assem_initassemsymbols();
	mm_support_init_tt_tables();
	mm_support_initbblib();
	R1 = 64;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	R1 = tou64("PROGRAM");
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = tou64("$prog");
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	mm_decls_stprogram = asu64(R1);
	asu64(R1) = mm_decls_stprogram;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&mm_support_mgetsourceinfo;
	pc_decls_igetmsourceinfo = asu64(R1);
	R1 = (u64)&mm_assemaux_domcl_assem;
	pc_api_idomcl_assem = asu64(R1);
	R1 = (u64)&mm_genpcl_findhostfn;
	pc_api_igethostfn = asu64(R1);
	R1 = (u64)&mm_assemaux_checkasmlabel;
	pc_api_icheckasmlabel = asu64(R1);
	R1 = tou64("PSYMTAB");
	asi32(R1) = remove(asu64(R1));
	return;
}

static void mm_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 paramno;
	i64 pmtype;
	i64 sw;
	i64 extlen;
	u64 name;
	u64 value;
	u64 ext;
	struct $B15 filespec;
	i64 av_1;
	asu8(R1) = pcl_pc_userunpcl;
	if (!asu8(R1)) goto L5173;
	R1 = 5;
	mm_decls_passlevel = asi64(R1);
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
	R1 = 0;
	mm_decls_fverbose = asi64(R1);
L5173:
	R1 = 1;
	paramno = asi64(R1);
	R1 = tou64("ms.exe");
	asu64(R2) = mwindows_os_gethostname();
	asu64(R2) = mlib_extractfile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5175;
	R1 = 1;
	mm_cli_msfile = asu8(R1);
	R1 = 0;
	mm_decls_fverbose = asi64(R1);
	R1 = 0;
	R2 = tou64("");
	R3 = 13;
	mm_cli_do_option(asi64(R3), asu64(R2), asi64(R1));
L5175:
	goto L5177;
L5176:
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5180;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5181;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5182;
	goto L5183;
L5180:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 55;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5187;
L5184:
	R1 = (u64)&mm_cli_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5189;
	asi64(R1) = paramno;
	asu64(R2) = value;
	asi64(R3) = sw;
	mm_cli_do_option(asi64(R3), asu64(R2), asi64(R1));
	goto L5186;
L5189:
	sw += 1; if (sw <= av_1) goto L5184;
L5187:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 99;
	exit(R1);
L5186:
	goto L5179;
L5181:
	asu64(R1) = mm_cli_inputfile;
	if (!asu64(R1)) goto L5191;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Specify one lead module only");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5191:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_cli_inputfile = asu64(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5194;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5193;
L5194:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	mm_cli_cmdskip = asi64(R1);
	goto L5178;
L5193:
	goto L5179;
L5182:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Lib files go in module headers");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
	goto L5179;
L5183:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Invalid params");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5179:
L5177:
	R1 = tou64("m");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	pmtype = asi64(R2);
	if (asi64(R1)) goto L5176;
L5178:
	asi64(R1) = mm_decls_prodmode;
	asi64(R2) = mm_decls_debugmode;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L5196;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5196;
	R1 = 9;
	mm_decls_passlevel = asi64(R1);
	R1 = tou64("exe");
	mm_cli_outext = asu64(R1);
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
L5196:
	asi64(R1) = mm_decls_passlevel;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5198;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5198;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5199;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5200;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5200;
	goto L5201;
L5198:
	R1 = 2;
	mm_decls_highmem = asu8(R1);
	goto L5197;
L5199:
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L5203;
	R1 = 2;
	mm_decls_highmem = asu8(R1);
L5203:
	goto L5197;
L5200:
	R1 = 0;
	mm_decls_highmem = asu8(R1);
	goto L5197;
L5201:
L5197:
	asu64(R1) = mm_cli_inputfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5205;
	mm_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("   ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(" prog[.m]  Compile prog.m to prog.exe");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("   ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(" -h           Show all options");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
	goto L5204;
L5205:
	asu64(R1) = mm_cli_inputfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
	asu64(R1) = mm_decls_destfilename;
	if (!asu64(R1)) goto L5207;
	asu64(R1) = mm_decls_destfilename;
	mm_decls_outfile = asu64(R1);
L5207:
	asu64(R1) = mm_decls_destfilepath;
	if (!asu64(R1)) goto L5209;
	asu64(R1) = mm_decls_destfilepath;
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mm_decls_outfile;
	R2 = (u64)&filespec;
	asu64(R2) = mlib_extractfile(asu64(R2));
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
L5209:
L5204:
	R1 = 0;
	asu64(R2) = mm_cli_inputfile;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	ext = asu64(R1);
	asu64(R1) = ext;
	asi64(R1) = strlen(asu64(R1));
	extlen = asi64(R1);
	asu64(R1) = ext;
	asu64(R2) = msysc_cmdparams;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mm_cli_inputfile;
	R2 = (u64)&filespec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5211;
	asi64(R1) = mm_decls_passlevel;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L5211;
	R1 = tou64("2.m");
	R2 = (u64)&filespec;
	R3 = (u64)&filespec;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	asi64(R3) = extlen;
	R2 -= (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("New dest=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_decls_outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5211:
	asi64(R1) = mm_decls_fshortnames;
	R2 = -1;
	asu8(R3) = mm_decls_highmem;
	R3 = toi64(tou8(R3));
	pc_api_pcl_setflags(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mm_cli_cmdskip;
	pc_api_pcl_cmdskip(asi64(R2), asu64(R1));
	asu8(R1) = mm_decls_msyslevel;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5213;
	R1 = 1;
	pc_api_pfullsys = asu8(R1);
L5213:
	return;
}

static void mm_cli_do_option(i64 sw, u64 value, i64 paramno) {
    u64 R1, R2, R3; 
	asi64(R1) = sw;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5216;
	R2 = 13;
	if (asi64(R1) > asi64(R2)) goto L5216;
	asi64(R1) = mm_decls_prodmode;
	if (!asi64(R1)) goto L5218;
	R1 = tou64("");
	R2 = (u64)&mm_cli_optionnames;
	asi64(R3) = sw;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = tou64("dupl prod option:");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5218:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_decls_passlevel = asi64(R1);
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
	R1 = (u64)&mm_cli_passnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_cli_outext = asu64(R1);
	asi64(R1) = sw;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5220;
	goto L5221;
L5220:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	mm_cli_cmdskip = asi64(R1);
	goto L5219;
L5221:
L5219:
	goto L5214;
	goto L5215;
L5216:
	asi64(R1) = sw;
	R2 = 14;
	if (asi64(R1) < asi64(R2)) goto L5222;
	R2 = 21;
	if (asi64(R1) > asi64(R2)) goto L5222;
	asi64(R1) = mm_decls_debugmode;
	if (!asi64(R1)) goto L5224;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("dupl debug option");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5224:
	asi64(R1) = sw;
	R2 = 14;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	mm_decls_dpasslevel = asi64(R1);
	R1 = 1;
	mm_decls_debugmode = asi64(R1);
	goto L5214;
L5222:
L5215:
	asi64(R1) = sw;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L5226;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L5227;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L5228;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L5229;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L5230;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5231;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L5232;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L5233;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5234;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L5235;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L5236;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5237;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5238;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L5239;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L5239;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L5239;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L5240;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5241;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5242;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5243;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5244;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L5244;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L5244;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5245;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5245;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L5246;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5246;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L5247;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5248;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5249;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5250;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L5251;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L5252;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5252;
	goto L5253;
L5226:
	R1 = 1;
	mm_decls_fshowast1 = asu8(R1);
	goto L5225;
L5227:
	R1 = 1;
	mm_decls_fshowast2 = asu8(R1);
	goto L5225;
L5228:
	R1 = 1;
	mm_decls_fshowast3 = asu8(R1);
	goto L5225;
L5229:
	R1 = 1;
	mm_decls_fshowpcl = asu8(R1);
	goto L5225;
L5230:
	R1 = 1;
	mm_decls_fshowc = asu8(R1);
	goto L5225;
L5231:
	R1 = 1;
	mm_decls_fshowasm = asu8(R1);
	goto L5225;
L5232:
	R1 = 1;
	mm_decls_fshowst = asu8(R1);
	goto L5225;
L5233:
	R1 = 1;
	mm_decls_fshowstflat = asu8(R1);
	goto L5225;
L5234:
	R1 = 1;
	mm_decls_fshowpst = asu8(R1);
	goto L5225;
L5235:
	R1 = 1;
	mm_decls_fshowtypes = asu8(R1);
	goto L5225;
L5236:
	R1 = 1;
	mm_decls_fshowss = asu8(R1);
	goto L5225;
L5237:
	R1 = 1;
	mm_decls_fshowmodules = asu8(R1);
	goto L5225;
L5238:
	R1 = 1;
	mm_decls_clinux = asu8(R1);
	goto L5225;
L5239:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	mm_decls_msyslevel = asu8(R1);
	goto L5225;
L5240:
	R1 = 0;
	R2 = R1;
	pc_decls_fregoptim = asu8(R2);
	pc_decls_fpeephole = asu8(R1);
	goto L5225;
L5241:
	R1 = 0;
	pc_decls_fpeephole = asu8(R1);
	goto L5225;
L5242:
	R1 = 0;
	pc_decls_fregoptim = asu8(R1);
	goto L5225;
L5243:
	R1 = 1;
	mm_decls_fshowtiming = asu8(R1);
	goto L5225;
L5244:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_decls_fverbose = asi64(R1);
	goto L5225;
L5245:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	pc_decls_pverbose = asu8(R1);
	goto L5225;
L5246:
	mm_cli_showhelp();
	R1 = 0;
	exit(R1);
	goto L5225;
L5247:
	R1 = 0;
	mm_decls_dointlibs = asu8(R1);
	goto L5225;
L5248:
	asu8(R1) = mm_cli_do_option_outpathused;
	if (!asu8(R1)) goto L5255;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("mixed out/path");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5255:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_destfilename = asu64(R1);
	R1 = 1;
	mm_cli_do_option_outused = asu8(R1);
	goto L5225;
L5249:
	asu8(R1) = mm_cli_do_option_outused;
	if (!asu8(R1)) goto L5257;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("mixed out/path");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5257:
	asu64(R1) = value;
	asu64(R2) = value;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5259;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5259;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Path needs to end with \\ or /");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5259:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_destfilepath = asu64(R1);
	R1 = 1;
	mm_cli_do_option_outpathused = asu8(R1);
	goto L5225;
L5250:
	R1 = 1;
	mm_decls_fcheckunusedlocals = asu8(R1);
	goto L5225;
L5251:
	R1 = 1;
	mm_decls_fshortnames = asi64(R1);
	goto L5225;
L5252:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	mm_decls_highmem = asu8(R1);
	goto L5225;
L5253:
L5225:
L5214:
	return;
}

static void mm_cli_showcaption() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("M Compiler [M7.1]");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("21-Jul-2025");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("11:50:05");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_cli_showhelp() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("M Compiler for 64-bit Windows\n\nNormal use:           Compiles lead module prog.m to:\n\n    mm      prog      prog.exe (default)\n    mm -r   prog      in-memory native code then execute\n    mm -i   prog      in-memory IL then interpret\n\n    mm -exe prog      prog.exe\n    mm -dll prog      prog.dll\n    mm -obj prog      prog.obj\n    mm -a   prog      prog.asm\n    mm -n   prog      prog.nasm\n    mm -mx  prog      prog.mx\n    mm -p   prog      prog.pcl (textual IL)\n    mm -ma   prog     prog.ma (single amalgamated source file)\n\nOther options:\n\n    -ext              Used std headers external to compiler\n    -opt              Optimise native code\n    -out:file         Name output file (extension can be added)\n    -rip              Use RIP address modes\n    -himem            Generate PIC code (automatic with -obj/-dll)\n    @file             Read files and options from a file\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_cli_do_writeexports() {
    u64 R1, R2; 
	struct $B15 str;
	asu64(R1) = mm_decls_outfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("dll");
	R2 = (u64)&str;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R2) = mm_decls_outfile;
	mm_export_dummy_writeexports(asu64(R2), asu64(R1));
	return;
}

static u64 mm_cli_getoutfilename(u64 file, u64 ext) {
    u64 R1, R2; 
	asu64(R1) = ext;
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L5263;
L5263:
	return asu64(R1);
}

static void mm_cli_fixstartprocs() {
    u64 R1, R2, R3, R4, R5; 
	u64 ms;
	u64 ps;
	u64 d;
	u64 p;
	u64 q;
	i64 s;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5267;
L5265:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = ps;
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5269;
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = ps;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L5269:
	i += 1; if (i <= mm_decls_nsubprogs) goto L5265;
L5267:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5272;
L5270:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	asu64(R1) = ms;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5274;
	R1 = 1;
	R2 = (u64)&mm_decls_subproghasstart;
	asu64(R3) = ms;
	R4 = 18;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5274:
	i += 1; if (i <= mm_decls_nmodules) goto L5270;
L5272:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5277;
L5275:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	asu64(R1) = ms;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5279;
	asu64(R1) = ms;
	R2 = 18;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&mm_decls_subproghasstart;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5281;
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = s;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L5281;
	asi64(R1) = i;
	R2 = 2;
	R3 = tou64("start");
	asu64(R4) = ms;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mm_cli_addstartproc(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ms;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5281:
L5279:
	i += 1; if (i <= mm_decls_nmodules) goto L5275;
L5277:
	return;
}

static u64 mm_cli_addstartproc(u64 owner, u64 name, i64 scope, i64 moduleno) {
    u64 R1, R2, R3; 
	u64 stproc;
	R1 = 6;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = moduleno;
	asu64(R2) = stproc;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = moduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stproc;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = stproc;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stproc;
	mm_lib_addtoproclist(asu64(R1));
	asu64(R1) = stproc;
	goto L5282;
L5282:
	return asu64(R1);
}

static void mm_genpcl_codegen_il(u64 dummy) {
    u64 R1, R2; 
	u64 d;
	u64 pp;
	i64 i;
	asi64(R1) = mm_decls_nunits;
	R2 = 0;
	asu64(R1) = pc_api_pcl_start(asu64(R2), asi64(R1));
	mm_genpcl_dolibs();
	asu64(R1) = mm_decls_staticlist;
	pp = asu64(R1);
	goto L5285;
L5284:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_dostaticvar(asu64(R1));
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L5285:
	asu64(R1) = pp;
	if (asu64(R1)) goto L5284;
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ndllproctable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5289;
L5287:
	R1 = (u64)&mm_decls_dllproctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_genpcl_gendllproc(asu64(R1));
	i += 1; if (i <= mm_decls_ndllproctable) goto L5287;
L5289:
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L5291;
L5290:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = R1;
	mm_decls_currproc = asu64(R2);
	mm_genpcl_genprocdef(asu64(R1));
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L5291:
	asu64(R1) = pp;
	if (asu64(R1)) goto L5290;
	mm_genpcl_scanprocs();
	pc_api_pcl_end();
	return;
}

static void mm_genpcl_genprocdef(u64 p) {
    u64 R1, R2, R3; 
	u64 ms;
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = p;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	R1 = 0;
	mm_genpcl_pcldoswx = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ms;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L5295;
	R1 = (u64)&mm_decls_moduletosub;
	asu64(R2) = p;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L5295;
	asu64(R1) = p;
	mm_genpcl_genmaindef(asu64(R1));
	goto L5293;
	goto L5294;
L5295:
	asu64(R1) = p;
	asu64(R2) = ms;
	R3 = 48;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L5296;
	asu64(R1) = p;
	mm_genpcl_genstartdef(asu64(R1));
	goto L5293;
L5296:
L5294:
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5298;
	R1 = 0;
	R2 = 126;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	mm_genpcl_pcldoswx = asu64(R1);
	R1 = 0;
	R2 = 0;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5298:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
L5293:
	return;
}

static void mm_genpcl_gendllproc(u64 p) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = p;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_setimport(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5303;
L5300:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5303:
	asu64(R1) = e;
	if (asu64(R1)) goto L5300;
	R1 = 0;
	pc_api_pc_setimport(asu64(R1));
	return;
}

static void mm_genpcl_dolibs() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5307;
L5305:
	R1 = (u64)&mm_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5309;
	R1 = (u64)&mm_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pc_api_pc_addplib(asu64(R1));
L5309:
	i += 1; if (i <= mm_decls_nlibfiles) goto L5305;
L5307:
	return;
}

static void mm_genpcl_dostaticvar(u64 d) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5312;
	goto L5310;
L5312:
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5314;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) != asu64(R2)) goto L5314;
	R1 = tou64("$cmdskip");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5316;
	R1 = 3;
	asu64(R2) = d;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5316:
L5314:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5318;
	goto L5310;
	goto L5317;
L5318:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5319;
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	pc_api_pc_setalign(asi64(R1));
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5317;
L5319:
// mm_genpcl.dostaticvar.dozstatic:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 124;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	pc_api_pc_setalign(asi64(R1));
L5317:
L5310:
	return;
}

static void mm_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset) {
    u64 R1, R2, R3, R4, R5; 
	struct $B45 data;
	i64 t;
	i64 tbase;
	u8 allbytes;
	u8 nbytes;
	u64 q;
	u64 a;
	u64 d;
	u64 s;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5323;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5324;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5325;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L5326;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L5327;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5328;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5328;
	goto L5329;
L5323:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5331;
	asi64(R1) = t;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L5333;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5335;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L5337;
	R1 = 0;
	R2 = tou64("1:B-str?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5337:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5334;
L5335:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5334:
	goto L5332;
L5333:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5332:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5330;
L5331:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5338;
	asi64(R1) = t;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genrealimm(asr64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
	goto L5330;
L5338:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5339;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5341;
	R1 = 0;
	R2 = tou64("IDATA/ARRAY/NOT BLOCKDATA");
	mm_support_gerror(asu64(R2), asu64(R1));
L5341:
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_gendata(asu64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5330;
L5339:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5330:
	goto L5322;
L5324:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	allbytes = asu8(R1);
	R1 = 0;
	nbytes = asu8(R1);
	goto L5345;
L5342:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5347;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5347;
	asu8(R1) = nbytes;
	R1 = toi64(tou8(R1));
	R2 = 2000;
	if (asi64(R1) >= asi64(R2)) goto L5347;
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&data;
	R3 = (u64)&nbytes;
	asu8(R3) = *(tou8p(R3)) += 1;
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L5346;
L5347:
	R1 = 0;
	allbytes = asu8(R1);
	goto L5344;
L5346:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5345:
	asu64(R1) = q;
	if (asu64(R1)) goto L5342;
L5344:
	asu8(R1) = allbytes;
	if (!asu8(R1)) goto L5349;
	asu8(R1) = nbytes;
	if (!asu8(R1)) goto L5349;
	asu8(R1) = nbytes;
	R1 = toi64(tou8(R1));
	asu8(R2) = nbytes;
	R2 = toi64(tou8(R2));
	R3 = (u64)&data;
	asu64(R2) = mlib_pcm_copyheapstringn(asu64(R3), asi64(R2));
	asu64(R1) = pc_api_gendata(asu64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5348;
L5349:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5353;
L5350:
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = q;
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5353:
	asu64(R1) = q;
	if (asu64(R1)) goto L5350;
L5348:
	goto L5322;
L5325:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5355;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5355;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5355;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5356;
	goto L5357;
L5355:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = offset;
	if (!asi64(R1)) goto L5359;
	asi64(R1) = offset;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L5359:
	asi64(R1) = am;
	R2 = 80;
	if (asi64(R1) != asi64(R2)) goto L5361;
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5360;
L5361:
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
L5360:
	goto L5354;
L5356:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5363;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5363:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5354;
L5357:
	R1 = 0;
	R2 = tou64("Idata &frameXXX");
	mm_support_gerror(asu64(R2), asu64(R1));
L5354:
	goto L5321;
	goto L5322;
L5326:
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5322;
L5327:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
	goto L5322;
L5328:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5365;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L5364;
L5365:
	R1 = 0;
L5364:
	R2 = 80;
	R3 = 1;
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5322;
L5329:
	asu64(R1) = p;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("IDATA: ");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5322:
L5321:
	return;
}

static u64 mm_genpcl_genmem_u(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L5366;
L5366:
	return asu64(R1);
}

static u64 mm_genpcl_genmem_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L5367;
L5367:
	return asu64(R1);
}

static void mm_genpcl_genpushmem_d(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static u64 mm_genpcl_genmemaddr_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L5369;
L5369:
	return asu64(R1);
}

static void mm_genpcl_genpushmemaddr_d(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static i64 mm_genpcl_definelabel() {
    u64 R1, R2; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = pc_api_mlabelno;
	goto L5371;
L5371:
	return asi64(R1);
}

static i64 mm_genpcl_createfwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L5372;
L5372:
	return asi64(R1);
}

static void mm_genpcl_definefwdlabel(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_genpcl_genreturn() {
    u64 R1, R2, R3; 
	asu64(R1) = mm_decls_currproc;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5376;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5377;
	goto L5378;
L5376:
	R1 = 0;
	R2 = 20;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5375;
L5377:
	R1 = 0;
	R2 = 23;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	goto L5375;
L5378:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	R3 = 122;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 23;
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
L5375:
	return;
}

static i64 mm_genpcl_reversecond(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5381;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5382;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5383;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5384;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5385;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5386;
	goto L5387;
L5381:
	R1 = 2;
	cc = asi64(R1);
	goto L5380;
L5382:
	R1 = 1;
	cc = asi64(R1);
	goto L5380;
L5383:
	R1 = 5;
	cc = asi64(R1);
	goto L5380;
L5384:
	R1 = 6;
	cc = asi64(R1);
	goto L5380;
L5385:
	R1 = 3;
	cc = asi64(R1);
	goto L5380;
L5386:
	R1 = 4;
	cc = asi64(R1);
	goto L5380;
L5387:
L5380:
	asi64(R1) = cc;
	goto L5379;
L5379:
	return asi64(R1);
}

static i64 mm_genpcl_reversecond_order(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5390;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5391;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5392;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5393;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5394;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5395;
	goto L5396;
L5390:
	R1 = 1;
	cc = asi64(R1);
	goto L5389;
L5391:
	R1 = 2;
	cc = asi64(R1);
	goto L5389;
L5392:
	R1 = 6;
	cc = asi64(R1);
	goto L5389;
L5393:
	R1 = 5;
	cc = asi64(R1);
	goto L5389;
L5394:
	R1 = 4;
	cc = asi64(R1);
	goto L5389;
L5395:
	R1 = 3;
	cc = asi64(R1);
	goto L5389;
L5396:
L5389:
	asi64(R1) = cc;
	goto L5388;
L5388:
	return asi64(R1);
}

static void mm_genpcl_stacklooplabels(i64 a, i64 b, i64 c) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_genpcl_loopindex;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L5399;
	R1 = 0;
	R2 = tou64("Too many nested loops");
	mm_support_gerror(asu64(R2), asu64(R1));
L5399:
	asi64(R1) = a;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 3;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static i64 mm_genpcl_findlooplabel(i64 k, i64 n) {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = mm_genpcl_loopindex;
	asi64(R2) = n;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5403;
	asi64(R1) = i;
	asi64(R2) = mm_genpcl_loopindex;
	if (asi64(R1) <= asi64(R2)) goto L5402;
L5403:
	R1 = 0;
	R2 = tou64("Bad loop index");
	mm_support_gerror(asu64(R2), asu64(R1));
L5402:
	R1 = (u64)&mm_genpcl_loopstack;
	asi64(R2) = i;
	R1 += (i64)R2*32-32;
	asi64(R2) = k;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L5400;
L5400:
	return asi64(R1);
}

static void mm_genpcl_genpc_sysfn(i64 fnindex, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asi64(R5) = fnindex;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_genpcl_genpc_sysproc(i64 fnindex, u64 a, u64 b, u64 c, i64 asfunc) {
    u64 R1, R2, R3; 
	i64 nargs;
	i64 opc;
	u64 d;
	u64 p;
	R1 = 0;
	nargs = asi64(R1);
	R1 = 0;
	opc = asi64(R1);
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	p = asu64(R1);
	R1 = (u64)&nargs;
	R2 = 3;
	asu64(R3) = c;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nargs;
	R2 = 2;
	asu64(R3) = b;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nargs;
	R2 = 1;
	asu64(R3) = a;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = nargs;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = fnindex;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5407;
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	asi64(R2) = asfunc;
	if (!asi64(R2)) goto L5409;
	R2 = 21;
	goto L5408;
L5409:
	R2 = 18;
L5408:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = nargs;
	pc_api_pc_setnargs(asi64(R1));
	goto L5406;
L5407:
	R1 = (u64)&mm_tables_sysfnnames;
	asi64(R2) = fnindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	asu64(R1) = pc_api_gennameaddr(asu64(R1));
	asi64(R2) = asfunc;
	if (!asi64(R2)) goto L5411;
	R2 = 21;
	goto L5410;
L5411:
	R2 = 18;
L5410:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5406:
	asi64(R1) = nargs;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_genpcl_pushsysarg(u64 p, i64 n, u64 nargs) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L5414;
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = nargs;
	(*toi64p(R1)) += 1;
L5414:
	return;
}

static void mm_genpcl_start() {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_genpcl_getsysfnhandler(i64 fn) {
    u64 R1, R2, R3; 
	u64 p;
	struct $B15 str;
	i64 report;
	u64 pp;
	R1 = (u64)&mm_tables_sysfnhandlers;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5418;
	R1 = (u64)&mm_tables_sysfnhandlers;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5416;
L5418:
	R1 = tou64("m$");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_sysfnnames;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L5422;
L5419:
	R1 = (u64)&str;
	asu64(R2) = pp;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5424;
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_tables_sysfnhandlers;
	asi64(R3) = fn;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5416;
L5424:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L5422:
	asu64(R1) = pp;
	if (asu64(R1)) goto L5419;
	R1 = 1;
	report = asi64(R1);
	R1 = 0;
	report = asi64(R1);
	asi64(R1) = report;
	if (!asi64(R1)) goto L5426;
	msysc_m$print_startcon();
	R1 = tou64("Sysfn not found:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5426:
	asi64(R1) = fn;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L5428;
	R1 = 33;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5430;
	asi64(R1) = report;
	if (!asi64(R1)) goto L5430;
	R1 = 0;
	R2 = tou64("No m$unimpl");
	mm_support_gerror(asu64(R2), asu64(R1));
L5430:
	asu64(R1) = p;
	goto L5416;
L5428:
	R1 = 0;
	goto L5416;
L5416:
	return asu64(R1);
}

static u64 mm_genpcl_findhostfn(i64 opc) {
    u64 R1, R2; 
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5433;
	goto L5434;
L5433:
	R1 = 32;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	goto L5432;
L5434:
	R1 = 0;
L5432:
	goto L5431;
L5431:
	return asu64(R1);
}

static void mm_genpcl_genpushint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genpushreal(r64 x, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asr64(R2) = x;
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genpushstring(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genmaindef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 i;
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5441;
L5439:
	asi64(R1) = i;
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) == asi64(R2)) goto L5443;
	R1 = (u64)&mm_decls_modules;
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
L5443:
	i += 1; if (i <= mm_decls_nsubprogs) goto L5439;
L5441:
	R1 = (u64)&mm_decls_modules;
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = mm_decls_mainsubprogno;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
	return;
}

static void mm_genpcl_genstartdef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lead;
	i64 m;
	i64 s;
	i64 i;
	R1 = 0;
	lead = asi64(R1);
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L5446;
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = s;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L5446;
	R1 = 1;
	lead = asi64(R1);
	goto L5445;
L5446:
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = s;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L5447;
	R1 = 2;
	lead = asi64(R1);
L5447:
L5445:
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	asi64(R1) = lead;
	if (!asi64(R1)) goto L5449;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5452;
L5450:
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = s;
	if (asi64(R1) != asi64(R2)) goto L5454;
	asi64(R1) = i;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L5454;
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
L5454:
	i += 1; if (i <= mm_decls_nmodules) goto L5450;
L5452:
L5449:
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
	return;
}

static void mm_genpcl_initstaticvar(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5457;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
L5457:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_genpcl_docallproc(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	if (asu64(R1)) goto L5460;
	goto L5458;
L5460:
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_api_pc_setnargs(asi64(R1));
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 18;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5458:
	return;
}

static void mm_genpcl_doprocdef(u64 d, i64 ismain) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 e;
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = ismain;
	R3 = 0;
	asu64(R4) = d;
	asu64(R4) = mm_libpcl_getpsymbol(asu64(R4));
	R5 = R4;
	p = asu64(R5);
	pc_api_pc_defproc(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5465;
L5462:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5467;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5468;
	goto L5469;
L5467:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	goto L5466;
L5468:
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5472;
	asu64(R1) = e;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5471;
L5472:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addlocal(asu64(R1));
L5471:
	goto L5466;
L5469:
L5466:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5465:
	asu64(R1) = e;
	if (asu64(R1)) goto L5462;
	return;
}

static void mm_genpcl_scanprocs() {
    u64 R1, R2, R3; 
	struct $B70 proctable;
	u64 currpcl;
	i64 nprocs;
	i64 i;
	R1 = 0;
	nprocs = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	currpcl = asu64(R1);
L5474:
	asu64(R1) = currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L5479;
	R2 = 121;
	if (asi64(R1) != asi64(R2)) goto L5478;
L5479:
	asu64(R1) = currpcl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5478;
	asi64(R1) = nprocs;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L5481;
	R1 = 0;
	R2 = tou64("PCL proctab overflow");
	mm_support_gerror(asu64(R2), asu64(R1));
L5481:
	asu64(R1) = currpcl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&proctable;
	R3 = (u64)&nprocs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5478:
	R1 = (u64)&currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L5474;
	asi64(R1) = nprocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5483;
	asu64(R1) = mm_blockpcl_pnprocs;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5483;
	R1 = 3;
	R2 = tou64("$nprocs");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pnprocs = asu64(R1);
	R1 = 10;
	asu64(R2) = mm_blockpcl_pnprocs;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5484;
L5483:
	mm_genpcl_setfunctab();
	asu64(R1) = mm_blockpcl_pprocaddr;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nprocs;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 11;
	asu64(R2) = mm_blockpcl_pprocaddr;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_api_pccurr;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = mm_blockpcl_pprocaddr;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5487;
L5485:
	R1 = (u64)&proctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nprocs) goto L5485;
L5487:
	asu64(R1) = mm_blockpcl_pprocname;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nprocs;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 11;
	asu64(R2) = mm_blockpcl_pprocname;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_api_pccurr;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = mm_blockpcl_pprocname;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5490;
L5488:
	R1 = (u64)&proctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nprocs) goto L5488;
L5490:
// mm_genpcl.scanprocs.finish:
L5484:
	asu64(R1) = mm_blockpcl_pnprocs;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = nprocs;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_setfunctab() {
    u64 R1, R2, R3; 
	asu64(R1) = mm_blockpcl_pnprocs;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5493;
	R1 = 3;
	R2 = tou64("$nprocs");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pnprocs = asu64(R1);
	R1 = 10;
	asu64(R2) = mm_blockpcl_pnprocs;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = tou64("$procname");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pprocname = asu64(R1);
	R1 = 3;
	R2 = tou64("$procaddr");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pprocaddr = asu64(R1);
L5493:
	return;
}

static u64 mm_libpcl_getpsymbol(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 e;
	struct $B16 str;
	struct $B22 chain;
	i64 n;
	i64 i;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5496;
	R1 = 0;
	goto L5494;
L5496:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5498;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5494;
L5498:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5500;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5500;
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getequivdef(asu64(R1));
	R2 = R1;
	e = asu64(R2);
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5494;
L5500:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5503;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5503;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5502;
L5503:
	asu64(R1) = d;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5505;
	asu64(R1) = d;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5504;
L5505:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L5504:
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L5501;
L5502:
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L5506:
	asu64(R1) = e;
	R2 = (u64)&chain;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5509;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5506;
L5509:
	R1 = (u64)&chain;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5512;
L5510:
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5514;
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L5513;
L5514:
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L5513:
	i += -1; if (i >= 1) goto L5510;
L5512:
L5501:
	R1 = (u64)&mm_tables_name2pid;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	R2 = R1;
	p = asu64(R2);
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5516;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5516;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5516:
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5518;
	R1 = 1;
	asu64(R2) = p;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5518:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5521;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5520;
L5521:
	R1 = 1;
	asu64(R2) = p;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5520:
	asu64(R1) = d;
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 6;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = p;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 108;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	if (!asu16(R1)) goto L5523;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5523;
	asu64(R1) = e;
	if (!asu64(R1)) goto L5523;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5523;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5523;
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 104;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5523:
	asu64(R1) = p;
	goto L5494;
L5494:
	return asu64(R1);
}

static void mm_libpcl_setmode(i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = mode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asi64(R2) = mode;
	asi64(R2) = mm_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static void mm_libpcl_setmode2(i64 mode) {
    u64 R1; 
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	pc_api_pc_setmode2(asi64(R1));
	return;
}

static void mm_libpcl_setmode_u(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = mode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asi64(R2) = mode;
	asi64(R2) = mm_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static u64 mm_libpcl_getequivdef(u64 d) {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5529;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L5530;
	goto L5531;
L5529:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5528;
L5530:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5528;
L5531:
	R1 = 0;
	R2 = tou64("geteqv");
	mm_support_gerror(asu64(R2), asu64(R1));
	R1 = 0;
L5528:
	goto L5527;
L5527:
	return asu64(R1);
}

static void mm_blockpcl_evalunit(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 a;
	u64 b;
	u64 c;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5534;
	goto L5532;
L5534:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L5538;
	case 2: goto L5539;
	case 3: case 5: case 7: case 9: case 10: case 11: case 12: case 13: case 20: case 21: case 22: case 23: case 24: case 26: case 27: case 37: case 41: case 42: case 43: case 44: case 45: case 47: case 50: case 54: case 57: case 60: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: goto L5537;
	case 4: goto L5540;
	case 6: goto L5541;
	case 8: goto L5602;
	case 14: goto L5604;
	case 15: goto L5575;
	case 16: goto L5576;
	case 17: goto L5592;
	case 18: goto L5593;
	case 19: goto L5594;
	case 25: goto L5544;
	case 28: goto L5545;
	case 29: goto L5547;
	case 30: goto L5546;
	case 31: goto L5548;
	case 32: goto L5542;
	case 33: goto L5577;
	case 34: goto L5578;
	case 35: goto L5579;
	case 36: goto L5591;
	case 38: goto L5599;
	case 39: goto L5600;
	case 40: goto L5595;
	case 46: goto L5580;
	case 48: goto L5605;
	case 49: goto L5583;
	case 51: goto L5581;
	case 52: goto L5582;
	case 53: goto L5584;
	case 55: goto L5585;
	case 56: goto L5586;
	case 58: goto L5587;
	case 59: goto L5589;
	case 61: goto L5588;
	case 62: goto L5590;
	case 89: goto L5543;
	case 90: goto L5601;
	case 91: goto L5549;
	case 92: goto L5550;
	case 93: goto L5551;
	case 94: goto L5552;
	case 95: goto L5553;
	case 96: goto L5554;
	case 97: goto L5555;
	case 98: goto L5556;
	case 99: goto L5557;
	case 100: goto L5558;
	case 101: goto L5559;
	case 102: goto L5560;
	case 103: goto L5561;
	case 104: goto L5562;
	case 105: goto L5563;
	case 106: goto L5564;
	case 107: case 108: case 109: case 110: goto L5565;
	case 111: goto L5567;
	case 112: goto L5568;
	case 113: goto L5566;
	case 114: case 115: goto L5569;
	case 116: case 117: goto L5570;
	case 118: goto L5571;
	case 119: goto L5572;
	case 120: goto L5573;
	case 121: goto L5574;
	case 122: goto L5603;
	default: goto L5537;
    };
// SWITCH
L5538:
	asu64(R1) = p;
	mm_blockpcl_do_const(asu64(R1));
	goto L5535;
L5539:
	goto L5535;
L5540:
	asu64(R1) = p;
	mm_blockpcl_do_name(asu64(R1));
	goto L5535;
L5541:
	asu64(R1) = p;
	mm_blockpcl_do_block(asu64(R1));
	goto L5535;
L5542:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_callproc(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5543:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_return(asu64(R2), asu64(R1));
	goto L5535;
L5544:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_returnmult(asu64(R2), asu64(R1));
	goto L5535;
L5545:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_assign(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5546:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignms(asu64(R2), asu64(R1));
	goto L5535;
L5547:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignmm(asu64(R2), asu64(R1));
	goto L5535;
L5548:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignmdrem(asu64(R2), asu64(R1));
	goto L5535;
L5549:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_to(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5550:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5535;
L5551:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_for(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5535;
L5552:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_for(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5535;
L5553:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_forall(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5535;
L5554:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_forall(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5535;
L5555:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_blockpcl_do_while(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5556:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_repeat(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5557:
	asu64(R1) = a;
	mm_blockpcl_do_goto(asu64(R1));
	goto L5535;
L5558:
	asu64(R1) = p;
	mm_blockpcl_do_labeldef(asu64(R1));
	goto L5535;
L5559:
	R1 = 1;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L5535;
L5560:
	R1 = 2;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L5535;
L5561:
	R1 = 3;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L5535;
L5562:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_do(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5563:
	R1 = 0;
	R2 = 0;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_blockpcl_do_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5535;
L5564:
	R1 = 0;
	R2 = 1;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_blockpcl_do_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5535;
L5565:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_switch(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5535;
L5566:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_recase(asu64(R2), asu64(R1));
	goto L5535;
L5567:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_swap(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5568:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_select(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5535;
L5569:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_print(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5570:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_print(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5571:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_read(asu64(R2), asu64(R1));
	goto L5535;
L5572:
	asu64(R1) = a;
	mm_blockpcl_do_readln(asu64(R1));
	goto L5535;
L5573:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_stop(asu64(R2), asu64(R1));
	goto L5535;
L5574:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 134;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5535;
L5575:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_andl(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5576:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_orl(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5577:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_setcc(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5578:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_setccchain(asu64(R2), asu64(R1));
	goto L5535;
L5579:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_bin(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5580:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_index(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5581:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_dotindex(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5582:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_dotslice(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5583:
	asu64(R1) = p;
	mm_blockpcl_do_dot(asu64(R1));
	goto L5535;
L5584:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_ptr(asu64(R2), asu64(R1));
	goto L5535;
L5585:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L5535;
L5586:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L5535;
L5587:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_convert(asu64(R2), asu64(R1));
	goto L5535;
L5588:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_typepun(asu64(R2), asu64(R1));
	goto L5535;
L5589:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_shorten(asu64(R2), asu64(R1));
	goto L5535;
L5590:
	asu64(R1) = p;
	mm_blockpcl_do_typeconst(asu64(R1));
	goto L5535;
L5591:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_unary(asu64(R2), asu64(R1));
	goto L5535;
L5592:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_notl(asu64(R2), asu64(R1));
	goto L5535;
L5593:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_istruel(asu64(R2), asu64(R1));
	goto L5535;
L5594:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_isfalsel(asu64(R2), asu64(R1));
	goto L5535;
L5595:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L5598;
	R2 = 85;
	if (asi64(R1) != asi64(R2)) goto L5597;
L5598:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_incr(asu64(R2), asu64(R1));
	goto L5596;
L5597:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_incrload(asu64(R2), asu64(R1));
L5596:
	goto L5535;
L5599:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_binto(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5600:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_unaryto(asu64(R2), asu64(R1));
	goto L5535;
L5601:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_syscall(asu64(R2), asu64(R1));
	goto L5535;
L5602:
	asu64(R1) = p;
	asu64(R1) = pc_api_genassem(asu64(R1));
	R2 = 42;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5535;
L5603:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_empty(asu64(R2), asu64(R1));
	goto L5535;
L5604:
	R1 = tou64(" ");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_api_gencomment(asu64(R1));
	goto L5535;
L5605:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_slice(asu64(R3), asu64(R2), asu64(R1));
	goto L5535;
L5537:
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("UNSUPPORTED TAG ");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L5532;
L5535:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5607;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5607;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5609;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L5609;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L5609;
	goto L5610;
L5609:
	goto L5608;
L5610:
	R1 = (u64)&mm_tables_jsolo;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5612;
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("NOT ALLOWED BY ITSELF:");
	asu64(R2) = pc_api_addstr(asu64(R3), asu64(R2));
	mm_support_gerror(asu64(R2), asu64(R1));
L5612:
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5608:
L5607:
L5532:
	return;
}

static void mm_blockpcl_evalref(u64 p, u64 q) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	u64 b;
	u64 c;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5615;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5616;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5617;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5618;
	goto L5619;
L5615:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushmemaddr_d(asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = q;
	if (!asu64(R1)) goto L5621;
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 17;
	mm_libpcl_setmode(asi64(R1));
L5621:
	goto L5614;
L5616:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_indexref(asu64(R2), asu64(R1));
	goto L5614;
L5617:
	asu64(R1) = p;
	mm_blockpcl_do_dotref(asu64(R1));
	goto L5614;
L5618:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	goto L5614;
L5619:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5623;
	goto L5624;
L5623:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5622;
L5624:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("evalref");
	mm_support_gerror(asu64(R2), asu64(R1));
L5622:
L5614:
	return;
}

static void mm_blockpcl_evalarray(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5627;
	goto L5628;
L5627:
	R1 = 0;
	asu64(R2) = p;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5626;
L5628:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L5630;
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5629;
L5630:
	R1 = 0;
	asu64(R2) = p;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
L5629:
L5626:
	return;
}

static void mm_blockpcl_do_block(u64 p) {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L5633;
L5632:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L5633:
	asu64(R1) = a;
	if (asu64(R1)) goto L5632;
	return;
}

static void mm_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	u64 s;
	i64 lab2;
	i64 i;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5637;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5638;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5639;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5639;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5640;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5641;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L5642;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5643;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L5644;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5645;
	goto L5646;
L5637:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5648;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5649;
	goto L5650;
L5648:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5647;
L5649:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L5647;
L5650:
L5647:
	goto L5636;
L5638:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5652;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5653;
	goto L5654;
L5652:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L5651;
L5653:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5651;
L5654:
L5651:
	goto L5636;
L5639:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5656;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5657;
	goto L5658;
L5656:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5655;
L5657:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5655;
L5658:
L5655:
	goto L5636;
L5640:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5636;
L5641:
	goto L5660;
L5659:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5660:
	asu64(R1) = q;
	if (!asu64(R1)) goto L5662;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5659;
L5662:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5636;
L5642:
	asi64(R1) = lab;
	asu64(R2) = r;
	asu64(R3) = q;
	asu64(R4) = p;
	R5 = 64;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asi64(R5) = opc;
	mm_blockpcl_gcomparejump(asi64(R5), asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5636;
L5643:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L5664;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 3;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 4;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L5663;
L5664:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 3;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 6;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L5663:
	goto L5636;
L5644:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5666;
	R1 = 0;
	R2 = tou64("empty set");
	mm_support_gerror(asu64(R2), asu64(R1));
L5666:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L5668;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5670;
L5669:
	asu64(R1) = s;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	if (!asu64(R1)) goto L5673;
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5672;
L5673:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 2;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5672:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L5670:
	asu64(R1) = s;
	if (asu64(R1)) goto L5669;
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L5667;
L5668:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5677;
L5674:
	asu64(R1) = s;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5679;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5679:
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
L5677:
	asu64(R1) = s;
	if (asu64(R1)) goto L5674;
L5667:
	goto L5636;
L5645:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L5681;
	goto L5683;
L5682:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5686;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	asi64(R2) = mm_genpcl_reversecond_order(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5685;
L5686:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5685:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L5683:
	asu64(R1) = r;
	if (asu64(R1)) goto L5682;
	goto L5680;
L5681:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	goto L5688;
L5687:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5691;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	asi64(R2) = mm_genpcl_reversecond_order(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5690;
L5691:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5690:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L5688:
	asu64(R1) = r;
	if (asu64(R1)) goto L5687;
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
L5680:
	goto L5636;
L5646:
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttisblock;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5693;
	R1 = 0;
	R2 = tou64("jumpt/f");
	mm_support_gerror(asu64(R2), asu64(R1));
L5693:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
L5636:
	return;
}

static void mm_blockpcl_gcomparejump(i64 jumpopc, i64 cond, u64 lhs, u64 rhs, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = jumpopc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L5696;
	asi64(R1) = cond;
	asi64(R1) = mm_genpcl_reversecond(asi64(R1));
	cond = asi64(R1);
L5696:
	asu64(R1) = lhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = cond;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = lhs;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_unimpl(u64 mess) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = mess;
	R3 = tou64("Unimplemented: #");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_const(u64 p) {
    u64 R1, R2, R3; 
	i64 mode;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5702;
	asi64(R1) = mode;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5701;
L5702:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	goto L5700;
L5701:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5703;
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	mm_genpcl_genpushreal(asr64(R2), asi64(R1));
	goto L5700;
L5703:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5704;
	asu64(R1) = p;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5706;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L5708;
	R1 = 0;
	R2 = tou64("1:B-str?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5708:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushstring(asu64(R1));
	goto L5705;
L5706:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
L5705:
	goto L5700;
L5704:
	R1 = 0;
	R2 = tou64("do_const");
	mm_support_gerror(asu64(R2), asu64(R1));
L5700:
	asi64(R1) = mode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_name(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5711;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5711;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5712;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5713;
	goto L5714;
L5711:
	asu64(R1) = d;
	mm_genpcl_genpushmemaddr_d(asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5710;
L5712:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5716;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5716:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5718;
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5717;
L5718:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5717:
	goto L5710;
L5713:
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_genpcl_genpushint(asi64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5710;
L5714:
	asu64(R1) = d;
	mm_genpcl_genpushmem_d(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
L5710:
	return;
}

static void mm_blockpcl_do_stop(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L5721;
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5720;
L5721:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L5720:
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_andl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 labfalse;
	i64 labend;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	labfalse = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = labfalse;
	asu64(R2) = a;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labfalse;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = labfalse;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_orl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 labtrue;
	i64 labfalse;
	i64 labend;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	labtrue = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labfalse = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = labtrue;
	asu64(R2) = a;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labfalse;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labtrue;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = labfalse;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_notl(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_istruel(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
	return;
}

static void mm_blockpcl_do_isfalsel(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 65;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
	return;
}

static void mm_blockpcl_do_typepun(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5729;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 92;
	R2 += (i64)R3;
	R3 = 5;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5729:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L5731;
	goto L5727;
L5731:
	R1 = 0;
	R2 = 110;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 53;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
L5727:
	return;
}

static void mm_blockpcl_do_shorten(u64 p, u64 a) {
    u64 R1; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	return;
}

static void mm_blockpcl_do_assign(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5735;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (asu16(R1)) goto L5735;
	goto L5733;
L5735:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5737;
	goto L5738;
L5737:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5740;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_assignblock(asu64(R3), asu64(R2), asu64(R1));
	goto L5733;
L5740:
	goto L5736;
L5738:
L5736:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5742;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L5743;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5744;
	goto L5745;
L5742:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	mm_blockpcl_do_storeindex(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L5733;
	goto L5741;
L5743:
	R1 = 0;
	R2 = tou64("ASS/SLICE");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L5741;
L5744:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	mm_blockpcl_do_storedot(asu64(R3), asu64(R2), asu64(R1));
	goto L5733;
	goto L5741;
L5745:
L5741:
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5747;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5747:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5749;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5750;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5751;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5752;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5753;
	goto L5754;
L5749:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5757;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5757;
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5756;
L5757:
	R1 = 0;
	R2 = tou64("Assign to proc?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5756:
	asu64(R1) = a;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5748;
L5750:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5748;
L5751:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 16;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	goto L5733;
	goto L5748;
L5752:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 17;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	goto L5733;
	goto L5748;
L5753:
	R1 = 1;
	asu64(R2) = a;
	R3 = 32;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = a;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5748;
L5754:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Can't assign");
	mm_support_gerror(asu64(R2), asu64(R1));
L5748:
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
L5733:
	return;
}

static void mm_blockpcl_do_bin(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L5761;
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L5760;
L5761:
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asu64(R3) = p;
	R4 = 62;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L5759;
L5760:
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L5763;
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L5763:
L5759:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_setcc(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 64;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 31;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_setccchain(u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	i64 lab1;
	i64 lab2;
	i64 i;
	i64 cond;
	u64 r;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5767;
L5766:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R1) = mm_genpcl_reversecond(asi64(R1));
	cond = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5770;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = cond;
	asi64(R1) = mm_genpcl_reversecond_order(asi64(R1));
	cond = asi64(R1);
L5770:
	asi64(R1) = lab1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = cond;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5772;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5772:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L5767:
	asu64(R1) = r;
	if (asu64(R1)) goto L5766;
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = lab1;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_binto(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5775;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5775;
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L5775:
	return;
}

static void mm_blockpcl_do_unary(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 adj;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5778;
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5780;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5780;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5781;
	goto L5782;
L5780:
	R1 = 8;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5784;
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	adj = asi64(R1);
	asi64(R1) = adj;
	if (!asi64(R1)) goto L5786;
	asi64(R1) = adj;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 43;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L5786:
L5784:
	goto L5779;
L5781:
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5779;
L5782:
L5779:
	goto L5776;
L5778:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
L5776:
	return;
}

static void mm_blockpcl_do_unaryto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_ptr(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_labeldef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	struct $B16 str;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5791;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5791:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 128;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_goto(u64 a) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5794;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5794;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5796;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5796:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5793;
L5794:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5793:
	return;
}

static void mm_blockpcl_do_do(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 lab_abc;
	i64 lab_d;
	asi64(R1) = mm_genpcl_definelabel();
	lab_abc = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_abc;
	asi64(R3) = lab_abc;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_to(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 cvar;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 count;
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cvar = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = cvar;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5800;
	asu64(R1) = cvar;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = mm_genpcl_pzero;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_d;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 4;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5799;
L5800:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	count = asi64(R1);
	asi64(R1) = count;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L5802;
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
L5802:
L5799:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 33;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = cvar;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_while(u64 p, u64 pcond, u64 pbody, u64 pincr) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_incr;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L5805;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_incr = asi64(R1);
	goto L5804;
L5805:
	asi64(R1) = lab_c;
	lab_incr = asi64(R1);
L5804:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = lab_incr;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L5807;
	asu64(R1) = pincr;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_incr;
	mm_genpcl_definefwdlabel(asi64(R1));
L5807:
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_repeat(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 lab_ab;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = mm_genpcl_definelabel();
	lab_ab = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_ab;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5811;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5810;
L5811:
	asi64(R1) = lab_ab;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
L5810:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_exit(u64 p, i64 k) {
    u64 R1, R2; 
	i64 n;
	i64 index;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	index = asi64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5814;
	asi64(R1) = mm_genpcl_loopindex;
	index = asi64(R1);
L5814:
	asi64(R1) = index;
	asi64(R2) = k;
	asi64(R1) = mm_genpcl_findlooplabel(asi64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5816;
	asu64(R1) = p;
	R2 = tou64("Bad exit/loop index");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L5815;
L5816:
	asi64(R1) = n;
	mm_blockpcl_genjumpl(asi64(R1));
L5815:
	return;
}

static void mm_blockpcl_do_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 isref) {
    u64 R1, R2, R3; 
	i64 labend;
	i64 i;
	i64 lab2;
	i64 ismult;
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	ismult = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L5819;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5819:
	goto L5823;
L5820:
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = pcond;
	R3 = 28;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L5825;
	R1 = 0;
	asu64(R2) = plist;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L5824;
L5825:
	asu64(R1) = plist;
	mm_blockpcl_evalunit(asu64(R1));
L5824:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L5827;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5827:
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5830;
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5829;
L5830:
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
L5829:
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcond = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
L5823:
	asu64(R1) = pcond;
	if (asu64(R1)) goto L5820;
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5832;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L5834;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L5833;
L5834:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L5833:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L5836;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5836:
L5832:
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_return(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L5839;
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5838;
L5839:
	asi64(R1) = mm_genpcl_retindex;
	mm_blockpcl_genjumpl(asi64(R1));
L5838:
	return;
}

static void mm_blockpcl_do_returnmult(u64 p, u64 a) {
    u64 R1, R2, R3; 
	struct $B93 params;
	u64 q;
	i64 nparams;
	i64 i;
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 0;
	nparams = asi64(R1);
	goto L5842;
L5841:
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5845;
	R1 = 0;
	R2 = tou64("Mult?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5845:
	asu64(R1) = q;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5842:
	asu64(R1) = q;
	if (asu64(R1)) goto L5841;
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5848;
L5846:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_evalunit(asu64(R1));
	i += -1; if (i >= 1) goto L5846;
L5848:
	asi64(R1) = mm_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 30;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = nparams;
	pc_api_pc_setnargs(asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_blockpcl_do_callproc(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	struct $B93 paramlist;
	struct $B5 argattr;
	i64 nparams;
	i64 isptr;
	i64 nvariadics;
	i64 nret;
	i64 isfn;
	i64 iparams;
	i64 fparams;
	i64 nfixedparams;
	u64 d;
	u64 e;
	u64 pmult;
	u64 q;
	i64 i;
	R1 = 0;
	isptr = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5851;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5852;
	goto L5853;
L5851:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5850;
L5852:
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 1;
	isptr = asi64(R1);
	goto L5850;
L5853:
	R1 = 0;
	R2 = tou64("call/not ptr");
	mm_support_gerror(asu64(R2), asu64(R1));
L5850:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nvariadics = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	nfixedparams = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5857;
L5854:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5859;
	R1 = (u64)&nfixedparams;
	(*toi64p(R1)) += 1;
L5859:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5857:
	asu64(R1) = e;
	if (asu64(R1)) goto L5854;
	asu64(R1) = b;
	q = asu64(R1);
	goto L5863;
L5860:
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5865;
	R1 = 0;
	R2 = tou64("maxparams");
	mm_support_gerror(asu64(R2), asu64(R1));
L5865:
	asu64(R1) = q;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5867;
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) < asi64(R2)) goto L5867;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L5867;
	asi64(R1) = nvariadics;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5867;
	asi64(R1) = nparams;
	nvariadics = asi64(R1);
L5867:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5863:
	asu64(R1) = q;
	if (asu64(R1)) goto L5860;
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	fparams = asi64(R2);
	iparams = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5870;
L5868:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5873;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5872;
L5873:
	R1 = (u64)&fparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5875;
	R1 = 2;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L5875:
	goto L5871;
L5872:
	R1 = (u64)&iparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5877;
	R1 = 2;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L5877:
L5871:
	i += 1; if (i <= nparams) goto L5868;
L5870:
	asi64(R1) = fparams;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5879;
	asi64(R1) = iparams;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5879;
	R1 = 0;
	R2 = tou64("Mixed stack args");
	mm_support_gerror(asu64(R2), asu64(R1));
L5879:
	asi64(R1) = fparams;
	asi64(R2) = iparams;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	R2 = 8;
	asi64(R1) -= asi64(R2);
	iparams = asi64(R1);
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5882;
L5880:
	asi64(R1) = iparams;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5884;
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	if (!asi8(R1)) goto L5884;
	R1 = 1;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	R1 = 0;
	iparams = asi64(R1);
L5884:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L5886;
	asi64(R1) = i;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L5886;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5886;
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 2;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 1;
	mm_libpcl_setmode(asi64(R1));
	goto L5885;
L5886:
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L5885:
	asi64(R1) = i;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	R1 = toi64(toi8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += -1; if (i >= 1) goto L5880;
L5882:
	asi64(R1) = isptr;
	if (asi64(R1)) goto L5888;
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L5890;
	R2 = 21;
	goto L5889;
L5890:
	R2 = 18;
L5889:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5887;
L5888:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L5892;
	R2 = 22;
	goto L5891;
L5892:
	R2 = 19;
L5891:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5887:
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = nvariadics;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L5894;
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5894:
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L5896;
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L5896;
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nret = asi64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5899;
L5897:
	R1 = 0;
	R2 = 13;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pmult;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nret) goto L5897;
L5899:
L5896:
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L5901;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5901;
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5901:
	return;
}

static void mm_blockpcl_do_print(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	u64 fmt;
	i64 m;
	i64 fn;
	i64 needprintend;
	asu64(R1) = a;
	if (!asu64(R1)) goto L5904;
	R1 = 1;
	needprintend = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5906;
	R1 = 0;
	R2 = tou64("@dev no ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L5906:
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5908;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5909;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5910;
	goto L5911;
L5908:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 2;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5907;
L5909:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 3;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5907;
L5910:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 4;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5907;
L5911:
	R1 = 0;
	R2 = tou64("@dev?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5907:
	goto L5903;
L5904:
	R1 = 1;
	needprintend = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 5;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L5903:
	asu64(R1) = b;
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L5913;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L5913;
	goto L5914;
L5913:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5917;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = q;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5916;
L5917:
	R1 = 0;
	R2 = tou64("string expected");
	mm_support_gerror(asu64(R2), asu64(R1));
L5916:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = q;
	R5 = 6;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5912;
L5914:
L5912:
	goto L5919;
L5918:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L5922;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5923;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L5924;
	goto L5925;
L5922:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fmt = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	goto L5921;
L5923:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 7;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5919;
	goto L5921;
L5924:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 8;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5919;
	goto L5921;
L5925:
	R1 = 0;
	fmt = asu64(R1);
	asu64(R1) = q;
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
L5921:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5927;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5928;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5929;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5930;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5931;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5932;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5933;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5934;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5935;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5936;
	goto L5937;
L5927:
	R1 = 9;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L5939;
	R1 = 10;
	fn = asi64(R1);
L5939:
	goto L5926;
L5928:
	R1 = 11;
	fn = asi64(R1);
	goto L5926;
L5929:
	R1 = 13;
	fn = asi64(R1);
	goto L5926;
L5930:
	R1 = 12;
	fn = asi64(R1);
	goto L5926;
L5931:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5942;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5941;
	R1 = (u64)&mm_decls_tttarget;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5941;
L5942:
	R1 = 14;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L5944;
	R1 = 15;
	fn = asi64(R1);
L5944:
	goto L5940;
L5941:
	R1 = 17;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L5946;
	R1 = 18;
	fn = asi64(R1);
L5946:
L5940:
	goto L5926;
L5932:
	R1 = 20;
	fn = asi64(R1);
	goto L5926;
L5933:
	R1 = 0;
	R2 = tou64("PRINTARRAY");
	mm_support_gerror(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5926;
L5934:
	R1 = 0;
	R2 = tou64("PRINTRECORD");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L5926;
L5935:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5948;
	R1 = 16;
	fn = asi64(R1);
	goto L5947;
L5948:
	R1 = 0;
	R2 = tou64("PRINTSLICE");
	mm_support_gerror(asu64(R2), asu64(R1));
L5947:
	goto L5926;
L5936:
	R1 = 19;
	fn = asi64(R1);
	goto L5926;
L5937:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("PRINT/T=#");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5926:
	asi64(R1) = fn;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5950;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5950;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5950;
	goto L5951;
L5950:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = r;
	asi64(R5) = fn;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5949;
L5951:
	R1 = 0;
	R2 = 0;
	asu64(R3) = fmt;
	if (!asu64(R3)) goto L5953;
	asu64(R3) = fmt;
	goto L5952;
L5953:
	asu64(R3) = mm_genpcl_pzero;
L5952:
	asu64(R4) = r;
	asi64(R5) = fn;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L5949:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5919:
	asu64(R1) = q;
	if (asu64(R1)) goto L5918;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 115;
	if (asi64(R1) == asi64(R2)) goto L5955;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L5955;
	goto L5956;
L5955:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 21;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5954;
L5956:
L5954:
	asi64(R1) = needprintend;
	if (!asi64(R1)) goto L5958;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 22;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L5958:
	return;
}

static void mm_blockpcl_do_incr(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_blockpcl_setincrstep(asi64(R1));
	return;
}

static void mm_blockpcl_setincrstep(i64 m) {
    u64 R1, R2, R3; 
	R1 = 1;
	pc_api_pc_setincr(asi64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5962;
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	pc_api_pc_setincr(asi64(R1));
L5962:
	return;
}

static void mm_blockpcl_do_incrload(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_blockpcl_setincrstep(asi64(R1));
	return;
}

static void mm_blockpcl_do_for(u64 p, u64 pindex, u64 pfrom, u64 pbody, i64 down) {
    u64 R1, R2, R3; 
	u64 pto;
	u64 pstep;
	u64 pelse;
	u64 px;
	u64 ptoinit;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 a;
	i64 b;
	i64 stepx;
	u64 d;
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = pto;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pstep = asu64(R1);
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptoinit = asu64(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 53;
	if (asi64(R1) != asi64(R2)) goto L5966;
	asu64(R1) = pto;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = px;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5968;
	asu64(R1) = px;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5968;
	asu64(R1) = d;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5968;
	R1 = 0;
	R2 = tou64("Possibly using &param as for-loop limit");
	mm_support_gerror(asu64(R2), asu64(R1));
L5968:
L5966:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5970;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_e = asi64(R1);
	goto L5969;
L5970:
	asi64(R1) = lab_d;
	lab_e = asi64(R1);
L5969:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = ptoinit;
	if (!asu64(R1)) goto L5972;
	R1 = 0;
	asu64(R2) = ptoinit;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ptoinit;
	mm_blockpcl_evalunit(asu64(R1));
L5972:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5974;
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5974;
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = down;
	if (!asi64(R1)) goto L5978;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L5977;
L5978:
	asi64(R1) = down;
	if (asi64(R1)) goto L5976;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L5976;
L5977:
	goto L5975;
L5976:
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5975:
	goto L5973;
L5974:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5980;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L5982;
	R2 = 6;
	goto L5981;
L5982:
	R2 = 3;
L5981:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	goto L5979;
L5980:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L5984;
	R2 = 3;
	goto L5983;
L5984:
	R2 = 6;
L5983:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5979:
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L5973:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pstep;
	if (!asu64(R1)) goto L5986;
	asu64(R1) = pstep;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5988;
	R1 = 0;
	R2 = tou64("for/step non-const not ready");
	mm_support_gerror(asu64(R2), asu64(R1));
L5988:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	stepx = asi64(R1);
	asi64(R1) = stepx;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L5990;
	R1 = 0;
	R2 = tou64("Bad for-step");
	mm_support_gerror(asu64(R2), asu64(R1));
L5990:
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = stepx;
	asi64(R3) = down;
	if (!asi64(R3)) goto L5992;
	R3 = 35;
	goto L5991;
L5992:
	R3 = 34;
L5991:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5985;
L5986:
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	asi64(R3) = down;
	if (!asi64(R3)) goto L5994;
	R3 = 35;
	goto L5993;
L5994:
	R3 = 34;
L5993:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L5985:
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5996;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5997;
	goto L5998;
L5996:
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5995;
L5997:
	asu64(R1) = pto;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5995;
L5998:
L5995:
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L6000;
	asi64(R1) = lab_e;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L6000:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_forall(u64 p, u64 pindex, u64 plist, u64 pbody, i64 down) {
    u64 R1, R2, R3; 
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 pelse;
	u64 passign;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 a;
	i64 b;
	u64 dto;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plocal = asu64(R1);
	asu64(R1) = plocal;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	passign = asu64(R1);
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L6003;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_e = asi64(R1);
	goto L6002;
L6003:
	asi64(R1) = lab_d;
	lab_e = asi64(R1);
L6002:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6005;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6005;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	dto = asu64(R1);
	asu64(R1) = dto;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = dto;
	asu64(R1) = mm_lib_createname(asu64(R1));
	pto = asu64(R1);
	asu64(R1) = dto;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pto;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pto;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6005:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6007;
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6007;
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = down;
	if (!asi64(R1)) goto L6011;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L6010;
L6011:
	asi64(R1) = down;
	if (asi64(R1)) goto L6009;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L6009;
L6010:
	goto L6008;
L6009:
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6008:
	goto L6006;
L6007:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6013;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L6015;
	R2 = 6;
	goto L6014;
L6015:
	R2 = 3;
L6014:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	goto L6012;
L6013:
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L6017;
	R2 = 3;
	goto L6016;
L6017:
	R2 = 6;
L6016:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L6012:
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L6006:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = passign;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	asi64(R3) = down;
	if (!asi64(R3)) goto L6019;
	R3 = 35;
	goto L6018;
L6019:
	R3 = 34;
L6018:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6021;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6022;
	goto L6023;
L6021:
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6020;
L6022:
	asu64(R1) = pto;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6020;
L6023:
	asu64(R1) = dto;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6020:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L6025;
	asi64(R1) = lab_e;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L6025:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_convert(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6028;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6029;
	goto L6030;
L6028:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	goto L6026;
	goto L6027;
L6029:
	R1 = 0;
	R2 = tou64("CONV/ERROR");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L6027;
L6030:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_convtopcl;
	asu64(R3) = p;
	R4 = 62;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6027:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = p;
	R2 = 53;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
L6026:
	return;
}

static void mm_blockpcl_do_swap(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = b;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	R2 = 36;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static i64 mm_blockpcl_checkdotchain(u64 p, u64 pname) {
    u64 R1, R2, R3; 
	i64 offset;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6034;
	goto L6035;
L6034:
	asu64(R1) = pname;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	goto L6032;
	goto L6033;
L6035:
	asu64(R1) = p;
	asu64(R2) = pname;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L6032;
L6033:
	R1 = 0;
	goto L6032;
L6032:
	return asi64(R1);
}

static void mm_blockpcl_do_dotref(u64 pdot) {
    u64 R1, R2, R3; 
	i64 imode;
	i64 offset;
	u64 a;
	u64 pname;
	R1 = 0;
	asu64(R2) = pdot;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	imode = asi64(R1);
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	if (!asi64(R1)) goto L6038;
	asi64(R1) = offset;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
L6038:
	asi64(R1) = imode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_dot(u64 pdot) {
    u64 R1, R2, R3; 
	i64 offset;
	u64 a;
	u64 pname;
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdot;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_storedot(u64 pdot, u64 pfield, u64 rhs) {
    u64 R1, R2, R3; 
	i64 offset;
	u64 a;
	u64 pname;
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pdot;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6042;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6042:
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 6;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdot;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_index(u64 p, u64 parray, u64 pindex) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	i64 offset;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = offset;
	asi64(R2) = scale;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_storeindex(u64 p, u64 parray, u64 pindex, u64 rhs) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6046;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6046:
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = scale;
	R3 = 6;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_indexref(u64 parray, u64 pindex) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = scale;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	return;
}

static i64 mm_blockpcl_getindexoffset(u64 parray, u64 pindex) {
    u64 R1, R2; 
	i64 offset;
	i64 addoffset;
	R1 = 0;
	addoffset = asi64(R1);
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 35;
	if (asi64(R1) != asi64(R2)) goto L6050;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6051;
	R2 = 44;
	if (asi64(R1) != asi64(R2)) goto L6050;
L6051:
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6053;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L6055;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6054;
L6055:
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
L6054:
	addoffset = asi64(R1);
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pindex;
	*tou64p(R2) = asu64(R1);
L6053:
L6050:
	asi64(R1) = addoffset;
	goto L6048;
L6048:
	return asi64(R1);
}

static void mm_blockpcl_do_switch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 isref) {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	i64 minlab;
	i64 maxlab;
	i64 n;
	i64 iscomplex;
	i64 i;
	i64 lab_a;
	i64 lab_d;
	i64 labjump;
	i64 elselab;
	i64 labstmt;
	i64 ax;
	i64 bx;
	i64 ismult;
	i64 mode;
	u8 looptype;
	u8 opc;
	struct $B95 labels;
	u64 w;
	u64 wt;
	u64 pjump;
	u64 psetup;
	u64 djump;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L6058;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L6059;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L6060;
	goto L6061;
L6058:
	R1 = 0;
	looptype = asu8(R1);
	R1 = 37;
	opc = asu8(R1);
	goto L6057;
L6059:
// mm_blockpcl.do_switch.dodosw:
	R1 = 1;
	looptype = asu8(R1);
	R1 = 37;
	opc = asu8(R1);
	goto L6057;
L6060:
	R1 = 2;
	looptype = asu8(R1);
	R1 = 38;
	opc = asu8(R1);
	goto L6057;
L6061:
	R1 = 3;
	looptype = asu8(R1);
L6057:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6063;
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6063;
	R1 = 1;
	goto L6064;
L6063:
	R1 = 0;
L6064:
	ismult = asi64(R1);
	R1 = 1000000;
	minlab = asi64(R1);
	R1 = -1000000;
	maxlab = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	iscomplex = asi64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L6066;
L6065:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6069;
L6068:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6072;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6073;
	goto L6074;
L6072:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
// mm_blockpcl.do_switch.dorange:
L6075:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L6078;
L6076:
	asi64(R1) = i;
	asi64(R2) = minlab;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	minlab = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = maxlab;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxlab = asi64(R1);
	i += 1; if (i <= bx) goto L6076;
L6078:
	goto L6071;
L6073:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L6075;
	goto L6071;
L6074:
	R1 = 0;
	asu64(R2) = w;
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Switch when2: not const: #");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6071:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6069:
	asu64(R1) = w;
	if (asu64(R1)) goto L6068;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6066:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6065;
	asi64(R1) = maxlab;
	asi64(R2) = minlab;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1000;
	if (asi64(R1) <= asi64(R2)) goto L6080;
	R1 = 0;
	R2 = tou64("Switch too big");
	mm_support_gerror(asu64(R2), asu64(R1));
L6080:
	asu8(R1) = looptype;
	if (!asu8(R1)) goto L6082;
	asi64(R1) = mm_genpcl_definelabel();
	lab_a = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_a;
	asi64(R3) = lab_a;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L6081;
L6082:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
L6081:
	asi64(R1) = mm_genpcl_createfwdlabel();
	labjump = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	elselab = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6084;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6084:
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6086;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pjump = asu64(R1);
	asu64(R1) = pjump;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6088;
	R1 = 0;
	R2 = tou64("doswx not name");
	mm_support_gerror(asu64(R2), asu64(R1));
L6088:
	asu64(R1) = pjump;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	djump = asu64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = djump;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6090;
	R1 = 0;
	R2 = tou64("doswx not ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L6090:
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pc_api_pccurr;
	psetup = asu64(R1);
	asu64(R1) = pjump;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = mm_genpcl_pcldoswx;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6092;
	R1 = 0;
	R2 = tou64("doswx in main?");
	mm_support_gerror(asu64(R2), asu64(R1));
L6092:
	asu64(R1) = psetup;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = mm_genpcl_pcldoswx;
	*(struct $B18*)(R2) = (R1_B18);
	asu64(R1) = psetup;
	R2 = 1;
	R1 += (i64)R2*32;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = mm_genpcl_pcldoswx;
	R3 = 1;
	R2 += (i64)R3*32;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = 2;
	R2 = (u64)&pc_api_pccurr;
	*tou64p(R2) -= asu64(R1)*32;
L6086:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6094;
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L6096;
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L6096:
	goto L6093;
L6094:
	R1 = tou64("J1");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L6093:
	asi64(R1) = labjump;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = minlab;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = maxlab;
	if (asi64(R1) > asi64(R2)) goto L6099;
L6097:
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= maxlab) goto L6097;
L6099:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L6101;
L6100:
	asi64(R1) = mm_genpcl_definelabel();
	labstmt = asi64(R1);
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6104;
L6103:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6107;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6108;
	goto L6109;
L6107:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
	goto L6106;
L6108:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L6106;
L6109:
L6106:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L6112;
L6110:
	asi64(R1) = labstmt;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	i += 1; if (i <= bx) goto L6110;
L6112:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6104:
	asu64(R1) = w;
	if (asu64(R1)) goto L6103;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6114;
	R1 = 0;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6113;
L6114:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
L6113:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6116;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6116:
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6118;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6119;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6120;
	goto L6121;
L6118:
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6117;
L6119:
	asi64(R1) = lab_a;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6117;
L6120:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L6117;
L6121:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("J2");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L6117:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6101:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6100;
	asi64(R1) = elselab;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L6123;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6125;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6124;
L6125:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L6124:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6127;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6127:
L6123:
	asu8(R1) = looptype;
	if (!asu8(R1)) goto L6129;
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6131;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6132;
	goto L6133;
L6131:
	asi64(R1) = lab_a;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6130;
L6132:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L6130;
L6133:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("J3");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L6130:
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
L6129:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_select(u64 p, u64 a, u64 b, u64 c, i64 isref) {
    u64 R1, R2, R3, R4; 
	struct $B96 labels;
	i64 labend;
	i64 labjump;
	i64 n;
	i64 i;
	i64 elselab;
	i64 labstmt;
	i64 ismult;
	u64 q;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6135;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6135;
	R1 = 1;
	goto L6136;
L6135:
	R1 = 0;
L6136:
	ismult = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L6138;
L6137:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L6141;
	R1 = 0;
	R2 = tou64("selectx: too many labels");
	mm_support_gerror(asu64(R2), asu64(R1));
L6141:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6138:
	asu64(R1) = q;
	if (asu64(R1)) goto L6137;
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labjump = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	elselab = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6143;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6143:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = n;
	R3 = 1;
	R4 = 37;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labjump;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6146;
L6144:
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L6144;
L6146:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	goto L6148;
L6147:
	asi64(R1) = mm_genpcl_definelabel();
	labstmt = asi64(R1);
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asi64(R1) = labstmt;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6151;
	R1 = 0;
	asu64(R2) = q;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6150;
L6151:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
L6150:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6153;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6153:
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6148:
	asu64(R1) = q;
	if (asu64(R1)) goto L6147;
	asi64(R1) = elselab;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6155;
	R1 = 0;
	asu64(R2) = c;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6154;
L6155:
	asu64(R1) = c;
	mm_blockpcl_evalunit(asu64(R1));
L6154:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6157;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6157:
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_case(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 loopsw, i64 isref) {
    u64 R1, R2, R3, R4; 
	struct $B44 labtable;
	struct $B44 unittable;
	i64 ncases;
	i64 ismult;
	i64 a;
	i64 b;
	i64 lab_abc;
	i64 lab_d;
	i64 labelse;
	u64 w;
	u64 wt;
	u64 plower;
	u64 pupper;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 106;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	loopsw = asi64(R1);
	asu64(R1) = pindex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6160;
	R1 = 0;
	R2 = tou64("EMPTY CASE NOT DONE");
	mm_support_gerror(asu64(R2), asu64(R1));
L6160:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6161;
	asi64(R1) = loopsw;
	if (asi64(R1)) goto L6161;
	R1 = 1;
	goto L6162;
L6161:
	R1 = 0;
L6162:
	ismult = asi64(R1);
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L6164;
	asi64(R1) = mm_genpcl_definelabel();
	lab_abc = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_abc;
	asi64(R3) = lab_abc;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L6163;
L6164:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
L6163:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6166;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6166:
	R1 = 0;
	ncases = asi64(R1);
	asi64(R1) = mm_blockpcl_casedepth;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L6168;
	R1 = 0;
	R2 = tou64("case nested too deeply");
	mm_support_gerror(asu64(R2), asu64(R1));
L6168:
	asu64(R1) = p;
	R2 = (u64)&mm_blockpcl_casestmt;
	R3 = (u64)&mm_blockpcl_casedepth;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pwhenthen;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6170;
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6172;
	R1 = 0;
	R2 = tou64("case");
	mm_support_gerror(asu64(R2), asu64(R1));
L6172:
	goto L6173;
L6170:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L6175;
L6174:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asi64(R1) = ncases;
	R2 = 500;
	if (asi64(R1) < asi64(R2)) goto L6178;
	R1 = 0;
	R2 = tou64("too many cases");
	mm_support_gerror(asu64(R2), asu64(R1));
L6178:
	asi64(R1) = mm_genpcl_createfwdlabel();
	R2 = (u64)&labtable;
	R3 = (u64)&ncases;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&unittable;
	asi64(R3) = ncases;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6180;
L6179:
	asu64(R1) = w;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&labtable;
	asi64(R2) = ncases;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	asu64(R3) = w;
	R4 = 40;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L6184;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6183;
L6184:
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6183:
	asu64(R1) = w;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6180:
	asu64(R1) = w;
	if (asu64(R1)) goto L6179;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6175:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6174;
// mm_blockpcl.do_case.skip:
L6173:
	asi64(R1) = mm_genpcl_createfwdlabel();
	labelse = asi64(R1);
	asi64(R1) = labelse;
	R2 = (u64)&mm_blockpcl_caseelse;
	asi64(R3) = mm_blockpcl_casedepth;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = labelse;
	mm_blockpcl_genjumpl(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6187;
L6185:
	R1 = (u64)&labtable;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6189;
	R1 = 0;
	R2 = (u64)&unittable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6188;
L6189:
	R1 = (u64)&unittable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_evalunit(asu64(R1));
L6188:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6191;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6191:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L6193;
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6192;
L6193:
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
L6192:
	i += 1; if (i <= ncases) goto L6185;
L6187:
	asi64(R1) = labelse;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L6195;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6197;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6196;
L6197:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L6196:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6199;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6199:
L6195:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L6201;
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	goto L6200;
L6201:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
L6200:
	R1 = (u64)&mm_blockpcl_casedepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_dotindex(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 14;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_dotslice(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 15;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_read(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 m;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6206;
	asu64(R1) = mm_genpcl_pzero;
	a = asu64(R1);
L6206:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6208;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 23;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6207;
L6208:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6209;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L6209;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 24;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6207;
L6209:
	asi64(R1) = m;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6210;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 25;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6207;
L6210:
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(M)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("CAN'T READ THIS ITEM");
	mm_support_gerror(asu64(R2), asu64(R1));
L6207:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_readln(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L6213;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6215;
	R1 = 0;
	R2 = tou64("@dev no ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L6215:
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6217;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6218;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6218;
	goto L6219;
L6217:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 26;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6216;
L6218:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 27;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6216;
L6219:
	R1 = 0;
	R2 = tou64("rd@dev?");
	mm_support_gerror(asu64(R2), asu64(R1));
L6216:
	goto L6212;
L6213:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 28;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L6212:
	return;
}

static void mm_blockpcl_docond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = lab;
	asu64(R2) = p;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_blockpcl_do_syscall(u64 p, u64 a) {
    u64 R1, R2, R3; 
	mm_genpcl_setfunctab();
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L6223;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L6224;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L6225;
	goto L6226;
L6223:
	asu64(R1) = mm_blockpcl_pnprocs;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6222;
L6224:
	asu64(R1) = mm_blockpcl_pprocname;
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = -8;
	R2 = 8;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L6222;
L6225:
	asu64(R1) = mm_blockpcl_pprocaddr;
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = -8;
	R2 = 8;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L6222;
L6226:
	R1 = tou64("SYSCALL/GENERIC");
	pc_api_gencomment(asu64(R1));
L6222:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_slice(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6229;
	asu64(R1) = a;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6231;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	mm_genpcl_genpushint(asi64(R1));
	goto L6230;
L6231:
	R1 = (u64)&mm_decls_ttlength;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_genpcl_genpushint(asi64(R1));
L6230:
	goto L6228;
L6229:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	mm_blockpcl_do_indexref(asu64(R2), asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6233;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6233;
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	mm_genpcl_genpushint(asi64(R1));
	goto L6232;
L6233:
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 44;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 43;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6232:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L6228:
	R1 = 0;
	R2 = 7;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_assignblock(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6236;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6238;
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignarray(asu64(R2), asu64(R1));
	goto L6237;
L6238:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignrecord(asu64(R2), asu64(R1));
L6237:
	goto L6235;
L6236:
	R1 = 0;
	R2 = tou64("ASSIGN BLOCK");
	mm_support_gerror(asu64(R2), asu64(R1));
L6235:
	return;
}

static void mm_blockpcl_do_assignarray(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 passign;
	u64 pindex;
	u64 pconst;
	u64 q;
	i64 index;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6241;
	R1 = 0;
	R2 = tou64("Assignment not suitable for []char type");
	mm_support_gerror(asu64(R2), asu64(R1));
L6241:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pconst = asu64(R1);
	asu64(R1) = pconst;
	asu64(R2) = a;
	R3 = 46;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pindex = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pindex;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	asu64(R3) = pindex;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	index = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6243;
L6242:
	asi64(R1) = index;
	asu64(R2) = pconst;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = pconst;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	asu64(R2) = passign;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&index;
	(*toi64p(R1)) += 1;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6243:
	asu64(R1) = q;
	if (asu64(R1)) goto L6242;
	return;
}

static void mm_blockpcl_do_assignrecord(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 passign;
	u64 pdot;
	u64 pfield;
	u64 q;
	i64 m;
	i64 fieldtype;
	u64 d;
	u64 e;
	R1 = 4;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	pfield = asu64(R1);
	asu64(R1) = pfield;
	asu64(R2) = a;
	R3 = 49;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pdot = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pdot;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	asu64(R3) = pdot;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6247;
L6246:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6250;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6250;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	fieldtype = asi64(R1);
	asu64(R1) = e;
	asu64(R2) = pfield;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = fieldtype;
	R2 = R1;
	asu64(R3) = pdot;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	R2 = R1;
	asu64(R3) = pfield;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = passign;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pdot;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6250:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L6247:
	asu64(R1) = e;
	if (asu64(R1)) goto L6246;
	return;
}

static void mm_blockpcl_pushrhs(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6253;
	goto L6251;
L6253:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_pushrhs(asu64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
L6251:
	return;
}

static void mm_blockpcl_do_assignms(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 nlhs;
	i64 nrhs;
	u64 d;
	i64 i;
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	nlhs = asi64(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L6256;
	goto L6257;
L6256:
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6259;
	R1 = 0;
	R2 = tou64("multassign from fn: not simple fn");
	mm_support_gerror(asu64(R2), asu64(R1));
L6259:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nrhs = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L6255;
L6257:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6261;
	R1 = 0;
	R2 = tou64("DECONSTR SLICE NOT READY");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L6260;
L6261:
	R1 = 0;
	R2 = tou64("(a,b):=x; var only");
	mm_support_gerror(asu64(R2), asu64(R1));
L6260:
L6255:
	asu64(R1) = a;
	mm_blockpcl_poptomult(asu64(R1));
	asi64(R1) = nrhs;
	asi64(R2) = nlhs;
	if (asi64(R1) <= asi64(R2)) goto L6263;
	asu64(R1) = b;
	asu64(R1) = mm_lib_getprocretmodes(asu64(R1));
	d = asu64(R1);
	asi64(R1) = nlhs;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nrhs;
	if (asi64(R1) > asi64(R2)) goto L6266;
L6264:
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nrhs) goto L6264;
L6266:
L6263:
	return;
}

static void mm_blockpcl_do_assignmm(u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_pushrhs(asu64(R1));
	R1 = 0;
	R2 = 133;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_poptomult(asu64(R1));
	return;
}

static void mm_blockpcl_do_assignmdrem(u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_poptomult(asu64(R1));
	return;
}

static void mm_blockpcl_poptomult(u64 a) {
    u64 R1, R2, R3; 
L6270:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6274;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L6275;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L6275;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6275;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6276;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6277;
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L6277;
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L6277;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L6277;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L6278;
	goto L6279;
L6274:
	asu64(R1) = a;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6273;
L6275:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6273;
L6276:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6273;
L6277:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6273;
L6278:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 16;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6273;
L6279:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Bad mult assign element");
	mm_support_gerror(asu64(R2), asu64(R1));
L6273:
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6270;
	return;
}

static void mm_blockpcl_do_recase(u64 p, u64 a) {
    u64 R1, R2, R3; 
	u64 q;
	u64 wt;
	u64 w;
	i64 destlab;
	i64 casevalue;
	asi64(R1) = mm_blockpcl_casedepth;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6282;
	R1 = 0;
	R2 = tou64("recase outside case stmt");
	mm_support_gerror(asu64(R2), asu64(R1));
L6282:
	asu64(R1) = a;
	if (!asu64(R1)) goto L6284;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	casevalue = asi64(R1);
	goto L6283;
L6284:
	R1 = (u64)&mm_blockpcl_caseelse;
	asi64(R2) = mm_blockpcl_casedepth;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_genjumpl(asi64(R1));
L6283:
	R1 = (u64)&mm_blockpcl_casestmt;
	asi64(R2) = mm_blockpcl_casedepth;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	destlab = asi64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
	goto L6286;
L6285:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6289;
L6288:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6292;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = w;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6292;
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = casevalue;
	if (asi64(R1) != asi64(R2)) goto L6292;
	asu64(R1) = w;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	destlab = asi64(R1);
	goto L6287;
L6292:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6289:
	asu64(R1) = w;
	if (asu64(R1)) goto L6288;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6286:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6285;
L6287:
	asi64(R1) = destlab;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6294;
	R1 = (u64)&mm_blockpcl_caseelse;
	asi64(R2) = mm_blockpcl_casedepth;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6293;
L6294:
	asi64(R1) = destlab;
	mm_blockpcl_genjumpl(asi64(R1));
L6293:
	return;
}

static void mm_blockpcl_do_empty(u64 p, u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 41;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_typeconst(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	return;
}

static void mm_blockpcl_do_setinplace() {
    u64 R1, R2, R3; 
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6299;
	asu64(R1) = pc_api_pccurr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6299;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6299:
	return;
}

static u64 mm_assem_readassemline() {
    u64 R1; 
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_assem_assembleline(asi64(R1));
	goto L6300;
L6300:
	return asu64(R1);
}

static u64 mm_assem_readassemblock() {
    u64 R1, R2, R3, R4, R5; 
	u64 ulist;
	u64 ulistx;
	u64 u;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L6302:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6305;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L6306;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6307;
	goto L6308;
L6305:
	R1 = tou64("EOF: 'End' missing in Assembler code");
	mm_support_serror(asu64(R1));
	goto L6304;
L6306:
	R1 = 0;
	R2 = 0;
	R3 = 135;
	R4 = (u64)&mm_decls_lx;
	R5 = 0;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L6303;
	goto L6304;
L6307:
	goto L6304;
L6308:
	R1 = 0;
	asu64(R1) = mm_assem_assembleline(asi64(R1));
	u = asu64(R1);
	asu64(R1) = u;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L6304:
	goto L6302;
L6303:
	asu64(R1) = ulist;
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	goto L6301;
L6301:
	return asu64(R1);
}

static u64 mm_assem_assembleline(i64 oneline) {
    u64 R1, R2, R3; 
	u64 dlist;
	u64 dlistx;
	u64 p;
	u64 pname;
	u64 q;
	i64 opc;
	i64 noperands;
	u64 stname;
	R1 = 0;
	R2 = R1;
	dlistx = asu64(R2);
	dlist = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6311;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6311;
	R1 = 100;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 14;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = mm_decls_currproc;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = mm_decls_currproc;
	mm_lib_adddef(asu64(R2), asu64(R1));
	mm_lex_lex();
	asi64(R1) = oneline;
	if (!asi64(R1)) goto L6313;
	mm_lex_lex();
L6313:
	asu64(R1) = p;
	goto L6309;
	goto L6310;
L6311:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L6314;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_createname(asu64(R1));
	pname = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = pname;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6316;
L6317:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&dlistx;
	R3 = (u64)&dlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6321;
	mm_lex_lex();
L6321:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6322;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L6317;
L6322:
L6316:
	asu64(R1) = dlist;
	asu64(R2) = pname;
	R3 = 9;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L6309;
L6314:
L6310:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L6324;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6325;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6326;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L6327;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L6328;
	goto L6329;
L6324:
	R1 = 38;
	opc = asi64(R1);
// mm_assem.assembleline.doop:
L6330:
	R1 = 8;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	goto L6323;
L6325:
	R1 = 39;
	opc = asi64(R1);
	goto L6330;
	goto L6323;
L6326:
	R1 = 40;
	opc = asi64(R1);
	goto L6330;
	goto L6323;
L6327:
	R1 = 51;
	opc = asi64(R1);
	goto L6330;
	goto L6323;
L6328:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6332;
	R1 = 29;
	opc = asi64(R1);
	goto L6330;
L6332:
	goto L6333;
	goto L6323;
L6329:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6335;
	R1 = 8;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L6337;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L6338;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L6339;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L6340;
	goto L6341;
L6337:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6336;
L6338:
	R1 = 26;
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6336;
L6339:
	R1 = 58;
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6336;
L6340:
	R1 = 15;
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6336;
L6341:
	R1 = tou64("ASM");
	mm_lex_ps(asu64(R1));
	R1 = tou64("x64 op expected");
	mm_support_serror(asu64(R1));
L6336:
	mm_lex_lex();
	goto L6334;
L6335:
// mm_assem.assembleline.$else:
L6333:
	R1 = tou64("ASM");
	mm_lex_ps(asu64(R1));
	R1 = tou64("ASM???");
	mm_support_serror(asu64(R1));
L6334:
L6323:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6343;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6343;
	R1 = 0;
	noperands = asi64(R1);
L6344:
	asu64(R1) = mm_assem_readassemopnd();
	q = asu64(R1);
	R1 = (u64)&noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L6347;
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6346;
L6347:
	R1 = tou64("Too many asm opnds");
	mm_support_serror(asu64(R1));
L6346:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6349;
	goto L6345;
	goto L6348;
L6349:
	mm_lex_lex();
L6348:
	goto L6344;
L6345:
L6343:
	R1 = 4;
	mm_parse_checksymbol(asi64(R1));
	asu64(R1) = p;
	goto L6309;
L6309:
	return asu64(R1);
}

static u64 mm_assem_readassemopnd() {
    u64 R1, R2, R3; 
	u64 p;
	i64 reg;
	i64 regix;
	i64 scale;
	i64 prefixmode;
	u64 pcode;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6352;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6352;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6353;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6354;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6354;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L6355;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6356;
	goto L6357;
L6352:
	asu64(R1) = mm_parse_readunit();
	goto L6350;
	goto L6351;
L6353:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6359;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L6360;
	goto L6361;
L6359:
	R1 = 10;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 164;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L6350;
	goto L6358;
L6360:
	R1 = 11;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L6350;
	goto L6358;
L6361:
L6358:
	asu64(R1) = mm_parse_readunit();
	goto L6350;
	goto L6351;
L6354:
	asu64(R1) = mm_parse_readunit();
	goto L6350;
	goto L6351;
L6355:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6363;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6363;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6363;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6363;
	goto L6364;
L6363:
	goto L6362;
L6364:
	R1 = tou64("Bad prefix");
	mm_support_serror(asu64(R1));
L6362:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	prefixmode = asi64(R1);
	R1 = 11;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L6365;
	goto L6351;
L6356:
	R1 = 0;
	prefixmode = asi64(R1);
// mm_assem.readassemopnd.gotprefix:
L6365:
	R1 = 0;
	R2 = R1;
	regix = asi64(R2);
	reg = asi64(R1);
	R1 = 0;
	pcode = asu64(R1);
	R1 = 1;
	scale = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6367;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L6367;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	reg = asi64(R1);
	mm_lex_lex();
L6367:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L6369;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6369;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L6369;
	mm_lex_lex();
L6369:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6371;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L6371;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	regix = asi64(R1);
	mm_lex_lex();
L6371:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L6373;
	R1 = 62;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	scale = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6375;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6375;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6375;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6375;
	goto L6376;
L6375:
	goto L6374;
L6376:
	R1 = tou64("Bad scale");
	mm_support_serror(asu64(R1));
L6374:
	mm_lex_lex();
L6373:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6378;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6378;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6378;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6378;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6378;
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L6378;
	goto L6379;
L6378:
	asu64(R1) = mm_parse_readunit();
	pcode = asu64(R1);
	goto L6377;
L6379:
L6377:
	R1 = 12;
	mm_parse_checksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = pcode;
	R2 = 12;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6381;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6381;
	asi64(R1) = reg;
	regix = asi64(R1);
	R1 = 0;
	reg = asi64(R1);
L6381:
	asu64(R1) = pcode;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6383;
	asi64(R1) = reg;
	asi64(R2) = regix;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6383;
	R1 = tou64("Empty []");
	mm_support_serror(asu64(R1));
L6383:
	asi64(R1) = reg;
	asu64(R2) = p;
	R3 = 40;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = regix;
	asu64(R2) = p;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 42;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = prefixmode;
	asu64(R2) = p;
	R3 = 43;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L6350;
	goto L6351;
L6357:
	R1 = tou64("BAD OPND");
	mm_lex_ps(asu64(R1));
	R1 = tou64("ASM: Bad operand?");
	mm_support_serror(asu64(R1));
L6351:
	R1 = 0;
	goto L6350;
L6350:
	return asu64(R1);
}

static void mm_assem_initassemsymbols() {
    u64 R1, R2, R3, R4, R5; 
	struct $B18 str;
	i64 i;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	i64 av_6;
	i64 av_7;
	i64 av_8;
	i64 av_9;
	i64 av_10;
// PROC LOCAL STATICS GO HERE
	static struct $B12 mm_assem_initassemsymbols_regnames = {{
	(u64)"aframe",
	(u64)"dframe",
	(u64)"astack",
	(u64)"dstack",
	(u64)"dprog",
	(u64)"dsptr"    }};
	static struct $B27 mm_assem_initassemsymbols_regnos = {{
3855,
	4112,
	2569    }};
	static struct $B27 mm_assem_initassemsymbols_sizes = {{
2052,
	2052,
	2056    }};
	R1 = 1;
	i = asi64(R1);
	R1 = 151;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6387;
L6385:
	R1 = 0;
	asi64(R2) = i;
	R3 = 78;
	R4 = (u64)&mc_decls_mclnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	R5 = 2;
	R4 += (i64)R5;
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L6385;
L6387:
	R1 = 1;
	i = asi64(R1);
	R1 = 137;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6390;
L6388:
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_regindices;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 70;
	R4 = (u64)&mc_decls_dregnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_2) goto L6388;
L6390:
	R1 = 1;
	i = asi64(R1);
	R1 = 16;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6393;
L6391:
	R1 = 0;
	asi64(R2) = i;
	R3 = 71;
	R4 = (u64)&mc_decls_xmmregnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_3) goto L6391;
L6393:
	R1 = 1;
	i = asi64(R1);
	R1 = 8;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6396;
L6394:
	R1 = 0;
	asi64(R2) = i;
	R3 = 72;
	R4 = (u64)&mc_decls_fregnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_4) goto L6394;
L6396:
	R1 = 1;
	i = asi64(R1);
	R1 = 8;
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6399;
L6397:
	R1 = 0;
	asi64(R2) = i;
	R3 = 73;
	R4 = (u64)&mc_decls_mregnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_5) goto L6397;
L6399:
	R1 = 1;
	i = asi64(R1);
	R1 = 18;
	av_6 = asi64(R1);
	asi64(R1) = av_6;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6402;
L6400:
	R1 = 0;
	R2 = (u64)&mc_decls_jmpcccodes;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 74;
	R4 = (u64)&mc_decls_jmpccnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_6) goto L6400;
L6402:
	R1 = 1;
	i = asi64(R1);
	R1 = 16;
	av_7 = asi64(R1);
	asi64(R1) = av_7;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6405;
L6403:
	R1 = 0;
	R2 = (u64)&mc_decls_setcccodes;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 75;
	R4 = (u64)&mc_decls_setccnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_7) goto L6403;
L6405:
	R1 = 1;
	i = asi64(R1);
	R1 = 16;
	av_8 = asi64(R1);
	asi64(R1) = av_8;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6408;
L6406:
	R1 = 0;
	R2 = (u64)&mc_decls_cmovcccodes;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 76;
	R4 = (u64)&mc_decls_cmovccnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_8) goto L6406;
L6408:
	R1 = 1;
	i = asi64(R1);
	R1 = 5;
	av_9 = asi64(R1);
	asi64(R1) = av_9;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6411;
L6409:
	R1 = (u64)&mc_decls_segmentnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&str;
	asi64(R3) = strlen(asu64(R3));
	*tou8p(((i64)R2+(i64)R3-4)) = asu8(R1);
	R1 = 0;
	asi64(R2) = i;
	R3 = 77;
	R4 = (u64)&str;
	asu64(R4) = mlib_pcm_copyheapstring(asu64(R4));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_9) goto L6409;
L6411:
	R1 = 1;
	i = asi64(R1);
	R1 = 6;
	av_10 = asi64(R1);
	asi64(R1) = av_10;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6414;
L6412:
	R1 = (u64)&mm_assem_initassemsymbols_sizes;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_assem_initassemsymbols_regnos;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 70;
	R4 = (u64)&mm_assem_initassemsymbols_regnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_10) goto L6412;
L6414:
	return;
}

static void mm_assemaux_domcl_assem(u64 pcode) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pcode;
	if (!asu64(R1)) goto L6418;
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6417;
L6418:
	goto L6415;
L6417:
	asu64(R1) = pcode;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_assemaux_genasmopnd(asu64(R1));
	asu64(R2) = pcode;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mm_assemaux_genasmopnd(asu64(R2));
	asu64(R3) = pcode;
	R4 = 40;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pcode;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_mccodex;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pcode;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6420;
	R2 = 93;
	if (asi64(R1) == asi64(R2)) goto L6420;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6420;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6420;
	goto L6421;
L6420:
	asu64(R1) = pcode;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L6424;
	asu64(R1) = pcode;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6423;
L6424:
	R1 = 0;
	R2 = tou64("pcmpistr/no imm");
	mm_support_gerror(asu64(R2), asu64(R1));
L6423:
	asu64(R1) = pcode;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_mccodex;
	R3 = 32;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6419;
L6421:
L6419:
L6415:
	return;
}

static u64 mm_assemaux_genasmopnd(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 ax;
	u64 d;
	i64 offset;
	i64 labno;
	u64 a;
	u64 x;
	u64 y;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6427;
	R1 = 0;
	goto L6425;
L6427:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6429;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6430;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6432;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6433;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6434;
	goto L6435;
L6429:
	R1 = (u64)&mc_decls_regmodes;
	asu64(R2) = p;
	R3 = 44;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L6428;
L6430:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L6428;
L6431:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	d = asu64(R1);
	R1 = 0;
	R2 = R1;
	labno = asi64(R2);
	offset = asi64(R1);
	asu64(R1) = a;
	if (!asu64(R1)) goto L6437;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6439;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6440;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6441;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6442;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L6443;
	goto L6444;
L6439:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	offset = asi64(R1);
	goto L6438;
L6440:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6446;
	asu64(R1) = d;
	asi64(R1) = mm_assemaux_fixasmlabel(asu64(R1));
	labno = asi64(R1);
	R1 = 0;
	d = asu64(R1);
L6446:
	goto L6438;
L6441:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6448;
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6448;
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6450;
	asu64(R1) = d;
	asi64(R1) = mm_assemaux_fixasmlabel(asu64(R1));
	labno = asi64(R1);
	R1 = 0;
	d = asu64(R1);
L6450:
	goto L6447;
L6448:
	goto L6451;
L6447:
	asu64(R1) = a;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6454;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L6453;
L6454:
	asu64(R1) = y;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6452;
L6453:
	asu64(R1) = y;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
L6452:
	offset = asi64(R1);
	goto L6438;
L6442:
	asu64(R1) = a;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6456;
	R1 = tou64("");
	R2 = tou64("assume/unary");
	pc_api_merror(asu64(R2), asu64(R1));
L6456:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6458;
	R1 = 0;
	R2 = tou64("-name");
	mm_support_gerror(asu64(R2), asu64(R1));
L6458:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	offset = asi64(R1);
	goto L6438;
L6443:
	R1 = tou64("");
	R2 = tou64("ASSEM/SYSFN?");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L6438;
L6444:
// mm_assemaux.genasmopnd.error:
L6451:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Can't do memexpr");
	mm_support_gerror(asu64(R2), asu64(R1));
L6438:
L6437:
	asu64(R1) = d;
	asi64(R2) = labno;
	R3 = (u64)&mm_decls_ttsize;
	asu64(R4) = p;
	R5 = 43;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu32(R3) = *tou32p(((i64)R3+(i64)R4*4));
	R3 = toi64(tou32(R3));
	asi64(R4) = offset;
	asu64(R5) = p;
	R6 = 42;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asu64(R6) = p;
	R7 = 41;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = p;
	R8 = 40;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	goto L6428;
L6432:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6460;
	asu64(R1) = d;
	asi64(R1) = mm_assemaux_fixasmlabel(asu64(R1));
	labno = asi64(R1);
	asi64(R1) = labno;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L6459;
L6460:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
L6459:
	goto L6428;
L6433:
	R1 = 8;
	asu64(R2) = p;
	R3 = 40;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L6428;
L6434:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6462;
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6462;
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6465;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L6464;
L6465:
	asu64(R1) = y;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6463;
L6464:
	asu64(R1) = y;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
L6463:
	offset = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6467;
	asu64(R1) = d;
	asi64(R1) = mm_assemaux_fixasmlabel(asu64(R1));
	labno = asi64(R1);
	asi64(R1) = labno;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L6466;
L6467:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
L6466:
	asi64(R1) = offset;
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6461;
L6462:
	R1 = 0;
	R2 = tou64("ax:imm/add");
	mm_support_gerror(asu64(R2), asu64(R1));
L6461:
	goto L6428;
L6435:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("genasmopnd?");
	mm_support_gerror(asu64(R2), asu64(R1));
L6428:
	asu64(R1) = ax;
	goto L6425;
L6425:
	return asu64(R1);
}

static i64 mm_assemaux_fixasmlabel(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 100;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6470;
	R1 = 0;
	R2 = tou64("FIXASMLABEL: zero");
	mm_support_gerror(asu64(R2), asu64(R1));
L6470:
	asu64(R1) = d;
	R2 = 100;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L6468;
L6468:
	return asi64(R1);
}

static i64 mm_assemaux_checkasmlabel(u64 p) {
    u64 R1, R2; 
	u64 q;
	u64 d;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L6473;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6473;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6475;
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L6471;
L6475:
L6473:
	R1 = 0;
	goto L6471;
L6471:
	return asi64(R1);
}

static void mm_diags_printst(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = level;
	asu64(R2) = p;
	asu64(R3) = f;
	mm_diags_printstrec(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6478;
L6477:
	asi64(R1) = level;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	asu64(R3) = f;
	mm_diags_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6478:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6477;
	return;
}

static void mm_diags_printstrec(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3, R4, R5; struct $B85 R1_B85; 
	struct $B85 dd;
	u64 q;
	struct $B3 v;
	u64 d;
	i64 col;
	i64 offset;
	i64 n;
	struct $B16 str;
	i64 av_1;
	R1 = (u64)&v;
	d = asu64(R1);
	asu64(R1) = d;
	mlib_gs_init(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6483;
L6481:
	R1 = tou64("    ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L6481;
L6483:
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 45;
	R2 = 28;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 46;
	R2 = 12;
	R3 = (u64)&mm_tables_namenames;
	asu64(R4) = p;
	R5 = 78;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	asi64(R1) = mlib_gs_getcol(asu64(R1));
	col = asi64(R1);
	asu64(R1) = p;
	(R1_B85) = *(struct $B85*)(R1);
	dd = (R1_B85);
	R1 = tou64("[");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6485;
	R1 = tou64("Imp ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6484;
L6485:
	R1 = (u64)&mm_tables_scopenames;
	asu64(R2) = p;
	R3 = 170;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6484:
	R1 = (u64)&dd;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6487;
	R1 = tou64("Stat");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6487:
	R1 = (u64)&dd;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6489;
	R1 = (u64)&dd;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6489;
	R1 = (u64)&mm_tables_parammodenames;
	R2 = (u64)&dd;
	R3 = 160;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6489:
	R1 = (u64)&dd;
	R2 = 149;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6491;
	R1 = tou64("@@");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&dd;
	R2 = 149;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" maxalign:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&dd;
	R2 = 166;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6491:
	R1 = (u64)&dd;
	R2 = 161;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6493;
	R1 = tou64("Opt ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6493:
	R1 = (u64)&dd;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6495;
	R1 = tou64("Var:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&dd;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6495:
	R1 = (u64)&dd;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6497;
	R1 = (u64)&dd;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6499;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Modno#");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&dd;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6498;
L6499:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Subno#");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&dd;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6498:
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6497:
	R1 = (u64)&dd;
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L6501;
	R1 = tou64("U ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6501:
	R1 = (u64)&dd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6503;
	R1 = tou64("Threaded ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6503:
	R1 = tou64("]");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 61;
	asi64(R2) = col;
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R3) = d;
	mlib_gs_padto(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6505;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 45;
	R2 = 18;
	R3 = (u64)&str;
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6504;
L6505:
	R1 = 45;
	R2 = 18;
	R3 = tou64("()");
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L6504:
	asu64(R1) = p;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6507;
	goto L6508;
L6507:
	R1 = tou64("Void ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6506;
L6508:
	asu64(R1) = p;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6506:
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6510;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6510;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6511;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6512;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6513;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6514;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6515;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6516;
	goto L6517;
L6510:
	R1 = tou64(" Offset:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6519;
	R1 = tou64(" Bitoffset:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 150;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 148;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
L6519:
	asu64(R1) = p;
	R2 = 136;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 143;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = tou64("%.*s");
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("v");
	asu64(R2) = p;
	R3 = 143;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64(".*");
	asu64(R2) = p;
	R3 = 136;
	R2 += (i64)R3;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = tou64(" UFLAGS:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("-");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 143;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6521;
	R1 = tou64("/:=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6521:
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6523;
	asu64(R1) = p;
	R2 = 162;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6523;
	R1 = tou64("...");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6523:
	goto L6509;
L6511:
	R1 = tou64("Index:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" Nret:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6509;
L6512:
	R1 = tou64("Index/PCaddr:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6525;
	R1 = tou64(" Truename:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6525:
	goto L6509;
L6513:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6527;
	R1 = tou64("=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6527:
	goto L6509;
L6514:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6529;
	R1 = tou64(":=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6529:
	goto L6509;
L6515:
	R1 = tou64("Const:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
	goto L6509;
L6516:
	asu64(R1) = p;
	R2 = 144;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6531;
	R1 = tou64("Baseclass:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("<HAS BASECLASS>");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6531:
	goto L6509;
L6517:
L6509:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6533;
	R1 = tou64(" @");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" +");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 151;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
L6533:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6535;
	asu64(R1) = p;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6535:
	R1 = tou64(" Lineno: ???");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6537;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6537;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6537;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6537;
	goto L6538;
L6537:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6540;
	asu64(R1) = f;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
L6540:
	goto L6536;
L6538:
L6536:
	return;
}

static void mm_diags_printstflat(u64 f) {
    u64 R1, R2, R3; 
	u64 p;
	i64 av_1;
	i64 i;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("GLOBAL SYMBOL TABLE:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	i = asi64(R1);
	R1 = 65534;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6544;
L6542:
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6546;
	goto L6543;
L6546:
	asu64(R1) = p;
	R2 = 77;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6548;
	goto L6549;
L6548:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("5");
	asi64(R2) = i;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	asu64(R2) = p;
	R3 = 77;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = p;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L6551;
L6550:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("     ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	asu64(R2) = p;
	R3 = 77;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = p;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6554;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" (From #:#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6554:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6551:
	asu64(R1) = p;
	if (asu64(R1)) goto L6550;
	goto L6547;
L6549:
L6547:
L6543:
	i += 1; if (i <= av_1) goto L6542;
L6544:
	return;
}

static void mm_diags_printcode(u64 f, u64 caption) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 pp;
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L6557;
L6556:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L6562;
	case 2: goto L6563;
	case 3: goto L6564;
	default: goto L6561;
    };
// SWITCH
L6562:
	R1 = tou64("Sub");
	goto L6559;
L6563:
	R1 = tou64("Prog");
	goto L6559;
L6564:
	R1 = tou64("Exp");
	goto L6559;
L6561:
	R1 = tou64("Mod");
L6559:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6566;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" in record");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6566:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	R2 = tou64("1");
	R3 = 0;
	asu64(R4) = p;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L6557:
	asu64(R1) = pp;
	if (asu64(R1)) goto L6556;
	return;
}

static void mm_diags_printunit(u64 p, i64 level, u64 prefix, u64 dev) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	i64 t;
	u64 idname;
	i64 a;
	r32 x32;
	i64 av_1;
	i64 av_2;
	i64 i;
// PROC LOCAL STATICS GO HERE
	static i64 mm_diags_printunit_cmpchain = 0;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6569;
	goto L6567;
L6569:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	if (!asu32(R1)) goto L6571;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	mm_diags_currlineno = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	mm_diags_currfileno = asi64(R1);
L6571:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = prefix;
	asi64(R3) = level;
	asu64(R1) = mm_diags_getprefix(asi64(R3), asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	idname = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = idname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6573;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L6574;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6575;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6576;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6577;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L6578;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L6579;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6579;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6580;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6581;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L6583;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L6583;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L6583;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L6584;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6585;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6586;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6587;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6588;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L6589;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6590;
	goto L6591;
L6573:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6593;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" {");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("}");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6593:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = d;
	asu64(R1) = mm_lib_getdottedname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6595;
	R1 = tou64(" {Dotted}");
	goto L6594;
L6595:
	R1 = tou64("");
L6594:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6597;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Lastcall:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L6597:
	asu64(R1) = p;
	R2 = 40;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6599;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Addroffirst.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6599:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Moduleno:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6601;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" AV:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 41;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L6601:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("P.INDEX=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6572;
L6574:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L6572;
L6575:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asi64(R1) = t;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6603;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 256;
	if (asi64(R1) <= asi64(R2)) goto L6605;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("(LONGSTR)");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6604;
L6605:
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	if (!asu32(R1)) goto L6606;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6604;
L6606:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6604:
	goto L6602;
L6603:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6608;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6608;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6608;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6608;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6609;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6609;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6609;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6609;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6610;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6610;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6611;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6611;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6612;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6613;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6614;
	goto L6615;
L6608:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = a;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6607;
L6609:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6607;
L6610:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = a;
	asu64(R1) = mlib_chr(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6607;
L6611:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6607;
L6612:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6617;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6616;
L6617:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("NIL");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6616:
	goto L6607;
L6613:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6619;
	R1 = tou64("True");
	goto L6618;
L6619:
	R1 = tou64("False");
L6618:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6607;
L6614:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<ARRAY>");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("P.STRTYPE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 45;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	R1 = tou64("P.SLENGTH=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6607;
L6615:
	msysc_m$print_startcon();
	R1 = tou64("TYPENAME(T)=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = t;
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<PRINTUNIT BAD CONST PROBABLY VOID");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6607:
L6602:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = t;
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6621;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" <isstr>(#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 45;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L6621:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6623;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" *L");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6623:
	goto L6572;
L6576:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Len:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6572;
L6577:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6572;
L6578:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&mm_tables_bitfieldnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6572;
L6579:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Convmode:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6572;
L6580:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Len:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(" Makeax:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6572;
L6581:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Offset:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6572;
L6582:
	goto L6572;
L6583:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6572;
L6584:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&mm_tables_sysfnnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6572;
L6585:
	goto L6572;
L6586:
	goto L6572;
L6587:
	goto L6572;
L6588:
	goto L6572;
L6589:
	goto L6572;
L6590:
	R1 = 1;
	i = asi64(R1);
	R1 = 4;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6626;
L6624:
	asu64(R1) = p;
	R2 = 40;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6628;
	goto L6626;
L6628:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	i += 1; if (i <= av_1) goto L6624;
L6626:
	goto L6572;
L6591:
L6572:
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6630;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Is const");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6629;
L6630:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Not const");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6629:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6632;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6633;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L6634;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6635;
	goto L6636;
L6632:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6638;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Pcl<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6637;
L6638:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" no-op");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
L6637:
	goto L6631;
L6633:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Prop<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_propnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6631;
L6634:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Conv<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_convnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6631;
L6635:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Pclcond<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 64;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6631;
L6636:
L6631:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6641;
L6639:
	R1 = 0;
	asi64(R2) = i;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asi64(R2) = level;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 16;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = dev;
	mm_diags_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	i += 1; if (i <= av_2) goto L6639;
L6641:
L6567:
	return;
}

static void mm_diags_printunitlist(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6644;
	goto L6642;
L6644:
	goto L6646;
L6645:
	asu64(R1) = dev;
	asu64(R2) = prefix;
	asi64(R3) = level;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6646:
	asu64(R1) = p;
	if (asu64(R1)) goto L6645;
L6642:
	return;
}

static u64 mm_diags_getprefix(i64 level, u64 prefix, u64 p) {
    u64 R1, R2, R3; 
	struct $B41 indentstr;
	struct $B87 modestr;
	u64 isexpr;
	i64 av_1;
	R1 = 0;
	R2 = (u64)&indentstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = level;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L6650;
	R1 = 10;
	level = asi64(R1);
L6650:
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6653;
L6651:
	R1 = tou64("- ");
	R2 = (u64)&indentstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L6651;
L6653:
	R1 = tou64("S");
	isexpr = asu64(R1);
	R1 = (u64)&mm_tables_jisexpr;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6655;
	R1 = tou64("E");
	isexpr = asu64(R1);
L6655:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6657;
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L6657;
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L6657;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L6657;
	goto L6658;
L6657:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6660;
	R1 = tou64("S");
	isexpr = asu64(R1);
L6660:
	goto L6656;
L6658:
L6656:
	R1 = (u64)&modestr;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# #:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = isexpr;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6662;
	R1 = tou64("RES");
	goto L6661;
L6662:
	R1 = tou64("---");
L6661:
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&modestr;
	R3 = 256;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = tou64("-----------------------------");
	R2 = (u64)&modestr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 32;
	R2 = (u64)&modestr;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&modestr;
	R3 = 18;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = mm_diags_getlineinfok();
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&modestr;
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&indentstr;
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L6664;
	R1 = tou64(" ");
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6664:
	R1 = (u64)&mm_diags_getprefix_str;
	goto L6648;
L6648:
	return asu64(R1);
}

static u64 mm_diags_getlineinfok() {
    u64 R1, R2; 
	R1 = (u64)&mm_diags_getlineinfok_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# # ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("Z2");
	asi64(R2) = mm_diags_currfileno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z4");
	asi64(R2) = mm_diags_currlineno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_diags_getlineinfok_str;
	goto L6665;
L6665:
	return asu64(R1);
}

static void mm_diags_printmodelist(u64 f) {
    u64 R1, R2, R3; 
	i64 mbase;
	i64 av_1;
	i64 m;
	i64 i;
// PROC LOCAL STATICS GO HERE
	static u64 mm_diags_printmodelist_tab = (u64)"\t";
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("MODELIST");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	m = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6669;
L6667:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("4");
	asi64(R2) = m;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Basetype:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mbase;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = 1;
	asi64(R2) = mbase;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("ttname:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("ttnamedef:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6671;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6670;
L6671:
	R1 = tou64("-");
L6670:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Target:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Sizeset");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttsizeset;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# Bounds: #..#  Length:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mbase;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L6673;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Mult:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6676;
L6674:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_ttmult;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	i += 1; if (i <= av_1) goto L6674;
L6676:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6673:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Signed:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttsigned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isreal:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isinteger:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isshort:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isref:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isblock:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	m += 1; if (m <= mm_decls_ntypes) goto L6667;
L6669:
	return;
}

static void mm_diags_showprojectinfo(u64 dev) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 ps;
	u64 s;
	u8 isfirst;
	u8 ismain;
	i64 av_1;
	u64 pf;
	i64 i;
	i64 j;
// PROC LOCAL STATICS GO HERE
	static u64 mm_diags_showprojectinfo_tab = (u64)"    ";
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Project Structure:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("---------------------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Modules");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_nmodules;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6680;
L6678:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6682;
	asu64(R1) = pm;
	R2 = 18;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 18;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) == asi64(R2)) goto L6682;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6682:
	R1 = (u64)&mm_decls_subprogs;
	R2 = (u64)&mm_decls_moduletosub;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = i;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isfirst = asu8(R1);
	asu64(R1) = ps;
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = i;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	ismain = asu8(R1);
	asu8(R1) = isfirst;
	if (!asu8(R1)) goto L6684;
	asu8(R1) = ismain;
	if (!asu8(R1)) goto L6684;
	R1 = tou64("hm");
	s = asu64(R1);
	goto L6683;
L6684:
	asu8(R1) = isfirst;
	if (!asu8(R1)) goto L6685;
	R1 = tou64("h ");
	s = asu64(R1);
	goto L6683;
L6685:
	asu8(R1) = ismain;
	if (!asu8(R1)) goto L6686;
	R1 = tou64("m ");
	s = asu64(R1);
	goto L6683;
L6686:
	R1 = tou64("  ");
	s = asu64(R1);
L6683:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("2");
	asi64(R2) = i;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("16jl");
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("Sys:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Sub:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_subprogs;
	asu64(R2) = pm;
	R3 = 18;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Fileno:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	asu64(R1) = pm;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6688;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Alias:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6688:
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6690;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_space();
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_scopenames;
	asu64(R2) = pm;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 170;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L6690:
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6692;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_space();
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_scopenames;
	asu64(R2) = pm;
	R3 = 48;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 170;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L6692:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nmodules) goto L6678;
L6680:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Subprograms");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_nsubprogs;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("MAINSUBPROGNO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_mainsubprogno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6695;
L6693:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Sys:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = ps;
	R3 = 14;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 1;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L6697;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	j = asi64(R1);
	asu64(R1) = ps;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = j;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L6700;
L6698:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_space();
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("(");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(")");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	j += 1; if (j <= av_1) goto L6698;
L6700:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6697:
	i += 1; if (i <= mm_decls_nsubprogs) goto L6693;
L6695:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Sourcefiles");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6703;
L6701:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("  #:  Name=# File=# Path=# Spec=# Size=#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("2");
	asi64(R2) = i;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("jl16");
	asu64(R2) = pf;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("jl18");
	asu64(R2) = pf;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("20jl");
	asu64(R2) = pf;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("30jl");
	asu64(R2) = pf;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("7");
	asu64(R2) = pf;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nsourcefiles) goto L6701;
L6703:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Link files");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_nlibfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6706;
L6704:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("16jl");
	R2 = (u64)&mm_decls_libfiles;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nlibfiles) goto L6704;
L6706:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showlogfile() {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 logdev;
	i64 size;
	u64 ss;
	asi64(R1) = mm_decls_debugmode;
	if (asi64(R1)) goto L6709;
	goto L6707;
L6709:
	R1 = tou64("w");
	R2 = tou64("mx.log");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	logdev = asu64(R1);
	asu8(R1) = mm_decls_fshowmodules;
	if (!asu8(R1)) goto L6711;
	asu64(R1) = logdev;
	mm_diags_showprojectinfo(asu64(R1));
L6711:
	asu8(R1) = mm_decls_fshowasm;
	if (!asu8(R1)) goto L6713;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L6713;
	asu64(R1) = logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC ASSEMBLY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = logdev;
	R2 = tou64("asm");
	asu64(R3) = mm_decls_outfile;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6713:
	asu8(R1) = mm_decls_fshowpcl;
	if (!asu8(R1)) goto L6715;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L6715;
	asu64(R1) = logdev;
	R2 = tou64("pcl");
	asu64(R3) = mm_decls_outfile;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6715:
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L6717;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L6717;
	asu64(R1) = logdev;
	R2 = tou64("PSYMTAB");
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6717:
	asu8(R1) = mm_decls_fshowast3;
	if (!asu8(R1)) goto L6719;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L6719;
	asu64(R1) = logdev;
	R2 = tou64("AST3");
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6719:
	asu8(R1) = mm_decls_fshowast2;
	if (!asu8(R1)) goto L6721;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L6721;
	asu64(R1) = logdev;
	R2 = tou64("AST2");
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6721:
	asu8(R1) = mm_decls_fshowast1;
	if (!asu8(R1)) goto L6723;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L6723;
	asu64(R1) = logdev;
	R2 = tou64("AST1");
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6723:
	asu8(R1) = mm_decls_fshowst;
	if (!asu8(R1)) goto L6725;
	asu64(R1) = logdev;
	R2 = tou64("SYMBOL TABLE");
	mm_diags_showsttree(asu64(R2), asu64(R1));
L6725:
	asu8(R1) = mm_decls_fshowstflat;
	if (!asu8(R1)) goto L6727;
	asu64(R1) = logdev;
	R2 = tou64("FLAT SYMBOL TABLE");
	mm_diags_showstflat(asu64(R2), asu64(R1));
L6727:
	asu8(R1) = mm_decls_fshowtypes;
	if (!asu8(R1)) goto L6729;
	asu64(R1) = logdev;
	mm_diags_printmodelist(asu64(R1));
L6729:
	asu64(R1) = logdev;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	size = asi64(R1);
	asu64(R1) = logdev;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = size;
	if (!asi64(R1)) goto L6731;
	msysc_m$print_startcon();
	R1 = tou64("PRESS KEY...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_getch();
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6733;
	R1 = 0;
	exit(R1);
L6733:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\m\\ed.bat ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mx.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = tou64("mm.m");
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L6735;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&str;
	asi64(R1) = mwindows_os_execwait(asu64(R3), asi64(R2), asu64(R1));
	goto L6734;
L6735:
	msysc_m$print_startcon();
	R1 = tou64("Diagnostic outputs written to");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mx.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6734:
L6731:
L6707:
	return;
}

static void mm_diags_showstflat(u64 caption, u64 f) {
    u64 R1; 
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	mm_diags_printstflat(asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showsttree(u64 caption, u64 f) {
    u64 R1, R2, R3; 
	u64 pp;
	u64 d;
	i64 i;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = mm_decls_stprogram;
	asu64(R3) = f;
	mm_diags_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Proc List:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L6739;
L6738:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#\t#.# (#) Mod:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("20jl");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L6739:
	asu64(R1) = pp;
	if (asu64(R1)) goto L6738;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("End\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("DLL Proc List:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ndllproctable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6743;
L6741:
	R1 = (u64)&mm_decls_dllproctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#\t#.# (#) Mod:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("20jl");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_ndllproctable) goto L6741;
L6743:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("End\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showast(u64 filename) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L6746;
	goto L6744;
L6746:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	asu64(R2) = f;
	mm_diags_printcode(asu64(R2), asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L6744:
	return;
}

static void mm_diags_printsymbol(u64 lp) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 l;
	asu64(R1) = lp;
	(R1_B3) = *(struct $B3*)(R1);
	l = (R1_B3);
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("%-18s");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = (u64)&l;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 6: case 15: case 19: case 21: case 24: case 25: case 26: case 27: case 28: case 29: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 41: case 42: case 43: goto L6762;
	case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 16: case 17: case 18: case 20: case 22: case 23: case 30: case 40: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 66: goto L6750;
	case 62: goto L6754;
	case 63: goto L6759;
	case 64: goto L6761;
	case 65: goto L6760;
	case 67: goto L6751;
	default: goto L6750;
    };
// SWITCH
L6751:
	R1 = (u64)&l;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&l;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_lex_printstrn(asu64(R2), asi64(R1));
	R1 = (u64)&l;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6753;
	msysc_m$print_startcon();
	R1 = tou64(" [#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6753:
	goto L6748;
L6754:
	R1 = (u64)&l;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6756;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6757;
	goto L6758;
L6756:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("int");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6755;
L6757:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	R1 = tou64("word");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6755;
L6758:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6755:
	goto L6748;
L6759:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6748;
L6760:
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&l;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6748;
L6761:
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6748;
L6762:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6748;
L6750:
	R1 = (u64)&l;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6764;
	msysc_m$print_startcon();
	R1 = tou64("SUBCODE:");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&l;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6764:
L6748:
	msysc_m$print_startcon();
	msysc_m$print_space();
	R1 = tou64("LX.FILENO=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showtime(u64 caption, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("# # ms # %");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = caption;
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("5");
	asi64(R2) = t;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("5.1jr");
	asi64(R2) = t;
	asr64(R2) = tor64(asi64(R2));
	asr64(R3) = 1.000000000000000000e+002;
	asr64(R2) *= asr64(R3);
	asi64(R3) = mm_cli_compiletime;
	asr64(R3) = tor64(asi64(R3));
	asr64(R2) /= asr64(R3);
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showtimings() {
    u64 R1, R2; 
	asi64(R1) = mwindows_os_clock();
	mm_cli_endclock = asi64(R1);
	asi64(R1) = mm_cli_endclock;
	asi64(R2) = mm_cli_startclock;
	asi64(R1) -= asi64(R2);
	mm_cli_compiletime = asi64(R1);
	asi64(R1) = mm_cli_loadtime;
	R2 = tou64("Load:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = mm_cli_parsetime;
	R2 = tou64("Parse:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = mm_cli_resolvetime;
	R2 = tou64("Resolve:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = mm_cli_typetime;
	R2 = tou64("Type:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = mm_cli_pcltime;
	R2 = tou64("PCL:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_mcltime;
	R2 = tou64("MCL:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_sstime;
	R2 = tou64("SS:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_exetime;
	R2 = tou64("EXE:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("-----------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mm_cli_compiletime;
	R2 = tou64("Total:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	return;
}

static void mm_export_dummy_writeexports(u64 basefile, u64 modulename) {
	return;
}

static void mm_lex_lex() {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 lena;
	i64 lenb;
	u64 p;
	(R1_B3) = mm_decls_nextlx;
	mm_decls_lx = (R1_B3);
	asu64(R1) = mm_lex_lxstart;
	asu64(R2) = mm_lex_lxsource;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 23;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L6769:
	mm_lex_lexreadtoken();
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L6771;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L6772;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6773;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6774;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6775;
	goto L6776;
L6771:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6779;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6779;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6779;
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6778;
	asi64(R1) = mm_decls_assemmode;
	if (asi64(R1)) goto L6778;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6778;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6778;
L6779:
	goto L6777;
L6778:
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6770;
L6777:
	goto L6769;
L6772:
	mm_lex_doinclude();
	goto L6769;
L6773:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L6781;
	goto L6782;
L6781:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6784;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6785;
	goto L6786;
L6784:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6788;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6789;
	goto L6790;
L6788:
	R1 = 1000000;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L6787;
L6789:
	R1 = 1000000000;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L6787;
L6790:
	R1 = tou64("Can't do this unit index");
	mm_support_lxerror(asu64(R1));
L6787:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6783;
L6785:
	R1 = tou64("Unit suffix after float not implem");
	mm_support_lxerror(asu64(R1));
	goto L6783;
L6786:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6770;
L6783:
	goto L6780;
L6782:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6770;
L6780:
	goto L6769;
L6774:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6770;
	goto L6769;
L6775:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 47;
	if (asi64(R1) != asi64(R2)) goto L6792;
	R1 = 45;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6791;
L6792:
	goto L6770;
L6791:
	goto L6769;
L6776:
	goto L6770;
	goto L6769;
L6770:
	asi64(R1) = mm_lex_lxfileno;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 24;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void mm_lex_lexreadtoken() {
    u64 R1, R2, R3; 
	i64 c;
	i64 hsum;
	u64 sptr;
	u64 lxsvalue;
	i64 length;
	i64 commentseen;
	u64 p;
	u64 q;
	u8 instr;
	struct $B16 str;
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6794:
	asu64(R1) = mm_lex_lxsptr;
	mm_lex_lxstart = asu64(R1);
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L6917;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: goto L6797;
	case 9: case 32: goto L6914;
	case 10: goto L6916;
	case 13: goto L6915;
	case 33: goto L6823;
	case 34: goto L6912;
	case 35: goto L6831;
	case 36: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L6798;
	case 37: goto L6890;
	case 38: goto L6906;
	case 39: goto L6911;
	case 40: goto L6865;
	case 41: goto L6866;
	case 42: goto L6886;
	case 43: goto L6878;
	case 44: goto L6859;
	case 45: goto L6881;
	case 46: goto L6851;
	case 47: goto L6889;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L6814;
	case 58: goto L6861;
	case 59: goto L6860;
	case 60: goto L6895;
	case 61: goto L6891;
	case 62: goto L6901;
	case 63: goto L6872;
	case 64: goto L6871;
	case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: goto L6813;
	case 91: goto L6867;
	case 92: goto L6832;
	case 93: goto L6868;
	case 94: goto L6870;
	case 96: goto L6913;
	case 123: goto L6849;
	case 124: goto L6869;
	case 125: goto L6850;
	case 126: goto L6877;
	default: goto L6797;
    };
// SWITCH
L6798:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	lxsvalue = asu64(R1);
// mm_lex.lexreadtoken.doname:
L6799:
	asu64(R1) = lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
	asu64(R1) = mm_lex_lxsptr;
	sptr = asu64(R1);
L6800:
	R1 = (u64)&mm_lex_namemap;
	R2 = (u64)&sptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6802;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6803;
	goto L6804;
L6802:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L6800;
L6803:
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) += asu64(R2);
	asu64(R2) = sptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 32;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L6800;
L6804:
	asu64(R1) = sptr;
	R2 = 1;
	R1 -= (i64)R2;
	mm_lex_lxsptr = asu64(R1);
	goto L6801;
	goto L6800;
L6801:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L6806;
	asu64(R1) = lxsvalue;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = mm_lex_lxsptr;
	if (asu64(R1) != asu64(R2)) goto L6808;
	asu64(R1) = lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6810;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L6810;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L6811;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L6811;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L6811;
	goto L6812;
L6810:
	mm_lex_readrawstring();
	goto L6793;
	goto L6809;
L6811:
	asi64(R1) = c;
	mm_lex_readarraystring(asi64(R1));
	goto L6793;
	goto L6809;
L6812:
L6809:
L6808:
L6806:
	asi64(R1) = hsum;
	asu64(R2) = mm_lex_lxsptr;
	asu64(R3) = lxsvalue;
	asi64(R2) -= asi64(R3);
	asu64(R3) = lxsvalue;
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	goto L6793;
	goto L6794;
L6813:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	lxsvalue = asu64(R1);
	R1 = 32;
	asu64(R2) = lxsvalue;
	*tou8p(R2) += asu8(R1);
	goto L6799;
	goto L6794;
L6814:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	mm_lex_lxstart = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L6816;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L6816;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L6816;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6816;
	R2 = 120;
	if (asu64(R1) == asu64(R2)) goto L6817;
	R2 = 88;
	if (asu64(R1) == asu64(R2)) goto L6817;
	goto L6818;
L6816:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6815;
L6817:
	asu64(R1) = mm_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L6820;
	R2 = 50;
	if (asu64(R1) == asu64(R2)) goto L6821;
	goto L6822;
L6820:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	mm_lex_readhex();
	goto L6819;
L6821:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	mm_lex_readbin();
	goto L6819;
L6822:
	R1 = tou64("Bad base");
	mm_support_lxerror(asu64(R1));
L6819:
	goto L6815;
L6818:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	mm_lex_readdec();
L6815:
	goto L6793;
	goto L6794;
L6823:
// mm_lex.lexreadtoken.docomment:
L6825:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6827;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6828;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6829;
	goto L6830;
L6827:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6826;
	goto L6825;
L6828:
	goto L6826;
	goto L6825;
L6829:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6826;
	goto L6825;
L6830:
	goto L6825;
L6826:
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6831:
	R1 = 23;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6832:
	R1 = 0;
	commentseen = asi64(R1);
L6833:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L6835;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6836;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L6837;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6838;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L6838;
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L6839;
	goto L6840;
L6835:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6834;
	goto L6833;
L6836:
	goto L6834;
	goto L6833;
L6837:
	R1 = 59;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6793;
	goto L6833;
L6838:
	goto L6833;
L6839:
	R1 = 1;
	commentseen = asi64(R1);
	goto L6833;
L6840:
	asi64(R1) = commentseen;
	if (asi64(R1)) goto L6842;
	R1 = tou64("\\ not followed by eol");
	mm_support_lxerror(asu64(R1));
L6842:
	goto L6833;
L6834:
L6843:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L6845;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6846;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6847;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L6847;
	goto L6848;
L6845:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6843;
L6846:
	goto L6843;
L6847:
	goto L6843;
L6848:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6844;
	goto L6843;
L6844:
	goto L6794;
L6849:
	R1 = 13;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6850:
	R1 = 14;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6851:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L6853;
	goto L6854;
L6853:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L6856;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 22;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6855;
L6856:
	R1 = 21;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 21;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6855:
	goto L6793;
	goto L6852;
L6854:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L6858;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L6858;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = tou64(".123 not done");
	mm_support_lxerror(asu64(R1));
	goto L6793;
	goto L6857;
L6858:
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
L6857:
L6852:
	goto L6794;
L6859:
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6860:
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6861:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L6863;
	goto L6864;
L6863:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 6;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 28;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6862;
L6864:
	R1 = 5;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6862:
	goto L6793;
	goto L6794;
L6865:
	R1 = 9;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6866:
	R1 = 10;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6867:
	R1 = 11;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6868:
	R1 = 12;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6869:
	R1 = 16;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6870:
	R1 = 15;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6871:
	R1 = 17;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6872:
	R1 = (u64)&str;
	p = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 += (i64)R2;
	q = asu64(R1);
	goto L6874;
L6873:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6874:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6876;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6876;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6873;
L6876:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 18;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6877:
	goto L6794;
L6878:
	R1 = 24;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L6880;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 61;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 84;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
L6880:
	goto L6793;
	goto L6794;
L6881:
	R1 = 25;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L6883;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L6884;
	goto L6885;
L6883:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 61;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 85;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6882;
L6884:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6882;
L6885:
L6882:
	goto L6793;
	goto L6794;
L6886:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 42;
	if (asu64(R1) != asu64(R2)) goto L6888;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 43;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6887;
L6888:
	R1 = 26;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6887:
	goto L6793;
	goto L6794;
L6889:
	R1 = 27;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6890:
	R1 = 28;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6891:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L6893;
	goto L6894;
L6893:
	R1 = 7;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6892;
L6894:
	R1 = 41;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6892:
	goto L6793;
	goto L6794;
L6895:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L6897;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L6898;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L6899;
	goto L6900;
L6897:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6896;
L6898:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 2;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6896;
L6899:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 34;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6896;
L6900:
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6896:
	goto L6793;
	goto L6794;
L6901:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L6903;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L6904;
	goto L6905;
L6903:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6902;
L6904:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 35;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6902;
L6905:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6902:
	goto L6793;
	goto L6794;
L6906:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L6908;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L6909;
	goto L6910;
L6908:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 20;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 57;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6907;
L6909:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 2;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6907;
L6910:
	R1 = 19;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 55;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6907:
	goto L6793;
	goto L6794;
L6911:
	R1 = 39;
	mm_lex_lxreadstring(asi64(R1));
	goto L6793;
	goto L6794;
L6912:
	R1 = 34;
	mm_lex_lxreadstring(asi64(R1));
	goto L6793;
	goto L6794;
L6913:
	mm_lex_readrawxname();
	goto L6793;
	goto L6794;
L6914:
	goto L6794;
L6915:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6916:
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6793;
	goto L6794;
L6917:
	asi64(R1) = mm_lex_sourcelevel;
	if (!asi64(R1)) goto L6919;
	mm_lex_unstacksource();
	goto L6793;
	goto L6918;
L6919:
	R1 = 59;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6793;
L6918:
	goto L6794;
L6797:
	R1 = tou64("Unknown char");
	mm_support_lxerror(asu64(R1));
	goto L6793;
	goto L6794;
L6793:
	return;
}

static void mm_lex_lexsetup() {
	mm_lex_inithashtable();
	return;
}

static void mm_lex_printstrn(u64 s, i64 length) {
    u64 R1, R2; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L6923;
	msysc_m$print_startcon();
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
L6923:
	return;
}

static void mm_lex_readrawstring() {
    u64 R1, R2, R3; 
	u64 dest;
	i64 c;
	R1 = 65;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	dest = asu64(R1);
L6925:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6927;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6928;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6928;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6928;
	goto L6929;
L6927:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L6931;
	R1 = 34;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6930;
L6931:
	goto L6926;
L6930:
	goto L6925;
L6928:
	R1 = tou64("Raw string not terminated");
	mm_support_lxerror(asu64(R1));
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6926;
	goto L6925;
L6929:
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6925;
L6926:
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lex_lookup(u64 name, i64 length, i64 hashindex) {
    u64 R1, R2, R3, R4; 
	i64 wrapped;
	i64 j;
	u64 d;
	asi64(R1) = hashindex;
	R2 = 65535;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L6933:
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6936;
	goto L6934;
L6936:
	asu64(R1) = d;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L6938;
	asi64(R1) = length;
	asu64(R2) = name;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6938;
	asu64(R1) = d;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 77;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6932;
L6938:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L6940;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L6942;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L6942:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L6940:
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	goto L6933;
L6934:
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mm_lex_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = name;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = d;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 77;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6932:
	return;
}

static i64 mm_lex_lookupsys(u64 name) {
    u64 R1, R2, R3; 
	i64 j;
	i64 wrapped;
	i64 hashvalue;
	asu64(R1) = name;
	asi64(R1) = mm_lex_gethashvaluez(asu64(R1));
	R2 = 65535;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L6944:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6947;
	goto L6945;
	goto L6946;
L6947:
	asu64(R1) = name;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6948;
	msysc_m$print_startcon();
	R1 = tou64("Lex dupl name:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L6948:
L6946:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L6950;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L6952;
	R1 = tou64("SYS:HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L6952:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L6950:
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6944;
L6945:
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lex_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = name;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	goto L6943;
L6943:
	return asi64(R1);
}

static i64 mm_lex_gethashvaluez(u64 s) {
    u64 R1, R2; 
	i64 c;
	i64 hsum;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6955;
	R1 = 0;
	goto L6953;
L6955:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
L6956:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6959;
	goto L6957;
L6959:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L6956;
L6957:
	asi64(R1) = hsum;
	goto L6953;
L6953:
	return asi64(R1);
}

static void mm_lex_inithashtable() {
    u64 R1, R2, R3; 
	i64 i;
	i64 av_1;
	R1 = 524288;
	R2 = 0;
	R3 = (u64)&mm_lex_hashtable;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	R1 = 174;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6963;
L6961:
	R1 = (u64)&mm_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mm_lex_lookupsys(asu64(R1));
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L6965;
	goto L6966;
L6965:
	R1 = (u64)&mm_tables_stsubcodes;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6964;
L6966:
	R1 = (u64)&mm_tables_stsubcodes;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6964:
	i += 1; if (i <= av_1) goto L6961;
L6963:
	return;
}

static void mm_lex_printhashtable() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("Hashtable:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_lex_addreservedword(u64 name, i64 symbol, i64 subcode, i64 regsize) {
    u64 R1, R2, R3; 
	asu64(R1) = name;
	asi64(R1) = mm_lex_lookupsys(asu64(R1));
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = symbol;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = subcode;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = regsize;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 164;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void mm_lex_doinclude() {
    u64 R1, R2, R3; 
	u64 file;
	u64 pf;
	mm_lex_lexreadtoken();
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L6971;
	R1 = tou64("include: string expected");
	mm_support_lxerror(asu64(R1));
L6971:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	file = asu64(R1);
	asu64(R1) = file;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = tou64("m");
	asu64(R2) = file;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	file = asu64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = mm_lex_lxfileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("");
	asu64(R3) = file;
	asu64(R1) = mm_support_getsupportfile(asu64(R3), asu64(R2), asu64(R1));
	pf = asu64(R1);
	mm_lex_lexreadtoken();
	R1 = 0;
	asu64(R2) = pf;
	R3 = 64;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	mm_lex_stacksource(asi64(R2), asi64(R1));
	return;
}

static void mm_lex_startlex(u64 file) {
    u64 R1, R2, R3; 
	asu64(R1) = file;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	mm_lex_lxsptr = asu64(R2);
	mm_lex_lxsource = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = file;
	R2 = 64;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	mm_lex_lxfileno = asi64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_lex_addnamestr(u64 name) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	struct $B3 oldlx;
	u64 symptr;
	(R1_B3) = mm_decls_nextlx;
	oldlx = (R1_B3);
	asu64(R1) = name;
	asi64(R1) = mm_lex_gethashvaluez(asu64(R1));
	asu64(R2) = name;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = name;
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B3) = oldlx;
	mm_decls_nextlx = (R1_B3);
	asu64(R1) = symptr;
	goto L6973;
L6973:
	return asu64(R1);
}

static void mm_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PS:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	mm_diags_printsymbol(asu64(R1));
	return;
}

static void mm_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_nextlx;
	mm_diags_printsymbol(asu64(R1));
	return;
}

static void mm_lex_psx(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	mm_diags_printsymbol(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_nextlx;
	mm_diags_printsymbol(asu64(R1));
	return;
}

static void mm_lex_stacksource(i64 fileno, i64 isimport) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asi64(R1) = mm_lex_sourcelevel;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L6979;
	R1 = tou64("Include file/macro overflow");
	mm_support_lxerror(asu64(R1));
L6979:
	R1 = (u64)&mm_lex_sourcelevel;
	(*toi64p(R1)) += 1;
	asu64(R1) = mm_lex_lxstart;
	R2 = (u64)&mm_lex_lxstart_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_lex_lxsource;
	R2 = (u64)&mm_lex_lxsource_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_lex_lxsptr_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mm_lex_lxfileno;
	R2 = (u64)&mm_lex_lxfileno_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	(R1_B3) = mm_decls_nextlx;
	R2 = (u64)&mm_lex_lxnextlx_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*(struct $B3*)(((i64)R2+(i64)R3*16-16)) = (R1_B3);
	asi64(R1) = mm_lex_lximport;
	R2 = (u64)&mm_lex_lximport_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = isimport;
	mm_lex_lximport = asi64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	mm_lex_lxsptr = asu64(R2);
	mm_lex_lxsource = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = fileno;
	mm_lex_lxfileno = asi64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_lex_unstacksource() {
    u64 R1, R2; struct $B3 R1_B3; 
	asi64(R1) = mm_lex_sourcelevel;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6982;
	R1 = (u64)&mm_lex_lxstart_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxstart = asu64(R1);
	R1 = (u64)&mm_lex_lxsource_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxsource = asu64(R1);
	R1 = (u64)&mm_lex_lxsptr_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxsptr = asu64(R1);
	R1 = (u64)&mm_lex_lxnextlx_stack;
	asi64(R2) = mm_lex_sourcelevel;
	(R1_B3) = *(struct $B3*)(((i64)R1+(i64)R2*16-16));
	mm_decls_nextlx = (R1_B3);
	R1 = (u64)&mm_lex_lxfileno_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxfileno = asi64(R1);
	R1 = (u64)&mm_lex_lximport_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_lex_lximport = asi64(R1);
	R1 = (u64)&mm_lex_sourcelevel;
	(*toi64p(R1)) -=1;
L6982:
	return;
}

static void mm_lex_readarraystring(i64 prefix) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 34;
	mm_lex_lxreadstring(asi64(R1));
	asi64(R1) = prefix;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L6985;
	R1 = 83;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6984;
L6985:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 2;
	R1 += (i64)R2;
	(*tou16p(R1)) -=1;
	R1 = 66;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6984:
	return;
}

static i64 mm_lex_setinttype(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 9223372036854775807;
	if (asu64(R1) > asu64(R2)) goto L6988;
	R1 = 3;
	goto L6987;
L6988:
	R1 = 4;
L6987:
	goto L6986;
L6986:
	return asi64(R1);
}

static void mm_lex_readrawxname() {
    u64 R1, R2, R3, R4; 
	i64 c;
	i64 hsum;
	i64 length;
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	hsum = asi64(R1);
	goto L6991;
L6990:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
L6991:
	R1 = (u64)&mm_lex_namemap;
	R2 = (u64)&mm_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6990;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6994;
	R1 = tou64("Bad ` name");
	mm_support_lxerror(asu64(R1));
L6994:
	asi64(R1) = hsum;
	asi64(R2) = length;
	R3 = (u64)&mm_decls_nextlx;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = 60;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6989;
L6989:
	return;
}

static void mm_lex_lxerror_s(u64 mess, u64 s) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_lxerror(asu64(R1));
	return;
}

static void mm_lex_lxreadstring(i64 termchar) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	i64 c;
	i64 d;
	i64 length;
	i64 hasescape;
	i64 a;
	i64 n;
	u64 str;
	i64 pass;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L6998;
	R1 = 65;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6997;
L6998:
	R1 = 64;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6997:
	R1 = 0;
	length = asi64(R1);
	R1 = 0;
	hasescape = asi64(R1);
	R1 = 0;
	t = asu64(R1);
	R1 = 1;
	pass = asi64(R1);
L6999:
	asu64(R1) = mm_lex_lxsptr;
	s = asu64(R1);
L7002:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L7005;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L7006;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7006;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7007;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7007;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7007;
	goto L7008;
L7005:
	R1 = 1;
	hasescape = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L7010;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L7010;
	R1 = 32;
	R2 = (u64)&c;
	*toi64p(R2) += asi64(R1);
L7010:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) == asi64(R2)) goto L7012;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L7013;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L7014;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L7014;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L7015;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L7016;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L7017;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7018;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L7018;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L7019;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L7020;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L7020;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L7021;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L7022;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L7023;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L7024;
	goto L7025;
L7012:
	R1 = 7;
	c = asi64(R1);
	goto L7011;
L7013:
	R1 = 8;
	c = asi64(R1);
	goto L7011;
L7014:
	R1 = 13;
	c = asi64(R1);
	goto L7011;
L7015:
	R1 = 27;
	c = asi64(R1);
	goto L7011;
L7016:
	R1 = 12;
	c = asi64(R1);
	goto L7011;
L7017:
	goto L7027;
L7026:
	R1 = 1;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = mm_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L7030;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L7030:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
L7027:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L7026;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
	goto L7011;
L7018:
	R1 = 10;
	c = asi64(R1);
	goto L7011;
L7019:
	R1 = 9;
	c = asi64(R1);
	goto L7011;
L7020:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L7032;
	asu64(R1) = t;
	goto L7031;
L7032:
	R1 = 0;
L7031:
	R2 = 0;
	asi64(R3) = c;
	R4 = 117;
	if (asi64(R3) != asi64(R4)) goto L7034;
	R3 = 4;
	goto L7033;
L7034:
	R3 = 6;
L7033:
	R4 = (u64)&s;
	asi64(R2) = mm_lex_readhexcode(asu64(R4), asi64(R3), asi64(R2));
	asi64(R1) = mm_lex_getutf8(asi64(R2), asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	goto L7002;
	goto L7011;
L7021:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L7036;
	R1 = 13;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L7036:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	R1 = 10;
	c = asi64(R1);
	goto L7011;
L7022:
	R1 = 0;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = mm_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	goto L7011;
L7023:
	R1 = 16;
	c = asi64(R1);
	goto L7011;
L7024:
	R1 = 0;
	c = asi64(R1);
	goto L7011;
L7025:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L7038;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L7039;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7040;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L7041;
	goto L7042;
L7038:
	R1 = 34;
	c = asi64(R1);
	goto L7037;
L7039:
	R1 = 92;
	c = asi64(R1);
	goto L7037;
L7040:
	R1 = 39;
	c = asi64(R1);
	goto L7037;
L7041:
	R1 = 0;
	c = asi64(R1);
	goto L7037;
L7042:
	asi64(R1) = c;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	R2 = tou64("Unknown string escape: \\%s");
	mm_lex_lxerror_s(asu64(R2), asu64(R1));
L7037:
L7011:
	goto L7004;
L7006:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L7044;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asi64(R2) = c;
	if (asi64(R1) != asi64(R2)) goto L7046;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L7045;
L7046:
	goto L7003;
L7045:
L7044:
	R1 = 1;
	hasescape = asi64(R1);
	goto L7004;
L7007:
	R1 = tou64("String not terminated");
	mm_support_lxerror(asu64(R1));
	goto L7004;
L7008:
L7004:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L7048;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L7048:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	goto L7002;
L7003:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7050;
	asu64(R1) = t;
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = hasescape;
	if (!asi64(R1)) goto L7052;
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7051;
L7052:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7053;
	R1 = tou64("");
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
	goto L6996;
	goto L7051;
L7053:
	asi64(R1) = length;
	asu64(R2) = mm_lex_lxsptr;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
	goto L6996;
L7051:
	goto L7049;
L7050:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
L7049:
	pass += 1; if (pass <= 2) goto L6999;
L6996:
	return;
}

static i64 mm_lex_readhexcode(u64 s, i64 n, i64 sp) {
    u64 R1, R2; 
	i64 a;
	i64 c;
	i64 i;
	R1 = 0;
	a = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7057;
L7055:
	asi64(R1) = sp;
	if (!asi64(R1)) goto L7059;
	asi64(R1) = i;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7059;
L7060:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7060;
	goto L7058;
L7059:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
L7058:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L7064;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L7064;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L7063;
L7064:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L7065;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L7065;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L7063;
L7065:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7066;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7066;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	goto L7063;
L7066:
	R1 = tou64("Bad hex digit");
	mm_support_lxerror(asu64(R1));
L7063:
	i += 1; if (i <= n) goto L7055;
L7057:
	asi64(R1) = a;
	goto L7054;
L7054:
	return asi64(R1);
}

static i64 mm_lex_getutf8(i64 c, u64 s) {
    u64 R1, R2, R3, R4; 
	i64 n;
	struct $B3 str;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7069;
	R1 = (u64)&str;
	s = asu64(R1);
L7069:
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L7071;
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7070;
L7071:
	asi64(R1) = c;
	R2 = 2047;
	if (asi64(R1) > asi64(R2)) goto L7072;
	R1 = 2;
	n = asi64(R1);
	R1 = 192;
	asi64(R2) = c;
	R3 = 6;
	R4 = 10;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7070;
L7072:
	asi64(R1) = c;
	R2 = 65535;
	if (asi64(R1) > asi64(R2)) goto L7073;
	R1 = 3;
	n = asi64(R1);
	R1 = 224;
	asi64(R2) = c;
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7070;
L7073:
	asi64(R1) = c;
	R2 = 1114111;
	if (asi64(R1) > asi64(R2)) goto L7074;
	R1 = 4;
	n = asi64(R1);
	R1 = 240;
	asi64(R2) = c;
	R3 = 18;
	R4 = 20;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 12;
	R4 = 17;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7070;
L7074:
	R1 = 0;
	n = asi64(R1);
L7070:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = n;
	goto L7067;
L7067:
	return asi64(R1);
}

static void mm_lex_readdec() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 islong;
	i64 length;
	struct $B41 str;
	u64 a;
	i64 av_1;
	R1 = 0;
	islong = asi64(R1);
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L7076:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7079;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7079;
	asu64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7078;
L7079:
	asi64(R1) = c;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L7081;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7081;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7082;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7083;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7083;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7084;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7084;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L7085;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L7085;
	goto L7086;
L7081:
	asu64(R1) = pstart;
	mm_lex_lxsptr = asu64(R1);
	mm_lex_readreal();
	goto L7075;
	goto L7080;
L7082:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L7088;
	asu64(R1) = pstart;
	mm_lex_lxsptr = asu64(R1);
	mm_lex_readreal();
	goto L7075;
L7088:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7077;
	goto L7080;
L7083:
	goto L7080;
L7084:
	mm_lex_nodecimal();
	goto L7080;
L7085:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L7090;
	R1 = tou64("bin overflow");
	mm_support_lxerror(asu64(R1));
L7090:
	R1 = (u64)&str;
	dest = asu64(R1);
	R1 = 0;
	a = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7093;
L7091:
	asu64(R1) = dest;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 50;
	if (asu64(R1) < asu64(R2)) goto L7095;
	R1 = tou64("bad bin digit");
	mm_support_lxerror(asu64(R1));
L7095:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	if (--asi64(av_1)) goto L7091;
L7093:
	goto L7096;
	goto L7080;
L7086:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7077;
L7080:
L7078:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7098;
	R1 = tou64("Numlit too long");
	mm_support_lxerror(asu64(R1));
L7098:
	goto L7076;
L7077:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L7101;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7100;
	R1 = 20;
	asu64(R2) = mm_lex_u64maxstr;
	R3 = (u64)&str;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7100;
L7101:
	mm_lex_nodecimal();
L7100:
// mm_lex.readdec.finish:
L7096:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7075:
	return;
}

static void mm_lex_readhex() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B41 str;
	u64 a;
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L7103:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7106;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7106;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7105;
L7106:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L7107;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L7107;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L7105;
L7107:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L7108;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L7108;
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L7105;
L7108:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7110;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7110;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7111;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7111;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7112;
	goto L7113;
L7110:
	goto L7109;
L7111:
	mm_lex_nodecimal();
	goto L7109;
L7112:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7104;
	goto L7109;
L7113:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7104;
L7109:
L7105:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7115;
	R1 = tou64("Numlit too long");
	mm_support_lxerror(asu64(R1));
L7115:
	goto L7103;
L7104:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L7117;
	R1 = tou64("MAKEDEC");
	mm_support_lxerror(asu64(R1));
	goto L7102;
L7117:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7102:
	return;
}

static void mm_lex_readbin() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B41 str;
	u64 a;
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L7119:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L7122;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7122;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7123;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7123;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7124;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7124;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7125;
	goto L7126;
L7122:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7121;
L7123:
	goto L7121;
L7124:
	mm_lex_nodecimal();
	goto L7121;
L7125:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7120;
	goto L7121;
L7126:
	asi64(R1) = c;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L7128;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7128;
	R1 = tou64("bin bad digit");
	mm_support_lxerror(asu64(R1));
	goto L7127;
L7128:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7120;
L7127:
L7121:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7130;
	R1 = tou64("bin overflow");
	mm_support_lxerror(asu64(R1));
L7130:
	goto L7119;
L7120:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L7132;
	mm_lex_nodecimal();
L7132:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void mm_lex_readreal() {
    u64 R1, R2, R3; 
	i64 c;
	i64 negexpon;
	i64 dotseen;
	i64 length;
	i64 fractlen;
	i64 expon;
	i64 expseen;
	r64 x;
	struct $B41 str;
	u64 dest;
	u64 destend;
	u64 a;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 i;
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 100;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	R2 = R1;
	fractlen = asi64(R2);
	R2 = R1;
	expon = asi64(R2);
	R2 = R1;
	expseen = asi64(R2);
	R2 = R1;
	dotseen = asi64(R2);
	R2 = R1;
	negexpon = asi64(R2);
	length = asi64(R1);
L7134:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7137;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7137;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L7139;
	R1 = (u64)&fractlen;
	(*toi64p(R1)) += 1;
L7139:
	goto L7136;
L7137:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7141;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L7142;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7142;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7143;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7143;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7144;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7144;
	goto L7145;
L7141:
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L7147;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7135;
L7147:
	R1 = 1;
	dotseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7140;
L7142:
	asi64(R1) = expseen;
	if (!asi64(R1)) goto L7149;
	R1 = tou64("double expon");
	mm_support_lxerror(asu64(R1));
L7149:
	R1 = 1;
	expseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7151;
L7150:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
L7151:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L7150;
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L7155;
	R2 = 45;
	if (asi64(R1) != asi64(R2)) goto L7154;
L7155:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L7157;
	R1 = 1;
	negexpon = asi64(R1);
L7157:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L7154:
	R1 = 0;
	expon = asi64(R1);
L7158:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7161;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7161;
	asi64(R1) = expon;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	expon = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7163;
	R1 = tou64("expon?");
	mm_support_lxerror(asu64(R1));
L7163:
	goto L7160;
L7161:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7165;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7165;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7166;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7166;
	goto L7167;
L7165:
	goto L7164;
L7166:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	mm_lex_nodecimal();
	goto L7133;
	goto L7164;
L7167:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7135;
L7164:
L7160:
	goto L7158;
	goto L7140;
L7143:
	goto L7140;
L7144:
	mm_lex_nodecimal();
	goto L7133;
	goto L7140;
L7145:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7135;
L7140:
L7136:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7169;
	R1 = tou64("r64lit too long");
	mm_support_lxerror(asu64(R1));
L7169:
	goto L7134;
L7135:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = expseen;
	if (!asi64(R1)) goto L7171;
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7171;
	asi64(R1) = dotseen;
	if (asi64(R1)) goto L7171;
	R1 = 0;
	a = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7174;
L7172:
	asu64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&str;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	i += 1; if (i <= length) goto L7172;
L7174:
	asi64(R1) = expon;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7177;
L7175:
	asu64(R1) = a;
	R2 = 10;
	asu64(R1) *= asu64(R2);
	a = asu64(R1);
	if (--asi64(av_1)) goto L7175;
L7177:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7133;
L7171:
	asi64(R1) = negexpon;
	if (!asi64(R1)) goto L7179;
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	expon = asi64(R1);
L7179:
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = dotseen;
	asi64(R1) += asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7182;
L7180:
	R1 = (u64)&str;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7184;
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 48;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	x = asr64(R1);
L7184:
	i += 1; if (i <= av_2) goto L7180;
L7182:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7186;
	asi64(R1) = expon;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7189;
L7187:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_3)) goto L7187;
L7189:
	goto L7185;
L7186:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7192;
L7190:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_4)) goto L7190;
L7192:
L7185:
	asr64(R1) = x;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 63;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7133:
	return;
}

static void mm_lex_nodecimal() {
    u64 R1; 
	R1 = tou64("Decimal not ready");
	mm_support_lxerror(asu64(R1));
	return;
}

static void mm_lex_start() {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 c;
	R1 = 0;
	c = asi64(R1);
	R1 = 255;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7197;
L7195:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L7201;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L7200;
L7201:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7202;
	R2 = 57;
	if (asi64(R1) <= asi64(R2)) goto L7200;
L7202:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7203;
	R2 = 36;
	if (asi64(R1) != asi64(R2)) goto L7199;
L7203:
L7200:
	R1 = 1;
	R2 = (u64)&mm_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7198;
L7199:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L7204;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L7204;
	R1 = 2;
	R2 = (u64)&mm_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7204:
L7198:
	c += 1; if (c <= av_1) goto L7195;
L7197:
	return;
}

static u64 mm_lib_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 88;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L7205;
L7205:
	return asu64(R1);
}

static u64 mm_lib_getduplnameptr(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = mm_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 78;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	asu64(R2) = p;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L7206;
L7206:
	return asu64(R1);
}

static void mm_lib_adddef(u64 owner, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (!asu64(R1)) goto L7209;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L7211;
	msysc_m$print_startcon();
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Duplicate name");
	mm_support_serror(asu64(R1));
L7211:
L7209:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7213;
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7212;
L7213:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7212:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 4;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L7214;
L7214:
	return asu64(R1);
}

static u64 mm_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L7215;
L7215:
	return asu64(R1);
}

static u64 mm_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L7216;
L7216:
	return asu64(R1);
}

static u64 mm_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L7217;
L7217:
	return asu64(R1);
}

static u64 mm_lib_createunit3(i64 tag, u64 p, u64 q, u64 r) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = u;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L7218;
L7218:
	return asu64(R1);
}

static void mm_lib_insertunit(u64 p, i64 tag) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 q;
	u64 nextunit;
	i64 mode;
	asu64(R1) = mm_lib_allocunitrec();
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = q;
	*(struct $B60*)(R2) = (R1_B60);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nextunit = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	memset(R1, 0, 65);
	asi64(R1) = tag;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = nextunit;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_lib_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = p;
	*(struct $B60*)(R2) = (R1_B60);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_createconstunit(u64 a, i64 t) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = u;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = u;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L7221;
L7221:
	return asu64(R1);
}

static u64 mm_lib_createstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 20;
	asu64(R2) = u;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7224;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L7223;
L7224:
	asi64(R1) = length;
	asu64(R2) = u;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L7223:
	asu64(R1) = u;
	goto L7222;
L7222:
	return asu64(R1);
}

static i64 mm_lib_newtypename(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_decls_ntypenames;
	R2 = 38000;
	if (asi64(R1) < asi64(R2)) goto L7227;
	R1 = tou64("Too many type names");
	mm_support_serror(asu64(R1));
L7227:
	R1 = (u64)&mm_decls_ntypenames;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	R2 = (u64)&mm_decls_typenames;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*32;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	R2 = (u64)&mm_decls_typenames;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*32;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_typenamepos;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*4;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_ntypenames;
	asi64(R1) = -asi64(R1);
	goto L7225;
L7225:
	return asi64(R1);
}

static i64 mm_lib_createusertype(u64 stname) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_decls_ntypes;
	R2 = 16000;
	if (asi64(R1) < asi64(R2)) goto L7230;
	msysc_m$print_startcon();
	asi64(R1) = mm_decls_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many types");
	mm_support_serror(asu64(R1));
L7230:
	R1 = (u64)&mm_decls_ntypes;
	(*toi64p(R1)) += 1;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttname;
	asi64(R3) = mm_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = stname;
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = mm_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = mm_decls_ntypes;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlineno;
	asi64(R3) = mm_decls_ntypes;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = mm_decls_ntypes;
	asu64(R2) = stname;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = mm_decls_ntypes;
	goto L7228;
L7228:
	return asi64(R1);
}

static i64 mm_lib_createusertypefromstr(u64 name) {
    u64 R1, R2, R3; 
	u64 stname;
	R1 = 5;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stmodule;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	goto L7231;
L7231:
	return asi64(R1);
}

static u64 mm_lib_getrangelwbunit(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L7234;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7233;
L7234:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
L7233:
	goto L7232;
L7232:
	return asu64(R1);
}

static u64 mm_lib_getrangeupbunit(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L7237;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7236;
L7237:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
L7236:
	goto L7235;
L7235:
	return asu64(R1);
}

static i64 mm_lib_createarraymode(u64 owner, i64 target, u64 dimexpr, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 k;
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7240;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7239;
L7240:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7239:
	R1 = 10;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = dimexpr;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7238;
L7238:
	return asi64(R1);
}

static i64 mm_lib_sameunit(u64 p, u64 q, u64 powner, u64 qowner) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = p;
	asu64(R2) = q;
	if (asu64(R1) != asu64(R2)) goto L7243;
	R1 = 1;
	goto L7241;
L7243:
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L7246;
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7245;
L7246:
	R1 = 0;
	goto L7241;
L7245:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L7248;
	R1 = 0;
	goto L7241;
L7248:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7250;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L7251;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7251;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7252;
	goto L7253;
L7250:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L7241;
	goto L7249;
L7251:
	R1 = 0;
	R2 = 0;
	asu64(R3) = q;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = mm_lib_sameunit(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7254;
	R1 = 0;
	R2 = 0;
	asu64(R3) = q;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = mm_lib_sameunit(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7254;
	R1 = 1;
	goto L7255;
L7254:
	R1 = 0;
L7255:
	goto L7241;
	goto L7249;
L7252:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L7257;
	asu64(R1) = powner;
	asu64(R2) = qowner;
	if (asu64(R1) != asu64(R2)) goto L7257;
	R1 = 1;
	goto L7241;
L7257:
	goto L7249;
L7253:
L7249:
	R1 = 0;
	goto L7241;
L7241:
	return asi64(R1);
}

static i64 mm_lib_createarraymodek(u64 owner, i64 target, i64 lower, i64 length, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 atype;
	i64 m;
	R1 = 10;
	atype = asi64(R1);
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7260;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7259;
L7260:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7259:
	asi64(R1) = atype;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7262;
	R1 = tou64("CREATEARRAYMODEK/TARGET NOT RESOLVED");
	mm_support_serror(asu64(R1));
L7262:
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = target;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7258;
L7258:
	return asi64(R1);
}

static u64 mm_lib_nextautotype() {
    u64 R1; 
	R1 = (u64)&mm_lib_nextautotype_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_autotypeno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_lib_nextautotype_str;
	goto L7263;
L7263:
	return asu64(R1);
}

static i64 mm_lib_createslicemode(u64 owner, i64 slicetype, i64 target, u64 dimexpr, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7266;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7265;
L7266:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7265:
	asi64(R1) = slicetype;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = dimexpr;
	if (!asu64(R1)) goto L7268;
	asu64(R1) = dimexpr;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L7267;
L7268:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L7267:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7264;
L7264:
	return asi64(R1);
}

static i64 mm_lib_createslicemodek(u64 owner, i64 target, i64 lower, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7271;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7270;
L7271:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7270:
	R1 = 11;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7269;
L7269:
	return asi64(R1);
}

static i64 mm_lib_createrefmode(u64 owner, i64 target, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 k;
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7274;
	R1 = 31;
	k = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L7277;
L7275:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7279;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = k;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = target;
	if (asi64(R1) != asi64(R2)) goto L7281;
	asi64(R1) = k;
	goto L7272;
L7281:
L7279:
	k += 1; if (k <= mm_decls_ntypes) goto L7275;
L7277:
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7273;
L7274:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7273:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	R2 = 7;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7272;
L7272:
	return asi64(R1);
}

static i64 mm_lib_createrefprocmode(u64 owner, u64 stproc, u64 paramlist, i64 kwd, i64 prettype, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mproc;
	asu64(R1) = stproc;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	mproc = asi64(R1);
	asu64(R1) = paramlist;
	asu64(R2) = stproc;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = prettype;
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 24;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = mproc;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7284;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7283;
L7284:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7283:
	asi64(R1) = mproc;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	R2 = 7;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7282;
L7282:
	return asi64(R1);
}

static void mm_lib_copyttvalues(i64 dest, i64 source) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttsigned;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsigned;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisshort;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisblock;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_lib_getdottedname(u64 p) {
    u64 R1, R2; 
	struct $B16 str2;
	u64 owner;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	goto L7288;
L7287:
	R1 = (u64)&mm_lib_getdottedname_str;
	R2 = (u64)&str2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
L7288:
	asu64(R1) = owner;
	if (!asu64(R1)) goto L7290;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7287;
L7290:
	R1 = (u64)&mm_lib_getdottedname_str;
	goto L7286;
L7286:
	return asu64(R1);
}

static u64 mm_lib_getavname(u64 owner, i64 id) {
    u64 R1, R2, R3; 
	u64 p;
	struct $B18 str;
	u64 name;
	asi64(R1) = id;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7293;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7293;
	R1 = tou64("Auto frame not in proc");
	mm_support_serror(asu64(R1));
L7293:
	asi64(R1) = id;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7295;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("av_");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_nextavindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7294;
L7295:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("sv_");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_nextsvindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7294:
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	asi64(R1) = id;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 168;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = p;
	goto L7291;
L7291:
	return asu64(R1);
}

static void mm_lib_unionstr_clear(u64 u) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = u;
	*tou64p(R2) = asu64(R1);
	return;
}

static void mm_lib_unionstr_append(u64 u, i64 c) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7299;
	R1 = tou64("Uflags overflow/a");
	mm_support_serror(asu64(R1));
L7299:
	asu64(R1) = u;
	R2 = 7;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asi64(R1) = c;
	asu64(R2) = u;
	asu64(R3) = u;
	R4 = 7;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mm_lib_unionstr_concat(u64 u, u64 v) {
    u64 R1, R2, R3, R4; 
	i64 ulen;
	i64 vlen;
	i64 i;
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	ulen = asi64(R1);
	asu64(R1) = v;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	vlen = asi64(R1);
	asi64(R1) = ulen;
	asi64(R2) = vlen;
	asi64(R1) += asi64(R2);
	R2 = 7;
	if (asi64(R1) <= asi64(R2)) goto L7302;
	R1 = tou64("Uflags overflow/c");
	mm_support_serror(asu64(R1));
L7302:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = vlen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7305;
L7303:
	asu64(R1) = v;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = u;
	asi64(R3) = i;
	asi64(R4) = ulen;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= vlen) goto L7303;
L7305:
	asi64(R1) = ulen;
	asi64(R2) = vlen;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static i64 mm_lib_unionstr_last(u64 u) {
    u64 R1, R2, R3; 
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7308;
	asu64(R1) = u;
	asu64(R2) = u;
	R3 = 7;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L7306;
L7308:
	R1 = 0;
	goto L7306;
L7306:
	return asi64(R1);
}

static void mm_lib_unionstr_copy(u64 u, u64 v) {
    u64 R1, R2, R3; 
	R1 = 8;
	asu64(R2) = v;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mm_lib_createrecordmode(u64 owner, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7312;
	asu64(R1) = owner;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	goto L7311;
L7312:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7311:
	R1 = 8;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7310;
L7310:
	return asi64(R1);
}

static i64 mm_lib_createtuplemode(u64 owner, u64 elements, i64 elementslen, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	i64 i;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7315;
	asu64(R1) = owner;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	goto L7314;
L7315:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7314:
	R1 = 28;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = elementslen;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = elementslen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&mm_decls_ttmult;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = elementslen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7318;
L7316:
	R1 = (u64)&mm_decls_ttmult;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = i;
	R1 += (i64)R2*4-4;
	asu64(R2) = elements;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	i += 1; if (i <= elementslen) goto L7316;
L7318:
	asi64(R1) = m;
	goto L7313;
L7313:
	return asi64(R1);
}

static u64 mm_lib_strexpr(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mm_lib_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = mm_lib_exprstr;
	mm_lib_jevalx2(asu64(R2), asu64(R1));
	asu64(R1) = mm_lib_exprstr;
	goto L7319;
L7319:
	return asu64(R1);
}

static void mm_lib_jevalx2(u64 dest, u64 p) {
    u64 R1; 
	asu64(R1) = dest;
	mm_lib_jdest = asu64(R1);
	asu64(R1) = p;
	mm_lib_jevalx(asu64(R1));
	return;
}

static void mm_lib_jevalx(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 a;
	u64 b;
	struct $B46 str;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7323;
	goto L7321;
L7323:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7325;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7326;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L7327;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L7327;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L7329;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7330;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7331;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L7331;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L7331;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7331;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7332;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7333;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L7334;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7335;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L7336;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L7337;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L7338;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L7338;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L7339;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L7340;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7341;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L7342;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7343;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7344;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7345;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L7346;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7347;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L7348;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L7348;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L7349;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L7350;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L7351;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L7352;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7353;
	goto L7354;
L7325:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7356;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7356;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7356;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7356;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7358;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7358;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7359;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7359;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7360;
	goto L7361;
L7356:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L7355;
L7357:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7355;
L7358:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L7355;
L7359:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7355;
L7360:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7363;
	asu64(R1) = p;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7363;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 250;
	if (asi64(R1) <= asi64(R2)) goto L7365;
	R1 = tou64("LONGSTR)");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7364;
L7365:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
L7364:
	R1 = tou64("\"");
	mm_lib_jadditem(asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("\"");
	mm_lib_jadditem(asu64(R1));
	goto L7321;
	goto L7362;
L7363:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L7362:
	goto L7355;
L7361:
	R1 = tou64("<EVAL/CONST PROBABLY VOID>");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L7355:
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7326:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7327:
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7328:
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L7367;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	goto L7366;
L7367:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
L7366:
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7329:
	R1 = (u64)&mm_tables_propnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7330:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	goto L7369;
L7368:
	asu64(R1) = q;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L7372;
	R1 = tou64(",");
	mm_lib_jadditem(asu64(R1));
L7372:
L7369:
	asu64(R1) = q;
	if (asu64(R1)) goto L7368;
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7331:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L7375;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L7374;
L7375:
	R1 = tou64(".");
	mm_lib_jadditem(asu64(R1));
L7374:
	R1 = tou64("[");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("]");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7332:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(".");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L7324;
L7333:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	q = asu64(R1);
	goto L7377;
L7376:
	asu64(R1) = q;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L7380;
	R1 = tou64(",");
	mm_lib_jadditem(asu64(R1));
L7380:
L7377:
	asu64(R1) = q;
	if (asu64(R1)) goto L7376;
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7334:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("..");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7335:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":=");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L7324;
L7336:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("|");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("|");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7337:
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7338:
	R1 = 1;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L7382;
	R1 = tou64("@");
	mm_lib_jadditem(asu64(R1));
L7382:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7339:
	R1 = tou64("shorten(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7340:
	R1 = tou64("cast(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7341:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L7384;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jevalx(asu64(R1));
	goto L7383;
L7384:
	R1 = tou64("-");
	mm_lib_jaddstr(asu64(R1));
L7383:
	goto L7324;
L7342:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("^");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7343:
	R1 = tou64("<JBLOCK>");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7344:
	R1 = tou64("<nullunit>");
	mm_lib_jaddstr(asu64(R1));
	goto L7324;
L7345:
	R1 = tou64("&");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L7386;
	R1 = tou64("+");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_lib_jdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
L7386:
	goto L7324;
L7346:
	R1 = tou64("&.");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L7324;
L7347:
	R1 = tou64("TYPESTR(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7324;
L7348:
	R1 = tou64("$");
	mm_lib_jaddstr(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	mm_lib_jaddstr(asu64(R1));
	goto L7324;
L7349:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(".");
	mm_lib_jaddstr(asu64(R1));
	R1 = (u64)&mm_tables_bitfieldnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lib_jaddstr(asu64(R1));
	goto L7324;
L7350:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L7324;
L7351:
	R1 = (u64)&mm_tables_sysfnnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	mm_lib_jaddstr(asu64(R1));
	R1 = tou64("(");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L7388;
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
L7388:
	R1 = tou64(")");
	mm_lib_jaddstr(asu64(R1));
	goto L7324;
L7352:
	R1 = tou64("incr ");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L7324;
L7353:
	R1 = tou64("strinclude ");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L7324;
L7354:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("CAN'T DO JEVAL");
	mm_support_gerror(asu64(R2), asu64(R1));
L7324:
L7321:
	return;
}

static void mm_lib_jadditem(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = mm_lib_jdest;
	mm_support_gs_additem(asu64(R2), asu64(R1));
	return;
}

static void mm_lib_jaddstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = mm_lib_jdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static u64 mm_lib_strmode(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lib_strmode_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_lib_strmode_str;
	goto L7391;
L7391:
	return asu64(R1);
}

static u64 mm_lib_strmode2(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lib_strmode2_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_lib_strmode2_str;
	goto L7392;
L7392:
	return asu64(R1);
}

static void mm_lib_istrmode(i64 m, i64 expand, u64 dest) {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	u64 d;
	u64 q;
	i64 needcomma;
	i64 i;
	i64 target;
	i64 mbase;
	i64 n;
	struct $B3 sxx;
	u64 xx;
	u64 sdim;
	struct $B5 strdim;
	u64 prefix;
	struct $B18 tn;
	R1 = (u64)&sxx;
	xx = asu64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7395;
	R1 = tou64("*");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	(R1_B18) = *(struct $B18*)(((i64)R1+(i64)R2*32));
	tn = (R1_B18);
	R1 = (u64)&tn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7397;
	R1 = (u64)&tn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7397:
	R1 = (u64)&tn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7393;
L7395:
	asi64(R1) = m;
	R2 = 31;
	if (asi64(R1) >= asi64(R2)) goto L7399;
	asi64(R1) = m;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7399;
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7393;
L7399:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	mbase = asi64(R2);
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7401;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7402;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7403;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7404;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7405;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L7406;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7407;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7408;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7409;
	goto L7410;
L7401:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7412;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7412;
	asi64(R1) = target;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7411;
L7412:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L7411:
	goto L7400;
L7402:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L7414;
	R1 = (u64)&strdim;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	mm_support_gs_copytostr(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("@[#<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&strdim;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7413;
L7414:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	if (!asi32(R1)) goto L7416;
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7418;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7417;
L7418:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#..#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7417:
	goto L7415;
L7416:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7420;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[]");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L7419;
L7420:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#:]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7419:
L7415:
L7413:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L7400;
L7403:
	R1 = (u64)&mm_tables_stdnames;
	asi64(R2) = mbase;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	prefix = asu64(R1);
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L7422;
	R1 = (u64)&strdim;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	mm_support_gs_copytostr(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("@#[#:]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = prefix;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&strdim;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7421;
L7422:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7424;
	asu64(R1) = prefix;
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("[]");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7423;
L7424:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#[#:]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = prefix;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7423:
L7421:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L7400;
L7404:
	asi64(R1) = expand;
	if (asi64(R1)) goto L7426;
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7393;
L7426:
	R1 = tou64("");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = expand;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7428;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7428:
	R1 = tou64("(");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L7432;
L7429:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L7434;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7434:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7432:
	asu64(R1) = q;
	if (asu64(R1)) goto L7429;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7400;
L7405:
	R1 = tou64("void");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7400;
L7406:
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7400;
L7407:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = tou64("proc(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	goto L7436;
L7435:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L7439;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7439:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7436:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7435;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7441;
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = d;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L7441:
	goto L7400;
L7408:
	R1 = tou64("Tuple(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7444;
L7442:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_ttmult;
	asi64(R4) = m;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asi64(R4) = i;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4-4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = n;
	if (asi64(R1) >= asi64(R2)) goto L7446;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7446:
	i += 1; if (i <= n) goto L7442;
L7444:
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7400;
L7409:
	R1 = tou64("bitfield");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7400;
L7410:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 31;
	if (asi64(R1) >= asi64(R2)) goto L7448;
	R1 = tou64("Alias for:");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L7447;
L7448:
	msysc_m$print_startcon();
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("NEWSTRMODE");
	mm_support_mcerror(asu64(R1));
L7447:
L7400:
L7393:
	return;
}

static void mm_lib_addtoproclist(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_proclist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7451;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_proclistx = asu64(R2);
	mm_decls_proclist = asu64(R1);
	goto L7450;
L7451:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_proclistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_proclistx = asu64(R1);
L7450:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lib_addstatic(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_staticlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7454;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_staticlistx = asu64(R2);
	mm_decls_staticlist = asu64(R1);
	goto L7453;
L7454:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_staticlistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_staticlistx = asu64(R1);
L7453:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lib_addexpconst(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_constlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7457;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_constlistx = asu64(R2);
	mm_decls_constlist = asu64(R1);
	goto L7456;
L7457:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_constlistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_constlistx = asu64(R1);
L7456:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_typename(i64 m) {
    u64 R1, R2; 
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7460;
	R1 = (u64)&mm_decls_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L7458;
L7460:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7458;
L7458:
	return asu64(R1);
}

static u64 mm_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = (u64)&mm_decls_nunits;
	(*toi64p(R1)) += 1;
	R1 = 65;
	R2 = (u64)&mm_decls_nunitsmem;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&mm_lib_remainingunits;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) -= 1; asi64(R1) = asi64(R2);
	if (!asi64(R1)) goto L7463;
	asu64(R1) = mm_lib_unitheapptr;
	p = asu64(R1);
	R1 = (u64)&mm_lib_unitheapptr;
	(*tou64p(R1)) += 65;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 58;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L7461;
L7463:
	R1 = 2129920;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	mm_lib_unitheapptr = asu64(R2);
	p = asu64(R1);
	R1 = 2129920;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 32767;
	mm_lib_remainingunits = asi64(R1);
	R1 = (u64)&mm_lib_unitheapptr;
	(*tou64p(R1)) += 65;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 58;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L7461;
L7461:
	return asu64(R1);
}

static u64 mm_lib_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mm_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 78;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L7466;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7468;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7467;
L7468:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7467:
L7466:
	asu64(R1) = p;
	goto L7464;
L7464:
	return asu64(R1);
}

static u64 mm_lib_createnewmoduledef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3; 
	asi64(R1) = id;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	goto L7469;
L7469:
	return asu64(R1);
}

static u64 mm_lib_duplunit(u64 p, i64 lineno) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 q;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7472;
	R1 = 0;
	goto L7470;
L7472:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = q;
	*(struct $B60*)(R2) = (R1_B60);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7475;
L7473:
	R1 = 0;
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= av_1) goto L7473;
L7475:
	asu64(R1) = q;
	goto L7470;
L7470:
	return asu64(R1);
}

static i64 mm_lib_isconstunit(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L7476;
L7476:
	return asi64(R1);
}

static void mm_lib_getownername(u64 d, u64 dest) {
    u64 R1, R2; 
	u64 owner;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L7480;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7479;
L7480:
	goto L7477;
L7479:
	asu64(R1) = dest;
	asu64(R2) = owner;
	mm_lib_getownername(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7477:
	return;
}

static i64 mm_lib_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7483;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7484;
	goto L7485;
L7483:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	goto L7481;
	goto L7482;
L7484:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 166;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7487;
	R1 = 8;
	a = asi64(R1);
L7487:
	asi64(R1) = a;
	goto L7481;
	goto L7482;
L7485:
	R1 = (u64)&mm_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7489;
	R1 = 8;
	goto L7481;
L7489:
L7482:
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7491;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7491;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7491;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7491;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7492;
	goto L7493;
L7491:
	asi64(R1) = a;
	goto L7481;
	goto L7490;
L7492:
	R1 = 8;
	goto L7481;
	goto L7490;
L7493:
L7490:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("GETALIGN SIZE NOT 1248");
	mm_support_gerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L7481;
L7481:
	return asi64(R1);
}

static void mm_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7496;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L7495;
L7496:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7495:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static i64 mm_lib_storemode(u64 owner, i64 m, u64 pmode) {
    u64 R1, R2, R3; 
	u64 r;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7499;
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asi64(R1) = m;
	goto L7497;
L7499:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7501;
	asu64(R1) = owner;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = pmode;
	asu64(R2) = r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7503;
	R1 = tou64("PMODE=NIL");
	mm_support_serror(asu64(R1));
L7503:
	asi64(R1) = m;
	goto L7497;
L7501:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	r = asu64(R1);
	asu64(R1) = owner;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = pmode;
	asu64(R2) = r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	goto L7497;
L7497:
	return asi64(R1);
}

static i64 mm_lib_gettypebase(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7506;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7506;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7506;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7507;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7507;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7507;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7508;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7509;
	goto L7510;
L7506:
	R1 = 3;
	goto L7505;
L7507:
	R1 = 3;
	goto L7505;
L7508:
	R1 = 1;
	goto L7505;
L7509:
	R1 = 5;
	goto L7505;
L7510:
	asi64(R1) = m;
L7505:
	goto L7504;
L7504:
	return asi64(R1);
}

static void mm_lib_writegsfile(u64 filename, u64 d) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	return;
}

static void mm_lib_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7514;
	msysc_m$print_startcon();
	R1 = tou64("ATL ERROR");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7512;
L7514:
L7515:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7518;
	goto L7516;
L7518:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L7515;
L7516:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7512:
	return;
}

static u64 mm_lib_getprocretmodes(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7521;
	R1 = 0;
	R2 = tou64("multass/need multfn");
	mm_support_txerror(asu64(R2), asu64(R1));
L7521:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7523;
	goto L7524;
L7523:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7522;
L7524:
	R1 = (u64)&mm_decls_ttnamedef;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L7522:
	goto L7519;
L7519:
	return asu64(R1);
}

static i64 mm_lib_getpclmode(i64 t) {
    u64 R1, R2, R3; 
	i64 u;
	R1 = (u64)&mm_tables_stdpcl;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7527;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = t;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7529;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7530;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7531;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7532;
	goto L7533;
L7529:
	R1 = 6;
	u = asi64(R1);
	goto L7528;
L7530:
	R1 = 5;
	u = asi64(R1);
	goto L7528;
L7531:
	R1 = 4;
	u = asi64(R1);
	goto L7528;
L7532:
	R1 = 3;
	u = asi64(R1);
	goto L7528;
L7533:
L7528:
L7527:
	asi64(R1) = u;
	goto L7525;
L7525:
	return asi64(R1);
}

static void mm_libsources_loadbuiltins() {
    u64 R1, R2, R3; 
	u64 pf;
	u64 filename;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7537;
L7535:
	R1 = (u64)&mm_libsources_syslibnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	filename = asu64(R1);
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L7535;
L7537:
	return;
}

static u64 mm_modules_loadsp(u64 filename, i64 mainsub) {
    u64 R1, R2, R3, R4, R5; 
	u64 sp;
	struct $B45 modnames;
	struct $B45 aliases;
	struct $B45 paths;
	struct $B45 subnames;
	struct $B45 subpaths;
	i64 nmods;
	i64 nsubs;
	i64 hdrcode;
	i64 firstmod;
	i64 lastmod;
	i64 issyslib;
	u64 pm;
	u64 d;
	u64 stalias;
	u64 path;
	u64 name;
	u64 ext;
	u64 file2;
	u8 proj;
	u8 sepheader;
	i64 i;
	i64 j;
	R1 = 0;
	nmods = asi64(R1);
	R1 = 0;
	nsubs = asi64(R1);
	R1 = 0;
	issyslib = asi64(R1);
	R1 = 0;
	proj = asu8(R1);
	R1 = 0;
	sepheader = asu8(R1);
	asu64(R1) = mm_cli_syslibname;
	asu64(R2) = filename;
	asu64(R2) = mlib_extractbasefile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7540;
	R1 = 1;
	issyslib = asi64(R1);
L7540:
	R1 = 0;
	asu64(R2) = filename;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	ext = asu64(R1);
	R1 = tou64("m");
	asu64(R2) = ext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7542;
	asu64(R1) = ext;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_modules_fileext = asu64(R1);
L7542:
	asi64(R1) = issyslib;
	asu64(R2) = filename;
	asu64(R1) = mm_modules_loadmodule(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7544;
	R1 = tou64("");
	asu64(R2) = filename;
	R3 = tou64("Can't load lead module: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7544:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	path = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7547;
L7545:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7549;
	R1 = tou64("");
	asu64(R2) = sp;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Subprog already loaded: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7549:
	i += 1; if (i <= mm_decls_nsubprogs) goto L7545;
L7547:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lex_startlex(asu64(R1));
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 115;
	if (asi64(R1) != asi64(R2)) goto L7551;
	R1 = 1;
	proj = asu8(R1);
	R1 = 41;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
L7551:
L7552:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L7555;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7556;
	goto L7557;
L7555:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	hdrcode = asi64(R1);
	mm_lex_lex();
	asi64(R1) = hdrcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7559;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7560;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7561;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7562;
	goto L7563;
L7559:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7565;
	asi64(R1) = nmods;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L7567;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many modules in header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7567:
	asu64(R1) = name;
	R2 = (u64)&modnames;
	R3 = (u64)&nmods;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = path;
	R2 = (u64)&paths;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&aliases;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L7565:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L7569;
	R1 = tou64("as");
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7569;
	mm_lex_lex();
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L7571;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stalias = asu64(R1);
	mm_lex_lex();
	goto L7570;
L7571:
	R1 = 65;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	stalias = asu64(R1);
L7570:
	asu64(R1) = stalias;
	R2 = (u64)&aliases;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L7569:
	goto L7558;
L7560:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	asi64(R1) = nsubs;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L7573;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many imports in header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7573:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	R3 = (u64)&nsubs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = path;
	R2 = (u64)&subpaths;
	asi64(R3) = nsubs;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L7558;
L7561:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_modules_addlib(asu64(R1));
	goto L7558;
L7562:
	R1 = 65;
	mm_parse_checksymbol(asi64(R1));
	asu8(R1) = mm_decls_loadedfromma;
	if (asu8(R1)) goto L7575;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	path = asu64(R1);
L7575:
	goto L7558;
L7563:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Hdr cmd not ready");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7558:
	mm_lex_lex();
	goto L7554;
L7556:
	goto L7554;
L7557:
	goto L7553;
L7554:
	goto L7552;
L7553:
	asu8(R1) = proj;
	if (!asu8(R1)) goto L7577;
	R1 = 0;
	R2 = 0;
	R3 = 115;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L7577:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L7579;
	R1 = 1;
	sepheader = asu8(R1);
L7579:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nsubs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7582;
L7580:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7584;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Importing self");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7584:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&subnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	R4 = (u64)&subpaths;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R2) = mm_modules_getmodulefilename(asu64(R4), asu64(R3), asi64(R2));
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
	i += 1; if (i <= nsubs) goto L7580;
L7582:
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 30;
	if (asi64(R1) < asi64(R2)) goto L7586;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many subprogs");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7586:
	R1 = 16;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	sp = asu64(R1);
	asu64(R1) = sp;
	R2 = (u64)&mm_decls_subprogs;
	R3 = (u64)&mm_decls_nsubprogs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = sp;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mainsub;
	if (!asi64(R1)) goto L7588;
	asi64(R1) = mm_decls_nsubprogs;
	mm_decls_mainsubprogno = asi64(R1);
L7588:
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	asi64(R1) += asi64(R2);
	firstmod = asi64(R1);
	asi64(R1) = firstmod;
	asi64(R2) = nmods;
	asi64(R1) += asi64(R2);
	lastmod = asi64(R1);
	asi64(R1) = lastmod;
	R2 = 300;
	if (asi64(R1) <= asi64(R2)) goto L7590;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many modules");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7590:
	asi64(R1) = lastmod;
	mm_decls_nmodules = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 18;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 1;
	asu64(R2) = pm;
	R3 = 23;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = firstmod;
	asu64(R2) = pm;
	R3 = 16;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = d;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = (u64)&mm_decls_moduletosub;
	asi64(R3) = firstmod;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = sp;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = lastmod;
	asu64(R2) = sp;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = issyslib;
	asu64(R2) = sp;
	R3 = 14;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = firstmod;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nmods;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7593;
L7591:
	asi64(R1) = issyslib;
	asi64(R2) = issyslib;
	R3 = (u64)&modnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	R4 = (u64)&paths;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R2) = mm_modules_getmodulefilename(asu64(R4), asu64(R3), asi64(R2));
	asu64(R1) = mm_modules_loadmodule(asu64(R2), asi64(R1));
	pm = asu64(R1);
	R1 = (u64)&aliases;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	stalias = asu64(R1);
	asu64(R1) = pm;
	if (asu64(R1)) goto L7595;
	R1 = tou64("");
	R2 = (u64)&modnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = tou64("Can't load: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7595:
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = firstmod;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 18;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = stalias;
	if (!asu64(R1)) goto L7597;
	R1 = 15;
	asu64(R2) = stalias;
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	asu64(R2) = pm;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_decls_stprogram;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pm;
	R3 = 40;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = pm;
	R3 = 40;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7597:
	asi64(R1) = firstmod;
	asi64(R2) = i;
	asi64(R1) += asi64(R2);
	R2 = R1;
	asu64(R3) = pm;
	R4 = 16;
	*toi16p(((i64)R3+(i64)R4)) = asi16(R2);
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = d;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = (u64)&mm_decls_moduletosub;
	asu64(R3) = d;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7600;
L7598:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7602;
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl mod name:");
	mm_support_serror_s(asu64(R2), asu64(R1));
L7602:
	j += 1; if (j <= mm_decls_nmodules) goto L7598;
L7600:
	i += 1; if (i <= nmods) goto L7591;
L7593:
	asu64(R1) = sp;
	goto L7538;
L7538:
	return asu64(R1);
}

static u64 mm_modules_loadmodule(u64 filespec, i64 issyslib) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 pf;
	asi64(R1) = issyslib;
	asu64(R2) = filespec;
	asu64(R1) = mm_modules_loadsourcefile(asu64(R2), asi64(R1));
	pf = asu64(R1);
	asu64(R1) = pf;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7605;
	R1 = 0;
	goto L7603;
L7605:
	R1 = 64;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pf;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	asu64(R2) = pm;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	R2 = 64;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 20;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = issyslib;
	asu64(R2) = pm;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	goto L7603;
L7603:
	return asu64(R1);
}

static u64 mm_modules_loadsourcefile(u64 filespec, i64 issyslib) {
    u64 R1, R2, R3; 
	u64 pf;
	u64 s;
	u64 filename;
	struct $B15 str;
	i64 i;
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractfile(asu64(R1));
	filename = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7609;
L7607:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = filename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7611;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = issyslib;
	if (asi64(R1) != asi64(R2)) goto L7611;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L7606;
L7611:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L7607;
L7609:
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = issyslib;
	asu64(R2) = pf;
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	asu64(R2) = pf;
	R3 = 64;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L7613;
	R1 = 0;
	goto L7606;
L7613:
	asu64(R1) = s;
	asu64(R2) = pf;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	asu64(R2) = pf;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7615;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7615:
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pf;
	goto L7606;
L7606:
	return asu64(R1);
}

static u64 mm_modules_getmodulefilename(u64 path, u64 name, i64 issyslib) {
    u64 R1, R2; 
	asu64(R1) = path;
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = name;
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = issyslib;
	if (!asi64(R1)) goto L7618;
	R1 = tou64("m");
	goto L7617;
L7618:
	asu64(R1) = mm_modules_fileext;
L7617:
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_modules_getmodulefilename_str;
	goto L7616;
L7616:
	return asu64(R1);
}

static void mm_modules_addlib(u64 libname) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7622;
L7620:
	asu64(R1) = libname;
	R2 = (u64)&mm_decls_libfiles;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7624;
	goto L7619;
L7624:
	i += 1; if (i <= mm_decls_nlibfiles) goto L7620;
L7622:
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L7626;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many libs");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7626:
	asu64(R1) = libname;
	R2 = (u64)&mm_decls_libfiles;
	R3 = (u64)&mm_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L7619:
	return;
}

static void mm_modules_loadsyslib() {
    u64 R1, R2, R3; 
	struct $B15 str;
	u64 name;
	u8 frunpcl;
	u8 fgenpcl;
	asi64(R1) = mm_decls_passlevel;
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	frunpcl = asu8(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	fgenpcl = asu8(R1);
	asu8(R1) = mm_decls_dointlibs;
	if (!asu8(R1)) goto L7629;
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L7628;
L7629:
	R1 = tou64("C:/mx/");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L7628:
	asu8(R1) = mm_decls_msyslevel;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7631;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7632;
	goto L7633;
L7631:
	goto L7627;
	goto L7630;
L7632:
	R1 = 0;
	if (asu16(R1)) goto L7636;
	asi64(R1) = mwindows_os_iswindows();
	if (asi64(R1)) goto L7635;
L7636:
	R1 = tou64("msysminc");
	goto L7634;
L7635:
	R1 = tou64("msysmin");
L7634:
	name = asu64(R1);
	goto L7630;
L7633:
	asi64(R1) = mwindows_os_iswindows();
	if (!asi64(R1)) goto L7638;
	asu8(R1) = mm_decls_clinux;
	if (asu8(R1)) goto L7638;
	R1 = 0;
	if (!asu16(R1)) goto L7640;
	R1 = tou64("msyswinc");
	name = asu64(R1);
	goto L7639;
L7640:
	asu8(R1) = frunpcl;
	if (asu8(R1)) goto L7642;
	asu8(R1) = fgenpcl;
	if (!asu8(R1)) goto L7641;
L7642:
	R1 = tou64("msyswini");
	name = asu64(R1);
	goto L7639;
L7641:
	R1 = tou64("msyswin");
	name = asu64(R1);
L7639:
	goto L7637;
L7638:
	R1 = tou64("msyslinc");
	name = asu64(R1);
L7637:
L7630:
	asu64(R1) = name;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_cli_syslibname = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L7644;
	msysc_m$print_startcon();
	R1 = tou64("SYSLIBNAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_cli_syslibname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7644:
	R1 = tou64(".m");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
L7627:
	return;
}

static void mm_modules_loadproject(u64 file) {
    u64 R1, R2, R3; 
	struct $B15 str;
	u64 file2;
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	asu8(R1) = mm_decls_dointlibs;
	if (!asu8(R1)) goto L7647;
	mm_libsources_loadbuiltins();
L7647:
	mm_modules_loadsyslib();
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L7649;
	R1 = tou64("ma");
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file2 = asu64(R1);
	asu64(R1) = file2;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L7651;
	asu64(R1) = file2;
	file = asu64(R1);
L7651:
L7649:
	R1 = tou64("ma");
	R2 = 0;
	asu64(R3) = file;
	asu64(R2) = mlib_extractext(asu64(R3), asi64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7653;
	msysc_m$print_startcon();
	R1 = tou64("LOADING FROM MA FILE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = file;
	mm_modules_loadmafile(asu64(R2), asu64(R1));
	R1 = 1;
	mm_decls_loadedfromma = asu8(R1);
	R1 = tou64("m");
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	file = asu64(R1);
L7653:
	R1 = 1;
	asu64(R2) = file;
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
	R1 = tou64("msvcrt");
	mm_modules_addlib(asu64(R1));
	asi64(R1) = mwindows_os_iswindows();
	if (!asi64(R1)) goto L7655;
	R1 = tou64("user32");
	mm_modules_addlib(asu64(R1));
	R1 = tou64("gdi32");
	mm_modules_addlib(asu64(R1));
	R1 = tou64("kernel32");
	mm_modules_addlib(asu64(R1));
L7655:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_loadtime = asi64(R1);
	return;
}

static u64 mm_modules_readfileline(u64 s) {
    u64 R1, R2, R3; 
	struct $B96 str;
	u64 t;
	i64 n;
	i64 c;
	R1 = (u64)&str;
	t = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L7657:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7659;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7660;
	goto L7661;
L7659:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	goto L7658;
	goto L7657;
L7660:
	goto L7658;
	goto L7657;
L7661:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L7663;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L7663:
	goto L7657;
L7658:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$read_strline(asu64(R1));
	asu64(R1) = s;
	goto L7656;
L7656:
	return asu64(R1);
}

static u64 mm_modules_findnextlineheader(u64 s) {
    u64 R1, R2; 
	i64 c;
L7665:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7667;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7668;
	goto L7669;
L7667:
	R1 = 0;
	goto L7664;
	goto L7665;
L7668:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L7671;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L7671;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L7671;
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	goto L7664;
L7671:
	goto L7665;
L7669:
	goto L7665;
	R1 = 0;
	goto L7664;
L7664:
	return asu64(R1);
}

static void mm_modules_loadmafile(u64 filespec, u64 builtinstr) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	struct $B5 name;
	i64 sys;
	i64 support;
	u64 pf;
	i64 i;
	asu64(R1) = filespec;
	if (!asu64(R1)) goto L7674;
	asu64(R1) = filespec;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7676;
	R1 = tou64("");
	asu64(R2) = filespec;
	R3 = tou64("Can't find MA file ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7676:
	goto L7673;
L7674:
	asu64(R1) = builtinstr;
	s = asu64(R1);
L7673:
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R1) = mm_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("ma");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7678;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA: bad header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7678:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asu64(R1) = s;
	asu64(R1) = mm_modules_findnextlineheader(asu64(R1));
	s = asu64(R1);
L7679:
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7682;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Unexpected EOF in MA file");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
	goto L7680;
L7682:
	asu64(R1) = s;
	asu64(R1) = mm_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	sys = asi64(R1);
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	support = asi64(R1);
	R1 = tou64("end");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7684;
	goto L7680;
L7684:
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 300;
	if (asi64(R1) < asi64(R2)) goto L7686;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many files in MA");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7686:
	asu64(R1) = s;
	asu64(R1) = mm_modules_findnextlineheader(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7688;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA error");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7688:
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	R1 = (u64)&name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = R1;
	asu64(R3) = pf;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = pf;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&name;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 3;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pf;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = s;
	asu64(R2) = pf;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64("");
	R2 = R1;
	asu64(R3) = pf;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = pf;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = sys;
	asu64(R2) = pf;
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = support;
	asu64(R2) = pf;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = t;
	s = asu64(R1);
	goto L7679;
L7680:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7691;
L7689:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	R1 = 0;
	asu64(R2) = pf;
	R3 = 32;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pf;
	R4 = 48;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= mm_decls_nsourcefiles) goto L7689;
L7691:
	return;
}

static void mm_name_rx_typetable() {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 31;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L7695;
L7693:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7697;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 144;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7699;
	asu64(R1) = d;
	mm_name_do_baseclass(asu64(R1));
L7699:
L7697:
	i += 1; if (i <= mm_decls_ntypes) goto L7693;
L7695:
	return;
}

static void mm_name_rx_unit(u64 owner, u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	u64 a;
	u64 b;
	i64 n;
	i64 oldnoexpand;
	i64 oldnoassem;
	i64 oldtag;
	i64 useparams;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 4: goto L7704;
	case 5: case 6: case 7: case 8: case 10: case 11: case 12: case 13: case 14: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 27: case 28: case 29: case 30: case 31: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: goto L7703;
	case 9: goto L7744;
	case 15: case 16: goto L7727;
	case 17: goto L7736;
	case 18: goto L7732;
	case 26: goto L7707;
	case 32: goto L7709;
	case 49: goto L7708;
	default: goto L7703;
    };
// SWITCH
L7704:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_resolvename(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7706;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L7706;
	asi64(R1) = mm_name_noexpand;
	if (asi64(R1)) goto L7706;
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
L7706:
	goto L7701;
L7707:
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	goto L7701;
L7708:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_resolvedot(asu64(R2), asu64(R1));
	goto L7701;
L7709:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	oldtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7711;
	asi64(R1) = mm_name_noexpand;
	oldnoexpand = asi64(R1);
	R1 = 1;
	mm_name_noexpand = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldnoexpand;
	mm_name_noexpand = asi64(R1);
	goto L7710;
L7711:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L7710:
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unitlist(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7713;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7715;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7716;
	goto L7717;
L7715:
	R1 = 58;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7719;
	asu64(R1) = b;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L7721;
L7720:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L7721:
	asu64(R1) = b;
	if (asu64(R1)) goto L7720;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L7719:
	goto L7714;
L7716:
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7724;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	b = asu64(R1);
	R1 = 0;
	useparams = asi64(R1);
	goto L7723;
L7724:
	R1 = 0;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	useparams = asi64(R1);
L7723:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
	asi64(R1) = useparams;
	if (!asi64(R1)) goto L7726;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7726;
	asi64(R1) = oldtag;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7726:
	goto L7714;
L7717:
L7714:
L7713:
	goto L7701;
L7727:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7729;
	R1 = 18;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L7729:
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7731;
	R1 = 18;
	asu64(R2) = b;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L7731:
	goto L7701;
L7732:
// mm_name.rx_unit.doistruel:
L7733:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7735;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L7735:
	goto L7701;
L7736:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7738;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7739;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7740;
	goto L7741;
L7738:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	R1 = 18;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L7733;
	goto L7737;
L7739:
	R1 = 19;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L7737;
L7740:
	R1 = 18;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L7737;
L7741:
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7743;
	R1 = 19;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L7743:
L7737:
	goto L7701;
L7744:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_resolvename(asu64(R2), asu64(R1));
	asi64(R1) = mm_name_noexpand;
	if (asi64(R1)) goto L7746;
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_name_noassem;
	oldnoassem = asi64(R1);
	R1 = 1;
	mm_name_noassem = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldnoassem;
	mm_name_noassem = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
L7746:
	goto L7701;
L7703:
// mm_name.rx_unit.doabc:
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7750;
L7748:
	asu64(R1) = p;
	R2 = 16;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = owner;
	mm_name_rx_unitlist(asu64(R2), asu64(R1));
	i += 1; if (i <= av_1) goto L7748;
L7750:
L7701:
	return;
}

static i64 mm_name_rx_module(i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	mm_decls_currmoduleno = asi64(R1);
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_decls_stprogram;
	mm_name_rx_passdef(asu64(R2), asu64(R1));
	R1 = 1;
	goto L7751;
L7751:
	return asi64(R1);
}

static void mm_name_rx_deflist(u64 owner, u64 p) {
    u64 R1, R2; 
	u64 pstart;
	asu64(R1) = p;
	pstart = asu64(R1);
	goto L7754;
L7753:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_passdef(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7754:
	asu64(R1) = p;
	if (asu64(R1)) goto L7753;
	return;
}

static void mm_name_rx_passdef(u64 owner, u64 p) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7758;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7758;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7759;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7760;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7761;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7761;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7761;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7761;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7762;
	goto L7763;
L7758:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L7757;
L7759:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	asu64(R1) = p;
	mm_name_currstproc = asu64(R1);
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = 0;
	mm_name_currstproc = asu64(R1);
	goto L7757;
L7760:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L7757;
L7761:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7765;
	asu64(R1) = p;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L7765:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7767;
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L7767:
	goto L7757;
L7762:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L7757;
L7763:
L7757:
	return;
}

static void mm_name_rx_unitlist(u64 owner, u64 p) {
    u64 R1, R2; 
	goto L7770;
L7769:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7770:
	asu64(R1) = p;
	if (asu64(R1)) goto L7769;
	return;
}

static u64 mm_name_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod) {
    u64 R1, R2, R3, R4; 
	i64 extcount;
	i64 subprogno;
	u64 p;
	u64 q;
	u64 powner;
	u64 extdef;
	u64 moddef;
	struct $B1 ambiglist;
	i64 i;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7774;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L7778;
L7775:
	asu64(R1) = q;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stnewname;
	if (asu64(R1) != asu64(R2)) goto L7780;
	asu64(R1) = q;
	goto L7772;
L7780:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7778:
	asu64(R1) = q;
	if (asu64(R1)) goto L7775;
L7774:
	asu64(R1) = stnewname;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = moduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	R1 = 0;
	extcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	moddef = asu64(R2);
	extdef = asu64(R1);
	goto L7784;
L7781:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	powner = asu64(R1);
	asu64(R1) = powner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7786;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7787;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7788;
	goto L7789;
L7786:
	asu64(R1) = powner;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = moduleno;
	if (asi64(R1) != asi64(R2)) goto L7791;
	asu64(R1) = p;
	goto L7772;
	goto L7790;
L7791:
	asu64(R1) = p;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7792;
	asu64(R1) = powner;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L7795;
	asu64(R1) = p;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7795;
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7794;
L7795:
	R1 = (u64)&extcount;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	extdef = asu64(R1);
	asi64(R1) = extcount;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L7797;
	asu64(R1) = extdef;
	R2 = (u64)&ambiglist;
	asi64(R3) = extcount;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L7797:
L7794:
L7792:
L7790:
	goto L7785;
L7787:
	asu64(R1) = powner;
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L7800;
	asu64(R1) = powner;
	asu64(R2) = owner;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L7799;
L7800:
	asu64(R1) = p;
	goto L7772;
L7799:
	goto L7785;
L7788:
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7802;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7802;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7803;
	goto L7804;
L7802:
	asi64(R1) = subprogno;
	R2 = (u64)&mm_decls_moduletosub;
	asu64(R3) = p;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L7806;
	asu64(R1) = p;
	moddef = asu64(R1);
	goto L7805;
L7806:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7809;
L7807:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7811;
	R1 = 1;
	asu64(R2) = p;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 10;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	moddef = asu64(R1);
	goto L7809;
L7811:
	i += 1; if (i <= mm_decls_nsubprogs) goto L7807;
L7809:
L7805:
	goto L7801;
L7803:
	asu64(R1) = p;
	goto L7772;
	goto L7801;
L7804:
L7801:
	goto L7785;
L7789:
L7785:
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7784:
	asu64(R1) = p;
	if (asu64(R1)) goto L7781;
	asi64(R1) = allowmod;
	if (!asi64(R1)) goto L7813;
	asu64(R1) = moddef;
	if (!asu64(R1)) goto L7813;
	asu64(R1) = moddef;
	goto L7772;
L7813:
	asu64(R1) = extdef;
	if (!asu64(R1)) goto L7815;
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L7817;
	R1 = tou64("mclib");
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7819;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7822;
L7820:
	R1 = (u64)&ambiglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	extdef = asu64(R1);
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = extdef;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= extcount) goto L7820;
L7822:
	R1 = tou64("mclib");
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7824;
	R1 = 0;
	asu64(R2) = extdef;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Ambiguous ext name: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7824:
L7819:
L7817:
	asu64(R1) = extdef;
	goto L7772;
L7815:
	R1 = 0;
	goto L7772;
L7772:
	return asu64(R1);
}

static void mm_name_resolvename(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	i64 moduleno;
	i64 mode;
	i64 islet;
	struct $B15 str;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7827;
	goto L7825;
L7827:
	asi64(R1) = mm_name_allowmodname;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L7829;
	R1 = 0;
	islet = asi64(R1);
	R1 = 0;
	mode = asi64(R1);
	asu64(R1) = p;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L7831;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L7831;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L7831;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7832;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L7832;
	goto L7833;
L7831:
	R1 = 3;
	mode = asi64(R1);
	R1 = 1;
	islet = asi64(R1);
	goto L7830;
L7832:
	R1 = 23;
	mode = asi64(R1);
	goto L7830;
L7833:
L7830:
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7835;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_convucstring(asu64(R1));
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = tou64("pcl:Undefined: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L7834;
L7835:
	asi64(R1) = mode;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_addframevar(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 88;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = islet;
	asu64(R2) = e;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L7834:
L7829:
	asu64(R1) = e;
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 255;
	if (asi64(R1) >= asi64(R2)) goto L7837;
	asu64(R1) = e;
	R2 = 168;
	R1 += (i64)R2;
	(*tou16p(R1)) += 1;
L7837:
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7825:
	return;
}

static u64 mm_name_finddupl(u64 d, u64 pdupl) {
    u64 R1, R2; 
	asu64(R1) = pdupl;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7840;
	asu64(R1) = pdupl;
	goto L7838;
L7840:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
	goto L7842;
L7841:
	asu64(R1) = pdupl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L7845;
	asu64(R1) = pdupl;
	goto L7838;
L7845:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
L7842:
	asu64(R1) = pdupl;
	if (asu64(R1)) goto L7841;
	R1 = 0;
	goto L7838;
L7838:
	return asu64(R1);
}

static u64 mm_name_finddupl_sub(u64 d, u64 pdupl) {
    u64 R1, R2; 
	i64 subprogno;
	asu64(R1) = pdupl;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7848;
	asu64(R1) = pdupl;
	goto L7846;
L7848:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	goto L7850;
L7849:
	asu64(R1) = pdupl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) != asi64(R2)) goto L7853;
	asu64(R1) = pdupl;
	goto L7846;
L7853:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
L7850:
	asu64(R1) = pdupl;
	if (asu64(R1)) goto L7849;
	R1 = 0;
	goto L7846;
L7846:
	return asu64(R1);
}

static void mm_name_resolvedot(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 lhs;
	u64 rhs;
	u64 d;
	u64 e;
	u64 t;
	i64 m;
	i64 moduleno;
	i64 subprogno;
	i64 oldallowmod;
	asu64(R1) = p;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = p;
	R2 = 58;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = rhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asi64(R1) = mm_name_allowmodname;
	oldallowmod = asi64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	mm_name_allowmodname = asi64(R1);
	asu64(R1) = lhs;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldallowmod;
	mm_name_allowmodname = asi64(R1);
	asu64(R1) = lhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7856;
	goto L7857;
L7856:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7859;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7859;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7859;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7859;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7860;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7860;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7860;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7861;
	goto L7862;
L7859:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7864;
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L7864;
	goto L7865;
L7864:
	asu64(R1) = e;
	asu64(R2) = d;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7867;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7869;
	asu64(R1) = e;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L7871;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L7873;
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7873;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need export to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7873:
	goto L7870;
L7871:
	asu64(R1) = e;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = moduleno;
	if (asi64(R1) == asi64(R2)) goto L7874;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7876;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need global to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7876:
L7874:
L7870:
L7869:
// mm_name.resolvedot.domodule:
L7877:
	R1 = 4;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7879;
	goto L7880;
L7879:
	goto L7878;
L7880:
L7878:
	goto L7866;
L7867:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve .#");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7866:
	goto L7858;
L7860:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7882;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7883;
	goto L7884;
L7882:
	goto L7881;
L7883:
L7885:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7888;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7889;
	goto L7890;
L7888:
	goto L7886;
	goto L7887;
L7889:
	goto L7887;
L7890:
	R1 = 0;
	R2 = tou64("2:Record expected");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7887:
	goto L7885;
L7886:
	goto L7881;
L7884:
	R1 = 0;
	R2 = tou64("Record expected");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7881:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	t = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = t;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7892;
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7891;
L7892:
	R1 = 0;
	asu64(R2) = rhs;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7891:
	goto L7858;
L7861:
// mm_name.resolvedot.dosubprogid:
L7865:
	asu64(R1) = e;
	asu64(R2) = d;
	asu64(R1) = mm_name_finddupl_sub(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7894;
	asu64(R1) = e;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L7896;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L7898;
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7898;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need export to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7898:
L7896:
	goto L7877;
	goto L7893;
L7894:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve sub.#");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7893:
	goto L7858;
L7862:
L7858:
	goto L7855;
L7857:
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L7900;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7900:
L7855:
	return;
}

static void mm_name_fixmode(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 pmode;
	u64 a;
	u64 d;
	u64 e;
	u64 f;
	u64 owner;
	i64 m;
	i64 moduleno;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pmode = asu64(R1);
	asu64(R1) = pmode;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	owner = asu64(R2);
	d = asu64(R1);
	goto L7903;
L7902:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7903:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7902;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7906;
	asu64(R1) = d;
	if (!asu64(R1)) goto L7906;
	R1 = 0;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
L7906:
	asu64(R1) = e;
	if (!asu64(R1)) goto L7908;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7908;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	goto L7907;
L7908:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("2:Can't resolve tentative type: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7907:
	return;
}

static void mm_name_fixusertypes() {
    u64 R1, R2; 
	u64 p;
	i64 npasses;
	i64 notresolved;
	u64 d;
	i64 i;
	R1 = 0;
	npasses = asi64(R1);
L7910:
	R1 = (u64)&npasses;
	(*toi64p(R1)) += 1;
	R1 = 0;
	notresolved = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypenames;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7915;
L7913:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = i;
	R1 += (i64)R2*32;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7917;
	R1 = (u64)&mm_decls_typenamepos;
	asi64(R2) = i;
	R1 += (i64)R2*4;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	mm_name_fixmode(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7919;
	R1 = (u64)&notresolved;
	(*toi64p(R1)) += 1;
L7919:
L7917:
	i += 1; if (i <= mm_decls_ntypenames) goto L7913;
L7915:
	asi64(R1) = npasses;
	R2 = 5;
	if (asi64(R1) <= asi64(R2)) goto L7921;
	msysc_m$print_startcon();
	R1 = tou64("Type phase errors - check these user types:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypenames;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7924;
L7922:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = i;
	R1 += (i64)R2*32;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7926;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7928;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7928:
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7926:
	i += 1; if (i <= mm_decls_ntypenames) goto L7922;
L7924:
	R1 = 0;
	R2 = tou64("Fixtypes: too many passes (cyclic ref?)");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7921:
	asi64(R1) = notresolved;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7910;
	return;
}

static u64 mm_name_addframevar(u64 owner, u64 d, i64 moduleno, i64 mode) {
    u64 R1, R2, R3; 
	u64 e;
	R1 = 11;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = mode;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = e;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = e;
	goto L7929;
L7929:
	return asu64(R1);
}

static u64 mm_name_copylistunit(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plist;
	u64 plistx;
	R1 = 0;
	R2 = R1;
	plistx = asu64(R2);
	plist = asu64(R1);
	goto L7932;
L7931:
	asu64(R1) = p;
	asu64(R1) = mm_name_copyunit(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&plistx;
	R3 = (u64)&plist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7932:
	asu64(R1) = p;
	if (asu64(R1)) goto L7931;
	asu64(R1) = plist;
	goto L7930;
L7930:
	return asu64(R1);
}

static u64 mm_name_copyunit(u64 p) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 q;
	u64 d;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7936;
	R1 = 0;
	goto L7934;
L7936:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7938;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_name_nmacroparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7941;
L7939:
	R1 = (u64)&mm_name_macroparamsgen;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L7943;
	R1 = (u64)&mm_name_macroargs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mm_name_copyunit(asu64(R1));
	goto L7934;
	goto L7941;
L7943:
	i += 1; if (i <= mm_name_nmacroparams) goto L7939;
L7941:
L7938:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = q;
	*(struct $B60*)(R2) = (R1_B60);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7946;
L7944:
	asu64(R1) = q;
	R2 = 16;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mm_name_copylistunit(asu64(R1));
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= av_1) goto L7944;
L7946:
	asu64(R1) = q;
	goto L7934;
L7934:
	return asu64(R1);
}

static void mm_name_replaceunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 pnext;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pnext = asu64(R1);
	asu64(R1) = q;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = p;
	*(struct $B60*)(R2) = (R1_B60);
	asu64(R1) = pnext;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_name_expandmacro(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	u64 pm;
	u64 pnew;
	i64 ignoreargs;
	asi64(R1) = mm_name_macrolevels;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L7950;
	R1 = 0;
	R2 = tou64("Too many macro levels (recursive macro?)");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7950:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	mm_name_nmacroparams = asi64(R1);
	goto L7952;
L7951:
	asi64(R1) = mm_name_nmacroparams;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L7955;
	R1 = 0;
	R2 = tou64("macro param overflow");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7955:
	asu64(R1) = pm;
	R2 = (u64)&mm_name_macroparams;
	R3 = (u64)&mm_name_nmacroparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_name_macroparamsgen;
	asi64(R3) = mm_name_nmacroparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L7952:
	asu64(R1) = pm;
	if (asu64(R1)) goto L7951;
	R1 = 0;
	mm_name_nmacroargs = asi64(R1);
	goto L7957;
L7956:
	asi64(R1) = mm_name_nmacroargs;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L7960;
	R1 = 0;
	R2 = tou64("macro arg overflow");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7960:
	asu64(R1) = b;
	R2 = (u64)&mm_name_macroargs;
	R3 = (u64)&mm_name_nmacroargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L7957:
	asu64(R1) = b;
	if (asu64(R1)) goto L7956;
	asi64(R1) = mm_name_nmacroargs;
	asi64(R2) = mm_name_nmacroparams;
	if (asi64(R1) >= asi64(R2)) goto L7962;
	msysc_m$print_startcon();
	R1 = tou64("NMACROARGS=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_name_nmacroargs;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mm_name_nmacroparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Too few macro args");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7962:
	R1 = 0;
	ignoreargs = asi64(R1);
	asi64(R1) = mm_name_nmacroargs;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7964;
	asi64(R1) = mm_name_nmacroparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7964;
	R1 = 1;
	ignoreargs = asi64(R1);
	R1 = 0;
	R2 = R1;
	mm_name_nmacroparams = asi64(R2);
	mm_name_nmacroargs = asi64(R1);
	goto L7963;
L7964:
	asi64(R1) = mm_name_nmacroargs;
	asi64(R2) = mm_name_nmacroparams;
	if (asi64(R1) <= asi64(R2)) goto L7965;
	R1 = 0;
	R2 = tou64("Too many macro args");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7965:
L7963:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_name_copyunit(asu64(R1));
	pnew = asu64(R1);
	asi64(R1) = ignoreargs;
	if (asi64(R1)) goto L7967;
	asu64(R1) = pnew;
	asu64(R2) = p;
	mm_name_replaceunit(asu64(R2), asu64(R1));
	goto L7966;
L7967:
	asu64(R1) = pnew;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7966:
	return;
}

static void mm_name_duplfield(u64 owner, u64 p, u64 q) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7970;
	R1 = tou64("DUPLFIELD");
	mm_support_serror(asu64(R1));
L7970:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 92;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	R2 = 136;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 72;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void mm_name_do_baseclass(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 newd;
	u64 dbase;
	i64 normalexit;
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = p;
	R3 = 144;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	dbase = asu64(R1);
	asu64(R1) = dbase;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7973;
L7972:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 1;
	normalexit = asi64(R1);
	goto L7976;
L7975:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7979;
	R1 = 0;
	normalexit = asi64(R1);
	goto L7977;
L7979:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L7976:
	asu64(R1) = e;
	if (asu64(R1)) goto L7975;
L7977:
	asi64(R1) = normalexit;
	if (!asi64(R1)) goto L7981;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7983;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7983;
	goto L7984;
L7983:
	R1 = 17;
	asu64(R2) = d;
	asu64(R3) = p;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = newd;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7982;
L7984:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	asu64(R3) = p;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = d;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_name_duplfield(asu64(R3), asu64(R2), asu64(R1));
L7982:
	asu64(R1) = newd;
	asu64(R2) = p;
	mm_lib_adddef(asu64(R2), asu64(R1));
L7981:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7973:
	asu64(R1) = d;
	if (asu64(R1)) goto L7972;
	return;
}

static i64 mm_parse_parsemodule(u64 pm) {
    u64 R1, R2; 
	u64 owner;
	mm_parse_initparser();
	asu64(R1) = pm;
	R2 = 16;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	mm_decls_currmoduleno = asi64(R1);
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_decls_stmodule = asu64(R1);
	asu64(R1) = mm_decls_stmodule;
	mm_decls_currproc = asu64(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lex_startlex(asu64(R1));
	asu64(R1) = mm_decls_stmodule;
	owner = asu64(R1);
	mm_lex_lex();
	asu64(R1) = owner;
	mm_parse_readmoduledefs(asu64(R1));
	R1 = 1;
	goto L7985;
L7985:
	return asi64(R1);
}

static void mm_parse_readmoduledefs(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	i64 globalflag;
	R1 = 0;
	globalflag = asi64(R1);
L7987:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L8018;
	case 2: case 3: case 5: case 6: case 7: case 8: case 9: case 10: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 110: case 112: case 113: case 118: case 119: case 124: case 127: case 128: case 129: case 130: case 131: goto L7991;
	case 4: goto L8006;
	case 11: case 79: case 80: case 117: case 121: goto L7998;
	case 59: goto L8007;
	case 67: goto L8019;
	case 108: case 109: goto L7997;
	case 111: goto L8004;
	case 114: goto L8001;
	case 115: goto L8009;
	case 116: goto L8002;
	case 120: goto L8000;
	case 122: goto L8008;
	case 123: goto L8003;
	case 125: goto L8014;
	case 126: goto L7992;
	case 132: goto L8005;
	default: goto L7991;
    };
// SWITCH
L7992:
	asi64(R1) = globalflag;
	if (!asi64(R1)) goto L7994;
	R1 = tou64("global global?");
	mm_support_serror(asu64(R1));
L7994:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	globalflag = asi64(R1);
	asi64(R1) = globalflag;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7996;
	asu64(R1) = mm_decls_stmodule;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_nsubprogs;
	if (asi64(R1) == asi64(R2)) goto L7996;
	R1 = 2;
	globalflag = asi64(R1);
L7996:
	mm_lex_lex();
	goto L7989;
L7997:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7989;
L7998:
// mm_parse.readmoduledefs.dovar:
L7999:
	R1 = 0;
	R2 = 10;
	R3 = 0;
	asi64(R4) = globalflag;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7989;
L8000:
	mm_lex_lex();
	R1 = 120;
	R2 = 10;
	R3 = 0;
	asi64(R4) = globalflag;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7989;
L8001:
	asu64(R1) = owner;
	mm_parse_readimportmodule(asu64(R1));
	goto L7989;
L8002:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7989;
L8003:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7989;
L8004:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7989;
L8005:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7989;
L8006:
	mm_lex_lex();
	goto L7989;
L8007:
	goto L7988;
	goto L7989;
L8008:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7989;
L8009:
L8010:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L8013;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L8010;
L8013:
	R1 = 0;
	R2 = 0;
	R3 = 115;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L7989;
L8014:
L8015:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8015;
	goto L7989;
L8018:
	R1 = tou64("MODULE/DOT");
	mm_support_serror(asu64(R1));
	goto L7989;
L8019:
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8021;
	goto L7999;
L8021:
	goto L8022;
	goto L7989;
L7991:
// mm_parse.readmoduledefs.doexec:
L8022:
	R1 = tou64("Code outside a function");
	mm_support_serror(asu64(R1));
L7989:
	goto L7987;
L7988:
	return;
}

static void mm_parse_initparser() {
    u64 R1; 
	u64 tabledataname;
	asu64(R1) = mm_decls_nullunit;
	if (asu64(R1)) goto L8025;
	R1 = 2;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	mm_decls_nullunit = asu64(R1);
L8025:
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	R1 = 0;
	mm_parse_varattribs = asi64(R1);
	R1 = 0;
	mm_parse_intabledata = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 0;
	mm_parse_inparamlist = asi64(R1);
	R1 = 0;
	mm_parse_inrecordbody = asi64(R1);
	R1 = 0;
	mm_parse_inimportmodule = asi64(R1);
	R1 = tou64("");
	tabledataname = asu64(R1);
	R1 = 0;
	mm_parse_labelseen = asi64(R1);
	R1 = 0;
	mm_parse_ndollar = asi64(R1);
	return;
}

static void mm_parse_skipsemi() {
    u64 R1, R2; 
	goto L8028;
L8027:
	mm_lex_lex();
L8028:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8027;
	return;
}

static u64 mm_parse_makeblock(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L8032;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8032;
	asu64(R1) = p;
	goto L8030;
L8032:
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L8030;
L8030:
	return asu64(R1);
}

static void mm_parse_checkequals() {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8035;
	R1 = tou64("\"=\" expected");
	mm_support_serror(asu64(R1));
L8035:
	return;
}

static i64 mm_parse_getcurrline() {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	goto L8036;
L8036:
	return asi64(R1);
}

static i64 mm_parse_checkbegin(i64 fbrack) {
    u64 R1, R2; 
	i64 closesym;
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8039;
	asi64(R1) = fbrack;
	if (!asi64(R1)) goto L8039;
	R1 = 10;
	closesym = asi64(R1);
	mm_lex_lex();
	goto L8038;
L8039:
	R1 = 87;
	closesym = asi64(R1);
L8038:
	asi64(R1) = closesym;
	goto L8037;
L8037:
	return asi64(R1);
}

static void mm_parse_checkbeginend(i64 closesym, i64 kwd, i64 startline) {
    u64 R1, R2, R3, R4; 
	mm_parse_skipsemi();
	asi64(R1) = closesym;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8042;
	asi64(R1) = closesym;
	mm_parse_checksymbollex(asi64(R1));
	goto L8041;
L8042:
	asi64(R1) = startline;
	R2 = 0;
	asi64(R3) = kwd;
	asi64(R4) = closesym;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L8041:
	return;
}

static void mm_parse_checkend(i64 endsym, i64 endkwd1, i64 endkwd2, i64 startline) {
    u64 R1, R2, R3; 
	struct $B5 str;
	mm_parse_skipsemi();
	asi64(R1) = endsym;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L8045;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8045;
	goto L8043;
L8045:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L8047;
	R1 = tou64("'End' expected");
	mm_support_serror(asu64(R1));
L8047:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8049;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L8052;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L8051;
L8052:
	mm_lex_lex();
	goto L8043;
	goto L8050;
L8051:
// mm_parse.checkend.error:
	R1 = tou64("Mismatched end ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = startline;
	if (!asi64(R1)) goto L8055;
	R1 = (u64)&str;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" (from line #)");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = startline;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L8055:
	R1 = (u64)&str;
	mm_support_serror(asu64(R1));
L8050:
L8049:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L8058;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L8057;
L8058:
	mm_lex_lex();
L8057:
L8043:
	return;
}

static u64 mm_parse_readvardef(u64 owner, i64 scope, i64 isstatic, i64 varid, i64 k) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 nvars;
	i64 m;
	i64 initcode;
	u64 stname;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8061;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	m = asi64(R1);
	goto L8060;
L8061:
	R1 = tou64("Readvar?");
	mm_support_serror(asu64(R1));
L8060:
	R1 = 0;
	nvars = asi64(R1);
	goto L8063;
L8062:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	asi64(R1) = varid;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stname;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = isstatic;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = k;
	R2 = 120;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = varid;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L8066;
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 11;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8066:
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = varid;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8068;
	asu64(R1) = stname;
	mm_lib_addstatic(asu64(R1));
L8068:
	mm_lex_lex();
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8071;
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L8070;
L8071:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8073;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8074;
	goto L8075;
L8073:
	R1 = 1;
	initcode = asi64(R1);
	goto L8072;
L8074:
	R1 = 2;
	initcode = asi64(R1);
	goto L8072;
L8075:
	R1 = 3;
	initcode = asi64(R1);
L8072:
	R1 = 1;
	asu64(R2) = stname;
	R3 = 168;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8077;
	asi64(R1) = varid;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8079;
	R1 = tou64("Non-variants can't use :=");
	mm_support_serror(asu64(R1));
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8081;
	R1 = tou64("Can't use := for statics inside procs");
	mm_support_serror(asu64(R1));
L8081:
L8079:
	goto L8076;
L8077:
	asi64(R1) = varid;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8083;
	R1 = tou64("Need 'static' for '='");
	mm_support_serror(asu64(R1));
	asu64(R1) = stname;
	mm_lib_addstatic(asu64(R1));
L8083:
L8076:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = initcode;
	asu64(R2) = stname;
	R3 = 171;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = varid;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8085;
	asu64(R1) = stname;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	asu64(R2) = mm_lib_createname(asu64(R2));
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 59;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8085:
	goto L8069;
L8070:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8086;
	asi64(R1) = k;
	R2 = 120;
	if (asi64(R1) != asi64(R2)) goto L8088;
	R1 = tou64("let@");
	mm_support_serror(asu64(R1));
L8088:
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8069;
L8086:
	asi64(R1) = k;
	R2 = 120;
	if (asi64(R1) != asi64(R2)) goto L8089;
	R1 = tou64("let needs :=/=");
	mm_support_serror(asu64(R1));
L8089:
L8069:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8091;
	goto L8064;
L8091:
	mm_lex_lex();
L8063:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8062;
L8064:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8093;
	R1 = tou64("No vars declared");
	mm_support_serror(asu64(R1));
L8093:
	asu64(R1) = ulist;
	goto L8059;
L8059:
	return asu64(R1);
}

static void mm_parse_readconstdef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	i64 nconsts;
	i64 deft;
	i64 m;
	u64 stname;
	mm_lex_lex();
	R1 = 0;
	nconsts = asi64(R1);
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8096;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	deft = asi64(R1);
	goto L8095;
L8096:
	R1 = 22;
	deft = asi64(R1);
L8095:
	goto L8098;
L8097:
	R1 = 9;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = deft;
	m = asi64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nconsts;
	(*toi64p(R1)) += 1;
	asi64(R1) = scope;
	asu64(R2) = stname;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8101;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L8101;
	asu64(R1) = stname;
	mm_lib_addexpconst(asu64(R1));
L8101:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8103;
	goto L8099;
L8103:
	mm_lex_lex();
L8098:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8097;
L8099:
	asi64(R1) = nconsts;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8105;
	R1 = tou64("No consts declared");
	mm_support_serror(asu64(R1));
L8105:
	return;
}

static u64 mm_parse_readlbrack() {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	u64 plower;
	i64 oldirp;
	i64 length;
	i64 usecomma;
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	plower = asu64(R1);
	R1 = 0;
	length = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8108;
	mm_lex_lex();
	asi64(R1) = mm_parse_inreadprint;
	oldirp = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	plower = asu64(R1);
	asi64(R1) = oldirp;
	mm_parse_inreadprint = asi64(R1);
	R1 = 5;
	mm_parse_checksymbollex(asi64(R1));
	goto L8107;
L8108:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8109;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8109;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	plower = asu64(R1);
	mm_lex_lex();
	mm_lex_lex();
	goto L8107;
L8109:
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8110;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8110;
	R1 = 63;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	mm_lex_lex();
	asu64(R1) = p;
	goto L8106;
	goto L8107;
L8110:
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8111;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8111;
	R1 = 63;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	R1 = 10;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = p;
	goto L8106;
L8111:
L8107:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8113;
	goto L8114;
L8113:
	mm_lex_lex();
	R1 = 20;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8106;
	goto L8112;
L8114:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
L8112:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8116;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8117;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8118;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8119;
	goto L8120;
L8116:
	mm_lex_lex();
	asu64(R1) = p;
	goto L8106;
	goto L8115;
L8117:
	R1 = 1;
	usecomma = asi64(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8122;
	mm_lex_lex();
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L8106;
L8122:
// mm_parse.readlbrack.docomma:
L8123:
	R1 = 1;
	length = asi64(R1);
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asi64(R1) = usecomma;
	if (!asi64(R1)) goto L8125;
L8126:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8130;
	goto L8128;
L8130:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8132;
	R1 = tou64(",, null expr not allowed");
	mm_support_serror(asu64(R1));
L8132:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8126;
L8128:
	goto L8124;
L8125:
L8133:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8137;
	goto L8135;
L8137:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8139;
	R1 = tou64(",, null expr not allowed");
	mm_support_serror(asu64(R1));
L8139:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8133;
L8135:
L8124:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = ulist;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L8106;
	goto L8115;
L8118:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8141;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8142;
	goto L8143;
L8141:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = q;
	asu64(R3) = p;
	asu64(R3) = mm_parse_fixcond(asu64(R3));
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 48;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L8106;
	goto L8140;
L8142:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = q;
	asu64(R3) = p;
	asu64(R3) = mm_parse_fixcond(asu64(R3));
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 48;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L8106;
	goto L8140;
L8143:
L8140:
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8145;
L8146:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8146;
	R1 = 16;
	mm_parse_checksymbol(asi64(R1));
	goto L8144;
L8145:
	mm_lex_lex();
L8144:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = ulist;
	asu64(R3) = p;
	R4 = 112;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L8106;
	goto L8115;
L8119:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8150;
	R1 = 0;
	usecomma = asi64(R1);
	goto L8123;
L8150:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L8151:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8155;
	goto L8153;
L8155:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8151;
L8153:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = ulist;
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	goto L8106;
	goto L8115;
L8120:
	R1 = tou64("(x ...");
	mm_support_serror(asu64(R1));
L8115:
	R1 = 0;
	goto L8106;
L8106:
	return asu64(R1);
}

static void mm_parse_addlistparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8158;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L8157;
L8158:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 152;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8157:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static u64 mm_parse_readcast() {
    u64 R1, R2, R3; 
	u64 p;
	i64 opc;
	i64 t;
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8161;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8162;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8163;
	goto L8164;
L8161:
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 26;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L8159;
	goto L8160;
L8162:
	R1 = 61;
	opc = asi64(R1);
	mm_lex_lex();
	goto L8160;
L8163:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L8166;
	mm_lex_lex();
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 26;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	mm_lex_lex();
	goto L8165;
L8166:
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L8165:
	asu64(R1) = p;
	goto L8159;
	goto L8160;
L8164:
	R1 = 58;
	opc = asi64(R1);
L8160:
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = mm_decls_currproc;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	goto L8159;
L8159:
	return asu64(R1);
}

static u64 mm_parse_readopc() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	i64 tag;
	i64 opc;
	i64 firstsym;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	firstsym = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L8169;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L8170;
	goto L8171;
L8169:
	R1 = 36;
	tag = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L8168;
L8170:
	R1 = 35;
	tag = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L8168;
L8171:
	R1 = 36;
	tag = asi64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
L8168:
	mm_lex_lex();
	asi64(R1) = firstsym;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L8173;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L8174;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L8175;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L8175;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L8175;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L8175;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L8175;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8175;
	goto L8176;
L8173:
	asu64(R1) = mm_parse_readterm2();
	goto L8167;
	goto L8172;
L8174:
	R1 = 60;
	opc = asi64(R1);
	goto L8172;
L8175:
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L8178;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8180;
	R1 = tou64("Needs (x,y)");
	mm_support_serror(asu64(R1));
L8180:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L8167;
	goto L8177;
L8178:
	R1 = tou64("READOPC/SINGLE OPND?");
	mm_support_serror(asu64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L8167;
L8177:
	goto L8172;
L8176:
	R1 = (u64)&mm_tables_symboloptypes;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8182;
	R1 = tou64("Can't be used as unary op");
	mm_support_serror(asu64(R1));
L8182:
L8172:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8184;
	mm_lex_lex();
	R1 = 39;
	tag = asi64(R1);
	asi64(R1) = firstsym;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L8186;
	goto L8187;
L8186:
	R1 = 105;
	opc = asi64(R1);
	goto L8185;
L8187:
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8189;
	R1 = tou64("op:= not available");
	mm_support_serror(asu64(R1));
L8189:
L8185:
L8184:
	asu64(R1) = mm_parse_readterm2();
	R2 = R1;
	q = asu64(R2);
	asi64(R2) = tag;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L8191;
	R1 = tou64("Too many opnds");
	mm_support_serror(asu64(R1));
L8191:
	asu64(R1) = p;
	goto L8167;
L8167:
	return asu64(R1);
}

static u64 mm_parse_readcompilervar() {
    u64 R1, R2, R3; 
	struct $B5 str;
	struct $B3 tm;
	u64 p;
	u64 currmodule;
// PROC LOCAL STATICS GO HERE
	static struct $B29 mm_parse_readcompilervar_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = mm_decls_currmoduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	currmodule = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 71: goto L8199;
	case 72: goto L8200;
	case 73: goto L8201;
	case 74: goto L8202;
	case 75: goto L8203;
	case 76: goto L8204;
	case 77: goto L8205;
	case 78: goto L8206;
	case 79: goto L8195;
	case 80: goto L8196;
	case 81: goto L8197;
	case 82: goto L8198;
	case 83: case 84: goto L8207;
	default: goto L8195;
    };
// SWITCH
L8196:
	R1 = 7;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8192;
	goto L8193;
L8197:
	R1 = 1;
	asr64(R2) = 3.141592653589793100e+000;
	asi64(R2) = asi64(R2);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8192;
	goto L8193;
L8198:
	R1 = 1;
	asr64(R2) = (1.0/0.0);
	asi64(R2) = asi64(R2);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8192;
	goto L8193;
L8199:
	R1 = 3;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asu64(R2) = mm_support_getlineno(asu64(R2));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8192;
	goto L8193;
L8200:
	R1 = (u64)&str;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asi64(R2) = mm_support_getlineno(asu64(R2));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L8193;
L8201:
	asu64(R1) = mm_decls_stmodule;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8193;
L8202:
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = currmodule;
	R3 = 20;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8193;
L8203:
	asu64(R1) = mm_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8193;
L8204:
	R1 = (u64)&tm;
	mwindows_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_parse_readcompilervar_monthnames;
	R2 = (u64)&tm;
	R3 = 2;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L8193;
L8205:
	R1 = (u64)&tm;
	mwindows_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 10;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 12;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L8193;
L8206:
	R1 = tou64("Compiler:M6.4");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8193;
L8207:
	R1 = 6;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 83;
	asi64(R2) = asi64(R2)  ==  asi64(R3);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8192;
	goto L8193;
L8195:
	R1 = (u64)&mm_tables_jtagnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("compiler var not impl: #");
	mm_support_serror_s(asu64(R2), asu64(R1));
L8193:
	mm_lex_lex();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R2) = mlib_pcm_copyheapstring(asu64(R2));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	goto L8192;
L8192:
	return asu64(R1);
}

static u64 mm_parse_readcastx() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 m;
	u64 p;
	mm_lex_lex();
	R1 = 58;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8210;
	R1 = 61;
	opc = asi64(R1);
	mm_lex_lex();
L8210:
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	m = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8212;
	asi64(R1) = opc;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L8214;
	R1 = tou64("@ type missing");
	mm_support_serror(asu64(R1));
L8214:
	R1 = 60;
	opc = asi64(R1);
	goto L8211;
L8212:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	m = asi64(R1);
L8211:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = mm_decls_currproc;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	goto L8208;
L8208:
	return asu64(R1);
}

static void mm_parse_checksymbol(i64 symbol) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L8217;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	asi64(R2) = symbol;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	mm_support_serror(asu64(R1));
L8217:
	return;
}

static void mm_parse_lexchecksymbol(i64 symbol) {
    u64 R1; 
	mm_lex_lex();
	asi64(R1) = symbol;
	mm_parse_checksymbol(asi64(R1));
	return;
}

static void mm_parse_checksymbollex(i64 symbol) {
    u64 R1; 
	asi64(R1) = symbol;
	mm_parse_checksymbol(asi64(R1));
	mm_lex_lex();
	return;
}

static i64 mm_parse_readtypespec(u64 owner, i64 typedefx) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	i64 t;
	i64 kwd;
	i64 sltype;
	i64 w;
	u64 x;
	u64 pupper;
	u64 plx;
	u64 dim;
	u64 length;
	struct $B83 dims;
	i64 ndims;
	i64 i;
	i64 n;
	i64 k;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8222;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L8223;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8224;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L8225;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L8225;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L8226;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L8227;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L8228;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L8229;
	goto L8230;
L8222:
// mm_parse.readtypespec.arraybounds:
	mm_lex_lex();
	R1 = 0;
	ndims = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
L8232:
	R1 = 0;
	length = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8236;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8235;
L8236:
	R1 = 0;
	dim = asu64(R1);
	goto L8234;
L8235:
	asu64(R1) = mm_parse_readunit();
	dim = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8238;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8238;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8239;
	goto L8240;
L8238:
	goto L8237;
L8239:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8242;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8242;
	asu64(R1) = mm_parse_readunit();
	length = asu64(R1);
	asu64(R1) = length;
	asu64(R2) = dim;
	R3 = 27;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	dim = asu64(R1);
	goto L8241;
L8242:
	asu64(R1) = dim;
	R2 = 27;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	dim = asu64(R1);
L8241:
	goto L8237;
L8240:
L8237:
L8234:
	asi64(R1) = ndims;
	R2 = 30;
	if (asi64(R1) < asi64(R2)) goto L8244;
	R1 = tou64("Too many array dims");
	mm_support_serror(asu64(R1));
L8244:
	asu64(R1) = dim;
	R2 = (u64)&dims;
	R3 = (u64)&ndims;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8246;
	goto L8233;
L8246:
	mm_lex_lex();
	goto L8232;
L8233:
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 12;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = ndims;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8249;
L8247:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8251;
	asi64(R1) = typedefx;
	goto L8250;
L8251:
	R1 = 0;
L8250:
	R2 = (u64)&dims;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R3) = t;
	asu64(R4) = owner;
	asi64(R1) = mm_lib_createarraymode(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	t = asi64(R1);
	i += -1; if (i >= 1) goto L8247;
L8249:
	asi64(R1) = t;
	goto L8220;
	goto L8221;
L8223:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	mm_lex_lex();
	goto L8221;
L8224:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8253;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	t = asi64(R1);
	mm_lex_lex();
	goto L8252;
L8253:
	asu64(R1) = d;
	R2 = 0;
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	t = asi64(R1);
L8252:
	goto L8221;
L8225:
	R1 = tou64("Use 'record name =' syntax");
	mm_support_serror(asu64(R1));
	goto L8221;
L8226:
	R1 = tou64("Top-level union not allowed");
	mm_support_serror(asu64(R1));
	goto L8221;
L8227:
// mm_parse.readtypespec.retry:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) != asi64(R2)) goto L8256;
	mm_lex_lex();
L8256:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L8258;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L8258;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L8259;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L8260;
	goto L8261;
L8258:
	asi64(R1) = typedefx;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readrefproc(asu64(R2), asi64(R1));
	t = asi64(R1);
	goto L8257;
L8259:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8263;
	goto L8264;
L8263:
	R1 = 20;
	t = asi64(R1);
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L8266;
	R1 = 12;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8266:
	goto L8262;
L8264:
	goto L8267;
L8262:
	mm_lex_lex();
	goto L8257;
L8260:
	mm_lex_lex();
	R1 = 0;
	t = asi64(R1);
	goto L8268;
	goto L8257;
L8261:
// mm_parse.readtypespec.readtarget:
L8267:
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
// mm_parse.readtypespec.gottarget:
L8268:
	asi64(R1) = typedefx;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	t = asi64(R1);
L8257:
	goto L8221;
L8228:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L8270;
	R1 = 20;
	t = asi64(R1);
	goto L8269;
L8270:
	R1 = 7;
	t = asi64(R1);
L8269:
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L8272;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8272:
	mm_lex_lex();
	goto L8221;
L8229:
	asi64(R1) = typedefx;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_parse_readslicetype(asu64(R3), asi64(R2), asi64(R1));
	t = asi64(R1);
	goto L8221;
L8230:
	R1 = tou64("Bad type starter");
	mm_support_serror(asu64(R1));
L8221:
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L8274;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8274:
	asi64(R1) = t;
	goto L8220;
L8220:
	return asi64(R1);
}

static i64 mm_parse_readslicetype(u64 owner, i64 slicetype, i64 typedefx) {
    u64 R1, R2, R3, R4, R5; 
	u64 plower;
	i64 t;
	R1 = 11;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8277;
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	plower = asu64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 5;
	mm_parse_checksymbol(asi64(R1));
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L8276;
L8277:
	R1 = 0;
	plower = asu64(R1);
L8276:
	mm_lex_lex();
	asi64(R1) = typedefx;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = typedefx;
	asu64(R2) = plower;
	asi64(R3) = t;
	asi64(R4) = slicetype;
	asu64(R5) = owner;
	asi64(R1) = mm_lib_createslicemode(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L8275;
L8275:
	return asi64(R1);
}

static u64 mm_parse_readslist(i64 iscall, i64 donulls) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	i64 oldinparamlist;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8280;
	asu64(R1) = ulist;
	goto L8278;
L8280:
	asi64(R1) = mm_parse_inparamlist;
	oldinparamlist = asi64(R1);
	asi64(R1) = iscall;
	mm_parse_inparamlist = asi64(R1);
L8281:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8284;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8285;
	goto L8286;
L8284:
	asi64(R1) = donulls;
	if (!asi64(R1)) goto L8288;
	R1 = 2;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L8287;
L8288:
	R1 = tou64("null comma expr not allowed");
	mm_support_serror(asu64(R1));
L8287:
	mm_lex_lex();
	goto L8283;
L8285:
	asi64(R1) = donulls;
	if (!asi64(R1)) goto L8290;
	asu64(R1) = mm_decls_nullunit;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8290:
	goto L8282;
	goto L8283;
L8286:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8293;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8292;
L8293:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8295;
	goto L8282;
L8295:
	goto L8291;
L8292:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8297;
	goto L8282;
L8297:
	R1 = tou64("SLIST?");
	mm_support_serror(asu64(R1));
L8291:
L8283:
	goto L8281;
L8282:
	asi64(R1) = oldinparamlist;
	mm_parse_inparamlist = asi64(R1);
	asu64(R1) = ulist;
	goto L8278;
L8278:
	return asu64(R1);
}

static u64 mm_parse_readindex(u64 p, i64 dot) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plower;
	u64 pupper;
	mm_lex_lex();
	asi64(R1) = dot;
	if (asi64(R1)) goto L8300;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8302;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L8303;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8303;
	goto L8304;
L8302:
// mm_parse.readindex.fullslice:
L8305:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	plower = asu64(R1);
	R1 = 3;
	asu64(R2) = plower;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	pupper = asu64(R1);
	R1 = 4;
	asu64(R2) = pupper;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pupper;
	asu64(R2) = plower;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 48;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L8298;
	goto L8301;
L8303:
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L8305;
	goto L8301;
L8304:
L8301:
L8300:
L8306:
	asi64(R1) = mm_parse_ndollar;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L8309;
	R1 = tou64("Too many nested a[$]");
	mm_support_serror(asu64(R1));
L8309:
	asu64(R1) = p;
	R2 = (u64)&mm_parse_dollarstack;
	R3 = (u64)&mm_parse_ndollar;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_parse_ndollar;
	(*toi64p(R1)) -=1;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8311;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = dot;
	if (!asi64(R3)) goto L8313;
	R3 = 52;
	goto L8312;
L8313:
	R3 = 48;
L8312:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8310;
L8311:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = dot;
	if (!asi64(R3)) goto L8315;
	R3 = 51;
	goto L8314;
L8315:
	R3 = 46;
L8314:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8310:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8317;
	goto L8307;
L8317:
	mm_lex_lex();
	goto L8306;
L8307:
	R1 = 12;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	goto L8298;
L8298:
	return asu64(R1);
}

static u64 mm_parse_readdotsuffix(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 p2;
	goto L8320;
L8319:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8323;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8324;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L8325;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L8326;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L8327;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L8328;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L8329;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L8330;
	goto L8331;
L8323:
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = mm_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L8322;
L8324:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = p;
	R3 = 49;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L8322;
L8325:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8333;
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8335;
	R1 = 9;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asu64(R2) = r;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8334;
L8335:
	R1 = 3;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = r;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8334:
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p2 = asu64(R1);
	asu64(R1) = p2;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L8332;
L8333:
// mm_parse.readdotsuffix.doprop:
L8336:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8332:
	mm_lex_lex();
	goto L8322;
L8326:
	asu64(R1) = p;
	R2 = 68;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	goto L8322;
L8327:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L8338;
	goto L8339;
L8338:
	goto L8337;
L8339:
	R1 = tou64("RDS:TYPEOF");
	mm_support_serror(asu64(R1));
L8337:
	mm_lex_lex();
	goto L8322;
L8328:
	R1 = 10;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8336;
	goto L8322;
L8329:
	R1 = 9;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8336;
	goto L8322;
L8330:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8341;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8341;
	asu64(R1) = p;
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 36;
	asu64(R2) = mm_lib_createunit1(asi64(R3), asu64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 9;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asu64(R2) = q;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8340;
L8341:
	goto L8342;
L8340:
	mm_lex_lex();
	asu64(R1) = q;
	p = asu64(R1);
	goto L8322;
L8331:
// mm_parse.readdotsuffix.error:
L8342:
	R1 = tou64("Unknown dot suffix");
	mm_support_serror(asu64(R1));
L8322:
L8320:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8319;
	asu64(R1) = p;
	goto L8318;
L8318:
	return asu64(R1);
}

static u64 mm_parse_readconstexpr(i64 needconst) {
    u64 R1; 
	asu64(R1) = mm_parse_readunit();
	goto L8343;
L8343:
	return asu64(R1);
}

static i64 mm_parse_readconstint() {
    u64 R1, R2; 
	i64 x;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8346;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	mm_lex_lex();
	asi64(R1) = x;
	goto L8344;
	goto L8345;
L8346:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L8347;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8349;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	mm_lex_lex();
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L8344;
L8349:
L8347:
L8345:
	R1 = tou64("Can't do complex expr");
	mm_support_serror(asu64(R1));
	R1 = 0;
	goto L8344;
L8344:
	return asi64(R1);
}

static void mm_parse_readprocdef(u64 procowner, i64 scope) {
    u64 R1, R2, R3; 
	i64 kwd;
	i64 startline;
	i64 closesym;
	i64 shortfun;
	u64 stproc;
	u64 stname;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	shortfun = asi64(R1);
	R1 = 0;
	mm_parse_nforloops = asi64(R1);
	R1 = 1;
	mm_decls_assemmode = asi64(R1);
	asi64(R1) = scope;
	asu64(R2) = procowner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	stproc = asu64(R1);
	R1 = 0;
	mm_decls_assemmode = asi64(R1);
	mm_parse_checkequals();
	mm_lex_lex();
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	asi64(R1) = shortfun;
	if (asi64(R1)) goto L8352;
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
L8352:
	asu64(R1) = stproc;
	mm_parse_pushproc(asu64(R1));
	R1 = 0;
	mm_lib_nextavindex = asi64(R1);
	asu64(R1) = mm_parse_dretvar;
	if (!asu64(R1)) goto L8354;
	R1 = 11;
	asu64(R2) = mm_parse_dretvar;
	asu64(R3) = stproc;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asu64(R2) = stproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stname;
	asu64(R2) = stproc;
	mm_lib_adddef(asu64(R2), asu64(R1));
L8354:
	asu64(R1) = stproc;
	mm_lib_addtoproclist(asu64(R1));
	asi64(R1) = shortfun;
	if (!asi64(R1)) goto L8356;
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4;
	mm_parse_checksymbollex(asi64(R1));
	goto L8355;
L8356:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = startline;
	asi64(R2) = kwd;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
L8355:
	asu64(R1) = stproc;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	mm_parse_popproc();
	return;
}

static u64 mm_parse_readprocdecl(u64 procowner, i64 scope) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 varparams;
	i64 nparams;
	i64 nretvalues;
	i64 isthreaded;
	i64 subprogno;
	struct $B18 retmodes;
	u64 ms;
	u64 ps;
	u64 metadata;
	u64 truename;
	u64 pequiv;
	u64 stproc;
	u64 owner;
	u64 paramlist;
	u64 nameptr;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isthreaded = asi64(R1);
	R1 = 0;
	pequiv = asu64(R1);
	R1 = tou64("");
	metadata = asu64(R1);
	R1 = 0;
	truename = asu64(R1);
	R1 = 0;
	varparams = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L8359;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	truename = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8358;
L8359:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
L8358:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L8361;
	R1 = 7;
	goto L8360;
L8361:
	R1 = 6;
L8360:
	asu64(R2) = nameptr;
	asu64(R3) = procowner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L8363;
	R1 = 1;
	scope = asi64(R1);
L8363:
	asi64(R1) = isthreaded;
	asu64(R2) = stproc;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = truename;
	if (!asu64(R1)) goto L8365;
	asu64(R1) = truename;
	asu64(R2) = stproc;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8365:
	asu64(R1) = stproc;
	asu64(R2) = procowner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8367;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 11;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8367:
	asu64(R1) = stproc;
	owner = asu64(R1);
	asu64(R1) = stproc;
	mm_parse_pushproc(asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L8369;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 6;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	mm_lex_lex();
L8369:
	R1 = 0;
	paramlist = asu64(R1);
	R1 = 0;
	R2 = (u64)&retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8371;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8373;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = procowner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L8373:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8376;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8375;
L8376:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
	goto L8374;
L8375:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8378;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8377;
L8378:
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L8377:
L8374:
	goto L8370;
L8371:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8380;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8379;
L8380:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L8379:
L8370:
	R1 = 0;
	mm_parse_dretvar = asu64(R1);
	asi64(R1) = nretvalues;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8382;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8384;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_parse_dretvar = asu64(R1);
	mm_lex_lex();
L8384:
L8382:
	asi64(R1) = nretvalues;
	if (asi64(R1)) goto L8386;
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) != asi64(R2)) goto L8386;
	R1 = tou64("Function needs ret type");
	mm_support_serror(asu64(R1));
L8386:
	asi64(R1) = nretvalues;
	if (!asi64(R1)) goto L8388;
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L8388;
	R1 = tou64("Proc can't return value");
	mm_support_serror(asu64(R1));
L8388:
	asu64(R1) = paramlist;
	asu64(R2) = stproc;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nretvalues;
	asu64(R2) = stproc;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nretvalues;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8390;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8391;
	goto L8392;
L8390:
	R1 = 0;
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L8389;
L8391:
	asu64(R1) = stproc;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&retmodes;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	goto L8389;
L8392:
	R1 = 0;
	asi64(R2) = nretvalues;
	R3 = (u64)&retmodes;
	asu64(R4) = procowner;
	asi64(R1) = mm_lib_createtuplemode(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8389:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8394;
	R1 = tou64("READPROCDEF @");
	mm_support_serror(asu64(R1));
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8394:
	R1 = 0;
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = varparams;
	asu64(R2) = stproc;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = procowner;
	asu64(R2) = mm_decls_stmodule;
	if (asu64(R1) != asu64(R2)) goto L8396;
	asu64(R1) = stproc;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8398;
	R1 = tou64("start");
	asu64(R2) = stproc;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8398;
	asu64(R1) = stproc;
	R2 = (u64)&mm_decls_modules;
	asu64(R3) = mm_decls_stmodule;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8399;
	goto L8397;
L8398:
	asu64(R1) = stproc;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8400;
	R1 = tou64("main");
	asu64(R2) = stproc;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8400;
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = mm_decls_stmodule;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	R1 = (u64)&mm_decls_subprogs;
	asu64(R2) = mm_decls_stmodule;
	R3 = 95;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = ps;
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L8402;
	R1 = tou64("More than one main() in SP");
	mm_support_serror(asu64(R1));
L8402:
	asu64(R1) = mm_decls_stmodule;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ps;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = stproc;
	asu64(R2) = ms;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ps;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L8404;
	R1 = 3;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
// mm_parse.readprocdecl.dosigcheck:
L8399:
	asu64(R1) = stproc;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L8407;
	asu64(R1) = stproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8406;
L8407:
	R1 = tou64("Wrong 'main/start' sig");
	mm_support_serror(asu64(R1));
L8406:
L8404:
L8400:
L8397:
L8396:
	mm_parse_popproc();
	asu64(R1) = stproc;
	goto L8357;
L8357:
	return asu64(R1);
}

static u64 mm_parse_readparams(u64 procowner, u64 owner, u64 varparams, u64 nparams) {
    u64 R1, R2, R3; 
	u64 stlist;
	u64 stlistx;
	u64 stname;
	i64 parammode;
	i64 pmode;
	i64 m;
	i64 isoptional;
	i64 types;
	struct $B18 str;
	R1 = 0;
	R2 = R1;
	stlistx = asu64(R2);
	stlist = asu64(R1);
	R1 = 0;
	pmode = asi64(R1);
	R1 = 0;
	asu64(R2) = nparams;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	parammode = asi64(R1);
	R1 = 0;
	types = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8410;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8411;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8410;
L8411:
	R1 = 1;
	types = asi64(R1);
L8410:
L8412:
	R1 = 0;
	parammode = asi64(R1);
	R1 = 0;
	isoptional = asi64(R1);
	asi64(R1) = types;
	if (asi64(R1)) goto L8416;
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8415;
L8416:
	R1 = 0;
	asu64(R2) = procowner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	pmode = asi64(R1);
// mm_parse.readparams.gotmode:
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8419;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8420;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8419;
L8420:
L8421:
	asu64(R1) = nparams;
	(*toi64p(R1)) += 1;
	R1 = 36;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = nparams;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 12;
	R2 = (u64)&str;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = pmode;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = parammode;
	asu64(R2) = stname;
	R3 = 160;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8424;
	goto L8425;
L8424:
	goto L8422;
	goto L8423;
L8425:
L8423:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L8427;
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = varparams;
	*toi64p(R2) = asi64(R1);
	mm_lex_lex();
	goto L8422;
L8427:
	R1 = 0;
	asu64(R2) = procowner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	pmode = asi64(R1);
	goto L8421;
L8422:
	asu64(R1) = stlist;
	goto L8408;
L8419:
	goto L8414;
L8415:
	asi64(R1) = pmode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8428;
	R1 = tou64("Type expected");
	mm_support_serror(asu64(R1));
L8428:
L8414:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8430;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L8431;
	goto L8432;
L8430:
	R1 = 1;
	parammode = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8434;
	mm_lex_lex();
L8434:
	goto L8429;
L8431:
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = varparams;
	*toi64p(R2) = asi64(R1);
	mm_lex_lex();
	asu64(R1) = stlist;
	goto L8408;
	goto L8429;
L8432:
L8429:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	asu64(R1) = nparams;
	(*toi64p(R1)) += 1;
	R1 = 12;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	mm_lex_lex();
	asi64(R1) = parammode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8436;
	R1 = 0;
	asi64(R2) = pmode;
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	goto L8435;
L8436:
	asi64(R1) = pmode;
	m = asi64(R1);
L8435:
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = parammode;
	asu64(R2) = stname;
	R3 = 160;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = isoptional;
	asu64(R2) = stname;
	R3 = 161;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8438;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8438;
	goto L8439;
L8438:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 171;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 161;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8437;
L8439:
L8437:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8441;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8442;
	goto L8443;
L8441:
	mm_lex_lex();
	goto L8440;
L8442:
	goto L8413;
	goto L8440;
L8443:
	R1 = tou64("nameparams1");
	mm_support_serror(asu64(R1));
L8440:
	goto L8412;
L8413:
	asu64(R1) = stlist;
	goto L8408;
L8408:
	return asu64(R1);
}

static u64 mm_parse_readcondsuffix(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L8446;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L8447;
	goto L8448;
L8446:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = mm_parse_readunit();
	asu64(R2) = mm_parse_fixcond(asu64(R2));
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L8445;
L8447:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	R2 = 17;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 63;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = q;
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L8445;
L8448:
	asu64(R1) = p;
L8445:
	goto L8444;
L8444:
	return asu64(R1);
}

static u64 mm_parse_readif() {
    u64 R1, R2, R3, R4; 
	i64 pos1;
	i64 kwd;
	u64 clist;
	u64 clistx;
	u64 plist;
	u64 plistx;
	u64 pelse;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos1 = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = 0;
	R2 = R1;
	pelse = asu64(R2);
	R2 = R1;
	plistx = asu64(R2);
	R2 = R1;
	plist = asu64(R2);
	R2 = R1;
	clistx = asu64(R2);
	clist = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L8451;
	mm_lex_lex();
L8451:
	goto L8452;
L8453:
	mm_lex_lex();
// mm_parse.readif.nextif:
L8452:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	R2 = (u64)&clistx;
	R3 = (u64)&clist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_parse_skipsemi();
	R1 = 82;
	mm_parse_checksymbollex(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8457;
	asu64(R1) = clist;
	asu64(R2) = clistx;
	if (asu64(R1) != asu64(R2)) goto L8459;
	asi64(R1) = kwd;
	R2 = 81;
	if (asi64(R1) != asi64(R2)) goto L8459;
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = mm_parse_readunit();
	asu64(R3) = clist;
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8449;
	goto L8458;
L8459:
	R1 = tou64("then: not allowed");
	mm_support_serror(asu64(R1));
L8458:
L8457:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	R2 = (u64)&plistx;
	R3 = (u64)&plist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L8453;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L8461;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L8462;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L8462;
	goto L8463;
L8461:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8460;
L8462:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readswitchcase();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L8460;
L8463:
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L8460:
	asu64(R1) = pelse;
	asu64(R2) = plist;
	asu64(R3) = clist;
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8449;
L8449:
	return asu64(R1);
}

static u64 mm_parse_readgoto(i64 gototag) {
    u64 R1, R2; 
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asi64(R2) = gototag;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L8464;
L8464:
	return asu64(R1);
}

static u64 mm_parse_readunless() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	u64 pcond;
	u64 pthen;
	u64 pelse;
	u64 p;
	u64 q;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	R1 = 82;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L8467;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	goto L8466;
L8467:
	R1 = 0;
	pelse = asu64(R1);
L8466:
	R1 = 0;
	R2 = 0;
	R3 = 88;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pelse;
	asu64(R2) = pthen;
	asu64(R3) = pcond;
	R4 = 17;
	asu64(R3) = mm_lib_createunit1(asi64(R4), asu64(R3));
	R4 = R3;
	q = asu64(R4);
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 63;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8465;
L8465:
	return asu64(R1);
}

static u64 mm_parse_readswitchcase() {
    u64 R1, R2, R3, R4; 
	i64 pos1;
	i64 kwd;
	i64 opc;
	i64 pos2;
	i64 rangeused;
	i64 nwhen;
	u64 pexpr;
	u64 pwhenlist;
	u64 pwhenlistx;
	u64 pwhen;
	u64 pwhenx;
	u64 pelse;
	u64 p;
	u64 pthen;
	u64 pwhenthen;
	u64 pjump;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos1 = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = 0;
	pjump = asu64(R1);
	mm_lex_lex();
	mm_parse_skipsemi();
	asi64(R1) = opc;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L8470;
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	pjump = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 1;
	asu64(R2) = mm_decls_currproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8470:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L8472;
	asi64(R1) = kwd;
	R2 = 104;
	if (asi64(R1) != asi64(R2)) goto L8474;
	R1 = tou64("switch expr missing");
	mm_support_serror(asu64(R1));
L8474:
	R1 = 0;
	pexpr = asu64(R1);
	goto L8471;
L8472:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pexpr = asu64(R1);
	asu64(R1) = pjump;
	asu64(R2) = pexpr;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8471:
	R1 = 0;
	R2 = R1;
	pwhenlistx = asu64(R2);
	pwhenlist = asu64(R1);
	R1 = 0;
	rangeused = asi64(R1);
	R1 = 0;
	nwhen = asi64(R1);
	mm_parse_skipsemi();
	goto L8476;
L8475:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos2 = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	pwhenx = asu64(R2);
	pwhen = asu64(R1);
L8478:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&nwhen;
	(*toi64p(R1)) += 1;
	asi64(R1) = pos2;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8481;
	R1 = 1;
	rangeused = asi64(R1);
L8481:
	asu64(R1) = p;
	R2 = (u64)&pwhenx;
	R3 = (u64)&pwhen;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8483;
	goto L8479;
L8483:
	mm_lex_lex();
	goto L8478;
L8479:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8485;
	R1 = 82;
	mm_parse_checksymbol(asi64(R1));
L8485:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pwhen;
	R3 = 85;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pwhenthen = asu64(R1);
	asi64(R1) = pos2;
	asu64(R2) = pwhenthen;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pwhenthen;
	R2 = (u64)&pwhenlistx;
	R3 = (u64)&pwhenlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8476:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L8475;
	asi64(R1) = opc;
	R2 = 107;
	if (asi64(R1) != asi64(R2)) goto L8487;
	asi64(R1) = rangeused;
	if (asi64(R1)) goto L8487;
	asi64(R1) = nwhen;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L8489;
	R1 = 105;
	opc = asi64(R1);
L8489:
L8487:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L8491;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L8492;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L8493;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L8493;
	goto L8494;
L8491:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8490;
L8492:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readif();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L8490;
L8493:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readswitchcase();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L8490;
L8494:
	R1 = 0;
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L8490:
	asu64(R1) = pelse;
	asu64(R2) = pwhenlist;
	asu64(R3) = pexpr;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8468;
L8468:
	return asu64(R1);
}

static u64 mm_parse_readstop() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	mm_lex_lex();
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8497;
	asu64(R1) = mm_parse_readunit();
	R2 = 120;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8496;
L8497:
	R1 = 120;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
L8496:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L8495;
L8495:
	return asu64(R1);
}

static u64 mm_parse_readreturn() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	mm_lex_lex();
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8500;
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 89;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8499;
L8500:
	R1 = 89;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8499:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L8498;
L8498:
	return asu64(R1);
}

static u64 mm_parse_readdo() {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 pos;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 96;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 104;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8501;
L8501:
	return asu64(R1);
}

static u64 mm_parse_readto() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	i64 id;
	u64 p;
	u64 pcount;
	u64 pbody;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pcount = asu64(R1);
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 96;
	R3 = 94;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 11;
	id = asi64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8504;
	R1 = 10;
	id = asi64(R1);
L8504:
	asi64(R1) = id;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = pbody;
	asu64(R3) = pcount;
	R4 = 91;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8502;
L8502:
	return asu64(R1);
}

static u64 mm_parse_readwhile() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	u64 pcond;
	u64 pbody;
	u64 pincr;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	R1 = 0;
	pincr = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8507;
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pincr = asu64(R1);
L8507:
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 96;
	R3 = 97;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pincr;
	asu64(R2) = pbody;
	asu64(R3) = pcond;
	R4 = 97;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8505;
L8505:
	return asu64(R1);
}

static u64 mm_parse_readrepeat() {
    u64 R1, R2, R3; 
	i64 pos;
	u64 pbody;
	u64 pcond;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 99;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 98;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8508;
L8508:
	return asu64(R1);
}

static u64 mm_parse_readloopcontrol() {
    u64 R1, R2, R3; 
	i64 opc;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8511;
	R1 = tou64("all");
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8511;
	mm_lex_lex();
	R1 = 3;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8510;
L8511:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8512;
	R1 = 1;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8510;
L8512:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L8510:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L8509;
L8509:
	return asu64(R1);
}

static u64 mm_parse_readprint() {
    u64 R1, R2, R3, R4; 
	i64 oldinreadprint;
	i64 opc;
	i64 isfprint;
	i64 fshowname;
	u64 pformat;
	u64 pdev;
	u64 printlist;
	u64 printlistx;
	u64 p;
	u64 q;
	u64 expr;
	u64 s;
	asi64(R1) = mm_parse_inreadprint;
	oldinreadprint = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	asi64(R1) = opc;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L8515;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L8515;
	goto L8516;
L8515:
	R1 = 1;
	isfprint = asi64(R1);
	goto L8514;
L8516:
	R1 = 0;
	isfprint = asi64(R1);
L8514:
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	printlistx = asu64(R2);
	printlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8518;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pdev = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8520;
	mm_lex_lex();
	goto L8519;
L8520:
	goto L8521;
L8519:
L8518:
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L8523;
	asu64(R1) = mm_parse_readunit();
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8525;
	mm_lex_lex();
	goto L8524;
L8525:
	goto L8521;
L8524:
L8523:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L8527;
	goto L8521;
L8527:
L8528:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8531;
	R2 = 130;
	if (asi64(R1) == asi64(R2)) goto L8532;
	goto L8533;
L8531:
	R1 = 87;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L8530;
L8532:
	R1 = 88;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_lex_lex();
	goto L8530;
L8533:
	R1 = 0;
	fshowname = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L8535;
	R1 = 1;
	fshowname = asi64(R1);
	mm_lex_lex();
L8535:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8537;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = p;
	R3 = 86;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8537:
	asi64(R1) = fshowname;
	if (!asi64(R1)) goto L8539;
	asu64(R1) = p;
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	expr = asu64(R1);
	R1 = -1;
	R2 = tou64("=");
	asu64(R3) = expr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = expr;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_iconvucn(asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	R2 = R1;
	q = asu64(R2);
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8539:
	asu64(R1) = p;
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8530:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8541;
	goto L8529;
L8541:
	mm_lex_lex();
	goto L8528;
L8529:
// mm_parse.readprint.finish:
L8521:
	asi64(R1) = oldinreadprint;
	mm_parse_inreadprint = asi64(R1);
	asi64(R1) = opc;
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L8543;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8543;
	R1 = tou64("No print items");
	mm_support_serror(asu64(R1));
L8543:
	asi64(R1) = opc;
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L8545;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8545;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8545;
	R1 = tou64("No print items");
	mm_support_serror(asu64(R1));
L8545:
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L8547;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8549;
	R1 = tou64("No fmt str");
	mm_support_serror(asu64(R1));
L8549:
	asu64(R1) = printlist;
	asu64(R2) = pformat;
	asu64(R3) = pdev;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L8546;
L8547:
	asu64(R1) = printlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
L8546:
	goto L8513;
L8513:
	return asu64(R1);
}

static u64 mm_parse_readread() {
    u64 R1, R2, R3; 
	i64 oldinreadprint;
	i64 opc;
	u64 pformat;
	u64 pdev;
	u64 readlist;
	u64 readlistx;
	u64 p;
	u64 pread;
	asi64(R1) = mm_parse_inreadprint;
	oldinreadprint = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	readlistx = asu64(R2);
	readlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8552;
	asi64(R1) = opc;
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L8554;
	R1 = tou64("@ on read");
	mm_support_serror(asu64(R1));
L8554:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pdev = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8556;
	mm_lex_lex();
L8556:
L8552:
	asi64(R1) = opc;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L8558;
	asu64(R1) = pdev;
	R2 = 119;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8558:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L8560;
	goto L8561;
L8560:
L8562:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8565;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pformat = asu64(R1);
	goto L8564;
L8565:
	R1 = 0;
	pformat = asu64(R1);
L8564:
	asu64(R1) = pformat;
	R2 = 118;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	pread = asu64(R1);
	asu64(R1) = pread;
	asu64(R2) = p;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8567;
	goto L8563;
L8567:
	mm_lex_lex();
	goto L8562;
L8563:
// mm_parse.readread.finish:
L8561:
	asi64(R1) = oldinreadprint;
	mm_parse_inreadprint = asi64(R1);
	asi64(R1) = opc;
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L8569;
	asu64(R1) = readlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8569;
	R1 = tou64("No read items");
	mm_support_serror(asu64(R1));
L8569:
	asu64(R1) = readlist;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L8550;
L8550:
	return asu64(R1);
}

static u64 mm_parse_readfor() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	i64 opc;
	u64 pindex;
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 pstep;
	u64 ptoinit;
	u64 plist;
	u64 passign;
	u64 pcond;
	u64 pbody;
	u64 pelse;
	u64 p;
	i64 i;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	plocal = asu64(R1);
	R1 = 0;
	ptoinit = asu64(R1);
	asu64(R1) = mm_parse_readname();
	pindex = asu64(R1);
	asi64(R1) = mm_parse_nforloops;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L8572;
	R1 = tou64("Too many for-loops");
	mm_support_serror(asu64(R1));
L8572:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_parse_nforloops;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8575;
L8573:
	R1 = (u64)&mm_parse_forindexvars;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pindex;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L8577;
	R1 = tou64("Re-using nested loop index");
	mm_support_serror(asu64(R1));
L8577:
	i += 1; if (i <= mm_parse_nforloops) goto L8573;
L8575:
	asu64(R1) = pindex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_parse_forindexvars;
	R3 = (u64)&mm_parse_nforloops;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8579;
	mm_lex_lex();
	asu64(R1) = mm_parse_readname();
	plocal = asu64(R1);
L8579:
	R1 = 93;
	opc = asi64(R1);
	R1 = 0;
	pstep = asu64(R1);
	R1 = 0;
	pcond = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L8582;
	R2 = 46;
	if (asi64(R1) != asi64(R2)) goto L8581;
L8582:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L8584;
	R1 = 94;
	opc = asi64(R1);
L8584:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	plist = asu64(R1);
	asu64(R1) = plist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8586;
	asu64(R1) = plist;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = plist;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	goto L8585;
L8586:
	asi64(R1) = opc;
	R2 = 93;
	if (asi64(R1) != asi64(R2)) goto L8588;
	R1 = 95;
	goto L8587;
L8588:
	R1 = 96;
L8587:
	opc = asi64(R1);
	R1 = 0;
	asu64(R2) = plist;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_getrangelwbunit(asu64(R1));
	pfrom = asu64(R1);
	R1 = 0;
	asu64(R2) = plist;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_getrangeupbunit(asu64(R1));
	pto = asu64(R1);
L8585:
	goto L8580;
L8581:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8590;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pfrom = asu64(R1);
	goto L8589;
L8590:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pfrom = asu64(R1);
L8589:
	R1 = 94;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8592;
	R1 = 94;
	goto L8591;
L8592:
	R1 = 93;
L8591:
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pto = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L8594;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	pstep = asu64(R1);
	asu64(R1) = pstep;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8596;
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8598;
	R1 = 0;
	pstep = asu64(R1);
L8598:
L8596:
L8594:
L8580:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L8600;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
L8600:
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	pelse = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L8602;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
L8602:
	R1 = 0;
	R2 = 96;
	R3 = 93;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pcond;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L8604;
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pbody = asu64(R1);
L8604:
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opc;
	R2 = 93;
	if (asi64(R1) == asi64(R2)) goto L8606;
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L8606;
	goto L8607;
L8606:
	asu64(R1) = plocal;
	if (!asu64(R1)) goto L8609;
	R1 = tou64("for i,x?");
	mm_support_serror(asu64(R1));
L8609:
	R1 = 73;
	asu64(R2) = pindex;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8611;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8611;
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	plocal = asu64(R1);
	R1 = 73;
	asu64(R2) = plocal;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pto;
	asu64(R2) = plocal;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	ptoinit = asu64(R1);
	asu64(R1) = ptoinit;
	asu64(R2) = pindex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = plocal;
	pto = asu64(R1);
L8611:
	asu64(R1) = pto;
	asu64(R2) = pfrom;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pstep;
	asu64(R2) = pto;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pfrom;
	asu64(R3) = pindex;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8605;
L8607:
	asu64(R1) = plocal;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8613;
	asu64(R1) = pindex;
	plocal = asu64(R1);
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	pindex = asu64(R1);
L8613:
	R1 = 73;
	asu64(R2) = pindex;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 76;
	asu64(R2) = plocal;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = plocal;
	asu64(R2) = pindex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pfrom;
	asu64(R2) = plocal;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pto;
	asu64(R2) = pfrom;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = pindex;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 0;
	asu64(R3) = plist;
	asu64(R2) = mm_lib_duplunit(asu64(R3), asi64(R2));
	R3 = 46;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	R2 = 0;
	asu64(R3) = plocal;
	asu64(R2) = mm_lib_duplunit(asu64(R3), asi64(R2));
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	asu64(R1) = passign;
	asu64(R2) = plist;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = plist;
	asu64(R3) = pindex;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8605:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mm_parse_nforloops;
	(*toi64p(R1)) -=1;
	asu64(R1) = p;
	goto L8570;
L8570:
	return asu64(R1);
}

static u64 mm_parse_readname() {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8616;
	R1 = tou64("Name expected");
	mm_support_serror(asu64(R1));
L8616:
	asu64(R1) = p;
	goto L8614;
L8614:
	return asu64(R1);
}

static void mm_parse_readtypedef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	u64 sttype;
	u64 stname;
	i64 t;
	i64 m;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 5;
	asu64(R2) = stname;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	sttype = asu64(R1);
	asu64(R1) = sttype;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = sttype;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	asu64(R2) = sttype;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = scope;
	asu64(R2) = sttype;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = sttype;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8619;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = t;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L8621;
	asi64(R1) = t;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L8620;
L8621:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8622;
	goto L8620;
L8622:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8624;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8625;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8626;
	goto L8627;
L8624:
	goto L8623;
L8625:
	goto L8623;
L8626:
	goto L8623;
L8627:
	asi64(R1) = t;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8623:
L8620:
	goto L8618;
L8619:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
L8618:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8629;
	asi64(R1) = t;
	asi64(R2) = m;
	mm_lib_copyttvalues(asi64(R2), asi64(R1));
	goto L8628;
L8629:
	R1 = 29;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8628:
	return;
}

static void mm_parse_readrecordfields(u64 owner, i64 m) {
    u64 R1, R2, R3; 
	i64 nvars;
	i64 offset;
	u64 stname;
	u64 stbitfield;
	R1 = 0;
	nvars = asi64(R1);
	goto L8632;
L8631:
	R1 = 13;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	R1 = (u64)&mm_parse_unionpend;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8635;
	R1 = (u64)&mm_parse_unionpend;
	asu64(R2) = stname;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_copy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	R2 = (u64)&mm_parse_unionstring;
	mm_lib_unionstr_concat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_clear(asu64(R1));
	goto L8634;
L8635:
	asu64(R1) = stname;
	R2 = 136;
	R1 += (i64)R2;
	mm_lib_unionstr_clear(asu64(R1));
L8634:
	asu64(R1) = stname;
	mm_parse_unionlastvar = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8637;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8638;
	goto L8639;
L8637:
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = owner;
	asu64(R1) = mm_parse_readequivfield(asu64(R1));
	asu64(R2) = stname;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L8641;
	mm_lex_lex();
	asi64(R1) = mm_parse_readconstint();
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 9223372036854775807;
	if (asi64(R1) <= asi64(R2)) goto L8643;
	R1 = tou64("Offset>255");
	mm_support_serror(asu64(R1));
L8643:
	asi64(R1) = offset;
	asu64(R2) = stname;
	R3 = 151;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8641:
	goto L8636;
L8638:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
L8644:
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = 13;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stbitfield = asu64(R1);
	R1 = 27;
	asu64(R2) = stbitfield;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = stbitfield;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = stbitfield;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = stname;
	asu64(R2) = stbitfield;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 5;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = 62;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = stbitfield;
	R3 = 148;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8644;
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	goto L8636;
L8639:
L8636:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8648;
	goto L8633;
L8648:
	mm_lex_lex();
L8632:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8631;
L8633:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8650;
	R1 = tou64("No fields declared");
	mm_support_serror(asu64(R1));
L8650:
	return;
}

static void mm_parse_readtabledef(u64 owner, i64 scope) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 ncols;
	i64 nrows;
	i64 enums;
	i64 nextenumvalue;
	i64 firstval;
	i64 lastval;
	i64 startline;
	i64 closesym;
	i64 ltype;
	u64 stvar;
	u64 stenum;
	u64 stgen;
	struct $B30 varnameptrs;
	struct $B30 varlisttypes;
	struct $B30 plist;
	struct $B30 plistx;
	struct $B44 enumvalues;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	enums = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	mm_parse_tabledataname = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8653;
	asi64(R1) = enums;
	if (asi64(R1)) goto L8655;
	R1 = tou64("Use 'enumdata'");
	mm_support_serror(asu64(R1));
L8655:
	R1 = 1;
	enums = asi64(R1);
	mm_lex_lex();
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
L8653:
	R1 = 1;
	nextenumvalue = asi64(R1);
	R1 = 0;
	nrows = asi64(R1);
	R1 = 0;
	ncols = asi64(R1);
	goto L8657;
L8656:
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	ltype = asi64(R1);
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&ncols;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L8660;
	R1 = tou64("tabledata/too many columns");
	mm_support_serror(asu64(R1));
L8660:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&varnameptrs;
	asi64(R3) = ncols;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = ltype;
	R2 = (u64)&varlisttypes;
	asi64(R3) = ncols;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8662;
	mm_lex_lex();
	goto L8661;
L8662:
	goto L8658;
L8661:
L8657:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L8656;
L8658:
	mm_lex_lex();
	mm_parse_skipsemi();
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	mm_parse_skipsemi();
	R1 = 0;
	R2 = R1;
	lastval = asi64(R2);
	firstval = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8665;
L8663:
	R1 = 0;
	R2 = R1;
	R3 = (u64)&plistx;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	R2 = (u64)&plist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= ncols) goto L8663;
L8665:
	R1 = 1;
	mm_parse_intabledata = asi64(R1);
L8666:
	mm_parse_skipsemi();
	asi64(R1) = ncols;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8669;
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
L8669:
	R1 = (u64)&nrows;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L8671;
	R1 = tou64("tabledata:too many rows");
	mm_support_serror(asu64(R1));
L8671:
	asi64(R1) = enums;
	if (!asi64(R1)) goto L8673;
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stgen = asu64(R1);
	asu64(R1) = stgen;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_parse_tabledataname = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L8675;
	asi64(R1) = nrows;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8677;
	R1 = tou64("enum=x, 1st row only");
	mm_support_serror(asu64(R1));
L8677:
	mm_lex_lex();
	asi64(R1) = mm_parse_readconstint();
	nextenumvalue = asi64(R1);
L8675:
	asi64(R1) = nextenumvalue;
	R2 = (u64)&enumvalues;
	asi64(R3) = nrows;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 9;
	asu64(R2) = stgen;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stenum = asu64(R1);
	R1 = 3;
	asu64(R2) = stenum;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 3;
	asi64(R2) = nextenumvalue;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = stenum;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stenum;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stenum;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8679;
	asu64(R1) = stenum;
	mm_lib_addexpconst(asu64(R1));
L8679:
	asi64(R1) = nrows;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8681;
	asi64(R1) = nextenumvalue;
	firstval = asi64(R1);
L8681:
	asi64(R1) = nextenumvalue;
	lastval = asi64(R1);
	R1 = (u64)&nextenumvalue;
	(*toi64p(R1)) += 1;
	asi64(R1) = ncols;
	if (!asi64(R1)) goto L8683;
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
L8683:
L8673:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8686;
L8684:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&plistx;
	asi64(R3) = i;
	R2 += (i64)R3*8-8;
	R3 = (u64)&plist;
	asi64(R4) = i;
	R3 += (i64)R4*8-8;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = ncols;
	if (asi64(R1) != asi64(R2)) goto L8688;
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	goto L8687;
L8688:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
L8687:
	i += 1; if (i <= ncols) goto L8684;
L8686:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8690;
	goto L8667;
L8690:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = closesym;
	if (asi64(R1) != asi64(R2)) goto L8692;
	goto L8667;
L8692:
	goto L8666;
L8667:
	R1 = 0;
	mm_parse_intabledata = asi64(R1);
	mm_parse_skipsemi();
	asi64(R1) = startline;
	R2 = 132;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nrows;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8694;
	R1 = tou64("No table data");
	mm_support_serror(asu64(R1));
L8694:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8697;
L8695:
	R1 = 10;
	R2 = (u64)&varnameptrs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stvar = asu64(R1);
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = stvar;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nrows;
	asu64(R2) = stvar;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = stvar;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 9;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = stvar;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&varlisttypes;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = scope;
	asu64(R2) = stvar;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stvar;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stvar;
	mm_lib_addstatic(asu64(R1));
	i += 1; if (i <= ncols) goto L8695;
L8697:
	return;
}

static void mm_parse_readclassdef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	i64 kwd;
	i64 baseclass;
	i64 m;
	i64 startline;
	i64 closesym;
	i64 mrec;
	i64 isrecord;
	i64 align;
	u64 nameptr;
	u64 sttype;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	asi64(R1) = kwd;
	R2 = 111;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isrecord = asi64(R1);
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	mm_lex_lex();
	R1 = 0;
	baseclass = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8700;
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	baseclass = asi64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
L8700:
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 0;
	align = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8702;
	mm_lex_lex();
	R1 = 1;
	align = asi64(R1);
L8702:
	R1 = 5;
	asu64(R2) = nameptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	sttype = asu64(R1);
	asu64(R1) = sttype;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = sttype;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	asi64(R1) = m;
	asu64(R2) = owner;
	asi64(R1) = mm_lib_createrecordmode(asu64(R2), asi64(R1));
	mrec = asi64(R1);
	asu64(R1) = sttype;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = mrec;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = sttype;
	R2 = 144;
	R1 += (i64)R2;
	asi64(R2) = baseclass;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = align;
	asu64(R2) = sttype;
	R3 = 149;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	asi64(R1) = kwd;
	asu64(R2) = sttype;
	mm_parse_readclassbody(asu64(R2), asi64(R1));
	asi64(R1) = startline;
	asi64(R2) = kwd;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = scope;
	asu64(R2) = sttype;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_parse_readclassbody(u64 owner, i64 classkwd) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 t;
	i64 lbcount;
	R1 = 0;
	lbcount = asi64(R1);
	R1 = (u64)&mm_parse_unionstring;
	mm_lib_unionstr_clear(asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_clear(asu64(R1));
L8704:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L8706;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L8707;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L8707;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L8708;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L8709;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L8710;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8711;
	R2 = 132;
	if (asi64(R1) == asi64(R2)) goto L8712;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L8713;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L8714;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L8714;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L8715;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8715;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L8716;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L8717;
	goto L8718;
L8706:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L8704;
L8707:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	asu64(R1) = owner;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L8720;
	R1 = 0;
	asu64(R2) = owner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	goto L8719;
L8720:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
L8719:
	goto L8704;
L8708:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L8704;
L8709:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L8704;
L8710:
	R1 = tou64("Class eof?");
	mm_support_serror(asu64(R1));
	goto L8705;
	goto L8704;
L8711:
	mm_lex_lex();
	goto L8704;
L8712:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	goto L8704;
L8713:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	goto L8704;
L8714:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 112;
	if (asi64(R1) != asi64(R2)) goto L8722;
	R1 = 83;
	goto L8721;
L8722:
	R1 = 85;
L8721:
	R2 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
	R1 = 0;
	mm_parse_unionlastvar = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8724;
	R1 = (u64)&lbcount;
	(*toi64p(R1)) += 1;
	mm_lex_lex();
L8724:
	goto L8704;
L8715:
	R1 = (u64)&mm_parse_unionstring;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8726;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8728;
	asi64(R1) = lbcount;
	if (!asi64(R1)) goto L8728;
	mm_lex_lex();
	R1 = (u64)&lbcount;
	(*toi64p(R1)) -=1;
	goto L8727;
L8728:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&mm_parse_unionstring;
	asi64(R3) = mm_lib_unionstr_last(asu64(R3));
	R4 = 83;
	if (asi64(R3) != asi64(R4)) goto L8730;
	R3 = 112;
	goto L8729;
L8730:
	R3 = 113;
L8729:
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L8727:
	asu64(R1) = mm_parse_unionlastvar;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L8733;
	R1 = (u64)&mm_parse_unionpend;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8732;
L8733:
	R1 = tou64("Empty union group");
	mm_support_serror(asu64(R1));
L8732:
	asu64(R1) = mm_parse_unionlastvar;
	R2 = 136;
	R1 += (i64)R2;
	asi64(R1) = mm_lib_unionstr_last(asu64(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L8735;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L8735;
	goto L8736;
L8735:
	goto L8734;
L8736:
	R1 = 42;
	asu64(R2) = mm_parse_unionlastvar;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
L8734:
	R1 = 69;
	asu64(R2) = mm_parse_unionlastvar;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
	R1 = (u64)&mm_parse_unionstring;
	R2 = 7;
	R1 += (i64)R2;
	(*tou8p(R1)) -=1;
	goto L8725;
L8726:
	goto L8705;
L8725:
	goto L8704;
L8716:
	mm_lex_lex();
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8738;
// mm_parse.readclassbody.readmut:
L8739:
	R1 = (u64)&mm_parse_insiderecord;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	R1 = (u64)&mm_parse_insiderecord;
	(*toi64p(R1)) -=1;
	goto L8737;
L8738:
	R1 = 22;
	t = asi64(R1);
L8737:
	asi64(R1) = t;
	asu64(R2) = owner;
	mm_parse_readrecordfields(asu64(R2), asi64(R1));
	goto L8704;
L8717:
	R1 = tou64("Let not allowed");
	mm_support_serror(asu64(R1));
	goto L8704;
L8718:
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8741;
	goto L8739;
	goto L8740;
L8741:
	goto L8705;
L8740:
	goto L8704;
L8705:
	asi64(R1) = lbcount;
	if (!asi64(R1)) goto L8743;
	R1 = tou64("LB?");
	mm_support_serror(asu64(R1));
L8743:
	return;
}

static void mm_parse_readimportmodule(u64 owner) {
    u64 R1, R2, R3; 
	i64 isnew;
	i64 startline;
	i64 closesym;
	u64 stname;
	u64 stname0;
	i64 i;
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L8746;
	R1 = tou64("nested importdll");
	mm_support_serror(asu64(R1));
L8746:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L8748;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	stname = asu64(R1);
	goto L8747;
L8748:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
L8747:
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 1;
	isnew = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8751;
L8749:
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_libfiles;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8753;
	R1 = 0;
	isnew = asi64(R1);
	goto L8751;
L8753:
	i += 1; if (i <= mm_decls_nlibfiles) goto L8749;
L8751:
	asi64(R1) = isnew;
	if (!asi64(R1)) goto L8755;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_modules_addlib(asu64(R1));
L8755:
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	R1 = 1;
	mm_parse_insidedllimport = asi64(R1);
	asu64(R1) = owner;
	mm_parse_readimportbody(asu64(R1));
	R1 = 0;
	mm_parse_insidedllimport = asi64(R1);
	asi64(R1) = startline;
	R2 = 114;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_parse_readimportbody(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	i64 pos;
	u64 d;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
L8757:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L8760;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L8760;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L8761;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L8762;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L8763;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L8764;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L8765;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8765;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L8765;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L8765;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8765;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L8765;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L8766;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L8767;
	goto L8768;
L8760:
// mm_parse.readimportbody.doproc:
	R1 = 0;
	asu64(R2) = owner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = mm_decls_ndllproctable;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L8771;
	R1 = tou64("Too many dll procs");
	mm_support_serror(asu64(R1));
L8771:
	asu64(R1) = d;
	R2 = (u64)&mm_decls_dllproctable;
	R3 = (u64)&mm_decls_ndllproctable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L8759;
L8761:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L8759;
L8762:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L8759;
L8763:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L8759;
L8764:
	mm_lex_lex();
	R1 = 119;
	R2 = 8;
	R3 = 0;
	R4 = 1;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8759;
L8765:
	R1 = 0;
	R2 = 8;
	R3 = 0;
	R4 = 1;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8759;
L8766:
	goto L8758;
	goto L8759;
L8767:
	goto L8758;
	goto L8759;
L8768:
	R1 = tou64("symbol");
	mm_lex_ps(asu64(R1));
	R1 = tou64("Not allowed in importmodule");
	mm_support_serror(asu64(R1));
L8759:
	goto L8757;
L8758:
	return;
}

static u64 mm_parse_readequivfield(u64 owner) {
    u64 R1, R2, R3; 
	u64 p;
	u64 d;
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	mm_lex_lex();
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L8774;
L8773:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8777;
	asu64(R1) = p;
	goto L8772;
L8777:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L8774:
	asu64(R1) = p;
	if (asu64(R1)) goto L8773;
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find @ field");
	mm_support_serror(asu64(R1));
	R1 = 0;
	goto L8772;
L8772:
	return asu64(R1);
}

static i64 mm_parse_readrefproc(u64 owner, i64 typedefx) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 kwd;
	i64 prettype;
	i64 m;
	i64 varparams;
	i64 nparams;
	struct $B18 retmodes;
	u64 paramlist;
	u64 stproc;
	i64 rettype2;
	i64 rettype3;
	i64 nretvalues;
	u64 name;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	paramlist = asu64(R1);
	R1 = 0;
	prettype = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = 0;
	varparams = asi64(R1);
	asu64(R1) = mm_lib_nextautotype();
	name = asu64(R1);
	R1 = 5;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stmodule;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asu64(R1) = stproc;
	asu64(R2) = mm_decls_stmodule;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) != asi64(R2)) goto L8780;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8782;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8784;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = owner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L8784:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8787;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8786;
L8787:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
	goto L8785;
L8786:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8789;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8788;
L8789:
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L8788:
L8785:
	goto L8781;
L8782:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8791;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8790;
L8791:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L8790:
L8781:
	asi64(R1) = nretvalues;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8793;
	R1 = tou64("Function needs return type");
	mm_support_serror(asu64(R1));
L8793:
	asi64(R1) = nretvalues;
	if (!asi64(R1)) goto L8795;
	asi64(R1) = kwd;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L8795;
	R1 = tou64("Proc can't return value");
	mm_support_serror(asu64(R1));
L8795:
	goto L8779;
L8780:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8797;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8799;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = owner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L8799:
	mm_lex_lex();
L8797:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8802;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8802;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8801;
L8802:
	R1 = tou64("proc can't have ret value");
	mm_support_serror(asu64(R1));
L8801:
L8779:
	asi64(R1) = typedefx;
	asi64(R2) = prettype;
	asi64(R3) = kwd;
	asu64(R4) = paramlist;
	asu64(R5) = stproc;
	asu64(R6) = owner;
	asi64(R1) = mm_lib_createrefprocmode(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	asu64(R1) = stproc;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&retmodes;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = nretvalues;
	asu64(R2) = stproc;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stproc;
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = varparams;
	asu64(R2) = stproc;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L8778;
L8778:
	return asi64(R1);
}

static void mm_parse_pushproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_parse_nprocstack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L8805;
	R1 = tou64("Too many nested proc");
	mm_support_serror(asu64(R1));
L8805:
	asu64(R1) = mm_decls_currproc;
	R2 = (u64)&mm_parse_procstack;
	R3 = (u64)&mm_parse_nprocstack;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	mm_decls_currproc = asu64(R1);
	return;
}

static void mm_parse_popproc() {
    u64 R1, R2, R3; 
	asi64(R1) = mm_parse_nprocstack;
	if (!asi64(R1)) goto L8808;
	R1 = (u64)&mm_parse_procstack;
	R2 = (u64)&mm_parse_nprocstack;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_decls_currproc = asu64(R1);
	goto L8807;
L8808:
	asu64(R1) = mm_decls_stmodule;
	mm_decls_currproc = asu64(R1);
L8807:
	return;
}

static i64 mm_parse_readreturntype(u64 owner, u64 retmodes) {
    u64 R1, R2, R3; 
	i64 nretvalues;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	asu64(R2) = retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 1;
	nretvalues = asi64(R1);
	goto L8811;
L8810:
	asi64(R1) = nretvalues;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L8814;
	R1 = tou64("Too many return values");
	mm_support_serror(asu64(R1));
L8814:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	asu64(R2) = retmodes;
	R3 = (u64)&nretvalues;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L8811:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8810;
	asi64(R1) = nretvalues;
	goto L8809;
L8809:
	return asi64(R1);
}

static u64 mm_parse_readset() {
    u64 R1, R2, R3; 
	i64 length;
	i64 nkeyvalues;
	i64 oldirp;
	u64 p;
	u64 ulist;
	u64 ulistx;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8817;
	goto L8818;
L8817:
	mm_lex_lex();
	R1 = 0;
	R2 = 22;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L8815;
	goto L8816;
L8818:
L8816:
	R1 = 0;
	length = asi64(R1);
	R1 = 0;
	nkeyvalues = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L8819:
	asi64(R1) = mm_parse_inreadprint;
	oldirp = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	asi64(R1) = oldirp;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L8822;
	R1 = (u64)&nkeyvalues;
	(*toi64p(R1)) += 1;
L8822:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8824;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8825;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8826;
	goto L8827;
L8824:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L8829;
	goto L8820;
L8829:
	goto L8823;
L8825:
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L8820;
	goto L8823;
L8826:
	goto L8820;
	goto L8823;
L8827:
	R1 = tou64("readset?");
	mm_support_serror(asu64(R1));
L8823:
	mm_parse_skipsemi();
	goto L8819;
L8820:
	mm_lex_lex();
	asi64(R1) = nkeyvalues;
	if (!asi64(R1)) goto L8831;
	asi64(R1) = length;
	asi64(R2) = nkeyvalues;
	if (asi64(R1) <= asi64(R2)) goto L8833;
	R1 = tou64("dict: mixed elements");
	mm_support_serror(asu64(R1));
L8833:
	asu64(R1) = ulist;
	R2 = 23;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8830;
L8831:
	asu64(R1) = ulist;
	R2 = 22;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L8830:
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8815;
L8815:
	return asu64(R1);
}

static i64 mm_parse_istypestarter() {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8836;
	R1 = 1;
	goto L8834;
L8836:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8838;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8840;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8841;
	goto L8842;
L8840:
	R1 = 1;
	goto L8834;
	goto L8839;
L8841:
	R1 = 1;
	goto L8834;
	goto L8839;
L8842:
L8839:
L8838:
	R1 = 0;
	goto L8834;
L8834:
	return asi64(R1);
}

static u64 mm_parse_readunit() {
    u64 R1, R2, R3; 
	u64 p;
	u64 pt;
	i64 pos;
	R1 = 0;
	pt = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	asu64(R1) = mm_parse_readterm2();
	pt = asu64(R1);
	R1 = (u64)&mm_tables_jisexpr;
	asu64(R2) = pt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8845;
	asu64(R1) = pt;
	goto L8843;
L8845:
	R1 = (u64)&mm_tables_endsexpr;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8847;
	asu64(R1) = pt;
	goto L8843;
L8847:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8849;
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	R1 = (u64)&mm_tables_endsexpr;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8851;
	asu64(R1) = p;
	asu64(R2) = pt;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8843;
L8851:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = pt;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8848;
L8849:
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8848:
	goto L8853;
L8852:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 0;
	asu64(R2) = mm_parse_readassignment(asu64(R2));
	R3 = 32;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8853:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8852;
	asu64(R1) = p;
	goto L8843;
L8843:
	return asu64(R1);
}

static u64 mm_parse_readassignment(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	u64 q;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readorterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8857;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8857:
	asu64(R1) = p;
	goto L8855;
L8855:
	return asu64(R1);
}

static u64 mm_parse_readorterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readandterms(asu64(R1));
	p = asu64(R1);
	goto L8860;
L8859:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8863;
	R1 = tou64("OR:=");
	mm_support_serror(asu64(R1));
L8863:
	R1 = 0;
	asu64(R1) = mm_parse_readandterms(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8860:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L8859;
	asu64(R1) = p;
	goto L8858;
L8858:
	return asu64(R1);
}

static u64 mm_parse_readandterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readcmpterms(asu64(R1));
	p = asu64(R1);
	goto L8866;
L8865:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8869;
	R1 = tou64("AND:=");
	mm_support_serror(asu64(R1));
L8869:
	R1 = 0;
	asu64(R1) = mm_parse_readcmpterms(asu64(R1));
	asu64(R2) = p;
	R3 = 15;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8866:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L8865;
	asu64(R1) = p;
	goto L8864;
L8864:
	return asu64(R1);
}

static u64 mm_parse_readcmpterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	i64 n;
	u64 ulist;
	u64 ulistx;
	u64 q;
	u32 genops;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readinterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8872;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L8872;
	asu64(R1) = p;
	goto L8870;
L8872:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asu64(R1) = p;
	R2 = 34;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = (u64)&genops;
	memset(R1, 0, 4);
L8873:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8875;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L8875;
	goto L8876;
L8875:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L8878;
	R1 = tou64("cmpchain: Too many items");
	mm_support_serror(asu64(R1));
L8878:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&genops;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readinterms(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pos;
	asu64(R2) = q;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8873;
L8876:
	goto L8874;
	goto L8873;
L8874:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8880;
	R1 = 33;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&genops;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 64;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8879;
L8880:
	asu32(R1) = genops;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8879:
	asu64(R1) = p;
	goto L8870;
L8870:
	return asu64(R1);
}

static u64 mm_parse_readinterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readrangeterm(asu64(R1));
	p = asu64(R1);
L8882:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L8884;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L8884;
	goto L8885;
L8884:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readrangeterm(asu64(R1));
	asu64(R2) = p;
	R3 = 41;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8882;
L8885:
	goto L8883;
	goto L8882;
L8883:
	asu64(R1) = p;
	goto L8881;
L8881:
	return asu64(R1);
}

static u64 mm_parse_readrangeterm(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readaddterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8888;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readaddterms(asu64(R1));
	asu64(R2) = p;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8888:
	asu64(R1) = p;
	goto L8886;
L8886:
	return asu64(R1);
}

static u64 mm_parse_readaddterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 sym;
	i64 tag;
	i64 genop;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readmulterms(asu64(R1));
	p = asu64(R1);
L8890:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	sym = asi64(R2);
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L8892;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L8892;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L8892;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L8892;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8892;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L8892;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L8892;
	goto L8893;
L8892:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	genop = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8895;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 38;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8891;
L8895:
	R1 = 0;
	asu64(R1) = mm_parse_readmulterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8890;
L8893:
	goto L8891;
	goto L8890;
L8891:
	asu64(R1) = p;
	goto L8889;
L8889:
	return asu64(R1);
}

static u64 mm_parse_readmulterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 sym;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	p = asu64(R1);
L8897:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	sym = asi64(R2);
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L8899;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L8899;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8899;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L8899;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L8899;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L8899;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L8899;
	goto L8900;
L8899:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8902;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 38;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8898;
L8902:
	R1 = 0;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8897;
L8900:
	goto L8898;
	goto L8897;
L8898:
	asu64(R1) = p;
	goto L8896;
L8896:
	return asu64(R1);
}

static u64 mm_parse_readpowerterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8905;
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
L8905:
	goto L8907;
L8906:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 82;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8907:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L8906;
	asu64(R1) = p;
	goto L8903;
L8903:
	return asu64(R1);
}

static u64 mm_parse_readterm2() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	u64 pbyte;
	u64 a;
	i64 oldipl;
	i64 opc;
	i64 oldinrp;
	i64 pos;
	i64 shift;
	i64 t;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	asu64(R1) = mm_parse_readterm();
	p = asu64(R1);
L8910:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8912;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8913;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8914;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8915;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8916;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L8917;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8918;
	goto L8919;
L8912:
	mm_lex_lex();
	asi64(R1) = mm_parse_inreadprint;
	oldinrp = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 1;
	R2 = 1;
	asu64(R1) = mm_parse_readslist(asi64(R2), asi64(R1));
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 90;
	if (asi64(R1) != asi64(R2)) goto L8921;
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8920;
L8921:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 32;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8920:
	asi64(R1) = oldinrp;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	p = asu64(R1);
	goto L8910;
L8913:
	asu64(R1) = p;
	R2 = 53;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L8910;
L8914:
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L8910;
L8915:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readdotsuffix(asu64(R1));
	p = asu64(R1);
	goto L8910;
L8916:
	asi64(R1) = mm_parse_inreadprint;
	if (!asi64(R1)) goto L8923;
	goto L8911;
L8923:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = mm_parse_inparamlist;
	if (!asi64(R3)) goto L8925;
	R3 = 26;
	goto L8924;
L8925:
	R3 = 27;
L8924:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8910;
L8917:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L8927;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L8928;
	goto L8929;
L8927:
	R1 = 88;
	opc = asi64(R1);
	goto L8926;
L8928:
	R1 = 89;
	opc = asi64(R1);
	goto L8926;
L8929:
L8926:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8910;
L8918:
	R1 = tou64("X{...} not ready");
	mm_support_serror(asu64(R1));
	goto L8910;
L8919:
	goto L8911;
	goto L8910;
L8911:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8909;
L8909:
	return asu64(R1);
}

static u64 mm_parse_readterm() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	u64 a;
	i64 opc;
	i64 pos;
	i64 length;
	u8 strtype;
	u64 s;
	struct $B16 cstr;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: goto L8960;
	case 3: case 4: case 5: case 6: case 7: case 8: case 10: case 12: case 14: case 15: case 16: case 17: case 18: case 21: case 22: case 23: case 26: case 27: case 28: case 29: case 30: case 34: case 35: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 54: case 57: case 58: case 59: case 60: case 66: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 82: case 83: case 84: case 85: case 86: case 87: case 92: case 95: case 99: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 118: case 119: case 120: case 122: case 123: case 125: case 126: case 127: case 132: goto L8933;
	case 9: goto L8944;
	case 11: goto L8953;
	case 13: goto L8998;
	case 19: case 20: goto L8955;
	case 24: case 25: case 31: case 32: case 33: case 36: case 37: case 49: case 50: case 51: case 52: case 53: case 55: case 56: goto L8946;
	case 47: goto L8947;
	case 48: goto L8950;
	case 61: goto L8954;
	case 62: case 63: goto L8937;
	case 64: goto L8939;
	case 65: goto L8938;
	case 67: goto L8934;
	case 69: goto L8996;
	case 79: case 80: case 117: goto L8945;
	case 81: goto L8976;
	case 88: goto L8977;
	case 89: case 90: case 104: case 105: goto L8978;
	case 91: goto L8979;
	case 93: goto L8980;
	case 94: goto L8981;
	case 96: goto L8982;
	case 97: goto L8983;
	case 98: goto L8984;
	case 100: goto L8986;
	case 101: goto L8987;
	case 102: goto L8985;
	case 103: goto L8975;
	case 106: goto L8988;
	case 107: goto L8989;
	case 121: goto L8999;
	case 124: goto L8997;
	case 128: goto L8971;
	case 129: goto L8961;
	case 130: goto L8962;
	case 131: goto L8991;
	case 133: goto L8972;
	case 134: goto L8990;
	case 135: goto L8992;
	case 136: goto L8995;
	default: goto L8933;
    };
// SWITCH
L8934:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8936;
	asu64(R1) = mm_parse_readcast();
	p = asu64(R1);
	goto L8935;
L8936:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_createname(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	mm_lex_lex();
L8935:
	goto L8931;
L8937:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L8931;
L8938:
	R1 = (u64)&mm_decls_lx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	goto L8931;
L8939:
	R1 = (u64)&mm_decls_lx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L8941;
	R1 = tou64("Char const too long");
	mm_support_serror(asu64(R1));
L8941:
	R1 = 0;
	a = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L8943;
	asi64(R1) = length;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&a;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L8943:
	R1 = 5;
	asu64(R2) = a;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L8931;
L8944:
	asu64(R1) = mm_parse_readlbrack();
	p = asu64(R1);
	goto L8931;
L8945:
	asu64(R1) = mm_parse_readcast();
	p = asu64(R1);
	goto L8931;
L8946:
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L8931;
L8947:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8949;
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L8948;
L8949:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 17;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 63;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8948:
	goto L8931;
L8950:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8952;
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L8951;
L8952:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 18;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L8951:
	goto L8931;
L8953:
	asu64(R1) = mm_parse_readset();
	p = asu64(R1);
	goto L8931;
L8954:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 40;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8931;
L8955:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) != asi64(R2)) goto L8957;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8959;
	R1 = tou64("Params not allowed");
	mm_support_serror(asu64(R1));
L8959:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8957:
	goto L8931;
L8960:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 56;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8931;
L8961:
	asu64(R1) = mm_parse_readcompilervar();
	p = asu64(R1);
	goto L8931;
L8962:
	asi64(R1) = mm_parse_intabledata;
	if (!asi64(R1)) goto L8964;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8966;
	R1 = 0;
	R2 = (u64)&cstr;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_parse_tabledataname;
	R2 = (u64)&cstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&cstr;
	R3 = 1;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L8965;
L8966:
	asu64(R1) = mm_parse_tabledataname;
	s = asu64(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L8968;
	mm_lex_lex();
	mm_lex_lex();
	R1 = 62;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L8968:
	R1 = -1;
	asu64(R2) = s;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
L8965:
	goto L8963;
L8964:
	asi64(R1) = mm_parse_ndollar;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L8970;
	R1 = tou64("[$] No array");
	mm_support_serror(asu64(R1));
L8970:
	R1 = (u64)&mm_parse_dollarstack;
	asi64(R2) = mm_parse_ndollar;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8963:
	mm_lex_lex();
	goto L8931;
L8971:
	asu64(R1) = mm_parse_readcastx();
	p = asu64(R1);
	goto L8931;
L8972:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8974;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8974;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L8973;
L8974:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L8973:
	mm_lex_lex();
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 56;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 55;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8931;
L8975:
	R1 = 99;
	asu64(R1) = mm_parse_readgoto(asi64(R1));
	p = asu64(R1);
	goto L8931;
L8976:
	asu64(R1) = mm_parse_readif();
	p = asu64(R1);
	goto L8931;
L8977:
	asu64(R1) = mm_parse_readunless();
	p = asu64(R1);
	goto L8931;
L8978:
	asu64(R1) = mm_parse_readswitchcase();
	p = asu64(R1);
	goto L8931;
L8979:
	asu64(R1) = mm_parse_readrecase();
	p = asu64(R1);
	goto L8931;
L8980:
	asu64(R1) = mm_parse_readfor();
	p = asu64(R1);
	goto L8931;
L8981:
	asu64(R1) = mm_parse_readto();
	p = asu64(R1);
	goto L8931;
L8982:
	asu64(R1) = mm_parse_readdo();
	p = asu64(R1);
	goto L8931;
L8983:
	asu64(R1) = mm_parse_readwhile();
	p = asu64(R1);
	goto L8931;
L8984:
	asu64(R1) = mm_parse_readrepeat();
	p = asu64(R1);
	goto L8931;
L8985:
	asu64(R1) = mm_parse_readloopcontrol();
	p = asu64(R1);
	goto L8931;
L8986:
	asu64(R1) = mm_parse_readreturn();
	p = asu64(R1);
	goto L8931;
L8987:
	asu64(R1) = mm_parse_readstop();
	p = asu64(R1);
	goto L8931;
L8988:
	asu64(R1) = mm_parse_readprint();
	p = asu64(R1);
	goto L8931;
L8989:
	asu64(R1) = mm_parse_readread();
	p = asu64(R1);
	goto L8931;
L8990:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 111;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8931;
L8991:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	R2 = 121;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8931;
L8992:
	R1 = 1;
	asu64(R2) = mm_decls_currproc;
	R3 = 120;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	mm_decls_assemmode = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8994;
	asu64(R1) = mm_assem_readassemline();
	p = asu64(R1);
	goto L8993;
L8994:
	asu64(R1) = mm_assem_readassemblock();
	p = asu64(R1);
L8993:
	R1 = 0;
	mm_decls_assemmode = asi64(R1);
	goto L8931;
L8995:
	R1 = 90;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	goto L8931;
L8996:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	strtype = asu8(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 13;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu8(R1) = strtype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8931;
L8997:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 122;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8931;
L8998:
	R1 = tou64("{...} not ready");
	mm_support_serror(asu64(R1));
	goto L8931;
L8999:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 24;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8931;
L8933:
// mm_parse.readterm.doelse:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("LX.SYMBOL=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mm_parse_istypestarter();
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("readterm?");
	mm_support_serror(asu64(R1));
L8931:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8930;
L8930:
	return asu64(R1);
}

static void mm_parse_readmacrodef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	u64 nameptr;
	u64 stmacro;
	u64 paramlist;
	u64 paramlistx;
	u64 stname;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	R1 = 15;
	asu64(R2) = nameptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stmacro = asu64(R1);
	asu64(R1) = stmacro;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stmacro;
	owner = asu64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	paramlistx = asu64(R2);
	paramlist = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L9003;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9005;
L9006:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L9009;
	goto L9010;
L9009:
	R1 = 16;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	R2 = (u64)&paramlistx;
	R3 = (u64)&paramlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9012;
	goto L9007;
L9012:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	goto L9008;
L9010:
	R1 = tou64("macro def params");
	mm_support_serror(asu64(R1));
L9008:
	goto L9006;
L9007:
L9005:
	mm_lex_lex();
L9003:
	asu64(R1) = paramlist;
	asu64(R2) = stmacro;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stmacro;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_parse_checkequals();
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stmacro;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_parse_readrecase() {
    u64 R1, R2; 
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L9015;
	mm_lex_lex();
	R1 = 113;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	goto L9014;
L9015:
	asu64(R1) = mm_parse_readunit();
	R2 = 113;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
L9014:
	goto L9013;
L9013:
	return asu64(R1);
}

static u64 mm_parse_fixcond(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	mm_parse_checknotempty(asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9018;
	R1 = 18;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L9018:
	asu64(R1) = p;
	goto L9016;
L9016:
	return asu64(R1);
}

static u64 mm_parse_readsunit(i64 inwhile) {
    u64 R1, R2, R3, R4, R5; 
	i64 pos;
	i64 m;
	i64 sym;
	i64 opc;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	u64 stname;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L9020:
	goto L9024;
L9023:
	mm_lex_lex();
L9024:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9023;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 4: goto L9059;
	case 5: case 6: case 7: case 8: case 9: case 12: case 13: case 14: case 15: case 16: case 17: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 81: case 88: case 89: case 90: case 91: case 93: case 94: case 95: case 97: case 98: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 110: case 112: case 113: case 114: case 115: case 118: case 124: case 125: case 126: case 128: case 129: case 130: case 131: goto L9028;
	case 10: case 82: case 83: case 84: case 85: case 86: case 87: case 92: case 99: goto L9050;
	case 11: case 79: case 80: case 117: case 121: goto L9034;
	case 18: goto L9060;
	case 59: goto L9049;
	case 67: goto L9051;
	case 96: goto L9056;
	case 108: case 109: goto L9033;
	case 111: goto L9046;
	case 116: goto L9044;
	case 119: case 120: goto L9040;
	case 122: goto L9047;
	case 123: goto L9045;
	case 127: goto L9029;
	case 132: goto L9048;
	default: goto L9028;
    };
// SWITCH
L9029:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L9032;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L9031;
L9032:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	goto L9030;
L9031:
	R1 = 0;
	opc = asi64(R1);
L9030:
	asi64(R1) = opc;
	R2 = 10;
	R3 = 1;
	R4 = 0;
	asu64(R5) = mm_decls_currproc;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L9026;
L9033:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
	goto L9026;
L9034:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9037;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9037;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9036;
L9037:
	goto L9038;
	goto L9035;
L9036:
	R1 = 0;
	sym = asi64(R1);
	goto L9039;
L9035:
	goto L9026;
L9040:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	sym = asi64(R1);
	mm_lex_lex();
// mm_parse.readsunit.dovar:
L9039:
	asi64(R1) = sym;
	R2 = 11;
	R3 = 0;
	R4 = 0;
	asu64(R5) = mm_decls_currproc;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	q = asu64(R1);
	goto L9042;
L9041:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L9042:
	asu64(R1) = q;
	if (asu64(R1)) goto L9041;
	goto L9026;
L9044:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L9026;
L9045:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L9026;
L9046:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L9026;
L9047:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	goto L9026;
L9048:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	goto L9026;
L9049:
	msysc_m$print_startcon();
	asu64(R1) = mm_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Unexpected EOF in proc");
	mm_support_serror(asu64(R1));
	goto L9026;
L9050:
	goto L9022;
	goto L9026;
L9051:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9053;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L9054;
	goto L9055;
L9053:
	R1 = 100;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 14;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = mm_decls_currproc;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = mm_decls_currproc;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	mm_lex_lex();
	R1 = 4;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L9052;
L9054:
	R1 = 119;
	sym = asi64(R1);
	goto L9039;
	goto L9038;
	goto L9052;
L9055:
	goto L9038;
L9052:
	goto L9026;
L9056:
	asi64(R1) = inwhile;
	if (!asi64(R1)) goto L9058;
	goto L9022;
L9058:
	goto L9038;
	goto L9026;
L9059:
	goto L9026;
L9060:
	R1 = -1;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	R2 = 14;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9061;
	goto L9026;
L9028:
// mm_parse.readsunit.doexec:
L9038:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
// mm_parse.readsunit.doexec2:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L9064;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L9064;
	R1 = tou64("Possibly var/let needed");
	mm_support_serror(asu64(R1));
L9064:
// mm_parse.readsunit.doexec3:
L9061:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 96;
	if (asi64(R1) != asi64(R2)) goto L9066;
	goto L9022;
L9066:
L9026:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9020;
L9022:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9068;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9068;
	goto L9069;
L9068:
	goto L9067;
L9069:
	R1 = tou64("Readsunit: \";\" expected, or bad unit starter");
	mm_support_serror(asu64(R1));
L9067:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L9072;
	asu64(R1) = ulist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9071;
L9072:
	asu64(R1) = ulist;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L9070;
L9071:
	asu64(R1) = ulist;
L9070:
	goto L9019;
L9019:
	return asu64(R1);
}

static u64 mm_parse_readbxdata() {
    u64 R1, R2, R3; 
	u64 p;
	i64 curralloc;
	i64 n;
	u64 q;
	u64 r;
	u64 qnew;
	R1 = 4;
	curralloc = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	p = asu64(R1);
	asi64(R1) = curralloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	r = asu64(R2);
	q = asu64(R1);
L9074:
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L9077;
	goto L9075;
L9077:
	asi64(R1) = n;
	asi64(R2) = curralloc;
	if (asi64(R1) != asi64(R2)) goto L9079;
	R1 = 2;
	R2 = (u64)&curralloc;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = curralloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qnew = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = qnew;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qnew;
	asu64(R2) = r;
	asu64(R3) = q;
	asi64(R2) -= asi64(R3);
	R1 += (i64)R2;
	r = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = q;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = qnew;
	q = asu64(R1);
L9079:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9081;
	goto L9075;
L9081:
	goto L9074;
L9075:
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
	mm_lex_lex();
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L9073;
L9073:
	return asu64(R1);
}

static void mm_parse_checknotempty(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L9085;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9084;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9084;
L9085:
	R1 = tou64("Empty sunit");
	mm_support_serror(asu64(R1));
L9084:
	return;
}

static u64 mm_support_newsourcefile() {
    u64 R1, R2, R3; 
	u64 pf;
	R1 = 68;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pf = asu64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 300;
	if (asi64(R1) < asi64(R2)) goto L9088;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many sources");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L9088:
	asu64(R1) = pf;
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_nsourcefiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	asu64(R2) = pf;
	R3 = 64;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = pf;
	goto L9086;
L9086:
	return asu64(R1);
}

static void mm_support_mcerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("MC Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_serror_gen(u64 mess) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 42;
	mm_support_showdivider(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("Syntax Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_decls_currproc;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	mm_support_showerrorsource(asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_lx;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	R4 = 24;
	R5 = 31;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_showdivider(u64 ch) {
    u64 R1, R2; 
	i64 av_1;
	R1 = 87;
	av_1 = asi64(R1);
L9092:
	msysc_m$print_startcon();
	R1 = 0;
	asu64(R2) = ch;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L9092;
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_support_showerrorsource(i64 pos, u64 stproc) {
    u64 R1, R2, R3; 
	i64 fileno;
	i64 lineoffset;
	u64 errorline;
	u64 s;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	asi64(R1) = pos;
	asi64(R1) = mm_support_getfileno(asu64(R1));
	fileno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("    Line:     #");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = stproc;
	if (!asu64(R1)) goto L9097;
	asu64(R1) = stproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9097;
	msysc_m$print_startcon();
	R1 = tou64("    Function: #()");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = stproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9097:
	msysc_m$print_startcon();
	R1 = tou64("    Module:   # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	mm_support_showdivider(asu64(R1));
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourceline(asu64(R1));
	R2 = R1;
	errorline = asu64(R2);
	s = asu64(R1);
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourcepos(asu64(R1));
	asu64(R2) = errorline;
	asi64(R1) -= asi64(R2);
	lineoffset = asi64(R1);
	R1 = 6;
	av_1 = asi64(R1);
L9098:
	msysc_m$print_startcon();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L9098;
	goto L9102;
L9101:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L9102:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9104;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9101;
L9104:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = errorline;
	s = asu64(R1);
	R1 = 6;
	av_2 = asi64(R1);
L9105:
	msysc_m$print_startcon();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_2)) goto L9105;
	asi64(R1) = lineoffset;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L9110;
L9108:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L9112;
	msysc_m$print_startcon();
	R1 = 0;
	R2 = 9;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L9111;
L9112:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = 32;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L9111:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L9108;
L9110:
	msysc_m$print_startcon();
	R1 = tou64("^");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	mm_support_showdivider(asu64(R1));
	return;
}

static void mm_support_stopcompiler(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("PRESS key");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_getch();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_serror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_serror_gen(asu64(R1));
	return;
}

static void mm_support_serror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	mm_support_serror_gen(asu64(R1));
	return;
}

static void mm_support_error_gen(i64 pass, u64 mess, u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	if (!asu64(R1)) goto L9118;
	msysc_m$print_startcon();
	R1 = tou64("P.POS");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	goto L9117;
L9118:
	msysc_m$print_startcon();
	R1 = tou64("MMPOS");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = pc_decls_mmpos;
	pos = asi64(R1);
L9117:
	msysc_m$print_startcon();
	R1 = tou64("GETFILENO(POS)=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pos;
	asi64(R1) = mm_support_getfileno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 42;
	mm_support_showdivider(asu64(R1));
	asi64(R1) = pass;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L9120;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L9121;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L9122;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L9123;
	goto L9124;
L9120:
	msysc_m$print_startcon();
	R1 = tou64("RX Name Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9119;
L9121:
	msysc_m$print_startcon();
	R1 = tou64("TX Type Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9119;
L9122:
	msysc_m$print_startcon();
	R1 = tou64("GX Code Gen Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9119;
L9123:
	msysc_m$print_startcon();
	R1 = tou64("AX Code Gen Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9119;
L9124:
L9119:
	asu64(R1) = mm_decls_currproc;
	asi64(R2) = pos;
	mm_support_showerrorsource(asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = pos;
	asi64(R3) = mm_support_getfileno(asu64(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_rxerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 78;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_gerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 71;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror_s(u64 mess, u64 a, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror_ss(u64 mess, u64 a, u64 b) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_rxerror_s(u64 mess, u64 a, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 78;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_gerror_s(u64 mess, u64 s, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 71;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_lxerror_gen(u64 mess) {
    u64 R1, R2, R3, R4, R5; 
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Lex Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_lx;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	R4 = 24;
	R5 = 31;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_lxerror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_lxerror_gen(asu64(R1));
	return;
}

static void mm_support_loaderror(u64 mess, u64 mess2, u64 mess3) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess3;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_gs_additem(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9137;
	asu64(R1) = d;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = mm_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L9139;
	asi64(R1) = nextchar;
	asi64(R1) = mm_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L9139;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L9139:
L9137:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_support_gs_copytostr(u64 source, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9142;
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = source;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = s;
	asu64(R3) = source;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9141;
L9142:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L9141:
	return;
}

static i64 mm_support_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L9147;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L9146;
L9147:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L9148;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L9146;
L9148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L9145;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L9145;
L9146:
	R1 = 1;
	goto L9143;
L9145:
	R1 = 0;
	goto L9143;
L9143:
	return asi64(R1);
}

static void mm_support_init_tt_tables() {
    u64 R1, R2, R3; 
	i64 i;
	i64 size;
	i64 bitsize;
	i64 s;
	i64 t;
	i64 u;
	i64 v;
	i64 av_1;
	R1 = 0;
	i = asi64(R1);
	R1 = 30;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L9152;
L9150:
	R1 = (u64)&mm_tables_stdnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_ttname;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = i;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_tables_stdsize;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9154;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9155;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9155;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9155;
	goto L9156;
L9154:
	R1 = 0;
	size = asi64(R1);
	goto L9153;
L9155:
	R1 = 1;
	size = asi64(R1);
	goto L9153;
L9156:
	asi64(R1) = bitsize;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
L9153:
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = i;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	asi64(R1) = i;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9158;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L9158;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9158;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9158;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9159;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9159;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9159;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9159;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9159;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9159;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9160;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9160;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9161;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9161;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L9161;
	goto L9162;
L9158:
	R1 = 1;
	R2 = (u64)&mm_decls_ttsigned;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9157;
L9159:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9157;
L9160:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9157;
L9161:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9157;
L9162:
L9157:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9164;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L9164;
	R1 = 1;
	R2 = (u64)&mm_decls_ttisshort;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9164:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = i;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9167;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9167;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9167;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L9166;
L9167:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9166:
	i += 1; if (i <= av_1) goto L9150;
L9152:
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 12;
	R2 = (u64)&mm_decls_tttarget;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 30;
	mm_decls_ntypes = asi64(R1);
	R1 = 0;
	R2 = 24;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	mm_tables_trefproc = asi64(R1);
	R1 = 0;
	R2 = 25;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	mm_tables_treflabel = asi64(R1);
	return;
}

static u64 mm_support_getsupportfile(u64 filename, u64 ext, u64 path) {
    u64 R1, R2, R3; 
	struct $B15 filespec;
	struct $B15 filespec2;
	u64 file;
	i64 fileno;
	u64 pfile;
	i64 i;
	asu64(R1) = filename;
	file = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9170;
	msysc_m$print_startcon();
	R1 = tou64("Get file:# (ext:#) (path:#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ext;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = path;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9170:
	asu64(R1) = ext;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L9172;
	asu64(R1) = ext;
	asu64(R2) = filename;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	file = asu64(R1);
L9172:
	asu8(R1) = mm_decls_loadedfromma;
	if (!asu8(R1)) goto L9174;
	asu64(R1) = file;
	asu64(R1) = mlib_extractfile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file = asu64(R1);
L9174:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9177;
L9175:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = file;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9179;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9179;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L9168;
L9179:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L9175;
L9177:
	asu64(R1) = file;
	asi64(R1) = mm_support_isabspath(asu64(R1));
	if (asi64(R1)) goto L9181;
	asu64(R1) = path;
	R2 = (u64)&filespec2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&filespec2;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&filespec2;
	file = asu64(R1);
L9181:
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9183;
	asi64(R1) = fileno;
	if (!asi64(R1)) goto L9183;
	msysc_m$print_startcon();
	R1 = tou64("Checkfile:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9183:
	asu64(R1) = file;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L9186;
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L9185;
L9186:
	R1 = tou64("");
	asu64(R2) = file;
	R3 = tou64("Can't find file: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L9185:
	R1 = 0;
	asu64(R2) = file;
	asu64(R1) = mm_modules_loadsourcefile(asu64(R2), asi64(R1));
	pfile = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9188;
	asu64(R1) = pfile;
	if (!asu64(R1)) goto L9188;
	msysc_m$print_startcon();
	R1 = tou64("Found:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9188:
	R1 = 1;
	asu64(R2) = pfile;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pfile;
	goto L9168;
L9168:
	return asu64(R1);
}

static i64 mm_support_isabspath(u64 filespec) {
    u64 R1, R2; 
	u64 path;
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	path = asu64(R1);
	asu64(R1) = path;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L9192;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L9192;
	asu64(R1) = path;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9191;
	asu64(R1) = path;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L9191;
L9192:
	R1 = 1;
	goto L9189;
L9191:
	R1 = 0;
	goto L9189;
L9189:
	return asi64(R1);
}

static void mm_support_initbblib() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 6;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9196;
L9194:
	R1 = 1;
	R2 = (u64)&mm_decls_typestarterset;
	R3 = (u64)&mm_tables_d_typestarterset;
	asi64(R4) = i;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L9194;
L9196:
	return;
}

static i64 mm_support_getfileno(u64 pos) {
    u64 R1, R2, R3; 
	i64 fileno;
	asu64(R1) = pos;
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9200;
	asi64(R1) = fileno;
	asi64(R2) = mm_decls_nsourcefiles;
	if (asi64(R1) <= asi64(R2)) goto L9199;
L9200:
	R1 = tou64("No file no");
	mlib_abortprogram(asu64(R1));
L9199:
	asi64(R1) = fileno;
	goto L9197;
L9197:
	return asi64(R1);
}

static i64 mm_support_getlineno(u64 pos) {
    u64 R1, R2; 
	u64 source;
	u64 sline;
	u64 s;
	i64 lineno;
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	source = asu64(R1);
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourceline(asu64(R1));
	sline = asu64(R1);
	asu64(R1) = sline;
	s = asu64(R1);
	R1 = 1;
	lineno = asi64(R1);
	goto L9203;
L9202:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9206;
	R1 = (u64)&lineno;
	(*toi64p(R1)) += 1;
L9206:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
L9203:
	asu64(R1) = s;
	asu64(R2) = source;
	if (asu64(R1) >= asu64(R2)) goto L9202;
	asi64(R1) = lineno;
	goto L9201;
L9201:
	return asi64(R1);
}

static u64 mm_support_getsourceline(u64 pos) {
    u64 R1, R2; 
	u64 source;
	u64 s;
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	source = asu64(R1);
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcepos(asu64(R1));
	s = asu64(R1);
	goto L9209;
L9208:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
L9209:
	asu64(R1) = s;
	asu64(R2) = source;
	if (asu64(R1) <= asu64(R2)) goto L9211;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9208;
L9211:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9213;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L9213:
	asu64(R1) = s;
	goto L9207;
L9207:
	return asu64(R1);
}

static u64 mm_support_getsourcestart(u64 pos) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L9214;
L9214:
	return asu64(R1);
}

static u64 mm_support_getsourcepos(u64 pos) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pos;
	R3 = 0;
	R4 = 23;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R1 += (i64)R2;
	goto L9215;
L9215:
	return asu64(R1);
}

static i64 mm_support_mgetsourceinfo(i64 pos, u64 filename, u64 sourceline) {
    u64 R1, R2; 
	i64 lineno;
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	lineno = asi64(R1);
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	asu64(R2) = sourceline;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = filename;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = lineno;
	goto L9216;
L9216:
	return asi64(R1);
}

static void mm_support_do_writema(u64 inpfile) {
    u64 R1, R2, R3, R4; 
	struct $B15 filename;
	struct $B50 sflist;
	u64 f;
	i64 offset;
	i64 nfiles;
	i64 fileno;
	u64 pf;
	i64 i;
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9219;
	goto L9217;
L9219:
	R1 = tou64("ma");
	asu64(R2) = inpfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	nfiles = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9222;
L9220:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9224;
	asi64(R1) = i;
	R2 = (u64)&sflist;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L9224:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L9220;
L9222:
	asi64(R1) = nfiles;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9226;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA: no files");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L9226:
	R1 = tou64("wb");
	R2 = (u64)&filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L9228;
	R1 = tou64("");
	R2 = (u64)&filename;
	R3 = tou64("Can't create MA file ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L9228:
	asi64(R1) = mm_decls_fverbose;
	if (!asi64(R1)) goto L9230;
	msysc_m$print_startcon();
	R1 = tou64("Writing ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9230:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== MA # ===");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9233;
L9231:
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&sflist;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== # # # #/# ===");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pf;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pf;
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi64(R1) = mlib_getfilepos(asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pf;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	asu64(R3) = pf;
	R4 = 40;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= nfiles) goto L9231;
L9233:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== END ===");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9236;
L9234:
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&sflist;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pf;
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= nfiles) goto L9234;
L9236:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 0;
	exit(R1);
L9217:
	return;
}

static void mm_support_do_getinfo(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 fs;
	u64 pm;
	i64 i;
	asi64(R1) = mm_decls_passlevel;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9239;
	R1 = tou64("wb");
	R2 = tou64("list");
	asu64(R3) = filename;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	R3 = R2;
	fs = asu64(R3);
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L9241;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = fs;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_decls_stprogram;
	asu64(R2) = f;
	mm_support_getst(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L9241:
L9239:
	asi64(R1) = mm_decls_passlevel;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9243;
	R1 = tou64("wb");
	R2 = tou64("proj");
	asu64(R3) = filename;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	R3 = R2;
	fs = asu64(R3);
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L9245;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = fs;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9248;
L9246:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("16jl");
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("16jl");
	R2 = (u64)&mm_decls_subprogs;
	asu64(R3) = pm;
	R4 = 18;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("q");
	asu64(R2) = pm;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	asu64(R1) = pm;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nmodules) goto L9246;
L9248:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L9245:
L9243:
	return;
}

static void mm_support_getst(u64 f, u64 d) {
    u64 R1, R2; 
	u64 q;
	asu64(R1) = d;
	asu64(R2) = f;
	mm_support_getstrec(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L9253;
L9250:
	asu64(R1) = q;
	asu64(R2) = f;
	mm_support_getst(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9253:
	asu64(R1) = q;
	if (asu64(R1)) goto L9250;
	return;
}

static void mm_support_getstrec(u64 f, u64 d) {
    u64 R1, R2, R3, R4, R5; 
	u64 name;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9256;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9256;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9256;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9256;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9256;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L9256;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9256;
	goto L9257;
L9256:
	goto L9255;
L9257:
	goto L9254;
L9255:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9259;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9259;
	goto L9254;
L9259:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jl");
	R2 = (u64)&mm_decls_subprogs;
	R3 = (u64)&mm_decls_moduletosub;
	asu64(R4) = d;
	R5 = 94;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = d;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("18jl");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9261;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9262;
	goto L9263;
L9261:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9265;
	R1 = tou64("funcid");
	goto L9264;
L9265:
	R1 = tou64("procid");
L9264:
	name = asu64(R1);
	goto L9260;
L9262:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9267;
	R1 = tou64("dllfuncid");
	goto L9266;
L9267:
	R1 = tou64("dllprocid");
L9266:
	name = asu64(R1);
	goto L9260;
L9263:
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	name = asu64(R1);
L9260:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jl");
	asu64(R2) = name;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("5");
	asu64(R2) = d;
	R3 = 88;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asi64(R2) = mm_support_getlineno(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9269;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9270;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9271;
	goto L9272;
L9269:
	R1 = tou64("Module");
	name = asu64(R1);
	goto L9268;
L9270:
	R1 = tou64("Subprog");
	name = asu64(R1);
	goto L9268;
L9271:
	R1 = tou64("Program");
	name = asu64(R1);
	goto L9268;
L9272:
	R1 = tou64("Export");
	name = asu64(R1);
L9268:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9274;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Import ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9274:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jlq");
	R2 = 1;
	asu64(R3) = d;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("q");
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_modules;
	asu64(R4) = d;
	R5 = 94;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	R4 = 20;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9254:
	return;
}

static void mm_tables_start() {
    u64 R1, R2, R3, R4; 
	i64 genop;
	i64 s;
	i64 t;
	i64 a;
	i64 specop;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 12;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9278;
L9276:
	R1 = 1;
	R2 = (u64)&mm_tables_endsexpr;
	R3 = (u64)&mm_tables_exprendsymbols;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= av_1) goto L9276;
L9278:
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 18;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 19;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 43;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tpass(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 d;
	u64 a;
	u64 b;
	u64 c;
	u64 q;
	i64 oldmmpos;
	i64 m;
	i64 nparams;
	i64 paramtype;
	i64 restype;
	i64 amode;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9281;
	goto L9279;
L9281:
	asi64(R1) = mm_type_tpass_depth;
	R2 = 100;
	if (asi64(R1) != asi64(R2)) goto L9283;
	R1 = 0;
	R2 = tou64("TX looping detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9283:
	R1 = (u64)&mm_type_tpass_depth;
	(*toi64p(R1)) += 1;
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: case 7: goto L9288;
	case 2: case 3: case 5: case 9: case 23: case 25: case 26: case 27: case 29: case 30: case 31: case 42: case 43: case 44: case 45: case 47: case 50: case 54: case 57: case 63: case 64: case 69: case 70: case 71: case 72: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: goto L9286;
	case 4: goto L9287;
	case 6: goto L9319;
	case 8: goto L9349;
	case 10: case 11: goto L9352;
	case 12: goto L9353;
	case 13: goto L9391;
	case 14: goto L9394;
	case 15: case 16: goto L9307;
	case 17: case 18: case 19: goto L9308;
	case 20: goto L9335;
	case 21: goto L9312;
	case 22: goto L9393;
	case 24: goto L9392;
	case 28: goto L9297;
	case 32: goto L9305;
	case 33: case 35: goto L9291;
	case 34: goto L9385;
	case 36: goto L9293;
	case 37: goto L9294;
	case 38: goto L9295;
	case 39: goto L9296;
	case 40: goto L9311;
	case 41: goto L9292;
	case 46: goto L9303;
	case 48: goto L9318;
	case 49: goto L9306;
	case 51: case 52: goto L9317;
	case 53: goto L9304;
	case 55: goto L9298;
	case 56: goto L9301;
	case 58: goto L9309;
	case 59: goto L9390;
	case 60: goto L9332;
	case 61: goto L9310;
	case 62: goto L9289;
	case 65: case 66: goto L9290;
	case 67: goto L9354;
	case 68: goto L9371;
	case 73: case 74: goto L9370;
	case 86: goto L9357;
	case 87: case 88: goto L9348;
	case 89: goto L9322;
	case 90: goto L9372;
	case 91: goto L9331;
	case 92: goto L9302;
	case 93: case 94: goto L9329;
	case 95: case 96: goto L9330;
	case 97: goto L9340;
	case 98: goto L9344;
	case 99: goto L9338;
	case 100: goto L9339;
	case 101: case 102: case 103: goto L9337;
	case 104: goto L9321;
	case 105: case 106: goto L9316;
	case 107: case 108: case 109: case 110: goto L9315;
	case 111: goto L9313;
	case 112: goto L9314;
	case 113: goto L9365;
	case 114: case 115: case 116: case 117: goto L9323;
	case 118: goto L9359;
	case 119: goto L9358;
	case 120: goto L9336;
	case 121: goto L9320;
	case 122: goto L9386;
	default: goto L9286;
    };
// SWITCH
L9287:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tx_name(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9288:
	goto L9284;
L9289:
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9284;
L9290:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9284;
L9291:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_bin(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9292:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_tx_in(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9293:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_unary(asu64(R2), asu64(R1));
	goto L9284;
L9294:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_prop(asu64(R2), asu64(R1));
	goto L9284;
L9295:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_binto(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9296:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_unaryto(asu64(R2), asu64(R1));
	goto L9284;
L9297:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_assign(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9298:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 53;
	if (asi64(R1) != asi64(R2)) goto L9300;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9299;
L9300:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9299:
	goto L9284;
L9301:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_addroffirst(asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9302:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_if(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9303:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_type_tx_index(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9304:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_ptr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9305:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_callproc(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9306:
	asi64(R1) = lv;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_dot(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9307:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_andl(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9308:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_notl(asu64(R2), asu64(R1));
	goto L9284;
L9309:
	R1 = 1;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_convert(asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9310:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_typepun(asu64(R2), asu64(R1));
	goto L9284;
L9311:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_incrto(asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9312:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_makerange(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9313:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_swap(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9314:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_select(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9315:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_switch(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9316:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9317:
	asi64(R1) = lv;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_dotindex(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9318:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_slice(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9319:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_block(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9320:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9321:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9322:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_return(asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9323:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_type_fixchararray(asu64(R1));
	goto L9325;
L9324:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) != asi64(R2)) goto L9328;
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = R3;
	c = asu64(R4);
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 20;
	asu64(R3) = b;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9327;
L9328:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	R4 = R3;
	c = asu64(R4);
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9327:
	asu64(R1) = c;
	mm_type_fixchararray(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L9325:
	asu64(R1) = b;
	if (asu64(R1)) goto L9324;
	R1 = 0;
	R2 = 23;
	asu64(R3) = p;
	R4 = 32;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9329:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	mm_type_tx_for(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9330:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	mm_type_tx_forall(asu64(R3), asu64(R2), asu64(R1));
	goto L9284;
L9331:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9332:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9334;
	R1 = 0;
	R2 = tou64("cast() needs type");
	mm_support_txerror(asu64(R2), asu64(R1));
L9334:
	R1 = 1;
	asi64(R2) = t;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L9284;
L9335:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_makelist(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9336:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9337:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_exit(asu64(R2), asu64(R1));
	goto L9284;
L9338:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_goto(asu64(R2), asu64(R1));
	goto L9284;
L9339:
	goto L9284;
L9340:
	R1 = 0;
	R2 = 6;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L9342;
	R1 = 104;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L9341;
L9342:
	asu64(R1) = a;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L9343;
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9343:
L9341:
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9344:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (asi64(R1)) goto L9347;
	asu64(R1) = b;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L9346;
L9347:
	R1 = 0;
	R2 = tou64("repeat/const cond");
	mm_support_txerror(asu64(R2), asu64(R1));
L9346:
	goto L9284;
L9348:
	goto L9284;
L9349:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9351;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9351:
	R1 = 1;
	mm_type_inassem = asi64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = c;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	mm_type_inassem = asi64(R1);
	goto L9284;
L9352:
	goto L9284;
L9353:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9354:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L9356;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	m = asi64(R1);
	goto L9355;
L9356:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
L9355:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9284;
L9357:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9358:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9284;
L9359:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9361;
	R1 = 0;
	R2 = 5;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9361:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9364;
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9363;
L9364:
	asi64(R1) = t;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	t = asi64(R1);
L9363:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9284;
L9365:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9367;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9369;
	R1 = 0;
	R2 = tou64("recase must be const");
	mm_support_txerror(asu64(R2), asu64(R1));
L9369:
L9367:
	goto L9284;
L9370:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9284;
L9371:
	asi64(R1) = lv;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_bitfield(asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9372:
	R1 = 0;
	restype = asi64(R1);
	R1 = 0;
	paramtype = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L9374;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L9375;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L9376;
	goto L9377;
L9374:
	R1 = 3;
	restype = asi64(R1);
	goto L9373;
L9375:
	R1 = 3;
	paramtype = asi64(R1);
	R1 = 20;
	restype = asi64(R1);
	goto L9373;
L9376:
	R1 = 3;
	paramtype = asi64(R1);
	R1 = 7;
	restype = asi64(R1);
	goto L9373;
L9377:
L9373:
	asi64(R1) = paramtype;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9379;
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9381;
	R1 = 0;
	R2 = tou64("sys: arg missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L9381:
	R1 = 0;
	asi64(R2) = paramtype;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9383;
	R1 = 0;
	R2 = tou64("sys: too many args");
	mm_support_txerror(asu64(R2), asu64(R1));
L9383:
	goto L9378;
L9379:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9384;
	R1 = 0;
	R2 = tou64("sys: too many args");
	mm_support_txerror(asu64(R2), asu64(R1));
L9384:
L9378:
	asi64(R1) = restype;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9284;
L9385:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_cmpchain(asu64(R2), asu64(R1));
	goto L9284;
L9386:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9388;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9388;
	goto L9389;
L9388:
	goto L9387;
L9389:
	R1 = 0;
	R2 = tou64("Clear scalar?");
	mm_support_txerror(asu64(R2), asu64(R1));
L9387:
	goto L9284;
L9390:
	goto L9284;
L9391:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_strinclude(asu64(R2), asu64(R1));
	goto L9284;
L9392:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_makeslice(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9393:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_makeset(asu64(R3), asu64(R2), asi64(R1));
	goto L9284;
L9394:
	goto L9284;
L9286:
	msysc_m$print_startcon();
	R1 = tou64("TXUNIT: CAN'T DO:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
// mm_type.tpass.doelse:
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9398;
L9396:
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	R4 = 16;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L9396;
L9398:
L9284:
	asu64(R1) = p;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9400;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L9400;
	goto L9401;
L9400:
	goto L9399;
L9401:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L9403;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9403;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L9403;
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L9403:
L9399:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9405;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9407;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L9407;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L9407;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L9407;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9408;
	goto L9409;
L9407:
	goto L9406;
L9408:
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9412;
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L9411;
L9412:
L9411:
	goto L9406;
L9409:
L9406:
L9405:
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_type_tpass_depth;
	(*toi64p(R1)) -=1;
L9279:
	return;
}

static void mm_type_tx_allprocs() {
    u64 R1, R2, R3; 
	u64 pp;
	u64 pcode;
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L9415;
L9414:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_decls_currproc = asu64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcode = asu64(R1);
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	R3 = 122;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 1;
	if (asi64(R2) <= asi64(R3)) goto L9418;
	R2 = 28;
	goto L9417;
L9418:
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
L9417:
	asu64(R3) = pcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9420;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L9421;
	goto L9422;
L9420:
	goto L9419;
L9421:
	goto L9419;
L9422:
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L9424;
	R1 = 89;
	asu64(R2) = pcode;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pcode;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pcode;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9424:
L9419:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L9415:
	asu64(R1) = pp;
	if (asu64(R1)) goto L9414;
	return;
}

static void mm_type_tx_block(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	goto L9427;
L9426:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L9427:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9429;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L9426;
L9429:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9431;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9433;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L9432;
L9433:
	R1 = 0;
L9432:
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9431:
	return;
}

static void mm_type_tx_typetable() {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 31;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L9437;
L9435:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L9439;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	d = asu64(R2);
	mm_type_tx_passdef(asu64(R1));
L9439:
	asi64(R1) = i;
	mm_type_setmodesize(asi64(R1));
	i += 1; if (i <= mm_decls_ntypes) goto L9435;
L9437:
	return;
}

static void mm_type_setmodesize(i64 m) {
    u64 R1, R2, R3; 
	i64 size;
	i64 target;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L9442;
	goto L9440;
L9442:
	R1 = (u64)&mm_decls_ttlineno;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9444;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9445;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9446;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L9446;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9447;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L9448;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L9449;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L9450;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L9451;
	goto L9452;
L9444:
	asi64(R1) = m;
	mm_type_setarraysize(asi64(R1));
	goto L9443;
L9445:
	asi64(R1) = m;
	mm_type_setrecordsize(asi64(R1));
	goto L9443;
L9446:
	goto L9443;
L9447:
	asi64(R1) = m;
	mm_type_setslicesize(asi64(R1));
	goto L9443;
L9448:
	R1 = 0;
	R2 = tou64("SETMODESIZE/AUTO?");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L9443;
L9449:
	goto L9443;
L9450:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = target;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = target;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L9443;
L9451:
	goto L9443;
L9452:
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = R1;
	size = asi64(R2);
	if (!asi64(R1)) goto L9454;
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	goto L9440;
L9454:
	msysc_m$print_startcon();
	R1 = tou64("SIZE 0:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STDNAMES[TTBASETYPE[M]]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_stdnames;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Can't set mode size");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9443:
L9440:
	return;
}

static void mm_type_setarraysize(i64 m) {
    u64 R1, R2, R3; 
	i64 lower;
	i64 length;
	i64 elemsize;
	i64 target;
	i64 size;
	u64 pdim;
	u64 a;
	u64 b;
	R1 = (u64)&mm_decls_ttsizeset;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9457;
	goto L9455;
L9457:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pdim = asu64(R1);
	asu64(R1) = pdim;
	if (!asu64(R1)) goto L9459;
	asu64(R1) = pdim;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = pdim;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = pdim;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = pdim;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L9461;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L9462;
	goto L9463;
L9461:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	lower = asi64(R1);
	asu64(R1) = b;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	goto L9460;
L9462:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	lower = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L9465;
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	length = asi64(R1);
	goto L9464;
L9465:
	R1 = 0;
	length = asi64(R1);
L9464:
	goto L9460;
L9463:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pdim;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdim;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	length = asi64(R1);
	R1 = 1;
	lower = asi64(R1);
L9460:
	goto L9458;
L9459:
	R1 = 1;
	lower = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L9458:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L9467;
	R1 = 0;
	R2 = tou64("Neg length");
	mm_support_txerror(asu64(R2), asu64(R1));
L9467:
	R1 = 0;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	elemsize = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	R2 = R1;
	size = asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttsizeset;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	mm_type_checkblocktype(asi64(R1));
L9455:
	return;
}

static void mm_type_setslicesize(i64 m) {
    u64 R1, R2, R3; 
	u64 pdim;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L9470;
	goto L9468;
L9470:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pdim = asu64(R1);
	asu64(R1) = pdim;
	if (!asu64(R1)) goto L9472;
	asu64(R1) = pdim;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = pdim;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdim;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L9471;
L9472:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L9471:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = 11;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
L9468:
	return;
}

static i64 mm_type_tx_module(i64 n) {
    u64 R1, R2; 
	struct $B31 m;
	u64 d;
	i64 globalflag;
	i64 status;
	asi64(R1) = n;
	mm_decls_currmoduleno = asi64(R1);
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_tx_passdef(asu64(R1));
	R1 = 1;
	goto L9473;
L9473:
	return asi64(R1);
}

static void mm_type_tx_passdef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 oldmmpos;
	u64 q;
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9476;
	goto L9474;
L9476:
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L9478;
L9477:
	asu64(R1) = d;
	mm_type_tx_passdef(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L9478:
	asu64(R1) = d;
	if (asu64(R1)) goto L9477;
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9481;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9482;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9483;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9483;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9483;
	goto L9484;
L9481:
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	goto L9480;
L9482:
	asu64(R1) = p;
	mm_type_tx_namedconst(asu64(R1));
	goto L9480;
L9483:
	asu64(R1) = p;
	mm_type_tx_namedef(asu64(R1));
	goto L9480;
L9484:
L9480:
	R1 = 1;
	asu64(R2) = p;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
L9474:
	return;
}

static void mm_type_tx_unitlist(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	goto L9487;
L9486:
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L9487:
	asu64(R1) = p;
	if (asu64(R1)) goto L9486;
	return;
}

static void mm_type_tx_namedef(u64 d) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mold;
	i64 inidataold;
	u64 dcode;
	u64 pequiv;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9491;
	R1 = 0;
	R2 = tou64("Circular reference detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9491:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9493;
	goto L9489;
L9493:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = m;
	mm_type_setmodesize(asi64(R1));
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dcode = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9495;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pequiv = asu64(R1);
	asu64(R1) = pequiv;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L9497;
	asu64(R1) = pequiv;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pequiv;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L9497:
	asu64(R1) = pequiv;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9499;
	R1 = 0;
	R2 = tou64("@name needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L9499:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pequiv;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9495:
	asu64(R1) = dcode;
	if (!asu64(R1)) goto L9501;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9501;
	asi64(R1) = m;
	mold = asi64(R1);
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L9503;
	asu64(R1) = dcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9503;
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L9503;
	R1 = 0;
	R2 = 20;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9502;
L9503:
	asi64(R1) = mm_type_inidata;
	inidataold = asi64(R1);
	R1 = 1;
	mm_type_inidata = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = inidataold;
	mm_type_inidata = asi64(R1);
L9502:
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9505;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9505;
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9505:
	asi64(R1) = mold;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L9507;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9509;
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = mold;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9509;
	R1 = 59;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = mold;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9508;
L9509:
	asi64(R1) = mold;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9510;
	asi64(R1) = mold;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9510:
L9508:
L9507:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9512;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_checkconstexpr(asu64(R1));
L9512:
	goto L9500;
L9501:
	asu64(R1) = dcode;
	if (!asu64(R1)) goto L9513;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L9513;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9513;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9513;
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L9500;
L9513:
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L9500:
L9489:
	return;
}

static void mm_type_tx_namedconst(u64 d) {
    u64 R1, R2, R3; 
	i64 m;
	u64 q;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9516;
	R1 = 0;
	R2 = tou64("Circular const reference detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9516:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9518;
	goto L9514;
L9518:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asi64(R2) = m;
	R3 = 22;
	if (asi64(R2) != asi64(R3)) goto L9520;
	R2 = 23;
	goto L9519;
L9520:
	asi64(R2) = m;
L9519:
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	asi64(R1) = m;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L9522;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9522:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9524;
	goto L9525;
L9524:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9527;
	R1 = 0;
	R2 = tou64("Bad const type");
	mm_support_txerror(asu64(R2), asu64(R1));
L9527:
	goto L9523;
L9525:
L9523:
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L9514:
	return;
}

static void mm_type_checkconstexpr(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 pmode;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9530;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L9530;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9531;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L9532;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L9533;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L9534;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L9534;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9535;
	goto L9536;
L9530:
	goto L9528;
	goto L9529;
L9531:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L9538;
L9537:
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9538:
	asu64(R1) = q;
	if (asu64(R1)) goto L9537;
	goto L9529;
L9532:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9541;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L9540;
L9541:
	goto L9542;
L9540:
	goto L9529;
L9533:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_checkconstexpr(asu64(R1));
	goto L9529;
L9534:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9544;
	goto L9545;
L9544:
	goto L9543;
L9545:
	goto L9542;
L9543:
	goto L9529;
L9535:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9547;
	goto L9528;
L9547:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9549;
	goto L9528;
L9549:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L9551;
	goto L9528;
L9551:
	goto L9542;
	goto L9529;
L9536:
// mm_type.checkconstexpr.error:
L9542:
	msysc_m$print_startcon();
	R1 = tou64("JTAGNAMES[P.TAG]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("Getconstexpr: not const");
	mm_support_txerror(asu64(R2), asu64(R1));
L9529:
L9528:
	return;
}

static i64 mm_type_getconstint(u64 q) {
    u64 R1, R2, R3; 
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9555;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L9554;
L9555:
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L9552;
	goto L9553;
L9554:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9556;
	asu64(R1) = q;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L9552;
	goto L9553;
L9556:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Getconstint: not i32/64");
	mm_support_txerror(asu64(R2), asu64(R1));
L9553:
	R1 = 0;
	goto L9552;
L9552:
	return asi64(R1);
}

static void mm_type_makenewconst(u64 p, i64 x, i64 t) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9559;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9559:
	return;
}

static void mm_type_tx_name(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	u64 d;
	i64 oldmmpos;
	u64 pcode;
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9562;
	goto L9560;
L9562:
	asu64(R1) = p;
	R2 = 2;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9564;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9565;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9565;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9565;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9566;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9566;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9567;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9568;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L9569;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9570;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9571;
	goto L9572;
L9564:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L9574;
	R1 = 0;
	R2 = tou64("&const");
	mm_support_txerror(asu64(R2), asu64(R1));
L9574:
	asu64(R1) = d;
	mm_type_tx_namedconst(asu64(R1));
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcode = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L9576;
	asu64(R1) = pcode;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L9575;
L9576:
	asu64(R1) = pcode;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L9575:
	asu64(R1) = pcode;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pcode;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9563;
L9565:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9578;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L9578;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't use 'let' as lvalue: ");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9578:
	asu64(R1) = d;
	mm_type_tx_namedef(asu64(R1));
	asi64(R1) = mm_type_inassem;
	if (asi64(R1)) goto L9580;
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9582;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9584;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 53;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9584:
L9582:
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	goto L9579;
L9580:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9579:
	goto L9563;
L9566:
	asi64(R1) = mm_tables_trefproc;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9563;
L9567:
	asi64(R1) = mm_tables_treflabel;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9563;
L9568:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Module name can't be used on it's own: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L9563;
L9569:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9563;
L9570:
	R1 = 62;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9563;
L9571:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9586;
	R1 = 0;
	R2 = tou64("Can't init dllvar");
	mm_support_txerror(asu64(R2), asu64(R1));
L9586:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9563;
L9572:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_tables_namenames;
	asu64(R3) = d;
	R4 = 78;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("TNAME? # #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9563:
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
L9560:
	return;
}

static void mm_type_tx_bin(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 q;
	i64 amode;
	i64 bmode;
	i64 abase;
	i64 bbase;
	i64 cmode;
	i64 resmode;
	i64 relop;
	i64 simpleset;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L9589;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L9590;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L9591;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L9592;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L9593;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L9593;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L9593;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L9593;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L9593;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L9593;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L9594;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L9594;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L9595;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L9596;
	R2 = 81;
	if (asi64(R1) == asi64(R2)) goto L9596;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L9597;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L9597;
	goto L9598;
L9589:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9600;
	goto L9587;
L9600:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9602;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9604;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9604;
	asu64(R1) = b;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9604;
	asu64(R1) = p;
	mm_type_combinestrings(asu64(R1));
	goto L9587;
L9604:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9606;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 57;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9587;
L9606:
L9602:
	goto L9588;
L9590:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9608;
	goto L9587;
L9608:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9610;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9612;
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L9614;
	R1 = 59;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9587;
	goto L9613;
L9614:
	R1 = 0;
	R2 = tou64("ref-ref: not compat");
	mm_support_txerror(asu64(R2), asu64(R1));
L9613:
L9612:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9616;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 58;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9587;
L9616:
L9610:
	goto L9588;
L9591:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9618;
	goto L9587;
L9618:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9620;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9622;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9622;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9622;
	asu64(R1) = p;
	mm_type_mulstrings(asu64(R1));
	goto L9587;
L9622:
L9620:
	goto L9588;
L9592:
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9625;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9625;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L9624;
L9625:
	asi64(R1) = bmode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9626;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9626;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L9624;
L9626:
	R1 = 47;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9627;
L9624:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumf(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9629;
	goto L9587;
L9629:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9631;
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9631;
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L9587;
L9631:
	goto L9588;
L9593:
// mm_type.tx_bin.doidiv:
L9627:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumi(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9633;
	goto L9587;
L9633:
	goto L9588;
L9594:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9635;
	goto L9587;
L9635:
	goto L9588;
L9595:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9637;
	goto L9587;
L9637:
	goto L9588;
L9596:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9587;
	goto L9588;
L9597:
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9640;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9640;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L9639;
L9640:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9587;
L9639:
	goto L9588;
L9598:
	asu64(R1) = p;
	R2 = 64;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9642;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9644;
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9587;
L9644:
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9646;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9646;
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9648;
	R1 = 0;
	R2 = tou64("Cmp ref/ref not compat");
	mm_support_txerror(asu64(R2), asu64(R1));
L9648:
	goto L9587;
L9646:
	asu64(R1) = p;
	R2 = 64;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9651;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9650;
L9651:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L9653;
	goto L9587;
L9653:
L9650:
	goto L9641;
L9642:
	R1 = 0;
	R2 = tou64("txbin?");
	mm_support_txerror(asu64(R2), asu64(R1));
L9641:
L9588:
	msysc_m$print_startcon();
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	asi64(R2) = bmode;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("BIN/CAN'T RESOLVE MODES");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9587:
	return;
}

static void mm_type_tx_binto(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 abase;
	i64 bbase;
	i64 amode;
	i64 bmode;
	i64 opc;
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = bmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	bbase = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 93;
	if (asi64(R1) != asi64(R2)) goto L9656;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = abase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9656;
	R1 = 94;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9656:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L9658;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L9659;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L9660;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L9660;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L9660;
	R2 = 97;
	if (asi64(R1) == asi64(R2)) goto L9660;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L9660;
	goto L9661;
L9658:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9663;
	asi64(R1) = bbase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9663;
	R1 = 0;
	R2 = tou64("to:ref+ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L9663:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9665;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9665;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 103;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9654;
L9665:
	goto L9657;
L9659:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9667;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9667;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 104;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9654;
L9667:
	goto L9657;
L9660:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L9654;
	goto L9657;
L9661:
L9657:
	asi64(R1) = abase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9669;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9669;
	R1 = 0;
	asi64(R2) = abase;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L9668;
L9669:
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = abase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9670;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9670;
	R1 = 0;
	asi64(R2) = abase;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L9668;
L9670:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9672;
	R1 = 1;
	asi64(R2) = bmode;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("BIN: modes not compatible: # #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9672:
L9668:
L9654:
	return;
}

static i64 mm_type_getdominantmode(i64 amode, i64 bmode) {
    u64 R1, R2; 
	i64 abase;
	i64 bbase;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = bmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	bbase = asi64(R1);
	asi64(R1) = abase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9675;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9675;
	asi64(R1) = abase;
	asi64(R2) = bbase;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	goto L9673;
L9675:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9677;
	R1 = 0;
	R2 = tou64("Getdom: no dominant mode");
	mm_support_txerror(asu64(R2), asu64(R1));
L9677:
	asi64(R1) = amode;
	goto L9673;
L9673:
	return asi64(R1);
}

static void mm_type_tx_cmpchain(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 u;
	i64 genop;
	u64 q;
	u64 r;
	i64 av_1;
	i64 i;
	asu64(R1) = a;
	q = asu64(R1);
	goto L9680;
L9679:
	R1 = 0;
	R2 = 23;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	asu64(R2) = a;
	if (asu64(R1) != asu64(R2)) goto L9683;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L9682;
L9683:
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L9682:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9680:
	asu64(R1) = q;
	if (asu64(R1)) goto L9679;
	asu64(R1) = a;
	q = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L9685;
L9684:
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = q;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9685:
	asu64(R1) = q;
	if (asu64(R1)) goto L9684;
	R1 = 1;
	i = asi64(R1);
	R1 = 4;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9689;
L9687:
	asu64(R1) = p;
	R2 = 40;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	genop = asi64(R1);
	asi64(R1) = genop;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9691;
	goto L9689;
L9691:
	asi64(R1) = u;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 32;
	R2 += (i64)R3;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
	i += 1; if (i <= av_1) goto L9687;
L9689:
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_callproc(u64 p, u64 a, u64 pargs, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	u64 e;
	u64 pm;
	struct $B93 paramlist;
	struct $B93 arglist;
	struct $B93 newarglist;
	i64 nparams;
	i64 i;
	i64 j;
	i64 k;
	i64 nargs;
	i64 m;
	i64 kwdused;
	i64 qm;
	i64 ismproc;
	u64 name;
	u64 ulist;
	u64 ulistx;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = R1;
	nparams = asi64(R2);
	nargs = asi64(R1);
	R1 = 0;
	ismproc = asi64(R1);
// mm_type.tx_callproc.retry:
L9693:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9695;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L9696;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L9696;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9696;
	goto L9697;
L9695:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9700;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9699;
L9700:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	ismproc = asi64(R1);
// mm_type.tx_callproc.getparams:
L9701:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L9703;
L9702:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L9706;
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L9708;
	R1 = 0;
	R2 = tou64("Param overflow");
	mm_support_txerror(asu64(R2), asu64(R1));
L9708:
	asu64(R1) = e;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L9706:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L9703:
	asu64(R1) = e;
	if (asu64(R1)) goto L9702;
	goto L9698;
L9699:
	goto L9710;
L9709:
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9710:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9709;
	goto L9712;
L9698:
	goto L9694;
L9696:
	R1 = 0;
	R2 = tou64("Can't do ifx/function");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L9694;
L9697:
// mm_type.tx_callproc.dorefproc:
L9712:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) != asi64(R2)) goto L9714;
	asu64(R1) = pargs;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tmethodcall(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pargs = asu64(R1);
	goto L9693;
L9714:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L9716;
	R1 = 0;
	R2 = tou64("Function pointer expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9716:
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9718;
	R1 = 0;
	R2 = tou64("Function expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9718:
	goto L9701;
L9694:
	asu64(R1) = pargs;
	q = asu64(R1);
	goto L9720;
L9719:
	asi64(R1) = nargs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L9723;
	R1 = 0;
	R2 = tou64("Param overflow");
	mm_support_txerror(asu64(R2), asu64(R1));
L9723:
	asu64(R1) = q;
	R2 = (u64)&arglist;
	R3 = (u64)&nargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9720:
	asu64(R1) = q;
	if (asu64(R1)) goto L9719;
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9725;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9725;
	R1 = 0;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
L9725:
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9727;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9730;
L9728:
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L9732;
	R1 = 0;
	R2 = (u64)&paramlist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&arglist;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9731;
L9732:
	R1 = 0;
	R2 = 23;
	R3 = (u64)&arglist;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9731:
	i += 1; if (i <= nargs) goto L9728;
L9730:
	goto L9692;
L9727:
	R1 = 0;
	k = asi64(R1);
	R1 = 0;
	kwdused = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9735;
L9733:
	R1 = 0;
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nparams) goto L9733;
L9735:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9738;
L9736:
	R1 = (u64)&arglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L9740;
	goto L9741;
L9740:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9745;
L9742:
	asu64(R1) = name;
	R2 = (u64)&paramlist;
	asi64(R3) = j;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9747;
	goto L9744;
L9747:
	j += 1; if (j <= nparams) goto L9742;
L9745:
	R1 = 0;
	asu64(R2) = name;
	R3 = tou64("Can't find kwd param: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9744:
	R1 = (u64)&newarglist;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L9749;
	R1 = 0;
	asu64(R2) = name;
	R3 = tou64("Kwd: # already used or was implicit");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9749:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&newarglist;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	kwdused = asi64(R1);
	goto L9739;
L9741:
	asi64(R1) = kwdused;
	if (!asi64(R1)) goto L9751;
	R1 = 0;
	R2 = tou64("Normal param follows kwd");
	mm_support_txerror(asu64(R2), asu64(R1));
L9751:
	asi64(R1) = k;
	asi64(R2) = nparams;
	if (asi64(R1) < asi64(R2)) goto L9753;
	msysc_m$print_startcon();
	R1 = tou64("K=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = k;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("NPARAMS=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Too many params supplied");
	mm_support_txerror(asu64(R2), asu64(R1));
L9753:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9755;
	R1 = 0;
	goto L9754;
L9755:
	asu64(R1) = q;
L9754:
	R2 = (u64)&newarglist;
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L9739:
	i += 1; if (i <= nargs) goto L9736;
L9738:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9758;
L9756:
	R1 = (u64)&newarglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pm = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9760;
	asu64(R1) = pm;
	R2 = 161;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9762;
	R1 = 0;
	R2 = 0;
	asi64(R3) = i;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Param not optional: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9762:
	asu64(R1) = pm;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9764;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pm;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L9763;
L9764:
	R1 = 3;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L9763:
L9760:
	i += 1; if (i <= nparams) goto L9756;
L9758:
	R1 = 0;
	ulist = asu64(R1);
	R1 = 0;
	ulistx = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9767;
L9765:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pm = asu64(R1);
	R1 = (u64)&newarglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = pm;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9769;
	R1 = 1;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = pm;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = R2;
	m = asi64(R3);
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qm = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = qm;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9771;
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = qm;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("&param: type mismatch");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9771:
	R1 = 55;
	asu64(R2) = q;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = pm;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9768;
L9769:
	R1 = 0;
	asu64(R2) = pm;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9768:
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	i += 1; if (i <= nparams) goto L9765;
L9767:
	asu64(R1) = ulist;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9692:
	return;
}

static void mm_type_tx_unary(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 size;
	i64 amode;
	i64 mbase;
	i64 tmax;
	i64 x;
	i64 xhigh;
	i64 resmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asi64(R1) = amode;
	resmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L9774;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L9775;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L9775;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L9775;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L9776;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L9776;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L9776;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L9777;
	goto L9778;
L9774:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	resmode = asi64(R1);
	goto L9773;
L9775:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) <= asi64(R2)) goto L9780;
	R1 = 0;
	R2 = tou64("not num");
	mm_support_txerror(asu64(R2), asu64(R1));
L9780:
	goto L9773;
L9776:
	asi64(R1) = amode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L9782;
	R1 = 0;
	R2 = tou64("toboolt");
	mm_support_txerror(asu64(R2), asu64(R1));
L9782:
	goto L9773;
L9777:
	R1 = 3;
	resmode = asi64(R1);
	goto L9773;
L9778:
	msysc_m$print_startcon();
	R1 = tou64("TTT");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9773:
	asi64(R1) = resmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_prop(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 size;
	i64 amode;
	i64 mbase;
	i64 tmax;
	i64 x;
	i64 xhigh;
	i64 resmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asi64(R1) = amode;
	resmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9785;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9785;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9785;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9785;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9785;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9786;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9786;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9787;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9787;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9788;
	goto L9789;
L9785:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_do_bounds(asu64(R2), asu64(R1));
	goto L9783;
	goto L9784;
L9786:
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 62;
	if (asi64(R2) != asi64(R3)) goto L9791;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	goto L9790;
L9791:
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
L9790:
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 7;
	if (asi64(R2) != asi64(R3)) goto L9793;
	R2 = 1;
	goto L9792;
L9793:
	R2 = 8;
L9792:
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	R1 = 0;
	asi64(R2) = size;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	resmode = asi64(R1);
	goto L9784;
L9787:
	R1 = 3;
	resmode = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L9795;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	goto L9794;
L9795:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
L9794:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L9797;
	asi64(R1) = mbase;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9799;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L9800;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9801;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9802;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9803;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9803;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9803;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9803;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9803;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9803;
	goto L9804;
L9799:
	R1 = -128;
	x = asi64(R1);
	goto L9798;
L9800:
	R1 = -32768;
	x = asi64(R1);
	goto L9798;
L9801:
	R1 = -2147483648;
	x = asi64(R1);
	goto L9798;
L9802:
	R1 = 0x8000000000000000;
	x = asi64(R1);
	goto L9798;
L9803:
	R1 = 0;
	x = asi64(R1);
	goto L9798;
L9804:
	R1 = 0;
	R2 = 1;
	asi64(R3) = mbase;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do minvalue on #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9798:
	goto L9796;
L9797:
	asi64(R1) = mbase;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9806;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L9807;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9808;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9809;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9810;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9810;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9811;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9812;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9813;
	goto L9814;
L9806:
	R1 = 127;
	x = asi64(R1);
	goto L9805;
L9807:
	R1 = 32767;
	x = asi64(R1);
	goto L9805;
L9808:
	R1 = 2147483647;
	x = asi64(R1);
	goto L9805;
L9809:
	R1 = 9223372036854775807;
	x = asi64(R1);
	goto L9805;
L9810:
	R1 = 255;
	x = asi64(R1);
	goto L9805;
L9811:
	R1 = 65535;
	x = asi64(R1);
	goto L9805;
L9812:
	R1 = 4294967295;
	x = asi64(R1);
	goto L9805;
L9813:
	R1 = 0;
	x = asi64(R1);
	R1 = (u64)&x;
	(*toi64p(R1)) -=1;
	R1 = 4;
	resmode = asi64(R1);
	goto L9805;
L9814:
	R1 = 0;
	R2 = 1;
	asi64(R3) = mbase;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do maxvalue on #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9805:
L9796:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9784;
L9788:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L9816;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	amode = asi64(R1);
	goto L9815;
L9816:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
L9815:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asi64(R2) = amode;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L9783;
	goto L9784;
L9789:
	msysc_m$print_startcon();
	R1 = tou64("PROP");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9784:
	asi64(R1) = resmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9783:
	return;
}

static void mm_type_tx_unaryto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L9819;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L9819;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L9819;
	goto L9820;
L9819:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L9822;
	R1 = 0;
	R2 = tou64("Not int");
	mm_support_txerror(asu64(R2), asu64(R1));
L9822:
	goto L9818;
L9820:
L9818:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	u64 pc;
	u64 pl;
	i64 u;
	asu64(R1) = pcond;
	pc = asu64(R1);
	asu64(R1) = plist;
	pl = asu64(R1);
	R1 = 0;
	u = asi64(R1);
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L9825;
	asi64(R1) = t;
	u = asi64(R1);
L9825:
	goto L9829;
L9826:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pc;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = pl;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9831;
	asi64(R1) = u;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9833;
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L9832;
L9833:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L9834;
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9836;
	R1 = 0;
	R2 = tou64("IF/LV?");
	mm_support_txerror(asu64(R2), asu64(R1));
L9836:
	goto L9832;
L9834:
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L9832:
L9831:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = pl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pl = asu64(R1);
L9829:
	asu64(R1) = pc;
	if (asu64(R1)) goto L9826;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9838;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9838;
	R1 = 0;
	R2 = tou64("else needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L9838:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = pelse;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9840;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L9842;
	asu64(R1) = pelse;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9844;
	R1 = 0;
	R2 = tou64("IF/LV2?");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L9843;
L9844:
	asu64(R1) = pelse;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L9843:
L9842:
L9840:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9846;
	asu64(R1) = plist;
	pl = asu64(R1);
	goto L9850;
L9847:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9852;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pl;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L9852:
	asu64(R1) = pl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pl = asu64(R1);
L9850:
	asu64(R1) = pl;
	if (asu64(R1)) goto L9847;
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9854;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pelse;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L9854:
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9846:
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = plist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L9856;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9856;
	asu64(R1) = pcond;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L9858;
	asu64(R1) = plist;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L9857;
L9858:
	asu64(R1) = pcond;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L9859;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9861;
	R1 = 6;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	pelse = asu64(R1);
L9861:
	asu64(R1) = pelse;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L9859:
L9857:
L9856:
	return;
}

static void mm_type_tx_incrto(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9864;
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L9866;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L9867;
	goto L9868;
L9866:
	R1 = 86;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9865;
L9867:
	R1 = 87;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9865;
L9868:
L9865:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9863;
L9864:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L9870;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L9871;
	goto L9872;
L9870:
	R1 = 84;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9869;
L9871:
	R1 = 85;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9869;
L9872:
L9869:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9863:
	R1 = 0;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_tx_for(u64 pindex, u64 pfrom, u64 pbody) {
    u64 R1, R2, R3, R4; 
	u64 pto;
	u64 pstep;
	u64 plocal;
	u64 plist;
	i64 u;
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = pto;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pstep = asu64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = pindex;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pindex;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9875;
	R1 = 0;
	R2 = tou64("Loop index not a variable");
	mm_support_txerror(asu64(R2), asu64(R1));
L9875:
	asu64(R1) = pindex;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = pindex;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pfrom;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pto;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pstep;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_type_tx_forall(u64 pindex, u64 plist, u64 pbody) {
    u64 R1, R2, R3, R4; 
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 passign;
	i64 u;
	i64 mlist;
	i64 elemtype;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plocal = asu64(R1);
	asu64(R1) = plocal;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	passign = asu64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = pindex;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = pfrom;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = pto;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = plist;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = plist;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mlist = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9878;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9879;
	goto L9880;
L9878:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	goto L9877;
L9879:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	goto L9877;
L9880:
	R1 = 0;
	R2 = tou64("forall/can't iterate");
	mm_support_txerror(asu64(R2), asu64(R1));
L9877:
	R1 = 0;
	R2 = 23;
	asu64(R3) = plocal;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = plocal;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9882;
	asi64(R1) = elemtype;
	asu64(R2) = plocal;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = plocal;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9882:
	R1 = 0;
	R2 = 23;
	asu64(R3) = passign;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_type_tx_index(u64 p, u64 a, u64 b, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 emode;
	i64 pmode;
	i64 tmode;
	i64 tbasemode;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9885;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9885;
	R1 = 0;
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't index: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9885:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_tx_makerange(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 9;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_ptr(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9889;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9890;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9891;
	goto L9892;
L9889:
	R1 = 0;
	R2 = tou64("Deref Void");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L9888;
L9890:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9888;
L9891:
	msysc_m$print_startcon();
	R1 = tou64("DEREF SLICE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9888;
L9892:
	R1 = 0;
	R2 = tou64("PTR: need ref T");
	mm_support_txerror(asu64(R2), asu64(R1));
L9888:
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_setrecordsize(i64 m) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	struct $B88 fieldlist;
	i64 i;
	i64 nfields;
	i64 indent;
	i64 nrfields;
	i64 size;
	i64 index;
	i64 maxalign;
	u64 d;
	u64 e;
	u64 flags;
	i64 flag;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L9895;
	goto L9893;
L9895:
	R1 = (u64)&mm_type_setrecordsize_depth;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L9897;
	R1 = tou64("Recursive record?");
	mm_support_serror(asu64(R1));
L9897:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	R1 = 83;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L9899;
L9898:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9902;
	asi64(R1) = nfields;
	R2 = 200;
	if (asi64(R1) < asi64(R2)) goto L9904;
	R1 = 0;
	R2 = tou64("srs:too many fields");
	mm_support_gerror(asu64(R2), asu64(R1));
L9904:
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_type_setmodesize(asi64(R1));
	asu64(R1) = e;
	R2 = 136;
	R1 += (i64)R2;
	flags = asu64(R1);
L9905:
	asu64(R1) = flags;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 83;
	if (asu64(R1) == asu64(R2)) goto L9907;
	R2 = 85;
	if (asu64(R1) == asu64(R2)) goto L9907;
	goto L9908;
L9907:
	asu64(R1) = flags;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	asi64(R1) = flag;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&flags;
	(*tou64p(R1)) += 1;
	goto L9905;
L9908:
	goto L9906;
	goto L9905;
L9906:
	asu64(R1) = e;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L9909:
	R1 = (u64)&flags;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	asi64(R1) = flag;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L9912;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L9913;
	goto L9914;
L9912:
	goto L9911;
L9913:
	R1 = 69;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L9911;
L9914:
	goto L9910;
L9911:
	goto L9909;
L9910:
L9902:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L9899:
	asu64(R1) = e;
	if (asu64(R1)) goto L9898;
	R1 = 69;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&fieldlist;
	asi64(R3) = nfields;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	mm_type_countedfields = asi64(R1);
	R1 = 2;
	index = asi64(R1);
	R1 = 1;
	maxalign = asi64(R1);
	R1 = (u64)&maxalign;
	asu64(R2) = d;
	R3 = 149;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
	R4 = (u64)&size;
	R5 = (u64)&index;
	R6 = (u64)&fieldlist;
	R7 = 83;
	mm_type_scanrecord(asi64(R7), asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 149;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9916;
	asi64(R1) = maxalign;
	asi64(R2) = size;
	asi64(R1) = mm_type_roundoffset(asi64(R2), asi64(R1));
	size = asi64(R1);
	asi64(R1) = maxalign;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L9915;
L9916:
	R1 = 1;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9918;
	R1 = 8;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L9917;
L9918:
	asi64(R1) = size;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9919;
	R1 = 4;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L9917;
L9919:
	asi64(R1) = size;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9920;
	R1 = 2;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L9920:
L9917:
L9915:
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	asi64(R1) = mm_type_countedfields;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = m;
	mm_type_checkblocktype(asi64(R1));
	R1 = (u64)&mm_type_setrecordsize_depth;
	(*toi64p(R1)) -=1;
L9893:
	return;
}

static void mm_type_checkblocktype(i64 m) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9923;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9923;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9923;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9923;
	goto L9924;
L9923:
	R1 = 0;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9922;
L9924:
L9922:
	return;
}

static void mm_type_scanrecord(i64 state, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 e;
	u64 f;
	u64 ea;
	i64 size;
	i64 fieldsize;
	i64 bitoffset;
	i64 alignment;
	i64 newoffset;
	R1 = 0;
	size = asi64(R1);
	R1 = 0;
	bitoffset = asi64(R1);
	goto L9927;
L9926:
	asu64(R1) = f;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L9930;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L9930;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L9931;
	goto L9932;
L9930:
	asu64(R1) = maxalign;
	asi64(R2) = calign;
	asi64(R3) = offset;
	R4 = (u64)&fieldsize;
	asu64(R5) = index;
	asu64(R6) = fields;
	asu64(R7) = f;
	mm_type_scanrecord(asi64(R7), asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L9929;
L9931:
	asi64(R1) = state;
	R2 = 85;
	if (asi64(R1) != asi64(R2)) goto L9934;
	R1 = (u64)&mm_type_countedfields;
	(*toi64p(R1)) += 1;
L9934:
	asi64(R1) = size;
	asu64(R2) = isize;
	*toi64p(R2) = asi64(R1);
	goto L9925;
	goto L9929;
L9932:
	asu64(R1) = f;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L9936;
	R1 = 0;
	fieldsize = asi64(R1);
	asu64(R1) = f;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ea = asu64(R1);
	asu64(R1) = ea;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = bitoffset;
	asu64(R2) = f;
	R3 = 150;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 148;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&bitoffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = bitoffset;
	R2 = (u64)&mm_decls_ttsize;
	asu64(R3) = f;
	R4 = 128;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	R3 = 8;
	asi64(R2) *= asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L9938;
	R1 = 0;
	R2 = tou64("Bit fields overflow type");
	mm_support_txerror(asu64(R2), asu64(R1));
L9938:
	goto L9935;
L9936:
	asu64(R1) = f;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9939;
	R1 = 0;
	bitoffset = asi64(R1);
	asu64(R1) = f;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	fieldsize = asi64(R1);
	asu64(R1) = e;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = f;
	R3 = 151;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9935;
L9939:
	R1 = 0;
	bitoffset = asi64(R1);
	asi64(R1) = state;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L9941;
	R1 = (u64)&mm_type_countedfields;
	(*toi64p(R1)) += 1;
L9941:
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = f;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	fieldsize = asi64(R1);
	asi64(R1) = calign;
	if (!asi64(R1)) goto L9943;
	asu64(R1) = f;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asu64(R2) = maxalign;
	asi64(R2) = *toi64p(R2);
	if (asi64(R1) <= asi64(R2)) goto L9945;
	asi64(R1) = alignment;
	asu64(R2) = maxalign;
	*toi64p(R2) = asi64(R1);
L9945:
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = mm_type_roundoffset(asi64(R2), asi64(R1));
	newoffset = asi64(R1);
	asi64(R1) = newoffset;
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L9942;
L9943:
	asi64(R1) = offset;
	newoffset = asi64(R1);
L9942:
	asi64(R1) = newoffset;
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = newoffset;
	offset = asi64(R1);
L9935:
L9929:
	asi64(R1) = state;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L9947;
	asi64(R1) = fieldsize;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = fieldsize;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L9946;
L9947:
	asi64(R1) = size;
	asi64(R2) = fieldsize;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	size = asi64(R1);
L9946:
L9927:
	asu64(R1) = fields;
	asu64(R2) = index;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) += 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L9926;
L9925:
	return;
}

static i64 mm_type_roundoffset(i64 offset, i64 alignment) {
    u64 R1, R2; 
	i64 mask;
	asi64(R1) = alignment;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9950;
	asi64(R1) = offset;
	goto L9948;
L9950:
	asi64(R1) = alignment;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mask = asi64(R1);
	goto L9952;
L9951:
	R1 = (u64)&offset;
	(*toi64p(R1)) += 1;
L9952:
	asi64(R1) = offset;
	asi64(R2) = mask;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L9951;
	asi64(R1) = offset;
	goto L9948;
L9948:
	return asi64(R1);
}

static void mm_type_tx_convert(u64 p, u64 a, i64 hard) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9956;
	goto L9957;
L9956:
	R1 = 0;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	mm_type_tx_makelist(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9955;
L9957:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = hard;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L9955:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	return;
}

static void mm_type_tx_makelist(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3, R4, R5; struct $B60 R1_B60; 
	i64 alength;
	i64 tlength;
	i64 elemtype;
	i64 newt;
	i64 i;
	i64 nfields;
	i64 isconst;
	i64 m;
	u64 q;
	u64 b;
	u64 e;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alength = asi64(R1);
	R1 = 0;
	newt = asi64(R1);
	R1 = 1;
	isconst = asi64(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tlength = asi64(R1);
	asi64(R1) = tlength;
	if (!asi64(R1)) goto L9960;
	asi64(R1) = alength;
	asi64(R2) = tlength;
	if (asi64(R1) >= asi64(R2)) goto L9962;
	R1 = 0;
	asi64(R2) = tlength;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = 0;
	asi64(R3) = alength;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Too few elements");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L9961;
L9962:
	asi64(R1) = alength;
	asi64(R2) = tlength;
	if (asi64(R1) <= asi64(R2)) goto L9963;
	R1 = 0;
	asi64(R2) = tlength;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = 0;
	asi64(R3) = alength;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Too many elements");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9963:
L9961:
L9960:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9965;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9966;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9967;
	goto L9968;
L9965:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	asi64(R1) = tlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9970;
	R1 = 0;
	asi64(R2) = alength;
	R3 = (u64)&mm_decls_ttlower;
	asi64(R4) = t;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asi64(R4) = elemtype;
	R5 = 0;
	asi64(R1) = mm_lib_createarraymodek(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	newt = asi64(R1);
	goto L9969;
L9970:
	asi64(R1) = t;
	newt = asi64(R1);
L9969:
	asu64(R1) = a;
	q = asu64(R1);
	goto L9972;
L9971:
	asi64(R1) = lv;
	asi64(R2) = elemtype;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9975;
	R1 = 0;
	isconst = asi64(R1);
L9975:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9972:
	asu64(R1) = q;
	if (asu64(R1)) goto L9971;
	asi64(R1) = newt;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9964;
L9966:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	goto L9977;
L9976:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9980;
	goto L9982;
L9981:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L9985;
	goto L9983;
L9985:
L9982:
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L9981;
L9983:
	asi64(R1) = lv;
	asu64(R2) = e;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9987;
	R1 = 0;
	isconst = asi64(R1);
L9987:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9980:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L9977:
	asu64(R1) = q;
	if (!asu64(R1)) goto L9988;
	asu64(R1) = e;
	if (asu64(R1)) goto L9976;
L9988:
	goto L9990;
L9989:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L9990:
	asu64(R1) = e;
	if (!asu64(R1)) goto L9992;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9989;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L9989;
L9992:
	asu64(R1) = q;
	if (asu64(R1)) goto L9995;
	asu64(R1) = e;
	if (!asu64(R1)) goto L9994;
L9995:
	R1 = 0;
	R2 = tou64("Can't initialise unions");
	mm_support_txerror(asu64(R2), asu64(R1));
L9994:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9964;
L9967:
	msysc_m$print_startcon();
	R1 = tou64("TSLICE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9964;
L9968:
	R1 = 0;
	R2 = 1;
	asi64(R3) = t;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Unknown makelist type: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9964:
	asi64(R1) = isconst;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = p;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L9997;
	asi64(R1) = mm_type_inidata;
	if (asi64(R1)) goto L9999;
	asi64(R1) = isconst;
	if (!asi64(R1)) goto L9999;
	R1 = 10;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = e;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = e;
	mm_lib_addstatic(asu64(R1));
	R1 = 0;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = q;
	*(struct $B60*)(R2) = (R1_B60);
	asu64(R1) = q;
	asu64(R2) = e;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9999:
L9997:
	return;
}

static void mm_type_tx_makeslicefromlist(u64 p, u64 a, i64 t) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MAKESLICE/TX");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("MAKESLICE FROM LIST NOT READY");
	mm_support_txerror(asu64(R2), asu64(R1));
	return;
}

static void mm_type_tx_makeslice(u64 p, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("MAKESLICE/TX");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10003;
	R1 = 0;
	R2 = tou64("slice init not ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L10003:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10005;
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10007;
	R1 = 0;
	R2 = tou64("slice/ptr mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L10007:
L10005:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	msysc_m$print_startcon();
	R1 = tou64("MKSLICE2");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_makeset(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10012;
L10009:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10014;
	R1 = 0;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10014:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L10012:
	asu64(R1) = a;
	if (asu64(R1)) goto L10009;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_dot(u64 p, u64 a, u64 b, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 recmode;
	i64 recbasemode;
	i64 i;
	i64 j;
	i64 newtag;
	i64 tmode;
	u64 q;
	u64 pindex;
	u64 d;
	u64 dequiv;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	recmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	recbasemode = asi64(R1);
	goto L10017;
L10016:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = tmode;
	R2 = R1;
	asu64(R3) = a;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	recmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	recbasemode = asi64(R1);
L10017:
	asi64(R1) = recbasemode;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10016;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10020;
	R1 = 0;
	R2 = tou64("Bad record type");
	mm_support_txerror(asu64(R2), asu64(R1));
L10020:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10022;
	asi64(R1) = recmode;
	asu64(R2) = d;
	asu64(R1) = mm_type_resolvefield(asu64(R2), asi64(R1));
	R2 = R1;
	asu64(R3) = b;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	d = asu64(R1);
L10022:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L10024;
	asu64(R1) = d;
	R2 = 150;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	asu64(R2) = d;
	R3 = 148;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	j = asi64(R1);
	asu64(R1) = d;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dequiv = asu64(R1);
	asu64(R1) = dequiv;
	asu64(R2) = b;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = dequiv;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) != asi64(R2)) goto L10026;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pindex = asu64(R1);
	R1 = 51;
	newtag = asi64(R1);
	goto L10025;
L10026:
	R1 = 3;
	asi64(R2) = j;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = 3;
	asi64(R3) = i;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pindex = asu64(R1);
	R1 = 9;
	asu64(R2) = pindex;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pindex;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pindex;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 52;
	newtag = asi64(R1);
L10025:
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	asi64(R1) = newtag;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pindex;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10015;
L10024:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
L10015:
	return;
}

static u64 mm_type_resolvefield(u64 d, i64 m) {
    u64 R1, R2, R3; 
	u64 e;
	u64 t;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10029;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10030;
	goto L10031;
L10029:
	goto L10028;
L10030:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10033;
	R1 = 0;
	R2 = tou64("3:record expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L10033:
	goto L10028;
L10031:
	R1 = 0;
	R2 = tou64("4:record expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L10028:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	t = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = t;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L10035;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10035:
	asu64(R1) = e;
	goto L10027;
L10027:
	return asu64(R1);
}

static void mm_type_tx_andl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 6;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_convintconst(u64 p, i64 x) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_sliceptr(u64 p, u64 a) {
    u64 R1, R2, R3, R4, R5; 
	i64 m;
	i64 tmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10040;
	goto L10041;
L10040:
	goto L10039;
L10041:
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("SLICEPTR #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10039:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&mm_decls_ttlower;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&mm_decls_tttarget;
	asi64(R5) = m;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5*4));
	R4 = toi64(toi32(R4));
	R5 = 0;
	asi64(R1) = mm_lib_createarraymodek(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	tmode = asi64(R1);
	R1 = 0;
	asi64(R2) = tmode;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_swap(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 av;
	i64 bv;
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 23;
	asu64(R2) = b;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10044;
	R1 = 0;
	R2 = tou64("SWAP: type mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L10044:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_select(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	i64 i;
	i64 u;
	u64 q;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	goto L10047;
L10046:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	asu64(R2) = b;
	if (asu64(R1) != asu64(R2)) goto L10050;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L10049;
L10050:
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L10049:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L10047:
	asu64(R1) = q;
	if (asu64(R1)) goto L10046;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	goto L10052;
L10051:
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = q;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L10052:
	asu64(R1) = q;
	if (asu64(R1)) goto L10051;
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_case(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 amode;
	i64 u;
	u64 wt;
	u64 w;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 106;
	if (asi64(R1) != asi64(R2)) goto L10056;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L10056;
	R1 = 0;
	R2 = tou64("&docase");
	mm_support_gerror(asu64(R2), asu64(R1));
L10056:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10058;
	R1 = 23;
	amode = asi64(R1);
	goto L10057;
L10058:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
L10057:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10060;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = amode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L10060;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	amode = asi64(R1);
L10060:
	R1 = 0;
	u = asi64(R1);
	asu64(R1) = b;
	wt = asu64(R1);
	goto L10062;
L10061:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L10065;
L10064:
	R1 = 0;
	R2 = 23;
	asu64(R3) = w;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L10068;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10070;
	R1 = 0;
	R2 = tou64("case: need int index");
	mm_support_txerror(asu64(R2), asu64(R1));
L10070:
	goto L10067;
L10068:
	asi64(R1) = amode;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10072;
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = w;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10074;
	R1 = 0;
	R2 = tou64("CASE/BOOL?");
	mm_support_txerror(asu64(R2), asu64(R1));
	R1 = 18;
	asu64(R2) = w;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L10074:
	goto L10071;
L10072:
	R1 = 0;
	asi64(R2) = amode;
	asu64(R3) = w;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L10071:
L10067:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L10065:
	asu64(R1) = w;
	if (asu64(R1)) goto L10064;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = wt;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10076;
	asi64(R1) = u;
	if (!asi64(R1)) goto L10078;
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	goto L10077;
L10078:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
L10077:
L10076:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L10062:
	asu64(R1) = wt;
	if (asu64(R1)) goto L10061;
	asu64(R1) = c;
	if (!asu64(R1)) goto L10080;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10082;
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L10082:
	goto L10079;
L10080:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10083;
	R1 = 0;
	R2 = tou64("case needs else");
	mm_support_txerror(asu64(R2), asu64(R1));
L10083:
L10079:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10085;
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10084;
L10085:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10084:
	return;
}

static void mm_type_tx_notl(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_typepun(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 smode;
	i64 tmode;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10089;
	goto L10090;
L10089:
	R1 = 0;
	R2 = tou64("TYPEPUN/LIST");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L10088;
L10090:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	smode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = smode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10093;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = tmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10092;
L10093:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = smode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10094;
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = tmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10092;
L10094:
	R1 = 0;
	R2 = tou64("Invalid type-punning; only real<->int");
	mm_support_txerror(asu64(R2), asu64(R1));
L10092:
	asi64(R1) = tmode;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L10097;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L10096;
L10097:
	R1 = 3;
	tmode = asi64(R1);
L10096:
	asi64(R1) = tmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10088:
	return;
}

static void mm_type_tx_exit(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10100;
	goto L10098;
L10100:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10102;
	R1 = 0;
	R2 = tou64("exit/etc not const");
	mm_support_txerror(asu64(R2), asu64(R1));
L10102:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L10098:
	return;
}

static void mm_type_tx_goto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 m;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L10106;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L10105;
L10106:
	R1 = 0;
	R2 = tou64("goto: not label");
	mm_support_txerror(asu64(R2), asu64(R1));
L10105:
	return;
}

static void mm_type_tx_switch(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	struct $B96 valueset;
	u64 wt;
	u64 w;
	i64 ax;
	i64 bx;
	i64 i;
	i64 u;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L10109;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L10109;
	R1 = 0;
	R2 = tou64("&doswitch");
	mm_support_gerror(asu64(R2), asu64(R1));
L10109:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L10111;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10113;
	R1 = 0;
	R2 = tou64("not ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L10113:
	goto L10110;
L10111:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L10110:
	R1 = 2048;
	R2 = 0;
	R3 = (u64)&valueset;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 0;
	u = asi64(R1);
	asu64(R1) = b;
	wt = asu64(R1);
	goto L10115;
L10114:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L10118;
L10117:
	R1 = 0;
	R2 = 23;
	asu64(R3) = w;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	asi64(R1) = mm_lib_isconstunit(asu64(R1));
	if (asi64(R1)) goto L10121;
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = w;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("Switch not constant");
	mm_support_txerror(asu64(R2), asu64(R1));
L10121:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = w;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L10123;
	goto L10124;
L10123:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
// mm_type.tx_switch.dorange:
L10125:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L10128;
L10126:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L10131;
	asi64(R1) = i;
	R2 = 2047;
	if (asi64(R1) <= asi64(R2)) goto L10130;
L10131:
	R1 = 0;
	R2 = tou64("switch: value out of range");
	mm_support_txerror(asu64(R2), asu64(R1));
L10130:
	R1 = (u64)&valueset;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10133;
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Duplicate switch value");
	mm_support_txerror(asu64(R2), asu64(R1));
L10133:
	R1 = 1;
	R2 = (u64)&valueset;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= bx) goto L10126;
L10128:
	goto L10122;
L10124:
	R1 = 0;
	R2 = 3;
	asu64(R3) = w;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10135;
	R1 = 0;
	R2 = tou64("Switch value: not const int");
	mm_support_txerror(asu64(R2), asu64(R1));
L10135:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L10125;
L10122:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L10118:
	asu64(R1) = w;
	if (asu64(R1)) goto L10117;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = wt;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10137;
	asi64(R1) = u;
	if (!asi64(R1)) goto L10139;
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	goto L10138;
L10139:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
L10138:
L10137:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L10115:
	asu64(R1) = wt;
	if (asu64(R1)) goto L10114;
	asu64(R1) = c;
	if (!asu64(R1)) goto L10141;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10143;
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L10143:
	goto L10140;
L10141:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10144;
	R1 = 0;
	R2 = tou64("switch needs else");
	mm_support_txerror(asu64(R2), asu64(R1));
L10144:
L10140:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10146;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L10148;
L10147:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10151;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = b;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L10151:
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = w;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L10148:
	asu64(R1) = w;
	if (asu64(R1)) goto L10147;
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10153;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = c;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10152;
L10153:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10152:
	goto L10145;
L10146:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10145:
	return;
}

static void mm_type_tx_addroffirst(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	i64 m;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10156;
	R1 = 0;
	R2 = tou64("&. ref[] expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L10156:
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10158;
	R1 = 1;
	asu64(R2) = a;
	R3 = 40;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10158:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_return(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	i64 m;
	i64 nvalues;
	i64 nret;
	i64 i;
	u64 pmult;
	u64 q;
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nret = asi64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10161;
	asi64(R1) = nret;
	if (!asi64(R1)) goto L10163;
	R1 = 0;
	R2 = tou64("return value(s) missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L10163:
	goto L10159;
	goto L10160;
L10161:
	asi64(R1) = nret;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10164;
	R1 = 0;
	R2 = tou64("Superfluous return value");
	mm_support_txerror(asu64(R2), asu64(R1));
L10164:
L10160:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10166;
	R1 = 25;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nret;
	if (asi64(R1) == asi64(R2)) goto L10168;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10170;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10170;
	goto L10171;
L10170:
	R1 = 0;
	R2 = tou64("return constructor not supported");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L10169;
L10171:
	R1 = 0;
	R2 = tou64("Wrong number of return values");
	mm_support_txerror(asu64(R2), asu64(R1));
L10169:
L10168:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10174;
L10172:
	R1 = 0;
	asu64(R2) = pmult;
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= nret) goto L10172;
L10174:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10176;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10175;
L10176:
	R1 = 28;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10175:
	goto L10165;
L10166:
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L10178;
	R1 = 0;
	R2 = tou64("RETERROR?");
	mm_support_txerror(asu64(R2), asu64(R1));
L10178:
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10180;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10179;
L10180:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L10179:
L10165:
	R1 = (u64)&mm_decls_ttisshort;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10182;
	R1 = 0;
	R2 = tou64("SHORT RET TYPE");
	mm_support_txerror(asu64(R2), asu64(R1));
L10182:
L10159:
	return;
}

static void mm_type_tx_dotindex(u64 p, u64 a, u64 b, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 pmode;
	u64 i;
	u64 j;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	pmode = asi64(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10185;
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10187;
	R1 = 61;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	R2 = R1;
	asu64(R3) = a;
	R4 = 53;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10186;
L10187:
	R1 = 0;
	R2 = tou64("a.[i]: not int/str value");
	mm_support_txerror(asu64(R2), asu64(R1));
L10186:
L10185:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L10189;
	goto L10190;
L10189:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	i = asu64(R1);
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	j = asu64(R1);
	asu64(R1) = i;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = j;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L10192;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10192;
	asu64(R1) = i;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = j;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L10194;
	asu64(R1) = b;
	R2 = 16;
	R1 += (i64)R2;
	asu64(R2) = b;
	R3 = 24;
	R2 += (i64)R3;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L10194:
L10192:
	goto L10188;
L10190:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L10188:
	asi64(R1) = pmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_slice(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10197;
	R1 = 0;
	R2 = 1;
	R3 = 12;
	asu64(R4) = mm_decls_currproc;
	asi64(R1) = mm_lib_createslicemodek(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10196;
L10197:
	R1 = 1;
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10199;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10200;
	goto L10201;
L10199:
	R1 = 0;
	R2 = 1;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu64(R4) = mm_decls_currproc;
	asi64(R1) = mm_lib_createslicemodek(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10198;
L10200:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10198;
L10201:
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(A.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("a[i..j]: not array");
	mm_support_txerror(asu64(R2), asu64(R1));
L10198:
L10196:
	return;
}

static void mm_type_twiden(u64 p, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 u;
	i64 mbase;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = R2;
	m = asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	asi64(R1) = mbase;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10204;
	goto L10202;
L10204:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L10206;
	goto L10202;
L10206:
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = mbase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10208;
	goto L10202;
L10208:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10210;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L10210;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L10210;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L10210;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L10210;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L10210;
	goto L10211;
L10210:
	R1 = 58;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10209;
L10211:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("widen? #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10209:
L10202:
	return;
}

static void mm_type_tstringslice(u64 p, i64 slicemode) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	u64 prange;
	i64 length;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = slicemode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L10214;
	R1 = 0;
	R2 = tou64("Not char slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L10214:
	asu64(R1) = p;
	a = asu64(R1);
	R1 = 48;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10216;
	goto L10215;
L10216:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	b = asu64(R1);
	R1 = 36;
	asu64(R2) = b;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 3;
	R3 = 1;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	prange = asu64(R1);
	R1 = 9;
	asu64(R2) = prange;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = prange;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L10215:
	asi64(R1) = slicemode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_bitfield(u64 p, u64 a, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 j;
	i64 bitsize;
	i64 topbit;
	u64 r;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10219;
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10219;
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10221;
	R1 = 61;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	R2 = R1;
	asu64(R3) = a;
	R4 = 53;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10220;
L10221:
	R1 = 0;
	R2 = tou64("Int/ref needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L10220:
L10219:
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_ttbasetype;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	topbit = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10223;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10224;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10225;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10226;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10226;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10227;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10228;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L10229;
	goto L10230;
L10223:
	R1 = 0;
	i = asi64(R1);
	R1 = 7;
	j = asi64(R1);
	goto L10222;
L10224:
	asi64(R1) = topbit;
	j = asi64(R1);
	asi64(R1) = topbit;
	R2 = 7;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	goto L10222;
L10225:
	R1 = 0;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L10222;
L10226:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L10232;
	R1 = 0;
	R2 = tou64("Can't assign");
	mm_support_txerror(asu64(R2), asu64(R1));
L10232:
	R1 = 0;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L10222;
L10227:
	asi64(R1) = topbit;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L10222;
L10228:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	j = asi64(R1);
	goto L10222;
L10229:
	asi64(R1) = bitsize;
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	i = asi64(R1);
	asi64(R1) = topbit;
	j = asi64(R1);
	goto L10222;
L10230:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("BITFIELD");
	mm_support_txerror(asu64(R2), asu64(R1));
L10222:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) != asi64(R2)) goto L10234;
	R1 = 51;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L10236;
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	mm_type_addnotl(asu64(R1));
L10236:
	goto L10233;
L10234:
	R1 = 3;
	asi64(R2) = j;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = 3;
	asi64(R3) = i;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	R1 = 1;
	asu64(R2) = r;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = r;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 9;
	asu64(R2) = r;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 52;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L10233:
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_deref(u64 a, i64 needres) {
    u64 R1, R2, R3; 
	i64 abasemode;
	i64 tmode;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abasemode = asi64(R1);
	goto L10239;
L10238:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = tmode;
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abasemode = asi64(R1);
L10239:
	asi64(R1) = abasemode;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10238;
	return;
}

static void mm_type_tmethodcall(u64 p, u64 pdot, u64 pargs) {
    u64 R1, R2, R3; 
	i64 mrec;
	u64 prec;
	u64 pfield;
	u64 pfunc;
	u64 d;
	u64 e;
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	prec = asu64(R1);
	asu64(R1) = pdot;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfield = asu64(R1);
	asu64(R1) = prec;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mrec = asi64(R1);
	asu64(R1) = pfield;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mrec;
	asu64(R2) = d;
	asu64(R1) = mm_type_resolvefield(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10243;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve method:");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10243:
	asu64(R1) = e;
	asu64(R1) = mm_lib_createname(asu64(R1));
	pfunc = asu64(R1);
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pfunc;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pargs;
	asu64(R2) = prec;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pfunc;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = prec;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_type_do_bounds(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 mbase;
	i64 opc;
	i64 lower;
	i64 upper;
	R1 = 1;
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L10246;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	m = asi64(R1);
L10246:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10248;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10249;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10250;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L10251;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10252;
	goto L10253;
L10248:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10255;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10255;
	goto L10256;
L10255:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L10244;
	goto L10254;
L10256:
// mm_type.do_bounds.error:
L10257:
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("lwb/upb/len?");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10254:
	goto L10247;
L10249:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10259;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10260;
	goto L10261;
L10259:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L10258;
L10260:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10258;
L10261:
	goto L10257;
L10258:
	goto L10247;
L10250:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10263;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10264;
	goto L10265;
L10263:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L10262;
L10264:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10262;
L10265:
	goto L10257;
L10262:
	goto L10247;
L10251:
	R1 = 9;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10267;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10268;
	goto L10269;
L10267:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10244;
	goto L10266;
L10268:
	goto L10266;
L10269:
	goto L10257;
L10266:
	goto L10247;
L10252:
	asi64(R1) = mbase;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10271;
	R1 = 0;
	R2 = tou64("Not slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L10271:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10247;
L10253:
L10247:
L10244:
	return;
}

static void mm_type_addnotl(u64 p) {
    u64 R1, R2, R3; 
	R1 = 17;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 63;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tevaluate(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	u64 pname;
	i64 offset;
	i64 tag;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	tag = asi64(R1);
	R1 = (u64)&mm_tables_jisexpr;
	asi64(R2) = tag;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L10275;
	asu64(R1) = p;
	mm_type_tevalbinop(asu64(R1));
	goto L10274;
L10275:
	R1 = (u64)&mm_tables_jisexpr;
	asi64(R2) = tag;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10276;
	asu64(R1) = p;
	mm_type_tevalmonop(asu64(R1));
	goto L10274;
L10276:
	asi64(R1) = tag;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L10278;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L10279;
	goto L10280;
L10278:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L10282;
	asu64(R1) = a;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = b;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10284;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10284;
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 60;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10284:
L10282:
	goto L10277;
L10279:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = (u64)&offset;
	asu64(R2) = a;
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	pname = asu64(R1);
	asu64(R1) = pname;
	if (!asu64(R1)) goto L10286;
	asu64(R1) = pname;
	asu64(R2) = a;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10288;
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L10287;
L10288:
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
L10287:
L10286:
	goto L10277;
L10280:
L10277:
L10274:
	return;
}

static u64 mm_type_addrdotindex(u64 p, u64 offset) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 axmode;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L10291;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L10292;
	goto L10293;
L10291:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10295;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = offset;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L10294;
L10295:
	asu64(R1) = offset;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = q;
L10294:
	goto L10290;
L10292:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	axmode = asi64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10297;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10299;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = axmode;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = axmode;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = offset;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L10298;
L10299:
	asu64(R1) = offset;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L10301;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = axmode;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = axmode;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = offset;
	*toi64p(R2) += asi64(R1);
L10301:
	asu64(R1) = q;
L10298:
	goto L10296;
L10297:
	R1 = 0;
L10296:
	goto L10290;
L10293:
	R1 = 0;
L10290:
	goto L10289;
L10289:
	return asu64(R1);
}

static void mm_type_tevalbinop(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 a;
	i64 b;
	i64 c;
	i64 offset;
	r64 x;
	r64 y;
	r64 z;
	u64 lhs;
	u64 rhs;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = rhs;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L10305;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10304;
L10305:
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L10307;
	asu64(R1) = rhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10307;
	asu64(R1) = lhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10309;
	asu64(R1) = rhs;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = lhs;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	offset = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L10311;
	asi64(R1) = offset;
	asi64(R1) = -asi64(R1);
	offset = asi64(R1);
L10311:
	asu64(R1) = lhs;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10313;
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = lhs;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L10312;
L10313:
	asi64(R1) = offset;
	asu64(R2) = lhs;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
L10312:
	asu64(R1) = lhs;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L10309:
L10307:
	goto L10302;
L10304:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10315;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	y = asr64(R1);
	goto L10314;
L10315:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
L10314:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10317;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10317;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10318;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10318;
	goto L10319;
L10317:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L10321;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L10322;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L10323;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L10324;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L10325;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L10326;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L10327;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L10328;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L10329;
	goto L10330;
L10321:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L10320;
L10322:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L10320;
L10323:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) *= asi64(R2);
	c = asi64(R1);
	goto L10320;
L10324:
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10332;
	R1 = 0;
	R2 = tou64("x/0");
	mm_support_txerror(asu64(R2), asu64(R1));
L10332:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	c = asi64(R1);
	goto L10320;
L10325:
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10334;
	R1 = 0;
	R2 = tou64("x rem 0");
	mm_support_txerror(asu64(R2), asu64(R1));
L10334:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) %= asi64(R2);
	c = asi64(R1);
	goto L10320;
L10326:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) <<= asi64(R2);
	c = asi64(R1);
	goto L10320;
L10327:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) &= asi64(R2);
	c = asi64(R1);
	goto L10320;
L10328:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) |= asi64(R2);
	c = asi64(R1);
	goto L10320;
L10329:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	c = asi64(R1);
	goto L10320;
L10330:
	goto L10302;
L10320:
	goto L10316;
L10318:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L10336;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L10337;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L10338;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L10339;
	goto L10340;
L10336:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) += asr64(R2);
	z = asr64(R1);
	goto L10335;
L10337:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) -= asr64(R2);
	z = asr64(R1);
	goto L10335;
L10338:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) *= asr64(R2);
	z = asr64(R1);
	goto L10335;
L10339:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) = pow(asr64(R1), asr64(R2));
	z = asr64(R1);
	goto L10335;
L10340:
	goto L10302;
L10335:
	goto L10316;
L10319:
	goto L10302;
L10316:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10342;
	R1 = 0;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L10341;
L10342:
	R1 = 0;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L10341:
L10302:
	return;
}

static void mm_type_tevalmonop(u64 p) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	i64 c;
	r64 x;
	r64 z;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10345;
	goto L10343;
L10345:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10347;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10347;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10348;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10348;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10349;
	goto L10350;
L10347:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L10353;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L10352;
L10353:
	goto L10354;
L10352:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L10356;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L10357;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L10358;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L10359;
	goto L10360;
L10356:
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L10355;
L10357:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10355;
L10358:
	asi64(R1) = a;
	asi64(R1) = ~asi64(R1);
	c = asi64(R1);
	goto L10355;
L10359:
	asi64(R1) = a;
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L10355;
L10360:
	goto L10343;
L10355:
	goto L10346;
L10348:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L10362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L10363;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L10364;
	goto L10365;
L10362:
	asr64(R1) = x;
	asr64(R1) = -asr64(R1);
	z = asr64(R1);
	goto L10361;
L10363:
	asr64(R1) = x;
	asr64(R1) = atan(asr64(R1));
	z = asr64(R1);
	goto L10361;
L10364:
	asr64(R1) = x;
	asr64(R1) = sqrt(asr64(R1));
	z = asr64(R1);
	goto L10361;
L10365:
	goto L10343;
L10361:
	goto L10346;
L10349:
// mm_type.tevalmonop.dobool:
L10354:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L10367;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L10368;
	goto L10369;
L10367:
	asi64(R1) = a;
	asi64(R1) = !!asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10366;
L10368:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10366;
L10369:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L10371;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L10372;
	goto L10373;
L10371:
	asi64(R1) = a;
	asi64(R1) = !!asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10370;
L10372:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10370;
L10373:
L10370:
L10366:
	goto L10346;
L10350:
	goto L10343;
L10346:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10375;
	R1 = 0;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L10374;
L10375:
	R1 = 0;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L10374:
L10343:
	return;
}

static i64 mm_type_iscondtrue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10377;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10377;
	R1 = 1;
	goto L10378;
L10377:
	R1 = 0;
L10378:
	goto L10376;
L10376:
	return asi64(R1);
}

static i64 mm_type_iscondfalse(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10380;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10380;
	R1 = 1;
	goto L10381;
L10380:
	R1 = 0;
L10381:
	goto L10379;
L10379:
	return asi64(R1);
}

static void mm_type_fixchararray(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L10384;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L10384;
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L10384;
	R1 = 0;
	R2 = 20;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L10384:
	return;
}

static void mm_type_combinestrings(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	i64 alen;
	i64 blen;
	i64 clen;
	i64 needterm;
	u8 atype;
	u8 btype;
	u8 ctype;
	u64 s;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alen = asi64(R1);
	asu64(R1) = b;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	blen = asi64(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	atype = asu8(R1);
	asu64(R1) = b;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	btype = asu8(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	asu8(R2) = btype;
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L10387;
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L10387;
	R1 = 0;
	needterm = asi64(R1);
	R1 = 66;
	ctype = asu8(R1);
	goto L10386;
L10387:
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L10389;
	asu8(R1) = btype;
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L10388;
L10389:
	R1 = 0;
	R2 = tou64("Mixed str+bin strings");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L10386;
L10388:
	R1 = (u64)&alen;
	(*toi64p(R1)) -=1;
	R1 = (u64)&blen;
	(*toi64p(R1)) -=1;
	R1 = 1;
	needterm = asi64(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L10392;
	asu8(R1) = btype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L10391;
L10392:
	R1 = 83;
	ctype = asu8(R1);
	goto L10390;
L10391:
	R1 = 0;
	ctype = asu8(R1);
L10390:
L10386:
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	clen = asi64(R1);
	asi64(R1) = blen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10394;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L10385;
	goto L10393;
L10394:
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10395;
	asu64(R1) = b;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L10385;
L10395:
L10393:
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asi64(R1) = alen;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	asi64(R4) = alen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = needterm;
	if (!asi64(R1)) goto L10397;
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = clen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10397:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu8(R1) = atype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10385:
	return;
}

static void mm_type_mulstrings(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	i64 alen;
	i64 scale;
	i64 clen;
	i64 needterm;
	u8 atype;
	u8 ctype;
	u64 s;
	u64 t;
	i64 av_1;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alen = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	scale = asi64(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	atype = asu8(R1);
	R1 = (u64)&alen;
	(*toi64p(R1)) -=1;
	R1 = 1;
	needterm = asi64(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L10400;
	R1 = 1;
	needterm = asi64(R1);
L10400:
	asi64(R1) = alen;
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	clen = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10403;
	asi64(R1) = clen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10403;
	asi64(R1) = clen;
	R2 = 100000;
	if (asi64(R1) > asi64(R2)) goto L10403;
	asi64(R1) = alen;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L10402;
L10403:
	R1 = 0;
	R2 = tou64("mulstr");
	mm_support_txerror(asu64(R2), asu64(R1));
L10402:
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	s = asu64(R2);
	t = asu64(R1);
	asi64(R1) = scale;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L10406;
L10404:
	asi64(R1) = alen;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = alen;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	if (--asi64(av_1)) goto L10404;
L10406:
	asi64(R1) = needterm;
	if (!asi64(R1)) goto L10408;
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = clen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10408:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu8(R1) = atype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_strinclude(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 fileno;
	u64 pf;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10412;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10411;
L10412:
	R1 = 0;
	R2 = tou64("strincl/not string");
	mm_support_txerror(asu64(R2), asu64(R1));
L10411:
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = p;
	R3 = 57;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	fileno = asi64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("");
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mm_support_getsupportfile(asu64(R3), asu64(R2), asu64(R1));
	pf = asu64(R1);
	asu64(R1) = pf;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = a;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L10414;
	asu64(R1) = a;
	R2 = 40;
	R1 += (i64)R2;
	(*tou32p(R1)) -=1;
L10414:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	return;
}

static void mm_type_coerceunit(u64 p, i64 t, i64 hard) {
    u64 R1, R2, R3, R4, R5; 
	i64 opc;
	i64 s;
	i64 n;
	i64 sbase;
	i64 tbase;
	i64 starg;
	i64 ttarg;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10418;
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L10417;
L10418:
	goto L10415;
L10417:
	asi64(R1) = s;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10420;
	R1 = 0;
	R2 = tou64("Void expression/return value missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L10420:
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L10422;
	goto L10415;
L10422:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	R1 = 0;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	starg = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	ttarg = asi64(R1);
	asi64(R1) = s;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10424;
	R1 = 20;
	sbase = asi64(R1);
L10424:
	asi64(R1) = t;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10426;
	R1 = 20;
	tbase = asi64(R1);
L10426:
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10428;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10428;
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10430;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10430;
	R1 = (u64)&mm_tables_softconvtable;
	asi64(R2) = sbase;
	R1 += (i64)R2*10-10;
	asi64(R2) = tbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	opc = asi64(R1);
	goto L10429;
L10430:
	asi64(R1) = tbase;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10432;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10432;
	goto L10433;
L10432:
	R1 = 7;
	opc = asi64(R1);
// mm_type.coerceunit.checkhard:
L10434:
	asi64(R1) = hard;
	if (asi64(R1)) goto L10436;
	R1 = 9;
	opc = asi64(R1);
L10436:
	goto L10431;
L10433:
	asi64(R1) = tbase;
	R2 = 12;
	if (asi64(R1) < asi64(R2)) goto L10438;
	R2 = 19;
	if (asi64(R1) > asi64(R2)) goto L10438;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = sbase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10440;
	asi64(R1) = hard;
	if (asi64(R1)) goto L10442;
	R1 = 10;
	opc = asi64(R1);
	goto L10441;
L10442:
	R1 = 3;
	opc = asi64(R1);
L10441:
L10440:
	goto L10437;
L10438:
	asi64(R1) = tbase;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10444;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L10445;
	goto L10446;
L10444:
	R1 = 8;
	opc = asi64(R1);
	goto L10443;
L10445:
	R1 = 7;
	opc = asi64(R1);
	goto L10443;
L10446:
L10443:
L10437:
L10431:
L10429:
	goto L10427;
L10428:
	asi64(R1) = sbase;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10448;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10449;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10450;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10451;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10452;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L10453;
	goto L10454;
L10448:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10457;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10456;
L10457:
	R1 = 7;
	opc = asi64(R1);
L10456:
	goto L10447;
L10449:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10459;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10459;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10460;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10461;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10462;
	goto L10463;
L10459:
	R1 = 7;
	opc = asi64(R1);
	goto L10434;
	goto L10458;
L10460:
	asi64(R1) = starg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10466;
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10465;
L10466:
	R1 = 7;
	opc = asi64(R1);
	goto L10464;
L10465:
// mm_type.coerceunit.checkref:
L10467:
	R1 = 7;
	opc = asi64(R1);
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10469;
	goto L10434;
L10469:
L10464:
	goto L10458;
L10461:
	goto L10467;
	goto L10458;
L10462:
	R1 = 8;
	opc = asi64(R1);
	goto L10458;
L10463:
L10458:
	goto L10447;
L10450:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10471;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10471;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10472;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10473;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10474;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10475;
	goto L10476;
L10471:
	R1 = 7;
	opc = asi64(R1);
	goto L10434;
	goto L10470;
L10472:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10479;
	asi64(R1) = hard;
	if (!asi64(R1)) goto L10478;
L10479:
	R1 = 7;
	opc = asi64(R1);
	goto L10477;
L10478:
	R1 = 9;
	opc = asi64(R1);
L10477:
	goto L10470;
L10473:
	R1 = 8;
	opc = asi64(R1);
	goto L10470;
L10474:
	asi64(R1) = ttarg;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L10482;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L10481;
L10482:
	R1 = 11;
	opc = asi64(R1);
L10481:
	goto L10470;
L10475:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10484;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10484;
	R1 = 7;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10486;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = p;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = t;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = t;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	goto L10485;
L10486:
	R1 = 0;
	R2 = tou64("Array not empty");
	mm_support_txerror(asu64(R2), asu64(R1));
L10485:
L10484:
	goto L10470;
L10476:
L10470:
	goto L10447;
L10451:
	asi64(R1) = tbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10488;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10489;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10490;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10491;
	goto L10492;
L10488:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10494;
	R1 = 7;
	opc = asi64(R1);
L10494:
	goto L10487;
L10489:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10496;
	R1 = 12;
	opc = asi64(R1);
L10496:
	goto L10487;
L10490:
	asi64(R1) = starg;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L10499;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L10498;
L10499:
	R1 = 13;
	opc = asi64(R1);
L10498:
	goto L10487;
L10491:
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10501;
	R1 = 13;
	opc = asi64(R1);
L10501:
	goto L10487;
L10492:
L10487:
	goto L10447;
L10452:
	asi64(R1) = tbase;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10503;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10504;
	goto L10505;
L10503:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10507;
	R1 = 7;
	opc = asi64(R1);
L10507:
	goto L10502;
L10504:
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10510;
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10509;
L10510:
	R1 = 0;
	R2 = tou64("COERCE/SLICEPTR");
	mm_support_gerror(asu64(R2), asu64(R1));
L10509:
	goto L10502;
L10505:
L10502:
	goto L10447;
L10453:
	asi64(R1) = tbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10512;
	R1 = 7;
	opc = asi64(R1);
L10512:
	goto L10447;
L10454:
L10447:
L10427:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	mm_type_applyconversion(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L10415:
	return;
}

static void mm_type_applyconversion(u64 p, i64 s, i64 t, i64 opc) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10515;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L10516;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10517;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10518;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L10519;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10520;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L10521;
	goto L10522;
L10515:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do conversion: # => #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L10514;
L10516:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Need explicit cast: # => #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L10514;
L10517:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10513;
	goto L10514;
L10518:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	asi64(R1) = mm_type_tevalconvert(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10524;
	goto L10513;
L10524:
	R1 = 59;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10513;
	goto L10514;
L10519:
	R1 = 48;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10513;
	goto L10514;
L10520:
	asi64(R1) = t;
	asu64(R2) = p;
	mm_type_tstringslice(asu64(R2), asi64(R1));
	goto L10513;
	goto L10514;
L10521:
	R1 = 56;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10513;
	goto L10514;
L10522:
L10514:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	asi64(R1) = mm_type_tevalconvert(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10526;
	goto L10513;
L10526:
	R1 = 58;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = s;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10528;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	t = asi64(R1);
L10528:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10513:
	return;
}

static void mm_type_checkmodes(i64 s, i64 t) {
    u64 R1, R2, R3; 
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10531;
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Type-compare error: # <-> #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L10531:
	return;
}

static i64 mm_type_comparemodes(i64 s, i64 t) {
    u64 R1, R2, R3; 
	i64 sbase;
	i64 tbase;
	i64 starg;
	i64 ttarg;
	u64 d;
	u64 e;
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L10534;
	R1 = 1;
	goto L10532;
L10534:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	starg = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	ttarg = asi64(R1);
	asi64(R1) = sbase;
	asi64(R2) = tbase;
	if (asi64(R1) != asi64(R2)) goto L10536;
	asi64(R1) = sbase;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10538;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10539;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10540;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L10541;
	goto L10542;
L10538:
	asi64(R1) = starg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10545;
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10544;
L10545:
	R1 = 1;
	goto L10532;
L10544:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	goto L10532;
	goto L10537;
L10539:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10547;
	R1 = 0;
	goto L10532;
L10547:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	if (asi64(R1) == asi64(R2)) goto L10550;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10550;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10549;
L10550:
	R1 = 1;
	goto L10532;
L10549:
	goto L10537;
L10540:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	goto L10532;
	goto L10537;
L10541:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = s;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	e = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L10552;
	asu64(R1) = e;
	if (!asu64(R1)) goto L10552;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10554;
	R1 = 0;
	goto L10532;
L10554:
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10556;
	asu64(R1) = e;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10556;
	R1 = 1;
	goto L10532;
L10556:
L10552:
	goto L10537;
L10542:
L10537:
	goto L10535;
L10536:
	asi64(R1) = sbase;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L10559;
	asi64(R1) = tbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L10558;
L10559:
	asi64(R1) = sbase;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L10557;
	asi64(R1) = tbase;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L10557;
L10558:
	R1 = 1;
	goto L10532;
	goto L10535;
L10557:
L10535:
	R1 = 0;
	goto L10532;
L10532:
	return asi64(R1);
}

static i64 mm_type_tevalconvert(u64 p, i64 s, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	r64 x;
	r64 z;
	i64 a;
	i64 c;
	i64 sbase;
	i64 tbase;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10562;
	R1 = 0;
	goto L10560;
L10562:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asi64(R1) = s;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = t;
	asi64(R1) |= asi64(R2);
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L10564;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L10564;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L10565;
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L10566;
	R2 = 196625;
	if (asi64(R1) == asi64(R2)) goto L10567;
	R2 = 196623;
	if (asi64(R1) == asi64(R2)) goto L10568;
	goto L10569;
L10564:
	asi64(R1) = a;
	asr64(R1) = tor64(asi64(R1));
	z = asr64(R1);
	goto L10563;
L10565:
	asr64(R1) = x;
	R1 = toi64(asr64(R1));
	c = asi64(R1);
	goto L10563;
L10566:
	asr64(R1) = x;
	z = asr64(R1);
	goto L10563;
L10567:
	asi64(R1) = a;
	asi64(R1) = toi64(tou8(R1));
	c = asi64(R1);
	goto L10563;
L10568:
	asi64(R1) = a;
	asi64(R1) = toi64(toi16(R1));
	c = asi64(R1);
	goto L10563;
L10569:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10571;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10571;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = s;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = t;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	if (asi64(R1) != asi64(R2)) goto L10571;
	asi64(R1) = a;
	c = asi64(R1);
	goto L10570;
L10571:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	asi64(R2) = tbase;
	if (asi64(R1) != asi64(R2)) goto L10573;
	R1 = 1;
	goto L10560;
L10573:
	R1 = 0;
	goto L10560;
L10570:
L10563:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10575;
	asi64(R1) = t;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L10574;
L10575:
	asi64(R1) = t;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L10574:
	R1 = 1;
	goto L10560;
L10560:
	return asi64(R1);
}

static void mm_type_tx_assign(u64 p, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 mm;
	i64 needres;
	u64 d;
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	needres = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10578;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L10579;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L10579;
	goto L10580;
L10578:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10582;
	asi64(R1) = needres;
	if (!asi64(R1)) goto L10584;
	R1 = 0;
	R2 = tou64("Mult assign has no result");
	mm_support_txerror(asu64(R2), asu64(R1));
L10584:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_assignmultmult(asu64(R3), asu64(R2), asu64(R1));
	goto L10581;
L10582:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_assignmultscalar(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L10581:
	goto L10576;
	goto L10577;
L10579:
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	mm_type_tx_dotindex(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10576;
	goto L10577;
L10580:
L10577:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10586;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L10586;
	asu64(R1) = p;
	R2 = 59;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10586;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10585;
L10586:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
L10585:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = needres;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L10588;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10588;
	asi64(R1) = m;
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = b;
	mm_type_tx_makeslicefromlist(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10587;
L10588:
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L10591;
	R2 = 48;
	if (asi64(R1) != asi64(R2)) goto L10590;
L10591:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10589;
L10590:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L10592;
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10589;
L10592:
	asi64(R1) = m;
	mm = asi64(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10594;
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	mm = asi64(R1);
L10594:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L10596;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10597;
	goto L10598;
L10596:
	R1 = 0;
	asi64(R2) = mm;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10595;
L10597:
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10595;
L10598:
	R1 = 0;
	asi64(R2) = mm;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L10595:
	asi64(R1) = mm;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L10600;
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10600;
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	asu64(R3) = b;
	R4 = 53;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	if (asi64(R1) > asi64(R2)) goto L10600;
	asi64(R1) = needres;
	if (asi64(R1)) goto L10600;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L10600:
L10589:
L10587:
L10576:
	return;
}

static void mm_type_tx_assignmultmult(u64 pp, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 lhs;
	u64 rhs;
	R1 = 29;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = b;
	R3 = 40;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	if (asi64(R1) == asi64(R2)) goto L10603;
	R1 = 0;
	R2 = tou64("Mult assign: count mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L10603:
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10605;
	R1 = 0;
	R2 = tou64("Invalid assignment");
	mm_support_txerror(asu64(R2), asu64(R1));
L10605:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = lhs;
	p = asu64(R1);
	goto L10609;
L10606:
	R1 = 23;
	asu64(R2) = p;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L10609:
	asu64(R1) = p;
	if (asu64(R1)) goto L10606;
	asu64(R1) = lhs;
	p = asu64(R1);
	asu64(R1) = rhs;
	q = asu64(R1);
	goto L10613;
L10610:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L10613:
	asu64(R1) = q;
	if (asu64(R1)) goto L10610;
	return;
}

static void mm_type_tx_assignmultscalar(u64 pp, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 alist;
	i64 nretmodes;
	i64 i;
	i64 alength;
	u64 pmult;
	u64 d;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	alist = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alength = asi64(R1);
	R1 = 0;
	nretmodes = asi64(R1);
	R1 = 30;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L10616;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10617;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L10618;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10619;
	goto L10620;
L10616:
	asu64(R1) = b;
	asu64(R1) = mm_lib_getprocretmodes(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nretmodes = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L10622;
	R1 = 0;
	R2 = tou64("Not a tuple");
	mm_support_txerror(asu64(R2), asu64(R1));
L10622:
	asi64(R1) = alength;
	asi64(R2) = nretmodes;
	if (asi64(R1) <= asi64(R2)) goto L10624;
	R1 = 0;
	R2 = tou64("mult ass/mult returns don't agree in number");
	mm_support_txerror(asu64(R2), asu64(R1));
L10624:
	asi64(R1) = nretmodes;
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L10626;
	R1 = 0;
	R2 = tou64("mult ass rhs needs fn yielding 2+ values");
	mm_support_txerror(asu64(R2), asu64(R1));
L10626:
	asu64(R1) = alist;
	p = asu64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L10630;
L10627:
	asu64(R1) = pmult;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) += 1; asi64(R2) = asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L10630:
	asu64(R1) = p;
	if (asu64(R1)) goto L10627;
	goto L10615;
L10617:
	asi64(R1) = alength;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10632;
	R1 = 0;
	R2 = tou64("(a,b):=slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L10632:
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = b;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = alist;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = alist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_type_tpasslv(asu64(R2), asi64(R1));
	goto L10615;
L10618:
	goto L10615;
L10619:
	goto L10615;
L10620:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 35;
	if (asi64(R1) != asi64(R2)) goto L10634;
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) != asi64(R2)) goto L10634;
	asi64(R1) = alength;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10636;
	R1 = 0;
	R2 = tou64("(a,b):=divrem");
	mm_support_txerror(asu64(R2), asu64(R1));
L10636:
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = alist;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = alist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 31;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10633;
L10634:
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't expand to mult values:");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10633:
L10615:
	asi64(R1) = t;
	asu64(R2) = pp;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tpasslv(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	R2 = 23;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L10639;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10639;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10641;
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = p;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("PassLV type mismatch: #:=#");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L10641:
L10639:
	return;
}

static i64 mm_type_dobinnumx(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10644;
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10644;
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10642;
L10644:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10646;
	asi64(R1) = bmode;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L10647;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L10646;
L10647:
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = amode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10642;
	goto L10645;
L10646:
	asi64(R1) = amode;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L10649;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L10648;
L10649:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10648;
	asi64(R1) = bmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = bmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10642;
L10648:
L10645:
	R1 = 0;
	goto L10642;
L10642:
	return asi64(R1);
}

static i64 mm_type_dobinnumf(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L10652;
	asi64(R1) = bmode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L10652;
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10650;
L10652:
	R1 = 0;
	goto L10650;
L10650:
	return asi64(R1);
}

static i64 mm_type_dobinnumi(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10656;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10656;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L10655;
L10656:
	asi64(R1) = bmode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10657;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10657;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L10655;
L10657:
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10653;
L10655:
	R1 = 0;
	goto L10653;
L10653:
	return asi64(R1);
}

static i64 mm_type_tx_in(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 simpleset;
	i64 amode;
	i64 bmode;
	u64 q;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	simpleset = asi64(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L10660;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L10664;
L10661:
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10666;
	R1 = 0;
	simpleset = asi64(R1);
	goto L10663;
L10666:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L10664:
	asu64(R1) = q;
	if (asu64(R1)) goto L10661;
L10663:
L10660:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10668;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L10669;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L10668;
L10669:
	asi64(R1) = simpleset;
	if (!asi64(R1)) goto L10668;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L10671;
	R1 = 43;
	goto L10670;
L10671:
	R1 = 44;
L10670:
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10667;
L10668:
	R1 = 0;
	R2 = tou64("doin");
	mm_support_txerror(asu64(R2), asu64(R1));
L10667:
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10673;
	asu64(R1) = p;
	mm_type_addnotl(asu64(R1));
L10673:
	R1 = 1;
	goto L10658;
L10658:
	return asi64(R1);
}

static void pcl_start() {
	mc_genss_start();
	mc_decls_start();
	mc_writenasm_start();
	return;
}

static void mm_start() {
	mm_genpcl_start();
	mm_lex_start();
	mm_tables_start();
	return;
}

static struct $B86 $procaddr = {{
(u64)&mc_genmcl_px_nop,
(u64)&mc_genmcl_px_dupl,
(u64)&mc_genmcl_px_double,
(u64)&mc_genmcl_px_opnd,
(u64)&mc_genmcl_px_type,
(u64)&mc_genmcl_px_comment,
(u64)&mc_genmcl_px_proc,
(u64)&mc_genmcl_px_endproc,
(u64)&mc_genmcl_px_endprog,
(u64)&mc_genmcl_px_istatic,
(u64)&mc_genmcl_px_zstatic,
(u64)&mc_genmcl_px_data,
(u64)&mc_genmcl_px_label,
(u64)&mc_genmcl_px_load,
(u64)&mc_genmcl_px_store,
(u64)&mc_genmcl_px_add,
(u64)&mc_genmcl_px_sub,
(u64)&mc_genmcl_px_mul,
(u64)&mc_genmcl_px_div,
(u64)&mc_genmcl_px_eval,
(u64)&mc_genmcl_px_widen,
(u64)&mc_genmcl_px_jump,
(u64)&mc_genmcl_px_ijump,
(u64)&mc_genmcl_px_neg,
(u64)&mc_genmcl_px_abs,
(u64)&mc_genmcl_px_bitnot,
(u64)&mc_genmcl_px_not,
(u64)&mc_genmcl_px_toboolt,
(u64)&mc_genmcl_px_sqr,
(u64)&mc_genmcl_px_sqrt,
(u64)&mc_genmcl_px_jumpcc,
(u64)&mc_genmcl_px_jumpt,
(u64)&mc_genmcl_px_jumpf,
(u64)&mc_genmcl_px_bitand,
(u64)&mc_genmcl_px_bitor,
(u64)&mc_genmcl_px_bitxor,
(u64)&mc_genmcl_px_shl,
(u64)&mc_genmcl_px_shr,
(u64)&mc_genmcl_px_retproc,
(u64)&mc_genmcl_px_retfn,
(u64)&mc_genmcl_px_setcall,
(u64)&mc_genmcl_px_setarg,
(u64)&mc_genmcl_px_callp,
(u64)&mc_genmcl_px_jumpret,
(u64)&mc_genmcl_px_jumpretm,
(u64)&mc_genmcl_px_startmx,
(u64)&mc_genmcl_px_resetmx,
(u64)&mc_genmcl_px_stop,
(u64)&mc_genmcl_px_incrto,
(u64)&mc_genmcl_px_decrto,
(u64)&mc_genmcl_px_incrload,
(u64)&mc_genmcl_px_decrload,
(u64)&mc_genmcl_px_loadincr,
(u64)&mc_genmcl_px_loaddecr,
(u64)&mc_genmcl_px_forup,
(u64)&mc_genmcl_px_fordown,
(u64)&mc_genmcl_px_iload,
(u64)&mc_genmcl_px_iloadx,
(u64)&mc_genmcl_px_istore,
(u64)&mc_genmcl_px_istorex,
(u64)&mc_genmcl_px_storem,
(u64)&mc_genmcl_px_addpx,
(u64)&mc_genmcl_px_subpx,
(u64)&mc_genmcl_px_to,
(u64)&mc_genmcl_px_iswap,
(u64)&mc_genmcl_px_swapstk,
(u64)&mc_genmcl_px_labeldef,
(u64)&mc_genmcl_px_addto,
(u64)&mc_genmcl_px_subto,
(u64)&mc_genmcl_px_multo,
(u64)&mc_genmcl_px_bitandto,
(u64)&mc_genmcl_px_bitorto,
(u64)&mc_genmcl_px_bitxorto,
(u64)&mc_genmcl_px_shlto,
(u64)&mc_genmcl_px_shrto,
(u64)&mc_genmcl_px_fix,
(u64)&mc_genmcl_px_float,
(u64)&mc_genmcl_px_idiv,
(u64)&mc_genmcl_px_irem,
(u64)&mc_genmcl_px_idivrem,
(u64)&mc_genmcl_px_clear,
(u64)&mc_genmcl_px_subp,
(u64)&mc_genmcl_px_switch,
(u64)&mc_genmcl_px_switchu,
(u64)&mc_genmcl_px_swlabel,
(u64)&mc_genmcl_px_endsw,
(u64)&mc_genmcl_px_fwiden,
(u64)&mc_genmcl_px_fnarrow,
(u64)&mc_genmcl_px_truncate,
(u64)&mc_genmcl_px_typepun,
(u64)&mc_genmcl_px_unload,
(u64)&mc_genmcl_px_loadbit,
(u64)&mc_genmcl_px_assem,
(u64)&mc_genmcl_px_sin,
(u64)&mc_genmcl_px_cos,
(u64)&mc_genmcl_px_tan,
(u64)&mc_genmcl_px_asin,
(u64)&mc_genmcl_px_acos,
(u64)&mc_genmcl_px_atan,
(u64)&mc_genmcl_px_log,
(u64)&mc_genmcl_px_log10,
(u64)&mc_genmcl_px_exp,
(u64)&mc_genmcl_px_round,
(u64)&mc_genmcl_px_floor,
(u64)&mc_genmcl_px_ceil,
(u64)&mc_genmcl_px_atan2,
(u64)&mc_genmcl_px_fmod,
(u64)&mc_genmcl_px_setcc,
(u64)&mc_genmcl_px_min,
(u64)&mc_genmcl_px_max,
(u64)&mc_genmcl_px_power,
(u64)&mc_genmcl_px_minto,
(u64)&mc_genmcl_px_maxto,
(u64)&mc_genmcl_px_negto,
(u64)&mc_genmcl_px_absto,
(u64)&mc_genmcl_px_addpxto,
(u64)&mc_genmcl_px_subpxto,
(u64)&mc_genmcl_px_divto,
(u64)&mc_genmcl_px_bitnotto,
(u64)&mc_genmcl_px_notto,
(u64)&mc_genmcl_px_toboolto,
(u64)&mc_genmcl_px_sign,
(u64)&mc_genmcl_px_loadbf,
(u64)&mc_genmcl_px_storebit,
(u64)&mc_genmcl_px_storebf,
(u64)&mc_genmcl_px_loadall,
(u64)&mc_genmcl_px_setjmp,
(u64)&mc_genmcl_px_longjmp,
(u64)&mc_genmcl_px_initdswx,
(u64)&mc_auxmcl_do_addrmode}};

static struct $B86 $procname = {{
(u64)"px_nop",
(u64)"px_dupl",
(u64)"px_double",
(u64)"px_opnd",
(u64)"px_type",
(u64)"px_comment",
(u64)"px_proc",
(u64)"px_endproc",
(u64)"px_endprog",
(u64)"px_istatic",
(u64)"px_zstatic",
(u64)"px_data",
(u64)"px_label",
(u64)"px_load",
(u64)"px_store",
(u64)"px_add",
(u64)"px_sub",
(u64)"px_mul",
(u64)"px_div",
(u64)"px_eval",
(u64)"px_widen",
(u64)"px_jump",
(u64)"px_ijump",
(u64)"px_neg",
(u64)"px_abs",
(u64)"px_bitnot",
(u64)"px_not",
(u64)"px_toboolt",
(u64)"px_sqr",
(u64)"px_sqrt",
(u64)"px_jumpcc",
(u64)"px_jumpt",
(u64)"px_jumpf",
(u64)"px_bitand",
(u64)"px_bitor",
(u64)"px_bitxor",
(u64)"px_shl",
(u64)"px_shr",
(u64)"px_retproc",
(u64)"px_retfn",
(u64)"px_setcall",
(u64)"px_setarg",
(u64)"px_callp",
(u64)"px_jumpret",
(u64)"px_jumpretm",
(u64)"px_startmx",
(u64)"px_resetmx",
(u64)"px_stop",
(u64)"px_incrto",
(u64)"px_decrto",
(u64)"px_incrload",
(u64)"px_decrload",
(u64)"px_loadincr",
(u64)"px_loaddecr",
(u64)"px_forup",
(u64)"px_fordown",
(u64)"px_iload",
(u64)"px_iloadx",
(u64)"px_istore",
(u64)"px_istorex",
(u64)"px_storem",
(u64)"px_addpx",
(u64)"px_subpx",
(u64)"px_to",
(u64)"px_iswap",
(u64)"px_swapstk",
(u64)"px_labeldef",
(u64)"px_addto",
(u64)"px_subto",
(u64)"px_multo",
(u64)"px_bitandto",
(u64)"px_bitorto",
(u64)"px_bitxorto",
(u64)"px_shlto",
(u64)"px_shrto",
(u64)"px_fix",
(u64)"px_float",
(u64)"px_idiv",
(u64)"px_irem",
(u64)"px_idivrem",
(u64)"px_clear",
(u64)"px_subp",
(u64)"px_switch",
(u64)"px_switchu",
(u64)"px_swlabel",
(u64)"px_endsw",
(u64)"px_fwiden",
(u64)"px_fnarrow",
(u64)"px_truncate",
(u64)"px_typepun",
(u64)"px_unload",
(u64)"px_loadbit",
(u64)"px_assem",
(u64)"px_sin",
(u64)"px_cos",
(u64)"px_tan",
(u64)"px_asin",
(u64)"px_acos",
(u64)"px_atan",
(u64)"px_log",
(u64)"px_log10",
(u64)"px_exp",
(u64)"px_round",
(u64)"px_floor",
(u64)"px_ceil",
(u64)"px_atan2",
(u64)"px_fmod",
(u64)"px_setcc",
(u64)"px_min",
(u64)"px_max",
(u64)"px_power",
(u64)"px_minto",
(u64)"px_maxto",
(u64)"px_negto",
(u64)"px_absto",
(u64)"px_addpxto",
(u64)"px_subpxto",
(u64)"px_divto",
(u64)"px_bitnotto",
(u64)"px_notto",
(u64)"px_toboolto",
(u64)"px_sign",
(u64)"px_loadbf",
(u64)"px_storebit",
(u64)"px_storebf",
(u64)"px_loadall",
(u64)"px_setjmp",
(u64)"px_longjmp",
(u64)"px_initdswx",
(u64)"do_addrmode"}};

static i64 $nprocs = 130;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

