# GAS VERSION
    .code64
    .intel_syntax prefix
    .global main

    .global msys.$cmdskip
    .global cc_cli.main

    .text
#MCL1
    .bss
    .align    8
msys.fmtparam:
    .space    8
    .align    8
msys.$cmdskip:
$cmdskip:
    .space    8
    .data
    .align    8
msys.needgap:
    .quad     0
    .align    8
msys.outdev:
    .quad     1
    .align    8
msys.outchan:
    .quad     0
    .align    8
msys.fmtstr:
    .quad     0
    .bss
    .align    8
msys.outchan_stack:
    .space    80
    .align    8
msys.outdev_stack:
    .space    80
    .align    8
msys.fmtstr_stack:
    .space    80
msys.needgap_stack:
    .space    10
    .align    8
msys.ptr_stack:
    .space    80
    .data
    .align    8
msys.niostack:
    .quad     0
msys.digits:
    .quad     0x3736353433323130
    .quad     0x4645444342413938
    .byte     0
#ENDDATA
    .align    8
msys.defaultfmt:
    .byte     0
    .byte     0
    .byte     10
    .byte     0
    .byte     32
    .byte     102
    .byte     0
    .byte     0
    .byte     0
    .byte     82
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .bss
    .align    8
msys.rd_buffer:
    .space    8
    .align    8
msys.rd_length:
    .space    8
    .align    8
msys.rd_pos:
    .space    8
    .align    8
msys.rd_lastpos:
    .space    8
    .align    8
msys.termchar:
    .space    8
    .align    8
msys.itemerror:
    .space    8
msys.printbuffer:
    .space    4096
    .align    8
msys.printptr:
    .space    8
    .align    8
msys.printlen:
    .space    8
    .align    8
msys.nsysparams:
    .space    8
    .align    8
msys.ncmdparams:
    .space    8
    .align    8
msys.nenvstrings:
    .space    8
    .align    8
msys.sysparams:
    .space    1024
    .align    8
msys.cmdparams:
    .space    8
    .align    8
msys.envstrings:
    .space    8
msys.start.startupinfo:
    .space    128
    .align    8
msys.getfmt.fmt:
    .space    16
msys.strint.str:
    .space    100
msys.strword.str:
    .space    100
msys.strreal.str:
    .space    320
    .align    8
mlib.allocupper:
    .space    2408
    .align    8
mlib.alloccode:
    .space    8
    .align    8
mlib.allocbytes:
    .space    8
    .data
    .align    8
mlib.fdebug:
    .quad     0
    .bss
    .align    8
mlib.rfsize:
    .space    8
    .align    8
mlib.maxmemory:
    .space    8
    .align    8
mlib.maxalloccode:
    .space    8
    .data
mlib.pcm_setup:
    .byte     0
    .align    8
mlib.show:
    .quad     0
    .align    8
mlib.memtotal:
    .quad     0
    .align    8
mlib.smallmemtotal:
    .quad     0
    .align    8
mlib.smallmemobjs:
    .quad     0
    .align    8
mlib.maxmemtotal:
    .quad     0
    .bss
    .align    8
mlib.memalloctable:
    .space    24
    .align    4
mlib.memallocsize:
    .space    12
    .align    8
mlib.pcheapstart:
    .space    8
    .align    8
mlib.pcheapend:
    .space    8
    .align    8
mlib.pcheapptr:
    .space    8
mlib.sizeindextable:
    .space    2049
    .align    8
mlib.freelist:
    .space    72
    .data
    .align    8
mlib.pmnames:
    .quad     L9026
    .quad     L9027
    .quad     L9028
    .quad     L9029
    .quad     L9030
    .quad     L9031
    .align    8
mlib.seed:
    .quad     0x2989881111111272
    .quad     0x1673267373358264
    .bss
    .align    8
mlib.pcm_newblock.totalheapsize:
    .space    8
    .data
    .align    4
mlib.pcm_round.allocbytes:
    .long     0
    .long     16
    .long     32
    .long     64
    .long     128
    .long     256
    .long     512
    .long     1024
    .long     2048
    .bss
mlib.changeext.newfile:
    .space    260
mlib.extractpath.str:
    .space    260
mlib.extractbasefile.str:
    .space    100
    .data
    .align    8
mlib.nextcmdparamnew.infile:
    .quad     0
    .align    8
mlib.nextcmdparamnew.filestart:
    .quad     0
    .align    8
mlib.nextcmdparamnew.fileptr:
    .quad     0
mlib.nextcmdparamnew.colonseen:
    .byte     0
    .bss
mlib.nextcmdparamnew.str:
    .space    300
mlib.readnextfileitem.str:
    .space    256
mlib.padstr.str:
    .space    256
mlib.chr.str:
    .space    8
    .align    8
mwindows.hconsole:
    .space    8
    .align    8
mwindows.hconsolein:
    .space    8
    .align    4
mwindows.lastkey:
    .space    20
    .align    4
mwindows.pendkey:
    .space    20
    .align    8
mwindows.keypending:
    .space    8
    .align    8
mwindows.hpfreq:
    .space    8
    .data
    .align    8
mwindows.wndproc_callbackfn:
    .quad     0
    .align    8
mwindows.init_flag:
    .quad     0
    .bss
mwindows.os_gxregisterclass.registered:
    .space    1
    .data
    .align    8
mwindows.mainwndproc.count:
    .quad     0
    .bss
mwindows.os_gethostname.name:
    .space    300
    .align    8
mwindows.os_gethostname.n:
    .space    8
    .align    8
mwindows.os_peek.lastticks:
    .space    8
    .data
pcl.pc_userunpcl:
    .byte     0
pcl.asmonly:
    .byte     0
    .bss
    .align    8
pc_api.pclseqno:
    .space    8
    .align    8
pc_api.stseqno:
    .space    8
    .align    8
pc_api.pcstart:
    .space    8
    .align    8
pc_api.pccurr:
    .space    8
    .align    8
pc_api.pcend:
    .space    8
    .align    8
pc_api.pcalloc:
    .space    8
pc_api.pcfixed:
    .space    1
    .align    8
pc_api.pcseqno:
    .space    8
    .align    8
pc_api.pcneedfntable:
    .space    8
    .data
    .align    8
pc_api.initpcalloc:
    .quad     0x10000
    .bss
    .align    8
pc_api.longstring:
    .space    8
    .align    8
pc_api.longstringlen:
    .space    8
    .align    8
pc_api.mlabelno:
    .space    8
pc_api.phighmem:
    .space    1
pc_api.pfullsys:
    .space    1
pc_api.fpshortnames:
    .space    1
    .align    8
pc_api.idomcl_assem:
    .space    8
    .align    8
pc_api.icheckasmlabel:
    .space    8
    .align    8
pc_api.igethostfn:
    .space    8
pc_api.strpmode.str:
    .space    32
pc_api.getfullname.str:
    .space    256
pc_api.addstr.str:
    .space    256
    .align    8
pc_decls.pinfo:
    .space    8
    .align    8
pc_decls.bspill:
    .space    8
    .align    8
pc_decls.bxspill:
    .space    8
pc_decls.r10used:
    .space    1
pc_decls.r11used:
    .space    1
pc_decls.localshadow:
    .space    1
    .align    8
pc_decls.mmpos:
    .space    8
    .align    8
pc_decls.psymboltable:
    .space    8
    .align    8
pc_decls.psymboltablex:
    .space    8
    .align    8
pc_decls.currprog:
    .space    8
    .align    8
pc_decls.currfunc:
    .space    8
    .align    8
pc_decls.blockretname:
    .space    8
    .align    8
pc_decls.entryproc:
    .space    8
    .align    8
pc_decls.sbuffer:
    .space    16
    .data
    .align    8
pc_decls.pdest:
    .quad     pc_decls.sbuffer
    .bss
    .align    8
pc_decls.plibfiles:
    .space    400
    .align    8
pc_decls.plibinst:
    .space    400
    .align    8
pc_decls.nplibfiles:
    .space    8
    .align    8
pc_decls.igetmsourceinfo:
    .space    8
pc_decls.pcldone:
    .space    1
pc_decls.mcldone:
    .space    1
pc_decls.ssdone:
    .space    1
pc_decls.objdone:
    .space    1
pc_decls.exedone:
    .space    1
pc_decls.pverbose:
    .space    1
    .align    8
pc_decls.pcmdskip:
    .space    8
    .data
    .align    8
pc_decls.assemtype:
    .quad     0x4141
    .bss
    .align    8
pc_decls.ppseqno:
    .space    8
    .data
pc_decls.fpeephole:
    .byte     1
pc_decls.fregoptim:
    .byte     1
    .bss
    .align    8
pc_decls.pcltime:
    .space    8
    .align    8
pc_decls.mcltime:
    .space    8
    .align    8
pc_decls.sstime:
    .space    8
    .align    8
pc_decls.objtime:
    .space    8
    .align    8
pc_decls.exetime:
    .space    8
    .align    8
pc_decls.$pmodulename:
    .space    8
    .align    8
pc_decls.pclflags:
    .space    1144
    .align    8
pc_decls.pstartclock:
    .space    8
    .align    8
pc_decls.npcl:
    .space    8
    .align    8
pc_decls.npst:
    .space    8
    .align    8
pc_diags.sbuffer:
    .space    16
    .data
    .align    8
pc_diags.dest:
    .quad     pc_diags.sbuffer
    .bss
    .align    8
pc_diags.destlinestart:
    .space    8
pc_diags.stropnd.str:
    .space    512
    .align    8
pc_diags.stropnd.longstring:
    .space    8
    .data
    .align    8
pc_run.dotrace:
    .quad     0
    .align    8
pc_run.dostep:
    .quad     1
    .bss
    .align    8
pc_run.go:
    .space    8
    .align    8
pc_run.seqno:
    .space    8
    .align    8
pc_run.emptyst:
    .space    128
    .align    8
pc_run.labeltable:
    .space    8
    .data
    .align    8
pc_tables.pstdnames:
    .quad     L9032
    .quad     L9033
    .quad     L9034
    .quad     L9035
    .quad     L9036
    .quad     L9037
    .quad     L9038
    .quad     L9039
    .quad     L9040
    .quad     L9041
    .quad     L9042
    .quad     L9043
    .quad     L9044
    .quad     L9045
pc_tables.psize:
    .quad     0x108040201080400
    .byte     2
    .byte     4
    .byte     8
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.psigned:
    .quad     0x100000000000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pint:
    .quad     0x101010101000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pfloat:
    .quad     0x10100
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pmin:
    .quad     0x906050505020100
    .byte     9
    .byte     9
    .byte     10
    .byte     11
    .byte     12
    .byte     0
#ENDDATA
pc_tables.xxpiwrb:
    .quad     0xA06060606020100
    .byte     10
    .byte     10
    .byte     10
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.opndnames:
    .quad     L9046
    .quad     L9047
    .quad     L9048
    .quad     L9049
    .quad     L9050
    .quad     L9051
    .quad     L9052
    .quad     L9053
    .quad     L9054
    .quad     L9055
    .quad     L9056
    .quad     L9057
    .quad     L9058
    .quad     L9059
    .align    8
pc_tables.pclnames:
    .quad     L9060
    .quad     L9061
    .quad     L9062
    .quad     L9063
    .quad     L9064
    .quad     L9065
    .quad     L9066
    .quad     L9067
    .quad     L9068
    .quad     L9069
    .quad     L9070
    .quad     L9071
    .quad     L9072
    .quad     L9073
    .quad     L9074
    .quad     L9075
    .quad     L9076
    .quad     L9077
    .quad     L9078
    .quad     L9079
    .quad     L9080
    .quad     L9081
    .quad     L9082
    .quad     L9083
    .quad     L9084
    .quad     L9085
    .quad     L9086
    .quad     L9087
    .quad     L9088
    .quad     L9089
    .quad     L9090
    .quad     L9091
    .quad     L9092
    .quad     L9093
    .quad     L9094
    .quad     L9095
    .quad     L9096
    .quad     L9097
    .quad     L9098
    .quad     L9099
    .quad     L9100
    .quad     L9101
    .quad     L9102
    .quad     L9103
    .quad     L9104
    .quad     L9105
    .quad     L9106
    .quad     L9107
    .quad     L9108
    .quad     L9109
    .quad     L9110
    .quad     L9111
    .quad     L9112
    .quad     L9113
    .quad     L9114
    .quad     L9115
    .quad     L9116
    .quad     L9117
    .quad     L9118
    .quad     L9119
    .quad     L9120
    .quad     L9121
    .quad     L9122
    .quad     L9123
    .quad     L9124
    .quad     L9125
    .quad     L9126
    .quad     L9127
    .quad     L9128
    .quad     L9129
    .quad     L9130
    .quad     L9131
    .quad     L9132
    .quad     L9133
    .quad     L9134
    .quad     L9135
    .quad     L9136
    .quad     L9137
    .quad     L9138
    .quad     L9139
    .quad     L9140
    .quad     L9141
    .quad     L9142
    .quad     L9143
    .quad     L9144
    .quad     L9145
    .quad     L9146
    .quad     L9147
    .quad     L9148
    .quad     L9149
    .quad     L9150
    .quad     L9151
    .quad     L9152
    .quad     L9153
    .quad     L9154
    .quad     L9155
    .quad     L9156
    .quad     L9157
    .quad     L9158
    .quad     L9159
    .quad     L9160
    .quad     L9161
    .quad     L9162
    .quad     L9163
    .quad     L9164
    .quad     L9165
    .quad     L9166
    .quad     L9167
    .quad     L9168
    .quad     L9169
    .quad     L9170
    .quad     L9171
    .quad     L9172
    .quad     L9173
    .quad     L9174
    .quad     L9175
    .quad     L9176
    .quad     L9177
    .quad     L9178
    .quad     L9179
    .quad     L9180
    .quad     L9181
    .quad     L9182
    .quad     L9183
    .quad     L9184
    .quad     L9185
    .quad     L9186
    .quad     L9187
    .quad     L9188
    .quad     L9189
    .quad     L9190
    .quad     L9191
    .quad     L9192
    .quad     L9193
    .quad     L9194
    .quad     L9195
    .quad     L9196
    .quad     L9197
    .quad     L9198
    .quad     L9199
    .quad     L9200
    .quad     L9201
    .quad     L9202
pc_tables.pclhastype:
    .quad     0x101010101010100
    .quad     0x101010101000000
    .quad     0x101010000000101
    .quad     0x101010101010100
    .quad     0x10101010100
    .quad     0x101010101000100
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x202010101010101
    .quad     0x101000202020202
    .quad     0x10101000000
    .quad     0
    .byte     0
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclextra:
    .quad     0x2000002000100
    .quad     0x20000
    .quad     0x2020002020000
    .quad     0x10000
    .quad     0x2020001010000
    .quad     0
    .quad     0
    .quad     0x1020200
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101
    .quad     0x100000000000000
    .quad     1
    .quad     0
    .quad     0
    .quad     0x201000000
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclhasopnd:
    .quad     0x100000D00
    .quad     0xD00000000
    .quad     0x20000020000
    .quad     0x3030303030003
    .quad     0x303030003030300
    .quad     0xD0000
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x3000D0101000101
    .quad     2
    .byte     0
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     7
    .byte     1
#ENDDATA
pc_tables.pclargs:
    .quad     0
    .quad     0x202000000000000
    .quad     0x9090009090202
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101010101010101
    .quad     0x2020201
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.ccnames:
    .quad     L9203
    .quad     L9204
    .quad     L9205
    .quad     L9206
    .quad     L9207
    .quad     L9208
    .quad     L9209
    .align    8
pc_tables.idnames:
    .quad     L9210
    .quad     L9211
    .quad     L9212
    .quad     L9213
    .quad     L9214
    .quad     L9215
    .quad     L9216
    .quad     L9217
    .quad     L9218
    .quad     L9219
    .bss
    .align    8
mc_genmcl.debug:
    .space    8
    .align    8
mc_genmcl.frameoffset:
    .space    8
    .align    8
mc_genmcl.paramoffset:
    .space    8
    .align    8
mc_genmcl.framebytes:
    .space    8
    .align    8
mc_genmcl.px_handlertable:
    .space    1144
    .data
mc_genmcl.scondcodes:
    .byte     4
    .byte     5
    .byte     12
    .byte     14
    .byte     13
    .byte     15
#ENDDATA
mc_genmcl.ucondcodes:
    .byte     4
    .byte     5
    .byte     2
    .byte     6
    .byte     3
    .byte     7
#ENDDATA
mc_genmcl.inithandlers.initdone:
    .byte     0
mc_genmcl.inithandlers.dupltable:
    .ascii    "MX"
#ENDDATA
    .ascii    "A@"
#ENDDATA
    .byte     21
    .byte     18
#ENDDATA
    .byte     19
    .byte     18
#ENDDATA
    .byte     22
    .byte     18
#ENDDATA
    .ascii    "wv"
#ENDDATA
    .ascii    "yx"
#ENDDATA
    .ascii    "^/"
#ENDDATA
    .ascii    "_0"
#ENDDATA
    .bss
    .align    8
mc_auxmcl.nnn:
    .space    8
    .align    8
mc_auxmcl.nauxprocs:
    .space    8
    .align    8
mc_auxmcl.nauxnoframe:
    .space    8
    .align    8
mc_auxmcl.mclframesetup:
    .space    8
    .align    8
mc_libmcl.mclseqno:
    .space    8
    .align    8
mc_libmcl.nmclopnd:
    .space    8
    .align    8
mc_libmcl.smallinttable:
    .space    96
    .align    8
mc_libmcl.nametable:
    .space    160
    .align    8
mc_libmcl.nnametable:
    .space    8
    .align    8
mc_libmcl.mgenextname.table:
    .space    160
    .align    8
mc_libmcl.mgenextname.ntable:
    .space    8
mc_stackmcl.stropndstack.str:
    .space    512
mc_genss.rex:
    .space    1
mc_genss.sizeoverride:
    .space    1
mc_genss.addroverride:
    .space    1
mc_genss.f2override:
    .space    1
mc_genss.f3override:
    .space    1
mc_genss.nowmask:
    .space    1
mc_genss.usesizeb:
    .space    1
    .align    8
mc_genss.extraparam:
    .space    8
    .data
    .align    8
mc_genss.currseg:
    .quad     0
    .bss
    .align    8
mc_genss.currdata:
    .space    8
    .align    8
mc_genss.currrelocs:
    .space    8
    .align    8
mc_genss.nrelocs:
    .space    8
mc_genss.ishighreg:
    .space    16
    .align    8
mc_genss.currmcl:
    .space    8
    .align    8
mc_genss.ripentry:
    .space    8
    .data
    .align    8
mc_genss.genrm.scaletable:
    .quad     0
    .quad     1
    .quad     0
    .quad     2
    .quad     0
    .quad     0
    .quad     0
    .quad     3
    .align    8
mc_decls.valtypenames:
    .quad     L9220
    .quad     L9221
    .quad     L9222
    .quad     L9223
    .quad     L9224
    .quad     L9225
    .quad     L9226
    .quad     L9227
    .quad     L9228
    .align    8
mc_decls.mclnames:
    .quad     L9229
    .quad     L9230
    .quad     L9231
    .quad     L9232
    .quad     L9233
    .quad     L9234
    .quad     L9235
    .quad     L9236
    .quad     L9237
    .quad     L9238
    .quad     L9239
    .quad     L9240
    .quad     L9241
    .quad     L9242
    .quad     L9243
    .quad     L9244
    .quad     L9245
    .quad     L9246
    .quad     L9247
    .quad     L9248
    .quad     L9249
    .quad     L9250
    .quad     L9251
    .quad     L9252
    .quad     L9253
    .quad     L9254
    .quad     L9255
    .quad     L9256
    .quad     L9257
    .quad     L9258
    .quad     L9259
    .quad     L9260
    .quad     L9261
    .quad     L9262
    .quad     L9263
    .quad     L9264
    .quad     L9265
    .quad     L9266
    .quad     L9267
    .quad     L9268
    .quad     L9269
    .quad     L9270
    .quad     L9271
    .quad     L9272
    .quad     L9273
    .quad     L9274
    .quad     L9275
    .quad     L9276
    .quad     L9277
    .quad     L9278
    .quad     L9279
    .quad     L9280
    .quad     L9281
    .quad     L9282
    .quad     L9283
    .quad     L9284
    .quad     L9285
    .quad     L9286
    .quad     L9287
    .quad     L9288
    .quad     L9289
    .quad     L9290
    .quad     L9291
    .quad     L9292
    .quad     L9293
    .quad     L9294
    .quad     L9295
    .quad     L9296
    .quad     L9297
    .quad     L9298
    .quad     L9299
    .quad     L9300
    .quad     L9301
    .quad     L9302
    .quad     L9303
    .quad     L9304
    .quad     L9305
    .quad     L9306
    .quad     L9307
    .quad     L9308
    .quad     L9309
    .quad     L9310
    .quad     L9311
    .quad     L9312
    .quad     L9313
    .quad     L9314
    .quad     L9315
    .quad     L9316
    .quad     L9317
    .quad     L9318
    .quad     L9319
    .quad     L9320
    .quad     L9321
    .quad     L9322
    .quad     L9323
    .quad     L9324
    .quad     L9325
    .quad     L9326
    .quad     L9327
    .quad     L9328
    .quad     L9329
    .quad     L9330
    .quad     L9331
    .quad     L9332
    .quad     L9333
    .quad     L9334
    .quad     L9335
    .quad     L9336
    .quad     L9337
    .quad     L9338
    .quad     L9339
    .quad     L9340
    .quad     L9341
    .quad     L9342
    .quad     L9343
    .quad     L9344
    .quad     L9345
    .quad     L9346
    .quad     L9347
    .quad     L9348
    .quad     L9349
    .quad     L9350
    .quad     L9351
    .quad     L9352
    .quad     L9353
    .quad     L9354
    .quad     L9355
    .quad     L9356
    .quad     L9357
    .quad     L9358
    .quad     L9359
    .quad     L9360
    .quad     L9361
    .quad     L9362
    .quad     L9363
    .quad     L9364
    .quad     L9365
    .quad     L9366
    .quad     L9367
    .quad     L9368
    .quad     L9369
    .quad     L9370
    .quad     L9371
    .quad     L9372
    .quad     L9373
    .quad     L9374
    .quad     L9375
    .quad     L9376
    .quad     L9377
    .quad     L9378
    .quad     L9379
    .quad     L9380
mc_decls.mclnopnds:
    .quad     0
    .quad     0x202020101020001
    .quad     0x100000102020202
    .quad     0x102020202020101
    .quad     0x202020101030201
    .quad     0x202020202020202
    .quad     0x101010102
    .quad     0x202020202020100
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010303020202
    .quad     0x10101
    .quad     0x200000000000000
    .quad     0x101010101020202
    .quad     0x101010101000000
    .quad     0x10101010100
    .quad     0x102000000
    .quad     0
#ENDDATA
mc_decls.mclcodes:
    .quad     0
    .quad     0x9000
    .quad     0xC9C3E800000000
    .quad     0x5030205000000E9
    .quad     0x601040607000004
    .quad     0x201000507040700
    .quad     0x100020303
    .quad     0x5151ACA4BDBC0000
    .quad     0x5E5E59595C5C5858
    .quad     0xEF545457572E2F00
    .quad     0xDB
    .quad     0x302006263F36600
    .quad     0xFAF9C9E9C1030200
    .quad     0x5DE0E1F3F2FBFFFE
    .quad     0x5F5D5F
    .quad     0x804020100000000
    .quad     0xE3E3E2E1E0D7
    .quad     0xE8EE000000310000
    .quad     0xF4F400EDECEAE9EB
#ENDDATA
    .align    8
mc_decls.regnames:
    .quad     L9381
    .quad     L9382
    .quad     L9383
    .quad     L9384
    .quad     L9385
    .quad     L9386
    .quad     L9387
    .quad     L9388
    .quad     L9389
    .quad     L9390
    .quad     L9391
    .quad     L9392
    .quad     L9393
    .quad     L9394
    .quad     L9395
    .quad     L9396
    .quad     L9397
    .quad     L9398
    .quad     L9399
    .quad     L9400
    .quad     L9401
mc_decls.regcodes:
    .quad     0xC0603070B0A0000
    .quad     0x5090802010F0E0D
    .byte     4
    .byte     4
    .byte     7
    .byte     5
    .byte     6
#ENDDATA
    .align    8
mc_decls.condnames:
    .quad     L9402
    .quad     L9403
    .quad     L9404
    .quad     L9405
    .quad     L9406
    .quad     L9407
    .quad     L9408
    .quad     L9409
    .quad     L9410
    .quad     L9411
    .quad     L9412
    .quad     L9413
    .quad     L9414
    .quad     L9415
    .quad     L9416
    .quad     L9417
    .quad     L9418
    .quad     L9419
    .quad     L9420
    .quad     L9421
    .align    8
mc_decls.asmcondnames:
    .quad     L9422
    .quad     L9423
    .quad     L9424
    .quad     L9425
    .quad     L9426
    .quad     L9427
    .quad     L9428
    .quad     L9429
    .quad     L9430
    .quad     L9431
    .quad     L9432
    .quad     L9433
    .quad     L9434
    .quad     L9435
    .quad     L9436
    .quad     L9437
    .quad     L9438
    .quad     L9439
    .quad     L9440
    .quad     L9441
    .align    8
mc_decls.asmrevcond:
    .quad     1
    .quad     0
    .quad     3
    .quad     2
    .quad     5
    .quad     4
    .quad     7
    .quad     6
    .quad     9
    .quad     8
    .quad     0xB
    .quad     0xA
    .quad     0xD
    .quad     0xC
    .quad     0xF
    .quad     0xE
    .quad     0x11
    .quad     0x10
    .quad     0x13
    .quad     0x12
    .align    8
mc_decls.dregnames:
    .quad     L9442
    .quad     L9443
    .quad     L9444
    .quad     L9445
    .quad     L9446
    .quad     L9447
    .quad     L9448
    .quad     L9449
    .quad     L9450
    .quad     L9451
    .quad     L9452
    .quad     L9453
    .quad     L9454
    .quad     L9455
    .quad     L9456
    .quad     L9457
    .quad     L9458
    .quad     L9459
    .quad     L9460
    .quad     L9461
    .quad     L9462
    .quad     L9463
    .quad     L9464
    .quad     L9465
    .quad     L9466
    .quad     L9467
    .quad     L9468
    .quad     L9469
    .quad     L9470
    .quad     L9471
    .quad     L9472
    .quad     L9473
    .quad     L9474
    .quad     L9475
    .quad     L9476
    .quad     L9477
    .quad     L9478
    .quad     L9479
    .quad     L9480
    .quad     L9481
    .quad     L9482
    .quad     L9483
    .quad     L9484
    .quad     L9485
    .quad     L9486
    .quad     L9487
    .quad     L9488
    .quad     L9489
    .quad     L9490
    .quad     L9491
    .quad     L9492
    .quad     L9493
    .quad     L9494
    .quad     L9495
    .quad     L9496
    .quad     L9497
    .quad     L9498
    .quad     L9499
    .quad     L9500
    .quad     L9501
    .quad     L9502
    .quad     L9503
    .quad     L9504
    .quad     L9505
    .quad     L9506
    .quad     L9507
    .quad     L9508
    .quad     L9509
    .quad     L9510
    .quad     L9511
    .quad     L9512
    .quad     L9513
    .quad     L9514
    .quad     L9515
    .quad     L9516
    .quad     L9517
    .quad     L9518
    .quad     L9519
    .quad     L9520
    .quad     L9521
    .quad     L9522
    .quad     L9523
    .quad     L9524
    .quad     L9525
    .quad     L9526
    .quad     L9527
    .quad     L9528
    .quad     L9529
    .quad     L9530
    .quad     L9531
    .quad     L9532
    .quad     L9533
    .quad     L9534
    .quad     L9535
    .quad     L9536
    .quad     L9537
    .quad     L9538
    .quad     L9539
    .quad     L9540
    .quad     L9541
    .quad     L9542
    .quad     L9543
    .quad     L9544
    .quad     L9545
    .quad     L9546
    .quad     L9547
    .quad     L9548
    .quad     L9549
    .quad     L9550
    .quad     L9551
    .quad     L9552
    .quad     L9553
    .quad     L9554
    .quad     L9555
    .quad     L9556
    .quad     L9557
    .quad     L9558
    .quad     L9559
    .quad     L9560
    .quad     L9561
    .quad     L9562
    .quad     L9563
    .quad     L9564
    .quad     L9565
    .quad     L9566
    .quad     L9567
    .quad     L9568
    .quad     L9569
    .quad     L9570
    .quad     L9571
    .quad     L9572
    .quad     L9573
    .quad     L9574
    .quad     L9575
    .quad     L9576
    .quad     L9577
    .quad     L9578
mc_decls.regsizes:
    .quad     0x808080808080808
    .quad     0x808080808080808
    .quad     0x404040404040404
    .quad     0x404040404040404
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x808080001010101
    .quad     0x808080808080808
    .quad     0x404040808080808
    .quad     0x404040404040404
    .quad     0x202020404040404
    .quad     0x202020202020202
    .quad     0x101010202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .byte     1
#ENDDATA
mc_decls.regindices:
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0xB05010014131211
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0xF0406141312110C
    .quad     0x9080703020E0D10
    .byte     10
#ENDDATA
    .align    8
mc_decls.xmmregnames:
    .quad     L9579
    .quad     L9580
    .quad     L9581
    .quad     L9582
    .quad     L9583
    .quad     L9584
    .quad     L9585
    .quad     L9586
    .quad     L9587
    .quad     L9588
    .quad     L9589
    .quad     L9590
    .quad     L9591
    .quad     L9592
    .quad     L9593
    .quad     L9594
    .align    8
mc_decls.fregnames:
    .quad     L9595
    .quad     L9596
    .quad     L9597
    .quad     L9598
    .quad     L9599
    .quad     L9600
    .quad     L9601
    .quad     L9602
    .align    8
mc_decls.mregnames:
    .quad     L9603
    .quad     L9604
    .quad     L9605
    .quad     L9606
    .quad     L9607
    .quad     L9608
    .quad     L9609
    .quad     L9610
    .align    8
mc_decls.jmpccnames:
    .quad     L9611
    .quad     L9612
    .quad     L9613
    .quad     L9614
    .quad     L9615
    .quad     L9616
    .quad     L9617
    .quad     L9618
    .quad     L9619
    .quad     L9620
    .quad     L9621
    .quad     L9622
    .quad     L9623
    .quad     L9624
    .quad     L9625
    .quad     L9626
    .quad     L9627
    .quad     L9628
mc_decls.jmpcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
    .byte     2
    .byte     3
#ENDDATA
    .align    8
mc_decls.setccnames:
    .quad     L9629
    .quad     L9630
    .quad     L9631
    .quad     L9632
    .quad     L9633
    .quad     L9634
    .quad     L9635
    .quad     L9636
    .quad     L9637
    .quad     L9638
    .quad     L9639
    .quad     L9640
    .quad     L9641
    .quad     L9642
    .quad     L9643
    .quad     L9644
mc_decls.setcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.cmovccnames:
    .quad     L9645
    .quad     L9646
    .quad     L9647
    .quad     L9648
    .quad     L9649
    .quad     L9650
    .quad     L9651
    .quad     L9652
    .quad     L9653
    .quad     L9654
    .quad     L9655
    .quad     L9656
    .quad     L9657
    .quad     L9658
    .quad     L9659
    .quad     L9660
mc_decls.cmovcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.segmentnames:
    .quad     L9661
    .quad     L9662
    .quad     L9663
    .quad     L9664
    .quad     L9665
    .quad     L9666
    .align    8
mc_decls.reftypenames:
    .quad     L9667
    .quad     L9668
    .quad     L9669
    .align    8
mc_decls.opndnames_ma:
    .quad     L9670
    .quad     L9671
    .quad     L9672
    .quad     L9673
    .quad     L9674
    .quad     L9675
    .bss
    .align    8
mc_decls.pclopnd:
    .space    400
mc_decls.pclreg:
    .space    50
mc_decls.pclmode:
    .space    50
mc_decls.pclcount:
    .space    50
mc_decls.pclloc:
    .space    50
mc_decls.pcltempflags:
    .space    50
    .align    8
mc_decls.pcltempopnds:
    .space    400
    .align    8
mc_decls.noperands:
    .space    8
    .align    8
mc_decls.mstackdepth:
    .space    8
    .data
    .align    8
mc_decls.locnames:
    .quad     L9676
    .quad     L9677
    .quad     L9678
    .quad     L9679
    .bss
mc_decls.workregs:
    .space    16
mc_decls.workxregs:
    .space    16
    .align    8
mc_decls.nworkregs:
    .space    8
    .align    8
mc_decls.nworkxregs:
    .space    8
    .align    8
mc_decls.nregvars:
    .space    8
    .align    8
mc_decls.nxregvars:
    .space    8
    .align    8
mc_decls.maxregvars:
    .space    8
    .align    8
mc_decls.maxxregvars:
    .space    8
    .align    8
mc_decls.xregmax:
    .space    8
mc_decls.regset:
    .space    16
mc_decls.xregset:
    .space    16
mc_decls.isregvar:
    .space    16
mc_decls.isxregvar:
    .space    16
mc_decls.usedregs:
    .space    16
mc_decls.usedxregs:
    .space    16
mc_decls.noxorclear:
    .space    1
    .data
    .align    8
mc_decls.xregnames:
    .quad     L9680
    .quad     L9681
    .quad     L9682
    .quad     L9683
    .quad     L9684
    .quad     L9685
    .quad     L9686
    .quad     L9687
    .quad     L9688
    .quad     L9689
    .quad     L9690
    .quad     L9691
    .quad     L9692
    .quad     L9693
    .quad     L9694
    .quad     L9695
    .quad     L9695
    .bss
mc_decls.callalign:
    .space    32
mc_decls.callblockret:
    .space    32
    .align    4
mc_decls.callblocksize:
    .space    128
    .align    4
mc_decls.callargsize:
    .space    512
    .align    8
mc_decls.ncalldepth:
    .space    8
    .align    8
mc_decls.lababs32:
    .space    8
    .align    8
mc_decls.lababs64:
    .space    8
    .align    8
mc_decls.labneg32:
    .space    8
    .align    8
mc_decls.labneg64:
    .space    8
    .align    8
mc_decls.labmask63:
    .space    8
    .align    8
mc_decls.laboffset64:
    .space    8
    .align    8
mc_decls.labzero:
    .space    8
    .data
    .align    8
mc_decls.kk0used:
    .quad     0
    .bss
    .align    8
mc_decls.mccode:
    .space    8
    .align    8
mc_decls.mccodex:
    .space    8
    .data
    .align    8
mc_decls.currsegment:
    .quad     0
    .bss
    .align    8
mc_decls.dstackopnd:
    .space    8
    .align    8
mc_decls.dframeopnd:
    .space    8
    .align    8
mc_decls.regtable:
    .space    1024
    .align    8
mc_decls.frameregtable:
    .space    1544
    .align    8
mc_decls.cstringlist:
    .space    8
    .align    8
mc_decls.vstringlist:
    .space    8
    .align    8
mc_decls.creallist:
    .space    8
    .align    8
mc_decls.cr32list:
    .space    8
    .align    8
mc_decls.currasmproc:
    .space    8
    .align    8
mc_decls.lab_funcnametable:
    .space    8
    .align    8
mc_decls.lab_funcaddrtable:
    .space    8
    .align    8
mc_decls.lab_funcnprocs:
    .space    8
    .align    8
mc_decls.ss_zdatalen:
    .space    8
    .align    8
mc_decls.ss_zdata:
    .space    8
    .align    8
mc_decls.ss_idata:
    .space    8
    .align    8
mc_decls.ss_code:
    .space    8
    .align    8
mc_decls.ss_idatarelocs:
    .space    8
    .align    8
mc_decls.ss_coderelocs:
    .space    8
    .align    8
mc_decls.ss_nidatarelocs:
    .space    8
    .align    8
mc_decls.ss_ncoderelocs:
    .space    8
    .align    8
mc_decls.ss_symboltable:
    .space    8
    .align    8
mc_decls.ss_nsymbols:
    .space    8
    .align    8
mc_decls.ss_symboltablesize:
    .space    8
    .align    8
mc_decls.labeldeftable:
    .space    8
    .align    8
mc_decls.aaseqno:
    .space    8
    .align    8
mc_decls.aapos:
    .space    8
    .data
mc_decls.regmodes:
    .quad     0x600000005000403
#ENDDATA
    .bss
mc_decls.pmode:
    .space    1
    .align    8
mc_decls.currpcl:
    .space    8
    .align    8
mc_decls.mclprocentry:
    .space    8
    .align    8
mc_decls.mce_oldmccodex:
    .space    8
    .align    8
mc_decls.mce_lastmcl:
    .space    8
    .align    8
mc_decls.mce_nextmcl:
    .space    8
    .align    8
mc_decls.mcf_oldmccodex:
    .space    8
    .align    8
mc_decls.mcf_lastmcl:
    .space    8
    .align    8
mc_decls.mcf_nextmcl:
    .space    8
mc_decls.fpcheckunusedlocals:
    .space    1
    .align    8
mc_decls.riplist:
    .space    8
    .align    8
mc_decls.blockdefs:
    .space    400
    .align    8
mc_decls.nblocktemps:
    .space    8
    .data
    .align    8
mc_decls.multregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     0xB
    .quad     0xC
    .quad     0xD
    .align    8
mc_decls.multxregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     4
    .quad     5
    .quad     6
    .bss
mc_decls.ploadopx:
    .space    14
mc_decls.ploadop:
    .space    14
    .data
    .align    8
mc_objdecls.relocnames:
    .quad     L9696
    .quad     L9697
    .quad     L9698
    .quad     L9699
    .quad     L9700
    .quad     L9701
    .quad     L9702
    .align    8
mc_writeasm.asmext:
    .quad     L9703
    .bss
    .align    8
mc_writeasm.nregnames:
    .space    1024
    .align    8
mc_writeasm.regvars:
    .space    128
    .align    8
mc_writeasm.xregvars:
    .space    128
mc_writeasm.strmcl.str:
    .space    512
mc_writeasm.mstropnd.str:
    .space    512
mc_writeasm.strvalue.str:
    .space    512
    .data
    .align    8
mc_writeasm.getregname.prefix:
    .quad     L9704
    .quad     L9705
    .quad     L9706
    .quad     L9707
    .quad     L9708
    .quad     L9708
    .quad     L9708
    .quad     L9709
    .quad     L9710
    .quad     L9710
    .quad     L9710
    .quad     L9710
    .quad     L9710
    .quad     L9710
    .quad     L9710
    .quad     L9711
    .quad     L9712
    .bss
mc_writeasm.getregname.str:
    .space    32
mc_writeasm.getxregname.str:
    .space    32
mc_writeasm.getdispname.str:
    .space    256
mc_writeasm.gettempname.str:
    .space    128
    .align    8
mc_writeexe.libinsttable:
    .space    400
    .align    8
mc_writeexe.libinstnames:
    .space    400
    .align    8
mc_writeexe.libnotable:
    .space    400
    .align    8
mc_writeexe.basereloclist:
    .space    8
    .align    8
mc_writeexe.nbaserelocs:
    .space    8
    .align    8
mc_writeexe.maxrelocaddr:
    .space    8
    .align    8
mc_writeexe.blockbases:
    .space    4000
    .align    4
mc_writeexe.blockcounts:
    .space    2000
    .align    4
mc_writeexe.blockbytes:
    .space    2000
mc_writeexe.blockpadding:
    .space    500
    .align    8
mc_writeexe.nbaseblocks:
    .space    8
    .align    8
mc_writeexe.basetablesize:
    .space    8
    .align    8
mc_writeexe.imagebase:
    .space    8
    .align    8
mc_writeexe.imagesize:
    .space    8
    .align    8
mc_writeexe.filesize:
    .space    8
    .align    8
mc_writeexe.thunktable:
    .space    8
    .align    8
mc_writeexe.fileiatoffset:
    .space    8
    .align    8
mc_writeexe.fileiatsize:
    .space    8
    .align    8
mc_writeexe.stentrypoint:
    .space    8
    .align    8
mc_writeexe.stentrypoint2:
    .space    8
    .align    8
mc_writeexe.stentrypoint3:
    .space    8
    .align    8
mc_writeexe.sectiontable:
    .space    720
    .align    8
mc_writeexe.nsections:
    .space    8
    .align    8
mc_writeexe.importdir:
    .space    8
    .align    8
mc_writeexe.importtable:
    .space    144048
    .align    8
mc_writeexe.nimports:
    .space    8
    .align    8
mc_writeexe.exporttable:
    .space    16000
    .align    8
mc_writeexe.nexports:
    .space    8
    .align    8
mc_writeexe.dllfilename:
    .space    8
    .align    8
mc_writeexe.isdll:
    .space    8
    .align    8
mc_writeexe.dlltable:
    .space    2400
    .align    8
mc_writeexe.ndlls:
    .space    8
    .align    8
mc_writeexe.datastart:
    .space    8
    .align    8
mc_writeexe.dataptr:
    .space    8
    .align    8
mc_writeexe.userentrypoint:
    .space    8
    .align    8
mc_writeexe.exportdirvirtaddr:
    .space    8
    .align    8
mc_writeexe.exportdirvirtsize:
    .space    8
    .align    8
mc_writeexe.exportdiroffset:
    .space    8
    .align    8
mc_writeexe.blockdirvirtaddr:
    .space    8
    .align    8
mc_writeexe.blockdirvirtsize:
    .space    8
    .align    8
mc_writeexe.blockdiroffset:
    .space    8
    .data
mc_writeexe.writedosstub.stubdata:
    .quad     0x300905A4D
    .quad     0xFFFF00000004
    .quad     0xB8
    .quad     0x40
    .quad     0
    .quad     0
    .quad     0
    .quad     0x8000000000
    .quad     0xCD09B4000EBA1F0E
    .quad     0x685421CD4C01B821
    .quad     0x72676F7270207369
    .quad     0x6F6E6E6163206D61
    .quad     0x6E75722065622074
    .quad     0x20534F44206E6920
    .quad     0xA0D0D2E65646F6D
    .quad     0x24
#ENDDATA
    .bss
    .align    8
mc_writeobj.symtaboffset:
    .space    8
    .align    8
mc_writeobj.datastart:
    .space    8
    .align    8
mc_writeobj.dataptr:
    .space    8
    .align    2
mc_writeobj.symboltable:
    .space    234018
    .align    8
mc_writeobj.nsymbols:
    .space    8
    .data
    .align    8
mc_writeobj.stoffset:
    .quad     0
    .bss
    .align    8
mc_writeobj.stringtable:
    .space    40000
    .align    8
mc_writeobj.stringlengths:
    .space    40000
    .data
    .align    8
mc_writeobj.nextstringoffset:
    .quad     0
    .align    8
mc_writeobj.nstrings:
    .quad     0
    .bss
    .align    2
mc_writeobj.writerelocs.s:
    .space    10
    .align    2
mc_writeobj.makesymbol.r:
    .space    18
    .align    2
mc_writeobj.strtoaux.r:
    .space    18
    .align    2
mc_writeobj.sectiontoaux.r:
    .space    18
    .data
    .align    8
mx_decls.mcxdirnames:
    .quad     L9713
    .quad     L9714
    .quad     L9715
    .quad     L9716
    .quad     L9717
    .quad     L9718
    .quad     L9719
    .quad     L9720
    .quad     L9721
    .quad     L9722
    .quad     L9723
    .quad     L9724
    .quad     L9725
    .quad     L9726
    .align    8
mx_decls.mcxrelocnames:
    .quad     L9727
    .quad     L9728
    .quad     L9729
    .quad     L9730
    .quad     L9731
    .quad     L9732
    .bss
    .align    8
mx_decls.dllnametable:
    .space    160
    .align    8
mx_decls.dllinsttable:
    .space    160
    .align    8
mx_decls.ndlllibs:
    .space    8
    .align    8
mx_decls.libnametable:
    .space    160
    .align    8
mx_decls.libtable:
    .space    160
mx_decls.librelocated:
    .space    20
mx_decls.libinitdone:
    .space    20
    .align    8
mx_decls.nlibs:
    .space    8
    .align    8
mx_decls.symbolnametable:
    .space    24000
mx_decls.symboldefined:
    .space    3000
    .align    8
mx_decls.symboladdress:
    .space    24000
    .align    2
mx_decls.symbollibindex:
    .space    6000
mx_decls.symboldllindex:
    .space    3000
    .align    8
mx_decls.nsymbols:
    .space    8
    .data
    .align    8
mx_decls.nsymimports:
    .quad     0
    .align    8
mx_decls.nsymexports:
    .quad     0
    .align    8
mx_lib.rsegmentnames:
    .quad     L9733
    .quad     L9734
    .quad     L9735
    .quad     L9736
    .quad     L9737
    .quad     L9738
    .bss
    .align    8
mx_write.dest:
    .space    8
    .align    8
mx_write.entrypoint:
    .space    8
    .data
    .align    8
cc_cli.passnames:
    .quad     L9739
    .quad     L9740
    .quad     L9741
    .quad     L9742
    .quad     L9743
    .quad     L9744
    .quad     L9745
    .quad     L9746
    .quad     L9747
    .quad     L9748
    .quad     L9749
    .quad     L9750
    .quad     L9751
    .align    8
cc_cli.extnames:
    .quad     L9752
    .quad     L9753
    .quad     L9754
    .quad     L9754
    .quad     L9755
    .quad     L9756
    .quad     L9757
    .quad     L9757
    .quad     L9758
    .quad     L9759
    .quad     L9760
    .quad     L9761
    .quad     L9762
    .bss
cc_cli.cc_pass:
    .space    1
cc_cli.dummy:
    .space    20
cc_cli.debugmode:
    .space    1
    .align    8
cc_cli.outfile:
    .space    8
    .data
    .align    8
cc_cli.outext:
    .quad     L9763
    .bss
    .align    8
cc_cli.cmdskip:
    .space    8
    .align    8
cc_cli.ttt:
    .space    8
    .data
cc_cli.fverbose:
    .byte     1
cc_cli.fshowincludes:
    .byte     0
cc_cli.dointheaders:
    .byte     1
cc_cli.highmem:
    .byte     1
    .bss
cc_cli.fshowst:
    .space    1
cc_cli.fshowstflat:
    .space    1
cc_cli.fshowast:
    .space    1
cc_cli.fshowpcl:
    .space    1
cc_cli.fshowpst:
    .space    1
cc_cli.fshowmcl:
    .space    1
cc_cli.fshowss:
    .space    1
cc_cli.fshowtypes:
    .space    1
cc_cli.fshowfiles:
    .space    1
cc_cli.fshowpaths:
    .space    1
cc_cli.fshowheaders:
    .space    1
cc_cli.fwriteheaders:
    .space    1
cc_cli.fshowlog:
    .space    1
cc_cli.fshowtiming:
    .space    1
cc_cli.fgendll:
    .space    1
cc_cli.fstdout:
    .space    1
cc_cli.fshortnames:
    .space    1
    .data
cc_cli.fwriteerrors:
    .byte     1
    .bss
    .align    8
cc_cli.entrypointname:
    .space    8
    .data
    .align    8
cc_cli.optionnames:
    .quad     L9764
    .quad     L9765
    .quad     L9766
    .quad     L9767
    .quad     L9768
    .quad     L9769
    .quad     L9770
    .quad     L9771
    .quad     L9772
    .quad     L9773
    .quad     L9774
    .quad     L9775
    .quad     L9776
    .quad     L9777
    .quad     L9778
    .quad     L9779
    .quad     L9780
    .quad     L9781
    .quad     L9782
    .quad     L9783
    .quad     L9784
    .quad     L9785
    .quad     L9786
    .quad     L9787
    .quad     L9788
    .quad     L9789
    .quad     L9790
    .quad     L9791
    .quad     L9792
    .quad     L9793
    .quad     L9794
    .quad     L9795
    .quad     L9796
    .quad     L9797
    .quad     L9798
    .quad     L9799
    .quad     L9800
    .quad     L9801
    .quad     L9802
    .quad     L9803
    .quad     L9804
    .quad     L9805
    .quad     L9806
    .quad     L9807
    .quad     L9808
    .quad     L9809
    .quad     L9810
    .quad     L9811
    .quad     L9812
    .align    8
cc_cli.optvars:
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     pc_decls.fregoptim
    .quad     pc_decls.fpeephole
    .quad     0
    .quad     cc_cli.fshowpaths
    .quad     cc_cli.fshowheaders
    .quad     0
    .quad     cc_cli.fshowincludes
    .quad     cc_cli.fshowst
    .quad     cc_cli.fshowstflat
    .quad     cc_cli.fshowast
    .quad     cc_cli.fshowpcl
    .quad     cc_cli.fshowpst
    .quad     cc_cli.fshowmcl
    .quad     cc_cli.fshowss
    .quad     cc_cli.fshowtypes
    .quad     cc_cli.fshowfiles
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     pc_decls.pverbose
    .quad     pc_decls.pverbose
    .quad     0
    .quad     0
    .quad     cc_cli.dointheaders
    .quad     cc_cli.fwriteheaders
    .quad     0
    .quad     cc_cli.fstdout
    .quad     cc_cli.fshortnames
    .quad     cc_cli.highmem
    .quad     cc_cli.highmem
cc_cli.optvalues:
    .quad     0x605050403020201
    .quad     0xC0B090A0A080807
    .quad     0x10101010000000D
    .quad     0x101010101010101
    .quad     0x201000302020101
    .quad     0x1010001000000
    .byte     2
#ENDDATA
    .align    8
cc_cli.totallines:
    .quad     0
    .align    8
cc_cli.nstringobjects:
    .quad     0
    .bss
    .align    8
cc_cli.startclock:
    .space    8
    .align    8
cc_cli.loadtime:
    .space    8
    .align    8
cc_cli.parsetime:
    .space    8
    .align    8
cc_cli.pcltime:
    .space    8
    .align    8
cc_cli.compiletime:
    .space    8
    .align    8
cc_cli.inittime:
    .space    8
    .data
    .align    8
cc_cli.showextrainfo.infotext:
    .quad     L9813
    .bss
    .align    8
cc_decls.ntypes:
    .space    8
    .align    8
cc_decls.ttnamedef:
    .space    640000
    .align    2
cc_decls.ttbasetype:
    .space    160000
    .align    8
cc_decls.ttlength:
    .space    640000
cc_decls.ttconst:
    .space    80000
    .align    2
cc_decls.tttarget:
    .space    160000
    .align    2
cc_decls.ttreftype:
    .space    160000
    .align    2
cc_decls.ttconsttype:
    .space    160000
    .align    8
cc_decls.ttsize:
    .space    640000
cc_decls.ttisref:
    .space    80000
cc_decls.ttisblock:
    .space    80000
cc_decls.ttsigned:
    .space    80000
    .align    4
cc_decls.ttshared:
    .space    320000
    .align    8
cc_decls.ttparams:
    .space    640000
    .align    8
cc_decls.tttypedef:
    .space    640000
    .align    8
cc_decls.trefchar:
    .space    8
    .align    8
cc_decls.trefwchar:
    .space    8
    .align    8
cc_decls.inputfile:
    .space    8
    .align    8
cc_decls.mainfileno:
    .space    8
    .align    8
cc_decls.libfiles:
    .space    1608
    .align    8
cc_decls.sourcefilenames:
    .space    1608
    .align    8
cc_decls.sourcefilepaths:
    .space    1608
    .align    8
cc_decls.sourcefiletext:
    .space    1608
    .align    4
cc_decls.sourcefilesizes:
    .space    804
    .align    8
cc_decls.nsourcefiles:
    .space    8
    .align    8
cc_decls.nlibfiles:
    .space    8
    .align    8
cc_decls.searchdirs:
    .space    160
    .data
    .align    8
cc_decls.nsearchdirs:
    .quad     0
    .bss
    .align    8
cc_decls.includepaths:
    .space    160
    .data
    .align    8
cc_decls.nincludepaths:
    .quad     0
    .bss
    .align    8
cc_decls.stprogram:
    .space    8
    .align    8
cc_decls.stmodule:
    .space    8
    .align    8
cc_decls.logdev:
    .space    8
    .align    8
cc_decls.nullunit:
    .space    8
    .data
    .align    8
cc_decls.clineno:
    .quad     0
    .align    8
cc_decls.cfileno:
    .quad     0
    .bss
    .align    8
cc_decls.lx:
    .space    32
    .align    8
cc_decls.nextlx:
    .space    32
    .data
    .align    8
cc_decls.debug:
    .quad     0
    .align    8
cc_decls.hstsize:
    .quad     0x10000
    .bss
    .align    8
cc_decls.hstmask:
    .space    8
    .align    8
cc_decls.hashtable:
    .space    8
    .align    4
cc_decls.blockowner:
    .space    8404
    .align    4
cc_decls.blockcounts:
    .space    8404
    .align    4
cc_decls.blockstack:
    .space    404
    .align    8
cc_decls.currblockno:
    .space    8
    .align    8
cc_decls.nextblockno:
    .space    8
    .align    8
cc_decls.blocklevel:
    .space    8
    .align    8
cc_decls.currproc:
    .space    8
    .data
    .align    8
cc_decls.dheaderfile:
    .quad     0
    .align    8
cc_decls.structpadding:
    .quad     1
    .align    8
cc_decls.callbackflag:
    .quad     0
    .bss
    .align    8
cc_decls.slineno:
    .space    8
    .align    8
cc_decls.sfileno:
    .space    8
    .data
    .align    8
cc_decls.oemname:
    .quad     L9814
    .bss
    .align    8
cc_decls.mclstr:
    .space    8
    .align    8
cc_decls.mclstrlen:
    .space    8
    .align    8
cc_decls.nunits:
    .space    8
    .align    8
cc_decls.pmodulelist:
    .space    1592
    .align    8
cc_decls.pheaderlist:
    .space    800
    .align    8
cc_decls.pliblist:
    .space    800
    .align    8
cc_decls.npmodules:
    .space    8
    .align    8
cc_decls.npheaders:
    .space    8
    .align    8
cc_decls.nplibs:
    .space    8
cc_decls.pci_target:
    .space    1
    .data
    .align    8
cc_tables.stdtypenames:
    .quad     L9815
    .quad     L9816
    .quad     L9817
    .quad     L9818
    .quad     L9819
    .quad     L9820
    .quad     L9821
    .quad     L9822
    .quad     L9823
    .quad     L9824
    .quad     L9825
    .quad     L9826
    .quad     L9827
    .quad     L9828
    .quad     L9829
    .quad     L9830
    .quad     L9831
    .quad     L9832
    .quad     L9833
    .quad     L9834
    .quad     L9835
    .quad     L9836
cc_tables.stdtypewidths:
    .quad     0x1008084020100800
    .quad     0x4040400040204020
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsigned:
    .quad     0x101010100
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdpcl:
    .quad     0x403030A09080700
    .quad     0x60902010605
    .byte     11
    .byte     11
    .byte     11
    .byte     11
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsize:
    .quad     0x201010804020100
    .quad     0x8040804
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
cc_tables.catnames:
    .quad     L9837
    .quad     L9838
    .quad     L9839
    .quad     L9840
    .quad     L9841
    .align    8
cc_tables.typespecnames:
    .quad     L9842
    .quad     L9843
    .quad     L9844
    .quad     L9845
    .quad     L9846
    .quad     L9847
    .quad     L9848
    .quad     L9849
    .quad     L9850
    .quad     L9851
    .quad     L9852
    .quad     L9853
    .quad     L9854
    .quad     L9855
    .quad     L9856
    .align    4
cc_tables.typespectypes:
    .long     0
    .long     1
    .long     0
    .long     0
    .long     3
    .long     10
    .long     11
    .long     0
    .long     0
    .long     5
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
cc_tables.typespecsizes:
    .quad     0x8040404020100
    .byte     0
    .byte     1
    .byte     0
    .byte     0
    .byte     0
    .byte     4
    .byte     0
#ENDDATA
    .align    8
cc_tables.pmflagnames:
    .quad     L9857
    .quad     L9858
    .quad     L9859
    .quad     L9860
    .align    8
cc_tables.scopenames:
    .quad     L9861
    .quad     L9862
    .quad     L9863
    .quad     L9864
    .quad     L9865
    .align    8
cc_tables.cccnames:
    .quad     L9866
    .quad     L9867
    .quad     L9868
    .quad     L9869
    .quad     L9870
    .quad     L9871
    .align    8
cc_tables.linkagenames:
    .quad     L9872
    .quad     L9873
    .quad     L9874
    .quad     L9875
    .quad     L9876
    .quad     L9877
    .align    8
cc_tables.typequalnames:
    .quad     L9878
    .quad     L9879
    .quad     L9880
    .quad     L9881
    .align    8
cc_tables.fnspecnames:
    .quad     L9882
    .quad     L9883
    .quad     L9884
    .align    8
cc_tables.jtagnames:
    .quad     L9885
    .quad     L9886
    .quad     L9887
    .quad     L9888
    .quad     L9889
    .quad     L9890
    .quad     L9891
    .quad     L9892
    .quad     L9893
    .quad     L9894
    .quad     L9895
    .quad     L9896
    .quad     L9897
    .quad     L9898
    .quad     L9899
    .quad     L9900
    .quad     L9901
    .quad     L9902
    .quad     L9903
    .quad     L9904
    .quad     L9905
    .quad     L9906
    .quad     L9907
    .quad     L9908
    .quad     L9909
    .quad     L9910
    .quad     L9911
    .quad     L9912
    .quad     L9913
    .quad     L9914
    .quad     L9915
    .quad     L9916
    .quad     L9917
    .quad     L9918
    .quad     L9919
    .quad     L9920
    .quad     L9921
    .quad     L9922
    .quad     L9923
    .quad     L9924
    .quad     L9925
    .quad     L9926
    .quad     L9927
    .quad     L9928
    .quad     L9929
    .quad     L9930
    .quad     L9931
    .quad     L9932
    .quad     L9933
    .quad     L9934
    .quad     L9935
    .quad     L9936
    .quad     L9937
    .quad     L9938
    .quad     L9939
    .quad     L9940
    .quad     L9941
    .quad     L9942
    .quad     L9943
    .quad     L9944
    .quad     L9945
    .quad     L9946
    .quad     L9947
    .quad     L9948
    .quad     L9949
    .quad     L9950
    .quad     L9951
    .quad     L9952
    .quad     L9953
    .quad     L9954
    .quad     L9955
    .quad     L9956
    .quad     L9957
    .quad     L9958
    .quad     L9959
    .quad     L9960
    .quad     L9961
    .quad     L9962
    .align    8
cc_tables.symbolnames:
    .quad     L9963
    .quad     L9964
    .quad     L9965
    .quad     L9966
    .quad     L9967
    .quad     L9968
    .quad     L9969
    .quad     L9970
    .quad     L9971
    .quad     L9972
    .quad     L9973
    .quad     L9974
    .quad     L9975
    .quad     L9976
    .quad     L9977
    .quad     L9978
    .quad     L9979
    .quad     L9980
    .quad     L9981
    .quad     L9982
    .quad     L9983
    .quad     L9984
    .quad     L9985
    .quad     L9986
    .quad     L9987
    .quad     L9988
    .quad     L9989
    .quad     L9990
    .quad     L9991
    .quad     L9992
    .quad     L9993
    .quad     L9994
    .quad     L9995
    .quad     L9996
    .quad     L9997
    .quad     L9998
    .quad     L9999
    .quad     L10000
    .quad     L10001
    .quad     L10002
    .quad     L10003
    .quad     L10004
    .quad     L10005
    .quad     L10006
    .quad     L10007
    .quad     L10008
    .quad     L10009
    .quad     L10010
    .quad     L10011
    .quad     L10012
    .quad     L10013
    .quad     L10014
    .quad     L10015
    .quad     L10016
    .quad     L10017
    .quad     L10018
    .quad     L10019
    .quad     L10020
    .quad     L10021
    .quad     L10022
    .quad     L10023
    .quad     L10024
    .quad     L10025
    .quad     L10026
    .quad     L10027
    .quad     L10028
    .quad     L10029
    .quad     L10030
    .quad     L10031
    .quad     L10032
    .quad     L10033
    .quad     L10034
    .quad     L10035
    .quad     L10036
    .quad     L10037
    .quad     L10038
    .quad     L10039
    .quad     L10040
    .quad     L10041
    .quad     L10042
    .quad     L10043
    .quad     L10044
    .quad     L10045
    .quad     L10046
    .quad     L10047
    .quad     L10048
    .quad     L10049
    .quad     L10050
    .quad     L10051
    .quad     L10052
    .quad     L10053
    .quad     L10054
    .quad     L10055
    .quad     L10056
    .quad     L10057
    .quad     L10058
    .align    8
cc_tables.shortsymbolnames:
    .quad     L10059
    .quad     L10060
    .quad     L10061
    .quad     L10062
    .quad     L10062
    .quad     L10062
    .quad     L10063
    .quad     L10064
    .quad     L10065
    .quad     L10066
    .quad     L10067
    .quad     L10068
    .quad     L10069
    .quad     L10070
    .quad     L10071
    .quad     L10072
    .quad     L10073
    .quad     L10074
    .quad     L10075
    .quad     L10076
    .quad     L10077
    .quad     L10078
    .quad     L10079
    .quad     L10080
    .quad     L10081
    .quad     L10082
    .quad     L10083
    .quad     L10084
    .quad     L10085
    .quad     L10086
    .quad     L10087
    .quad     L10088
    .quad     L10089
    .quad     L10090
    .quad     L10091
    .quad     L10092
    .quad     L10093
    .quad     L10094
    .quad     L10095
    .quad     L10096
    .quad     L10097
    .quad     L10098
    .quad     L10099
    .quad     L10100
    .quad     L10101
    .quad     L10102
    .quad     L10103
    .quad     L10104
    .quad     L10105
    .quad     L10106
    .quad     L10107
    .quad     L10108
    .quad     L10109
    .quad     L10110
    .quad     L10111
    .quad     L10112
    .quad     L10112
    .quad     L10113
    .quad     L10113
    .quad     L10113
    .quad     L10114
    .quad     L10114
    .quad     L10114
    .quad     L10114
    .quad     L10115
    .quad     L10116
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10117
    .quad     L10118
cc_tables.symboltojtag:
    .quad     0x323100
    .quad     0xB0B0000
    .quad     0x2827000000000000
    .quad     0x18192E2C2D2B2A29
    .quad     0x213B48471A3C302F
    .quad     0x3F3E3D2526242322
    .quad     0x46454442434140
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
#ENDDATA
    .align    8
cc_tables.sourcedirnames:
    .quad     L10119
    .quad     L10120
    .quad     L10121
    .quad     L10122
    .quad     L10123
    .quad     L10124
    .quad     L10125
    .quad     L10126
    .quad     L10127
    .quad     L10128
    .quad     L10129
    .quad     L10130
    .quad     L10131
    .quad     L10132
    .quad     L10133
    .align    8
cc_tables.namespacenames:
    .quad     L10134
    .quad     L10135
    .quad     L10136
    .quad     L10137
    .quad     L10138
    .align    8
cc_tables.namenames:
    .quad     L10139
    .quad     L10140
    .quad     L10141
    .quad     L10142
    .quad     L10143
    .quad     L10144
    .quad     L10145
    .quad     L10146
    .quad     L10147
    .quad     L10148
    .quad     L10149
    .quad     L10150
    .quad     L10151
    .quad     L10152
    .quad     L10153
    .align    4
cc_tables.namespaces:
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     1
    .long     1
    .long     1
    .long     1
    .long     1
    .long     4
    .long     1
    .long     2
    .long     2
    .long     3
cc_tables.name2pid:
    .quad     0x302000000000000
    .byte     4
    .byte     5
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     6
#ENDDATA
    .align    8
cc_tables.stnames:
    .quad     L10154
    .quad     L10155
    .quad     L10156
    .quad     L10157
    .quad     L10158
    .quad     L10159
    .quad     L10160
    .quad     L10161
    .quad     L10162
    .quad     L10163
    .quad     L10164
    .quad     L10165
    .quad     L10166
    .quad     L10167
    .quad     L10168
    .quad     L10169
    .quad     L10170
    .quad     L10171
    .quad     L10172
    .quad     L10173
    .quad     L10174
    .quad     L10175
    .quad     L10176
    .quad     L10177
    .quad     L10178
    .quad     L10179
    .quad     L10180
    .quad     L10181
    .quad     L10182
    .quad     L10183
    .quad     L10184
    .quad     L10185
    .quad     L10186
    .quad     L10187
    .quad     L10188
    .quad     L10189
    .quad     L10190
    .quad     L10191
    .quad     L10192
    .quad     L10193
    .quad     L10194
    .quad     L10195
    .quad     L10196
    .quad     L10197
    .quad     L10198
    .quad     L10199
    .quad     L10200
    .quad     L10201
    .quad     L10202
    .quad     L10203
    .quad     L10204
    .quad     L10205
    .quad     L10206
    .quad     L10207
    .quad     L10208
    .quad     L10209
    .quad     L10210
    .quad     L10211
    .quad     L10212
    .quad     L10213
    .quad     L10214
    .quad     L10215
    .quad     L10216
    .align    4
cc_tables.stsymbols:
    .long     71
    .long     72
    .long     73
    .long     74
    .long     75
    .long     77
    .long     76
    .long     78
    .long     79
    .long     80
    .long     81
    .long     82
    .long     83
    .long     84
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     85
    .long     85
    .long     85
    .long     85
    .long     85
    .long     86
    .long     86
    .long     86
    .long     86
    .long     88
    .long     88
    .long     89
    .long     90
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     91
    .long     91
    .long     92
    .long     93
    .long     94
    .long     95
    .long     95
    .long     0
    .align    4
cc_tables.stsubcodes:
    .long     12
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     7
    .long     1
    .long     4
    .long     8
    .long     9
    .long     6
    .long     10
    .long     11
    .long     15
    .long     14
    .long     2
    .long     3
    .long     1
    .long     4
    .long     5
    .long     1
    .long     2
    .long     3
    .long     4
    .long     1
    .long     2
    .long     0
    .long     0
    .long     1
    .long     2
    .long     3
    .long     4
    .long     5
    .long     6
    .long     7
    .long     8
    .long     9
    .long     10
    .long     1
    .long     3
    .long     4
    .long     2
    .long     7
    .long     8
    .long     5
    .long     5
    .long     0
    .long     1
    .long     0
    .long     0
    .long     0
    .long     75
    .long     76
    .long     0
    .align    8
cc_tables.convnames:
    .quad     L10217
    .quad     L10218
    .quad     L10219
    .quad     L10220
    .quad     L10221
    .quad     L10222
    .quad     L10223
    .quad     L10224
    .quad     L10225
    .quad     L10226
    .quad     L10227
    .quad     L10228
    .quad     L10229
    .quad     L10230
    .bss
cc_tables.dominantmode:
    .space    1024
cc_tables.conversionops:
    .space    256
    .data
cc_tables.dominantsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     4
#ENDDATA
    .byte     1
    .byte     5
    .byte     3
#ENDDATA
    .byte     1
    .byte     6
    .byte     3
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     4
#ENDDATA
    .byte     1
    .byte     10
    .byte     10
#ENDDATA
    .byte     1
    .byte     11
    .byte     11
#ENDDATA
    .byte     2
    .byte     1
    .byte     3
#ENDDATA
    .byte     2
    .byte     2
    .byte     3
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     4
#ENDDATA
    .byte     2
    .byte     5
    .byte     3
#ENDDATA
    .byte     2
    .byte     6
    .byte     3
#ENDDATA
    .byte     2
    .byte     7
    .byte     3
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     4
#ENDDATA
    .byte     2
    .byte     10
    .byte     10
#ENDDATA
    .byte     2
    .byte     11
    .byte     11
#ENDDATA
    .byte     3
    .byte     1
    .byte     3
#ENDDATA
    .byte     3
    .byte     2
    .byte     3
#ENDDATA
    .byte     3
    .byte     3
    .byte     3
#ENDDATA
    .byte     3
    .byte     4
    .byte     4
#ENDDATA
    .byte     3
    .byte     5
    .byte     3
#ENDDATA
    .byte     3
    .byte     6
    .byte     3
#ENDDATA
    .byte     3
    .byte     7
    .byte     3
#ENDDATA
    .byte     3
    .byte     8
    .byte     8
#ENDDATA
    .byte     3
    .byte     9
    .byte     4
#ENDDATA
    .byte     3
    .byte     10
    .byte     10
#ENDDATA
    .byte     3
    .byte     11
    .byte     11
#ENDDATA
    .byte     4
    .byte     1
    .byte     4
#ENDDATA
    .byte     4
    .byte     2
    .byte     4
#ENDDATA
    .byte     4
    .byte     3
    .byte     4
#ENDDATA
    .byte     4
    .byte     4
    .byte     4
#ENDDATA
    .byte     4
    .byte     5
    .byte     4
#ENDDATA
    .byte     4
    .byte     6
    .byte     4
#ENDDATA
    .byte     4
    .byte     7
    .byte     4
#ENDDATA
    .byte     4
    .byte     8
    .byte     4
#ENDDATA
    .byte     4
    .byte     9
    .byte     9
#ENDDATA
    .byte     4
    .byte     10
    .byte     10
#ENDDATA
    .byte     4
    .byte     11
    .byte     11
#ENDDATA
    .byte     5
    .byte     1
    .byte     3
#ENDDATA
    .byte     5
    .byte     2
    .byte     3
#ENDDATA
    .byte     5
    .byte     3
    .byte     3
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     8
#ENDDATA
    .byte     5
    .byte     6
    .byte     8
#ENDDATA
    .byte     5
    .byte     7
    .byte     8
#ENDDATA
    .byte     5
    .byte     8
    .byte     8
#ENDDATA
    .byte     5
    .byte     9
    .byte     9
#ENDDATA
    .byte     5
    .byte     10
    .byte     10
#ENDDATA
    .byte     5
    .byte     11
    .byte     11
#ENDDATA
    .byte     6
    .byte     1
    .byte     3
#ENDDATA
    .byte     6
    .byte     2
    .byte     3
#ENDDATA
    .byte     6
    .byte     3
    .byte     3
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     0
#ENDDATA
    .byte     6
    .byte     6
    .byte     8
#ENDDATA
    .byte     6
    .byte     7
    .byte     8
#ENDDATA
    .byte     6
    .byte     8
    .byte     8
#ENDDATA
    .byte     6
    .byte     9
    .byte     9
#ENDDATA
    .byte     6
    .byte     10
    .byte     10
#ENDDATA
    .byte     6
    .byte     11
    .byte     11
#ENDDATA
    .byte     7
    .byte     1
    .byte     3
#ENDDATA
    .byte     7
    .byte     2
    .byte     3
#ENDDATA
    .byte     7
    .byte     3
    .byte     3
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     8
#ENDDATA
    .byte     7
    .byte     6
    .byte     8
#ENDDATA
    .byte     7
    .byte     7
    .byte     8
#ENDDATA
    .byte     7
    .byte     8
    .byte     8
#ENDDATA
    .byte     7
    .byte     9
    .byte     9
#ENDDATA
    .byte     7
    .byte     10
    .byte     10
#ENDDATA
    .byte     7
    .byte     11
    .byte     11
#ENDDATA
    .byte     8
    .byte     1
    .byte     3
#ENDDATA
    .byte     8
    .byte     2
    .byte     3
#ENDDATA
    .byte     8
    .byte     3
    .byte     8
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     8
#ENDDATA
    .byte     8
    .byte     6
    .byte     8
#ENDDATA
    .byte     8
    .byte     7
    .byte     8
#ENDDATA
    .byte     8
    .byte     8
    .byte     8
#ENDDATA
    .byte     8
    .byte     9
    .byte     9
#ENDDATA
    .byte     8
    .byte     10
    .byte     10
#ENDDATA
    .byte     8
    .byte     11
    .byte     11
#ENDDATA
    .byte     9
    .byte     1
    .byte     9
#ENDDATA
    .byte     9
    .byte     2
    .byte     9
#ENDDATA
    .byte     9
    .byte     3
    .byte     9
#ENDDATA
    .byte     9
    .byte     4
    .byte     9
#ENDDATA
    .byte     9
    .byte     5
    .byte     9
#ENDDATA
    .byte     9
    .byte     6
    .byte     9
#ENDDATA
    .byte     9
    .byte     7
    .byte     9
#ENDDATA
    .byte     9
    .byte     8
    .byte     9
#ENDDATA
    .byte     9
    .byte     9
    .byte     9
#ENDDATA
    .byte     9
    .byte     10
    .byte     10
#ENDDATA
    .byte     9
    .byte     11
    .byte     11
#ENDDATA
    .byte     10
    .byte     1
    .byte     11
#ENDDATA
    .byte     10
    .byte     2
    .byte     11
#ENDDATA
    .byte     10
    .byte     3
    .byte     11
#ENDDATA
    .byte     10
    .byte     4
    .byte     11
#ENDDATA
    .byte     10
    .byte     5
    .byte     11
#ENDDATA
    .byte     10
    .byte     6
    .byte     11
#ENDDATA
    .byte     10
    .byte     7
    .byte     11
#ENDDATA
    .byte     10
    .byte     8
    .byte     11
#ENDDATA
    .byte     10
    .byte     9
    .byte     11
#ENDDATA
    .byte     10
    .byte     10
    .byte     10
#ENDDATA
    .byte     10
    .byte     11
    .byte     11
#ENDDATA
    .byte     11
    .byte     1
    .byte     11
#ENDDATA
    .byte     11
    .byte     2
    .byte     11
#ENDDATA
    .byte     11
    .byte     3
    .byte     11
#ENDDATA
    .byte     11
    .byte     4
    .byte     11
#ENDDATA
    .byte     11
    .byte     5
    .byte     11
#ENDDATA
    .byte     11
    .byte     6
    .byte     11
#ENDDATA
    .byte     11
    .byte     7
    .byte     11
#ENDDATA
    .byte     11
    .byte     8
    .byte     11
#ENDDATA
    .byte     11
    .byte     9
    .byte     11
#ENDDATA
    .byte     11
    .byte     10
    .byte     11
#ENDDATA
    .byte     11
    .byte     11
    .byte     11
#ENDDATA
cc_tables.convsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     3
#ENDDATA
    .byte     1
    .byte     5
    .byte     13
#ENDDATA
    .byte     1
    .byte     6
    .byte     1
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     3
#ENDDATA
    .byte     1
    .byte     10
    .byte     5
#ENDDATA
    .byte     1
    .byte     11
    .byte     5
#ENDDATA
    .byte     2
    .byte     1
    .byte     12
#ENDDATA
    .byte     2
    .byte     2
    .byte     0
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     3
#ENDDATA
    .byte     2
    .byte     5
    .byte     13
#ENDDATA
    .byte     2
    .byte     6
    .byte     12
#ENDDATA
    .byte     2
    .byte     7
    .byte     1
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     3
#ENDDATA
    .byte     2
    .byte     10
    .byte     5
#ENDDATA
    .byte     2
    .byte     11
    .byte     5
#ENDDATA
    .byte     3
    .byte     1
    .byte     12
#ENDDATA
    .byte     3
    .byte     2
    .byte     12
#ENDDATA
    .byte     3
    .byte     3
    .byte     0
#ENDDATA
    .byte     3
    .byte     4
    .byte     3
#ENDDATA
    .byte     3
    .byte     5
    .byte     13
#ENDDATA
    .byte     3
    .byte     6
    .byte     12
#ENDDATA
    .byte     3
    .byte     7
    .byte     12
#ENDDATA
    .byte     3
    .byte     8
    .byte     1
#ENDDATA
    .byte     3
    .byte     9
    .byte     3
#ENDDATA
    .byte     3
    .byte     10
    .byte     5
#ENDDATA
    .byte     3
    .byte     11
    .byte     5
#ENDDATA
    .byte     4
    .byte     1
    .byte     12
#ENDDATA
    .byte     4
    .byte     2
    .byte     12
#ENDDATA
    .byte     4
    .byte     3
    .byte     12
#ENDDATA
    .byte     4
    .byte     4
    .byte     0
#ENDDATA
    .byte     4
    .byte     5
    .byte     13
#ENDDATA
    .byte     4
    .byte     6
    .byte     12
#ENDDATA
    .byte     4
    .byte     7
    .byte     12
#ENDDATA
    .byte     4
    .byte     8
    .byte     12
#ENDDATA
    .byte     4
    .byte     9
    .byte     1
#ENDDATA
    .byte     4
    .byte     10
    .byte     5
#ENDDATA
    .byte     4
    .byte     11
    .byte     5
#ENDDATA
    .byte     5
    .byte     1
    .byte     1
#ENDDATA
    .byte     5
    .byte     2
    .byte     4
#ENDDATA
    .byte     5
    .byte     3
    .byte     4
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     0
#ENDDATA
    .byte     5
    .byte     6
    .byte     1
#ENDDATA
    .byte     5
    .byte     7
    .byte     4
#ENDDATA
    .byte     5
    .byte     8
    .byte     4
#ENDDATA
    .byte     5
    .byte     9
    .byte     4
#ENDDATA
    .byte     5
    .byte     10
    .byte     6
#ENDDATA
    .byte     5
    .byte     11
    .byte     6
#ENDDATA
    .byte     6
    .byte     1
    .byte     1
#ENDDATA
    .byte     6
    .byte     2
    .byte     4
#ENDDATA
    .byte     6
    .byte     3
    .byte     4
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     13
#ENDDATA
    .byte     6
    .byte     6
    .byte     1
#ENDDATA
    .byte     6
    .byte     7
    .byte     4
#ENDDATA
    .byte     6
    .byte     8
    .byte     4
#ENDDATA
    .byte     6
    .byte     9
    .byte     4
#ENDDATA
    .byte     6
    .byte     10
    .byte     6
#ENDDATA
    .byte     6
    .byte     11
    .byte     6
#ENDDATA
    .byte     7
    .byte     1
    .byte     12
#ENDDATA
    .byte     7
    .byte     2
    .byte     1
#ENDDATA
    .byte     7
    .byte     3
    .byte     4
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     13
#ENDDATA
    .byte     7
    .byte     6
    .byte     12
#ENDDATA
    .byte     7
    .byte     7
    .byte     0
#ENDDATA
    .byte     7
    .byte     8
    .byte     4
#ENDDATA
    .byte     7
    .byte     9
    .byte     4
#ENDDATA
    .byte     7
    .byte     10
    .byte     6
#ENDDATA
    .byte     7
    .byte     11
    .byte     6
#ENDDATA
    .byte     8
    .byte     1
    .byte     12
#ENDDATA
    .byte     8
    .byte     2
    .byte     12
#ENDDATA
    .byte     8
    .byte     3
    .byte     1
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     13
#ENDDATA
    .byte     8
    .byte     6
    .byte     12
#ENDDATA
    .byte     8
    .byte     7
    .byte     12
#ENDDATA
    .byte     8
    .byte     8
    .byte     0
#ENDDATA
    .byte     8
    .byte     9
    .byte     4
#ENDDATA
    .byte     8
    .byte     10
    .byte     6
#ENDDATA
    .byte     8
    .byte     11
    .byte     6
#ENDDATA
    .byte     9
    .byte     1
    .byte     12
#ENDDATA
    .byte     9
    .byte     2
    .byte     12
#ENDDATA
    .byte     9
    .byte     3
    .byte     12
#ENDDATA
    .byte     9
    .byte     4
    .byte     1
#ENDDATA
    .byte     9
    .byte     5
    .byte     13
#ENDDATA
    .byte     9
    .byte     6
    .byte     12
#ENDDATA
    .byte     9
    .byte     7
    .byte     12
#ENDDATA
    .byte     9
    .byte     8
    .byte     12
#ENDDATA
    .byte     9
    .byte     9
    .byte     0
#ENDDATA
    .byte     9
    .byte     10
    .byte     6
#ENDDATA
    .byte     9
    .byte     11
    .byte     6
#ENDDATA
    .byte     10
    .byte     1
    .byte     7
#ENDDATA
    .byte     10
    .byte     2
    .byte     7
#ENDDATA
    .byte     10
    .byte     3
    .byte     7
#ENDDATA
    .byte     10
    .byte     4
    .byte     7
#ENDDATA
    .byte     10
    .byte     5
    .byte     8
#ENDDATA
    .byte     10
    .byte     6
    .byte     8
#ENDDATA
    .byte     10
    .byte     7
    .byte     8
#ENDDATA
    .byte     10
    .byte     8
    .byte     8
#ENDDATA
    .byte     10
    .byte     9
    .byte     8
#ENDDATA
    .byte     10
    .byte     10
    .byte     0
#ENDDATA
    .byte     10
    .byte     11
    .byte     9
#ENDDATA
    .byte     11
    .byte     1
    .byte     7
#ENDDATA
    .byte     11
    .byte     2
    .byte     7
#ENDDATA
    .byte     11
    .byte     3
    .byte     7
#ENDDATA
    .byte     11
    .byte     4
    .byte     7
#ENDDATA
    .byte     11
    .byte     5
    .byte     8
#ENDDATA
    .byte     11
    .byte     6
    .byte     8
#ENDDATA
    .byte     11
    .byte     7
    .byte     8
#ENDDATA
    .byte     11
    .byte     8
    .byte     8
#ENDDATA
    .byte     11
    .byte     9
    .byte     8
#ENDDATA
    .byte     11
    .byte     10
    .byte     10
#ENDDATA
    .byte     11
    .byte     11
    .byte     0
#ENDDATA
    .align    8
cc_tables.badexprs:
    .quad     1
    .quad     3
    .quad     0x1F
    .quad     0x18
    .quad     0x19
    .quad     0x1A
    .quad     0x1B
    .quad     0x1D
    .quad     0x20
    .quad     0x21
    .quad     0x22
    .quad     0x23
    .quad     0x24
    .quad     0x26
    .quad     0x25
    .quad     0x27
    .quad     0x28
    .quad     0x29
    .quad     0x2A
    .quad     0x2B
    .quad     0x2C
    .quad     0x2D
    .quad     0x2E
    .quad     0x2F
    .quad     0x30
    .quad     0x31
    .quad     0x32
    .quad     0x33
    .quad     0x34
    .quad     0x35
    .quad     0x36
    .quad     0x3A
    .quad     0x3B
    .quad     0x3C
    .align    8
cc_lex.tkptr:
    .quad     0
    .align    8
cc_lex.dowhitespace:
    .quad     0
    .bss
    .align    8
cc_lex.nincludes:
    .space    8
    .align    8
cc_lex.normaltkx:
    .space    32
    .data
    .align    8
cc_lex.normaltk:
    .quad     cc_lex.normaltkx
    .align    8
cc_lex.noexpand:
    .quad     0
    .bss
    .align    8
cc_lex.lx_stack:
    .space    480
    .align    8
cc_lex.lx_stackindex:
    .space    8
    .data
    .align    8
cc_lex.ifcondlevel:
    .quad     0
    .bss
    .align    8
cc_lex.headerpathlist:
    .space    160
cc_lex.headerpath:
    .space    300
    .align    8
cc_lex.lxstart:
    .space    8
    .align    8
cc_lex.lxsptr:
    .space    8
    .align    8
cc_lex.lxhashvalue:
    .space    8
    .align    8
cc_lex.lxsvalue:
    .space    8
cc_lex.alphamap:
    .space    256
cc_lex.digitmap:
    .space    256
cc_lex.commentmap:
    .space    256
cc_lex.linecommentmap:
    .space    256
cc_lex.spacemap:
    .space    256
    .align    8
cc_lex.destcopy:
    .space    8
    .align    8
cc_lex.pastedtokenlist:
    .space    696000
    .data
    .align    8
cc_lex.npastedtokens:
    .quad     0
    .align    8
cc_lex.isincludefile:
    .quad     0
    .align    8
cc_lex.firstsymbol:
    .quad     1
    .bss
    .align    8
cc_lex.reallxsptr:
    .space    8
    .align    8
cc_lex.nhstsymbols:
    .space    8
    .align    8
cc_lex.hstthreshold:
    .space    8
    .align    8
cc_lex.lex_preprocess_only.sbuffer:
    .space    16
    .data
    .align    8
cc_lex.lex_preprocess_only.dest:
    .quad     cc_lex.lex_preprocess_only.sbuffer
    .bss
cc_lex.getsourcefile.filespec:
    .space    300
    .data
    .align    8
cc_lex.lexm.doreset:
    .quad     0
    .align    8
cc_lex.lasttoken:
    .quad     0
    .bss
    .align    8
cc_lex.showtoken.buffer:
    .space    16
    .data
    .align    8
cc_lex.showtoken.dest:
    .quad     cc_lex.showtoken.buffer
    .bss
    .align    8
cc_lex.stringify.buffer:
    .space    16
    .data
    .align    8
cc_lex.stringify.deststr:
    .quad     cc_lex.stringify.buffer
    .align    8
cc_lex.expandpredefmacro.monthnames:
    .quad     L10231
    .quad     L10232
    .quad     L10233
    .quad     L10234
    .quad     L10235
    .quad     L10236
    .quad     L10237
    .quad     L10238
    .quad     L10239
    .quad     L10240
    .quad     L10241
    .quad     L10242
    .align    8
cc_lex.issimpleconstmacro.specialnames:
    .quad     L10243
    .quad     L10244
    .quad     L10245
    .bss
    .align    8
cc_parse.ist_symptr:
    .space    8
cc_parse.looptypestack:
    .space    64
    .align    8
cc_parse.loopindex:
    .space    8
    .align    8
cc_parse.casevaluestack:
    .space    512
    .data
cc_parse.ingeneric:
    .byte     0
    .bss
    .align    8
cc_genpcl.retindex:
    .space    8
    .align    8
cc_genpcl.initstaticsindex:
    .space    8
    .align    8
cc_genpcl.loopstack:
    .space    1600
    .align    8
cc_genpcl.loopindex:
    .space    8
    .align    8
cc_genpcl.zero_unit:
    .space    64
    .data
    .align    8
cc_genpcl.pzero:
    .quad     cc_genpcl.zero_unit
    .bss
    .align    8
cc_genpcl.nvarlocals:
    .space    8
    .align    8
cc_genpcl.nvarparams:
    .space    8
    .align    8
cc_blockpcl.continuestack:
    .space    512
    .align    8
cc_blockpcl.breakstack:
    .space    512
    .align    8
cc_blockpcl.loopindex:
    .space    8
    .align    8
cc_blockpcl.sw_labeltable:
    .space    8
    .align    8
cc_blockpcl.sw_valuetable:
    .space    8
    .align    8
cc_blockpcl.sw_lower:
    .space    8
    .align    8
cc_blockpcl.sw_ncases:
    .space    8
cc_blockpcl.sw_defaultseen:
    .space    1
    .align    8
cc_blockpcl.sw_defaultlabel:
    .space    8
    .align    8
cc_blockpcl.sw_breaklabel:
    .space    8
    .data
    .align    8
cc_lib.autotypeno:
    .quad     0
    .align    8
cc_lib.nextafindex:
    .quad     0
    .align    8
cc_lib.unitheapptr:
    .quad     0
    .align    8
cc_lib.remainingunits:
    .quad     0
    .bss
    .align    2
cc_lib.getoptocode.opctotable:
    .space    156
cc_lib.nextautotype.str:
    .space    32
cc_lib.getopcjname.str:
    .space    20
cc_lib.strmode.str:
    .space    16384
cc_lib.strmode2.str:
    .space    16384
cc_lib.typename.str:
    .space    300
cc_lib.getstname.name:
    .space    256
    .data
cc_support.bytemasks:
    .quad     0x8040201008040201
#ENDDATA
    .align    8
cc_headers.builtinheaders:
    .quad     1
    .align    8
cc_headers.h_assert:
    .quad     L10246
    .align    8
cc_headers.h_ctype:
    .quad     L10247
    .align    8
cc_headers.h_errno:
    .quad     L10248
    .align    8
cc_headers.h_fenv:
    .quad     L10249
    .align    8
cc_headers.h_float:
    .quad     L10250
    .align    8
cc_headers.h_inttypes:
    .quad     L10251
    .align    8
cc_headers.h_stdint:
    .quad     L10252
    .align    8
cc_headers.h_limits:
    .quad     L10253
    .align    8
cc_headers.h_locale:
    .quad     L10254
    .align    8
cc_headers.h__ansi:
    .quad     L10255
    .align    8
cc_headers.h_math:
    .quad     L10256
    .align    8
cc_headers.h_setjmp:
    .quad     L10257
    .align    8
cc_headers.h_signal:
    .quad     L10258
    .align    8
cc_headers.h_stdarg:
    .quad     L10259
    .align    8
cc_headers.h_stdbool:
    .quad     L10260
    .align    8
cc_headers.h_stddef:
    .quad     L10261
    .align    8
cc_headers.h_stdio:
    .quad     L10262
    .align    8
cc_headers.h_stdlib:
    .quad     L10263
    .align    8
cc_headers.h__syslist:
    .quad     L10264
    .align    8
cc_headers.h_string:
    .quad     L10265
    .align    8
cc_headers.h_time:
    .quad     L10266
    .align    8
cc_headers.h_utime:
    .quad     L10267
    .align    8
cc_headers.h_unistd:
    .quad     L10268
    .align    8
cc_headers.h_safelib:
    .quad     L10269
    .align    8
cc_headers.h_wchar:
    .quad     L10270
    .align    8
cc_headers.h_wctype:
    .quad     L10271
    .align    8
cc_headers.h_systypes:
    .quad     L10272
    .align    8
cc_headers.h_sysstat:
    .quad     L10273
    .align    8
cc_headers.h_systimeb:
    .quad     L10274
    .align    8
cc_headers.h_sysutime:
    .quad     L10275
    .align    8
cc_headers.h_memory:
    .quad     L10276
    .align    8
cc_headers.h_fcntl:
    .quad     L10277
    .align    8
cc_headers.h_io:
    .quad     L10278
    .align    8
cc_headers.h_direct:
    .quad     L10279
    .align    8
cc_headers.h_process:
    .quad     L10280
    .align    8
cc_headers.h_malloc:
    .quad     L10281
    .align    8
cc_headers.h_conio:
    .quad     L10282
    .align    8
cc_headers.h_winsock2:
    .quad     L10283
    .align    8
cc_headers.h__mingw:
    .quad     L10284
    .align    8
cc_headers.h_windowsx:
    .quad     L10285
    .align    8
cc_headers.stdhdrnames:
    .quad     L10286
    .quad     L10287
    .quad     L10288
    .quad     L10289
    .quad     L10290
    .quad     L10291
    .quad     L10292
    .quad     L10293
    .quad     L10294
    .quad     L10295
    .quad     L10296
    .quad     L10297
    .quad     L10298
    .quad     L10299
    .quad     L10300
    .quad     L10301
    .quad     L10302
    .quad     L10303
    .quad     L10304
    .quad     L10305
    .quad     L10306
    .quad     L10307
    .quad     L10308
    .quad     L10309
    .quad     L10310
    .quad     L10311
    .quad     L10312
    .quad     L10313
    .quad     L10314
    .quad     L10315
    .quad     L10316
    .quad     L10317
    .quad     L10318
    .quad     L10319
    .quad     L10320
    .quad     L10321
    .quad     L10322
    .quad     L10323
    .quad     L10324
    .quad     L10325
    .align    8
cc_headers.stdhdrtext:
    .quad     cc_headers.h_assert
    .quad     cc_headers.h_ctype
    .quad     cc_headers.h_errno
    .quad     cc_headers.h_fenv
    .quad     cc_headers.h_float
    .quad     cc_headers.h_inttypes
    .quad     cc_headers.h_stdint
    .quad     cc_headers.h_limits
    .quad     cc_headers.h_locale
    .quad     cc_headers.h__ansi
    .quad     cc_headers.h_math
    .quad     cc_headers.h_setjmp
    .quad     cc_headers.h_signal
    .quad     cc_headers.h_stdarg
    .quad     cc_headers.h_stdbool
    .quad     cc_headers.h_stddef
    .quad     cc_headers.h_stdio
    .quad     cc_headers.h_stdlib
    .quad     cc_headers.h__syslist
    .quad     cc_headers.h_string
    .quad     cc_headers.h_time
    .quad     cc_headers.h_utime
    .quad     cc_headers.h_unistd
    .quad     cc_headers.h_safelib
    .quad     cc_headers.h_wchar
    .quad     cc_headers.h_wctype
    .quad     cc_headers.h_systypes
    .quad     cc_headers.h_sysstat
    .quad     cc_headers.h_systimeb
    .quad     cc_headers.h_sysutime
    .quad     cc_headers.h_malloc
    .quad     cc_headers.h_fcntl
    .quad     cc_headers.h_io
    .quad     cc_headers.h_direct
    .quad     cc_headers.h_process
    .quad     cc_headers.h_memory
    .quad     cc_headers.h_conio
    .quad     cc_headers.h_winsock2
    .quad     cc_headers.h__mingw
    .quad     cc_headers.h_windowsx
    .bss
    .align    8
cc_show.currfileno:
    .space    8
    .align    8
cc_show.currlineno:
    .space    8
    .align    8
cc_show.sbuffer:
    .space    16
    .data
    .align    8
cc_show.dest:
    .quad     cc_show.sbuffer
    .bss
    .align    8
cc_show.destlinestart:
    .space    8
    .align    8
cc_show.exprstrvar:
    .space    16
    .data
    .align    8
cc_show.exprstr:
    .quad     cc_show.exprstrvar
    .bss
cc_show.getprefix.str:
    .space    512
cc_show.getdottedname.str:
    .space    256
cc_show.getlineinfok.str:
    .space    40
    .text
# Proc msys.start
msys.start:
#?>>
    .set msys.start.nargs, -8
    .set msys.start.args, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    sub       %rsp,	8
    lea       %rax,	[%rip+msys.start.startupinfo]
    push      %rax
    lea       %rcx,	[%rbp + msys.start.nargs]
    lea       %rdx,	[%rbp + msys.start.args]
    lea       %r8,	[%rip+msys.envstrings]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      __getmainargs
    add       %rsp,	48
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    movsxd    %rax,	dword ptr[%rbp + msys.start.nargs]
    mov       [%rip+msys.nsysparams],	%rax
    mov       %rax,	[%rip+msys.nsysparams]
    cmp       %rax,	128
    jle       L3
    lea       %rcx,	[%rip+L10326]
    call      printf
    mov       %rcx,	50
    call      exit
L3:
    movsxd    %rax,	dword ptr[%rbp + msys.start.nargs]
    mov       %rdi,	%rax
    mov       %r12,	1
    cmp       %rdi,	1
    jl        L6
L4:
    mov       %rax,	[%rbp + msys.start.args]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+msys.sysparams]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r12
    cmp       %r12,	%rdi
    jle       L4
L6:
    mov       %rax,	[%rip+msys.$cmdskip]
    inc       %rax
    mov       %r10,	[%rip+msys.nsysparams]
    sub       %r10,	%rax
    mov       [%rip+msys.ncmdparams],	%r10
    lea       %rax,	[%rip+msys.sysparams]
    mov       %r10,	[%rip+msys.$cmdskip]
    lea       %rax,	[%rax + %r10*8]
    mov       [%rip+msys.cmdparams],	%rax
    mov       %rsi,	1
    xor       %eax,	%eax
    mov       [%rip+msys.nenvstrings],	%rax
    jmp       L8
L7:
    inc       qword ptr[%rip+msys.nenvstrings]
    inc       %rsi
L8:
    mov       %rax,	[%rip+msys.envstrings]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    test      %rax,	%rax
    jnz       L7
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.pushio
msys.pushio:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.niostack]
    cmp       %rax,	10
    jl        L12
    lea       %rcx,	[%rip+L10327]
    call      printf
    mov       %rcx,	53
    call      exit
L12:
    inc       qword ptr[%rip+msys.niostack]
    mov       %rax,	[%rip+msys.outchan]
    lea       %r10,	[%rip+msys.outchan_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+msys.outdev]
    lea       %r10,	[%rip+msys.outdev_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+msys.fmtstr]
    lea       %r10,	[%rip+msys.fmtstr_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rip+msys.needgap]
    lea       %r10,	[%rip+msys.needgap_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.fmtstr],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.outchan],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_startfile
msys.m$print_startfile:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.pushio
    mov       [%rip+msys.outchan],	%rdi
    test      %rdi,	%rdi
    jz        L15
    mov       %rax,	2
    mov       [%rip+msys.outdev],	%rax
    jmp       L14
L15:
    mov       %rax,	1
    mov       [%rip+msys.outdev],	%rax
L14:
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startstr
msys.m$print_startstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      msys.pushio
    mov       %rax,	%rbx
    lea       %r10,	[%rip+msys.ptr_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    lea       %rax,	[%rip+msys.ptr_stack]
    mov       %r10,	[%rip+msys.niostack]
    lea       %rax,	[%rax + %r10*8-8]
    mov       %rdi,	%rax
    mov       [%rip+msys.outchan],	%rdi
    mov       %rax,	3
    mov       [%rip+msys.outdev],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startptr
msys.m$print_startptr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.pushio
    mov       [%rip+msys.outchan],	%rdi
    mov       %rax,	3
    mov       [%rip+msys.outdev],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startcon
msys.m$print_startcon:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.pushio
    mov       %rax,	1
    mov       [%rip+msys.outdev],	%rax
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_setfmt
msys.m$print_setfmt:
#?>>
#?]]
#---------------
    mov       [%rip+msys.fmtstr],	%rcx
#---------------
    ret       
# End 
# Proc msys.m$print_end
msys.m$print_end:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    mov       %rcx,	1
    call      msys.nextfmtchars
    mov       %rax,	[%rip+msys.niostack]
    cmp       %rax,	1
    jnz       L22
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jz        L23
    cmp       %rax,	2
    jnz       L22
L23:
    call      msys.dumpprintbuffer
L22:
    mov       %rax,	[%rip+msys.niostack]
    test      %rax,	%rax
    jz        L20
L25:
    lea       %rax,	[%rip+msys.outchan_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.outchan],	%rax
    lea       %rax,	[%rip+msys.outdev_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.outdev],	%rax
    lea       %rax,	[%rip+msys.fmtstr_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.fmtstr],	%rax
    lea       %rax,	[%rip+msys.needgap_stack]
    mov       %r10,	[%rip+msys.niostack]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rip+msys.needgap],	%rax
    dec       qword ptr[%rip+msys.niostack]
L20:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_ptr
msys.m$print_ptr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L28
    lea       %rax,	[%rip+L10328]
    mov       %rbx,	%rax
L28:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      msys.m$print_u64
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_ptr_nf
msys.m$print_ptr_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_ptr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_i64
msys.m$print_i64:
#?>>
    .set msys.m$print_i64.s, -40
    .set msys.m$print_i64.fmt, -56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rsi,	%rsi
    jnz       L32
    cmp       %rbx,	0
    jl        L34
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.m$print_i64.s]
    mov       %r8,	10
    xor       %r9d,	%r9d
    call      msys.u64tostr
    mov       %rdi,	%rax
    jmp       L33
L34:
    mov       %rax,	%rbx
    mov       %r10,	-9223372036854775808
    cmp       %rax,	%r10
    jnz       L35
    lea       %rax,	[%rip+msys.defaultfmt]
    lea       %r10,	[%rbp + msys.m$print_i64.fmt]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r10],	%XMM4
    jmp       L36
L35:
    mov       %al,	45
    mov       [%rbp + msys.m$print_i64.s],	%al
    lea       %rax,	[%rbp + msys.m$print_i64.s+1]
    mov       %r10,	%rbx
    neg       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	10
    xor       %r9d,	%r9d
    call      msys.u64tostr
    inc       %rax
    mov       %rdi,	%rax
L33:
    lea       %rcx,	[%rbp + msys.m$print_i64.s]
    mov       %rdx,	%rdi
    call      msys.printstr_n
    jmp       L31
L32:
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_i64.fmt]
    call      msys.strtofmt
    movzx     %rax,	byte ptr[%rbp + msys.m$print_i64.fmt+14]
    cmp       %rax,	86
    jnz       L38
    mov       [%rip+msys.fmtparam],	%rbx
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    jmp       L37
L38:
#msys.m$print_i64.dofmt:
L36:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.m$print_i64.fmt]
    call      msys.tostr_i64
L37:
L31:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_i64_nf
msys.m$print_i64_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_i64
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_bool
msys.m$print_bool:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rdi,	%rdi
    jz        L42
    lea       %rcx,	[%rip+L10329]
    mov       %rdx,	%rbx
    call      msys.m$print_str
    jmp       L41
L42:
    lea       %rcx,	[%rip+L10330]
    mov       %rdx,	%rbx
    call      msys.m$print_str
L41:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_u64
msys.m$print_u64:
#?>>
    .set msys.m$print_u64.s, -40
    .set msys.m$print_u64.fmt, -56
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rbx,	%rbx
    jnz       L45
    lea       %rcx,	[%rbp + msys.m$print_u64.s]
    lea       %rdx,	[%rip+L10331]
    mov       %r8,	%rdi
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_u64.s]
    call      msys.printstr
    jmp       L44
L45:
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_u64.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + msys.m$print_u64.fmt]
    call      msys.tostr_u64
L44:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_r64
msys.m$print_r64:
#?>>
    .set msys.m$print_r64.s, -360
    .set msys.m$print_r64.fmt, -376
    push      %rdi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	416
    movq      %XMM15,	%XMM0
    mov       %rdi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L48
    lea       %rcx,	[%rbp + msys.m$print_r64.s]
    lea       %rdx,	[%rip+L10332]
    movq      %XMM2,	%XMM15
    movq      %r8,	%XMM2
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_r64.s]
    call      msys.printstr
    jmp       L47
L48:
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_r64.fmt]
    call      msys.strtofmt
    movq      %XMM0,	%XMM15
    lea       %rdx,	[%rbp + msys.m$print_r64.fmt]
    call      msys.tostr_r64
L47:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	416
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_r32
msys.m$print_r32:
#?>>
    .set msys.m$print_r32.s, -360
    .set msys.m$print_r32.fmt, -376
    push      %rdi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	416
    movq      %XMM15,	%XMM0
    mov       %rdi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L51
    movq      %XMM4,	%XMM15
    cvtss2sd  %XMM4,	%XMM4
    lea       %rcx,	[%rbp + msys.m$print_r32.s]
    lea       %rdx,	[%rip+L10332]
    movq      %XMM2,	%XMM4
    movq      %r8,	%XMM2
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_r32.s]
    call      msys.printstr
    jmp       L50
L51:
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_r32.fmt]
    call      msys.strtofmt
    movq      %XMM4,	%XMM15
    cvtss2sd  %XMM4,	%XMM4
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rbp + msys.m$print_r32.fmt]
    call      msys.tostr_r64
L50:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	416
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_c8
msys.m$print_c8:
#?>>
    .set msys.m$print_c8.a, 40
    .set msys.m$print_c8.s, -32
    .set msys.m$print_c8.fmt, -48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       [%rbp+40],	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %bl,	%bl
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rsi,	%rsi
    jz        L54
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_c8.fmt]
    call      msys.strtofmt
    mov       %bl,	[%rbp + msys.m$print_c8.fmt+12]
L54:
    movzx     %rax,	%bl
    cmp       %rax,	77
    jnz       L56
    lea       %rcx,	[%rbp + msys.m$print_c8.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.m$print_c8.s]
    lea       %r9,	[%rbp + msys.m$print_c8.fmt]
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L55
L56:
    mov       %rax,	[%rbp + msys.m$print_c8.a]
    mov       [%rbp + msys.m$print_c8.s],	%rax
    xor       %eax,	%eax
    mov       [%rbp + msys.m$print_c8.s+8],	%al
    lea       %rcx,	[%rbp + msys.m$print_c8.s]
    call      msys.getutfsize
    mov       %rdi,	%rax
L55:
    lea       %rcx,	[%rbp + msys.m$print_c8.s]
    mov       %rdx,	%rdi
    call      msys.printstr_n
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_str
msys.m$print_str:
#?>>
    .set msys.m$print_str.fmt, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L59
    lea       %rcx,	[%rip+L10333]
    call      msys.printstr
    jmp       L57
L59:
    test      %rbx,	%rbx
    jnz       L61
    mov       %rcx,	%rdi
    call      msys.printstr
    jmp       L60
L61:
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_str.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_str.fmt]
    call      msys.tostr_str
L60:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
L57:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_strn
msys.m$print_strn:
#?>>
    .set msys.m$print_strn.fmt, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L64
    lea       %rcx,	[%rip+L10333]
    call      msys.printstr
    jmp       L62
L64:
    test      %rsi,	%rsi
    jnz       L66
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      msys.printstr_n
    jmp       L65
L66:
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_strn.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rbp + msys.m$print_strn.fmt]
    call      msys.tostr_str
L65:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
L62:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_str_nf
msys.m$print_str_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_strsl
msys.m$print_strsl:
#?>>
    .set msys.m$print_strsl.s, 16
    .set msys.m$print_strsl.fmtstyle, 24
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L10334]
    call      mlib.abortprogram
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_newline
msys.m$print_newline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    mov       %rcx,	1
    call      msys.nextfmtchars
    lea       %rcx,	[%rip+L10335]
    call      msys.printstr
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_nogap
msys.m$print_nogap:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
#---------------
    ret       
# End 
# Proc msys.m$print_space
msys.m$print_space:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    lea       %rcx,	[%rip+L10336]
    call      msys.printstr
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.printstr
msys.printstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      strlen
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      msys.printstr_n
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.printstr_n
msys.printstr_n:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      msys.dumpstr
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.printstrn_app
msys.printstrn_app:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rbx,	%rbx
    jz        L76
    test      %rsi,	%rsi
    jnz       L78
    lea       %rcx,	[%rip+L10337]
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      printf
    jmp       L77
L78:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L10337]
    mov       %r8,	%rbx
    mov       %r9,	%rdi
    call      fprintf
L77:
L76:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.printchar
msys.printchar:
#?>>
    .set msys.printchar.str, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
    mov       [%rbp + msys.printchar.str],	%dil
    xor       %eax,	%eax
    mov       [%rbp + msys.printchar.str+1],	%al
    lea       %rcx,	[%rbp + msys.printchar.str]
    mov       %rdx,	1
    call      msys.printstr_n
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc msys.nextfmtchars
msys.nextfmtchars:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rax,	[%rip+msys.fmtstr]
    test      %rax,	%rax
    jnz       L82
    mov       %rax,	[%rip+msys.needgap]
    test      %rax,	%rax
    jz        L84
    mov       %rcx,	32
    call      msys.printchar
L84:
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    jmp       L80
L82:
    mov       %rbx,	[%rip+msys.fmtstr]
    xor       %rsi,	%rsi
L85:
    mov       %rax,	[%rip+msys.fmtstr]
    mov       %dil,	[%rax]
    movzx     %rax,	%dil
    cmp       %rax,	35
    jz        L88
    test      %rax,	%rax
    jz        L89
    cmp       %rax,	126
    jz        L90
    jmp       L91
L88:
    test      %r12,	%r12
    jz        L93
    jmp       L94
L93:
    inc       qword ptr[%rip+msys.fmtstr]
    test      %rsi,	%rsi
    jz        L96
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
L96:
    jmp       L80
L89:
    test      %rsi,	%rsi
    jz        L98
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
    jmp       L97
L98:
    test      %r12,	%r12
    jnz       L99
    lea       %rcx,	[%rip+L10338]
    mov       %rdx,	1
    call      msys.printstr_n
L99:
L97:
    jmp       L80
L90:
    test      %rsi,	%rsi
    jz        L101
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
    xor       %rsi,	%rsi
L101:
    inc       qword ptr[%rip+msys.fmtstr]
    mov       %rax,	[%rip+msys.fmtstr]
    mov       %dil,	[%rax]
    test      %dil,	%dil
    jz        L103
    inc       qword ptr[%rip+msys.fmtstr]
    movzx     %rax,	%dil
    mov       %rcx,	%rax
    call      msys.printchar
L103:
    mov       %rbx,	[%rip+msys.fmtstr]
    jmp       L87
L91:
#msys.nextfmtchars.skip:
L94:
    inc       %rsi
    inc       qword ptr[%rip+msys.fmtstr]
L87:
    jmp       L85
L80:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtofmt
msys.strtofmt:
#?>>
    .set msys.strtofmt.str, -104
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    lea       %rax,	[%rip+msys.defaultfmt]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r15],	%XMM4
    test      %r13,	%r13
    jnz       L106
    jmp       L104
L106:
    cmp       %r14,	-1
    jnz       L108
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L108:
    lea       %rcx,	[%rbp + msys.strtofmt.str]
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    xor       %eax,	%eax
    mov       [%rbp + %r14 + msys.strtofmt.str],	%al
    lea       %rax,	[%rbp + msys.strtofmt.str]
    mov       %r13,	%rax
    xor       %sil,	%sil
    jmp       L110
L109:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    inc       %r13
    cmp       %rdi,	65
    jnz       L113
    mov       %al,	65
    mov       [%r15+8],	%al
    jmp       L112
L113:
    cmp       %rdi,	97
    jnz       L114
    mov       %al,	97
    mov       [%r15+8],	%al
    jmp       L112
L114:
    mov       %rcx,	%rdi
    call      toupper
    movsxd    %r10,	%eax
    sub       %r10,	66
    cmp       %r10,	25
    jae       L117
    lea       %rax,	[%rip+L116]
    jmp       [%rax + %r10*8]
    .data
L116:
    .quad     L118
    .quad     L147
    .quad     L146
    .quad     L143
    .quad     L144
    .quad     L145
    .quad     L119
    .quad     L117
    .quad     L129
    .quad     L117
    .quad     L117
    .quad     L148
    .quad     L151
    .quad     L120
    .quad     L136
    .quad     L128
    .quad     L117
    .quad     L133
    .quad     L139
    .quad     L142
    .quad     L149
    .quad     L117
    .quad     L121
    .quad     L150
    .quad     L132
    .text
L118:
    mov       %al,	2
    mov       [%r15+2],	%al
    jmp       L115
L119:
    mov       %al,	16
    mov       [%r15+2],	%al
    jmp       L115
L120:
    mov       %al,	8
    mov       [%r15+2],	%al
    jmp       L115
L121:
    xor       %rbx,	%rbx
L122:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	48
    jl        L125
    cmp       %rax,	57
    jg        L125
    mov       %rax,	%rbx
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%rdi
    sub       %rax,	48
    mov       %rbx,	%rax
    inc       %r13
    jmp       L124
L125:
    jmp       L123
L124:
    jmp       L122
L123:
    mov       %rax,	%rbx
    cmp       %rax,	2
    jl        L127
    cmp       %rax,	16
    jg        L127
    mov       [%r15+2],	%bl
L127:
    jmp       L115
L128:
    mov       %al,	34
    mov       [%r15+3],	%al
    jmp       L115
L129:
    movzx     %rax,	byte ptr[%r13]
    mov       %rcx,	%rax
    call      toupper
    mov       [%r15+9],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L131
    inc       %r13
L131:
    jmp       L115
L132:
    mov       %al,	48
    mov       [%r15+4],	%al
    jmp       L115
L133:
    mov       %al,	[%r13]
    mov       [%r15+7],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L135
    inc       %r13
L135:
    jmp       L115
L136:
    mov       %al,	[%r13]
    mov       [%r15+4],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L138
    inc       %r13
L138:
    jmp       L115
L139:
    mov       %al,	[%r13]
    mov       [%r15+10],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L141
    inc       %r13
L141:
    jmp       L115
L142:
    mov       %al,	87
    mov       [%r15+11],	%al
    jmp       L115
L143:
    mov       %al,	101
    mov       [%r15+5],	%al
    jmp       L115
L144:
    mov       %al,	102
    mov       [%r15+5],	%al
    jmp       L115
L145:
    mov       %al,	103
    mov       [%r15+5],	%al
    jmp       L115
L146:
    mov       %al,	68
    mov       [%r15+13],	%al
    jmp       L115
L147:
    mov       %al,	67
    mov       [%r15+12],	%al
    jmp       L115
L148:
    mov       %al,	77
    mov       [%r15+12],	%al
    jmp       L115
L149:
    mov       %al,	86
    mov       [%r15+14],	%al
    jmp       L115
L150:
    lea       %rax,	[%r15+15]
    or        byte ptr[%rax],	1
    jmp       L115
L151:
    lea       %rax,	[%r15+15]
    or        byte ptr[%rax],	2
    jmp       L115
L117:
    mov       %rax,	%rdi
    cmp       %rax,	46
    jz        L153
    cmp       %rax,	44
    jz        L154
    cmp       %rax,	95
    jz        L154
    cmp       %rax,	43
    jz        L155
    cmp       %rax,	126
    jz        L156
    cmp       %rax,	42
    jz        L157
    jmp       L158
L153:
    mov       %sil,	1
    jmp       L152
L154:
    mov       [%r15+7],	%dil
    jmp       L152
L155:
    mov       %al,	43
    mov       [%r15+6],	%al
    jmp       L152
L156:
    mov       %al,	126
    mov       [%r15+3],	%al
    jmp       L152
L157:
    mov       %r12,	[%rip+msys.fmtparam]
    jmp       L159
L158:
    cmp       %rdi,	48
    jl        L161
    cmp       %rdi,	57
    jg        L161
    lea       %rax,	[%rdi-48]
    mov       %r12,	%rax
L162:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%r13]
    test      %rax,	%rax
    jz        L163
L165:
    cmp       %rdi,	48
    jl        L167
    cmp       %rdi,	57
    jg        L167
    inc       %r13
    mov       %rax,	%r12
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%rdi
    sub       %rax,	48
    mov       %r12,	%rax
    jmp       L166
L167:
    jmp       L163
L166:
    jmp       L162
L163:
#msys.strtofmt.gotwidth:
L159:
    test      %sil,	%sil
    jnz       L169
    mov       [%r15],	%r12b
    mov       %sil,	1
    jmp       L168
L169:
    mov       [%r15+1],	%r12b
L168:
L161:
L152:
L115:
L112:
L110:
    mov       %al,	[%r13]
    test      %al,	%al
    jnz       L109
L104:
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.domultichar
msys.domultichar:
#?>>
    .set msys.domultichar.fmt, 88
    .set msys.domultichar.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    lea       %rax,	[%rbp + msys.domultichar.str]
    mov       %rdi,	%rax
    mov       %rbx,	%r13
    mov       %rsi,	%r13
    cmp       %rsi,	0
    jle       L173
L171:
    movzx     %rax,	byte ptr[%r12]
    test      %rax,	%rax
    jz        L173
L175:
    mov       %al,	[%r12]
    mov       [%rdi],	%al
    inc       %rdi
    inc       %r12
    dec       %rsi
    jnz       L171
L173:
    xor       %eax,	%eax
    mov       [%rdi],	%al
    lea       %rcx,	[%rbp + msys.domultichar.str]
    call      strlen
    lea       %rcx,	[%rbp + msys.domultichar.str]
    mov       %rdx,	%r14
    mov       %r8,	%rax
    mov       %r9,	[%rbp + msys.domultichar.fmt]
    call      msys.expandstr
L170:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.expandstr
msys.expandstr:
#?>>
    .set msys.expandstr.n, 80
    .set msys.expandstr.fmt, 88
    .set msys.expandstr.av_2, -8
    .set msys.expandstr.av_3, -16
    .set msys.expandstr.av_4, -24
    .set msys.expandstr.av_5, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L179
    cmp       %rbx,	[%rbp + msys.expandstr.n]
    jg        L178
L179:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.expandstr.n]
    mov       [%r14 + %r10],	%al
    mov       %rax,	[%rbp + msys.expandstr.n]
    jmp       L176
L178:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+9]
    cmp       %rax,	76
    jnz       L181
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    add       %r14,	%rax
    mov       %rdi,	1
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       %r12,	%rax
    cmp       %r12,	1
    jl        L184
L182:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    inc       %rdi
    cmp       %rdi,	%r12
    jle       L182
L184:
    xor       %eax,	%eax
    mov       [%r14],	%al
    jmp       L180
L181:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+9]
    cmp       %rax,	82
    jnz       L185
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+4]
    cmp       %rax,	48
    jnz       L187
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+2]
    test      %al,	%al
    jz        L187
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	45
    jz        L188
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	43
    jnz       L187
L188:
    mov       %al,	[%r13]
    mov       [%r14],	%al
    inc       %r14
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       [%rbp + msys.expandstr.av_2],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_2]
    cmp       %rax,	0
    jle       L191
L189:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_2]
    jnz       L189
L191:
    mov       %rax,	[%rbp + msys.expandstr.n]
    dec       %rax
    lea       %r10,	[%r13+1]
    mov       %rcx,	%r14
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    lea       %r10,	[%r14 + %rax]
    sub       %r10,	1
    xor       %eax,	%eax
    mov       [%r10],	%al
    jmp       L186
L187:
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       [%rbp + msys.expandstr.av_3],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_3]
    cmp       %rax,	0
    jle       L194
L192:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_3]
    jnz       L192
L194:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.expandstr.n]
    mov       [%r14 + %r10],	%al
L186:
    jmp       L180
L185:
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    inc       %rax
    sar       %rax,	1
    mov       %rsi,	%rax
    mov       [%rbp + msys.expandstr.av_4],	%rsi
    mov       %rax,	[%rbp + msys.expandstr.av_4]
    cmp       %rax,	0
    jle       L197
L195:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_4]
    jnz       L195
L197:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    add       %r14,	%rax
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    sub       %rax,	%rsi
    mov       [%rbp + msys.expandstr.av_5],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_5]
    cmp       %rax,	0
    jle       L200
L198:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_5]
    jnz       L198
L200:
    xor       %eax,	%eax
    mov       [%r14],	%al
L180:
    mov       %rax,	%rbx
L176:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.u64tostr
msys.u64tostr:
#?>>
    .set msys.u64tostr.t, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	368
#---------------
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %r12,	%rax
    cmp       %r8,	10
    jnz       L203
    mov       %rax,	3
    jmp       L202
L203:
    mov       %rax,	4
L202:
    mov       %r13,	%rax
L204:
    mov       %rax,	%rcx
    mov       %r10,	%r8
    push      %rdx
    xor       %edx,	%edx
    div       %r10
    xchg      %rax,	%rdx
    pop       %rdx
    mov       %rdi,	%rax
    mov       %rax,	%rcx
    mov       %r10,	%r8
    push      %rdx
    xor       %edx,	%edx
    div       %r10
    pop       %rdx
    mov       %rcx,	%rax
    lea       %rax,	[%rip+msys.digits]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%rbp + %r10 + msys.u64tostr.t],	%al
    inc       %r12
    test      %r9,	%r9
    jz        L208
    test      %rcx,	%rcx
    jz        L208
    cmp       %r12,	%r13
    jnz       L208
    inc       %rbx
    mov       %rax,	%rbx
    mov       %r10b,	%r9b
    mov       [%rbp + %rax + msys.u64tostr.t],	%r10b
    xor       %r12,	%r12
L208:
    test      %rcx,	%rcx
    jnz       L204
    mov       %rsi,	%rbx
    mov       %r14,	%rdx
    jmp       L210
L209:
    mov       %rax,	%rbx
    dec       %rbx
    mov       %al,	[%rbp + %rax + msys.u64tostr.t]
    mov       [%rdx],	%al
    inc       %rdx
L210:
    test      %rbx,	%rbx
    jnz       L209
    xor       %eax,	%eax
    mov       [%rdx],	%al
    mov       %rax,	%rsi
L201:
#---------------
    add       %rsp,	368
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.i64tostrfmt
msys.i64tostrfmt:
#?>>
    .set msys.i64tostrfmt.str, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	392
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    xor       %rbx,	%rbx
    mov       %al,	[%r13+11]
    test      %al,	%al
    jz        L214
    mov       %rbx,	1
L214:
    mov       %rax,	%rsi
    mov       %r10,	-9223372036854775808
    cmp       %rax,	%r10
    jnz       L216
    test      %rbx,	%rbx
    jnz       L216
    mov       %al,	45
    mov       [%rbp + msys.i64tostrfmt.str],	%al
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    lea       %r11,	[%rbp + msys.i64tostrfmt.str+1]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      msys.i64mintostr
    inc       %rax
    mov       %rdi,	%rax
    jmp       L215
L216:
    test      %rbx,	%rbx
    jnz       L220
    cmp       %rsi,	0
    jl        L219
L220:
    mov       %al,	[%r13+6]
    test      %al,	%al
    jz        L218
L219:
    cmp       %rsi,	0
    jge       L222
    mov       %rax,	%rsi
    neg       %rax
    mov       %rsi,	%rax
    mov       %al,	45
    mov       [%rbp + msys.i64tostrfmt.str],	%al
    jmp       L221
L222:
    mov       %al,	43
    mov       [%rbp + msys.i64tostrfmt.str],	%al
L221:
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    lea       %r11,	[%rbp + msys.i64tostrfmt.str+1]
    mov       %rcx,	%rsi
    mov       %rdx,	%r11
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    inc       %rax
    mov       %rdi,	%rax
    jmp       L217
L218:
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + msys.i64tostrfmt.str]
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    mov       %rdi,	%rax
L217:
L215:
    mov       %al,	[%r13+10]
    test      %al,	%al
    jz        L224
    mov       %al,	[%r13+10]
    mov       [%rbp + %rdi + msys.i64tostrfmt.str],	%al
    inc       %rdi
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + msys.i64tostrfmt.str],	%r10b
L224:
    movzx     %rax,	byte ptr[%r13+2]
    cmp       %rax,	10
    jg        L227
    mov       %al,	[%r13+10]
    test      %al,	%al
    jz        L226
L227:
    movzx     %rax,	byte ptr[%r13+8]
    cmp       %rax,	97
    jnz       L226
    lea       %rcx,	[%rbp + msys.i64tostrfmt.str]
    call      mlib.convlcstring
L226:
    lea       %rcx,	[%rbp + msys.i64tostrfmt.str]
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    mov       %r9,	%r13
    call      msys.expandstr
L212:
#---------------
    add       %rsp,	392
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.u64tostrfmt
msys.u64tostrfmt:
#?>>
    .set msys.u64tostrfmt.str, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%r12+7]
    movzx     %r10,	byte ptr[%r12+2]
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.u64tostrfmt.str]
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    mov       %rdi,	%rax
    mov       %al,	[%r12+10]
    test      %al,	%al
    jz        L230
    mov       %al,	[%r12+10]
    mov       [%rbp + %rdi + msys.u64tostrfmt.str],	%al
    inc       %rdi
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + msys.u64tostrfmt.str],	%r10b
L230:
    movzx     %rax,	byte ptr[%r12+2]
    cmp       %rax,	10
    jg        L233
    mov       %al,	[%r12+10]
    test      %al,	%al
    jz        L232
    movzx     %rax,	byte ptr[%r12+8]
    cmp       %rax,	97
    jnz       L232
L233:
L232:
    lea       %rcx,	[%rbp + msys.u64tostrfmt.str]
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%r12
    call      msys.expandstr
L228:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.i64mintostr
msys.i64mintostr:
#?>>
    .set msys.i64mintostr.t, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	392
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    mov       %rax,	%r14
    cmp       %rax,	10
    jz        L236
    cmp       %rax,	16
    jz        L237
    cmp       %rax,	2
    jz        L238
    jmp       L239
L236:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10339]
    call      strcpy
    mov       %rbx,	3
    jmp       L235
L237:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10340]
    call      strcpy
    mov       %rbx,	1
    jmp       L235
L238:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10341]
    call      strcpy
    mov       %rbx,	7
    jmp       L235
L239:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10342]
    call      strcpy
L235:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    call      strlen
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    add       %r13,	%rax
    test      %r15,	%r15
    jz        L241
    mov       %rax,	%rbx
    add       %r13,	%rax
L241:
    xor       %eax,	%eax
    mov       [%r13],	%al
    xor       %rsi,	%rsi
    mov       %rax,	%r14
    cmp       %rax,	10
    jnz       L243
    mov       %rax,	3
    jmp       L242
L243:
    mov       %rax,	4
L242:
    mov       %r12,	%rax
    jmp       L245
L244:
    dec       %r13
    mov       %rax,	%rdi
    dec       %rdi
    mov       %al,	[%rbp + %rax + msys.i64mintostr.t-1]
    mov       [%r13],	%al
    test      %r15,	%r15
    jz        L248
    test      %rdi,	%rdi
    jz        L248
    inc       %rsi
    cmp       %rsi,	%r12
    jnz       L248
    dec       %r13
    mov       [%r13],	%r15b
    xor       %rsi,	%rsi
L248:
L245:
    test      %rdi,	%rdi
    jnz       L244
    mov       %rcx,	%r13
    call      strlen
L234:
#---------------
    add       %rsp,	392
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtostrfmt
msys.strtostrfmt:
#?>>
    .set msys.strtostrfmt.n, 80
    .set msys.strtostrfmt.fmt, 88
    .set msys.strtostrfmt.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    xor       %r12,	%r12
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jnz       L252
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+8]
    test      %al,	%al
    jz        L251
L252:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    cmp       %rax,	256
    jge       L254
    lea       %rax,	[%rbp + msys.strtostrfmt.str]
    mov       %rdi,	%rax
    jmp       L253
L254:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    add       %rax,	3
    mov       %r12,	%rax
    mov       %rcx,	%r12
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
L253:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L256
    mov       %rbx,	%rdi
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    mov       [%rbx],	%al
    inc       %rbx
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    test      %rax,	%rax
    jz        L258
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    call      strcpy
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    add       %rbx,	%rax
L258:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    mov       [%rbx],	%al
    inc       %rbx
    xor       %eax,	%eax
    mov       [%rbx],	%al
    mov       %rax,	2
    add       [%rbp + msys.strtostrfmt.n],	%rax
    jmp       L255
L256:
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    call      memcpy
L255:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    movzx     %rax,	byte ptr[%rax+8]
    cmp       %rax,	97
    jz        L260
    cmp       %rax,	65
    jz        L261
    jmp       L262
L260:
    mov       %rcx,	%rdi
    call      mlib.convlcstring
    jmp       L259
L261:
    mov       %rcx,	%rdi
    call      mlib.convucstring
L262:
L259:
    mov       %r13,	%rdi
L251:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    movzx     %rax,	byte ptr[%rax]
    mov       %rsi,	%rax
    cmp       %rsi,	[%rbp + msys.strtostrfmt.n]
    jle       L264
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    mov       %r9,	[%rbp + msys.strtostrfmt.fmt]
    call      msys.expandstr
    mov       [%rbp + msys.strtostrfmt.n],	%rax
    jmp       L263
L264:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    call      memcpy
L263:
    test      %r12,	%r12
    jz        L266
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      mlib.pcm_free
L266:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
L249:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_i64
msys.tostr_i64:
#?>>
    .set msys.tostr_i64.a, 32
    .set msys.tostr_i64.str, -360
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       [%rbp+32],	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+12]
    test      %rax,	%rax
    jz        L269
    cmp       %rax,	77
    jz        L270
    jmp       L271
L269:
    mov       %rcx,	[%rbp + msys.tostr_i64.a]
    lea       %rdx,	[%rbp + msys.tostr_i64.str]
    mov       %r8,	%rbx
    call      msys.i64tostrfmt
    mov       %rdi,	%rax
    jmp       L268
L270:
    lea       %rcx,	[%rbp + msys.tostr_i64.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.tostr_i64.str]
    mov       %r9,	%rbx
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L268
L271:
    mov       %rcx,	[%rbp + msys.tostr_i64.a]
    xor       %edx,	%edx
    call      msys.m$print_c8
    jmp       L267
L268:
    lea       %rcx,	[%rbp + msys.tostr_i64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
L267:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_u64
msys.tostr_u64:
#?>>
    .set msys.tostr_u64.a, 32
    .set msys.tostr_u64.str, -360
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       [%rbp+32],	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+12]
    cmp       %rax,	77
    jz        L274
    cmp       %rax,	67
    jz        L275
    jmp       L276
L274:
    lea       %rcx,	[%rbp + msys.tostr_u64.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.tostr_u64.str]
    mov       %r9,	%rbx
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L273
L275:
    mov       %rcx,	[%rbp + msys.tostr_u64.a]
    xor       %edx,	%edx
    call      msys.m$print_c8
    jmp       L272
L276:
    mov       %rcx,	[%rbp + msys.tostr_u64.a]
    lea       %rdx,	[%rbp + msys.tostr_u64.str]
    mov       %r8,	%rbx
    call      msys.u64tostrfmt
    mov       %rdi,	%rax
L273:
    lea       %rcx,	[%rbp + msys.tostr_u64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
L272:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_r64
msys.tostr_r64:
#?>>
    .set msys.tostr_r64.str, -360
    .set msys.tostr_r64.str2, -720
    .set msys.tostr_r64.cfmt, -736
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	776
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    mov       %al,	37
    mov       [%rbp + msys.tostr_r64.cfmt],	%al
    mov       %al,	[%rbx+1]
    test      %al,	%al
    jz        L279
    mov       %al,	46
    mov       [%rbp + msys.tostr_r64.cfmt+1],	%al
    mov       %al,	42
    mov       [%rbp + msys.tostr_r64.cfmt+2],	%al
    mov       %al,	[%rbx+5]
    mov       [%rbp + msys.tostr_r64.cfmt+3],	%al
    xor       %eax,	%eax
    mov       [%rbp + msys.tostr_r64.cfmt+4],	%al
    movsx     %rax,	byte ptr[%rbx+1]
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.cfmt]
    mov       %r8,	%rax
    movq      %XMM3,	%XMM15
    movq      %r9,	%XMM3
    call      sprintf
    jmp       L278
L279:
    mov       %al,	[%rbx+5]
    mov       [%rbp + msys.tostr_r64.cfmt+1],	%al
    xor       %eax,	%eax
    mov       [%rbp + msys.tostr_r64.cfmt+2],	%al
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.cfmt]
    movq      %XMM2,	%XMM15
    movq      %r8,	%XMM2
    call      sprintf
L278:
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    call      strlen
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rbx]
    mov       %r10,	%rdi
    cmp       %r10,	%rax
    jge       L281
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.str2]
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      msys.expandstr
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.str2]
    call      strcpy
L281:
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
#---------------
    add       %rsp,	776
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_str
msys.tostr_str:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r13,	-1
    jnz       L284
    mov       %rcx,	%r12
    call      strlen
    mov       %r13,	%rax
L284:
    mov       %rdi,	%r13
    mov       %al,	[%r14+3]
    test      %al,	%al
    jnz       L287
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	%rdi
    jg        L287
    mov       %al,	[%r14+8]
    test      %al,	%al
    jnz       L287
    mov       %al,	[%r14+1]
    test      %al,	%al
    jz        L286
L287:
    mov       %al,	[%r14+3]
    test      %al,	%al
    jz        L289
    mov       %rax,	2
    add       %rdi,	%rax
L289:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	%rdi
    jle       L291
    movzx     %rax,	byte ptr[%r14]
    mov       %rdi,	%rax
L291:
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    mov       %r8,	%r13
    mov       %r9,	%r14
    call      msys.strtostrfmt
    mov       %rbx,	%rax
    mov       %al,	[%r14+1]
    test      %al,	%al
    jz        L293
    movsx     %rax,	byte ptr[%r14+1]
    cmp       %rbx,	%rax
    jle       L10343
    mov       %rbx,	%rax
L10343:
L293:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      msys.printstr_n
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mlib.pcm_free
    jmp       L285
L286:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      msys.printstr_n
L285:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getfmt
msys.getfmt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L296
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rip+msys.getfmt.fmt]
    call      msys.strtofmt
    lea       %rax,	[%rip+msys.getfmt.fmt]
    jmp       L295
L296:
    lea       %rax,	[%rip+msys.defaultfmt]
L295:
L294:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.strint
msys.strint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strint.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rsi
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      msys.tostr_i64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strint.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L297:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getstrint
msys.getstrint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startstr
    xor       %ecx,	%ecx
    call      msys.getfmt
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      msys.tostr_i64
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strword
msys.strword:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strword.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rsi
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      msys.tostr_u64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strword.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L299:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strreal
msys.strreal:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strreal.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rbx
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    movq      %XMM0,	%XMM15
    mov       %rdx,	%rax
    call      msys.tostr_r64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strreal.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L300:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getstr
msys.getstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rbx+13]
    test      %al,	%al
    jz        L303
    mov       %rcx,	%rdi
    call      mlib.pcm_copyheapstring
    jmp       L302
L303:
    mov       %rax,	%rdi
L302:
L301:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.initreadbuffer
msys.initreadbuffer:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    test      %rax,	%rax
    jnz       L304
L306:
    mov       %rcx,	16384
    call      mlib.pcm_alloc
    mov       [%rip+msys.rd_buffer],	%rax
    xor       %eax,	%eax
    mov       %r10,	[%rip+msys.rd_buffer]
    mov       [%r10],	%al
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_lastpos],	%rax
    mov       [%rip+msys.rd_pos],	%rax
L304:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$read_conline
msys.m$read_conline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.initreadbuffer
    xor       %ecx,	%ecx
    mov       %rdx,	[%rip+msys.rd_buffer]
    mov       %r8,	16384
    call      mlib.readlinen
    mov       %rcx,	[%rip+msys.rd_buffer]
    call      strlen
    mov       [%rip+msys.rd_length],	%rax
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$read_fileline
msys.m$read_fileline:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.initreadbuffer
    cmp       %rdi,	1
    jnz       L310
    lea       %rcx,	[%rip+L10344]
    call      mlib.abortprogram
    jmp       L308
L310:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rip+msys.rd_buffer]
    mov       %r8,	16384
    call      mlib.readlinen
    mov       %rcx,	[%rip+msys.rd_buffer]
    call      strlen
    mov       [%rip+msys.rd_length],	%rax
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
L308:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_strline
msys.m$read_strline:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      msys.initreadbuffer
    mov       %rcx,	%rbx
    call      strlen
    mov       %rdi,	%rax
    cmp       %rdi,	16384
    jge       L313
    mov       %rcx,	[%rip+msys.rd_buffer]
    mov       %rdx,	%rbx
    call      strcpy
    jmp       L312
L313:
    mov       %rcx,	[%rip+msys.rd_buffer]
    mov       %rdx,	%rbx
    mov       %r8,	16383
    call      memcpy
    mov       %rax,	[%rip+msys.rd_buffer]
    lea       %rax,	[%rax+16384]
    sub       %rax,	1
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
L312:
    mov       [%rip+msys.rd_length],	%rdi
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.readitem
msys.readitem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    test      %rax,	%rax
    jnz       L316
    call      msys.initreadbuffer
L316:
    mov       %rbx,	[%rip+msys.rd_pos]
    jmp       L318
L317:
    inc       %rbx
L318:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	32
    jz        L317
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	9
    jz        L317
    mov       %rsi,	%rbx
    mov       %rax,	%rbx
    mov       [%rip+msys.rd_pos],	%rax
    mov       [%rip+msys.rd_lastpos],	%rax
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L321
    xor       %eax,	%eax
    mov       [%rip+msys.termchar],	%rax
    xor       %eax,	%eax
    mov       [%r14],	%rax
    mov       %rax,	%rbx
    jmp       L314
L321:
    xor       %r12b,	%r12b
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	34
    jnz       L323
    mov       %r12b,	34
    inc       %rbx
    jmp       L322
L323:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	39
    jnz       L324
    mov       %r12b,	39
    inc       %rbx
L324:
L322:
    mov       %rax,	%rbx
    mov       %rsi,	%rax
    mov       %rdi,	%rax
    jmp       L326
L325:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r13b,	[%rax]
    movzx     %rax,	%r13b
    cmp       %rax,	32
    jz        L329
    cmp       %rax,	9
    jz        L329
    cmp       %rax,	44
    jz        L329
    cmp       %rax,	61
    jnz       L330
L329:
    test      %r12b,	%r12b
    jnz       L333
    cmp       %rdi,	%rbx
    jnz       L332
L333:
    jmp       L334
L332:
    movzx     %rax,	%r13b
    mov       [%rip+msys.termchar],	%rax
    jmp       L327
L330:
#msys.readitem.normalchar:
L334:
    movzx     %rax,	%r13b
    movzx     %r10,	%r12b
    cmp       %rax,	%r10
    jnz       L336
    movzx     %rax,	byte ptr[%rbx]
    movzx     %r10,	%r12b
    cmp       %rax,	%r10
    jnz       L338
    mov       [%rdi],	%r13b
    inc       %rbx
    inc       %rdi
    jmp       L337
L338:
    movzx     %rax,	byte ptr[%rbx]
    mov       [%rip+msys.termchar],	%rax
    mov       %rax,	[%rip+msys.termchar]
    cmp       %rax,	44
    jz        L341
    cmp       %rax,	61
    jnz       L340
L341:
    inc       %rbx
    movzx     %rax,	byte ptr[%rbx]
    mov       [%rip+msys.termchar],	%rax
L340:
    jmp       L327
L337:
    jmp       L335
L336:
    mov       [%rdi],	%r13b
    inc       %rdi
L335:
L328:
L326:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L325
L327:
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L343
    xor       %eax,	%eax
    mov       [%rip+msys.termchar],	%rax
L343:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    mov       [%r14],	%rax
    mov       [%rip+msys.rd_pos],	%rbx
    mov       %rax,	%rsi
L314:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtoint
msys.strtoint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    cmp       %r14,	-1
    jnz       L346
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L346:
    xor       %dil,	%dil
    mov       %rax,	%r14
    test      %rax,	%rax
    jz        L348
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	45
    jnz       L348
    mov       %dil,	1
    inc       %r13
    dec       %r14
    jmp       L347
L348:
    test      %r14,	%r14
    jz        L349
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	43
    jnz       L349
    inc       %r13
    dec       %r14
L349:
L347:
    xor       %rbx,	%rbx
    jmp       L351
L350:
    mov       %rax,	%r13
    inc       %r13
    movzx     %rax,	byte ptr[%rax]
    mov       %rsi,	%rax
    dec       %r14
    mov       %rax,	%rsi
    cmp       %rax,	65
    jl        L354
    cmp       %rax,	70
    jg        L354
    lea       %rax,	[%rsi-65]
    add       %rax,	10
    mov       %r12,	%rax
    jmp       L353
L354:
    mov       %rax,	%rsi
    cmp       %rax,	97
    jl        L355
    cmp       %rax,	102
    jg        L355
    lea       %rax,	[%rsi-97]
    add       %rax,	10
    mov       %r12,	%rax
    jmp       L353
L355:
    mov       %rax,	%rsi
    cmp       %rax,	48
    jl        L356
    cmp       %rax,	57
    jg        L356
    lea       %rax,	[%rsi-48]
    mov       %r12,	%rax
    jmp       L353
L356:
    mov       %rax,	%rsi
    cmp       %rax,	95
    jz        L358
    cmp       %rax,	39
    jnz       L357
L358:
    jmp       L351
L357:
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
    jmp       L352
L353:
    cmp       %r12,	%r15
    jb        L360
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
    jmp       L352
L360:
    mov       %rax,	%rbx
    mov       %r10,	%r15
    imul      %rax,	%r10
    add       %rax,	%r12
    mov       %rbx,	%rax
L351:
    test      %r14,	%r14
    jnz       L350
L352:
    test      %dil,	%dil
    jz        L362
    mov       %rax,	%rbx
    neg       %rax
    jmp       L361
L362:
    mov       %rax,	%rbx
L361:
L344:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_i64
msys.m$read_i64:
#?>>
    .set msys.m$read_i64.length, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      toupper
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    mov       %rax,	%rbx
    cmp       %rax,	67
    jz        L365
    cmp       %rax,	84
    jz        L366
    cmp       %rax,	69
    jz        L367
    jmp       L368
L365:
    mov       %rax,	[%rip+msys.rd_pos]
    mov       [%rip+msys.rd_lastpos],	%rax
    mov       %rax,	[%rip+msys.rd_pos]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L370
    mov       %rax,	[%rip+msys.rd_pos]
    inc       qword ptr[%rip+msys.rd_pos]
    movzx     %rax,	byte ptr[%rax]
    jmp       L363
L370:
    xor       %eax,	%eax
    jmp       L363
L369:
    jmp       L364
L366:
    mov       %rax,	[%rip+msys.termchar]
    jmp       L363
L367:
    mov       %rax,	[%rip+msys.itemerror]
    jmp       L363
L368:
L364:
    lea       %rcx,	[%rbp + msys.m$read_i64.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    test      %rax,	%rax
    jz        L372
    cmp       %rax,	73
    jz        L372
    cmp       %rax,	66
    jz        L373
    cmp       %rax,	72
    jz        L374
    jmp       L375
L372:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	10
    call      msys.strtoint
    jmp       L363
L373:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	2
    call      msys.strtoint
    jmp       L363
L374:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	16
    call      msys.strtoint
    jmp       L363
L375:
L371:
    xor       %eax,	%eax
L363:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_r64
msys.m$read_r64:
#?>>
    .set msys.m$read_r64.fmt, 24
    .set msys.m$read_r64.str, -512
    .set msys.m$read_r64.length, -520
    .set msys.m$read_r64.numlength, -528
    .set msys.m$read_r64.x, -536
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	568
#---------------
    lea       %rcx,	[%rbp + msys.m$read_r64.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + msys.m$read_r64.length]
    test      %rax,	%rax
    jz        L379
    mov       %rax,	[%rbp + msys.m$read_r64.length]
    cmp       %rax,	512
    jl        L378
L379:
    movq      %XMM0,	[%rip+L10345]
    jmp       L376
L378:
    lea       %rcx,	[%rbp + msys.m$read_r64.str]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + msys.m$read_r64.length]
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.m$read_r64.length]
    mov       [%rbp + %r10 + msys.m$read_r64.str],	%al
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    lea       %rcx,	[%rbp + msys.m$read_r64.str]
    lea       %rdx,	[%rip+L10346]
    lea       %r8,	[%rbp + msys.m$read_r64.x]
    lea       %r9,	[%rbp + msys.m$read_r64.numlength]
    call      sscanf
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jz        L382
    movsxd    %rax,	dword ptr[%rbp + msys.m$read_r64.numlength]
    cmp       %rax,	[%rbp + msys.m$read_r64.length]
    jz        L381
L382:
    movq      %XMM4,	[%rip+L10347]
    movq      [%rbp + msys.m$read_r64.x],	%XMM4
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
L381:
    movq      %XMM0,	[%rbp + msys.m$read_r64.x]
L376:
#---------------
    add       %rsp,	568
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_str
msys.m$read_str:
#?>>
    .set msys.m$read_str.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    mov       %rax,	%r12
    cmp       %rax,	76
    jz        L386
    cmp       %rax,	108
    jnz       L385
L386:
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       %r10,	[%rip+msys.rd_length]
    lea       %rax,	[%rax + %r10]
    sub       %rax,	[%rip+msys.rd_pos]
    mov       [%rbp + msys.m$read_str.length],	%rax
    jmp       L384
L385:
    lea       %rcx,	[%rbp + msys.m$read_str.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	%r12
    cmp       %rax,	78
    jz        L389
    cmp       %rax,	110
    jnz       L388
L389:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_str.length]
    call      mlib.iconvlcn
L388:
L384:
    cmp       %rsi,	0
    jle       L391
    mov       %rax,	[%rbp + msys.m$read_str.length]
    cmp       %rax,	%rsi
    jl        L393
    lea       %rax,	[%rsi-1]
    mov       [%rbp + msys.m$read_str.length],	%rax
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
L393:
L391:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + msys.m$read_str.length]
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.m$read_str.length]
    mov       [%rbx + %r10],	%al
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.readstr
msys.readstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      msys.m$read_str
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.rereadln
msys.rereadln:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    mov       %rax,	[%rip+msys.rd_pos]
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    ret       
# End 
# Proc msys.reread
msys.reread:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%rax
#---------------
    ret       
# End 
# Proc msys.valint
msys.valint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    call      msys.initreadbuffer
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rbx,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%r12
    mov       %rcx,	%r13
    call      msys.m$read_i64
    mov       %rsi,	%rax
    mov       [%rip+msys.rd_pos],	%rdi
    mov       [%rip+msys.rd_lastpos],	%rbx
    mov       %rax,	%rsi
L397:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.valreal
msys.valreal:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    call      msys.initreadbuffer
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rbx,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%rsi
    xor       %ecx,	%ecx
    call      msys.m$read_r64
    movq      %XMM15,	%XMM0
    mov       [%rip+msys.rd_pos],	%rdi
    mov       [%rip+msys.rd_lastpos],	%rbx
    movq      %XMM0,	%XMM15
L398:
#---------------
    add       %rsp,	40
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.mclunimpl
msys.mclunimpl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    lea       %rcx,	[%rip+L10348]
    mov       %rdx,	%rdi
    call      printf
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.dumpstr
msys.dumpstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	3
    jnz       L402
    mov       %rdi,	[%rip+msys.outchan]
    test      %rsi,	%rsi
    jz        L404
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rdi
    mov       %r10,	%rsi
    add       [%rax],	%r10
L404:
    mov       %rax,	[%rdi]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    jmp       L400
L402:
    test      %rsi,	%rsi
    jnz       L406
    jmp       L400
L406:
    test      %r12,	%r12
    jz        L408
    cmp       %rsi,	2
    jl        L408
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jnz       L408
    dec       qword ptr[%rip+msys.printptr]
    mov       %rax,	[%rip+msys.printptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jnz       L410
    mov       %rax,	[%rip+msys.printptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jnz       L412
    mov       %rax,	[%rip+msys.printptr]
    sub       %rax,	1
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    jmp       L411
L412:
    xor       %eax,	%eax
    mov       %r10,	[%rip+msys.printptr]
    mov       [%r10],	%al
L411:
    lea       %rcx,	[%rip+msys.printbuffer]
    call      puts
    jmp       L400
L410:
L408:
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jz        L414
    cmp       %rax,	2
    jz        L415
    jmp       L416
L414:
    lea       %rcx,	[%rip+L10349]
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      printf
    jmp       L413
L415:
    mov       %rcx,	[%rip+msys.outchan]
    lea       %rdx,	[%rip+L10349]
    mov       %r8,	%rsi
    mov       %r9,	%rbx
    call      fprintf
L416:
L413:
L400:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.dumpprintbuffer
msys.dumpprintbuffer:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.printlen]
    test      %rax,	%rax
    jz        L419
    lea       %rcx,	[%rip+msys.printbuffer]
    mov       %rdx,	[%rip+msys.printlen]
    mov       %r8,	1
    call      msys.dumpstr
L419:
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.resetprintbuffer
msys.resetprintbuffer:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+msys.printbuffer]
    mov       [%rip+msys.printptr],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.printlen],	%rax
#---------------
    ret       
# End 
# Proc msys.addtobuffer
msys.addtobuffer:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rip+msys.printlen]
    add       %rax,	%rbx
    cmp       %rax,	4088
    jl        L423
    call      msys.dumpprintbuffer
L423:
    cmp       %rbx,	4096
    jge       L425
    mov       %rcx,	[%rip+msys.printptr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rbx
    add       [%rip+msys.printptr],	%rax
    mov       %rax,	%rbx
    add       [%rip+msys.printlen],	%rax
    jmp       L421
L425:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      msys.dumpstr
L421:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$power_i64
msys.m$power_i64:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    cmp       %rbx,	0
    jge       L428
    xor       %eax,	%eax
    jmp       L427
L428:
    test      %rbx,	%rbx
    jnz       L429
    mov       %rax,	1
    jmp       L427
L429:
    cmp       %rbx,	1
    jnz       L430
    mov       %rax,	%rdi
    jmp       L427
L430:
    mov       %rax,	%rbx
    and       %rax,	1
    jnz       L431
    mov       %rax,	%rbx
    sar       %rax,	1
    mov       %r10,	%rdi
    imul      %r10,	%r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      msys.m$power_i64
    jmp       L427
L431:
    lea       %rax,	[%rbx-1]
    sar       %rax,	1
    mov       %r10,	%rdi
    imul      %r10,	%r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      msys.m$power_i64
    mov       %r10,	%rdi
    imul      %rax,	%r10
L427:
L426:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getutfsize
msys.getutfsize:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	%rcx
    inc       %rcx
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L434
    xor       %eax,	%eax
    jmp       L433
L434:
    mov       %eax,	%edi
    shr       %eax,	7
    and       %eax,	1
    test      %rax,	%rax
    jnz       L435
    mov       %rax,	1
    jmp       L433
L435:
    mov       %rax,	%rdi
    shr       %rax,	5
    and       %rax,	7
    cmp       %rax,	6
    jnz       L436
    mov       %rax,	2
    jmp       L433
L436:
    mov       %rax,	%rdi
    shr       %rax,	4
    and       %rax,	15
    cmp       %rax,	14
    jnz       L437
    mov       %rax,	3
    jmp       L433
L437:
    mov       %rax,	%rdi
    shr       %rax,	3
    and       %rax,	31
    cmp       %rax,	30
    jnz       L438
    mov       %rax,	4
    jmp       L433
L438:
    mov       %rax,	1
L433:
L432:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_alloc
mlib.pcm_alloc:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	[%rip+mlib.pcm_setup]
    test      %al,	%al
    jnz       L441
    call      mlib.pcm_init
L441:
    cmp       %rbx,	2048
    jle       L443
    mov       %rcx,	%rbx
    call      mlib.pcm_getac
    mov       [%rip+mlib.alloccode],	%rax
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+mlib.allocbytes],	%rax
    mov       %rcx,	[%rip+mlib.allocbytes]
    call      mlib.allocmem
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L445
    lea       %rcx,	[%rip+L10350]
    call      mlib.abortprogram
L445:
    mov       %rax,	%rdi
    jmp       L439
L443:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       [%rip+mlib.alloccode],	%rax
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+mlib.allocbytes],	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L447
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+mlib.freelist]
    mov       %r11,	[%rip+mlib.alloccode]
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
    jmp       L439
L447:
    mov       %rdi,	[%rip+mlib.pcheapptr]
    mov       %rax,	[%rip+mlib.allocbytes]
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	[%rip+mlib.pcheapptr]
    cmp       %rax,	[%rip+mlib.pcheapend]
    jb        L449
    mov       %rcx,	[%rip+mlib.allocbytes]
    call      mlib.pcm_newblock
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    jmp       L439
L449:
    mov       %rax,	%rdi
L439:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_free
mlib.pcm_free:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rsi,	%rsi
    jz        L453
    test      %rbx,	%rbx
    jnz       L452
L453:
    jmp       L450
L452:
    cmp       %rsi,	2048
    jle       L455
    mov       %rcx,	%rbx
    call      free
    jmp       L454
L455:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbx],	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mlib.freelist]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
L454:
L450:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_freeac
mlib.pcm_freeac:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_clearmem
mlib.pcm_clearmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      memset
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_init
mlib.pcm_init:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    xor       %eax,	%eax
    mov       [%rip+mlib.alloccode],	%rax
    mov       %al,	[%rip+mlib.pcm_setup]
    test      %al,	%al
    jnz       L458
L460:
    xor       %ecx,	%ecx
    call      mlib.pcm_newblock
    mov       %r13,	1
L461:
    mov       %rdi,	1
    mov       %rbx,	16
    jmp       L465
L464:
    mov       %rax,	%rbx
    shl       %rax,	1
    mov       %rbx,	%rax
    inc       %rdi
L465:
    cmp       %r13,	%rbx
    jg        L464
    mov       %al,	%dil
    lea       %r10,	[%rip+mlib.sizeindextable]
    mov       %r11,	%r13
    mov       [%r10 + %r11],	%al
    inc       %r13
    cmp       %r13,	2048
    jle       L461
    mov       %rax,	16
    lea       %r10,	[%rip+mlib.allocupper]
    mov       [%r10+8],	%rax
    mov       %rsi,	16
    mov       %r13,	2
L467:
    mov       %rax,	%rsi
    shl       %rax,	1
    mov       %rsi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mlib.allocupper]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    cmp       %rsi,	33554432
    jl        L471
    mov       %rbx,	%r13
    jmp       L469
L471:
    inc       %r13
    cmp       %r13,	27
    jle       L467
L469:
    lea       %rax,	[%rbx+1]
    mov       %r13,	%rax
    mov       %r12,	300
    cmp       %r13,	%r12
    jg        L474
L472:
    mov       %rax,	33554432
    add       %rsi,	%rax
    mov       %rax,	%rsi
    mov       %r10,	8589934592
    cmp       %rax,	%r10
    jge       L476
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mlib.allocupper]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    mov       [%rip+mlib.maxmemory],	%rsi
    jmp       L475
L476:
    lea       %rax,	[%r13-1]
    mov       [%rip+mlib.maxalloccode],	%rax
    jmp       L474
L475:
    inc       %r13
    cmp       %r13,	%r12
    jle       L472
L474:
    mov       %al,	1
    mov       [%rip+mlib.pcm_setup],	%al
L458:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_getac
mlib.pcm_getac:
#?>>
#?]]
#---------------
    cmp       %rcx,	2048
    jg        L479
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    jmp       L477
L479:
    lea       %rax,	[%rcx+255]
    sar       %rax,	8
    mov       %rcx,	%rax
    cmp       %rcx,	2048
    jg        L481
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    add       %rax,	8
    jmp       L477
L481:
    lea       %rax,	[%rcx+63]
    sar       %rax,	6
    mov       %rcx,	%rax
    cmp       %rcx,	2048
    jg        L483
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    add       %rax,	14
    jmp       L477
L483:
    lea       %rax,	[%rcx-2048]
    add       %rax,	2047
    sar       %rax,	11
    add       %rax,	22
    mov       %rcx,	%rax
    mov       %rax,	%rcx
L477:
#---------------
    ret       
# End 
# Proc mlib.pcm_newblock
mlib.pcm_newblock:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	2097152
    add       [%rip+mlib.pcm_newblock.totalheapsize],	%rax
    xor       %eax,	%eax
    mov       [%rip+mlib.alloccode],	%rax
    mov       %rcx,	2097152
    call      mlib.allocmem
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L486
    lea       %rcx,	[%rip+L10351]
    call      mlib.abortprogram
L486:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	2097152
    call      memset
    mov       [%rip+mlib.pcheapptr],	%rdi
    lea       %rax,	[%rdi+2097152]
    mov       [%rip+mlib.pcheapend],	%rax
    mov       %rax,	[%rip+mlib.pcheapstart]
    test      %rax,	%rax
    jnz       L488
    mov       [%rip+mlib.pcheapstart],	%rdi
L488:
    mov       %rax,	%rbx
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	%rdi
L484:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_round
mlib.pcm_round:
#?>>
#?]]
#---------------
    cmp       %rcx,	2048
    jle       L491
    mov       %rax,	%rcx
    jmp       L490
L491:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rip+mlib.pcm_round.allocbytes]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       %rax,	%r10
L490:
L489:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocz
mlib.pcm_allocz:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      memset
    mov       %rax,	%rdi
L492:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstring
mlib.pcm_copyheapstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L495
    xor       %eax,	%eax
    jmp       L493
L495:
    mov       %rcx,	%rsi
    call      strlen
    inc       %rax
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rdi
L493:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstringn
mlib.pcm_copyheapstringn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L498
    xor       %eax,	%eax
    jmp       L496
L498:
    lea       %rax,	[%rsi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    xor       %eax,	%eax
    mov       [%rdi + %rsi],	%al
    mov       %rax,	%rdi
L496:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapblock
mlib.pcm_copyheapblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rsi,	%rsi
    jnz       L501
    xor       %eax,	%eax
    jmp       L499
L501:
    mov       %rcx,	%rsi
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rdi
L499:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.allocmem
mlib.allocmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      malloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L504
    mov       %rax,	%rdi
    jmp       L502
L504:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+mlib.memtotal]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10352]
    call      mlib.abortprogram
    xor       %eax,	%eax
L502:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.reallocmem
mlib.reallocmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      realloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L507
    mov       %rax,	%rdi
    jmp       L505
L507:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10353]
    call      mlib.abortprogram
    xor       %eax,	%eax
L505:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.abortprogram
mlib.abortprogram:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10354]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	5
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.getfilesize
mlib.getfilesize:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      ftell
    mov       %edi,	%eax
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    mov       %r8,	2
    call      fseek
    mov       %rcx,	%rsi
    call      ftell
    mov       %ebx,	%eax
    mov       %eax,	%edi
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      fseek
    mov       %eax,	%ebx
L509:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readrandom
mlib.readrandom:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      fseek
    mov       %rcx,	%rsi
    mov       %rdx,	1
    mov       %r8,	%r13
    mov       %r9,	%rbx
    call      fread
    mov       %rdi,	%rax
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.writerandom
mlib.writerandom:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      fseek
    mov       %rcx,	%rbx
    mov       %rdx,	1
    mov       %r8,	%r12
    mov       %r9,	%rdi
    call      fwrite
L511:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.setfilepos
mlib.setfilepos:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      fseek
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L512:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.getfilepos
mlib.getfilepos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      ftell
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L513:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.readfile
mlib.readfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L10355]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L516
    xor       %eax,	%eax
    jmp       L514
L516:
    mov       %rcx,	%rdi
    call      mlib.getfilesize
    mov       %rbx,	%rax
    mov       [%rip+mlib.rfsize],	%rax
    lea       %rax,	[%rbx+2]
    mov       %rcx,	%rax
    call      malloc
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L518
    xor       %eax,	%eax
    jmp       L514
L518:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    mov       %r9,	%rbx
    call      mlib.readrandom
    lea       %rax,	[%rsi + %rbx]
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%r12],	%ax
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	%rsi
L514:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.writefile
mlib.writefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L10356]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L521
    xor       %eax,	%eax
    jmp       L519
L521:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    mov       %r9,	%r13
    call      mlib.writerandom
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	%rbx
L519:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.checkfile
mlib.checkfile:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10357]
    call      fopen
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L524
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	1
    jmp       L522
L524:
    xor       %eax,	%eax
L522:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readlinen
mlib.readlinen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    test      %r13,	%r13
    jnz       L527
    call      mwindows.os_getstdin
    mov       %r13,	%rax
L527:
    test      %r13,	%r13
    jnz       L529
    xor       %rsi,	%rsi
    mov       %rax,	%r14
    mov       %rbx,	%rax
L530:
    call      getchar
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %rdi,	13
    jz        L534
    cmp       %rdi,	10
    jz        L534
    cmp       %rdi,	-1
    jnz       L533
L534:
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L525
L533:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    inc       %rsi
    lea       %rax,	[%r15-2]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jl        L536
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L525
L536:
    jmp       L530
L529:
    xor       %eax,	%eax
    mov       [%r14],	%al
    lea       %rax,	[%r15-2]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	%r13
    call      fgets
    test      %rax,	%rax
    jz        L525
L538:
    mov       %rcx,	%r14
    call      strlen
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L540
    jmp       L525
L540:
    lea       %rax,	[%r14 + %rsi]
    sub       %rax,	1
    mov       %rbx,	%rax
    xor       %r12b,	%r12b
    jmp       L542
L541:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	13
    jz        L546
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	10
    jnz       L545
L546:
    mov       %r12b,	1
L545:
    mov       %rax,	%rbx
    dec       %rbx
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
L542:
    cmp       %rbx,	%r14
    jb        L547
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	13
    jz        L541
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	10
    jz        L541
L547:
    test      %r12b,	%r12b
    jnz       L549
    lea       %rax,	[%rsi+4]
    cmp       %rax,	%r15
    jle       L549
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    call      msys.m$print_i64_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10358]
    call      mlib.abortprogram
L549:
L525:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.iconvlcn
mlib.iconvlcn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	%rsi
    cmp       %rdi,	0
    jle       L553
L551:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      tolower
    mov       [%rbx],	%al
    inc       %rbx
    dec       %rdi
    jnz       L551
L553:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.iconvucn
mlib.iconvucn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	%rsi
    cmp       %rdi,	0
    jle       L557
L555:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      toupper
    mov       [%rbx],	%al
    inc       %rbx
    dec       %rdi
    jnz       L555
L557:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.convlcstring
mlib.convlcstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	%rbx
    jmp       L560
L559:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      tolower
    mov       [%rbx],	%al
    inc       %rbx
L560:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L559
    mov       %rax,	%rdi
L558:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.convucstring
mlib.convucstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	%rbx
    jmp       L564
L563:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      toupper
    mov       [%rbx],	%al
    inc       %rbx
L564:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L563
    mov       %rax,	%rdi
L562:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.changeext
mlib.changeext:
#?>>
    .set mlib.changeext.newext2, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      strcpy
    movzx     %rax,	byte ptr[%r12]
    test      %rax,	%rax
    jz        L568
    cmp       %rax,	46
    jz        L569
    jmp       L570
L568:
    xor       %eax,	%eax
    mov       [%rbp + mlib.changeext.newext2],	%al
    xor       %eax,	%eax
    mov       [%rbp + mlib.changeext.newext2+1],	%al
    jmp       L567
L569:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      strcpy
    jmp       L567
L570:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10359]
    call      strcpy
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      strcat
L567:
    mov       %rcx,	%rsi
    mov       %rdx,	1
    call      mlib.extractext
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L572
    cmp       %rax,	46
    jz        L573
    jmp       L574
L572:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcat
    jmp       L571
L573:
    lea       %rax,	[%rbp + mlib.changeext.newext2+1]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcat
    jmp       L571
L574:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    sub       %rax,	2
    mov       %rbx,	%rax
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %r11,	%rbx
    lea       %r10,	[%r10 + %r11+1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcpy
L571:
    lea       %rax,	[%rip+mlib.changeext.newfile]
L566:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractext
mlib.extractext:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    call      mlib.extractfile
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L577
    lea       %rax,	[%rip+L10360]
    jmp       L575
L577:
    mov       %rcx,	%rdi
    call      strlen
    lea       %r10,	[%rdi + %rax]
    sub       %r10,	1
    mov       %rbx,	%r10
    jmp       L579
L578:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	46
    jnz       L582
    movzx     %rax,	byte ptr[%rbx+1]
    test      %rax,	%rax
    jnz       L584
    test      %r12,	%r12
    jz        L586
    lea       %rax,	[%rip+L10361]
    jmp       L585
L586:
    lea       %rax,	[%rip+L10362]
L585:
    jmp       L575
L584:
    lea       %rax,	[%rbx+1]
    jmp       L575
L582:
    dec       %rbx
L579:
    cmp       %rbx,	%rdi
    jae       L578
    lea       %rax,	[%rip+L10362]
L575:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractpath
mlib.extractpath:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      strlen
    lea       %r10,	[%rsi + %rax]
    sub       %r10,	1
    mov       %rdi,	%r10
    jmp       L589
L588:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	92
    jz        L592
    cmp       %rax,	47
    jz        L592
    cmp       %rax,	58
    jnz       L593
L592:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    inc       %rax
    mov       %rbx,	%rax
    lea       %rcx,	[%rip+mlib.extractpath.str]
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractpath.str]
    mov       %r11,	%rbx
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.extractpath.str]
    jmp       L587
L593:
L591:
    dec       %rdi
L589:
    cmp       %rdi,	%rsi
    jae       L588
    lea       %rax,	[%rip+L10362]
L587:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractfile
mlib.extractfile:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mlib.extractpath
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L596
    mov       %rax,	%rbx
    jmp       L594
L596:
    mov       %rcx,	%rdi
    call      strlen
    lea       %r10,	[%rbx + %rax]
    mov       %rax,	%r10
L594:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractbasefile
mlib.extractbasefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	%r13
    call      mlib.extractfile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      strlen
    mov       %r12,	%rax
    test      %r12,	%r12
    jnz       L599
    lea       %rax,	[%rip+L10362]
    jmp       L597
L599:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mlib.extractext
    mov       %rbx,	%rax
    mov       %al,	[%rbx]
    test      %al,	%al
    jz        L601
    mov       %rcx,	%rbx
    call      strlen
    mov       %r10,	%r12
    sub       %r10,	%rax
    dec       %r10
    mov       %rsi,	%r10
    lea       %rcx,	[%rip+mlib.extractbasefile.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractbasefile.str]
    mov       %r11,	%rsi
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.extractbasefile.str]
    jmp       L597
L601:
    lea       %rax,	[%rdi + %r12]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L603
    lea       %rax,	[%r12-1]
    lea       %rcx,	[%rip+mlib.extractbasefile.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractbasefile.str]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    lea       %rax,	[%rip+mlib.extractbasefile.str]
    jmp       L597
L603:
    mov       %rax,	%rdi
L597:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.addext
mlib.addext:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mlib.extractext
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L606
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mlib.changeext
    jmp       L604
L606:
    mov       %rax,	%rbx
L604:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_alloc32
mlib.pcm_alloc32:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	32
    mov       [%rip+mlib.allocbytes],	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L609
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+mlib.freelist]
    mov       [%r10+16],	%rax
    mov       %rax,	%rdi
    jmp       L607
L609:
    mov       %rcx,	32
    call      mlib.pcm_alloc
L607:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_free32
mlib.pcm_free32:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       [%rcx],	%rax
    mov       %rax,	%rcx
    lea       %r10,	[%rip+mlib.freelist]
    mov       [%r10+16],	%rax
#---------------
    ret       
# End 
# Proc mlib.outbyte
mlib.outbyte:
#?>>
    .set mlib.outbyte.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outbyte.x]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu16
mlib.outu16:
#?>>
    .set mlib.outu16.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu16.x]
    mov       %rdx,	2
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu32
mlib.outu32:
#?>>
    .set mlib.outu32.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu32.x]
    mov       %rdx,	4
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu64
mlib.outu64:
#?>>
    .set mlib.outu64.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu64.x]
    mov       %rdx,	8
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outstring
mlib.outstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      strlen
    inc       %rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.outblock
mlib.outblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.myeof
mlib.myeof:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      fgetc
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %rdi,	-1
    jnz       L619
    mov       %rax,	1
    jmp       L617
L619:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      ungetc
    xor       %eax,	%eax
L617:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.strbuffer_add
mlib.strbuffer_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L622
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L622:
    movsxd    %rax,	dword ptr[%r12+8]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L624
    lea       %rax,	[%r14+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%r12],	%rax
    mov       %eax,	[%rip+mlib.allocbytes]
    mov       [%r12+12],	%eax
    mov       [%r12+8],	%r14d
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    mov       %rax,	[%r12]
    xor       %r10d,	%r10d
    mov       %r11,	%r14
    mov       [%rax + %r11],	%r10b
    jmp       L620
L624:
    mov       %rax,	%rbx
    add       %rax,	%r14
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+1]
    movsxd    %r10,	dword ptr[%r12+12]
    cmp       %rax,	%r10
    jle       L626
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      memcpy
    mov       [%r12],	%rsi
    mov       %eax,	[%rip+mlib.allocbytes]
    mov       [%r12+12],	%eax
L626:
    mov       %rax,	[%r12]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    mov       %rax,	[%r12]
    xor       %r10d,	%r10d
    mov       %r11,	%rdi
    mov       [%rax + %r11],	%r10b
    mov       [%r12+8],	%edi
L620:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_init
mlib.gs_init:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	16
    call      mlib.pcm_clearmem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_free
mlib.gs_free:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %eax,	[%rdi+12]
    test      %eax,	%eax
    jz        L630
    movsxd    %rax,	dword ptr[%rdi+12]
    mov       %r10,	[%rdi]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mlib.pcm_free
L630:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_str
mlib.gs_str:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_char
mlib.gs_char:
#?>>
    .set mlib.gs_char.s, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       [%rbp + mlib.gs_char.s],	%bl
    xor       %eax,	%eax
    mov       [%rbp + mlib.gs_char.s+1],	%al
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + mlib.gs_char.s]
    mov       %r8,	1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strn
mlib.gs_strn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strvar
mlib.gs_strvar:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rbx]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strint
mlib.gs_strint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strln
mlib.gs_strln:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_str
    mov       %rcx,	%rdi
    call      mlib.gs_line
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strsp
mlib.gs_strsp:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10363]
    call      mlib.gs_str
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_line
mlib.gs_line:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10364]
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_getcol
mlib.gs_getcol:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+8]
L639:
#---------------
    ret       
# End 
# Proc mlib.gs_leftstr
mlib.gs_leftstr:
#?>>
    .set mlib.gs_leftstr.w, 80
    .set mlib.gs_leftstr.padch, 88
    .set mlib.gs_leftstr.str, -2560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2592
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r13+8]
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + mlib.gs_leftstr.str]
    mov       %rdx,	%r14
    call      strcpy
    mov       %rcx,	%r14
    call      strlen
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mlib.gs_leftstr.w]
    sub       %rax,	%r12
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L642
    mov       %rbx,	1
    cmp       %rsi,	1
    jl        L645
L643:
    mov       %rax,	%r12
    add       %rax,	%rbx
    mov       %r10b,	[%rbp + mlib.gs_leftstr.padch]
    mov       [%rbp + %rax + mlib.gs_leftstr.str-1],	%r10b
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L643
L645:
    mov       %rax,	%r12
    add       %rax,	%rsi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mlib.gs_leftstr.str],	%r10b
L642:
    mov       %rcx,	%r13
    lea       %rdx,	[%rbp + mlib.gs_leftstr.str]
    call      mlib.gs_str
#---------------
    add       %rsp,	2592
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_leftint
mlib.gs_leftint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      mlib.gs_leftstr
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_padto
mlib.gs_padto:
#?>>
    .set mlib.gs_padto.str, -2560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2600
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movsxd    %rax,	dword ptr[%rsi+8]
    mov       %r10,	%r12
    sub       %r10,	%rax
    mov       %rdi,	%r10
    cmp       %rdi,	0
    jle       L647
L649:
    mov       %rbx,	1
    cmp       %rdi,	1
    jl        L652
L650:
    mov       [%rbp + %rbx + mlib.gs_padto.str-1],	%r13b
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L650
L652:
    xor       %eax,	%eax
    mov       [%rbp + %rdi + mlib.gs_padto.str],	%al
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + mlib.gs_padto.str]
    call      mlib.gs_str
L647:
#---------------
    add       %rsp,	2600
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_println
mlib.gs_println:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+8]
    test      %rax,	%rax
    jz        L653
L655:
    mov       %rax,	[%rdi]
    movsxd    %r10,	dword ptr[%rdi+8]
    xor       %r11d,	%r11d
    mov       [%rax + %r10],	%r11b
    test      %rbx,	%rbx
    jnz       L657
    call      msys.m$print_startcon
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L656
L657:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L656:
L653:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.nextcmdparamnew
mlib.nextcmdparamnew:
#?>>
    .set mlib.nextcmdparamnew.defext, 88
    .set mlib.nextcmdparamnew.item, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#mlib.nextcmdparamnew.reenter:
L659:
    xor       %eax,	%eax
    mov       [%r14],	%rax
    xor       %eax,	%eax
    mov       [%r13],	%rax
    mov       %rax,	[%rip+mlib.nextcmdparamnew.infile]
    test      %rax,	%rax
    jz        L661
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.fileptr]
    lea       %rdx,	[%rbp + mlib.nextcmdparamnew.item]
    call      mlib.readnextfileitem
    test      %rax,	%rax
    jnz       L663
    mov       %rcx,	[%rip+mlib.nextcmdparamnew.filestart]
    call      free
    xor       %eax,	%eax
    mov       [%rip+mlib.nextcmdparamnew.infile],	%rax
    jmp       L659
L663:
    jmp       L660
L661:
    mov       %rax,	[%r12]
    cmp       %rax,	[%rip+msys.ncmdparams]
    jle       L665
    xor       %eax,	%eax
    jmp       L658
L665:
    mov       %rax,	[%r12]
    mov       %r10,	[%rip+msys.cmdparams]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + mlib.nextcmdparamnew.item],	%r10
    mov       %rax,	%r12
    inc       qword ptr[%rax]
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    call      strlen
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	64
    jnz       L667
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    lea       %rax,	[%rax+1]
    mov       %rcx,	%rax
    call      mlib.readfile
    mov       [%rip+mlib.nextcmdparamnew.fileptr],	%rax
    mov       [%rip+mlib.nextcmdparamnew.filestart],	%rax
    mov       %rax,	[%rip+mlib.nextcmdparamnew.filestart]
    test      %rax,	%rax
    jnz       L669
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10365]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	7
    call      exit
L669:
    mov       %rax,	1
    mov       [%rip+mlib.nextcmdparamnew.infile],	%rax
    jmp       L659
L667:
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	58
    jnz       L671
    mov       %al,	1
    mov       [%rip+mlib.nextcmdparamnew.colonseen],	%al
    mov       %rax,	4
    jmp       L658
L671:
L660:
    xor       %eax,	%eax
    mov       [%r14],	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	45
    jnz       L673
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L675
    xor       %eax,	%eax
    jmp       L674
L675:
    mov       %rax,	1
L674:
    mov       %r10,	[%rbp + mlib.nextcmdparamnew.item]
    lea       %r10,	[%r10 + %rax]
    mov       [%r13],	%r10
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    mov       %rdx,	58
    call      strchr
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L677
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    mov       %rdx,	61
    call      strchr
    mov       %rdi,	%rax
L677:
    test      %rdi,	%rdi
    jz        L679
    lea       %rax,	[%rdi+1]
    mov       [%r14],	%rax
    xor       %eax,	%eax
    mov       [%rdi],	%al
L679:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L681
    mov       %rax,	5
    jmp       L680
L681:
    mov       %rax,	1
L680:
    jmp       L658
L673:
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    xor       %edx,	%edx
    call      mlib.extractext
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    mov       [%r13],	%rax
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L683
    mov       %rax,	[%r13]
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.defext]
    test      %rax,	%rax
    jz        L685
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jnz       L685
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.str]
    mov       %rdx,	[%rbp + mlib.nextcmdparamnew.defext]
    call      mlib.addext
    mov       [%r13],	%rax
L685:
    jmp       L682
L683:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10366]
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L687
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10367]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L686
L687:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L689
    mov       %rax,	5
    jmp       L688
L689:
    mov       %rax,	3
L688:
    jmp       L658
L686:
L682:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L691
    mov       %rax,	5
    jmp       L690
L691:
    mov       %rax,	2
L690:
L658:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readnextfileitem
mlib.readnextfileitem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    mov       %rdi,	[%r13]
#mlib.readnextfileitem.reenter:
L693:
L694:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	32
    jz        L697
    cmp       %rax,	9
    jz        L697
    cmp       %rax,	13
    jz        L697
    cmp       %rax,	10
    jz        L697
    cmp       %rax,	26
    jz        L698
    test      %rax,	%rax
    jz        L698
    jmp       L699
L697:
    inc       %rdi
    jmp       L696
L698:
    xor       %eax,	%eax
    jmp       L692
L699:
    jmp       L695
L696:
    jmp       L694
L695:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	33
    jz        L701
    cmp       %rax,	35
    jnz       L702
L701:
    inc       %rdi
L703:
    mov       %rax,	%rdi
    inc       %rdi
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L705
    cmp       %rax,	26
    jz        L706
    test      %rax,	%rax
    jz        L706
    jmp       L707
L705:
    jmp       L693
L706:
    lea       %rax,	[%rdi-1]
    mov       [%r13],	%rax
    xor       %eax,	%eax
    jmp       L692
L707:
    jmp       L703
L702:
L700:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	34
    jnz       L710
L709:
    inc       %rdi
    mov       %rbx,	%rdi
L711:
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L714
    cmp       %rax,	26
    jz        L714
    cmp       %rax,	34
    jz        L715
    jmp       L716
L714:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10368]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	8
    call      exit
    jmp       L713
L715:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	44
    jnz       L718
    inc       %rdi
L718:
    jmp       L712
L716:
L713:
    inc       %rdi
    jmp       L711
L712:
    jmp       L708
L710:
    mov       %rbx,	%rdi
L719:
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L722
    cmp       %rax,	26
    jz        L722
    cmp       %rax,	32
    jz        L723
    cmp       %rax,	9
    jz        L723
    cmp       %rax,	44
    jz        L723
    cmp       %rax,	13
    jz        L723
    cmp       %rax,	10
    jz        L723
    jmp       L724
L722:
    mov       %rsi,	%rdi
    jmp       L720
L723:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %rsi,	%rax
    jmp       L720
L724:
L721:
    inc       %rdi
    jmp       L719
L720:
L708:
    mov       %rax,	%rsi
    sub       %rax,	%rbx
    mov       %r12,	%rax
    cmp       %r12,	256
    jl        L726
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10369]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	9
    call      exit
L726:
    lea       %rcx,	[%rip+mlib.readnextfileitem.str]
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.readnextfileitem.str]
    mov       %r11,	%r12
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.readnextfileitem.str]
    mov       [%r14],	%rax
    mov       [%r13],	%rdi
    mov       %rax,	1
L692:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.ipadstr
mlib.ipadstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	%rsi
    call      strlen
    mov       %rdi,	%rax
    mov       %rax,	%r12
    sub       %rax,	%rdi
    mov       %rbx,	%rax
    cmp       %rbx,	0
    jle       L730
L728:
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      strcat
    dec       %rbx
    jnz       L728
L730:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.padstr
mlib.padstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rip+mlib.padstr.str]
    mov       %rdx,	%rdi
    call      strcpy
    lea       %rcx,	[%rip+mlib.padstr.str]
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mlib.ipadstr
    lea       %rax,	[%rip+mlib.padstr.str]
L731:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.chr
mlib.chr:
#?>>
#?]]
#---------------
    mov       %al,	%cl
    lea       %r10,	[%rip+mlib.chr.str]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.chr.str]
    mov       [%r10+1],	%al
    lea       %rax,	[%rip+mlib.chr.str]
L732:
#---------------
    ret       
# End 
# Proc mlib.cmpstring
mlib.cmpstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      strcmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L735
    mov       %rax,	-1
    jmp       L734
L735:
    cmp       %rdi,	0
    jle       L736
    mov       %rax,	1
    jmp       L734
L736:
    xor       %eax,	%eax
L734:
L733:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.cmpstringn
mlib.cmpstringn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      strncmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L739
    mov       %rax,	-1
    jmp       L738
L739:
    cmp       %rdi,	0
    jle       L740
    mov       %rax,	1
    jmp       L738
L740:
    xor       %eax,	%eax
L738:
L737:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.eqstring
mlib.eqstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      strcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L741:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.cmpbytes
mlib.cmpbytes:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      memcmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L744
    mov       %rax,	-1
    jmp       L743
L744:
    cmp       %rdi,	0
    jle       L745
    mov       %rax,	1
    jmp       L743
L745:
    xor       %eax,	%eax
L743:
L742:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.eqbytes
mlib.eqbytes:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L746:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mseed
mlib.mseed:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10],	%rax
    test      %rdx,	%rdx
    jz        L749
    mov       %rax,	%rdx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10+8],	%rax
    jmp       L748
L749:
    lea       %rax,	[%rip+mlib.seed]
    lea       %rax,	[%rax+8]
    mov       %r10,	%rcx
    xor       [%rax],	%r10
L748:
#---------------
    ret       
# End 
# Proc mlib.mrandom
mlib.mrandom:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    lea       %rax,	[%rip+mlib.seed]
    mov       %rdi,	[%rax]
    lea       %rax,	[%rip+mlib.seed]
    mov       %rbx,	[%rax+8]
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10],	%rax
    mov       %rax,	%rdi
    shl       %rax,	23
    xor       %rdi,	%rax
    mov       %rax,	%rdi
    xor       %rax,	%rbx
    mov       %r10,	%rdi
    sar       %r10,	17
    xor       %rax,	%r10
    mov       %r10,	%rbx
    sar       %r10,	26
    xor       %rax,	%r10
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10+8],	%rax
    lea       %rax,	[%rip+mlib.seed]
    mov       %rax,	[%rax+8]
    add       %rax,	%rbx
L750:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomp
mlib.mrandomp:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.mrandom
    mov       %r10,	9223372036854775807
    and       %rax,	%r10
L751:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.mrandomint
mlib.mrandomint:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      mlib.mrandomp
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
L752:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomrange
mlib.mrandomrange:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	%rsi
    sub       %rax,	%rbx
    inc       %rax
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jg        L755
    xor       %eax,	%eax
    jmp       L753
L755:
    call      mlib.mrandomp
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    add       %rax,	%rbx
L753:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomreal
mlib.mrandomreal:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
#---------------
L757:
    call      mlib.mrandomp
    cvtsi2sd  %XMM4,	%rax
    divsd     %XMM4,	[%rip+L10370]
    movq      %XMM15,	%XMM4
    movq      %XMM4,	%XMM15
    comisd    %XMM4,	[%rip+L10371]
    jz        L757
    movq      %XMM0,	%XMM15
L756:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mlib.mrandomreal1
mlib.mrandomreal1:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.mrandomp
    cvtsi2sd  %XMM4,	%rax
    divsd     %XMM4,	[%rip+L10372]
    movq      %XMM0,	%XMM4
L760:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.readline
mlib.readline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$read_conline
    mov       %rax,	[%rip+msys.rd_buffer]
L761:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.findfunction
mlib.findfunction:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rdi,	[%rip+$nprocs]
    cmp       %rdi,	1
    jl        L765
L763:
    lea       %rax,	[%rip+$procname]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L767
    lea       %rax,	[%rip+$procaddr]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L762
L767:
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L763
L765:
    xor       %eax,	%eax
L762:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.roundtoblock
mlib.roundtoblock:
#?>>
#?]]
#---------------
    lea       %rax,	[%rdx-1]
    mov       %r10,	%rcx
    and       %r10,	%rax
    test      %r10,	%r10
    jnz       L770
    mov       %rax,	%rcx
    jmp       L768
L770:
    lea       %rax,	[%rdx-1]
    mov       %r10,	%rcx
    and       %r10,	%rax
    mov       %rax,	%rdx
    sub       %rax,	%r10
    mov       %r10,	%rcx
    add       %r10,	%rax
    mov       %rax,	%r10
L768:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocnfz
mlib.pcm_allocnfz:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	%rbx
    and       %rax,	7
    jz        L773
    mov       %rax,	%rbx
    and       %rax,	7
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rax,	%rbx
    add       %rax,	%r10
    mov       %rbx,	%rax
L773:
    mov       %rdi,	[%rip+mlib.pcheapptr]
    mov       %rax,	%rbx
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	[%rip+mlib.pcheapptr]
    cmp       %rax,	[%rip+mlib.pcheapend]
    jb        L775
    mov       %rcx,	%rbx
    call      mlib.pcm_newblock
    mov       %rdi,	%rax
L775:
    mov       %rax,	%rdi
L771:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_init
mwindows.os_init:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %eax,	4294967285
    mov       %eax,	%eax
    mov       %rcx,	%rax
    call      GetStdHandle
    mov       [%rip+mwindows.hconsole],	%rax
    mov       %eax,	4294967286
    mov       %eax,	%eax
    mov       %rcx,	%rax
    call      GetStdHandle
    mov       [%rip+mwindows.hconsolein],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mwindows.lastkey]
    mov       [%r10+8],	%ax
    xor       %eax,	%eax
    mov       [%rip+mwindows.keypending],	%rax
    xor       %ecx,	%ecx
    mov       %rdx,	1
    call      SetConsoleCtrlHandler
    mov       %rcx,	[%rip+mwindows.hconsole]
    mov       %rdx,	3
    call      SetConsoleMode
    mov       %rax,	1
    mov       [%rip+mwindows.init_flag],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_execwait
mwindows.os_execwait:
#?>>
    .set mwindows.os_execwait.workdir, 64
    .set mwindows.os_execwait.exitcode, -8
    .set mwindows.os_execwait.si, -112
    .set mwindows.os_execwait.xpi, -136
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	176
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %rbx,	%rbx
    mov       %rax,	104
    mov       %rdi,	%rax
    mov       %rdi,	24
    mov       %rdi,	123456
    mov       %rdi,	1193046
    lea       %rax,	[%rbp + mwindows.os_execwait.si]
    xor       %r10d,	%r10d
    mov       %r11,	13
L10373:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L10373
    lea       %rax,	[%rbp + mwindows.os_execwait.xpi]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       %rax,	%r12
    test      %rax,	%rax
    jz        L779
    cmp       %rax,	1
    jz        L780
    cmp       %rax,	2
    jz        L781
    jmp       L782
L779:
    mov       %rbx,	32
    jmp       L778
L780:
    mov       %rbx,	48
    jmp       L778
L781:
    mov       %rbx,	48
L782:
L778:
    mov       %eax,	104
    mov       [%rbp + mwindows.os_execwait.si],	%eax
    lea       %rax,	[%rbp + mwindows.os_execwait.xpi]
    push      %rax
    lea       %rax,	[%rbp + mwindows.os_execwait.si]
    push      %rax
    push      0
    push      0
    mov       %eax,	%ebx
    push      %rax
    push      1
    xor       %ecx,	%ecx
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      CreateProcessA
    add       %rsp,	80
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L784
    call      GetLastError
    mov       %r10d,	%eax
    mov       %rdi,	%r10
    lea       %rcx,	[%rip+L10374]
    mov       %rdx,	%rdi
    call      printf
    mov       %rax,	-1
    jmp       L777
L784:
    mov       %rax,	[%rbp + mwindows.os_execwait.xpi]
    mov       %rcx,	%rax
    mov       %rdx,	4294967295
    call      WaitForSingleObject
    mov       %rax,	[%rbp + mwindows.os_execwait.xpi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + mwindows.os_execwait.exitcode]
    call      GetExitCodeProcess
    mov       %rcx,	[%rbp + mwindows.os_execwait.xpi]
    call      CloseHandle
    mov       %rcx,	[%rbp + mwindows.os_execwait.xpi+8]
    call      CloseHandle
    mov       %eax,	[%rbp + mwindows.os_execwait.exitcode]
L777:
#---------------
    add       %rsp,	176
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_execcmd
mwindows.os_execcmd:
#?>>
    .set mwindows.os_execcmd.si, -104
    .set mwindows.os_execcmd.xpi, -128
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	160
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rbp + mwindows.os_execcmd.si]
    xor       %r10d,	%r10d
    mov       %r11,	13
L10375:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L10375
    lea       %rax,	[%rbp + mwindows.os_execcmd.xpi]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       %eax,	104
    mov       [%rbp + mwindows.os_execcmd.si],	%eax
    lea       %rax,	[%rbp + mwindows.os_execcmd.xpi]
    push      %rax
    lea       %rax,	[%rbp + mwindows.os_execcmd.si]
    push      %rax
    push      0
    push      0
    test      %rbx,	%rbx
    jz        L787
    mov       %rax,	16
    jmp       L786
L787:
    xor       %eax,	%eax
L786:
    mov       %r10,	32
    or        %r10,	%rax
    push      %r10
    push      1
    xor       %ecx,	%ecx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      CreateProcessA
    add       %rsp,	80
    mov       %rcx,	[%rbp + mwindows.os_execcmd.xpi]
    call      CloseHandle
    mov       %rcx,	[%rbp + mwindows.os_execcmd.xpi+8]
    call      CloseHandle
    mov       %rax,	1
L785:
#---------------
    add       %rsp,	160
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_getch
mwindows.os_getch:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      mwindows.os_getchx
    and       %rax,	255
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L788:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_kbhit
mwindows.os_kbhit:
#?>>
    .set mwindows.os_kbhit.count, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mwindows.init_flag]
    test      %rax,	%rax
    jnz       L791
    call      mwindows.os_init
L791:
    mov       %rcx,	[%rip+mwindows.hconsolein]
    lea       %rdx,	[%rbp + mwindows.os_kbhit.count]
    call      GetNumberOfConsoleInputEvents
    mov       %eax,	[%rbp + mwindows.os_kbhit.count]
    cmp       %rax,	1
    setg      %al
    movzx     %eax,	%al
L789:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mwindows.os_getdllinst
mwindows.os_getdllinst:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      LoadLibraryA
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L792:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_getdllprocaddr
mwindows.os_getdllprocaddr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      GetProcAddress
L793:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_initwindows
mwindows.os_initwindows:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mwindows.os_init
    lea       %rcx,	[%rip+L10376]
    call      mwindows.os_gxregisterclass
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_gxregisterclass
mwindows.os_gxregisterclass:
#?>>
    .set mwindows.os_gxregisterclass.r, -80
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	120
    mov       %rdi,	%rcx
#---------------
    mov       %al,	[%rip+mwindows.os_gxregisterclass.registered]
    test      %al,	%al
    jnz       L795
L797:
    lea       %rax,	[%rbp + mwindows.os_gxregisterclass.r]
    xor       %r10d,	%r10d
    mov       %r11,	10
L10377:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L10377
    mov       %eax,	80
    mov       [%rbp + mwindows.os_gxregisterclass.r],	%eax
    mov       %eax,	40
    mov       [%rbp + mwindows.os_gxregisterclass.r+4],	%eax
    lea       %rax,	[%rip+mwindows.mainwndproc]
    mov       [%rbp + mwindows.os_gxregisterclass.r+8],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_gxregisterclass.r+24],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_gxregisterclass.r+32],	%rax
    xor       %ecx,	%ecx
    mov       %rdx,	32512
    call      LoadCursorA
    mov       [%rbp + mwindows.os_gxregisterclass.r+40],	%rax
    mov       %rax,	16
    mov       [%rbp + mwindows.os_gxregisterclass.r+48],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_gxregisterclass.r+56],	%rax
    mov       [%rbp + mwindows.os_gxregisterclass.r+64],	%rdi
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_gxregisterclass.r+72],	%rax
    lea       %rcx,	[%rbp + mwindows.os_gxregisterclass.r]
    call      RegisterClassExA
    mov       %r10d,	%eax
    test      %r10,	%r10
    jnz       L799
    call      GetLastError
    mov       %r10d,	%eax
    lea       %rcx,	[%rip+L10378]
    mov       %rdx,	%rdi
    mov       %r8,	%r10
    call      printf
    mov       %rcx,	1
    call      exit
L799:
    mov       %al,	1
    mov       [%rip+mwindows.os_gxregisterclass.registered],	%al
L795:
#---------------
    add       %rsp,	120
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mwindows.mainwndproc
mwindows.mainwndproc:
#?>>
    .set mwindows.mainwndproc.m, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %rbx,	%rcx
    mov       %esi,	%edx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       [%rbp + mwindows.mainwndproc.m],	%rbx
    mov       [%rbp + mwindows.mainwndproc.m+8],	%esi
    mov       [%rbp + mwindows.mainwndproc.m+16],	%r12
    mov       [%rbp + mwindows.mainwndproc.m+24],	%r13
    xor       %eax,	%eax
    mov       [%rbp + mwindows.mainwndproc.m+40],	%eax
    xor       %eax,	%eax
    mov       [%rbp + mwindows.mainwndproc.m+44],	%eax
    mov       %rax,	[%rip+mwindows.wndproc_callbackfn]
    test      %rax,	%rax
    jz        L802
    lea       %rcx,	[%rbp + mwindows.mainwndproc.m]
    mov       %rax,	[%rip+mwindows.wndproc_callbackfn]
    call      %rax
    mov       %rdi,	%rax
    jmp       L801
L802:
    xor       %rdi,	%rdi
L801:
    mov       %eax,	[%rbp + mwindows.mainwndproc.m+8]
    cmp       %rax,	2
    jnz       L804
    xor       %eax,	%eax
    jmp       L800
L804:
    test      %rdi,	%rdi
    jnz       L806
    mov       %eax,	%esi
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	%r13
    call      DefWindowProcA
    jmp       L805
L806:
    xor       %eax,	%eax
L805:
L800:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_setmesshandler
mwindows.os_setmesshandler:
#?>>
#?]]
#---------------
    mov       [%rip+mwindows.wndproc_callbackfn],	%rcx
#---------------
    ret       
# End 
# Proc mwindows.os_getchx
mwindows.os_getchx:
#?>>
    .set mwindows.os_getchx.count, -8
    .set mwindows.os_getchx.shiftdown, -16
    .set mwindows.os_getchx.capslock, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    mov       %rax,	[%rip+mwindows.init_flag]
    test      %rax,	%rax
    jnz       L810
    call      mwindows.os_init
L810:
    mov       %rax,	[%rip+mwindows.keypending]
    test      %rax,	%rax
    jz        L812
    lea       %rax,	[%rip+mwindows.pendkey]
    lea       %r10,	[%rip+mwindows.lastkey]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11d,	[%rax+16]
    mov       [%r10+16],	%r11d
    xor       %eax,	%eax
    mov       [%rip+mwindows.keypending],	%rax
    jmp       L811
L812:
    lea       %rax,	[%rip+mwindows.lastkey]
    movzx     %rax,	word ptr[%rax+8]
    test      %rax,	%rax
    jnz       L814
L815:
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_getchx.count],	%rax
    mov       %rcx,	[%rip+mwindows.hconsolein]
    lea       %rdx,	[%rip+mwindows.lastkey]
    mov       %r8,	1
    lea       %r9,	[%rbp + mwindows.os_getchx.count]
    call      ReadConsoleInputA
    lea       %rax,	[%rip+mwindows.lastkey]
    movzx     %rax,	word ptr[%rax]
    cmp       %rax,	1
    jnz       L815
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+4]
    cmp       %rax,	1
    jnz       L815
L814:
L811:
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+16]
    and       %rax,	3
    jz        L819
    mov       %rax,	1
    jmp       L818
L819:
    xor       %eax,	%eax
L818:
    mov       %r12,	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+16]
    and       %rax,	12
    jz        L821
    mov       %rax,	1
    jmp       L820
L821:
    xor       %eax,	%eax
L820:
    mov       %r13,	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+16]
    and       %rax,	16
    jz        L823
    mov       %rax,	1
    jmp       L822
L823:
    xor       %eax,	%eax
L822:
    mov       [%rbp + mwindows.os_getchx.shiftdown],	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+16]
    and       %rax,	128
    jz        L825
    mov       %rax,	1
    jmp       L824
L825:
    xor       %eax,	%eax
L824:
    mov       [%rbp + mwindows.os_getchx.capslock],	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    lea       %rax,	[%rax+8]
    dec       word ptr[%rax]
    lea       %rax,	[%rip+mwindows.lastkey]
    movzx     %rax,	byte ptr[%rax+14]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    movzx     %rax,	word ptr[%rax+10]
    and       %rax,	255
    mov       %rsi,	%rax
    cmp       %rdi,	0
    jge       L827
    cmp       %rdi,	-128
    jge       L829
    xor       %rdi,	%rdi
    jmp       L828
L829:
    mov       %rax,	256
    add       %rdi,	%rax
L828:
L827:
    test      %r12,	%r12
    jz        L831
    test      %r13,	%r13
    jz        L831
    cmp       %rdi,	166
    jnz       L831
    xor       %eax,	%eax
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L830
L831:
    test      %r12,	%r12
    jnz       L834
    test      %r13,	%r13
    jz        L833
L834:
    xor       %rdi,	%rdi
    mov       %rax,	%rsi
    cmp       %rax,	65
    jl        L836
    cmp       %rsi,	90
    jg        L836
    lea       %rax,	[%rsi-64]
    mov       %rdi,	%rax
L836:
L833:
L830:
    mov       %rax,	[%rbp + mwindows.os_getchx.capslock]
    shl       %rax,	3
    mov       %r10,	%r12
    shl       %r10,	2
    or        %rax,	%r10
    mov       %r10,	%r13
    shl       %r10,	1
    or        %rax,	%r10
    or        %rax,	[%rbp + mwindows.os_getchx.shiftdown]
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    shl       %rax,	24
    mov       %r10,	%rsi
    shl       %r10,	16
    or        %rax,	%r10
    or        %rax,	%rdi
L808:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_getos
mwindows.os_getos:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+L10379]
L837:
#---------------
    ret       
# End 
# Proc mwindows.os_gethostsize
mwindows.os_gethostsize:
#?>>
#?]]
#---------------
    mov       %rax,	64
L838:
#---------------
    ret       
# End 
# Proc mwindows.os_shellexec
mwindows.os_shellexec:
#?>>
    .set mwindows.os_shellexec.opc, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    mov       %rcx,	%rdi
    call      system
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L839:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_sleep
mwindows.os_sleep:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      Sleep
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_getstdin
mwindows.os_getstdin:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L10380]
    lea       %rdx,	[%rip+L10381]
    call      fopen
L841:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_getstdout
mwindows.os_getstdout:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L10382]
    lea       %rdx,	[%rip+L10383]
    call      fopen
L842:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_gethostname
mwindows.os_gethostname:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    lea       %rdx,	[%rip+mwindows.os_gethostname.name]
    mov       %r8,	300
    call      GetModuleFileNameA
    lea       %rax,	[%rip+mwindows.os_gethostname.name]
L843:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_getmpath
mwindows.os_getmpath:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+L10384]
L844:
#---------------
    ret       
# End 
# Proc mwindows.os_clock
mwindows.os_clock:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mwindows.os_hpcounter
L845:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_ticks
mwindows.os_ticks:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      GetTickCount64
L846:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_iswindows
mwindows.os_iswindows:
#?>>
#?]]
#---------------
    mov       %rax,	1
L847:
#---------------
    ret       
# End 
# Proc mwindows.os_getsystime
mwindows.os_getsystime:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      GetLocalTime
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_peek
mwindows.os_peek:
#?>>
    .set mwindows.os_peek.m, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
#---------------
    call      GetTickCount64
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    sub       %rax,	[%rip+mwindows.os_peek.lastticks]
    cmp       %rax,	1000
    jl        L851
    mov       [%rip+mwindows.os_peek.lastticks],	%rdi
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + mwindows.os_peek.m]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      PeekMessageA
    add       %rsp,	48
L851:
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_allocexecmem
mwindows.os_allocexecmem:
#?>>
    .set mwindows.os_allocexecmem.oldprot, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    xor       %ecx,	%ecx
    mov       %rdx,	%rsi
    mov       %r8,	12288
    mov       %r9,	1
    call      VirtualAlloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L854
    xor       %eax,	%eax
    jmp       L852
L854:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	64
    lea       %r9,	[%rbp + mwindows.os_allocexecmem.oldprot]
    call      VirtualProtect
    mov       %r10d,	%eax
    mov       %rbx,	%r10
    test      %rbx,	%rbx
    jnz       L856
    xor       %eax,	%eax
    jmp       L852
L856:
    mov       %rax,	%rdi
L852:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.dirlist
mwindows.dirlist:
#?>>
    .set mwindows.dirlist.file, -328
    .set mwindows.dirlist.path, -632
    .set mwindows.dirlist.fullfilename, -936
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	976
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    xor       %rbx,	%rbx
    mov       %rcx,	%rsi
    call      mlib.extractpath
    lea       %rcx,	[%rbp + mwindows.dirlist.path]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + mwindows.dirlist.file]
    call      FindFirstFileA
    mov       %rdi,	%rax
    cmp       %rax,	-1
    jz        L859
L860:
    mov       %eax,	[%rbp + mwindows.dirlist.file]
    and       %rax,	16
    jz        L864
    mov       %rax,	%r14
    and       %rax,	2
    jnz       L866
    jmp       L861
L866:
    jmp       L863
L864:
    mov       %rax,	%r14
    and       %rax,	1
    jnz       L868
    jmp       L861
L868:
L863:
    cmp       %rbx,	%r13
    jl        L870
    mov       %rbx,	-1
    jmp       L862
L870:
    mov       %rax,	%r14
    and       %rax,	4
    jz        L872
    lea       %rax,	[%rbp + mwindows.dirlist.file+44]
    mov       %rcx,	%rax
    call      mlib.convlcstring
L872:
    lea       %rcx,	[%rbp + mwindows.dirlist.fullfilename]
    lea       %rdx,	[%rbp + mwindows.dirlist.path]
    call      strcpy
    lea       %rax,	[%rbp + mwindows.dirlist.file+44]
    lea       %rcx,	[%rbp + mwindows.dirlist.fullfilename]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + mwindows.dirlist.fullfilename]
    call      mlib.pcm_copyheapstring
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%r12 + %r10*8-8],	%rax
L861:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + mwindows.dirlist.file]
    call      FindNextFileA
    test      %eax,	%eax
    jnz       L860
L862:
    mov       %rcx,	%rdi
    call      FindClose
L859:
    mov       %rax,	%rbx
L857:
#---------------
    add       %rsp,	976
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_hpcounter
mwindows.os_hpcounter:
#?>>
    .set mwindows.os_hpcounter.a, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mwindows.hpfreq]
    test      %rax,	%rax
    jnz       L875
    call      mwindows.os_hpfreq
    mov       %r10,	1000
    cqo       
    idiv      %r10
    mov       [%rip+mwindows.hpfreq],	%rax
L875:
    lea       %rcx,	[%rbp + mwindows.os_hpcounter.a]
    call      QueryPerformanceCounter
    mov       %rax,	[%rbp + mwindows.os_hpcounter.a]
    mov       %r10,	[%rip+mwindows.hpfreq]
    cqo       
    idiv      %r10
L873:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mwindows.os_hpfreq
mwindows.os_hpfreq:
#?>>
    .set mwindows.os_hpfreq.a, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    lea       %rcx,	[%rbp + mwindows.os_hpfreq.a]
    call      QueryPerformanceFrequency
    mov       %rax,	[%rbp + mwindows.os_hpfreq.a]
L876:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mwindll.os_calldllfunction
mwindll.os_calldllfunction:
#?>>
    .set mwindll.os_calldllfunction.fnaddr, 16
    .set mwindll.os_calldllfunction.retcode, 24
    .set mwindll.os_calldllfunction.nargs, 32
    .set mwindll.os_calldllfunction.args, 40
    .set mwindll.os_calldllfunction.argcodes, 48
    .set mwindll.os_calldllfunction.a, -8
    .set mwindll.os_calldllfunction.x, -16
    .set mwindll.os_calldllfunction.nextra, -24
    .set mwindll.os_calldllfunction.pushedbytes, -32
    .set mwindll.os_calldllfunction.av_1, -40
    .set mwindll.os_calldllfunction.i, -48
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       [%rbp+16],	%rcx
    mov       [%rbp+24],	%rdx
    mov       [%rbp+32],	%r8
    mov       [%rbp+40],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    cmp       %rax,	4
    jge       L879
    mov       %rax,	4
    sub       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
    jmp       L878
L879:
    mov       %eax,	[%rbp + mwindll.os_calldllfunction.nargs]
    and       %eax,	1
    test      %rax,	%rax
    jz        L880
    mov       %rax,	1
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
L880:
L878:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nextra]
    add       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    shl       %rax,	3
    mov       [%rbp + mwindll.os_calldllfunction.pushedbytes],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nextra]
    mov       [%rbp + mwindll.os_calldllfunction.av_1],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.av_1]
    cmp       %rax,	0
    jle       L883
L881:
    push      0
    dec       qword ptr[%rbp + mwindll.os_calldllfunction.av_1]
    jnz       L881
L883:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    mov       [%rbp + mwindll.os_calldllfunction.i],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.i]
    cmp       %rax,	1
    jl        L886
L884:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.args]
    mov       %r10,	[%rbp + mwindll.os_calldllfunction.i]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + mwindll.os_calldllfunction.a],	%rax
    push      qword ptr[%rbp + mwindll.os_calldllfunction.a]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.i]
    dec       %rax
    mov       [%rbp + mwindll.os_calldllfunction.i],	%rax
    cmp       %rax,	1
    jge       L884
L886:
    mov       %rcx,	[%rsp]
    movq      %XMM0,	[%rsp]
    mov       %rdx,	[%rsp+8]
    movq      %XMM1,	[%rsp+8]
    mov       %r8,	[%rsp+16]
    movq      %XMM2,	[%rsp+16]
    mov       %r9,	[%rsp+24]
    movq      %XMM3,	[%rsp+24]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.retcode]
    cmp       %rax,	73
    jnz       L888
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.fnaddr]
    call      %rax
    mov       [%rbp + mwindll.os_calldllfunction.a],	%rax
    add       %rsp,	[%rbp + mwindll.os_calldllfunction.pushedbytes]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.a]
    jmp       L887
L888:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.fnaddr]
    call      %rax
    movq      [%rbp + mwindll.os_calldllfunction.x],	%XMM0
    add       %rsp,	[%rbp + mwindll.os_calldllfunction.pushedbytes]
    movq      %XMM4,	[%rbp + mwindll.os_calldllfunction.x]
    movq      %rax,	%XMM4
L887:
L877:
#---------------
    add       %rsp,	80
    pop       %rbp
    ret       
# End 
# Proc pc_api.pcl_start
pc_api.pcl_start:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rip+pc_decls.pcldone]
    test      %al,	%al
    jz        L891
    lea       %rcx,	[%rip+L10385]
    call      pc_api.pclerror
L891:
    test      %rdi,	%rdi
    jz        L893
    mov       %rcx,	%rdi
    mov       %rdx,	9
    call      pc_api.pc_makesymbol
    mov       [%rip+pc_decls.currprog],	%rax
L893:
    mov       %rax,	[%rip+pc_api.initpcalloc]
    mov       [%rip+pc_api.pcalloc],	%rax
    test      %rbx,	%rbx
    jz        L895
    mov       %rax,	%rbx
    lea       %rax,	[%rax + %rax*8]
    sar       %rax,	3
    mov       %rbx,	%rax
    jmp       L897
L896:
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	1
    mov       [%rip+pc_api.pcalloc],	%rax
L897:
    mov       %rax,	[%rip+pc_api.pcalloc]
    cmp       %rax,	%rbx
    jl        L896
L895:
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	5
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rip+pc_api.pcstart],	%rax
    mov       %rax,	[%rip+pc_api.pcstart]
    mov       %r10,	[%rip+pc_api.pcalloc]
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    sub       %rax,	256
    mov       [%rip+pc_api.pcend],	%rax
    mov       %rax,	[%rip+pc_api.pcstart]
    sub       %rax,	32
    mov       [%rip+pc_api.pccurr],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcfixed],	%al
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcseqno],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcneedfntable],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.mlabelno],	%rax
    mov       %rax,	[%rip+pc_decls.currprog]
L889:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_end
pc_api.pcl_end:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    cmp       %rax,	[%rip+pc_api.pccurr]
    jb        L901
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	136
    jz        L901
    mov       %rcx,	136
    xor       %edx,	%edx
    call      pc_api.pc_gen
L901:
    mov       %al,	1
    mov       [%rip+pc_decls.pcldone],	%al
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_writepcl
pc_api.pcl_writepcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_diags.writeallpcl
    mov       %rdi,	%rax
    test      %rbx,	%rbx
    jz        L904
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L906
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10386]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L906:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
    lea       %rax,	[%rip+L10387]
    jmp       L903
L904:
    mov       %rax,	[%rdi]
L903:
L902:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writepst
pc_api.pcl_writepst:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_diags.writepst
    mov       %rdi,	%rax
    test      %rbx,	%rbx
    jz        L909
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L911
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10388]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L911:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
    lea       %rax,	[%rip+L10389]
    jmp       L908
L909:
    mov       %rax,	[%rdi]
L908:
L907:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_genmcl
pc_api.pcl_genmcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_genss
pc_api.pcl_genss:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	%rdi
    call      mc_genss.genss
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writess
pc_api.pcl_writess:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	%r12
    call      mc_genss.genss
    mov       %rax,	%r12
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       %rcx,	%rax
    call      mc_writess_dummy.writessdata
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L916
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L10390]
    call      fopen
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_println
    mov       %rcx,	%rbx
    call      fclose
    mov       %rcx,	%rdi
    call      mlib.gs_free
    xor       %eax,	%eax
    jmp       L915
L916:
    mov       %rax,	[%rdi]
L915:
L914:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeasm
pc_api.pcl_writeasm:
#?>>
    .set pc_api.pcl_writeasm.atype, 48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_decls.assemtype]
    cmp       %rax,	1297301838
    jnz       L919
    mov       %al,	2
    mov       [%rip+pc_api.phighmem],	%al
L919:
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    call      mc_writeasm.getassemstr
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L921
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L923
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10391]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L923:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L10392]
    call      fopen
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_println
    mov       %rcx,	%rbx
    call      fclose
    mov       %rcx,	%rdi
    call      mlib.gs_free
    xor       %eax,	%eax
    jmp       L920
L921:
    mov       %rax,	[%rdi]
L920:
L917:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeobj
pc_api.pcl_writeobj:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	1
    call      mc_genss.genss
    xor       %eax,	%eax
    mov       [%rip+pc_api.phighmem],	%al
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10393]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mc_writeobj.writecoff
    call      mwindows.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.objtime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writedll
pc_api.pcl_writedll:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	2
    mov       [%rip+pc_api.phighmem],	%al
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss.genss
    call      mwindows.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      mc_writeexe.writeexe
    call      mwindows.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.exetime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeexe
pc_api.pcl_writeexe:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss.genss
    call      mwindows.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_writeexe.writeexe
    call      mwindows.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.exetime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writemx
pc_api.pcl_writemx:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss.genss
    mov       %rcx,	%rdi
    call      mx_write.writemcx
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_exec
pc_api.pcl_exec:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss.genss
    lea       %rcx,	[%rip+L10394]
    mov       %rdx,	[%rip+pc_decls.pcmdskip]
    call      mx_run.runlibfile
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_setflags
pc_api.pcl_setflags:
#?>>
#?]]
#---------------
    cmp       %rcx,	0
    jl        L931
    mov       [%rip+pc_api.phighmem],	%cl
L931:
    cmp       %rdx,	0
    jl        L933
    mov       [%rip+pc_decls.pverbose],	%dl
L933:
    cmp       %r8,	0
    jl        L935
    mov       [%rip+pc_api.fpshortnames],	%r8b
L935:
#---------------
    ret       
# End 
# Proc pc_api.extendpclblock
pc_api.extendpclblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	1
    mov       %rdi,	%rax
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    inc       %rax
    mov       %rbx,	%rax
    mov       %rax,	32
    mov       %r10,	%rdi
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	%rbx
    shl       %rax,	5
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+pc_api.pcstart]
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rdi
    sub       %rax,	%rbx
    shl       %rax,	5
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %r11,	[%rsi + %r10]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      mlib.pcm_clearmem
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    shl       %rax,	5
    lea       %r10,	[%rsi + %rax]
    mov       [%rip+pc_api.pccurr],	%r10
    mov       %rax,	%rdi
    shl       %rax,	5
    lea       %r10,	[%rsi + %rax]
    sub       %r10,	256
    mov       [%rip+pc_api.pcend],	%r10
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	5
    mov       %rcx,	[%rip+pc_api.pcstart]
    mov       %rdx,	%rax
    call      mlib.pcm_free
    mov       [%rip+pc_api.pcstart],	%rsi
    mov       [%rip+pc_api.pcalloc],	%rdi
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.newpcl
pc_api.newpcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    cmp       %rax,	[%rip+pc_api.pcend]
    jb        L939
    call      pc_api.extendpclblock
L939:
    add       qword ptr[%rip+pc_api.pccurr],	32
    mov       %eax,	[%rip+pc_decls.mmpos]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+24],	%eax
    inc       qword ptr[%rip+pc_api.pclseqno]
    mov       %rax,	[%rip+pc_api.pclseqno]
    mov       %r10,	[%rip+pc_api.pccurr]
    lea       %r10,	[%r10+28]
    mov       %r9d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r9d,	%r11d
    or        %r9d,	%eax
    mov       [%r10],	%r9d
    inc       qword ptr[%rip+pc_decls.npcl]
    mov       %rax,	[%rip+pc_api.pccurr]
L937:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pc_gen
pc_api.pc_gen:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L942
    call      pc_api.newpcl
    mov       %rbx,	%rax
L942:
    mov       [%rbx],	%dil
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genix
pc_api.pc_genix:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi],	%bl
    mov       [%rdi+16],	%esi
    mov       [%rdi+20],	%r12d
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genx
pc_api.pc_genx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L946
    call      pc_api.newpcl
    mov       %rsi,	%rax
L946:
    mov       [%rsi],	%dil
    mov       [%rsi+16],	%ebx
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genxy
pc_api.pc_genxy:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    test      %r12,	%r12
    jnz       L949
    call      pc_api.newpcl
    mov       %r12,	%rax
L949:
    mov       [%r12],	%dil
    mov       [%r12+16],	%ebx
    mov       [%r12+20],	%esi
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_gencond
pc_api.pc_gencond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L952
    call      pc_api.newpcl
    mov       %rsi,	%rax
L952:
    mov       [%rsi],	%dil
    mov       [%rsi+2],	%bl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genint
pc_api.genint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	4
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L953:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genreal
pc_api.genreal:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    movq      %XMM4,	%XMM15
    movq      [%rdi+8],	%XMM4
    cmp       %rbx,	2
    jnz       L956
    mov       %rax,	5
    jmp       L955
L956:
    mov       %rax,	6
L955:
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L954:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genrealimm
pc_api.genrealimm:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    movq      %XMM4,	%XMM15
    movq      [%rdi+8],	%XMM4
    cmp       %rbx,	2
    jnz       L959
    mov       %rax,	10
    jmp       L958
L959:
    mov       %rax,	11
L958:
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L957:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genstring
pc_api.genstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi+8],	%rax
    mov       %al,	7
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L960:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genpcstrimm
pc_api.genpcstrimm:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi+8],	%rax
    mov       %al,	8
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L961:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genlabel
pc_api.genlabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	3
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L962:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genmem
pc_api.genmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	1
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L963:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genmemaddr
pc_api.genmemaddr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	2
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L964:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.gendata
pc_api.gendata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	12
    mov       [%rdi+1],	%al
    mov       %al,	11
    mov       [%rdi+3],	%al
    mov       [%rdi+4],	%esi
    mov       %rax,	%rdi
L965:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.gencomment
pc_api.gencomment:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jnz       L969
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L968
L969:
    jmp       L966
L968:
    mov       %rcx,	%rdi
    call      pc_api.genpcstrimm
    mov       %rcx,	135
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L966:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.genname
pc_api.genname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rcx,	%rax
    call      pc_api.genmem
L970:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.gennameaddr
pc_api.gennameaddr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rcx,	%rax
    call      pc_api.genmemaddr
L971:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.genassem
pc_api.genassem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	9
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L972:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.strpmode
pc_api.strpmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    lea       %rdx,	[%rip+L10395]
    call      strcpy
    mov       %rax,	%rdi
    cmp       %rax,	11
    jz        L975
    test      %rax,	%rax
    jz        L976
    jmp       L977
L975:
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    lea       %rdx,	[%rip+L10396]
    call      strcpy
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_api.strpmode.str]
    jmp       L974
L976:
    lea       %rax,	[%rip+L10397]
    jmp       L974
L977:
    lea       %rax,	[%rip+pc_tables.pstdnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
L974:
L973:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_setmode
pc_api.pc_setmode:
#?>>
#?]]
#---------------
    mov       %al,	%cl
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+3],	%al
    test      %rdx,	%rdx
    jz        L980
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+4],	%eax
    jmp       L979
L980:
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rax,	[%rip+pc_api.pccurr]
    mov       [%rax+4],	%r10d
L979:
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+pc_tables.pclhastype]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	2
    jnz       L982
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %r10,	[%rip+pc_api.pccurr]
    lea       %r10,	[%r10+28]
    mov       %r9d,	[%r10]
    mov       %r11,	-256
    and       %r9d,	%r11d
    or        %r9d,	%eax
    mov       [%r10],	%r9d
L982:
#---------------
    ret       
# End 
# Proc pc_api.pc_setmode2
pc_api.pc_setmode2:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+28]
    mov       %r10d,	%ecx
    mov       %r9d,	[%rax]
    mov       %r11,	-256
    and       %r9d,	%r11d
    or        %r9d,	%r10d
    mov       [%rax],	%r9d
#---------------
    ret       
# End 
# Proc pc_api.pc_setxy
pc_api.pc_setxy:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setscaleoff
pc_api.pc_setscaleoff:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setoffset
pc_api.pc_setoffset:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_addoffset
pc_api.pc_addoffset:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+20]
    mov       %r10d,	%ecx
    add       [%rax],	%r10d
#---------------
    ret       
# End 
# Proc pc_api.pc_setincr
pc_api.pc_setincr:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnargs
pc_api.pc_setnargs:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnvariadics
pc_api.pc_setnvariadics:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setalign
pc_api.pc_setalign:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.perror
pc_api.perror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      pc_api.perror_s
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.perror_s
pc_api.perror_s:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10398]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    test      %rbx,	%rbx
    jz        L995
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10399]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
L995:
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.getbasename
pc_api.getbasename:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rbx + %rax]
    sub       %r10,	1
    mov       %rdi,	%r10
    jmp       L998
L997:
    dec       %rdi
L998:
    cmp       %rdi,	%rbx
    jbe       L1000
    lea       %rax,	[%rdi-1]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L997
L1000:
    mov       %rax,	%rdi
L996:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pclerror
pc_api.pclerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10400]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addsymbol
pc_api.pc_addsymbol:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_decls.psymboltable]
    test      %rax,	%rax
    jnz       L1004
    mov       %rax,	%rcx
    mov       [%rip+pc_decls.psymboltablex],	%rax
    mov       [%rip+pc_decls.psymboltable],	%rax
    jmp       L1003
L1004:
    mov       %rax,	%rcx
    mov       %r10,	[%rip+pc_decls.psymboltablex]
    mov       [%r10+8],	%rax
    mov       [%rip+pc_decls.psymboltablex],	%rcx
L1003:
#---------------
    ret       
# End 
# Proc pc_api.pc_makesymbol
pc_api.pc_makesymbol:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    inc       qword ptr[%rip+pc_decls.npst]
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    inc       qword ptr[%rip+pc_api.stseqno]
    mov       %rax,	[%rip+pc_api.stseqno]
    mov       [%rdi+120],	%eax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L1007
    cmp       %rax,	7
    jz        L1008
    jmp       L1009
L1007:
    mov       %al,	1
    mov       [%rdi+80],	%al
    jmp       L1006
L1008:
    mov       %al,	1
    mov       [%rdi+81],	%al
    mov       %rsi,	2
L1009:
L1006:
    mov       [%rdi+72],	%sil
    mov       %rax,	%rsi
    cmp       %rax,	4
    jz        L1012
    cmp       %rax,	5
    jnz       L1011
L1012:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    jmp       L1010
L1011:
    test      %rsi,	%rsi
    jz        L1013
    mov       %rcx,	%rdi
    call      pc_api.pc_addsymbol
L1013:
L1010:
    mov       %rax,	%rdi
L1005:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.getfullname
pc_api.getfullname:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	%rsi
    mov       %rbx,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+pc_api.getfullname.str]
    mov       [%r10],	%al
    test      %r12,	%r12
    jz        L1016
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L10401]
    call      strcpy
L1016:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L1018
    test      %r12,	%r12
    jz        L1020
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L10402]
    call      strcat
    jmp       L1019
L1020:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
L1019:
    lea       %rax,	[%rip+pc_api.getfullname.str]
    jmp       L1014
L1018:
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	4
    jz        L1023
    cmp       %rax,	5
    jnz       L1022
L1023:
    mov       %rax,	[%rsi+32]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L10403]
    call      strcat
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_api.getfullname.str]
    jmp       L1014
L1022:
    test      %r12,	%r12
    jz        L1025
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L1024
L1025:
    mov       %rax,	[%rsi]
L1024:
L1014:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcerrorstop
pc_api.pcerrorstop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+L10404]
    lea       %rdx,	[%rip+L10405]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      fclose
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addplib
pc_api.pc_addplib:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	50
    jl        L1029
    lea       %rcx,	[%rip+L10406]
    call      pc_api.perror
L1029:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10407]
    call      mlib.changeext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+pc_decls.nplibfiles]
    mov       %r10,	[%rip+pc_decls.nplibfiles]
    lea       %r11,	[%rip+pc_decls.plibfiles]
    mov       [%r11 + %r10*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_defproc
pc_api.pc_defproc:
#?>>
    .set pc_api.pc_defproc.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jz        L1032
    lea       %rcx,	[%rip+L10408]
    call      pc_api.pclerror
L1032:
    mov       %rcx,	%rdi
    call      pc_api.genmem
    mov       [%rbp + pc_api.pc_defproc.$T1],	%rax
    test      %r12,	%r12
    jz        L1034
    mov       %rax,	121
    jmp       L1033
L1034:
    mov       %rax,	120
L1033:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + pc_api.pc_defproc.$T1]
    call      pc_api.pc_gen
    test      %rbx,	%rbx
    jnz       L1036
    movzx     %rax,	byte ptr[%rdi+82]
    mov       %rbx,	%rax
L1036:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      pc_api.pc_setmode
    mov       %rax,	[%rdi+56]
    test      %rax,	%rax
    jz        L1038
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L10409]
    mov       %rdx,	%rax
    call      pc_api.addstr
    mov       %rcx,	%rax
    call      pc_api.pclerror
L1038:
    mov       %rax,	[%rip+pc_api.pccurr]
    mov       [%rdi+56],	%rax
    mov       %rax,	[%rip+pc_decls.entryproc]
    test      %rax,	%rax
    jnz       L1040
    test      %rsi,	%rsi
    jz        L1040
    mov       [%rip+pc_decls.entryproc],	%rdi
    mov       %al,	1
    mov       [%rdi+83],	%al
L1040:
    mov       [%rip+pc_decls.currfunc],	%rdi
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_setimport
pc_api.pc_setimport:
#?>>
#?]]
#---------------
    mov       [%rip+pc_decls.currfunc],	%rcx
#---------------
    ret       
# End 
# Proc pc_api.pc_addparam
pc_api.pc_addparam:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    test      %rdi,	%rdi
    jnz       L1044
    lea       %rcx,	[%rip+L10410]
    call      pc_api.pclerror
L1044:
    mov       %rbx,	[%rdi+16]
    test      %rbx,	%rbx
    jnz       L1046
    mov       [%rdi+16],	%rsi
    jmp       L1045
L1046:
    jmp       L1048
L1047:
    mov       %rbx,	[%rbx+16]
L1048:
    mov       %rax,	[%rbx+16]
    test      %rax,	%rax
    jnz       L1047
    mov       [%rbx+16],	%rsi
L1045:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jnz       L1051
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rsi+32],	%rax
L1051:
    mov       %rax,	[%rip+pc_decls.currfunc]
    lea       %rax,	[%rax+112]
    inc       byte ptr[%rax]
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addlocal
pc_api.pc_addlocal:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    test      %rdi,	%rdi
    jnz       L1054
    lea       %rcx,	[%rip+L10410]
    call      pc_api.pclerror
L1054:
    mov       %rbx,	[%rdi+24]
    test      %rbx,	%rbx
    jnz       L1056
    mov       [%rdi+24],	%rsi
    jmp       L1055
L1056:
    jmp       L1058
L1057:
    mov       %rbx,	[%rbx+24]
L1058:
    mov       %rax,	[%rbx+24]
    test      %rax,	%rax
    jnz       L1057
    mov       [%rbx+24],	%rsi
L1055:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jnz       L1061
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rsi+32],	%rax
L1061:
    mov       %rax,	[%rip+pc_decls.currfunc]
    lea       %rax,	[%rax+114]
    inc       word ptr[%rax]
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_endproc
pc_api.pc_endproc:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jnz       L1064
    lea       %rcx,	[%rip+L10410]
    call      pc_api.pclerror
L1064:
    mov       %rcx,	122
    xor       %edx,	%edx
    call      pc_api.pc_gen
    xor       %eax,	%eax
    mov       [%rip+pc_decls.currfunc],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.addstr
pc_api.addstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+pc_api.addstr.str]
    mov       %rdx,	%rdi
    call      strcpy
    lea       %rcx,	[%rip+pc_api.addstr.str]
    mov       %rdx,	%rbx
    call      strcat
    lea       %rax,	[%rip+pc_api.addstr.str]
L1065:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.merror
pc_api.merror:
#?>>
    .set pc_api.merror.filename, -8
    .set pc_api.merror.sourceline, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    test      %rax,	%rax
    jz        L1068
    mov       %rcx,	[%rip+pc_decls.mmpos]
    lea       %rdx,	[%rbp + pc_api.merror.filename]
    lea       %r8,	[%rbp + pc_api.merror.sourceline]
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    call      %rax
    mov       %rdi,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10411]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10412]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L1067
L1068:
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+L10413]
    mov       [%rbp + pc_api.merror.filename],	%rax
L1067:
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jz        L1070
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10414]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1070:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10415]
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+pc_decls.ppseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    mov       %rdx,	%rdi
    call      pc_api.pcerrorstop
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_duplpst
pc_api.pc_duplpst:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    push      %rdi
    mov       %r11,	16
L10416:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L10416
    pop       %rdi
    inc       qword ptr[%rip+pc_api.stseqno]
    mov       %rax,	[%rip+pc_api.stseqno]
    mov       [%rdi+120],	%eax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	%rdi
L1071:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_cmdskip
pc_api.pcl_cmdskip:
#?>>
    .set pc_api.pcl_cmdskip.dcmdskip, 24
#?]]
#---------------
    mov       [%rip+pc_decls.pcmdskip],	%rcx
#---------------
    ret       
# End 
# Proc pc_api.convertstring
pc_api.convertstring:
#?>>
    .set pc_api.convertstring.str, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rbx,	%r12
    jmp       L1075
L1074:
    mov       %rax,	%rdi
    cmp       %rax,	34
    jz        L1078
    cmp       %rax,	10
    jz        L1079
    cmp       %rax,	13
    jz        L1080
    cmp       %rax,	9
    jz        L1081
    cmp       %rax,	92
    jz        L1082
    cmp       %rax,	7
    jz        L1083
    cmp       %rax,	8
    jz        L1083
    cmp       %rax,	26
    jz        L1083
    cmp       %rax,	27
    jz        L1083
    jmp       L1084
L1078:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L1077
L1079:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L1077
L1080:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L1077
L1081:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L1077
L1082:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L1077
L1083:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	60
    mov       [%rax],	%r10b
    mov       %rax,	%rdi
    mov       %r10,	10
    cqo       
    idiv      %r10
    add       %rax,	48
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %rax,	%rdi
    mov       %r10,	10
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    add       %rax,	48
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	62
    mov       [%rax],	%r10b
    jmp       L1077
L1084:
    mov       %rax,	%rdi
    cmp       %rax,	32
    jl        L1086
    cmp       %rax,	126
    jg        L1086
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    jmp       L1085
L1086:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	120
    mov       [%rax],	%r10b
    lea       %rcx,	[%rbp + pc_api.convertstring.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10417]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + pc_api.convertstring.str]
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %al,	[%rbp + pc_api.convertstring.str+1]
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
L1085:
L1077:
L1075:
    mov       %rax,	%rsi
    inc       %rsi
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jnz       L1074
    xor       %eax,	%eax
    mov       [%r12],	%al
    mov       %rax,	%r12
    sub       %rax,	%rbx
L1073:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strpcl
pc_diags.strpcl:
#?>>
    .set pc_diags.strpcl.p, 64
    .set pc_diags.strpcl.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	127
    jz        L1089
    cmp       %rax,	128
    jz        L1090
    cmp       %rax,	135
    jz        L1091
    cmp       %rax,	120
    jz        L1092
    cmp       %rax,	121
    jz        L1092
    cmp       %rax,	122
    jz        L1093
    cmp       %rax,	136
    jz        L1094
    cmp       %rax,	125
    jz        L1095
    cmp       %rax,	123
    jz        L1096
    cmp       %rax,	124
    jz        L1096
    jmp       L1097
L1089:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      pc_diags.strlabel
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %eax,	[%rax+16]
    test      %eax,	%eax
    jz        L1099
    lea       %rcx,	[%rip+L10418]
    call      pc_diags.psstr
L1099:
    jmp       L1087
L1090:
    lea       %rcx,	[%rip+L10419]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L10420]
    call      pc_diags.psstr
    jmp       L1087
L1091:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L1101
    lea       %rcx,	[%rip+L10421]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rcx,	[%rax+8]
    call      pc_diags.psstr
    jmp       L1100
L1101:
    lea       %rcx,	[%rip+L10422]
    call      pc_diags.psstr
L1100:
    jmp       L1087
L1092:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %r13,	[%rax+8]
    cmp       %rdi,	121
    jnz       L1103
    lea       %rcx,	[%rip+L10423]
    call      pc_diags.psstr
    jmp       L1102
L1103:
    lea       %rcx,	[%rip+L10424]
    call      pc_diags.psstr
L1102:
    lea       %rcx,	[%rip+L10425]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    call      pc_diags.psname
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %al,	[%rax+81]
    test      %al,	%al
    jz        L1105
    lea       %rax,	[%rip+L10426]
    jmp       L1104
L1105:
    lea       %rax,	[%rip+L10427]
L1104:
    mov       %rcx,	%rax
    call      pc_diags.psstr
    mov       %al,	[%r13+83]
    test      %al,	%al
    jz        L1107
    lea       %rcx,	[%rip+L10427]
    call      pc_diags.psstr
L1107:
    call      pc_diags.psline
    mov       %r14,	[%r13+16]
    jmp       L1111
L1108:
    lea       %rcx,	[%rip+L10428]
    call      pc_diags.psstr
    mov       %eax,	[%r14+84]
    movzx     %r10,	byte ptr[%r14+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L10429]
    call      pc_diags.psstr
    mov       %rcx,	[%r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       %r14,	[%r14+16]
L1111:
    test      %r14,	%r14
    jnz       L1108
    mov       %r14,	[%r13+24]
    jmp       L1115
L1112:
    lea       %rcx,	[%rip+L10430]
    call      pc_diags.psstr
    mov       %eax,	[%r14+84]
    movzx     %r10,	byte ptr[%r14+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L10431]
    call      pc_diags.psstr
    mov       %rcx,	[%r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       %r14,	[%r14+24]
L1115:
    test      %r14,	%r14
    jnz       L1112
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1117
    lea       %rcx,	[%rip+L10432]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    call      pc_diags.psline
L1117:
    mov       %al,	[%r13+113]
    test      %al,	%al
    jz        L1119
    lea       %rcx,	[%rip+L10433]
    call      pc_diags.psstrline
L1119:
    jmp       L1087
L1093:
    lea       %rcx,	[%rip+L10434]
    call      pc_diags.psstr
    call      pc_diags.psline
    jmp       L1087
L1094:
    lea       %rcx,	[%rip+L10435]
    call      pc_diags.psstr
    jmp       L1087
L1095:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+3]
    cmp       %rax,	11
    jnz       L1121
    mov       %rcx,	[%rbp + pc_diags.strpcl.p]
    call      pc_diags.psdata
    jmp       L1087
L1121:
    jmp       L1088
L1096:
    jmp       L1122
L1097:
L1088:
    lea       %rcx,	[%rip+L10436]
    call      pc_diags.psstr
#pc_diags.strpcl.skiptab:
L1122:
    mov       %rax,	%rdi
    cmp       %rax,	26
    jz        L1124
    cmp       %rax,	31
    jz        L1125
    jmp       L1126
L1124:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L10437]
    call      strcpy
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+2]
    lea       %r10,	[%rip+pc_tables.ccnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%r10
    call      strcat
    jmp       L1123
L1125:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L10438]
    call      strcpy
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+2]
    lea       %r10,	[%rip+pc_tables.ccnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%r10
    call      strcat
    jmp       L1123
L1126:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcpy
L1123:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	9
    mov       %r9,	32
    call      mlib.gs_leftstr
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.strpcl.str],	%al
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1128
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %eax,	[%rax+4]
    mov       %r10,	[%rbp + pc_diags.strpcl.p]
    movzx     %r10,	byte ptr[%r10+3]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_tables.pclhastype]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	2
    jnz       L1130
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L10439]
    call      strcat
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+28]
    and       %rax,	255
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1130:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L10440]
    call      strcat
L1128:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	4
    mov       %r9,	32
    call      mlib.gs_leftstr
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.strpcl.str],	%al
    lea       %rax,	[%rip+pc_tables.pclextra]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L1132
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %r12,	%rax
    test      %rsi,	%rsi
    jnz       L1135
    cmp       %rbx,	2
    jnz       L1134
L1135:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L10441]
    call      strcat
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1134:
    cmp       %rbx,	2
    jnz       L1137
    test      %r12,	%r12
    jz        L1137
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L10441]
    call      strcat
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1137:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L10442]
    call      strcat
L1132:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	5
    mov       %r9,	32
    call      mlib.gs_leftstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+1]
    test      %rax,	%rax
    jz        L1139
    lea       %rcx,	[%rip+L10442]
    call      pc_diags.psstr
    mov       %rcx,	[%rbp + pc_diags.strpcl.p]
    call      pc_diags.stropnd
    mov       %rcx,	%rax
    call      pc_diags.psstr
L1139:
    mov       %rcx,	40
    call      pc_diags.pstabto
L1087:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.stropnd
pc_diags.stropnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L1142
    lea       %rax,	[%rip+L10443]
    jmp       L1140
L1142:
    xor       %eax,	%eax
    lea       %r10,	[%rip+pc_diags.stropnd.str]
    mov       [%r10],	%al
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jz        L1144
    cmp       %rax,	5
    jz        L1145
    cmp       %rax,	10
    jz        L1145
    cmp       %rax,	11
    jz        L1145
    cmp       %rax,	6
    jz        L1145
    cmp       %rax,	7
    jz        L1146
    cmp       %rax,	1
    jz        L1147
    cmp       %rax,	2
    jz        L1148
    cmp       %rax,	3
    jz        L1149
    test      %rax,	%rax
    jz        L1150
    cmp       %rax,	9
    jz        L1151
    cmp       %rax,	12
    jz        L1152
    jmp       L1153
L1144:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    jmp       L1140
L1145:
    movq      %XMM4,	[%rsi+8]
    comisd    %XMM4,	[%rip+L10444]
    jnz       L1155
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10445]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L1154
L1155:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L10446]
    call      msys.m$print_r64
    call      msys.m$print_end
L1154:
    jmp       L1143
L1146:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      strlen
    mov       %rdi,	%rax
    cmp       %rax,	256
    jge       L1157
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L10447]
    call      strcpy
    lea       %rax,	[%rip+pc_diags.stropnd.str]
    lea       %rax,	[%rax+1]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.convertstring
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L10447]
    call      strcat
    jmp       L1156
L1157:
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    test      %rax,	%rax
    jz        L1159
    mov       %rcx,	[%rip+pc_diags.stropnd.longstring]
    mov       %rdx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1159:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       [%rip+pc_api.longstringlen],	%rax
    mov       %rcx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_alloc
    mov       [%rip+pc_diags.stropnd.longstring],	%rax
    mov       %al,	34
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       [%r10],	%al
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    lea       %rax,	[%rax+1]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.convertstring
    mov       %rdi,	%rax
    mov       %al,	34
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       %r11,	%rdi
    mov       [%r10 + %r11+1],	%al
    xor       %eax,	%eax
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       %r11,	%rdi
    mov       [%r10 + %r11+2],	%al
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    jmp       L1140
L1156:
    jmp       L1143
L1147:
    mov       %rbx,	[%rsi+8]
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    mov       %rdx,	%rax
    call      strcat
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	123
    jz        L1162
    cmp       %rax,	124
    jnz       L1161
L1162:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L10448]
    call      strcat
    mov       %al,	[%rbx+81]
    test      %al,	%al
    jz        L1164
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L10448]
    call      strcat
L1164:
L1161:
    jmp       L1143
L1148:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L10449]
    call      strcpy
    jmp       L1147
L1149:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10450]
    call      msys.m$print_setfmt
    lea       %rcx,	[%rip+L10451]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rsi+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L1143
L1150:
    lea       %rax,	[%rip+L10452]
    jmp       L1140
L1151:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    jmp       L1140
L1152:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10453]
    call      msys.m$print_setfmt
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rsi+8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L1143
L1153:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10454]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+L10455]
    jmp       L1140
L1143:
    lea       %rax,	[%rip+pc_diags.stropnd.str]
L1140:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strpclstr
pc_diags.strpclstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_free
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    xor       %eax,	%eax
    mov       [%rip+pc_diags.destlinestart],	%rax
    mov       %rcx,	%rdi
    call      pc_diags.strpcl
    mov       %rcx,	[%rip+pc_diags.dest]
    xor       %edx,	%edx
    call      mlib.gs_char
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    cmp       %rax,	%rbx
    jl        L1167
    lea       %rax,	[%rip+L10456]
    jmp       L1165
L1167:
    mov       %rax,	[%rip+pc_diags.dest]
    mov       %rax,	[%rax]
L1165:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepcl
pc_diags.writepcl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_diags.strpcl
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	120
    jnz       L1171
L1170:
    jmp       L1169
L1171:
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_line
L1169:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writeallpcl
pc_diags.writeallpcl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       [%rip+pc_diags.destlinestart],	%rax
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rip+L10457]
    call      mlib.gs_strln
    mov       %rsi,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L1175
L1173:
    lea       %rcx,	[%rip+L10458]
    call      pc_diags.psstr
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8-8]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L10459]
    call      pc_diags.psstr
    call      pc_diags.psline
    inc       %rsi
    cmp       %rsi,	[%rip+pc_decls.nplibfiles]
    jle       L1173
L1175:
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    test      %rax,	%rax
    jz        L1177
    call      pc_diags.psline
L1177:
    mov       %rbx,	[%rip+pc_decls.psymboltable]
    jmp       L1181
L1178:
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	1
    jnz       L1183
    lea       %rcx,	[%rip+L10460]
    call      pc_diags.psstr
    mov       %rcx,	[%rbx]
    call      pc_diags.psstr
    mov       %al,	[%rbx+113]
    test      %al,	%al
    jz        L1185
    lea       %rcx,	[%rip+L10461]
    call      pc_diags.psstr
L1185:
    call      pc_diags.psline
L1183:
    mov       %rbx,	[%rbx+8]
L1181:
    test      %rbx,	%rbx
    jnz       L1178
    mov       %rdi,	[%rip+pc_api.pcstart]
    jmp       L1187
L1186:
    mov       %rcx,	%rdi
    call      pc_diags.writepcl
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       [%rip+pc_diags.destlinestart],	%rax
    add       %rdi,	32
L1187:
    cmp       %rdi,	[%rip+pc_api.pccurr]
    jbe       L1186
    call      pc_diags.psline
    mov       %rax,	[%rip+pc_api.longstring]
    test      %rax,	%rax
    jz        L1190
    mov       %rcx,	[%rip+pc_api.longstring]
    mov       %rdx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1190:
    mov       %rax,	[%rip+pc_diags.dest]
L1172:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psstr
pc_diags.psstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psstrline
pc_diags.psstrline:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_line
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psline
pc_diags.psline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rip+L10462]
    call      mlib.gs_str
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_diags.psint
pc_diags.psint:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rax
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psname
pc_diags.psname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi]
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rax
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.pstabto
pc_diags.pstabto:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    sub       %rax,	[%rip+pc_diags.destlinestart]
    mov       %rdi,	%rax
    jmp       L1198
L1197:
    lea       %rcx,	[%rip+L10463]
    call      pc_diags.psstr
    inc       %rdi
L1198:
    cmp       %rbx,	%rdi
    jg        L1197
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strlabel
pc_diags.strlabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+L10464]
    call      pc_diags.psstr
    mov       %rcx,	%rdi
    call      pc_diags.psint
    test      %rbx,	%rbx
    jz        L1202
    lea       %rcx,	[%rip+L10465]
    call      pc_diags.psstr
L1202:
    lea       %rcx,	[%rip+L10466]
    call      pc_diags.psstr
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psopnd
pc_diags.psopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_diags.stropnd
    mov       %rcx,	%rax
    call      pc_diags.psstr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psdata
pc_diags.psdata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %eax,	[%r13+4]
    mov       %rdi,	%rax
    mov       %rsi,	[%r13+8]
    test      %rdi,	%rdi
    jnz       L1206
    jmp       L1204
L1206:
    jmp       L1208
L1207:
    mov       %rbx,	%rdi
    cmp       %rbx,	20
    jl        L1211
    mov       %rbx,	20
L1211:
    mov       %rax,	%rbx
    sub       %rdi,	%rax
    lea       %rcx,	[%rip+L10467]
    call      pc_diags.psstr
    mov       %rcx,	%rbx
    call      pc_diags.psint
    lea       %rcx,	[%rip+L10468]
    call      pc_diags.psstr
    cmp       %rbx,	10
    jge       L1213
    lea       %rcx,	[%rip+L10469]
    call      pc_diags.psstr
L1213:
    mov       %r12,	%rbx
    cmp       %r12,	0
    jle       L1216
L1214:
    movzx     %rax,	byte ptr[%rsi]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L10469]
    call      pc_diags.psstr
    inc       %rsi
    dec       %r12
    jnz       L1214
L1216:
    test      %rdi,	%rdi
    jz        L1218
    call      pc_diags.psline
L1218:
L1208:
    cmp       %rdi,	0
    jg        L1207
L1204:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepst
pc_diags.writepst:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    xor       %dil,	%dil
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    lea       %rcx,	[%rip+L10470]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       %r12,	[%rip+pc_decls.psymboltable]
    jmp       L1223
L1220:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L10471]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L10472]
    call      pc_diags.psstr
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L10473]
    call      pc_diags.writepsymbol
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	2
    jz        L1226
    cmp       %rax,	1
    jnz       L1225
L1226:
    mov       %r13,	[%r12+16]
    xor       %rsi,	%rsi
    jmp       L1230
L1227:
    lea       %rcx,	[%rip+L10474]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L10475]
    call      pc_diags.writepsymbol
    mov       %r13,	[%r13+16]
L1230:
    test      %r13,	%r13
    jnz       L1227
    mov       %r13,	[%r12+24]
    xor       %rsi,	%rsi
    jmp       L1234
L1231:
    lea       %rcx,	[%rip+L10476]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L10477]
    call      pc_diags.writepsymbol
    mov       %r13,	[%r13+24]
L1234:
    test      %r13,	%r13
    jnz       L1231
L1225:
    call      pc_diags.psline
    mov       %r12,	[%r12+8]
L1223:
    test      %r12,	%r12
    jnz       L1220
    call      pc_diags.psline
    mov       %rax,	[%rip+pc_diags.dest]
L1219:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepsymbol
pc_diags.writepsymbol:
#?>>
    .set pc_diags.writepsymbol.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %dil,	%dil
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       %eax,	[%rsi+120]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10478]
    call      msys.m$print_i64
    movzx     %rax,	byte ptr[%rsi+72]
    lea       %r10,	[%rip+pc_tables.idnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+72]
    lea       %r10,	[%rip+pc_tables.idnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      strlen
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rbx,	%r10
    cmp       %rbx,	0
    jle       L1238
L1236:
    lea       %rcx,	[%rip+L10479]
    call      pc_diags.psstr
    dec       %rbx
    jnz       L1236
L1238:
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.writepsymbol.str],	%al
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      msys.m$print_str
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    mov       %eax,	[%rsi+84]
    movzx     %r10,	byte ptr[%rsi+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1240
    lea       %rcx,	[%rip+L10480]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+112]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L10481]
    call      pc_diags.psstr
    movsx     %rax,	word ptr[%rsi+114]
    mov       %rcx,	%rax
    call      pc_diags.psint
L1240:
    mov       %al,	[%rsi+81]
    test      %al,	%al
    jz        L1242
    lea       %rcx,	[%rip+L10482]
    call      pc_diags.psstr
L1242:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L1244
    lea       %rcx,	[%rip+L10483]
    call      pc_diags.psstr
L1244:
    mov       %al,	[%rsi+107]
    test      %al,	%al
    jz        L1246
    lea       %rcx,	[%rip+L10484]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+107]
    mov       %rcx,	%rax
    call      pc_diags.psint
L1246:
    mov       %al,	[%rsi+108]
    test      %al,	%al
    jz        L1248
    lea       %rcx,	[%rip+L10485]
    call      pc_diags.psstr
L1248:
    mov       %al,	[%rsi+95]
    test      %al,	%al
    jz        L1250
    lea       %rcx,	[%rip+L10486]
    call      pc_diags.psstr
L1250:
    mov       %al,	[%rsi+83]
    test      %al,	%al
    jz        L1252
    lea       %rcx,	[%rip+L10487]
    call      pc_diags.psstr
L1252:
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1254
    lea       %rcx,	[%rip+L10488]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+56]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10489]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
L1254:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jz        L1256
    lea       %rcx,	[%rip+L10490]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+32]
    mov       %eax,	[%rax+120]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L10491]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+32]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L10492]
    call      pc_diags.psstr
L1256:
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1258
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	3
    jnz       L1258
    mov       %rax,	[%rsi+56]
    test      %rax,	%rax
    jz        L1258
    lea       %rcx,	[%rip+L10493]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+56]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L10494]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+24]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10495]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L10496]
    call      pc_diags.psstr
L1258:
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1260
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1260
    movzx     %rax,	byte ptr[%rsi+104]
    shr       %eax,	1
    and       %eax,	1
    test      %rax,	%rax
    jz        L1260
    lea       %rcx,	[%rip+L10497]
    call      pc_diags.psstr
L1260:
    call      pc_diags.psline
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.showprocinfo
pc_diags.showprocinfo:
#?>>
    .set pc_diags.showprocinfo.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rsi+48]
    test      %rdi,	%rdi
    jnz       L1263
    jmp       L1261
L1263:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10498]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10499]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+1]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10500]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+2]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10501]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10502]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10503]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+5]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10504]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+6]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10505]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+7]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       %rbx,	[%rsi+16]
    jmp       L1267
L1264:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10506]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+92]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	byte ptr[%rbx+88]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       %rbx,	[%rbx+16]
L1267:
    test      %rbx,	%rbx
    jnz       L1264
    mov       %rbx,	[%rsi+24]
    jmp       L1271
L1268:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10507]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+92]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	byte ptr[%rbx+88]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       %rbx,	[%rbx+24]
L1271:
    test      %rbx,	%rbx
    jnz       L1268
    call      pc_diags.psline
L1261:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_reduce.pcl_reducetest
pc_reduce.pcl_reducetest:
#?>>
    .set pc_reduce.pcl_reducetest.pcproc, -8
    .set pc_reduce.pcl_reducetest.labelmap, -16
    .set pc_reduce.pcl_reducetest.pdef, -24
    .set pc_reduce.pcl_reducetest.callstack, -280
    .set pc_reduce.pcl_reducetest.ncall, -288
    .set pc_reduce.pcl_reducetest.nprocs, -296
    .set pc_reduce.pcl_reducetest.nleaf, -304
    .set pc_reduce.pcl_reducetest.nallparams, -312
    .set pc_reduce.pcl_reducetest.nalllocals, -320
    .set pc_reduce.pcl_reducetest.av_1, -328
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	360
#---------------
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nprocs],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nleaf],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nallparams],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nalllocals],	%rax
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    inc       %rax
    mov       %rdi,	%rax
    mov       %r13,	[%rip+pc_api.pcstart]
    mov       %rax,	[%rip+pc_api.mlabelno]
    shl       %rax,	1
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rbp + pc_reduce.pcl_reducetest.labelmap],	%rax
    jmp       L1276
L1273:
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	127
    jz        L1278
    cmp       %rax,	42
    jz        L1279
    jmp       L1280
L1278:
    jmp       L1277
L1279:
    mov       %rax,	[%rip+pc_api.icheckasmlabel]
    test      %rax,	%rax
    jz        L1282
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    mov       %r10,	[%rip+pc_api.icheckasmlabel]
    call      %r10
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jz        L1284
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %r10,	%rsi
    lea       %rax,	[%rax + %r10*2-2]
    inc       word ptr[%rax]
L1284:
L1282:
    jmp       L1277
L1280:
    movzx     %rax,	byte ptr[%r13+1]
    cmp       %rax,	3
    jnz       L1286
    mov       %rax,	[%r13+8]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    lea       %r10,	[%r10 + %rax*2-2]
    inc       word ptr[%r10]
L1286:
L1277:
    add       %r13,	32
L1276:
    cmp       %r13,	[%rip+pc_api.pccurr]
    jbe       L1273
#pc_reduce.pcl_reducetest.skip:
    mov       %r13,	[%rip+pc_api.pcstart]
    mov       %rax,	[%rip+pc_api.pcstart]
    sub       %rax,	32
    mov       %r14,	%rax
    xor       %rbx,	%rbx
    mov       %rax,	%rdi
    mov       [%rbp + pc_reduce.pcl_reducetest.av_1],	%rax
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.av_1]
    cmp       %rax,	0
    jle       L1290
L1288:
    lea       %rax,	[%r13+32]
    mov       %r15,	%rax
    movzx     %rax,	byte ptr[%r13]
    lea       %r10,	[%rip+pc_tables.pclargs]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %r12,	%r10
    test      %r10,	%r10
    jz        L1292
    cmp       %r12,	9
    jnz       L1294
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r12,	%rax
L1294:
    mov       %rax,	[%rip+pc_decls.pinfo]
    movzx     %rax,	byte ptr[%rax+4]
    mov       %r10,	%r12
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+4],	%al
L1292:
    movzx     %rax,	byte ptr[%r13+3]
    cmp       %rax,	11
    jnz       L1296
    mov       %rax,	[%rip+pc_decls.pinfo]
    test      %rax,	%rax
    jz        L1296
    mov       %eax,	[%r13+4]
    cmp       %rax,	16
    jz        L1296
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+7],	%al
L1296:
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	135
    jz        L1298
    cmp       %rax,	127
    jz        L1299
    cmp       %rax,	120
    jz        L1300
    cmp       %rax,	121
    jz        L1300
    cmp       %rax,	18
    jz        L1301
    cmp       %rax,	21
    jz        L1301
    cmp       %rax,	19
    jz        L1301
    cmp       %rax,	22
    jz        L1301
    cmp       %rax,	131
    jz        L1302
    cmp       %rax,	122
    jz        L1303
    cmp       %rax,	42
    jz        L1304
    cmp       %rax,	2
    jz        L1305
    cmp       %rax,	5
    jz        L1305
    cmp       %rax,	114
    jz        L1306
    cmp       %rax,	113
    jz        L1307
    cmp       %rax,	1
    jz        L1308
    jmp       L1309
L1298:
    jmp       L1297
L1299:
    mov       %rax,	[%r13+8]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %r10w,	[%r10 + %rax*2-2]
    test      %r10w,	%r10w
    jz        L1311
    jmp       L1309
L1311:
    jmp       L1297
L1300:
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.nprocs]
    mov       %rax,	[%r13+8]
    mov       [%rbp + pc_reduce.pcl_reducetest.pdef],	%rax
    lea       %rax,	[%r14+32]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [%r10+56],	%rax
    mov       %rcx,	8
    call      mlib.pcm_alloc
    mov       [%rip+pc_decls.pinfo],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [%r10+48],	%rax
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+3],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       %al,	[%rax+112]
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+1],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       %ax,	[%rax+114]
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+2],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    movzx     %rax,	byte ptr[%rax+112]
    add       [%rbp + pc_reduce.pcl_reducetest.nallparams],	%rax
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    movsx     %rax,	word ptr[%rax+114]
    add       [%rbp + pc_reduce.pcl_reducetest.nalllocals],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.ncall],	%rax
    lea       %rax,	[%r14+32]
    mov       [%rbp + pc_reduce.pcl_reducetest.pcproc],	%rax
    jmp       L1309
    jmp       L1297
L1301:
    xor       %eax,	%eax
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+3],	%al
    dec       qword ptr[%rbp + pc_reduce.pcl_reducetest.ncall]
    jmp       L1309
    jmp       L1297
L1302:
    add       %r14,	32
    mov       %rax,	%r13
    mov       %r10,	[%rax]
    mov       [%r14],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r14+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r14+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r14+24],	%r10
    inc       %rbx
    mov       %rax,	%rbx
    lea       %r10,	[%r14+28]
    mov       %r8d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r8d,	%r11d
    or        %r8d,	%eax
    mov       [%r10],	%r8d
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.ncall]
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.ncall]
    mov       %r10,	%r14
    mov       [%rbp + %rax*8 + pc_reduce.pcl_reducetest.callstack-8],	%r10
    jmp       L1297
L1303:
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1313
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.nleaf]
L1313:
    xor       %eax,	%eax
    mov       [%rip+pc_decls.pinfo],	%rax
    jmp       L1309
    jmp       L1297
L1304:
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+5],	%al
    jmp       L1309
    jmp       L1297
L1305:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	57
    jnz       L1315
    movzx     %rax,	byte ptr[%r13+3]
    cmp       %rax,	11
    jz        L1315
    mov       %al,	[%r13+3]
    mov       [%r14+3],	%al
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	2
    jnz       L1317
    mov       %rax,	3
    jmp       L1316
L1317:
    mov       %rax,	6
L1316:
    mov       [%r14],	%al
    jmp       L1314
L1315:
    jmp       L1309
L1314:
    jmp       L1297
L1306:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	113
    jnz       L1319
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    movsxd    %r10,	dword ptr[%r15+28]
    and       %r10,	255
    cmp       %rax,	%r10
    jnz       L1319
    add       %r13,	32
    jmp       L1318
L1319:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	28
    jz        L1321
    cmp       %rax,	27
    jnz       L1320
L1321:
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    mov       [%r15+3],	%al
    jmp       L1318
L1320:
    jmp       L1309
L1318:
    jmp       L1297
L1307:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	1
    jz        L1324
    cmp       %rax,	2
    jz        L1324
    cmp       %rax,	3
    jnz       L1323
L1324:
    movzx     %rax,	byte ptr[%r14+3]
    movsxd    %r10,	dword ptr[%r13+28]
    and       %r10,	255
    cmp       %rax,	%r10
    jz        L1322
L1323:
    jmp       L1309
L1322:
    jmp       L1297
L1308:
    movzx     %rax,	byte ptr[%r13+1]
    cmp       %rax,	4
    jnz       L1326
    movzx     %rax,	byte ptr[%r15]
    movzx     %r10,	byte ptr[%r14]
    cmp       %r10,	%rax
    jnz       L1327
    cmp       %r10,	57
    jnz       L1327
    mov       %rax,	1
    jmp       L1328
L1327:
    xor       %eax,	%eax
L1328:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L1326
    mov       %rax,	[%r13+8]
    movsxd    %r10,	dword ptr[%r15+16]
    imul      %rax,	%r10
    movsxd    %r10,	dword ptr[%r15+20]
    add       %rax,	%r10
    lea       %r10,	[%r14+20]
    add       [%r10],	%eax
    add       %r13,	32
    jmp       L1325
L1326:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	11
    jnz       L1329
    add       %r13,	32
    jmp       L1325
L1329:
    jmp       L1309
L1325:
    jmp       L1297
L1309:
    add       %r14,	32
    mov       %rax,	%r13
    mov       %r10,	[%rax]
    mov       [%r14],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r14+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r14+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r14+24],	%r10
    inc       %rbx
    mov       %rax,	%rbx
    lea       %r10,	[%r14+28]
    mov       %r8d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r8d,	%r11d
    or        %r8d,	%eax
    mov       [%r10],	%r8d
    movzx     %rax,	byte ptr[%r14+1]
    cmp       %rax,	2
    jnz       L1331
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	1
    jnz       L1334
    mov       %eax,	[%r14+16]
    test      %eax,	%eax
    jnz       L1333
L1334:
    mov       %rax,	[%r14+8]
    mov       %r10b,	1
    mov       [%rax+88],	%r10b
L1333:
L1331:
L1297:
    add       %r13,	32
    dec       qword ptr[%rbp + pc_reduce.pcl_reducetest.av_1]
    jnz       L1288
L1290:
    mov       [%rip+pc_api.pccurr],	%r14
    mov       %rcx,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %rdx,	[%rip+pc_api.mlabelno]
    call      mlib.pcm_free
#---------------
    add       %rsp,	360
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_run.dispatch_loop
pc_run.dispatch_loop:
#?>>
    .set pc_run.dispatch_loop.pcentry, 72
    .set pc_run.dispatch_loop.cmain, 80
    .set pc_run.dispatch_loop.a, -8
    .set pc_run.dispatch_loop.ptrb, -16
    .set pc_run.dispatch_loop.n, -24
    .set pc_run.dispatch_loop.d, -32
    .set pc_run.dispatch_loop.callstack, -40032
    .set pc_run.dispatch_loop.callstackst, -120032
    .set pc_run.dispatch_loop.callsp, -120040
    .set pc_run.dispatch_loop.str, -120296
    .set pc_run.dispatch_loop.oldsp, -120304
    .set pc_run.dispatch_loop.ncmd, -120312
    .set pc_run.dispatch_loop.cmd, -120320
    .set pc_run.dispatch_loop.lastpos, -120328
    .set pc_run.dispatch_loop.count, -120336
    .set pc_run.dispatch_loop.av_1, -120344
    .set pc_run.dispatch_loop.av_2, -120352
    .set pc_run.dispatch_loop.$T1, -120360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	120392
    mov       [%rbp+72],	%rcx
    mov       [%rbp+80],	%rdx
#---------------
    mov       %rbx,	[%rbp + pc_run.dispatch_loop.pcentry]
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_run.dispatch_loop.callsp],	%rax
    mov       %rcx,	560000
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.cmain]
    test      %rax,	%rax
    jz        L1337
    mov       %rax,	[%rip+msys.ncmdparams]
    mov       [%rbp + pc_run.dispatch_loop.ncmd],	%rax
    mov       %rax,	[%rip+msys.cmdparams]
    mov       [%rbp + pc_run.dispatch_loop.cmd],	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.ncmd]
    sub       %rax,	[%rip+pc_decls.pcmdskip]
    mov       [%rbp + pc_run.dispatch_loop.ncmd],	%rax
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    shl       %rax,	3
    mov       %r10,	[%rbp + pc_run.dispatch_loop.cmd]
    lea       %r10,	[%r10 + %rax]
    mov       [%rbp + pc_run.dispatch_loop.cmd],	%r10
    inc       %rsi
    mov       %rax,	%rsi
    mov       %r10,	[%rbp + pc_run.dispatch_loop.cmd]
    mov       [%rdi + %rax*8-8],	%r10
    mov       %rax,	[%rbp + pc_run.dispatch_loop.ncmd]
    inc       %rax
    inc       %rsi
    mov       %r10,	%rsi
    mov       [%rdi + %r10*8-8],	%rax
    inc       %rsi
    mov       %rax,	%rsi
    xor       %r10d,	%r10d
    mov       [%rdi + %rax*8-8],	%r10
L1337:
    xor       %eax,	%eax
    mov       [%rbp + pc_run.dispatch_loop.lastpos],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_run.dispatch_loop.count],	%rax
    mov       %rax,	[%rip+pc_run.dotrace]
    test      %rax,	%rax
    jz        L1339
    lea       %rax,	[%rip+L10508]
    lea       %r10,	[%rip+pc_run.emptyst]
    mov       [%r10],	%rax
L1339:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1342:
    .quad     L1344
    .quad     L1345
    .quad     L1348
    .quad     L1349
    .quad     L1350
    .quad     L1357
    .quad     L1358
    .quad     L1343
    .quad     L1359
    .quad     L1359
    .quad     L1360
    .quad     L1361
    .quad     L1362
    .quad     L1364
    .quad     L1365
    .quad     L1366
    .quad     L1367
    .quad     L1370
    .quad     L1371
    .quad     L1396
    .quad     L1386
    .quad     L1371
    .quad     L1404
    .quad     L1391
    .quad     L1409
    .quad     L1410
    .quad     L1411
    .quad     L1419
    .quad     L1422
    .quad     L1425
    .quad     L1426
    .quad     L1427
    .quad     L1434
    .quad     L1435
    .quad     L1438
    .quad     L1441
    .quad     L1444
    .quad     L1447
    .quad     L1447
    .quad     L1450
    .quad     L1451
    .quad     L1452
    .quad     L1453
    .quad     L1454
    .quad     L1457
    .quad     L1460
    .quad     L1463
    .quad     L1464
    .quad     L1467
    .quad     L1470
    .quad     L1471
    .quad     L1472
    .quad     L1473
    .quad     L1474
    .quad     L1475
    .quad     L1478
    .quad     L1482
    .quad     L1486
    .quad     L1487
    .quad     L1488
    .quad     L1489
    .quad     L1492
    .quad     L1495
    .quad     L1496
    .quad     L1497
    .quad     L1498
    .quad     L1499
    .quad     L1502
    .quad     L1503
    .quad     L1504
    .quad     L1505
    .quad     L1506
    .quad     L1507
    .quad     L1508
    .quad     L1509
    .quad     L1510
    .quad     L1511
    .quad     L1512
    .quad     L1513
    .quad     L1514
    .quad     L1515
    .quad     L1516
    .quad     L1517
    .quad     L1520
    .quad     L1521
    .quad     L1522
    .quad     L1523
    .quad     L1524
    .quad     L1525
    .quad     L1526
    .quad     L1527
    .quad     L1530
    .quad     L1533
    .quad     L1536
    .quad     L1536
    .quad     L1539
    .quad     L1540
    .quad     L1541
    .quad     L1542
    .quad     L1543
    .quad     L1544
    .quad     L1547
    .quad     L1551
    .quad     L1555
    .quad     L1556
    .quad     L1557
    .quad     L1558
    .quad     L1559
    .quad     L1560
    .quad     L1561
    .quad     L1562
    .quad     L1563
    .quad     L1566
    .quad     L1567
    .quad     L1568
    .quad     L1569
    .quad     L1570
    .quad     L1571
    .quad     L1572
    .quad     L1573
    .quad     L1574
    .quad     L1580
    .quad     L1581
    .quad     L1582
    .quad     L1583
    .quad     L1584
    .quad     L1595
    .quad     L1585
    .quad     L1586
    .quad     L1587
    .quad     L1588
    .quad     L1589
    .quad     L1590
    .quad     L1591
    .quad     L1592
    .quad     L1593
    .quad     L1594
L1344:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1345:
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	4
    jnz       L1347
    mov       %rax,	[%rbx+8]
    inc       %rsi
    mov       %r10,	%rsi
    mov       [%rdi + %r10*8-8],	%rax
    jmp       L1346
L1347:
    lea       %rax,	[%rdi + %r12*8-8]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      pc_runaux.pci_getopnd
    inc       %rsi
    mov       %r10,	%rsi
    mov       [%rdi + %r10*8-8],	%rax
L1346:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1348:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %r10,	[%rdi + %rsi*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1349:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	[%rdi + %rsi*8-8]
    movsxd    %r10,	dword ptr[%rbx+16]
    mov       %r11,	[%rbp + pc_run.dispatch_loop.a]
    imul      %r11,	%r10
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+20]
    lea       %rax,	[%rax + %r10]
    mov       %r13,	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1350:
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	1
    jnz       L1353
L1352:
    mov       %rax,	[%rbx+8]
    mov       [%rbp + pc_run.dispatch_loop.d],	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	3
    jnz       L1355
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    mov       %r13,	[%rax+56]
    jmp       L1354
L1355:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	11
    jnz       L1356
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	5
    jnz       L1356
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    movsxd    %rax,	dword ptr[%rax+76]
    mov       %r10,	%r12
    add       %r10,	%rax
    mov       %r10,	[%rdi + %r10*8-8]
    mov       %r13,	%r10
    jmp       L1354
L1356:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    movsxd    %rax,	dword ptr[%rax+76]
    mov       %r10,	%r12
    add       %r10,	%rax
    lea       %rax,	[%rdi + %r10*8-8]
    mov       %r13,	%rax
L1354:
    mov       %eax,	[%rbx+4]
    movzx     %r10,	byte ptr[%rbx+3]
    mov       %r11,	%rsi
    dec       %rsi
    mov       %r11,	[%rdi + %r11*8-8]
    mov       %rcx,	%r13
    mov       %rdx,	%r11
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      pc_runaux.pci_storeptr
    jmp       L1351
L1353:
    mov       %rcx,	%rbx
    call      pc_runaux.pcusopnd
L1351:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1357:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    mov       %eax,	[%rbx+4]
    movzx     %r10,	byte ptr[%rbx+3]
    mov       %r11,	%rsi
    dec       %rsi
    mov       %r11,	[%rdi + %r11*8-8]
    mov       %rcx,	%r13
    mov       %rdx,	%r11
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1358:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    movsxd    %r10,	dword ptr[%rbx+16]
    mov       %r11,	[%rbp + pc_run.dispatch_loop.a]
    imul      %r11,	%r10
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+20]
    lea       %rax,	[%rax + %r10]
    mov       %r13,	%rax
    mov       %eax,	[%rbx+4]
    movzx     %r10,	byte ptr[%rbx+3]
    mov       %r11,	%rsi
    dec       %rsi
    mov       %r11,	[%rdi + %r11*8-8]
    mov       %rcx,	%r13
    mov       %rdx,	%r11
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1359:
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    inc       %rsi
    mov       %rax,	%rsi
    mov       %r10,	[%rbp + pc_run.dispatch_loop.a]
    mov       [%rdi + %rax*8-8],	%r10
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1360:
    movsxd    %rax,	dword ptr[%rbx+16]
    dec       %rax
    mov       %r10,	%rsi
    sub       %r10,	%rax
    lea       %rax,	[%rdi + %r10*8-8]
    movsxd    %r10,	dword ptr[%rbx+20]
    dec       %r10
    mov       %r11,	%rsi
    sub       %r11,	%r10
    lea       %r10,	[%rdi + %r11*8-8]
    mov       %r11,	[%rax]
    mov       %r15,	[%r10]
    mov       [%r10],	%r11
    mov       [%rax],	%r15
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1361:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1362:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1364:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1365:
    mov       %rax,	[%rdi + %rsi*8-16]
    mov       %r10,	[%rdi + %rsi*8-8]
    mov       %cl,	%r10b
    shr       %rax,	%cl
    and       %eax,	1
    mov       [%rdi + %rsi*8-16],	%rax
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1366:
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       %r10,	[%rdi + %rsi*8-16]
    mov       %r11,	[%rdi + %rsi*8-24]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.pci_loadbf
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	2
    sub       %rsi,	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1367:
    mov       %r13,	[%rdi + %rsi*8-16]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	[%rdi + %rsi*8-24]
    test      %rax,	%rax
    jz        L1369
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       %r10,	1
    mov       %rcx,	%rax
    shl       %r10,	%cl
    or        [%rbp + pc_run.dispatch_loop.a],	%r10
    jmp       L1368
L1369:
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       %r10,	1
    mov       %rcx,	%rax
    shl       %r10,	%cl
    not       %r10
    and       [%rbp + pc_run.dispatch_loop.a],	%r10
L1368:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    mov       %rax,	3
    sub       %rsi,	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1370:
    mov       %r13,	[%rdi + %rsi*8-24]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	[%rdi + %rsi*8-32]
    mov       %r10,	[%rdi + %rsi*8-8]
    mov       %r11,	[%rdi + %rsi*8-16]
    mov       %rcx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %rdx,	%r11
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      pc_runaux.pci_storebf
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    mov       %rax,	4
    sub       %rsi,	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1371:
    mov       %rax,	[%rbx+8]
    mov       [%rbp + pc_run.dispatch_loop.d],	%rax
    mov       %rax,	[%rip+pc_run.dotrace]
    test      %rax,	%rax
    jz        L1373
    mov       %rax,	[%rbp + pc_run.dispatch_loop.callsp]
    mov       [%rbp + pc_run.dispatch_loop.av_1],	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.av_1]
    cmp       %rax,	0
    jle       L1376
L1374:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10509]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       qword ptr[%rbp + pc_run.dispatch_loop.av_1]
    jnz       L1374
L1376:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10510]
    call      msys.m$print_setfmt
    inc       qword ptr[%rip+pc_run.seqno]
    mov       %rcx,	[%rip+pc_run.seqno]
    call      msys.m$print_i64_nf
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      pc_run.getlineno
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1373:
    cmp       %rsi,	69900
    jle       L1378
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10511]
    lea       %r8,	[%rip+L10512]
    call      pc_runaux.pcerrorx
L1378:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    mov       %al,	[%rax+80]
    test      %al,	%al
    jz        L1380
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.n]
    dec       %rax
    sub       %rsi,	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    push      %rax
    movsxd    %rax,	dword ptr[%rbx+20]
    push      %rax
    lea       %rax,	[%rdi + %rsi*8-8]
    mov       %rcx,	[%rbp + pc_run.dispatch_loop.d]
    xor       %edx,	%edx
    mov       %r8,	%rax
    mov       %r9,	[%rbp + pc_run.dispatch_loop.n]
    sub       %rsp,	32
    call      pc_runaux.docalldll
    add       %rsp,	48
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	18
    jnz       L1382
    dec       %rsi
    jmp       L1381
L1382:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    mov       [%rdi + %rsi*8-8],	%rax
L1381:
    add       %rbx,	32
    jmp       L1379
L1380:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    mov       %rax,	[%rax+56]
    test      %rax,	%rax
    jnz       L1383
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10513]
    mov       %r8,	%rax
    call      pc_runaux.pcerrorx
    jmp       L1379
L1383:
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %r10,	%rsi
    sub       %r10,	%rax
    mov       [%rbp + pc_run.dispatch_loop.$T1],	%r10
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	21
    jnz       L1385
    mov       %rax,	1
    jmp       L1384
L1385:
    xor       %eax,	%eax
L1384:
    mov       %r10,	[%rbp + pc_run.dispatch_loop.$T1]
    add       %r10,	%rax
    inc       qword ptr[%rbp + pc_run.dispatch_loop.callsp]
    mov       %rax,	[%rbp + pc_run.dispatch_loop.callsp]
    mov       [%rbp + %rax*4 + pc_run.dispatch_loop.callstack-4],	%r10d
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    mov       %r10,	[%rbp + pc_run.dispatch_loop.callsp]
    mov       [%rbp + %r10*8 + pc_run.dispatch_loop.callstackst-8],	%rax
    lea       %rax,	[%rbx+32]
    movsxd    %r10,	dword ptr[%rbx+16]
    or        %rax,	%r10
    inc       %rsi
    mov       %r10,	%rsi
    mov       [%rdi + %r10*8-8],	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.d]
    mov       %rbx,	[%rax+56]
L1379:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1386:
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    movsxd    %rax,	dword ptr[%rbx+20]
    sub       %rsi,	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r12,	[%rdi + %rax*8-8]
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    mov       %rax,	%r13
    and       %rax,	15
    sub       %rsi,	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.callsp]
    cmp       %rax,	1
    jge       L1388
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10514]
    lea       %r8,	[%rip+L10515]
    call      pc_runaux.pcerrorx
L1388:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.callsp]
    dec       qword ptr[%rbp + pc_run.dispatch_loop.callsp]
    mov       %eax,	[%rbp + %rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [%rbp + pc_run.dispatch_loop.oldsp],	%rax
    cmp       %rsi,	[%rbp + pc_run.dispatch_loop.oldsp]
    jz        L1390
    lea       %rcx,	[%rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10516]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + pc_run.dispatch_loop.str]
    lea       %r8,	[%rip+L10517]
    call      pc_runaux.pcerrorx
L1390:
    mov       %rax,	%r13
    and       %rax,	-16
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1391:
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    movsxd    %rax,	dword ptr[%rbx+20]
    sub       %rsi,	%rax
    dec       %rsi
    mov       %rax,	%rsi
    mov       %r12,	[%rdi + %rax*8-8]
    dec       %rsi
    mov       %rax,	%rsi
    mov       %r13,	[%rdi + %rax*8-8]
    mov       %rax,	%r13
    and       %rax,	15
    sub       %rsi,	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    mov       [%rdi + %rsi*8-8],	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.callsp]
    cmp       %rax,	1
    jge       L1393
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10518]
    lea       %r8,	[%rip+L10519]
    call      pc_runaux.pcerrorx
L1393:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.callsp]
    dec       qword ptr[%rbp + pc_run.dispatch_loop.callsp]
    mov       %eax,	[%rbp + %rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [%rbp + pc_run.dispatch_loop.oldsp],	%rax
    cmp       %rsi,	[%rbp + pc_run.dispatch_loop.oldsp]
    jz        L1395
    lea       %rcx,	[%rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10520]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + pc_run.dispatch_loop.str]
    lea       %r8,	[%rip+L10521]
    call      pc_runaux.pcerrorx
L1395:
    mov       %rax,	%r13
    and       %rax,	-16
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1396:
    mov       %r13,	[%rdi + %rsi*8-8]
    test      %r13,	%r13
    jnz       L1398
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10522]
    lea       %r8,	[%rip+L10523]
    call      pc_runaux.pcerrorx
L1398:
    cmp       %r13,	[%rip+pc_api.pcstart]
    jb        L1400
    cmp       %r13,	[%rip+pc_api.pccurr]
    ja        L1400
#pc_run.dispatch_loop.icallp:
L1401:
    lea       %rax,	[%rsi-1]
    movsxd    %r10,	dword ptr[%rbx+16]
    sub       %rax,	%r10
    mov       [%rbp + pc_run.dispatch_loop.$T1],	%rax
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	22
    jnz       L1403
    mov       %rax,	1
    jmp       L1402
L1403:
    xor       %eax,	%eax
L1402:
    mov       %r10,	[%rbp + pc_run.dispatch_loop.$T1]
    add       %r10,	%rax
    inc       qword ptr[%rbp + pc_run.dispatch_loop.callsp]
    mov       %rax,	[%rbp + pc_run.dispatch_loop.callsp]
    mov       [%rbp + %rax*4 + pc_run.dispatch_loop.callstack-4],	%r10d
    lea       %rax,	[%rip+pc_run.emptyst]
    mov       %r10,	[%rbp + pc_run.dispatch_loop.callsp]
    mov       [%rbp + %r10*8 + pc_run.dispatch_loop.callstackst-8],	%rax
    lea       %rax,	[%rbx+32]
    movsxd    %r10,	dword ptr[%rbx+16]
    or        %rax,	%r10
    mov       [%rdi + %rsi*8-8],	%rax
    mov       %rbx,	%r13
    jmp       L1399
L1400:
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    dec       %rsi
    mov       %rax,	[%rbp + pc_run.dispatch_loop.n]
    dec       %rax
    sub       %rsi,	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    push      %rax
    movsxd    %rax,	dword ptr[%rbx+20]
    push      %rax
    lea       %rax,	[%rdi + %rsi*8-8]
    xor       %ecx,	%ecx
    mov       %rdx,	%r13
    mov       %r8,	%rax
    mov       %r9,	[%rbp + pc_run.dispatch_loop.n]
    sub       %rsp,	32
    call      pc_runaux.docalldll
    add       %rsp,	48
    dec       %rsi
    add       %rbx,	32
L1399:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1404:
    mov       %r13,	[%rdi + %rsi*8-8]
    test      %r13,	%r13
    jnz       L1406
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10524]
    lea       %r8,	[%rip+L10525]
    call      pc_runaux.pcerrorx
L1406:
    cmp       %r13,	[%rip+pc_api.pcstart]
    jb        L1408
    cmp       %r13,	[%rip+pc_api.pccurr]
    jbe       L1401
L1408:
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    dec       %rsi
    mov       %rax,	[%rbp + pc_run.dispatch_loop.n]
    dec       %rax
    sub       %rsi,	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    push      %rax
    movsxd    %rax,	dword ptr[%rbx+20]
    push      %rax
    lea       %rax,	[%rdi + %rsi*8-8]
    xor       %ecx,	%ecx
    mov       %rdx,	%r13
    mov       %r8,	%rax
    mov       %r9,	[%rbp + pc_run.dispatch_loop.n]
    sub       %rsp,	32
    call      pc_runaux.docalldll
    add       %rsp,	48
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
L1407:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1409:
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1410:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rbx,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1411:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1413
    movq      %XMM4,	[%rdi + %rsi*8-8]
    movq      %XMM5,	[%rdi + %rsi*8-16]
    movzx     %rax,	byte ptr[%rbx+2]
    mov       %rcx,	%rax
    movq      %XMM1,	%XMM5
    movq      %XMM2,	%XMM4
    call      pc_runaux.cmpreal
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    jmp       L1412
L1413:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1414
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       %r10,	[%rdi + %rsi*8-16]
    movzx     %r11,	byte ptr[%rbx+2]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.cmpint
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    jmp       L1412
L1414:
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       %r10,	[%rdi + %rsi*8-16]
    movzx     %r11,	byte ptr[%rbx+2]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.cmpword
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
L1412:
    mov       %eax,	[%rbx+16]
    test      %eax,	%eax
    jz        L1416
    mov       %rax,	[%rbp + pc_run.dispatch_loop.n]
    test      %rax,	%rax
    jnz       L1416
    dec       %rsi
    jmp       L1415
L1416:
    mov       %rax,	2
    sub       %rsi,	%rax
L1415:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.n]
    test      %rax,	%rax
    jz        L1418
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    jmp       L1417
L1418:
    add       %rbx,	32
L1417:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1419:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    test      %rax,	%rax
    jz        L1421
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    jmp       L1420
L1421:
    add       %rbx,	32
L1420:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1422:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    test      %rax,	%rax
    jnz       L1424
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    jmp       L1423
L1424:
    add       %rbx,	32
L1423:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1425:
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1426:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1427:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jz        L1429
    cmp       %rax,	1
    jz        L1430
    jmp       L1431
L1429:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10526]
    lea       %r8,	[%rip+L10527]
    call      pc_runaux.pcerrorx
    jmp       L1428
L1430:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10528]
    lea       %r8,	[%rip+L10529]
    call      pc_runaux.pcerrorx
    jmp       L1428
L1431:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1433
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       %r10,	[%rdi + %rsi*8-16]
    movzx     %r11,	byte ptr[%rbx+2]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.cmpint
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    jmp       L1432
L1433:
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       %r10,	[%rdi + %rsi*8-16]
    movzx     %r11,	byte ptr[%rbx+2]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.cmpword
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
L1432:
L1428:
    dec       %rsi
    mov       %rax,	[%rbp + pc_run.dispatch_loop.n]
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1434:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    jmp       L1335
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1435:
    lea       %rax,	[%rdi + %r12*8-8]
    lea       %r10,	[%rbx+32]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_runaux.pci_getopndaddr
    mov       %r13,	%rax
    mov       %rax,	%r13
    dec       qword ptr[%rax]
    mov       %rax,	[%r13]
    test      %rax,	%rax
    jz        L1437
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    jmp       L1436
L1437:
    add       %rbx,	64
L1436:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1438:
    lea       %rax,	[%rdi + %r12*8-8]
    lea       %r10,	[%rbx+32]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_runaux.pci_getopndaddr
    mov       %r13,	%rax
    lea       %rax,	[%rdi + %r12*8-8]
    lea       %r10,	[%rbx+64]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_runaux.pci_getopnd
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %r10,	%r13
    add       [%r10],	%rax
    mov       %rax,	[%r13]
    cmp       %rax,	[%rbp + pc_run.dispatch_loop.n]
    jg        L1440
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    jmp       L1439
L1440:
    add       %rbx,	96
L1439:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1441:
    lea       %rax,	[%rdi + %r12*8-8]
    lea       %r10,	[%rbx+32]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_runaux.pci_getopndaddr
    mov       %r13,	%rax
    lea       %rax,	[%rdi + %r12*8-8]
    lea       %r10,	[%rbx+64]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_runaux.pci_getopnd
    mov       [%rbp + pc_run.dispatch_loop.n],	%rax
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %r10,	%r13
    sub       [%r10],	%rax
    mov       %rax,	[%r13]
    cmp       %rax,	[%rbp + pc_run.dispatch_loop.n]
    jl        L1443
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    jmp       L1442
L1443:
    add       %rbx,	96
L1442:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1444:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	11
    jnz       L1446
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10530]
    lea       %r8,	[%rip+L10531]
    call      pc_runaux.pcerrorx
L1446:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    mov       [%rbp + pc_run.dispatch_loop.ptrb],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	[%rbp + pc_run.dispatch_loop.ptrb]
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       %r14,	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	[%rbp + pc_run.dispatch_loop.ptrb]
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1447:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %r10,	[%rbp + pc_run.dispatch_loop.a]
    cmp       %r10,	%rax
    jl        L1449
    movsxd    %rax,	dword ptr[%rbx+20]
    cmp       %r10,	%rax
    jg        L1449
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+32]
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    shl       %rax,	5
    lea       %r10,	[%r10 + %rax]
    movsxd    %rax,	dword ptr[%rbx+16]
    shl       %rax,	5
    sub       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
    jmp       L1448
L1449:
    lea       %rax,	[%rbx+32]
    mov       %rax,	[%rax+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rbx,	%r10
L1448:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1450:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1451:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1452:
    mov       %eax,	[%rbx+4]
    mov       %r10,	%rsi
    dec       %rsi
    mov       %r10,	[%rdi + %r10*8-8]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	%rax
    call      memset
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1453:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1454:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1456
    movq      %XMM4,	[%rdi + %rsi*8-8]
    lea       %rax,	[%rdi + %rsi*8-16]
    movq      %XMM5,	[%rax]
    addsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    jmp       L1455
L1456:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    add       [%r10],	%rax
L1455:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1457:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1459
    movq      %XMM4,	[%rdi + %rsi*8-8]
    lea       %rax,	[%rdi + %rsi*8-16]
    movq      %XMM5,	[%rax]
    subsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    jmp       L1458
L1459:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    sub       [%r10],	%rax
L1458:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1460:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1462
    movq      %XMM4,	[%rdi + %rsi*8-8]
    lea       %rax,	[%rdi + %rsi*8-16]
    movq      %XMM5,	[%rax]
    mulsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    jmp       L1461
L1462:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    mov       %r11,	[%r10]
    imul      %r11,	%rax
    mov       [%r10],	%r11
L1461:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1463:
    movq      %XMM4,	[%rdi + %rsi*8-16]
    movq      %XMM5,	[%rdi + %rsi*8-8]
    divsd     %XMM4,	%XMM5
    movq      [%rdi + %rsi*8-16],	%XMM4
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1464:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1466
    mov       %rax,	[%rdi + %rsi*8-16]
    mov       %r10,	[%rdi + %rsi*8-8]
    cqo       
    idiv      %r10
    mov       [%rdi + %rsi*8-16],	%rax
    jmp       L1465
L1466:
    mov       %rax,	[%rdi + %rsi*8-16]
    mov       %r10,	[%rdi + %rsi*8-8]
    xor       %edx,	%edx
    div       %r10
    mov       [%rdi + %rsi*8-16],	%rax
L1465:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1467:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1469
    mov       %rax,	[%rdi + %rsi*8-16]
    mov       %r10,	[%rdi + %rsi*8-8]
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rdi + %rsi*8-16],	%rax
    jmp       L1468
L1469:
    mov       %rax,	[%rdi + %rsi*8-16]
    mov       %r10,	[%rdi + %rsi*8-8]
    xor       %edx,	%edx
    div       %r10
    xchg      %rax,	%rdx
    mov       [%rdi + %rsi*8-16],	%rax
L1468:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1470:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1471:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    and       [%r10],	%rax
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1472:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    or        [%r10],	%rax
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1473:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    xor       [%r10],	%rax
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1474:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    mov       %cl,	%al
    shl       qword ptr[%r10],	%cl
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1475:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1477
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    mov       %cl,	%al
    sar       qword ptr[%r10],	%cl
    jmp       L1476
L1477:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    mov       %cl,	%al
    shr       qword ptr[%r10],	%cl
L1476:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1478:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1480
    movq      %XMM4,	[%rdi + %rsi*8-8]
    lea       %rax,	[%rdi + %rsi*8-16]
    movq      %XMM0,	[%rax]
    comisd    %XMM0,	%XMM4
    jbe       L10532
    movq      [%rax],	%XMM4
L10532:
    jmp       L1479
L1480:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1481
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    cmp       [%r10],	%rax
    jle       L10533
    mov       [%r10],	%rax
L10533:
    jmp       L1479
L1481:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    cmp       [%r10],	%rax
    jbe       L10534
    mov       [%r10],	%rax
L10534:
L1479:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1482:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1484
    movq      %XMM4,	[%rdi + %rsi*8-8]
    lea       %rax,	[%rdi + %rsi*8-16]
    movq      %XMM0,	[%rax]
    comisd    %XMM0,	%XMM4
    jae       L10535
    movq      [%rax],	%XMM4
L10535:
    jmp       L1483
L1484:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1485
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    cmp       [%r10],	%rax
    jge       L10536
    mov       [%r10],	%rax
L10536:
    jmp       L1483
L1485:
    mov       %rax,	[%rdi + %rsi*8-8]
    lea       %r10,	[%rdi + %rsi*8-16]
    cmp       [%r10],	%rax
    jae       L10537
    mov       [%r10],	%rax
L10537:
L1483:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1486:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	[%rdi + %rsi*8-8]
    movsxd    %r10,	dword ptr[%rbx+16]
    mov       %r11,	[%rbp + pc_run.dispatch_loop.a]
    imul      %r11,	%r10
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+20]
    lea       %rax,	[%rax + %r10]
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1487:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	[%rdi + %rsi*8-8]
    movsxd    %r10,	dword ptr[%rbx+16]
    mov       %r11,	[%rbp + pc_run.dispatch_loop.a]
    imul      %r11,	%r10
    sub       %rax,	%r11
    movsxd    %r10,	dword ptr[%rbx+20]
    lea       %rax,	[%rax + %r10]
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1488:
    mov       %rax,	[%rdi + %rsi*8-16]
    mov       %r10,	[%rdi + %rsi*8-8]
    sub       %rax,	%r10
    movsxd    %r10,	dword ptr[%rbx+16]
    cqo       
    idiv      %r10
    mov       [%rdi + %rsi*8-16],	%rax
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1489:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1491
    movq      %XMM4,	[%rdi + %rsi*8-8]
    xorpd     %XMM4,	[%rip+L10538]
    movq      [%rdi + %rsi*8-8],	%XMM4
    jmp       L1490
L1491:
    mov       %rax,	[%rdi + %rsi*8-8]
    neg       %rax
    mov       [%rdi + %rsi*8-8],	%rax
L1490:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1492:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1494
    movq      %XMM4,	[%rdi + %rsi*8-8]
    andpd     %XMM4,	[%rip+L10539]
    movq      [%rdi + %rsi*8-8],	%XMM4
    jmp       L1493
L1494:
    mov       %rax,	[%rdi + %rsi*8-8]
    cmp       %rax,	0
    jge       L10540
    neg       %rax
L10540:
    mov       [%rdi + %rsi*8-8],	%rax
L1493:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1495:
    mov       %rax,	[%rdi + %rsi*8-8]
    not       %rax
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1496:
    mov       %rax,	[%rdi + %rsi*8-8]
    xor       %rax,	1
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1497:
    mov       %rax,	[%rdi + %rsi*8-8]
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1498:
    mov       %rax,	[%rdi + %rsi*8-8]
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1499:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1501
    movq      %XMM4,	[%rdi + %rsi*8-8]
    lea       %rax,	[%rdi + %rsi*8-8]
    movq      %XMM5,	[%rax]
    mulsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    jmp       L1500
L1501:
    mov       %rax,	[%rdi + %rsi*8-8]
    imul      %rax,	%rax
    mov       [%rdi + %rsi*8-8],	%rax
L1500:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1502:
    movq      %XMM4,	[%rdi + %rsi*8-8]
    sqrtsd    %XMM4,	%XMM4
    movq      [%rdi + %rsi*8-8],	%XMM4
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1503:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1504:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1505:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1506:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1507:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1508:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1509:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1510:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1511:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1512:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1513:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1514:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1515:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1516:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1517:
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1519
    movq      %XMM4,	[%rdi + %rsi*8-16]
    movq      %XMM5,	[%rdi + %rsi*8-8]
    movq      %XMM0,	%XMM4
    movq      %XMM1,	%XMM5
    call      pow
    movq      [%rdi + %rsi*8-16],	%XMM0
    jmp       L1518
L1519:
    mov       %rax,	[%rdi + %rsi*8-16]
    mov       %r10,	[%rdi + %rsi*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%r10
    call      msys.m$power_i64
    mov       [%rdi + %rsi*8-16],	%rax
L1518:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1520:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1521:
    movzx     %rax,	byte ptr[%rbx+3]
    movsxd    %r10,	dword ptr[%rbx+16]
    mov       %r11,	%rsi
    dec       %rsi
    mov       %r11,	[%rdi + %r11*8-8]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.doincr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1522:
    movzx     %rax,	byte ptr[%rbx+3]
    movsxd    %r10,	dword ptr[%rbx+16]
    neg       %r10
    mov       %r11,	%rsi
    dec       %rsi
    mov       %r11,	[%rdi + %r11*8-8]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.doincr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1523:
    mov       %r13,	[%rdi + %rsi*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    movsxd    %r10,	dword ptr[%rbx+16]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.doincr
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1524:
    mov       %r13,	[%rdi + %rsi*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    movsxd    %r10,	dword ptr[%rbx+16]
    neg       %r10
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.doincr
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1525:
    mov       %r13,	[%rdi + %rsi*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rdi + %rsi*8-8],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    movsxd    %r10,	dword ptr[%rbx+16]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.doincr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1526:
    mov       %r13,	[%rdi + %rsi*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rdi + %rsi*8-8],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    movsxd    %r10,	dword ptr[%rbx+16]
    neg       %r10
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      pc_runaux.doincr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1527:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1529
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    movq      %XMM4,	%rax
    mov       %rax,	%r14
    movq      %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    movq      %rax,	%XMM4
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    jmp       L1528
L1529:
    mov       %rax,	%r14
    add       [%rbp + pc_run.dispatch_loop.a],	%rax
L1528:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1530:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1532
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    movq      %XMM4,	%rax
    mov       %rax,	%r14
    movq      %XMM5,	%rax
    subsd     %XMM4,	%XMM5
    movq      %rax,	%XMM4
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    jmp       L1531
L1532:
    mov       %rax,	%r14
    sub       [%rbp + pc_run.dispatch_loop.a],	%rax
L1531:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1533:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1535
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    movq      %XMM4,	%rax
    mov       %rax,	%r14
    movq      %XMM5,	%rax
    mulsd     %XMM4,	%XMM5
    movq      %rax,	%XMM4
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    jmp       L1534
L1535:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    imul      %rax,	%r14
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
L1534:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1536:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1538
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    movq      %XMM4,	%rax
    mov       %rax,	%r14
    movq      %XMM5,	%rax
    divsd     %XMM4,	%XMM5
    movq      %rax,	%XMM4
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    jmp       L1537
L1538:
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r10,	%r14
    cqo       
    idiv      %r10
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
L1537:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1539:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r10,	%r14
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1540:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    mov       %rax,	%r14
    and       [%rbp + pc_run.dispatch_loop.a],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1541:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    mov       %rax,	%r14
    or        [%rbp + pc_run.dispatch_loop.a],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1542:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    mov       %rax,	%r14
    xor       [%rbp + pc_run.dispatch_loop.a],	%rax
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1543:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    mov       %cl,	%r14b
    shl       qword ptr[%rbp + pc_run.dispatch_loop.a],	%cl
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1544:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1546
    mov       %cl,	%r14b
    sar       qword ptr[%rbp + pc_run.dispatch_loop.a],	%cl
    jmp       L1545
L1546:
    mov       %cl,	%r14b
    shr       qword ptr[%rbp + pc_run.dispatch_loop.a],	%cl
L1545:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1547:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1549
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    movq      %XMM4,	%rax
    mov       %rax,	%r14
    movq      %XMM5,	%rax
    maxss     %XMM4,	%XMM5
    movq      %rax,	%XMM4
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    jmp       L1548
L1549:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1550
    mov       %rax,	%r14
    cmp       [%rbp + pc_run.dispatch_loop.a],	%rax
    jle       L10541
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
L10541:
    jmp       L1548
L1550:
    mov       %rax,	%r14
    cmp       [%rbp + pc_run.dispatch_loop.a],	%rax
    jbe       L10542
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
L10542:
L1548:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1551:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r14,	[%rdi + %rax*8-8]
    movzx     %rax,	byte ptr[%rbx+3]
    cmp       %rax,	2
    jg        L1553
    mov       %rax,	[%rbp + pc_run.dispatch_loop.a]
    movq      %XMM4,	%rax
    mov       %rax,	%r14
    movq      %XMM5,	%rax
    minsd     %XMM4,	%XMM5
    movq      %rax,	%XMM4
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    jmp       L1552
L1553:
    movzx     %rax,	byte ptr[%rbx+3]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1554
    mov       %rax,	%r14
    cmp       [%rbp + pc_run.dispatch_loop.a],	%rax
    jge       L10543
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
L10543:
    jmp       L1552
L1554:
    mov       %rax,	%r14
    cmp       [%rbp + pc_run.dispatch_loop.a],	%rax
    jae       L10544
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
L10544:
L1552:
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + pc_run.dispatch_loop.a]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      pc_runaux.pci_storeptr
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1555:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    movsxd    %r10,	dword ptr[%rbx+16]
    imul      %rax,	%r10
    mov       %r10,	%r13
    add       [%r10],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1556:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    movsxd    %r10,	dword ptr[%rbx+16]
    imul      %rax,	%r10
    mov       %r10,	%r13
    sub       [%r10],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1557:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1558:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1559:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1560:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1561:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1562:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1563:
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1565
    mov       %rax,	[%rdi + %rsi*8-8]
    cvtsi2sd  %XMM4,	%rax
    movq      [%rdi + %rsi*8-8],	%XMM4
    jmp       L1564
L1565:
    mov       %rax,	[%rdi + %rsi*8-8]
    cmp       %rax,	0
    jl        L10545
    cvtsi2sd  %XMM4,	%rax
    jmp       L10546
L10545:
    and       %rax,	[%rip+L10547]
    cvtsi2sd  %XMM4,	%rax
    addsd     %XMM4,	[%rip+L10548]
L10546:
    movq      [%rdi + %rsi*8-8],	%XMM4
L1564:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1566:
    movq      %XMM4,	[%rdi + %rsi*8-8]
    cvttsd2si %rax,	%XMM4
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1567:
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    lea       %r10,	[%rdi + %rsi*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1568:
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    lea       %r10,	[%rdi + %rsi*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1569:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1570:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1571:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1572:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1573:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1574:
    inc       %rsi
    mov       %rax,	%rsi
    mov       %r10,	%r12
    mov       [%rdi + %rax*8-8],	%r10
    mov       %r12,	%rsi
    movsxd    %rax,	dword ptr[%rbx+20]
    add       %rsi,	%rax
    mov       %rax,	[%rip+pc_run.dotrace]
    test      %rax,	%rax
    jz        L1576
    mov       %rax,	[%rbp + pc_run.dispatch_loop.callsp]
    mov       [%rbp + pc_run.dispatch_loop.av_2],	%rax
    mov       %rax,	[%rbp + pc_run.dispatch_loop.av_2]
    cmp       %rax,	0
    jle       L1579
L1577:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10549]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       qword ptr[%rbp + pc_run.dispatch_loop.av_2]
    jnz       L1577
L1579:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10550]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+pc_run.seqno]
    call      msys.m$print_i64_nf
    mov       %rax,	[%rbx+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    mov       %rcx,	%r12
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1576:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1580:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1581:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1582:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1583:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1584:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1585:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1586:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1587:
    mov       %r13,	[%rdi + %rsi*8-8]
    lea       %rax,	[%rbx+32]
    mov       [%r13],	%rax
    mov       [%r13+8],	%rsi
    mov       [%r13+16],	%r12
    xor       %eax,	%eax
    mov       [%rdi + %rsi*8-8],	%rax
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1588:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %rax,	[%rdi + %rax*8-8]
    mov       [%rbp + pc_run.dispatch_loop.a],	%rax
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r13,	[%rdi + %rax*8-8]
    mov       %rbx,	[%r13]
    mov       %rsi,	[%r13+8]
    mov       %r12,	[%r13+16]
    inc       %rsi
    mov       %rax,	%rsi
    mov       %r10,	[%rbp + pc_run.dispatch_loop.a]
    mov       [%rdi + %rax*8-8],	%r10
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1589:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1590:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1591:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1592:
    dec       %rsi
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1593:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1594:
    jmp       L1363
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1595:
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
L1343:
#pc_run.dispatch_loop.unimpl:
L1363:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10551]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10552]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%rbx+28]
    shr       %rax,	8
    and       %rax,	16777215
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
    movzx     %rax,	byte ptr[%rbx]
    lea       %r10,	[%rip+L1342]
    jmp       [%r10 + %rax*8]
    xor       %eax,	%eax
L1335:
#---------------
    add       %rsp,	120392
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_run.fixuppcl
pc_run.fixuppcl:
#?>>
    .set pc_run.fixuppcl.paramslots, -8
    .set pc_run.fixuppcl.localslots, -16
    .set pc_run.fixuppcl.a, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    mov       %rax,	[%rip+pc_api.mlabelno]
    inc       %rax
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+pc_run.labeltable],	%rax
    mov       %rdi,	[%rip+pc_api.pcstart]
    jmp       L1600
L1597:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	120
    jz        L1602
    cmp       %rax,	121
    jnz       L1603
L1602:
    mov       %rax,	[%rdi+8]
    mov       %r10,	%rdi
    mov       [%rax+56],	%r10
L1603:
L1601:
    add       %rdi,	32
L1600:
    cmp       %rdi,	[%rip+pc_api.pccurr]
    jbe       L1597
    mov       %rdi,	[%rip+pc_api.pcstart]
    jmp       L1607
L1604:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	123
    jz        L1609
    cmp       %rax,	124
    jnz       L1610
L1609:
    mov       %rbx,	[%rdi+8]
    mov       %eax,	[%rdi+4]
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rbx+56],	%rax
L1610:
L1608:
    add       %rdi,	32
L1607:
    cmp       %rdi,	[%rip+pc_api.pccurr]
    jbe       L1604
    mov       %rdi,	[%rip+pc_api.pcstart]
    jmp       L1614
L1611:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	123
    jz        L1616
    cmp       %rax,	124
    jz        L1616
    cmp       %rax,	125
    jz        L1617
    cmp       %rax,	120
    jz        L1618
    cmp       %rax,	127
    jz        L1619
    cmp       %rax,	20
    jz        L1620
    cmp       %rax,	23
    jz        L1620
    jmp       L1621
L1616:
    mov       %rax,	[%rdi+8]
    mov       %r13,	[%rax+56]
    jmp       L1615
L1617:
    movzx     %rax,	byte ptr[%rdi+3]
    cmp       %rax,	11
    jz        L1623
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	1
    jz        L1625
    cmp       %rax,	2
    jz        L1626
    jmp       L1627
L1625:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10553]
    lea       %r8,	[%rip+L10554]
    call      pc_runaux.pcerrorx
    jmp       L1624
L1626:
    mov       %rbx,	[%rdi+8]
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	3
    jz        L1629
    cmp       %rax,	2
    jz        L1630
    cmp       %rax,	1
    jz        L1631
    jmp       L1632
L1629:
    mov       %rax,	[%rbx+56]
    mov       [%rbp + pc_run.fixuppcl.a],	%rax
    jmp       L1628
L1630:
    mov       %rax,	[%rbx+56]
    mov       [%rbp + pc_run.fixuppcl.a],	%rax
    jmp       L1628
L1631:
    mov       %rcx,	%rbx
    call      pc_runaux.getdllfnptr
    mov       [%rbp + pc_run.fixuppcl.a],	%rax
    jmp       L1628
L1632:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10555]
    lea       %r8,	[%rip+L10556]
    call      pc_runaux.pcerrorx
L1628:
    mov       %rax,	[%rbp + pc_run.fixuppcl.a]
    test      %rax,	%rax
    jnz       L1634
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10557]
    lea       %r8,	[%rip+L10558]
    call      pc_runaux.pcerrorx
L1634:
    jmp       L1624
L1627:
    mov       %rax,	[%rdi+8]
    mov       [%rbp + pc_run.fixuppcl.a],	%rax
L1624:
    mov       %eax,	[%rdi+4]
    mov       %rcx,	%r13
    lea       %rdx,	[%rbp + pc_run.fixuppcl.a]
    mov       %r8,	%rax
    call      memcpy
    jmp       L1622
L1623:
    mov       %eax,	[%rdi+4]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
L1622:
    mov       %eax,	[%rdi+4]
    add       %r13,	%rax
    jmp       L1615
L1618:
    mov       %rax,	[%rdi+8]
    mov       %rbx,	%rax
    mov       %r12,	%rax
    mov       %rsi,	[%rbx+16]
    xor       %r14,	%r14
    jmp       L1638
L1635:
    mov       %rax,	8
    add       %r14,	%rax
    mov       %rax,	%r14
    sar       %rax,	3
    inc       %rax
    neg       %rax
    mov       [%rsi+76],	%eax
    mov       %rsi,	[%rsi+16]
L1638:
    test      %rsi,	%rsi
    jnz       L1635
    mov       %rsi,	[%rbx+24]
    xor       %r15,	%r15
    jmp       L1642
L1639:
    mov       %rax,	%r15
    sar       %rax,	3
    inc       %rax
    mov       [%rsi+76],	%eax
    mov       %eax,	[%rsi+84]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mlib.roundtoblock
    add       %r15,	%rax
    mov       %rsi,	[%rsi+24]
L1642:
    test      %rsi,	%rsi
    jnz       L1639
    mov       %rax,	%r14
    sar       %rax,	3
    mov       [%rbp + pc_run.fixuppcl.paramslots],	%rax
    mov       [%rdi+16],	%eax
    mov       %rax,	%r15
    sar       %rax,	3
    mov       [%rbp + pc_run.fixuppcl.localslots],	%rax
    mov       [%rdi+20],	%eax
    jmp       L1615
L1619:
    mov       %rax,	[%rdi+8]
    mov       %r10,	%rdi
    mov       %r11,	[%rip+pc_run.labeltable]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L1615
L1620:
    mov       %eax,	[%rbp + pc_run.fixuppcl.paramslots]
    mov       [%rdi+16],	%eax
    mov       %eax,	[%rbp + pc_run.fixuppcl.localslots]
    mov       [%rdi+20],	%eax
L1621:
L1615:
    add       %rdi,	32
L1614:
    cmp       %rdi,	[%rip+pc_api.pccurr]
    jbe       L1611
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_run.pcl_runpcl
pc_run.pcl_runpcl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      pc_runaux.loadlibs
    call      pc_run.fixuppcl
    mov       %rax,	[%rip+pc_decls.entryproc]
    test      %rax,	%rax
    jnz       L1645
    mov       %rcx,	[%rip+pc_api.pcstart]
    lea       %rdx,	[%rip+L10559]
    lea       %r8,	[%rip+L10560]
    call      pc_runaux.pcerrorx
L1645:
    call      pc_runaux.docmdskip
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L1647
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10561]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1647:
    mov       %rax,	[%rip+pc_decls.entryproc]
    movzx     %rax,	byte ptr[%rax+112]
    cmp       %rax,	2
    setz      %al
    movzx     %eax,	%al
    mov       %r10,	[%rip+pc_decls.entryproc]
    mov       %r10,	[%r10+56]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_run.dispatch_loop
    mov       %rdi,	%rax
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L1649
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10562]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L1649:
    mov       %rcx,	%rdi
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_run.getlineno
pc_run.getlineno:
#?>>
    .set pc_run.getlineno.filename, -8
    .set pc_run.getlineno.sourceline, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    test      %rax,	%rax
    jz        L1652
    mov       %eax,	[%rdi+24]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + pc_run.getlineno.filename]
    lea       %r8,	[%rbp + pc_run.getlineno.sourceline]
    mov       %r10,	[%rip+pc_decls.igetmsourceinfo]
    call      %r10
    jmp       L1651
L1652:
    xor       %eax,	%eax
L1651:
L1650:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.pci_getopnd
pc_runaux.pci_getopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    movzx     %rax,	byte ptr[%r12+1]
    cmp       %rax,	4
    jz        L1655
    cmp       %rax,	1
    jz        L1656
    cmp       %rax,	2
    jz        L1657
    cmp       %rax,	7
    jz        L1658
    cmp       %rax,	5
    jz        L1659
    cmp       %rax,	6
    jz        L1659
    cmp       %rax,	3
    jz        L1660
    jmp       L1661
L1655:
    mov       %rdi,	[%r12+8]
    jmp       L1654
L1656:
    mov       %rbx,	[%r12+8]
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	3
    jnz       L1664
L1663:
    mov       %rsi,	[%rbx+56]
    jmp       L1662
L1664:
    movsxd    %rax,	dword ptr[%rbx+76]
    lea       %r10,	[%r13 + %rax*8]
    mov       %rsi,	%r10
    movzx     %rax,	byte ptr[%rbx+82]
    cmp       %rax,	11
    jnz       L1666
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	5
    jnz       L1666
    mov       %rsi,	[%rsi]
L1666:
L1662:
    movzx     %rax,	byte ptr[%r12+3]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      pc_runaux.pci_loadptr
    mov       %rdi,	%rax
    jmp       L1654
L1657:
    mov       %rbx,	[%r12+8]
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	4
    jz        L1668
    cmp       %rax,	5
    jz        L1669
    cmp       %rax,	1
    jz        L1670
    jmp       L1671
L1668:
    movsxd    %rax,	dword ptr[%rbx+76]
    lea       %r10,	[%r13 + %rax*8]
    mov       %rdi,	%r10
    jmp       L1667
L1669:
    movsxd    %rax,	dword ptr[%rbx+76]
    lea       %r10,	[%r13 + %rax*8]
    mov       %rdi,	%r10
    movzx     %rax,	byte ptr[%rbx+82]
    cmp       %rax,	11
    jnz       L1673
    mov       %rsi,	%rdi
    mov       %rdi,	[%rsi]
L1673:
    jmp       L1667
L1670:
    mov       %rcx,	%rbx
    call      pc_runaux.getdllfnptr
    mov       %rdi,	%rax
    jmp       L1667
L1671:
    mov       %rdi,	[%rbx+56]
L1667:
    jmp       L1654
L1658:
    mov       %rdi,	[%r12+8]
    jmp       L1654
L1659:
    movq      %XMM4,	[%r12+8]
    movq      %rax,	%XMM4
    mov       %rdi,	%rax
    jmp       L1654
L1660:
    mov       %rax,	[%r12+8]
    mov       %r10,	[%rip+pc_run.labeltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    jmp       L1654
L1661:
    mov       %rcx,	%r12
    call      pc_runaux.pcusopnd
L1654:
    mov       %rax,	%rdi
L1653:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.pci_loadptr
pc_runaux.pci_loadptr:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rdi,	%rdi
    jnz       L1676
    lea       %rcx,	[%rip+L10563]
    call      pc_api.pclerror
L1676:
    lea       %rax,	[%rbx-1]
    cmp       %rax,	11
    jae       L1679
    lea       %r10,	[%rip+L1678]
    jmp       [%r10 + %rax*8]
    .data
L1678:
    .quad     L1682
    .quad     L1681
    .quad     L1690
    .quad     L1689
    .quad     L1688
    .quad     L1687
    .quad     L1686
    .quad     L1685
    .quad     L1684
    .quad     L1683
    .quad     L1680
    .text
L1680:
    mov       %rax,	%rdi
    jmp       L1677
L1681:
    mov       %rax,	[%rdi]
    jmp       L1677
L1682:
    movd      %XMM4,	[%rdi]
    cvtss2sd  %XMM4,	%XMM4
    movq      %XMM15,	%XMM4
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    jmp       L1677
L1683:
    mov       %rax,	[%rdi]
    jmp       L1677
L1684:
    movsxd    %rax,	dword ptr[%rdi]
    jmp       L1677
L1685:
    movsx     %rax,	word ptr[%rdi]
    jmp       L1677
L1686:
    movsx     %rax,	byte ptr[%rdi]
    jmp       L1677
L1687:
    mov       %rax,	[%rdi]
    jmp       L1677
L1688:
    mov       %eax,	[%rdi]
    jmp       L1677
L1689:
    movzx     %rax,	word ptr[%rdi]
    jmp       L1677
L1690:
    movzx     %rax,	byte ptr[%rdi]
    jmp       L1677
L1679:
    xor       %eax,	%eax
L1677:
L1674:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.pci_storeptr
pc_runaux.pci_storeptr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    test      %rdi,	%rdi
    jnz       L1693
    lea       %rcx,	[%rip+L10563]
    call      pc_api.pclerror
L1693:
    mov       %rax,	%rsi
    cmp       %rax,	11
    jz        L1695
    cmp       %rax,	1
    jz        L1696
    jmp       L1697
L1695:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      memcpy
    jmp       L1694
L1696:
    mov       %rax,	%rbx
    movq      %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM4,	%XMM15
    cvtsd2ss  %XMM4,	%XMM4
    movd      [%rdi],	%XMM4
    jmp       L1694
L1697:
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	8
    jz        L1699
    cmp       %rax,	4
    jz        L1700
    cmp       %rax,	2
    jz        L1701
    jmp       L1702
L1699:
    mov       [%rdi],	%rbx
    jmp       L1698
L1700:
    mov       [%rdi],	%ebx
    jmp       L1698
L1701:
    mov       [%rdi],	%bx
    jmp       L1698
L1702:
    mov       [%rdi],	%bl
L1698:
L1694:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.pci_getopndaddr
pc_runaux.pci_getopndaddr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	1
    jz        L1705
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10564]
    lea       %r8,	[%rip+L10565]
    call      pc_runaux.pcerrorx
L1705:
    mov       %rdi,	[%rbx+8]
    movzx     %rax,	byte ptr[%rdi+72]
    cmp       %rax,	3
    jnz       L1707
    mov       %rax,	[%rdi+56]
    jmp       L1706
L1707:
    movsxd    %rax,	dword ptr[%rdi+76]
    lea       %r10,	[%rsi + %rax*8]
    mov       %rax,	%r10
L1706:
L1703:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.pcerrorx
pc_runaux.pcerrorx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10566]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L10567]
    call      msys.m$print_str_nf
    test      %rdi,	%rdi
    jz        L1710
    movsxd    %rax,	dword ptr[%rdi+28]
    shr       %rax,	8
    and       %rax,	16777215
    jmp       L1709
L1710:
    xor       %eax,	%eax
L1709:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.pcusopnd
pc_runaux.pcusopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10568]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L10569]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi]
    lea       %r10,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%rdi+28]
    shr       %rax,	8
    and       %rax,	16777215
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.docalldll
pc_runaux.docalldll:
#?>>
    .set pc_runaux.docalldll.nvars, 96
    .set pc_runaux.docalldll.retmode, 104
    .set pc_runaux.docalldll.args, -800
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	832
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    test      %r12,	%r12
    jnz       L1714
    mov       %rcx,	%rsi
    call      pc_runaux.getdllfnptr
    mov       %r12,	%rax
L1714:
    mov       %rbx,	%r14
    cmp       %rbx,	1
    jl        L1717
L1715:
    mov       %rax,	[%r13 + %rbx*8-8]
    mov       %r10,	%r14
    sub       %r10,	%rbx
    mov       [%rbp + %r10*8 + pc_runaux.docalldll.args],	%rax
    dec       %rbx
    cmp       %rbx,	1
    jge       L1715
L1717:
    sub       %rsp,	8
    push      0
    mov       %rax,	[%rbp + pc_runaux.docalldll.retmode]
    cmp       %rax,	1
    jz        L1720
    cmp       %rax,	2
    jnz       L1719
L1720:
    mov       %rax,	82
    jmp       L1718
L1719:
    mov       %rax,	73
L1718:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    mov       %r8,	%r14
    lea       %r9,	[%rbp + pc_runaux.docalldll.args]
    sub       %rsp,	32
    call      mwindll.os_calldllfunction
    add       %rsp,	48
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L1712:
#---------------
    add       %rsp,	832
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.getdllfnptr
pc_runaux.getdllfnptr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rdi,	[%r12+56]
    test      %rdi,	%rdi
    jz        L1723
    mov       %rax,	%rdi
    jmp       L1721
L1723:
    mov       %rbx,	[%r12]
    mov       %rsi,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L1727
L1724:
    lea       %rax,	[%rip+pc_decls.plibinst]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    call      mwindows.os_getdllprocaddr
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L1729
    jmp       L1726
L1729:
    inc       %rsi
    cmp       %rsi,	[%rip+pc_decls.nplibfiles]
    jle       L1724
L1727:
    xor       %ecx,	%ecx
    lea       %rdx,	[%rip+L10570]
    mov       %r8,	%rbx
    call      pc_runaux.pcerrorx
L1726:
    mov       [%r12+56],	%rdi
    mov       %rax,	%rdi
L1721:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.loadlibs
pc_runaux.loadlibs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L1733
L1731:
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    call      mwindows.os_getdllinst
    lea       %r10,	[%rip+pc_decls.plibinst]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    lea       %rax,	[%rip+pc_decls.plibinst]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    test      %rax,	%rax
    jnz       L1735
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    xor       %ecx,	%ecx
    lea       %rdx,	[%rip+L10571]
    mov       %r8,	%rax
    call      pc_runaux.pcerrorx
L1735:
    inc       %rdi
    cmp       %rdi,	[%rip+pc_decls.nplibfiles]
    jle       L1731
L1733:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.cmpreal
pc_runaux.cmpreal:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L1738
    cmp       %rax,	2
    jz        L1739
    cmp       %rax,	3
    jz        L1740
    cmp       %rax,	4
    jz        L1741
    cmp       %rax,	5
    jz        L1742
    jmp       L1743
L1738:
    movq      %XMM4,	%XMM1
    comisd    %XMM4,	%XMM2
    setz      %al
    movzx     %eax,	%al
    jmp       L1737
L1739:
    movq      %XMM4,	%XMM1
    comisd    %XMM4,	%XMM2
    setnz     %al
    movzx     %eax,	%al
    jmp       L1737
L1740:
    movq      %XMM4,	%XMM1
    comisd    %XMM4,	%XMM2
    setb      %al
    movzx     %eax,	%al
    jmp       L1737
L1741:
    movq      %XMM4,	%XMM1
    comisd    %XMM4,	%XMM2
    setbe     %al
    movzx     %eax,	%al
    jmp       L1737
L1742:
    movq      %XMM4,	%XMM1
    comisd    %XMM4,	%XMM2
    setae     %al
    movzx     %eax,	%al
    jmp       L1737
L1743:
    movq      %XMM4,	%XMM1
    comisd    %XMM4,	%XMM2
    seta      %al
    movzx     %eax,	%al
L1737:
L1736:
#---------------
    ret       
# End 
# Proc pc_runaux.cmpint
pc_runaux.cmpint:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L1746
    cmp       %rax,	2
    jz        L1747
    cmp       %rax,	3
    jz        L1748
    cmp       %rax,	4
    jz        L1749
    cmp       %rax,	5
    jz        L1750
    jmp       L1751
L1746:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setz      %al
    movzx     %eax,	%al
    jmp       L1745
L1747:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setnz     %al
    movzx     %eax,	%al
    jmp       L1745
L1748:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setl      %al
    movzx     %eax,	%al
    jmp       L1745
L1749:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setle     %al
    movzx     %eax,	%al
    jmp       L1745
L1750:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setge     %al
    movzx     %eax,	%al
    jmp       L1745
L1751:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setg      %al
    movzx     %eax,	%al
L1745:
L1744:
#---------------
    ret       
# End 
# Proc pc_runaux.cmpword
pc_runaux.cmpword:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L1754
    cmp       %rax,	2
    jz        L1755
    cmp       %rax,	3
    jz        L1756
    cmp       %rax,	4
    jz        L1757
    cmp       %rax,	5
    jz        L1758
    jmp       L1759
L1754:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setz      %al
    movzx     %eax,	%al
    jmp       L1753
L1755:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setnz     %al
    movzx     %eax,	%al
    jmp       L1753
L1756:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setb      %al
    movzx     %eax,	%al
    jmp       L1753
L1757:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setbe     %al
    movzx     %eax,	%al
    jmp       L1753
L1758:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    setae     %al
    movzx     %eax,	%al
    jmp       L1753
L1759:
    mov       %rax,	%rdx
    cmp       %rax,	%r8
    seta      %al
    movzx     %eax,	%al
L1753:
L1752:
#---------------
    ret       
# End 
# Proc pc_runaux.doincr
pc_runaux.doincr:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r8
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	8
    jz        L1762
    cmp       %rax,	4
    jz        L1763
    cmp       %rax,	2
    jz        L1764
    jmp       L1765
L1762:
    mov       %rax,	%rcx
    mov       %r10,	%rdx
    add       [%rax],	%r10
    jmp       L1761
L1763:
    mov       %rax,	%rcx
    mov       %r10d,	%edx
    add       [%rax],	%r10d
    jmp       L1761
L1764:
    mov       %rax,	%rcx
    mov       %r10w,	%dx
    add       [%rax],	%r10w
    jmp       L1761
L1765:
    mov       %rax,	%rcx
    mov       %r10b,	%dl
    add       [%rax],	%r10b
L1761:
#---------------
    ret       
# End 
# Proc pc_runaux.docmdskip
pc_runaux.docmdskip:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+pc_decls.psymboltable]
    jmp       L1770
L1767:
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10572]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L1772
    mov       %rax,	[%rdi+56]
    mov       %r10b,	[%rip+pc_decls.pcmdskip]
    mov       [%rax],	%r10b
    jmp       L1769
L1772:
    mov       %rdi,	[%rdi+8]
L1770:
    test      %rdi,	%rdi
    jnz       L1767
L1769:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.pci_loadbf
pc_runaux.pci_loadbf:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    cmp       %r8,	%rdx
    jae       L1775
    mov       %rax,	%rdx
    mov       %r10,	%r8
    mov       %r8,	%rax
    mov       %rdx,	%r10
L1775:
    mov       %rax,	%r8
    sub       %rax,	%rdx
    inc       %rax
    mov       %rbx,	%rax
    mov       %rax,	-1
    push      %rcx
    mov       %cl,	%bl
    shl       %rax,	%cl
    pop       %rcx
    not       %rax
    push      %rcx
    mov       %cl,	%dl
    shl       %rax,	%cl
    pop       %rcx
    mov       %rdi,	%rax
    mov       %rax,	%rcx
    and       %rax,	%rdi
    push      %rcx
    mov       %cl,	%dl
    shr       %rax,	%cl
    pop       %rcx
L1773:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_runaux.pci_storebf
pc_runaux.pci_storebf:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    cmp       %r8,	%rdx
    jae       L1778
    mov       %rax,	%rdx
    mov       %r10,	%r8
    mov       %r8,	%rax
    mov       %rdx,	%r10
L1778:
    mov       %rax,	%r8
    sub       %rax,	%rdx
    inc       %rax
    mov       %rbx,	%rax
    mov       %rax,	-1
    push      %rcx
    mov       %cl,	%bl
    shl       %rax,	%cl
    pop       %rcx
    not       %rax
    push      %rcx
    mov       %cl,	%dl
    shl       %rax,	%cl
    pop       %rcx
    mov       %rdi,	%rax
    mov       %rax,	%r9
    push      %rcx
    mov       %cl,	%dl
    shl       %rax,	%cl
    pop       %rcx
    and       %rax,	%rdi
    mov       %r9,	%rax
    mov       %rax,	%rdi
    not       %rax
    mov       %r10,	%rcx
    and       %r10,	%rax
    or        %r10,	%r9
    mov       %rax,	%r10
L1776:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.genmcl
mc_genmcl.genmcl:
#?>>
    .set mc_genmcl.genmcl.dummy, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.mcldone]
    test      %al,	%al
    jnz       L1779
L1781:
    xor       %eax,	%eax
    test      %ax,	%ax
    jnz       L1784
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1783
L1784:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10573]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1783:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10574]
    call      msys.m$print_str_nf
    mov       %rcx,	27
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_clock
    mov       %rdi,	%rax
    call      mc_genmcl.inithandlers
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10574]
    call      msys.m$print_str_nf
    mov       %rcx,	30
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    call      mc_libmcl.mclinit
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10574]
    call      msys.m$print_str_nf
    mov       %rcx,	32
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rip+pc_api.pcstart]
    mov       [%rip+mc_decls.currpcl],	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10574]
    call      msys.m$print_str_nf
    mov       %rcx,	36
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10575]
    call      mc_libmcl.mgencomment
    xor       %rbx,	%rbx
L1785:
    mov       %rcx,	[%rip+mc_decls.currpcl]
    call      mc_genmcl.convertpcl
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1789
    mov       %rax,	[%rip+mc_decls.currpcl]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	127
    jz        L1789
    cmp       %rax,	135
    jz        L1789
    cmp       %rax,	120
    jz        L1789
    cmp       %rax,	121
    jz        L1789
    cmp       %rax,	20
    jz        L1789
    cmp       %rax,	122
    jz        L1789
    call      mc_stackmcl.showopndstack
L1789:
    add       qword ptr[%rip+mc_decls.currpcl],	32
    mov       %rax,	[%rip+mc_decls.currpcl]
    cmp       %rax,	[%rip+pc_api.pccurr]
    ja        L1790
    mov       %rax,	[%rip+mc_decls.currpcl]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	136
    jnz       L1785
L1790:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10576]
    call      msys.m$print_str_nf
    mov       %rcx,	48
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mc_auxmcl.genrealtable
    call      mc_auxmcl.genabsneg
    call      mc_auxmcl.genstringtable
    mov       %rcx,	8
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	8
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L1792
    call      mc_optim.peephole
L1792:
    mov       %al,	1
    mov       [%rip+pc_decls.mcldone],	%al
    call      mwindows.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.mcltime],	%rax
L1779:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.convertpcl
mc_genmcl.convertpcl:
#?>>
    .set mc_genmcl.convertpcl.oldregset, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rsi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10577]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rsi]
    lea       %r10,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rsi+3]
    mov       [%rip+mc_decls.pmode],	%al
    mov       [%rip+mc_decls.currpcl],	%rsi
    mov       %eax,	[%rsi+24]
    mov       [%rip+pc_decls.mmpos],	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    shr       %rax,	8
    and       %rax,	16777215
    mov       [%rip+pc_decls.ppseqno],	%rax
    movzx     %rax,	byte ptr[%rsi]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rsi
    call      %r10
    lea       %rax,	[%rip+mc_decls.regset]
    lea       %r10,	[%rbp + mc_genmcl.convertpcl.oldregset]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r10],	%XMM4
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L1796
L1794:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L1798
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L1800
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L1799
L1800:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L1799:
L1798:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L1794
L1796:
    mov       %rax,	[%rbp + mc_genmcl.convertpcl.oldregset]
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r10,	[%r10]
    lea       %r11,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%r11]
    or        %r10,	%r11
    mov       %r11,	72340172838076673
    xor       %r10,	%r11
    and       %rax,	%r10
    mov       %r10,	[%rip+mc_decls.mccodex]
    lea       %r10,	[%r10+48]
    or        [%r10],	%rax
    mov       %rax,	[%rbp + mc_genmcl.convertpcl.oldregset+8]
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r10,	[%r10+8]
    lea       %r11,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%r11+8]
    or        %r10,	%r11
    mov       %r11,	72340172838076673
    xor       %r10,	%r11
    and       %rax,	%r10
    mov       %r10,	[%rip+mc_decls.mccodex]
    lea       %r10,	[%r10+56]
    or        [%r10],	%rax
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.inithandlers
mc_genmcl.inithandlers:
#?>>
    .set mc_genmcl.inithandlers.k, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+mc_genmcl.inithandlers.initdone]
    test      %al,	%al
    jnz       L1801
L1803:
    mov       %rsi,	[%rip+$nprocs]
    mov       %r15,	1
    cmp       %rsi,	1
    jl        L1806
L1804:
    lea       %rax,	[%rip+$procname]
    mov       %r10,	%r15
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10578]
    mov       %r8,	3
    call      mlib.eqbytes
    test      %rax,	%rax
    jz        L1808
    xor       %eax,	%eax
    mov       [%rbp + mc_genmcl.inithandlers.k],	%rax
    mov       %r12,	142
    cmp       %r12,	0
    jl        L1812
L1809:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%rbp + mc_genmcl.inithandlers.k]
    mov       %rbx,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	107
    jnz       L1814
    inc       %rbx
L1814:
    lea       %rax,	[%rdi+3]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L1816
    lea       %rax,	[%rip+$procaddr]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r11,	[%rbp + mc_genmcl.inithandlers.k]
    mov       [%r10 + %r11*8],	%rax
    jmp       L1811
L1816:
    mov       %rax,	[%rbp + mc_genmcl.inithandlers.k]
    inc       %rax
    mov       [%rbp + mc_genmcl.inithandlers.k],	%rax
    cmp       %rax,	%r12
    jle       L1809
L1812:
    lea       %rcx,	[%rip+L10579]
    mov       %rdx,	%rdi
    call      pc_api.merror
L1811:
L1808:
    inc       %r15
    cmp       %r15,	%rsi
    jle       L1804
L1806:
    mov       %r15,	1
    mov       %r13,	9
    cmp       %r13,	1
    jl        L1819
L1817:
    lea       %rax,	[%rip+mc_genmcl.inithandlers.dupltable]
    mov       %r10,	%r15
    lea       %rax,	[%rax + %r10*2-2]
    movzx     %rax,	byte ptr[%rax+1]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rax,	[%rip+mc_genmcl.inithandlers.dupltable]
    mov       %r11,	%r15
    lea       %rax,	[%rax + %r11*2-2]
    movzx     %rax,	byte ptr[%rax]
    lea       %r11,	[%rip+mc_genmcl.px_handlertable]
    mov       [%r11 + %rax*8],	%r10
    inc       %r15
    cmp       %r15,	%r13
    jle       L1817
L1819:
    xor       %r15,	%r15
    mov       %rax,	142
    mov       %r14,	%rax
    cmp       %r14,	0
    jl        L1822
L1820:
    lea       %rax,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jnz       L1824
    lea       %rax,	[%rip+mc_genmcl.unimpl]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r11,	%r15
    mov       [%r10 + %r11*8],	%rax
L1824:
    inc       %r15
    cmp       %r15,	%r14
    jle       L1820
L1822:
    mov       %al,	1
    mov       [%rip+mc_genmcl.inithandlers.initdone],	%al
L1801:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.doshowpcl
mc_genmcl.doshowpcl:
#?>>
    .set mc_genmcl.doshowpcl.str, -1256
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	1288
    mov       %rdi,	%rcx
#---------------
    jmp       L1825
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	120
    jz        L1827
    cmp       %rax,	121
    jz        L1827
    cmp       %rax,	20
    jz        L1827
    cmp       %rax,	122
    jz        L1827
    cmp       %rax,	123
    jz        L1827
    cmp       %rax,	124
    jz        L1827
    cmp       %rax,	125
    jnz       L1828
L1827:
    jmp       L1826
L1828:
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    lea       %rdx,	[%rip+L10580]
    call      strcpy
    mov       %rcx,	%rdi
    mov       %rdx,	1256
    call      pc_diags.strpclstr
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    call      mlib.pcm_copyheapstring
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
L1826:
L1825:
#---------------
    add       %rsp,	1288
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.unimpl
mc_genmcl.unimpl:
#?>>
    .set mc_genmcl.unimpl.str, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %rdi,	%rcx
#---------------
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10581]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi]
    lea       %r10,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      mlib.pcm_copyheapstring
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_nop
mc_genmcl.px_nop:
#?>>
    .set mc_genmcl.px_nop.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_genmcl.px_dupl
mc_genmcl.px_dupl:
#?>>
    .set mc_genmcl.px_dupl.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.duplpcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_double
mc_genmcl.px_double:
#?>>
    .set mc_genmcl.px_double.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.ncalldepth]
    test      %rax,	%rax
    jz        L1834
    call      mc_stackmcl.duplpcl
    jmp       L1833
L1834:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	[%rip+mc_decls.noperands]
    lea       %rax,	[%rax + %r10-1]
    inc       byte ptr[%rax]
L1833:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_opnd
mc_genmcl.px_opnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_type
mc_genmcl.px_type:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_comment
mc_genmcl.px_comment:
#?>>
    .set mc_genmcl.px_comment.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_genmcl.px_proc
mc_genmcl.px_proc:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       [%rip+pc_decls.currfunc],	%rax
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	1
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_auxmcl.initproc
    lea       %rcx,	[%rip+L10582]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mclprocentry],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    cmp       %rax,	2
    jnz       L1840
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+83]
    test      %al,	%al
    jz        L1840
    call      mc_auxmcl.fixmain
L1840:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_endproc
mc_genmcl.px_endproc:
#?>>
    .set mc_genmcl.px_endproc.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    test      %rax,	%rax
    jz        L1843
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10583]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10583]
    call      mc_libmcl.mgencomment
L1843:
    mov       %rcx,	2
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_endprog
mc_genmcl.px_endprog:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istatic
mc_genmcl.px_istatic:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+16]
    mov       %rcx,	73
    mov       %rdx,	%rax
    call      mc_libmcl.setsegment
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_zstatic
mc_genmcl.px_zstatic:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	[%rbx+8]
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %rcx,	90
    mov       %rdx,	%rax
    call      mc_libmcl.setsegment
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %eax,	[%rbx+4]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_data
mc_genmcl.px_data:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	11
    jnz       L1849
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_blockdata
    jmp       L1847
L1849:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jz        L1851
    cmp       %rax,	10
    jz        L1852
    cmp       %rax,	11
    jz        L1853
    cmp       %rax,	6
    jz        L1854
    cmp       %rax,	7
    jz        L1855
    cmp       %rax,	2
    jz        L1856
    cmp       %rax,	3
    jz        L1857
    jmp       L1858
L1851:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rdi,	%rax
    jmp       L1850
L1852:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1850
L1853:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1850
L1854:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1850
L1855:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    jmp       L1850
L1856:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+20]
    mov       [%rdi+12],	%eax
    jmp       L1850
L1857:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    jmp       L1850
L1858:
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L10584]
    mov       %rdx,	%r10
    call      pc_api.merror
L1850:
    mov       %eax,	[%rsi+4]
    cmp       %rax,	1
    jz        L1860
    cmp       %rax,	2
    jz        L1861
    cmp       %rax,	4
    jz        L1862
    cmp       %rax,	8
    jz        L1863
    jmp       L1864
L1860:
    mov       %rbx,	116
    jmp       L1859
L1861:
    mov       %rbx,	117
    jmp       L1859
L1862:
    mov       %rbx,	118
    jmp       L1859
L1863:
    mov       %rbx,	119
    jmp       L1859
L1864:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10585]
    call      msys.m$print_str_nf
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L10586]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10587]
    lea       %rdx,	[%rip+L10588]
    call      pc_api.merror
L1859:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1847:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_label
mc_genmcl.px_label:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_load
mc_genmcl.px_load:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_stackmcl.pushpcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_store
mc_genmcl.px_store:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	11
    jz        L1869
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1868
L1869:
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rbx,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
L1868:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_add
mc_genmcl.px_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1872
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1874
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    cmp       %rax,	1
    jnz       L1874
    mov       %rcx,	52
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1873
L1874:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1873:
    jmp       L1871
L1872:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	65
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1871:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sub
mc_genmcl.px_sub:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1877
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1879
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    cmp       %rax,	1
    jnz       L1879
    mov       %rcx,	53
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1878
L1879:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1878:
    jmp       L1876
L1877:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	67
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1876:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_mul
mc_genmcl.px_mul:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1882
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1884
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    jmp       L1883
L1884:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	34
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1883:
    jmp       L1881
L1882:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	69
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1881:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_div
mc_genmcl.px_div:
#?>>
    .set mc_genmcl.px_div.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	71
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_eval
mc_genmcl.px_eval:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_widen
mc_genmcl.px_widen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	6
    jnz       L1889
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    cmp       %rax,	5
    jnz       L1889
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	5
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	11
    jz        L1891
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1891:
    jmp       L1888
L1889:
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1893
    mov       %rax,	18
    jmp       L1892
L1893:
    mov       %rax,	19
L1892:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1888:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jump
mc_genmcl.px_jump:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rsi+8]
    lea       %rax,	[%rsi+32]
    mov       %rbx,	%rax
    jmp       L1896
L1895:
    add       %rbx,	32
L1896:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	135
    jz        L1895
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	127
    jz        L1899
    cmp       %rax,	24
    jz        L1900
    jmp       L1901
L1899:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rdi
    jz        L1894
L1903:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	127
    jnz       L1905
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rdi
    jz        L1894
L1905:
    jmp       L1898
L1900:
    xor       %eax,	%eax
    mov       [%rbx],	%al
L1901:
L1898:
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1894:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_ijump
mc_genmcl.px_ijump:
#?>>
    .set mc_genmcl.px_ijump.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_neg
mc_genmcl.px_neg:
#?>>
    .set mc_genmcl.px_neg.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1909
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1908
L1909:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_negreal
L1908:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_abs
mc_genmcl.px_abs:
#?>>
    .set mc_genmcl.px_abs.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1912
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	26
    mov       %rdx,	13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1911
L1912:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_absreal
L1911:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnot
mc_genmcl.px_bitnot:
#?>>
    .set mc_genmcl.px_bitnot.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	51
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_not
mc_genmcl.px_not:
#?>>
    .set mc_genmcl.px_not.p, 24
    .set mc_genmcl.px_not.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	1
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_not.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	40
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_not.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolt
mc_genmcl.px_toboolt:
#?>>
    .set mc_genmcl.px_toboolt.$T2, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r13,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    mov       %r12b,	%al
    movzx     %rax,	%r12b
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	%r12b
    cmp       %rax,	2
    jg        L1917
    movzx     %rax,	%r12b
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	3
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    movzx     %rax,	%r12b
    dec       %rax
    mov       %r10,	76
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	%r12b
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	64
    jnz       L1919
    mov       %rax,	5
    jmp       L1918
L1919:
    mov       %rax,	4
L1918:
    mov       %rcx,	58
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rsi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    jmp       L1916
L1917:
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       [%rbp + mc_genmcl.px_toboolt.$T2],	%rax
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	64
    jnz       L1921
    mov       %rax,	5
    jmp       L1920
L1921:
    mov       %rax,	4
L1920:
    mov       %rcx,	58
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_toboolt.$T2]
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-3],	%al
L1916:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sqr
mc_genmcl.px_sqr:
#?>>
    .set mc_genmcl.px_sqr.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1924
    mov       %rcx,	34
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1923
L1924:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	69
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1923:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sqrt
mc_genmcl.px_sqrt:
#?>>
    .set mc_genmcl.px_sqrt.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	63
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpcc
mc_genmcl.px_jumpcc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.ucondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1928
    lea       %rcx,	[%rip+L10589]
    lea       %rdx,	[%rip+L10590]
    call      pc_api.merror
    jmp       L1927
L1928:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1930
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1932
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jnz       L1932
    movzx     %rax,	byte ptr[%r13+2]
    cmp       %rax,	1
    jz        L1933
    cmp       %rax,	2
    jnz       L1932
L1933:
    mov       %rcx,	41
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1931
L1932:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1935
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.scondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
L1935:
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1931:
    jmp       L1929
L1930:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1929:
    mov       %rcx,	26
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
    mov       %eax,	[%r13+16]
    test      %eax,	%eax
    jnz       L1937
    call      mc_stackmcl.poppcl
L1937:
L1927:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpt
mc_genmcl.px_jumpt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	5
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpf
mc_genmcl.px_jumpf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitand
mc_genmcl.px_bitand:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	38
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitor
mc_genmcl.px_bitor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	39
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxor
mc_genmcl.px_bitxor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	40
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shl
mc_genmcl.px_shl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	43
    call      mc_auxmcl.do_shift
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shr
mc_genmcl.px_shr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1946
    mov       %rax,	44
    jmp       L1945
L1946:
    mov       %rax,	45
L1945:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_shift
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_retproc
mc_genmcl.px_retproc:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.mclprocentry]
    cmp       %rax,	[%rip+mc_decls.mccodex]
    jnz       L1949
    lea       %rcx,	[%rip+L10591]
    call      mc_libmcl.mgencomment
L1949:
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_procentry
    call      mc_auxmcl.do_procexit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_retfn
mc_genmcl.px_retfn:
#?>>
    .set mc_genmcl.px_retfn.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1952
    mov       %rcx,	1
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       [%r10],	%al
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+pc_decls.blockretname]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    mov       %rcx,	[%rip+pc_decls.blockretname]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_genmcl.px_retfn.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_retfn.$T1]
    call      mc_libmcl.genmc
L1952:
    mov       %rcx,	%rsi
    call      mc_genmcl.px_retproc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setcall
mc_genmcl.px_setcall:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_stackmcl.saveopnds
    mov       %rax,	[%rip+mc_decls.ncalldepth]
    cmp       %rax,	32
    jl        L1955
    lea       %rcx,	[%rip+L10592]
    lea       %rdx,	[%rip+L10593]
    call      pc_api.merror
L1955:
    inc       qword ptr[%rip+mc_decls.ncalldepth]
    movsxd    %rax,	dword ptr[%rdi+16]
    cmp       %rax,	4
    jg        L1957
    mov       %eax,	[%rip+mc_decls.mstackdepth]
    and       %eax,	1
    lea       %r10,	[%rip+mc_decls.callalign]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
    jmp       L1956
L1957:
    movsxd    %rax,	dword ptr[%rdi+16]
    and       %eax,	1
    mov       %r10d,	[%rip+mc_decls.mstackdepth]
    and       %r10d,	1
    xor       %rax,	%r10
    lea       %r10,	[%rip+mc_decls.callalign]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
L1956:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    setz      %al
    movzx     %eax,	%al
    lea       %r10,	[%rip+mc_decls.callblockret]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
    mov       %eax,	[%rdi+4]
    lea       %r10,	[%rip+mc_decls.callblocksize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11*4-4],	%eax
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1959
    mov       %rcx,	1
    call      mc_libmcl.pushslots
L1959:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setarg
mc_genmcl.px_setarg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+16]
    lea       %r10,	[%rip+mc_decls.callblockret]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    add       %rax,	%r10
    mov       %rdi,	%rax
    cmp       %rdi,	4
    jle       L1962
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1964
    mov       %eax,	[%rbx+4]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_auxmcl.copyblockarg
L1964:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.pushopnd
    jmp       L1961
L1962:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1965
    mov       %eax,	[%rbx+4]
    lea       %r10,	[%rip+mc_decls.callargsize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    shl       %r11,	4
    lea       %r10,	[%r10 + %r11-16]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*4-4],	%eax
L1965:
L1961:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_callp
mc_genmcl.px_callp:
#?>>
    .set mc_genmcl.px_callp.p, 72
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+72],	%rcx
#---------------
    xor       %r12,	%r12
    xor       %eax,	%eax
    mov       %r13,	%rax
    lea       %rax,	[%rip+mc_decls.callblockret]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movsxd    %rax,	dword ptr[%rax+16]
    add       %rax,	%r14
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    mov       %r10,	4
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	19
    jz        L1969
    cmp       %rax,	22
    jnz       L1968
L1969:
    mov       %r12,	1
L1968:
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_auxmcl.do_pushlowargs
    xor       %rsi,	%rsi
    mov       %rax,	%rdi
    cmp       %rax,	4
    jg        L1971
    mov       %rax,	[%rip+mc_decls.mstackdepth]
    test      %rax,	%rax
    jz        L1973
    mov       %rax,	4
    add       %rsi,	%rax
    mov       %rcx,	4
    call      mc_libmcl.pushslots
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    add       %rsi,	%rax
    jmp       L1972
L1973:
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
L1972:
    jmp       L1970
L1971:
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r10,	%rdi
    add       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	4
    call      mc_libmcl.pushslots
L1970:
    test      %r12,	%r12
    jz        L1975
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1974
L1975:
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1974:
    mov       %rax,	%rbx
    sub       %rax,	%r14
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L1978
L1976:
    call      mc_stackmcl.poppcl
    dec       %r15
    jnz       L1976
L1978:
    test      %rsi,	%rsi
    jz        L1980
    mov       %rcx,	%rsi
    call      mc_libmcl.popslots
L1980:
    mov       %al,	[%rip+mc_decls.pmode]
    test      %al,	%al
    jz        L1982
    mov       %rcx,	[%rbp + mc_genmcl.px_callp.p]
    call      mc_auxmcl.do_getretvalue
L1982:
    dec       qword ptr[%rip+mc_decls.ncalldepth]
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpret
mc_genmcl.px_jumpret:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %al,	[%rip+mc_decls.pmode]
    test      %al,	%al
    jz        L1985
    mov       %rax,	[%rip+mc_decls.noperands]
    test      %rax,	%rax
    jz        L1987
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    mov       %r8,	1
    call      mc_stackmcl.loadparam
    call      mc_stackmcl.poppcl
L1987:
L1985:
    mov       %rcx,	%rdi
    call      mc_genmcl.px_jump
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpretm
mc_genmcl.px_jumpretm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	%rax
    inc       %r10
    mov       %rdi,	%r10
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L1991
L1989:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    inc       %rdi
    dec       %rsi
    jnz       L1989
L1991:
    mov       %rbx,	1
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r12,	%rax
    cmp       %r12,	0
    jle       L1994
L1992:
    cmp       %rbx,	4
    jnz       L1996
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jle       L1996
    mov       %rbx,	11
L1996:
    mov       %rcx,	%rbx
    call      mc_stackmcl.movetoreg
    call      mc_stackmcl.poppcl
    inc       %rbx
    dec       %r12
    jnz       L1992
L1994:
    mov       %rcx,	%r13
    call      mc_genmcl.px_jump
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_startmx
mc_genmcl.px_startmx:
#?>>
    .set mc_genmcl.px_startmx.p, 16
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_stackmcl.saveopnds
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_resetmx
mc_genmcl.px_resetmx:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	1
    call      mc_stackmcl.movetoreg
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	118
    jnz       L2000
    call      mc_stackmcl.poppcl
L2000:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_stop
mc_genmcl.px_stop:
#?>>
    .set mc_genmcl.px_stop.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    lea       %rcx,	[%rip+L10594]
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_incrto
mc_genmcl.px_incrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_incr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_decrto
mc_genmcl.px_decrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_incr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_incrload
mc_genmcl.px_incrload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_incrload
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_decrload
mc_genmcl.px_decrload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_incrload
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadincr
mc_genmcl.px_loadincr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_loadincr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loaddecr
mc_genmcl.px_loaddecr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_loadincr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_forup
mc_genmcl.px_forup:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    mov       %r9,	14
    call      mc_auxmcl.do_for
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fordown
mc_genmcl.px_fordown:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    mov       %r9,	13
    call      mc_auxmcl.do_for
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iload
mc_genmcl.px_iload:
#?>>
    .set mc_genmcl.px_iload.p, 40
    .set mc_genmcl.px_iload.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jz        L2012
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2014
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    jmp       L2013
L2014:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
L2013:
    mov       %rax,	[%rip+mc_decls.currpcl]
    lea       %rax,	[%rax+32]
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	114
    jnz       L2016
    movzx     %rax,	byte ptr[%rsi+3]
    mov       [%rbp + mc_genmcl.px_iload.$T1],	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    lea       %r10,	[%rip+mc_decls.ploadop]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rsi+3]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    mov       [%rip+mc_decls.currpcl],	%rsi
    jmp       L2015
L2016:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_iload.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L2015:
    jmp       L2011
L2012:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind_simp
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.dolea
L2011:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.getsharereg
mc_genmcl.getsharereg:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %dil,	[%rcx+10]
    mov       %bl,	[%rcx+11]
    cmp       %rdx,	2
    jg        L2019
    xor       %eax,	%eax
    jmp       L2017
L2019:
    test      %dil,	%dil
    jz        L2021
    movzx     %rax,	%dil
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r10b,	[%r10 + %rax-1]
    test      %r10b,	%r10b
    jnz       L2022
    movzx     %rax,	%dil
    cmp       %rax,	11
    jl        L2021
    cmp       %rax,	14
    jg        L2021
L2022:
    movzx     %rax,	%dil
    jmp       L2017
L2021:
    test      %bl,	%bl
    jz        L2023
    movzx     %rax,	%bl
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r10b,	[%r10 + %rax-1]
    test      %r10b,	%r10b
    jnz       L2024
    movzx     %rax,	%dil
    cmp       %rax,	11
    jl        L2023
    cmp       %rax,	14
    jg        L2023
L2024:
    movzx     %rax,	%bl
    jmp       L2017
L2023:
L2020:
    xor       %eax,	%eax
L2017:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iloadx
mc_genmcl.px_iloadx:
#?>>
    .set mc_genmcl.px_iloadx.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      mc_auxmcl.do_addrmode
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L2027
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
    jmp       L2026
L2027:
    mov       %rax,	[%rip+mc_decls.currpcl]
    lea       %rax,	[%rax+32]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	114
    jnz       L2029
    movzx     %rax,	byte ptr[%rdi+3]
    mov       [%rbp + mc_genmcl.px_iloadx.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+28]
    and       %rax,	255
    lea       %r10,	[%rip+mc_decls.ploadop]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rdi+3]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    mov       [%rip+mc_decls.currpcl],	%rdi
    jmp       L2028
L2029:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_iloadx.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L2028:
L2026:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istore
mc_genmcl.px_istore:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2032
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    jmp       L2031
L2032:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
L2031:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L2034
    mov       %rcx,	%rbx
    call      mc_stackmcl.makesimpleaddr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2033
L2034:
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2033:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istorex
mc_genmcl.px_istorex:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_addrmode
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L2037
    mov       %rcx,	%rbx
    call      mc_stackmcl.makesimpleaddr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2036
L2037:
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2036:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storem
mc_genmcl.px_storem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %eax,	[%r12+4]
    cmp       %rax,	16
    jz        L2040
    lea       %rcx,	[%rip+L10595]
    lea       %rdx,	[%rip+L10596]
    call      pc_api.merror
L2040:
    mov       %rcx,	16
    call      mc_libmcl.newblocktemp
    mov       %rsi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addpx
mc_genmcl.px_addpx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_addrmode
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subpx
mc_genmcl.px_subpx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+16]
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%r14+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %r13,	%rax
    test      %rax,	%rax
    jz        L2044
    mov       %rax,	[%r13+8]
    mov       %r10,	%rdi
    imul      %rax,	%r10
    add       %rax,	%rbx
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2043
L2044:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r12,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_auxmcl.scaleindex
    mov       %rdi,	%rax
    cmp       %rdi,	1
    jle       L2046
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_auxmcl.mulimm
L2046:
    mov       %rcx,	29
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    test      %rbx,	%rbx
    jz        L2048
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10597]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10598]
    lea       %rdx,	[%rip+L10599]
    call      pc_api.merror
L2048:
L2043:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_to
mc_genmcl.px_to:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rsi+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rdi,	%rax
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rbx,	%rax
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iswap
mc_genmcl.px_iswap:
#?>>
    .set mc_genmcl.px_iswap.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jz        L2052
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L2051
L2052:
    lea       %rcx,	[%rip+L10600]
    lea       %rdx,	[%rip+L10601]
    call      pc_api.merror
L2051:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_swapstk
mc_genmcl.px_swapstk:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+20]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	%rax
    inc       %r10
    movsxd    %rax,	dword ptr[%rdi+16]
    mov       %r11,	[%rip+mc_decls.noperands]
    sub       %r11,	%rax
    inc       %r11
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    call      mc_stackmcl.swapopnds
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_labeldef
mc_genmcl.px_labeldef:
#?>>
    .set mc_genmcl.px_labeldef.str, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    lea       %rdx,	[%rip+L10602]
    call      strcat
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addto
mc_genmcl.px_addto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	28
    mov       %r8,	65
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subto
mc_genmcl.px_subto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	29
    mov       %r8,	67
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_multo
mc_genmcl.px_multo:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L2059
    mov       %rcx,	%r13
    mov       %rdx,	69
    call      mc_auxmcl.do_binto_float
    jmp       L2057
L2059:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	1
    jnz       L2061
    lea       %rcx,	[%rip+L10603]
    lea       %rdx,	[%rip+L10604]
    call      pc_api.merror
L2061:
    mov       %rcx,	10
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L2063
    mov       %rax,	[%r12+8]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    jmp       L2062
L2063:
    mov       %rcx,	34
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2062:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2057:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitandto
mc_genmcl.px_bitandto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	38
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitorto
mc_genmcl.px_bitorto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	39
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxorto
mc_genmcl.px_bitxorto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	40
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shlto
mc_genmcl.px_shlto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	43
    call      mc_auxmcl.do_shiftnto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shrto
mc_genmcl.px_shrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2070
    mov       %rax,	44
    jmp       L2069
L2070:
    mov       %rax,	45
L2069:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_shiftnto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fix
mc_genmcl.px_fix:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.pmin]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    dec       %rax
    mov       %r10,	84
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_float
mc_genmcl.px_float:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+28]
    and       %rax,	255
    mov       %r13b,	%al
    movzx     %rax,	%r13b
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	%r13b
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	4
    jge       L2074
    lea       %rcx,	[%rip+L10605]
    lea       %rdx,	[%rip+L10606]
    call      pc_api.merror
L2074:
    movzx     %rax,	%r13b
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2076
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%r14+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	86
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2075
L2076:
    movzx     %rax,	%r13b
    cmp       %rax,	6
    jnz       L2077
    mov       %rcx,	2
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    call      mc_libmcl.mcreatefwdlabel
    mov       %rsi,	%rax
    call      mc_libmcl.mcreatefwdlabel
    mov       %r12,	%rax
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	12
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%rsi
    call      mc_libmcl.mdefinefwdlabel
    mov       %rax,	[%rip+mc_decls.labmask63]
    test      %rax,	%rax
    jnz       L2079
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.labmask63],	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.laboffset64],	%rax
L2079:
    mov       %rcx,	[%rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	66
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mdefinefwdlabel
#mc_genmcl.px_float.reduce:
L2080:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	1
    jnz       L2082
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	88
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L2082:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2075
L2077:
    mov       %rcx,	2
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L2080
L2075:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_idiv
mc_genmcl.px_idiv:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	1
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_irem
mc_genmcl.px_irem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_idivrem
mc_genmcl.px_idivrem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	2
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_clear
mc_genmcl.px_clear:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind_simp
    mov       %rdi,	%rax
    mov       %eax,	[%rbx+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.clearblock
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subp
mc_genmcl.px_subp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%r12+16]
    cmp       %rax,	1
    jle       L2089
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    call      mc_libmcl.ispoweroftwo
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jz        L2091
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2090
L2091:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10607]
    lea       %rdx,	[%rip+L10608]
    call      pc_api.merror
L2090:
L2089:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_switch
mc_genmcl.px_switch:
#?>>
    .set mc_genmcl.px_switch.p, 64
    .set mc_genmcl.px_switch.bx, -8
    .set mc_genmcl.px_switch.ax2, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    mov       %rsi,	[%rax+8]
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    lea       %rax,	[%rax+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rax,	[%rip+mc_decls.currpcl]
    mov       %r12,	[%rax+8]
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    mov       %eax,	[%rax+4]
    cmp       %rax,	8
    jge       L2094
    mov       %rcx,	%r14
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       [%rbp + mc_genmcl.px_switch.ax2],	%r10
    mov       %rcx,	18
    mov       %rdx,	%rax
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %r14,	[%rbp + mc_genmcl.px_switch.ax2]
L2094:
    test      %rdi,	%rdi
    jz        L2096
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2096:
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    inc       %rax
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	3
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L2098
    call      mc_stackmcl.getworkireg
    mov       %r13,	%rax
    mov       %rcx,	%r13
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_genmcl.px_switch.bx],	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	[%rbp + mc_genmcl.px_switch.bx]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	8
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2097
L2098:
    sub       %rsp,	8
    push      0
    mov       %rax,	%rsi
    push      %rax
    push      0
    movzx     %rax,	byte ptr[%r14+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	8
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2097:
    call      mc_stackmcl.poppcl
    mov       %rcx,	73
    mov       %rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_switchu
mc_genmcl.px_switchu:
#?>>
    .set mc_genmcl.px_switchu.p, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    mov       %rsi,	[%rax+8]
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r13,	%rax
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L2101
    call      mc_stackmcl.getworkireg
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %r14,	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    sub       %rsp,	8
    push      0
    push      0
    push      0
    mov       %rax,	%rdi
    neg       %rax
    shl       %rax,	3
    movzx     %r10,	byte ptr[%r13+10]
    mov       %rcx,	%r12
    mov       %rdx,	%r10
    mov       %r8,	8
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2100
L2101:
    sub       %rsp,	8
    push      0
    mov       %rax,	%rsi
    push      %rax
    push      0
    mov       %rax,	%rdi
    neg       %rax
    shl       %rax,	3
    movzx     %r10,	byte ptr[%r13+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%r10
    mov       %r8,	8
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2100:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_swlabel
mc_genmcl.px_swlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_endsw
mc_genmcl.px_endsw:
#?>>
    .set mc_genmcl.px_endsw.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_fwiden
mc_genmcl.px_fwiden:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	89
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %al,	2
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fnarrow
mc_genmcl.px_fnarrow:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	88
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_truncate
mc_genmcl.px_truncate:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %bl,	%al
    movzx     %rax,	%bl
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    movzx     %r10,	%bl
    lea       %r11,	[%rip+pc_tables.psize]
    movzx     %r11,	byte ptr[%r11 + %r10]
    cmp       %rax,	%r11
    jz        L2108
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mc_libmcl.changeopndsize
    movzx     %r10,	%bl
    lea       %r11,	[%rip+mc_decls.ploadop]
    movzx     %r11,	byte ptr[%r11 + %r10]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2108:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_typepun
mc_genmcl.px_typepun:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_unload
mc_genmcl.px_unload:
#?>>
    .set mc_genmcl.px_unload.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_loadbit
mc_genmcl.px_loadbit:
#?>>
    .set mc_genmcl.px_loadbit.p, 48
    .set mc_genmcl.px_loadbit.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L2113
    mov       %rsi,	[%rbx+8]
    mov       %rax,	%rsi
    cmp       %rax,	0
    jl        L2115
    cmp       %rax,	31
    jg        L2115
    mov       %rax,	5
    jmp       L2114
L2115:
    mov       %rax,	6
L2114:
    mov       %r12,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L2117
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    cmp       %rsi,	63
    jz        L2120
L2119:
L2117:
    jmp       L2112
L2113:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2122
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2122:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2124
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2124:
L2112:
    mov       %rcx,	1
    mov       %rdx,	5
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_loadbit.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	38
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_loadbit.$T1]
    call      mc_libmcl.genmc
#mc_genmcl.px_loadbit.skip:
L2120:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_assem
mc_genmcl.px_assem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_api.idomcl_assem]
    test      %rax,	%rax
    jz        L2127
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %r10,	[%rip+pc_api.idomcl_assem]
    call      %r10
    jmp       L2126
L2127:
    lea       %rcx,	[%rip+L10609]
    lea       %rdx,	[%rip+L10610]
    call      pc_api.merror
L2126:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sin
mc_genmcl.px_sin:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10611]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_cos
mc_genmcl.px_cos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10612]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_tan
mc_genmcl.px_tan:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10613]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_asin
mc_genmcl.px_asin:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10614]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_acos
mc_genmcl.px_acos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10615]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_atan
mc_genmcl.px_atan:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10616]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_log
mc_genmcl.px_log:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10617]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_log10
mc_genmcl.px_log10:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10618]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_exp
mc_genmcl.px_exp:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10619]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_round
mc_genmcl.px_round:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10620]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_floor
mc_genmcl.px_floor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10621]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_ceil
mc_genmcl.px_ceil:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10622]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_atan2
mc_genmcl.px_atan2:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10623]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fmod
mc_genmcl.px_fmod:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10624]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setcc
mc_genmcl.px_setcc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.ucondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L2144
    lea       %rcx,	[%rip+L10625]
    lea       %rdx,	[%rip+L10626]
    call      pc_api.merror
    jmp       L2143
L2144:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2145
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2147
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.scondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
L2147:
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r12,	%rax
    jmp       L2143
L2145:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	3
    call      mc_stackmcl.getworkregm
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%r12+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_stackmcl.setnewzz
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
L2143:
    mov       %rcx,	58
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%r12
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_min
mc_genmcl.px_min:
#?>>
    .set mc_genmcl.px_min.p, 16
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2150
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2152
    mov       %rax,	15
    jmp       L2151
L2152:
    mov       %rax,	7
L2151:
    mov       %rcx,	%rax
    call      mc_auxmcl.do_max_int
    jmp       L2149
L2150:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	112
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_auxmcl.do_max_float
L2149:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_max
mc_genmcl.px_max:
#?>>
    .set mc_genmcl.px_max.p, 16
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2155
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2157
    mov       %rax,	12
    jmp       L2156
L2157:
    mov       %rax,	2
L2156:
    mov       %rcx,	%rax
    call      mc_auxmcl.do_max_int
    jmp       L2154
L2155:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	113
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_auxmcl.do_max_float
L2154:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_power
mc_genmcl.px_power:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2160
    mov       %rcx,	82
    call      mc_auxmcl.gethostfn
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	2
    call      mc_auxmcl.do_host
    jmp       L2159
L2160:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10627]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
L2159:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_minto
mc_genmcl.px_minto:
#?>>
    .set mc_genmcl.px_minto.p, 16
    .set mc_genmcl.px_minto.$T1, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2163
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_minto.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2165
    mov       %rax,	14
    jmp       L2164
L2165:
    mov       %rax,	6
L2164:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_minto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2162
L2163:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	6
    mov       %rdx,	%rax
    call      mc_auxmcl.do_maxto_real
L2162:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_genmcl.px_maxto
mc_genmcl.px_maxto:
#?>>
    .set mc_genmcl.px_maxto.p, 16
    .set mc_genmcl.px_maxto.$T1, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2168
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_maxto.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2170
    mov       %rax,	13
    jmp       L2169
L2170:
    mov       %rax,	3
L2169:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_maxto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2167
L2168:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	3
    mov       %rdx,	%rax
    call      mc_auxmcl.do_maxto_real
L2167:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_genmcl.px_negto
mc_genmcl.px_negto:
#?>>
    .set mc_genmcl.px_negto.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2173
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2172
L2173:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.do_negreal
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2172:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_absto
mc_genmcl.px_absto:
#?>>
    .set mc_genmcl.px_absto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2176
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	26
    mov       %rdx,	13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	50
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2175
L2176:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.do_absreal
L2175:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addpxto
mc_genmcl.px_addpxto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L2179
    mov       %rax,	[%rsi+8]
    movsxd    %r10,	dword ptr[%r12+16]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2178
L2179:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2178:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subpxto
mc_genmcl.px_subpxto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L2182
    mov       %rax,	[%rsi+8]
    movsxd    %r10,	dword ptr[%r12+16]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2181
L2182:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %eax,	[%r12+20]
    test      %eax,	%eax
    jz        L2184
    lea       %rcx,	[%rip+L10628]
    lea       %rdx,	[%rip+L10629]
    call      pc_api.merror
L2184:
L2181:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_divto
mc_genmcl.px_divto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	71
    call      mc_auxmcl.do_binto_float
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnotto
mc_genmcl.px_bitnotto:
#?>>
    .set mc_genmcl.px_bitnotto.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	51
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_notto
mc_genmcl.px_notto:
#?>>
    .set mc_genmcl.px_notto.p, 24
    .set mc_genmcl.px_notto.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	1
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_notto.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	40
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_notto.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolto
mc_genmcl.px_toboolto:
#?>>
    .set mc_genmcl.px_toboolto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	58
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sign
mc_genmcl.px_sign:
#?>>
    .set mc_genmcl.px_sign.p, 64
    .set mc_genmcl.px_sign.ltop, -8
    .set mc_genmcl.px_sign.$T1, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	10
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      mc_libmcl.clearreg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L2191
    mov       %r14b,	7
    mov       %al,	2
    mov       [%rbp + mc_genmcl.px_sign.ltop],	%al
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movq      %XMM0,	[%rip+L10630]
    mov       %rdx,	%rax
    call      mc_libmcl.mgenrealmem
    movzx     %r10,	byte ptr[%rip+mc_decls.pmode]
    dec       %r10
    mov       %r11,	73
    add       %r11,	%r10
    mov       %rcx,	%r11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2190
L2191:
    mov       %r14b,	15
    mov       %al,	12
    mov       [%rbp + mc_genmcl.px_sign.ltop],	%al
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2190:
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    movzx     %r10,	%r14b
    mov       %rcx,	26
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r12,	%r10
    movzx     %r10,	byte ptr[%rbp + mc_genmcl.px_sign.ltop]
    mov       %rcx,	26
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r13,	%r10
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_sign.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_sign.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	25
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadbf
mc_genmcl.px_loadbf:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jz        L2194
    test      %rbx,	%rbx
    jz        L2194
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%rsi
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mc_auxmcl.do_loadbf_const
    jmp       L2193
L2194:
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_loadbf_var
L2193:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storebit
mc_genmcl.px_storebit:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_storebit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storebf
mc_genmcl.px_storebf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_storebf
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadall
mc_genmcl.px_loadall:
#?>>
    .set mc_genmcl.px_loadall.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.checkallloaded
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_setjmp
mc_genmcl.px_setjmp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    call      mc_libmcl.mcreatefwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    mov       %rcx,	6
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	16
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rip+mc_decls.dframeopnd]
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    mov       %rcx,	%r12
    call      mc_stackmcl.freeworkregs
    mov       %rcx,	1
    call      mc_stackmcl.movetoreg
    mov       %rcx,	%rsi
    call      mc_libmcl.mdefinefwdlabel
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_longjmp
mc_genmcl.px_longjmp:
#?>>
    .set mc_genmcl.px_longjmp.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	16
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	6
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       %rcx,	1
    call      mc_stackmcl.swapopndregs
    mov       %rcx,	25
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_initdswx
mc_genmcl.px_initdswx:
#?>>
    .set mc_genmcl.px_initdswx.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_auxmcl.allocregvars
mc_auxmcl.allocregvars:
#?>>
    .set mc_auxmcl.allocregvars.params, -32
    .set mc_auxmcl.allocregvars.xparams, -64
    .set mc_auxmcl.allocregvars.leafparams, -96
    .set mc_auxmcl.allocregvars.xleafparams, -128
    .set mc_auxmcl.allocregvars.leafparamno, -136
    .set mc_auxmcl.allocregvars.xleafparamno, -144
    .set mc_auxmcl.allocregvars.locals, -400
    .set mc_auxmcl.allocregvars.xlocals, -656
    .set mc_auxmcl.allocregvars.reg, -664
    .set mc_auxmcl.allocregvars.nl, -672
    .set mc_auxmcl.allocregvars.np, -680
    .set mc_auxmcl.allocregvars.nlx, -688
    .set mc_auxmcl.allocregvars.npx, -696
    .set mc_auxmcl.allocregvars.d, -704
    .set mc_auxmcl.allocregvars.i, -712
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	712
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r12,	%rax
    xor       %r13,	%r13
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %rax,	[%rip+mc_decls.maxregvars]
    add       %rax,	[%rip+mc_decls.maxxregvars]
    test      %rax,	%rax
    jz        L2201
L2203:
    test      %rcx,	%rcx
    jnz       L2205
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+16]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    xor       %r15,	%r15
    jmp       L2209
L2206:
    inc       %r15
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+92]
    test      %al,	%al
    jz        L2211
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+91]
    test      %al,	%al
    jnz       L2211
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+88]
    test      %al,	%al
    jnz       L2211
    cmp       %r15,	4
    jg        L2211
    test      %rdx,	%rdx
    jnz       L2213
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2215
    cmp       %rdi,	4
    jge       L2217
    inc       %rdi
    mov       %rax,	%rdi
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.params-8],	%r10
L2217:
    jmp       L2214
L2215:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2218
    cmp       %rbx,	4
    jge       L2220
    inc       %rbx
    mov       %rax,	%rbx
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xparams-8],	%r10
L2220:
L2218:
L2214:
    jmp       L2212
L2213:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2222
    cmp       %rsi,	4
    jge       L2224
    inc       %rsi
    mov       %rax,	%rsi
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.leafparams-8],	%r10
    mov       [%rbp + %rsi + mc_auxmcl.allocregvars.leafparamno-1],	%r15b
L2224:
    jmp       L2221
L2222:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2225
    cmp       %r12,	4
    jge       L2227
    inc       %r12
    mov       %rax,	%r12
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xleafparams-8],	%r10
    mov       [%rbp + %r12 + mc_auxmcl.allocregvars.xleafparamno-1],	%r15b
L2227:
L2225:
L2221:
L2212:
L2211:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %rax,	[%rax+16]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
L2209:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    test      %rax,	%rax
    jnz       L2206
L2205:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    jmp       L2231
L2228:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+92]
    test      %al,	%al
    jz        L2233
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+91]
    test      %al,	%al
    jnz       L2233
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+88]
    test      %al,	%al
    jnz       L2233
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2235
    cmp       %r13,	32
    jge       L2237
    inc       %r13
    mov       %rax,	%r13
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.locals-8],	%r10
L2237:
    jmp       L2234
L2235:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2238
    cmp       %r14,	32
    jge       L2238
    inc       %r14
    mov       %rax,	%r14
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xlocals-8],	%r10
L2238:
L2234:
L2233:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
L2231:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    test      %rax,	%rax
    jnz       L2228
    test      %r13,	%r13
    jnz       L2240
    mov       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r10,	%rdi
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
    jmp       L2239
L2240:
    test      %rdi,	%rdi
    jnz       L2241
    mov       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r10,	%r13
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rax
    jmp       L2239
L2241:
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%r13
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rdi
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    add       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    sub       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L2243
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.np]
    dec       %r15
    cmp       %r15,	0
    jle       L2245
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    cmp       %rax,	0
    jle       L2245
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.np]
    dec       %r15
L2245:
    cmp       %r15,	0
    jle       L2247
    mov       %rax,	%r15
    sub       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
L2247:
L2243:
L2239:
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    cmp       %rax,	1
    jl        L2250
L2248:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.locals-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    inc       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    jle       L2248
L2250:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    cmp       %rax,	1
    jl        L2253
L2251:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.params-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    inc       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    jle       L2251
L2253:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rsi,	1
    jl        L2256
L2254:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.leafparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    movzx     %rax,	byte ptr[%rbp + %rax + mc_auxmcl.allocregvars.leafparamno-1]
    add       %rax,	11
    dec       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.reg]
    cmp       %rax,	11
    jnz       L2258
    mov       %al,	1
    mov       [%rip+pc_decls.r10used],	%al
L2258:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.reg]
    cmp       %rax,	12
    jnz       L2260
    mov       %al,	1
    mov       [%rip+pc_decls.r11used],	%al
L2260:
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	%rsi
    jle       L2254
L2256:
    test      %r14,	%r14
    jnz       L2262
    mov       %rax,	[%rip+mc_decls.maxxregvars]
    mov       %r10,	%rbx
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
    jmp       L2261
L2262:
    test      %rbx,	%rbx
    jnz       L2263
    mov       %rax,	[%rip+mc_decls.maxxregvars]
    mov       %r10,	%r14
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rax
    jmp       L2261
L2263:
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%r14
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rbx
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    add       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    sub       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L2265
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.npx]
    dec       %r15
    cmp       %r15,	0
    jle       L2267
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    cmp       %rax,	0
    jle       L2267
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.npx]
    dec       %r15
L2267:
    cmp       %r15,	0
    jle       L2269
    mov       %rax,	%r15
    sub       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
L2269:
L2265:
L2261:
    mov       %rax,	16
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    cmp       %rax,	1
    jl        L2272
L2270:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xlocals-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    jle       L2270
L2272:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    cmp       %rax,	1
    jl        L2275
L2273:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    jle       L2273
L2275:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %r12,	1
    jl        L2278
L2276:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xleafparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    movzx     %rax,	byte ptr[%rbp + %rax + mc_auxmcl.allocregvars.xleafparamno-1]
    inc       %rax
    dec       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	%r12
    jle       L2276
L2278:
L2201:
#---------------
    add       %rsp,	712
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.initproc
mc_auxmcl.initproc:
#?>>
    .set mc_auxmcl.initproc.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.workregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.workxregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.isregvar]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.isxregvar]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rax,	3
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+2],	%al
    mov       %rax,	2
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       [%r10+4],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       [%r10+5],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.maxxregvars],	%rax
    mov       [%rip+mc_decls.maxregvars],	%rax
    xor       %r12,	%r12
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       [%rip+pc_decls.pinfo],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    test      %rax,	%rax
    jnz       L2281
    mov       %rax,	10
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %rax,	12
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %rsi,	4
L2282:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    inc       %rsi
    cmp       %rsi,	10
    jle       L2282
    mov       %rsi,	7
L2285:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    inc       %rsi
    cmp       %rsi,	16
    jle       L2285
    jmp       L2280
L2281:
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %r10,	[%rip+pc_decls.pinfo]
    movzx     %r10,	byte ptr[%r10+4]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r10,	4
    cmp       %r10,	%rax
    cmovg     %r10,	%rax
    mov       %r12,	%r10
    mov       %rax,	4
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %al,	[%rax+7]
    test      %al,	%al
    jz        L2289
    inc       qword ptr[%rip+mc_decls.nworkregs]
L2289:
    mov       %rax,	5
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %rax,	[%rip+mc_decls.nworkregs]
    sub       %rax,	3
    mov       %rbx,	%rax
    cmp       %r12,	3
    jg        L2291
    test      %rbx,	%rbx
    jz        L2291
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+13],	%al
    dec       %rbx
    cmp       %r12,	2
    jg        L2293
    test      %rbx,	%rbx
    jz        L2293
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+12],	%al
    dec       %rbx
L2293:
L2291:
    mov       %rsi,	10
    mov       %r13,	%rbx
    cmp       %r13,	0
    jle       L2296
L2294:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.workregs]
    mov       [%r11 + %rax-1],	%r10b
    dec       %r13
    jnz       L2294
L2296:
    mov       %rsi,	7
    mov       %rax,	[%rip+mc_decls.nworkxregs]
    sub       %rax,	2
    mov       %r14,	%rax
    cmp       %r14,	0
    jle       L2299
L2297:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.workxregs]
    mov       [%r11 + %rax-1],	%r10b
    dec       %r14
    jnz       L2297
L2299:
L2280:
    mov       %rsi,	4
L2300:
    lea       %rax,	[%rip+mc_decls.workregs]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2304
    inc       qword ptr[%rip+mc_decls.maxregvars]
L2304:
    inc       %rsi
    cmp       %rsi,	10
    jle       L2300
    mov       %rsi,	7
L2305:
    lea       %rax,	[%rip+mc_decls.workxregs]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2309
    inc       qword ptr[%rip+mc_decls.maxxregvars]
L2309:
    inc       %rsi
    cmp       %rsi,	16
    jle       L2305
    lea       %rax,	[%rip+mc_decls.usedregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.usedxregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    mov       [%rax+32],	%r10
    mov       [%rax+40],	%r10
    mov       [%rax+48],	%r10w
    xor       %eax,	%eax
    mov       [%rip+pc_decls.r11used],	%al
    mov       [%rip+pc_decls.r10used],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.mstackdepth],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.noperands],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_genmcl.framebytes],	%rax
    mov       [%rip+mc_genmcl.paramoffset],	%rax
    mov       [%rip+mc_genmcl.frameoffset],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_decls.localshadow],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.nblocktemps],	%rax
    movzx     %rax,	byte ptr[%r15+82]
    cmp       %rax,	11
    jnz       L2311
    lea       %rcx,	[%rip+L10631]
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       %al,	[%r15+82]
    mov       [%rdi+82],	%al
    mov       %al,	1
    mov       [%rdi+92],	%al
    mov       %al,	5
    mov       [%rdi+72],	%al
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+16]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+pc_decls.currfunc]
    mov       [%r10+16],	%rax
    mov       [%rip+pc_decls.blockretname],	%rdi
L2311:
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jz        L2314
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    test      %rax,	%rax
    jnz       L2313
L2314:
    jmp       L2279
L2313:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       %al,	[%rax+5]
    test      %al,	%al
    jnz       L2279
L2316:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    movzx     %rax,	byte ptr[%rax+3]
    mov       [%rbp + mc_auxmcl.initproc.$T1],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+110]
    test      %al,	%al
    jnz       L2317
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+113]
    test      %al,	%al
    jz        L2318
L2317:
    mov       %rax,	1
    jmp       L2319
L2318:
    xor       %eax,	%eax
L2319:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.initproc.$T1]
    call      mc_auxmcl.allocregvars
L2279:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_procentry
mc_auxmcl.do_procentry:
#?>>
    .set mc_auxmcl.do_procentry.p, 72
    .set mc_auxmcl.do_procentry.ff, -8
    .set mc_auxmcl.do_procentry.r, -16
    .set mc_auxmcl.do_procentry.i, -24
    .set mc_auxmcl.do_procentry.$T1, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
    mov       %rcx,	[%rip+mc_decls.mclprocentry]
    call      mc_auxmcl.setmclentry
    xor       %eax,	%eax
    mov       [%rip+pc_decls.bxspill],	%rax
    mov       [%rip+pc_decls.bspill],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    test      %rax,	%rax
    jz        L2323
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       %al,	[%rax+5]
    test      %al,	%al
    jnz       L2322
L2323:
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L2324:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2329
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2328
L2329:
    inc       qword ptr[%rip+pc_decls.bspill]
L2328:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	10
    jle       L2324
    mov       %rax,	7
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L2330:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2335
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2334
L2335:
    inc       qword ptr[%rip+pc_decls.bxspill]
L2334:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	16
    jle       L2330
L2322:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %r14,	[%rax+16]
    jmp       L2339
L2336:
    mov       %al,	[%r14+91]
    test      %al,	%al
    jz        L2341
    lea       %rcx,	[%rip+L10632]
    lea       %rdx,	[%rip+L10633]
    call      pc_api.merror
L2341:
    mov       %al,	[%r14+90]
    test      %al,	%al
    jnz       L2343
    mov       %rax,	[%rip+mc_genmcl.paramoffset]
    add       %rax,	16
    mov       %r10,	[%rip+pc_decls.bspill]
    add       %r10,	[%rip+pc_decls.bxspill]
    shl       %r10,	3
    add       %rax,	%r10
    mov       [%r14+76],	%eax
    movsxd    %rax,	dword ptr[%r14+76]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    call      mc_writeasm.getdispname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    jmp       L2342
L2343:
    movzx     %rax,	byte ptr[%r14+90]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_decls.usedregs]
    movzx     %rax,	byte ptr[%rax+14]
    mov       [%rbp + mc_auxmcl.do_procentry.ff],	%rax
    xor       %eax,	%eax
    mov       [%r14+90],	%al
    movzx     %rax,	byte ptr[%r14+82]
    mov       %rcx,	%r15
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	6
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [%r14+90],	%r15b
    mov       %al,	[%rbp + mc_auxmcl.do_procentry.ff]
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2342:
    mov       %rax,	8
    add       [%rip+mc_genmcl.paramoffset],	%rax
    mov       %r14,	[%r14+16]
L2339:
    test      %r14,	%r14
    jnz       L2336
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+82]
    mov       %rdi,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %r14,	[%rax+24]
    jmp       L2347
L2344:
    movzx     %rax,	byte ptr[%r14+82]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %r12,	%r10
    movzx     %rax,	byte ptr[%r14+82]
    cmp       %rax,	11
    jnz       L2349
    mov       %eax,	[%r14+84]
    mov       %r12,	%rax
L2349:
    mov       %al,	[%r14+92]
    test      %al,	%al
    jz        L2345
L2351:
    mov       %al,	[%r14+91]
    test      %al,	%al
    jz        L2353
    mov       %rsi,	1
    jmp       L2352
L2353:
    mov       %al,	[%r14+90]
    test      %al,	%al
    jz        L2354
    movzx     %rax,	byte ptr[%r14+90]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_decls.usedregs]
    movzx     %rax,	byte ptr[%rax+14]
    mov       [%rbp + mc_auxmcl.do_procentry.ff],	%rax
    xor       %eax,	%eax
    mov       [%r14+90],	%al
    movzx     %rax,	byte ptr[%r14+82]
    mov       %rcx,	%r15
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	6
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [%r14+90],	%r15b
    mov       %al,	[%rbp + mc_auxmcl.do_procentry.ff]
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
    jmp       L2352
L2354:
    mov       %rcx,	%r12
    call      mc_libmcl.roundsizetg
    sub       [%rip+mc_genmcl.frameoffset],	%rax
    mov       %eax,	[%rip+mc_genmcl.frameoffset]
    mov       [%r14+76],	%eax
    movsxd    %rax,	dword ptr[%r14+76]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    call      mc_writeasm.getdispname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L2352:
L2345:
    mov       %r14,	[%r14+24]
L2347:
    test      %r14,	%r14
    jnz       L2344
    xor       %rbx,	%rbx
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.do_procentry.i],	%rax
L2355:
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.i]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2359
    inc       %rbx
    mov       %rax,	8
    sub       [%rip+mc_genmcl.frameoffset],	%rax
    lea       %rax,	[%rip+mc_decls.pcltempopnds]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.i]
    mov       %r13,	[%rax + %r10*8-8]
    mov       %eax,	[%rip+mc_genmcl.frameoffset]
    mov       [%r13+12],	%eax
    movsxd    %rax,	dword ptr[%r13+12]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	[%rip+pc_decls.currfunc]
    mov       %rdx,	[%rbp + mc_auxmcl.do_procentry.i]
    call      mc_writeasm.gettempname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L2359:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.i],	%rax
    cmp       %rax,	50
    jle       L2355
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+108]
    test      %al,	%al
    jz        L2361
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %ax,	[%rax+114]
    test      %ax,	%ax
    jnz       L2364
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L2363
L2364:
    lea       %rcx,	[%rip+L10634]
    lea       %rdx,	[%rip+L10635]
    call      pc_api.merror
L2363:
    test      %rbx,	%rbx
    jz        L2366
    lea       %rcx,	[%rip+L10636]
    lea       %rdx,	[%rip+L10637]
    call      pc_api.merror
L2366:
    call      mc_auxmcl.resetmclentry
    jmp       L2320
L2361:
    mov       %rax,	[%rip+mc_genmcl.frameoffset]
    neg       %rax
    mov       [%rip+mc_genmcl.framebytes],	%rax
    mov       %rax,	[%rip+pc_decls.bspill]
    add       %rax,	[%rip+pc_decls.bxspill]
    and       %eax,	1
    test      %rax,	%rax
    jz        L2368
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    and       %rax,	8
    jnz       L2370
    mov       %rax,	8
    add       [%rip+mc_genmcl.framebytes],	%rax
L2370:
    jmp       L2367
L2368:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    and       %rax,	8
    jz        L2372
    mov       %rax,	8
    add       [%rip+mc_genmcl.framebytes],	%rax
L2372:
L2367:
    mov       %al,	[%rip+pc_decls.localshadow]
    test      %al,	%al
    jz        L2374
    mov       %rax,	32
    add       [%rip+mc_genmcl.framebytes],	%rax
L2374:
    mov       %rax,	[%rip+pc_decls.bspill]
    test      %rax,	%rax
    jz        L2376
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L2377:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2382
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2381
L2382:
    mov       %rcx,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2381:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	10
    jle       L2377
L2376:
    mov       %rax,	[%rip+pc_decls.bxspill]
    test      %rax,	%rax
    jz        L2384
    mov       %rcx,	1
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %r13,	%rax
    mov       %rax,	7
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L2385:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2390
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2389
L2390:
    mov       %rcx,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%r13
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	12
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2389:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	16
    jle       L2385
L2384:
    lea       %rcx,	[%rip+L10638]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_auxmcl.mclframesetup],	%rax
    call      mc_auxmcl.spillparams
    lea       %rcx,	[%rip+L10639]
    call      mc_libmcl.mgencomment
    call      mc_auxmcl.resetmclentry
L2320:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_procexit
mc_auxmcl.do_procexit:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L10639]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+108]
    test      %al,	%al
    jz        L2393
    mov       %rcx,	22
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2391
L2393:
    mov       %rcx,	[%rip+mc_auxmcl.mclframesetup]
    call      mc_auxmcl.setmclentryf
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jnz       L2396
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L2395
L2396:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L2398
    mov       %rcx,	12
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    mov       %r8,	[%rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+mc_genmcl.framebytes]
    call      mc_libmcl.pushstack
    jmp       L2397
L2398:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jz        L2400
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    add       %rax,	8
    mov       %rcx,	%rax
    call      mc_libmcl.pushstack
L2400:
L2397:
L2395:
    call      mc_auxmcl.resetmclentryf
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jnz       L2403
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L2402
L2403:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L2405
    mov       %rcx,	[%rip+mc_genmcl.framebytes]
    call      mc_libmcl.popstack
    mov       %rcx,	13
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2404
L2405:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jz        L2407
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    add       %rax,	8
    mov       %rcx,	%rax
    call      mc_libmcl.popstack
L2407:
L2404:
L2402:
    mov       %rax,	[%rip+pc_decls.bxspill]
    test      %rax,	%rax
    jz        L2409
    mov       %rcx,	11
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rbx,	16
L2410:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2414
    mov       %rcx,	13
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2414:
    dec       %rbx
    cmp       %rbx,	7
    jge       L2410
L2409:
    mov       %rax,	[%rip+pc_decls.bspill]
    test      %rax,	%rax
    jz        L2416
    mov       %rbx,	10
L2417:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2421
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2421:
    dec       %rbx
    cmp       %rbx,	4
    jge       L2417
L2416:
    mov       %rcx,	22
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2391:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.spillparams
mc_auxmcl.spillparams:
#?>>
    .set mc_auxmcl.spillparams.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rsi,	16
    xor       %r12,	%r12
    xor       %eax,	%eax
    mov       %r12,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+113]
    test      %al,	%al
    jz        L2424
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %r13,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %r14,	%rax
    cmp       %r14,	3
    jg        L2427
L2425:
    sub       %rsp,	8
    push      0
    push      0
    push      8
    mov       %rax,	%r14
    shl       %rax,	3
    add       %rax,	%r13
    mov       %rcx,	15
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rbx,	%rax
    lea       %rax,	[%r14+11]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       %r14
    cmp       %r14,	3
    jle       L2425
L2427:
L2424:
    jmp       L2431
L2428:
    cmp       %r12,	3
    jg        L2430
L2433:
    mov       %al,	[%rdi+92]
    test      %al,	%al
    jz        L2435
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jnz       L2437
    sub       %rsp,	8
    push      0
    push      0
    push      8
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %rcx,	15
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rdi+82]
    cmp       %rax,	2
    jz        L2439
    cmp       %rax,	1
    jz        L2440
    jmp       L2441
L2439:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2438
L2440:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	16
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L2438
L2441:
    lea       %rax,	[%r12+11]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2438:
    jmp       L2436
L2437:
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jz        L2442
    movzx     %rax,	byte ptr[%rdi+82]
    cmp       %rax,	2
    jg        L2444
    movzx     %rax,	byte ptr[%rdi+90]
    cmp       %rax,	5
    jl        L2446
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%r12+1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+90]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2446:
    jmp       L2443
L2444:
    movzx     %rax,	byte ptr[%rdi+90]
    cmp       %rax,	10
    jg        L2447
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%r12+11]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+82]
    movzx     %r10,	byte ptr[%rdi+90]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2447:
L2443:
L2442:
L2436:
L2435:
    mov       %rax,	8
    add       %rsi,	%rax
    inc       %r12
    mov       %rdi,	[%rdi+16]
L2431:
    test      %rdi,	%rdi
    jnz       L2428
L2430:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_jumptruefalse
mc_auxmcl.do_jumptruefalse:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2450
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L2449
L2450:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	76
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2449:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	%r12
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_bitwise
mc_auxmcl.do_bitwise:
#?>>
    .set mc_auxmcl.do_bitwise.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_shift
mc_auxmcl.do_shift:
#?>>
    .set mc_auxmcl.do_shift.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2454
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jnz       L2454
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2453
L2454:
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2456
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2456:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2458
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2458:
L2453:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentry
mc_auxmcl.setmclentry:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mce_oldmccodex],	%rax
    mov       [%rip+mc_decls.mccodex],	%rcx
    mov       %rax,	[%rcx]
    mov       [%rip+mc_decls.mce_lastmcl],	%rax
    mov       %rax,	[%rcx+8]
    mov       [%rip+mc_decls.mce_nextmcl],	%rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentry
mc_auxmcl.resetmclentry:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+mc_decls.mce_lastmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+mc_decls.mce_nextmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       %rdi,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rip+mc_decls.mce_oldmccodex]
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       %rax,	%rdi
L2460:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentryf
mc_auxmcl.setmclentryf:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mcf_oldmccodex],	%rax
    mov       [%rip+mc_decls.mccodex],	%rcx
    mov       %rax,	[%rcx]
    mov       [%rip+mc_decls.mcf_lastmcl],	%rax
    mov       %rax,	[%rcx+8]
    mov       [%rip+mc_decls.mcf_nextmcl],	%rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentryf
mc_auxmcl.resetmclentryf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+mc_decls.mcf_lastmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+mc_decls.mcf_nextmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       %rdi,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rip+mc_decls.mcf_oldmccodex]
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       %rax,	%rdi
L2462:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_pushlowargs
mc_auxmcl.do_pushlowargs:
#?>>
    .set mc_auxmcl.do_pushlowargs.nvariadics, 80
    .set mc_auxmcl.do_pushlowargs.isptr, 88
    .set mc_auxmcl.do_pushlowargs.imode, -8
    .set mc_auxmcl.do_pushlowargs.blockret, -16
    .set mc_auxmcl.do_pushlowargs.dblock, -24
    .set mc_auxmcl.do_pushlowargs.av_1, -32
    .set mc_auxmcl.do_pushlowargs.i, -40
    .set mc_auxmcl.do_pushlowargs.$T1, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    test      %r15,	%r15
    jnz       L2465
    jmp       L2463
L2465:
    lea       %rax,	[%rip+mc_decls.callblockret]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.blockret],	%rax
    mov       %r12,	11
    mov       %r13,	1
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+mc_decls.noperands]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.i],	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%r15
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.av_1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    cmp       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.av_1]
    jl        L2468
L2466:
    inc       %rsi
    cmp       %rsi,	1
    jnz       L2470
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.blockret]
    test      %rax,	%rax
    jz        L2470
    lea       %rax,	[%rip+mc_decls.callblocksize]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    mov       %eax,	[%rax + %r10*4-4]
    mov       %rcx,	%rax
    call      mc_libmcl.newblocktemp
    mov       [%rbp + mc_auxmcl.do_pushlowargs.dblock],	%rax
    mov       %al,	1
    mov       %r10,	[%rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       [%r10+92],	%al
    mov       %rcx,	[%rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.do_pushlowargs.$T1],	%rax
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
    jmp       L2469
L2470:
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    sub       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.isptr]
    add       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.blockret]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	11
    jz        L2472
    cmp       %rax,	2
    jz        L2473
    cmp       %rax,	1
    jz        L2473
    jmp       L2474
L2472:
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    mov       %r8,	%r12
    call      mc_stackmcl.loadparam
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.callargsize]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    shl       %r10,	4
    lea       %rax,	[%rax + %r10-16]
    mov       %r10,	%rsi
    mov       %eax,	[%rax + %r10*4-4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      mc_auxmcl.copyblockarg
    jmp       L2471
L2473:
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    mov       %r8,	%r13
    call      mc_stackmcl.loadparam
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    test      %rax,	%rax
    jz        L2476
    cmp       %rsi,	[%rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    jl        L2476
    cmp       %r14,	1
    jnz       L2478
    mov       %rax,	5
    jmp       L2477
L2478:
    mov       %rax,	6
L2477:
    mov       [%rbp + mc_auxmcl.do_pushlowargs.imode],	%rax
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_pushlowargs.$T1],	%rax
    mov       %rcx,	%r12
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.imode]
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
L2476:
    jmp       L2471
L2474:
#mc_auxmcl.do_pushlowargs.doint:
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    mov       %r8,	%r12
    call      mc_stackmcl.loadparam
L2471:
L2469:
    inc       %r12
    inc       %r13
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    dec       %rax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.av_1]
    jge       L2466
L2468:
L2463:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_getretvalue
mc_auxmcl.do_getretvalue:
#?>>
    .set mc_auxmcl.do_getretvalue.modes, -80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	112
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%r12+32]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jnz       L2482
    xor       %rbx,	%rbx
    jmp       L2484
L2483:
    movzx     %rax,	byte ptr[%r12+3]
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%rbp + %r10*8 + mc_auxmcl.do_getretvalue.modes-8],	%rax
L2484:
    add       %r12,	32
    mov       %rax,	%r12
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L2483
    lea       %rax,	[%r12-32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rdi,	%rbx
    cmp       %rdi,	1
    jl        L2488
L2486:
    mov       %rsi,	[%rbp + %rdi*8 + mc_auxmcl.do_getretvalue.modes-8]
    cmp       %rsi,	2
    jg        L2490
    lea       %rax,	[%rip+mc_decls.multxregs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2489
L2490:
    lea       %rax,	[%rip+mc_decls.multregs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
L2489:
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_stackmcl.pushpcl_reg
    dec       %rdi
    cmp       %rdi,	1
    jge       L2486
L2488:
    jmp       L2481
L2482:
    movzx     %rax,	byte ptr[%r12+3]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      mc_stackmcl.pushpcl_reg
L2481:
#---------------
    add       %rsp,	112
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.ismemaddr
mc_auxmcl.ismemaddr:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2493
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	2
    jnz       L2493
    mov       %rax,	1
    jmp       L2491
L2493:
    xor       %eax,	%eax
L2491:
#---------------
    ret       
# End 
# Proc mc_auxmcl.do_incr
mc_auxmcl.do_incr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rbx+16]
    cmp       %rax,	1
    jnz       L2496
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2495
L2496:
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2495:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_incrload
mc_auxmcl.do_incrload:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+16]
    cmp       %rax,	1
    jnz       L2499
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2498
L2499:
    movsxd    %rax,	dword ptr[%rsi+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2498:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rdi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadincr
mc_auxmcl.do_loadincr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%rsi+16]
    cmp       %rax,	1
    jnz       L2502
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2501
L2502:
    movsxd    %rax,	dword ptr[%rsi+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2501:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_for
mc_auxmcl.do_for:
#?>>
    .set mc_auxmcl.do_for.addop, 80
    .set mc_auxmcl.do_for.cond, 88
    .set mc_auxmcl.do_for.mx, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    lea       %rax,	[%r13+32]
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.do_for.mx],	%rax
    mov       %rax,	[%rdi+8]
    mov       %al,	[%rax+90]
    test      %al,	%al
    jz        L2505
    movsxd    %rax,	dword ptr[%r13+16]
    cmp       %rax,	1
    jnz       L2507
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2506
L2507:
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	[%rbp + mc_auxmcl.do_for.addop]
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2506:
    mov       %rsi,	[%rbp + mc_auxmcl.do_for.mx]
    jmp       L2504
L2505:
    call      mc_stackmcl.getworkireg
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	[%rbp + mc_auxmcl.do_for.mx]
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%r13+16]
    cmp       %rax,	1
    jnz       L2509
    mov       %rcx,	%r14
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2508
L2509:
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	[%rbp + mc_auxmcl.do_for.addop]
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2508:
    mov       %rcx,	11
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L2504:
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	4
    jnz       L2511
    mov       %rax,	[%rbx+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %r12,	%rax
    jmp       L2510
L2511:
    mov       %rax,	[%rbx+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %r12,	%rax
L2510:
    mov       %rcx,	42
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.cond]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.scaleindex
mc_auxmcl.scaleindex:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L2515
    cmp       %rax,	2
    jz        L2515
    cmp       %rax,	4
    jz        L2515
    cmp       %rax,	8
    jnz       L2514
L2515:
    mov       %rax,	%rbx
    jmp       L2512
L2514:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.mulimm
    mov       %rax,	1
L2512:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.mulimm
mc_auxmcl.mulimm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rax,	%r13
    test      %rax,	%rax
    jz        L2518
    cmp       %rax,	1
    jz        L2519
    cmp       %rax,	-1
    jz        L2520
    jmp       L2521
L2518:
    mov       %rcx,	%r12
    call      mc_libmcl.clearreg
    jmp       L2516
L2519:
    jmp       L2516
L2520:
    mov       %rcx,	50
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2516
L2521:
L2517:
    xor       %rdi,	%rdi
    mov       %rax,	%r13
    mov       %rbx,	%rax
    jmp       L2523
L2522:
    sar       %rbx,	1
    inc       %rdi
L2523:
    mov       %eax,	%ebx
    and       %eax,	1
    test      %rax,	%rax
    jz        L2522
    test      %rdi,	%rdi
    jz        L2526
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2526:
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L2528
    cmp       %rax,	3
    jz        L2529
    cmp       %rax,	5
    jz        L2529
    cmp       %rax,	9
    jz        L2529
    jmp       L2530
L2528:
    jmp       L2516
L2529:
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rbx-1]
    movzx     %r10,	byte ptr[%r12+10]
    movzx     %r11,	byte ptr[%r12+10]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	14
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2527
L2530:
    test      %rdi,	%rdi
    jz        L2532
    mov       %al,	34
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+33],	%al
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+24],	%rax
    jmp       L2531
L2532:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2534
    mov       %rax,	9
    jmp       L2533
L2534:
    mov       %rax,	10
L2533:
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	34
    mov       %rdx,	%r12
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L2531:
L2527:
L2516:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_addrmode
mc_auxmcl.do_addrmode:
#?>>
    .set mc_auxmcl.do_addrmode.p, 72
    .set mc_auxmcl.do_addrmode.scale, -8
    .set mc_auxmcl.do_addrmode.regix, -16
    .set mc_auxmcl.do_addrmode.d, -24
    .set mc_auxmcl.do_addrmode.q, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %r12,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [%rbp + mc_auxmcl.do_addrmode.q],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2537
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    mov       %rax,	[%rax+8]
    mov       %r10,	[%rbp + mc_auxmcl.do_addrmode.scale]
    imul      %rax,	%r10
    add       %rax,	%r12
    mov       %r13,	%rax
L2537:
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    cmp       %rax,	2
    jnz       L2539
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2541
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2540
L2541:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2542
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2540
L2542:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-2]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2540:
    jmp       L2538
L2539:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_auxmcl.ismemaddr
    test      %rax,	%rax
    jz        L2543
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    mov       %rax,	[%rax+8]
    mov       [%rbp + mc_auxmcl.do_addrmode.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	3
    jnz       L2547
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jz        L2546
L2547:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	5
    jnz       L2545
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+82]
    cmp       %rax,	11
    jnz       L2545
L2546:
    jmp       L2548
L2545:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2550
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2549
L2550:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2551
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       %ecx,	%ecx
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2549
L2551:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2549:
    jmp       L2538
L2543:
#mc_auxmcl.do_addrmode.skip:
L2548:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2553
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2552
L2553:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2554
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2552
L2554:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2552:
L2538:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movzx     %rax,	byte ptr[%rax+3]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    lea       %rax,	[%rdi+8]
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rax,	%rdi
L2535:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.scaleregvar
mc_auxmcl.scaleregvar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%r12]
    cmp       %rax,	1
    jz        L2558
    cmp       %rax,	2
    jz        L2558
    cmp       %rax,	4
    jz        L2558
    cmp       %rax,	8
    jnz       L2557
L2558:
    mov       %rax,	%rsi
    jmp       L2555
L2557:
    call      mc_stackmcl.getworkireg
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    mov       %rax,	[%r12]
    cmp       %rax,	16
    jnz       L2560
    sub       %rsp,	8
    push      0
    push      0
    push      0
    mov       %rcx,	%rsi
    mov       %rdx,	%rsi
    mov       %r8,	1
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	14
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	8
    mov       [%r12],	%rax
    jmp       L2559
L2560:
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	[%r12]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rax,	1
    mov       [%r12],	%rax
L2559:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%dil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    mov       %al,	10
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%rdi
L2555:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.dolea
mc_auxmcl.dolea:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+11]
    movzx     %r10,	word ptr[%rbx+8]
    shr       %r10,	12
    and       %r10,	15
    cmp       %r10,	%rax
    jnz       L2565
    movsxd    %rax,	dword ptr[%rbx+12]
    cmp       %rax,	%r10
    jnz       L2565
    test      %rax,	%rax
    jnz       L2565
    mov       %rax,	1
    jmp       L2566
L2565:
    xor       %eax,	%eax
L2566:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2564
    movzx     %rax,	byte ptr[%rbx+10]
    movzx     %r10,	byte ptr[%rdi+10]
    cmp       %rax,	%r10
    jz        L2563
L2564:
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2563:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto
mc_auxmcl.do_binto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L2569
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      mc_auxmcl.do_binto_float
    jmp       L2567
L2569:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2567:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto_float
mc_auxmcl.do_binto_float:
#?>>
    .set mc_auxmcl.do_binto_float.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	%r12
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_shiftnto
mc_auxmcl.do_shiftnto:
#?>>
    .set mc_auxmcl.do_shiftnto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    test      %rax,	%rax
    jnz       L2573
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	4
    jnz       L2573
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2572
L2573:
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2575
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2575:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2577
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2577:
L2572:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_divrem
mc_auxmcl.do_divrem:
#?>>
    .set mc_auxmcl.do_divrem.issigned, 80
    .set mc_auxmcl.do_divrem.isdiv, 88
    .set mc_auxmcl.do_divrem.shifts, -8
    .set mc_auxmcl.do_divrem.fdivto, -16
    .set mc_auxmcl.do_divrem.locyy, -24
    .set mc_auxmcl.do_divrem.loczz, -32
    .set mc_auxmcl.do_divrem.$T1, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.do_divrem.fdivto],	%al
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       [%rbp + mc_auxmcl.do_divrem.locyy],	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    mov       [%rbp + mc_auxmcl.do_divrem.loczz],	%rax
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	94
    jz        L2581
    cmp       %rax,	95
    jnz       L2580
L2581:
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %r10,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       [%rbp + mc_auxmcl.do_divrem.loczz],	%rax
    mov       [%rbp + mc_auxmcl.do_divrem.locyy],	%r10
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %al,	1
    mov       [%rbp + mc_auxmcl.do_divrem.fdivto],	%al
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_stackmcl.makeopndind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    jmp       L2579
L2580:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
L2579:
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.isimmload
    mov       %r12,	%rax
    test      %r12,	%r12
    jz        L2583
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       %rax,	1
    jnz       L2583
    mov       %r14,	[%r12+8]
    mov       %rax,	%r14
    test      %rax,	%rax
    jz        L2585
    cmp       %rax,	1
    jz        L2586
    jmp       L2587
L2585:
    lea       %rcx,	[%rip+L10640]
    lea       %rdx,	[%rip+L10641]
    call      pc_api.merror
    jmp       L2584
L2586:
    call      mc_stackmcl.poppcl
    jmp       L2578
L2587:
    mov       %rcx,	%r14
    call      mc_libmcl.ispoweroftwo
    mov       [%rbp + mc_auxmcl.do_divrem.shifts],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.shifts]
    test      %rax,	%rax
    jz        L2589
    mov       %al,	[%rbp + mc_auxmcl.do_divrem.fdivto]
    test      %al,	%al
    jnz       L2589
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.shifts]
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.issigned]
    test      %rax,	%rax
    jz        L2591
    mov       %rax,	44
    jmp       L2590
L2591:
    mov       %rax,	45
L2590:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L2578
L2589:
L2584:
L2583:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    call      mc_auxmcl.saverdx
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_auxmcl.fixdivopnds
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.issigned]
    test      %rax,	%rax
    jz        L2593
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	8
    jz        L2595
    cmp       %r10,	4
    jz        L2596
    cmp       %r10,	2
    jz        L2597
    jmp       L2598
L2595:
    mov       %rax,	57
    jmp       L2594
L2596:
    mov       %rax,	56
    jmp       L2594
L2597:
    mov       %rax,	55
    jmp       L2594
L2598:
    lea       %rcx,	[%rip+L10642]
    lea       %rdx,	[%rip+L10643]
    call      pc_api.merror
    xor       %eax,	%eax
L2594:
    mov       %r13,	%rax
    mov       %rcx,	%r13
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %r13,	36
    jmp       L2592
L2593:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	%rax
    call      mc_libmcl.clearreg
    mov       %r13,	37
L2592:
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    test      %rax,	%rax
    jz        L2600
    cmp       %rax,	2
    jz        L2601
    jmp       L2602
L2600:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    jmp       L2599
L2601:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	2
    call      mc_stackmcl.swapopndregs
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.swapopnds
L2602:
L2599:
    call      mc_auxmcl.restorerdx
    mov       %al,	[%rbp + mc_auxmcl.do_divrem.fdivto]
    test      %al,	%al
    jz        L2604
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	13
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_stackmcl.makeopndind
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2604:
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       %rax,	2
    jz        L2606
    call      mc_stackmcl.poppcl
L2606:
L2578:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.fixdivopnds
mc_auxmcl.fixdivopnds:
#?>>
    .set mc_auxmcl.fixdivopnds.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r14,	%rcx
    mov       %r15,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r15
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    cmp       %rdi,	1
    jz        L2607
L2609:
    mov       %rcx,	%r14
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %r12,	%rax
    mov       %rcx,	%r15
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %r13,	%rax
    cmp       %rbx,	1
    jnz       L2611
    mov       %rcx,	27
    mov       %rdx,	%r12
    mov       %r8,	%r13
    call      mc_libmcl.genmc
    mov       %rcx,	%r14
    mov       %rdx,	%r15
    call      mc_stackmcl.swapopnds
    jmp       L2607
L2611:
    lea       %rax,	[%rip+mc_decls.regset]
    movzx     %rax,	byte ptr[%rax]
    test      %rax,	%rax
    jnz       L2613
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%r14
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       [%r10],	%al
    jmp       L2607
L2613:
    mov       %rsi,	[%rip+mc_decls.noperands]
    cmp       %rsi,	1
    jl        L2617
L2614:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2619
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2616
L2619:
    dec       %rsi
    cmp       %rsi,	1
    jge       L2614
L2617:
    jmp       L2607
L2616:
    mov       %rcx,	%r14
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_auxmcl.fixdivopnds.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixdivopnds.$T1]
    call      mc_libmcl.genmc
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r14
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rsi
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
L2607:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.saverdx
mc_auxmcl.saverdx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.r11used]
    test      %al,	%al
    jz        L2622
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2622:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.restorerdx
mc_auxmcl.restorerdx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.r11used]
    test      %al,	%al
    jz        L2625
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2625:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.clearblock
mc_auxmcl.clearblock:
#?>>
    .set mc_auxmcl.clearblock.ax, 64
    .set mc_auxmcl.clearblock.n, 72
    .set mc_auxmcl.clearblock.countreg, -8
    .set mc_auxmcl.clearblock.av_1, -16
    .set mc_auxmcl.clearblock.i, -24
    .set mc_auxmcl.clearblock.$T1, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    mov       %r10,	8
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       %r13,	%rax
    mov       %rax,	%r13
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    xor       %r14,	%r14
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L2628
    cmp       %rax,	8
    jg        L2628
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       [%rbp + mc_auxmcl.clearblock.av_1],	%rsi
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.av_1]
    cmp       %rax,	0
    jle       L2631
L2629:
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       %r14,	%rax
    dec       qword ptr[%rbp + mc_auxmcl.clearblock.av_1]
    jnz       L2629
L2631:
    jmp       L2627
L2628:
    test      %rsi,	%rsi
    jz        L2632
    mov       %rax,	%rsi
    and       %rax,	3
    jz        L2634
    call      mc_stackmcl.getworkireg
    mov       %r10,	%rax
    mov       [%rbp + mc_auxmcl.clearblock.countreg],	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.clearblock.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.ax]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %r14,	%r14
    jmp       L2633
L2634:
    call      mc_stackmcl.getworkireg
    mov       %r10,	%rax
    mov       [%rbp + mc_auxmcl.clearblock.countreg],	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       %rax,	%rsi
    sar       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.clearblock.i],	%rax
L2635:
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       %r14,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.clearblock.i],	%rax
    cmp       %rax,	4
    jle       L2635
    mov       %rcx,	32
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.clearblock.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.ax]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %r14,	%r14
L2633:
L2632:
L2627:
    test      %r13,	%r13
    jz        L2639
    mov       [%rbp + mc_auxmcl.clearblock.n],	%r13
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	4
    jl        L2641
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	4
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	4
    add       %r14,	%rax
L2641:
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	2
    jl        L2643
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	2
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	2
    add       %r14,	%rax
L2643:
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	1
    jnz       L2645
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2645:
L2639:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_blockdata
mc_auxmcl.do_blockdata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %eax,	[%r14+4]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L2648
    jmp       L2646
L2648:
    mov       %rax,	%rbx
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rdi,	[%r14+8]
    mov       %r13,	%rsi
    cmp       %r13,	0
    jle       L2651
L2649:
    mov       %rax,	%rdi
    add       %rdi,	8
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    dec       %r13
    jnz       L2649
L2651:
    mov       %rax,	%rsi
    shl       %rax,	3
    mov       %r10,	%rbx
    sub       %r10,	%rax
    mov       %r12,	%r10
    test      %r12,	%r12
    jz        L2653
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    mov       %r8,	66
    call      mc_auxmcl.genstring_db
L2653:
    lea       %rcx,	[%rip+L10644]
    call      mc_libmcl.mgencomment
L2646:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.copyblock
mc_auxmcl.copyblock:
#?>>
    .set mc_auxmcl.copyblock.n, 88
    .set mc_auxmcl.copyblock.savedest, 96
    .set mc_auxmcl.copyblock.oddbytes, -8
    .set mc_auxmcl.copyblock.offset, -16
    .set mc_auxmcl.copyblock.axreg, -24
    .set mc_auxmcl.copyblock.saved, -32
    .set mc_auxmcl.copyblock.av_1, -40
    .set mc_auxmcl.copyblock.$T1, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+88],	%r8
    mov       [%rbp+96],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.saved],	%al
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	16
    jnz       L2656
    mov       %rcx,	2
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	91
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %rcx,	91
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L2654
L2656:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    mov       %r10,	8
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rbp + mc_auxmcl.copyblock.oddbytes],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.offset],	%rax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L2658
    cmp       %rax,	4
    jg        L2658
    mov       %rcx,	%r13
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r13,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r14,	%rax
    mov       [%rbp + mc_auxmcl.copyblock.av_1],	%rsi
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.av_1]
    cmp       %rax,	0
    jle       L2661
L2659:
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
    dec       qword ptr[%rbp + mc_auxmcl.copyblock.av_1]
    jnz       L2659
L2661:
    jmp       L2657
L2658:
    test      %rsi,	%rsi
    jz        L2662
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.savedest]
    test      %rax,	%rax
    jz        L2664
    movzx     %rax,	byte ptr[%r13+10]
    mov       [%rbp + mc_auxmcl.copyblock.axreg],	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.copyblock.axreg]
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rbp + mc_auxmcl.copyblock.saved],	%al
L2664:
    mov       %rcx,	%r13
    call      mc_stackmcl.makesimpleaddr
    mov       %r13,	%rax
    mov       %rcx,	%r14
    call      mc_stackmcl.makesimpleaddr
    mov       %r14,	%rax
    lea       %rax,	[%r13+8]
    mov       %r10w,	8
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.copyblock.$T1],	%rax
    movzx     %rax,	byte ptr[%r13+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.copyblock.$T1],	%rax
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2662:
L2657:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    test      %rax,	%rax
    jz        L2666
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    mov       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	4
    jl        L2668
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	4
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	4
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2668:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	2
    jl        L2670
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	2
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	2
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2670:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	1
    jnz       L2672
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2672:
L2666:
    mov       %al,	[%rbp + mc_auxmcl.copyblock.saved]
    test      %al,	%al
    jz        L2674
    mov       %rcx,	[%rbp + mc_auxmcl.copyblock.axreg]
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2674:
L2654:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genstringtable
mc_auxmcl.genstringtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mc_decls.cstringlist]
    test      %rax,	%rax
    jz        L2675
L2677:
    lea       %rcx,	[%rip+L10645]
    call      mc_libmcl.mgencomment
    mov       %rcx,	73
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rax,	[%rip+mc_decls.kk0used]
    test      %rax,	%rax
    jz        L2679
    mov       %rcx,	[%rip+mc_decls.kk0used]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
L2679:
    mov       %rdi,	[%rip+mc_decls.cstringlist]
    jmp       L2683
L2680:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	-1
    xor       %r8d,	%r8d
    call      mc_auxmcl.genstring_db
    mov       %rdi,	[%rdi+8]
L2683:
    test      %rdi,	%rdi
    jnz       L2680
L2675:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genstring_db
mc_auxmcl.genstring_db:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L2686
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L2686:
    test      %r14,	%r14
    jnz       L2688
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
    jmp       L2684
L2688:
    xor       %rbx,	%rbx
    mov       %rax,	%r14
    mov       %r12,	%rax
    cmp       %r12,	0
    jle       L2691
L2689:
    mov       %rax,	%r13
    inc       %r13
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rdi,	32
    jl        L2694
    cmp       %rdi,	127
    jge       L2694
    mov       %rax,	%rdi
    cmp       %rax,	34
    jz        L2695
    cmp       %rax,	92
    jnz       L2693
L2695:
L2694:
    test      %rbx,	%rbx
    jz        L2697
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_auxmcl.gendbstring
    xor       %rbx,	%rbx
L2697:
    mov       %rcx,	%rdi
    call      mc_auxmcl.gendb
    jmp       L2692
L2693:
    test      %rbx,	%rbx
    jnz       L2699
    mov       %rbx,	1
    lea       %rax,	[%r13-1]
    mov       %rsi,	%rax
    jmp       L2698
L2699:
    inc       %rbx
L2698:
L2692:
    dec       %r12
    jnz       L2689
L2691:
    test      %rbx,	%rbx
    jz        L2701
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_auxmcl.gendbstring
L2701:
    test      %r15,	%r15
    jnz       L2703
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
L2703:
L2684:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendb
mc_auxmcl.gendb:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	116
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendbstring
mc_auxmcl.gendbstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenstring
    mov       %rcx,	120
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendq
mc_auxmcl.gendq:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genrealtable
mc_auxmcl.genrealtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mc_decls.creallist]
    test      %rax,	%rax
    jnz       L2709
    mov       %rax,	[%rip+mc_decls.cr32list]
    test      %rax,	%rax
    jz        L2707
L2709:
    lea       %rcx,	[%rip+L10646]
    call      mc_libmcl.mgencomment
    mov       %rcx,	73
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rdi,	[%rip+mc_decls.creallist]
    jmp       L2713
L2710:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movq      %XMM4,	[%rdi]
    comisd    %XMM4,	[%rip+L10647]
    jnz       L2715
    movq      %XMM4,	[%rdi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2714
L2715:
    movq      %XMM4,	[%rdi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2714:
    mov       %rdi,	[%rdi+8]
L2713:
    test      %rdi,	%rdi
    jnz       L2710
    lea       %rcx,	[%rip+L10648]
    call      mc_libmcl.mgencomment
    mov       %rdi,	[%rip+mc_decls.cr32list]
    jmp       L2719
L2716:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movq      %XMM4,	[%rdi]
    comisd    %XMM4,	[%rip+L10649]
    jnz       L2721
    movq      %XMM4,	[%rdi]
    cvtsd2ss  %XMM4,	%XMM4
    movd      %eax,	%XMM4
    mov       %ecx,	%eax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	118
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2720
L2721:
    movq      %XMM4,	[%rdi]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rcx,	118
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2720:
    mov       %rdi,	[%rdi+8]
L2719:
    test      %rdi,	%rdi
    jnz       L2716
L2707:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genabsneg
mc_auxmcl.genabsneg:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.lababs32]
    add       %rax,	[%rip+mc_decls.lababs64]
    add       %rax,	[%rip+mc_decls.labneg32]
    add       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jz        L2724
    mov       %rcx,	73
    mov       %rdx,	16
    call      mc_libmcl.setsegment
L2724:
    mov       %rax,	[%rip+mc_decls.lababs32]
    test      %rax,	%rax
    jz        L2726
    lea       %rcx,	[%rip+L10650]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372034707292159
    call      mc_auxmcl.gendq
    mov       %rcx,	9223372034707292159
    call      mc_auxmcl.gendq
L2726:
    mov       %rax,	[%rip+mc_decls.lababs64]
    test      %rax,	%rax
    jz        L2728
    lea       %rcx,	[%rip+L10651]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
L2728:
    mov       %rax,	[%rip+mc_decls.labneg32]
    test      %rax,	%rax
    jz        L2730
    lea       %rcx,	[%rip+L10652]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
    mov       %rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
L2730:
    mov       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jz        L2732
    lea       %rcx,	[%rip+L10653]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
    mov       %rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
L2732:
    mov       %rax,	[%rip+mc_decls.labzero]
    test      %rax,	%rax
    jz        L2734
    lea       %rcx,	[%rip+L10654]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labzero]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendq
L2734:
    mov       %rax,	[%rip+mc_decls.labmask63]
    test      %rax,	%rax
    jz        L2736
    lea       %rcx,	[%rip+L10655]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       %rcx,	[%rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	4890909195324358656
    call      mc_auxmcl.gendq
L2736:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_maths
mc_auxmcl.do_maths:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	%rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_host
mc_auxmcl.do_host:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    mov       %r9,	%rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_callrts
mc_auxmcl.do_callrts:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    mov       %rcx,	%r14
    call      mc_stackmcl.saveopnds
    xor       %rdi,	%rdi
    mov       %eax,	[%rip+mc_decls.mstackdepth]
    and       %eax,	1
    test      %rax,	%rax
    jz        L2741
    mov       %rcx,	1
    call      mc_libmcl.pushslots
    mov       %rdi,	1
L2741:
    mov       %rcx,	%r14
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_pushlowargs
    mov       %rax,	[%rip+mc_decls.mstackdepth]
    test      %rax,	%rax
    jz        L2743
    mov       %rax,	4
    add       %rdi,	%rax
    mov       %rcx,	4
    call      mc_libmcl.pushslots
    jmp       L2742
L2743:
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
L2742:
    test      %r12,	%r12
    jz        L2745
    mov       %rcx,	%r12
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2744
L2745:
    mov       %rcx,	%r13
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2744:
    mov       %rbx,	%r14
    cmp       %rbx,	0
    jle       L2748
L2746:
    call      mc_stackmcl.poppcl
    dec       %rbx
    jnz       L2746
L2748:
    test      %rdi,	%rdi
    jz        L2750
    mov       %rcx,	%rdi
    call      mc_libmcl.popslots
L2750:
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_getretvalue
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_int
mc_auxmcl.do_max_int:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	15
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_float
mc_auxmcl.do_max_float:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_int
mc_auxmcl.do_maxto_int:
#?>>
    .set mc_auxmcl.do_maxto_int.mode, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	26
    mov       %rdx,	%r13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_real
mc_auxmcl.do_maxto_real:
#?>>
    .set mc_auxmcl.do_maxto_real.mode, 72
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r13,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%r13
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r12,	%r10
    mov       %rcx,	26
    mov       %rdx,	%r14
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_negreal
mc_auxmcl.do_negreal:
#?>>
    .set mc_auxmcl.do_negreal.mode, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    test      %rax,	%rax
    jz        L2757
    mov       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jnz       L2759
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.labneg64],	%rax
L2759:
    mov       %rcx,	[%rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	77
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2756
L2757:
    mov       %rax,	[%rip+mc_decls.labneg32]
    test      %rax,	%rax
    jnz       L2761
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.labneg32],	%rax
L2761:
    mov       %rcx,	[%rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	76
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2756:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_absreal
mc_auxmcl.do_absreal:
#?>>
    .set mc_auxmcl.do_absreal.mode, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    test      %rax,	%rax
    jz        L2764
    mov       %rax,	[%rip+mc_decls.lababs64]
    test      %rax,	%rax
    jnz       L2766
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.lababs64],	%rax
L2766:
    mov       %rcx,	[%rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	79
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2763
L2764:
    mov       %rax,	[%rip+mc_decls.lababs32]
    test      %rax,	%rax
    jnz       L2768
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.lababs32],	%rax
L2768:
    mov       %rcx,	[%rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	78
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2763:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_const
mc_auxmcl.do_loadbf_const:
#?>>
    .set mc_auxmcl.do_loadbf_const.p, 56
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    cmp       %r13,	63
    jnz       L2771
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	44
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2770
L2771:
    test      %r12,	%r12
    jz        L2773
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2773:
    mov       %rax,	%r13
    sub       %rax,	%r12
    inc       %rax
    mov       %r10,	-1
    mov       %cl,	%al
    shl       %r10,	%cl
    not       %r10
    mov       %rsi,	%r10
    cmp       %rsi,	2147483647
    ja        L2775
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2774
L2775:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2774:
L2770:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_var
mc_auxmcl.do_loadbf_var:
#?>>
    .set mc_auxmcl.do_loadbf_var.p, 16
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L10656]
    lea       %rdx,	[%rip+L10657]
    call      pc_api.merror
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_storebit
mc_auxmcl.do_storebit:
#?>>
    .set mc_auxmcl.do_storebit.p, 72
    .set mc_auxmcl.do_storebit.offset, -8
    .set mc_auxmcl.do_storebit.mask1s, -16
    .set mc_auxmcl.do_storebit.mask0s, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %r13,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r14,	%rax
    test      %r13,	%r13
    jz        L2779
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %r15,	[%r13+8]
    mov       %rax,	%r15
    sar       %rax,	3
    mov       [%rbp + mc_auxmcl.do_storebit.offset],	%rax
    mov       %rax,	7
    and       %r15,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + mc_auxmcl.do_storebit.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rdi,	%rax
    mov       %rax,	1
    mov       %cl,	%r15b
    shl       %rax,	%cl
    mov       [%rbp + mc_auxmcl.do_storebit.mask0s],	%al
    mov       %rax,	1
    mov       %cl,	%r15b
    shl       %rax,	%cl
    not       %rax
    mov       [%rbp + mc_auxmcl.do_storebit.mask1s],	%al
    test      %r14,	%r14
    jz        L2781
    mov       %rax,	[%r14+8]
    test      %rax,	%rax
    jnz       L2783
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask1s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2782
L2783:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask0s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2782:
    jmp       L2780
L2781:
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	3
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask1s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    test      %r15,	%r15
    jz        L2785
    mov       %rcx,	%r15
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2785:
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2780:
    jmp       L2778
L2779:
    test      %r14,	%r14
    jz        L2786
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    test      %r13,	%r13
    jnz       L2788
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rsi,	%rax
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2790
    mov       %rcx,	12
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2790:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	10
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %r12,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	43
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2792
    mov       %rcx,	13
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2792:
    mov       %rax,	[%r14+8]
    test      %rax,	%rax
    jnz       L2794
    mov       %rcx,	51
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L2793
L2794:
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2793:
    jmp       L2787
L2788:
    lea       %rcx,	[%rip+L10658]
    lea       %rdx,	[%rip+L10659]
    call      pc_api.merror
L2787:
    jmp       L2778
L2786:
    lea       %rcx,	[%rip+L10660]
    lea       %rdx,	[%rip+L10661]
    call      pc_api.merror
L2778:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_storebf
mc_auxmcl.do_storebf:
#?>>
    .set mc_auxmcl.do_storebf.p, 72
    .set mc_auxmcl.do_storebf.r, -8
    .set mc_auxmcl.do_storebf.mask, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r15,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [%rbp + mc_auxmcl.do_storebf.r],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.r]
    cmp       %rax,	%r15
    jnz       L2797
    test      %rax,	%rax
    jnz       L2797
    lea       %rcx,	[%rip+L10662]
    lea       %rdx,	[%rip+L10663]
    call      pc_api.merror
L2797:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	3
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %r13,	[%r15+8]
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.r]
    mov       %r14,	[%rax+8]
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	%r14
    sub       %rax,	%r13
    inc       %rax
    mov       %r10,	-1
    mov       %cl,	%al
    shl       %r10,	%cl
    not       %r10
    mov       %cl,	%r13b
    shl       %r10,	%cl
    not       %r10
    mov       [%rbp + mc_auxmcl.do_storebf.mask],	%r10
    mov       %rcx,	[%rbp + mc_auxmcl.do_storebf.mask]
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    test      %r13,	%r13
    jz        L2799
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2799:
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.p]
    mov       %eax,	[%rax+4]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	38
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	39
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.p]
    mov       %eax,	[%rax+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gethostfn
mc_auxmcl.gethostfn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rax,	[%rip+pc_api.igethostfn]
    test      %rax,	%rax
    jnz       L2802
    cmp       %r13,	82
    jnz       L2805
L2804:
    lea       %rax,	[%rip+L10664]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+L10665]
    mov       %rsi,	%rax
    jmp       L2803
L2805:
    xor       %rbx,	%rbx
L2803:
    test      %rbx,	%rbx
    jz        L2807
    mov       %r12,	[%rip+pc_decls.psymboltable]
    jmp       L2811
L2808:
    mov       %rax,	[%r12]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L2814
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2813
L2814:
    mov       %rax,	%r12
    jmp       L2800
L2813:
    mov       %r12,	[%r12+8]
L2811:
    test      %r12,	%r12
    jnz       L2808
L2807:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L10666]
    mov       %rdx,	%rax
    call      pc_api.merror
L2802:
    mov       %rcx,	%r13
    mov       %rax,	[%rip+pc_api.igethostfn]
    call      %rax
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L2816
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L10667]
    mov       %rdx,	%rax
    call      pc_api.merror
L2816:
    mov       %rax,	%rdi
L2800:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.copyblockarg
mc_auxmcl.copyblockarg:
#?>>
    .set mc_auxmcl.copyblockarg.argno, 72
    .set mc_auxmcl.copyblockarg.$T3, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    test      %r12,	%r12
    jnz       L2819
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10668]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L10669]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2817
L2819:
    mov       %rcx,	%r13
    call      mc_libmcl.newblocktemp
    mov       %rdi,	%rax
    mov       %al,	1
    mov       [%rdi+92],	%al
    test      %r12,	%r12
    jz        L2821
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    jmp       L2820
L2821:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	11
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
L2820:
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       [%rbp + mc_auxmcl.copyblockarg.$T3],	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.copyblockarg.$T3]
    mov       %r8,	%r13
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    test      %r12,	%r12
    jz        L2823
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2823:
    xor       %ecx,	%ecx
    call      mc_stackmcl.freeworkregs
L2817:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.fixmain
mc_auxmcl.fixmain:
#?>>
    .set mc_auxmcl.fixmain.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    mov       %rbx,	[%rdi+16]
    mov       %rsi,	[%rbx+16]
    lea       %rcx,	[%rip+L10670]
    mov       %rdx,	3
    call      pc_api.pc_makesymbol
    mov       %r12,	%rax
    mov       %al,	6
    mov       [%r12+82],	%al
    mov       %eax,	8
    mov       [%r12+84],	%eax
    lea       %rcx,	[%rip+L10671]
    mov       %rdx,	3
    call      pc_api.pc_makesymbol
    mov       %r13,	%rax
    mov       %al,	11
    mov       [%r13+82],	%al
    mov       %eax,	128
    mov       [%r13+84],	%eax
    mov       %rcx,	90
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rcx,	%r13
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	128
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    mov       %rcx,	%r12
    call      pc_api.pc_addlocal
    mov       %rcx,	%r13
    call      pc_api.pc_addlocal
    xor       %eax,	%eax
    mov       [%rdi+16],	%rax
    mov       [%rsi+16],	%rax
    mov       [%rbx+16],	%rax
    xor       %eax,	%eax
    mov       [%rdi+112],	%al
    mov       %al,	4
    mov       [%rbx+72],	%al
    mov       %al,	1
    mov       [%rbx+92],	%al
    mov       %al,	4
    mov       [%rsi+72],	%al
    mov       %al,	4
    mov       [%rsi+92],	%al
    mov       %rcx,	%rsi
    call      pc_api.pc_addlocal
    mov       %rcx,	%rbx
    call      pc_api.pc_addlocal
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %r10,	%rax
    mov       %r14,	%r10
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%r13+88],	%al
    mov       %rcx,	12
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	32
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rbx+88],	%al
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rsi+88],	%al
    mov       %rcx,	%r12
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	13
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%r12+88],	%al
    mov       %rcx,	14
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	%rax
    call      mc_libmcl.clearreg
    lea       %rcx,	[%rip+L10672]
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	48
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    test      %rax,	%rax
    jz        L2826
    mov       %rcx,	[%rip+pc_decls.pcmdskip]
    mov       %rdx,	9
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	29
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    shl       %rax,	3
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
L2826:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mclinit
mc_libmcl.mclinit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %rax,	64
    cmp       %rax,	64
    jle       L2829
    lea       %rcx,	[%rip+L10673]
    call      mlib.abortprogram
L2829:
    mov       %rbx,	1
L2830:
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	2
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+8],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+24],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+56],	%rax
    inc       %rbx
    cmp       %rbx,	16
    jle       L2830
    mov       %r13,	-128
    mov       %rsi,	64
    cmp       %rsi,	-128
    jl        L2835
L2833:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r8w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       %al,	15
    mov       [%rdi+10],	%al
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r8w,	[%rax]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       [%rdi+12],	%r13d
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.frameregtable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8+1024],	%rax
    inc       %r13
    cmp       %r13,	%rsi
    jle       L2833
L2835:
    mov       %rcx,	15
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rip+mc_decls.dframeopnd],	%rax
    mov       %rcx,	16
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rip+mc_decls.dstackopnd],	%rax
    call      mc_libmcl.initmcdest
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    xor       %eax,	%eax
    mov       [%rip+mc_decls.lab_funcnametable],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.lab_funcaddrtable],	%rax
    mov       %r13,	-1
    mov       %r12,	10
    cmp       %r12,	-1
    jl        L2838
L2836:
    mov       %rcx,	%r13
    mov       %rdx,	8
    call      mc_libmcl.mgenint0
    lea       %r10,	[%rip+mc_libmcl.smallinttable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8+8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L2836
L2838:
    test      %r14,	%r14
    jz        L2840
    mov       %al,	1
    mov       [%rip+pc_decls.mcldone],	%al
L2840:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.initmcdest
mc_libmcl.initmcdest:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       [%rip+mc_decls.mccode],	%rax
#---------------
    ret       
# End 
# Proc mc_libmcl.genmc
mc_libmcl.genmc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	64
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi+33],	%sil
    inc       qword ptr[%rip+mc_libmcl.mclseqno]
    mov       %rax,	[%rip+mc_libmcl.mclseqno]
    mov       [%rdi+36],	%eax
    mov       %eax,	[%rip+pc_decls.mmpos]
    mov       [%rdi+40],	%eax
    mov       [%rdi+16],	%r12
    mov       [%rdi+24],	%r13
    mov       %rax,	%rsi
    cmp       %rax,	14
    jz        L2844
    cmp       %rax,	9
    jz        L2845
    cmp       %rax,	11
    jz        L2846
    jmp       L2847
L2844:
    test      %r13,	%r13
    jz        L2849
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jnz       L2849
    mov       %rax,	[%r13]
    mov       %r10b,	1
    mov       [%rax+88],	%r10b
L2849:
    jmp       L2843
L2845:
    mov       %rbx,	[%r12]
    jmp       L2843
L2846:
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L2852
    test      %r13,	%r13
    jz        L2851
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2851
L2852:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2854
    mov       %rax,	17
    jmp       L2853
L2854:
    mov       %rax,	16
L2853:
    mov       [%rdi+33],	%al
L2851:
L2847:
L2843:
    mov       %rax,	[%rip+mc_decls.mccode]
    test      %rax,	%rax
    jz        L2856
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rdi],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       [%rip+mc_decls.mccodex],	%rdi
    jmp       L2855
L2856:
    mov       %rax,	%rdi
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       [%rip+mc_decls.mccode],	%rax
L2855:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.genmc_cond
mc_libmcl.genmc_cond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %al,	%bl
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+34],	%al
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.genmc_str
mc_libmcl.genmc_str:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    call      mc_libmcl.mgenstring
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.newmclopnd
mc_libmcl.newmclopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    inc       qword ptr[%rip+mc_libmcl.nmclopnd]
    mov       %rax,	%rdi
L2859:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.duplopnd
mc_libmcl.duplopnd:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    movdqu    %XMM4,	[%rax]
    movdqu    [%rdi],	%XMM4
    mov       %rax,	%rdi
L2860:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenindex
mc_libmcl.mgenindex:
#?>>
    .set mc_libmcl.mgenindex.size, 96
    .set mc_libmcl.mgenindex.labno, 104
    .set mc_libmcl.mgenindex.def, 112
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r15w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       [%rdi+10],	%bl
    cmp       %rbx,	15
    jz        L2864
    cmp       %rsi,	15
    jnz       L2863
L2864:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2863:
    mov       [%rdi+11],	%sil
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%r12w
    mov       %r15w,	[%rax]
    mov       %r11,	-481
    shl       %r10w,	5
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	[%rbp + mc_libmcl.mgenindex.size]
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       [%rdi+12],	%r13d
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.labno]
    test      %rax,	%rax
    jz        L2866
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.labno]
    mov       [%rdi],	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r15w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    jmp       L2865
L2866:
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    test      %rax,	%rax
    jz        L2867
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    mov       [%rdi],	%rax
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    lea       %rax,	[%rax+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r15w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	4
    jz        L2870
    cmp       %rax,	5
    jnz       L2869
L2870:
    mov       %al,	15
    mov       [%rdi+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2869:
L2867:
L2865:
    mov       %rax,	%rdi
L2861:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r15
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgencomment
mc_libmcl.mgencomment:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	3
    mov       %rdx,	%rdi
    call      mc_libmcl.genmc_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenstring
mc_libmcl.mgenstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    cmp       %rsi,	0
    jge       L2874
    mov       %rcx,	%rbx
    call      strlen
    mov       %rsi,	%rax
L2874:
    lea       %rax,	[%rsi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rdi],	%rax
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	[%rdi]
    xor       %r10d,	%r10d
    mov       %r11,	%rsi
    mov       [%rax + %r11],	%r10b
    lea       %rax,	[%rdi+8]
    mov       %r10w,	4
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2872:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenname
mc_libmcl.mgenname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	7
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2875:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.setsegment
mc_libmcl.setsegment:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    cmp       %rsi,	[%rip+mc_decls.currsegment]
    jz        L2878
    mov       %rax,	%rsi
    cmp       %rax,	73
    jz        L2880
    cmp       %rax,	90
    jz        L2881
    cmp       %rax,	67
    jz        L2882
    cmp       %rax,	82
    jz        L2883
    jmp       L2884
L2880:
    mov       %rdi,	121
    jmp       L2879
L2881:
    mov       %rdi,	122
    jmp       L2879
L2882:
    mov       %rdi,	123
    jmp       L2879
L2883:
    lea       %rcx,	[%rip+L10674]
    lea       %rdx,	[%rip+L10675]
    call      pc_api.merror
    jmp       L2879
L2884:
    lea       %rcx,	[%rip+L10676]
    lea       %rdx,	[%rip+L10677]
    call      pc_api.merror
L2879:
    mov       %rax,	[%rip+mc_decls.mccodex]
    test      %rax,	%rax
    jz        L2886
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	121
    jz        L2887
    cmp       %rax,	122
    jz        L2887
    cmp       %rax,	123
    jnz       L2886
L2887:
    mov       %al,	%dil
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+33],	%al
    jmp       L2885
L2886:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2885:
    mov       [%rip+mc_decls.currsegment],	%rsi
L2878:
    cmp       %r12,	1
    jle       L2889
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	124
    jnz       L2891
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rax+16]
    mov       %rbx,	[%rax]
    cmp       %rbx,	%r12
    jge       L2876
L2893:
L2891:
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	124
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2889:
L2876:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.changeopndsize
mc_libmcl.changeopndsize:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	%rsi
    jz        L2896
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2898
    movzx     %rax,	byte ptr[%rbx+10]
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rax
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       %rax,	%rsi
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    jmp       L2897
L2898:
    mov       %rcx,	%rbx
    call      mc_libmcl.duplopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r8w,	[%rax]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
L2897:
    mov       %rax,	%rdi
    jmp       L2894
L2896:
    mov       %rax,	%rbx
L2894:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.applyoffset
mc_libmcl.applyoffset:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L2901
    test      %r12,	%r12
    jnz       L2901
    mov       %rax,	%rbx
    jmp       L2899
L2901:
    mov       %rcx,	%rbx
    call      mc_libmcl.duplopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+12]
    mov       %r10d,	%esi
    add       [%rax],	%r10d
    test      %r12,	%r12
    jz        L2903
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%r12w
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L2903:
    mov       %rax,	%rdi
L2899:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenint
mc_libmcl.mgenint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	-1
    jl        L2906
    cmp       %rax,	10
    jg        L2906
    cmp       %rbx,	8
    jnz       L2906
    lea       %rax,	[%rip+mc_libmcl.smallinttable]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8+8]
    jmp       L2904
L2906:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rsi
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%bx
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2904:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenint0
mc_libmcl.mgenint0:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rbx
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2907:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealmem
mc_libmcl.mgenrealmem:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rbx-1]
    test      %rax,	%rax
    jz        L2910
    movq      %XMM0,	%XMM15
    call      mc_libmcl.getrealindex
    mov       [%rdi],	%rax
    jmp       L2909
L2910:
    movq      %XMM0,	%XMM15
    call      mc_libmcl.getr32index
    mov       [%rdi],	%rax
L2909:
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	%rdi
L2908:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealimm
mc_libmcl.mgenrealimm:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    movq      %XMM4,	%XMM15
    movq      [%rdi],	%XMM4
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	%rdi
L2911:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabel
mc_libmcl.mgenlabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rbx,	%rbx
    jnz       L2914
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rbx,	[%rip+pc_api.mlabelno]
L2914:
    mov       [%rdi],	%rbx
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2912:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabelmem
mc_libmcl.mgenlabelmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2915:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenmem
mc_libmcl.mgenmem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %al,	[%rsi+90]
    test      %al,	%al
    jz        L2918
    movzx     %rax,	byte ptr[%rsi+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2920
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenxregvar
    jmp       L2916
L2920:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mc_libmcl.mgenregvar
    jmp       L2916
L2919:
L2918:
    xor       %rbx,	%rbx
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	4
    jz        L2923
    cmp       %rax,	5
    jnz       L2922
L2923:
    mov       %rbx,	15
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2922:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    mov       [%rdi],	%rsi
    lea       %rax,	[%rsi+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %r12,	%r12
    jz        L2925
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    jmp       L2924
L2925:
    mov       %eax,	[%rsi+84]
    mov       %r10,	8
    cmp       %rax,	%r10
    cmova     %rax,	%r10
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
L2924:
    mov       %rax,	%rdi
L2916:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenmemaddr
mc_libmcl.mgenmemaddr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	1
    mov       [%rbx+88],	%al
    lea       %rax,	[%rbx+89]
    inc       byte ptr[%rax]
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rbx
    lea       %rax,	[%rbx+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2926:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg0
mc_libmcl.mgenreg0:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rsi,	%rsi
    jnz       L2929
    lea       %rcx,	[%rip+L10678]
    lea       %rdx,	[%rip+L10679]
    call      pc_api.merror
L2929:
    mov       %rax,	%rdi
L2927:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenxreg
mc_libmcl.mgenxreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rsi,	%rsi
    jnz       L2932
    lea       %rcx,	[%rip+L10680]
    lea       %rdx,	[%rip+L10681]
    call      pc_api.merror
L2932:
    mov       %rax,	%rdi
L2930:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg
mc_libmcl.mgenreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    cmp       %r12,	2
    jg        L2935
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r8w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       [%rdi+10],	%sil
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedxregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r8w,	[%r10]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%ax
    mov       [%r10],	%r8w
    mov       %rax,	%rdi
    jmp       L2934
L2935:
    test      %rbx,	%rbx
    jnz       L2937
    mov       %rbx,	8
L2937:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rsi
    cmp       %rax,	11
    jl        L2939
    cmp       %rax,	14
    jg        L2939
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2939:
    lea       %rax,	[%rip+mc_decls.regtable]
    mov       %r10,	%rsi
    shl       %r10,	6
    lea       %rax,	[%rax + %r10-64]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2933
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg0
L2934:
L2933:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenregi
mc_libmcl.mgenregi:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.regtable]
    mov       %r10,	%rdi
    shl       %r10,	6
    lea       %rax,	[%rax + %r10-64]
    lea       %r10,	[%rip+pc_tables.psize]
    mov       %r11,	%rbx
    movzx     %r10,	byte ptr[%r10 + %r11]
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2940
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg0
L2940:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenireg
mc_libmcl.mgenireg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       [%rdi+12],	%r12d
    mov       %rax,	%rdi
L2941:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgentemp
mc_libmcl.mgentemp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2944
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rip+mc_decls.pcltempopnds]
    mov       %r11,	%rbx
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    jmp       L2942
L2944:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %al,	15
    mov       [%rdi+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       [%rdi],	%rbx
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.pcltempopnds]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pcltempflags]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
L2942:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.roundsizetg
mc_libmcl.roundsizetg:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    and       %rax,	7
    jnz       L2947
    mov       %rax,	%rcx
    jmp       L2945
L2947:
    mov       %rax,	%rcx
    and       %rax,	7
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rax,	%rcx
    add       %rax,	%r10
L2945:
#---------------
    ret       
# End 
# Proc mc_libmcl.merroropnd
mc_libmcl.merroropnd:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10682]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+pc_tables.opndnames]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mcreatefwdlabel
mc_libmcl.mcreatefwdlabel:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
L2949:
#---------------
    ret       
# End 
# Proc mc_libmcl.mdefinefwdlabel
mc_libmcl.mdefinefwdlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenextname
mc_libmcl.mgenextname:
#?>>
    .set mc_libmcl.mgenextname.str, -64
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
    mov       %rbx,	%rcx
#---------------
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    mov       %rdx,	%rbx
    call      strcpy
    mov       %rcx,	%rbx
    call      strlen
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mc_libmcl.mgenextname.str-1],	%r10b
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    call      mc_libmcl.findnamesym
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L2953
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    mov       %al,	1
    mov       [%rdi+72],	%al
    mov       %al,	1
    mov       [%rdi+80],	%al
    mov       %rcx,	%rdi
    call      mc_libmcl.addnamesym
L2953:
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenmemaddr
L2951:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenregvar
mc_libmcl.mgenregvar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L2954:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenxregvar
mc_libmcl.mgenxregvar:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.isxregvar]
    mov       [%r11 + %rax-1],	%r10b
    mov       %rax,	%rdi
L2955:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getprimreg
mc_libmcl.getprimreg:
#?>>
#?]]
#---------------
    mov       %al,	[%rcx+10]
    test      %al,	%al
    jz        L2958
    movzx     %rax,	byte ptr[%rcx+10]
    jmp       L2957
L2958:
    movzx     %rax,	byte ptr[%rcx+11]
L2957:
L2956:
#---------------
    ret       
# End 
# Proc mc_libmcl.pushslots
mc_libmcl.pushslots:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mc_libmcl.pushstack
    mov       %rax,	%rdi
    add       [%rip+mc_decls.mstackdepth],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.popslots
mc_libmcl.popslots:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mc_libmcl.popstack
    mov       %rax,	%rdi
    sub       [%rip+mc_decls.mstackdepth],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.pushstack
mc_libmcl.pushstack:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L2963
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2963:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.popstack
mc_libmcl.popstack:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L2966
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	28
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2966:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getstringindex
mc_libmcl.getstringindex:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jnz       L2969
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.kk0used],	%rax
    mov       %rax,	[%rip+mc_decls.kk0used]
    jmp       L2967
L2969:
    mov       %rax,	[%rip+mc_decls.cstringlist]
    test      %rax,	%rax
    jz        L2971
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2971
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax+16]
    jmp       L2967
L2971:
    lea       %rcx,	[%rip+mc_decls.cstringlist]
    mov       %rdx,	%rdi
    call      mc_libmcl.addconst
L2967:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.addconst
mc_libmcl.addconst:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	24
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi],	%rsi
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rbx]
    mov       [%rdi+8],	%rax
    mov       [%rbx],	%rdi
    mov       %rax,	[%rip+pc_api.mlabelno]
L2972:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getrealindex
mc_libmcl.getrealindex:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
#---------------
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    lea       %rcx,	[%rip+mc_decls.creallist]
    mov       %rdx,	%rax
    call      mc_libmcl.addconst
L2973:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mc_libmcl.getr32index
mc_libmcl.getr32index:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
#---------------
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    lea       %rcx,	[%rip+mc_decls.cr32list]
    mov       %rdx,	%rax
    call      mc_libmcl.addconst
L2974:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mc_libmcl.ispoweroftwo
mc_libmcl.ispoweroftwo:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	1
    xor       %rbx,	%rbx
    mov       %rax,	60
    mov       %rsi,	%rax
L2976:
    inc       %rbx
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %rdi,	%rax
    cmp       %rdi,	%rcx
    jnz       L2980
    mov       %rax,	%rbx
    jmp       L2975
L2980:
    dec       %rsi
    jnz       L2976
    xor       %eax,	%eax
L2975:
#---------------
    add       %rsp,	16
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.axerror
mc_libmcl.axerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10683]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L10684]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.aapos]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.newblocktemp
mc_libmcl.newblocktemp:
#?>>
    .set mc_libmcl.newblocktemp.str, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.nblocktemps]
    cmp       %rax,	50
    jle       L2984
    lea       %rcx,	[%rip+L10685]
    lea       %rdx,	[%rip+L10686]
    call      pc_api.merror
L2984:
    inc       qword ptr[%rip+mc_decls.nblocktemps]
    lea       %rcx,	[%rbp + mc_libmcl.newblocktemp.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10687]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.nblocktemps]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_libmcl.newblocktemp.str]
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       %al,	11
    mov       [%rdi+82],	%al
    mov       [%rdi+84],	%ebx
    mov       %al,	1
    mov       [%rdi+92],	%al
    mov       %al,	4
    mov       [%rdi+72],	%al
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+24]
    mov       [%rdi+24],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+pc_decls.currfunc]
    mov       [%r10+24],	%rax
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.blockdefs]
    mov       %r11,	[%rip+mc_decls.nblocktemps]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%rdi
L2982:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.findnamesym
mc_libmcl.findnamesym:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    cmp       %rax,	1
    jl        L2988
L2986:
    lea       %rax,	[%rip+mc_libmcl.nametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2990
    lea       %rax,	[%rip+mc_libmcl.nametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2985
L2990:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_libmcl.nnametable]
    jle       L2986
L2988:
    xor       %eax,	%eax
L2985:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.addnamesym
mc_libmcl.addnamesym:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    cmp       %rax,	20
    jge       L2993
    inc       qword ptr[%rip+mc_libmcl.nnametable]
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+mc_libmcl.nametable]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L2992
L2993:
    lea       %rcx,	[%rip+L10688]
    lea       %rdx,	[%rip+L10689]
    call      pc_api.merror
L2992:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.callproc
mc_libmcl.callproc:
#?>>
    .set mc_libmcl.callproc.cpname, 16
    .set mc_libmcl.callproc.name, 24
    .set mc_libmcl.callproc.lineno, 32
#?]]
#---------------
L2994:
#---------------
    ret       
# End 
# Proc mc_libmcl.mgenstringx
mc_libmcl.mgenstringx:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
L2995:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.clearreg
mc_libmcl.clearreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2998
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
L2998:
    mov       %rcx,	40
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd
mc_stackmcl.getopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L3001
    cmp       %rax,	2
    jz        L3001
    cmp       %rax,	3
    jz        L3002
    jmp       L3003
L3001:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenreg
    jmp       L2999
L3002:
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      mc_libmcl.mgentemp
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L2999
L3003:
L3000:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	1
    jz        L3005
    cmp       %rax,	2
    jz        L3006
    cmp       %rax,	4
    jz        L3007
    cmp       %rax,	5
    jz        L3008
    cmp       %rax,	6
    jz        L3008
    cmp       %rax,	7
    jz        L3009
    cmp       %rax,	3
    jz        L3010
    jmp       L3011
L3005:
    mov       %r12,	[%rsi+8]
    cmp       %r14,	11
    jnz       L3013
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	5
    jz        L3013
    mov       %r14,	6
    jmp       L3006
L3013:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
L3012:
    jmp       L3004
L3006:
    mov       %r12,	[%rsi+8]
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	5
    jnz       L3015
    movzx     %rax,	byte ptr[%r12+82]
    cmp       %rax,	11
    jnz       L3015
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    jmp       L3014
L3015:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L3014:
    jmp       L3004
L3007:
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	2
    jz        L3017
    cmp       %rax,	4
    jz        L3018
    jmp       L3019
L3017:
    lea       %rax,	[%rsi+8]
    mov       %r10,	65535
    and       [%rax],	%r10
    jmp       L3016
L3018:
    lea       %rax,	[%rsi+8]
    mov       %r10,	4294967295
    and       [%rax],	%r10
L3019:
L3016:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenint
    mov       %rbx,	%rax
    mov       %rax,	[%rsi+8]
    cmp       %rax,	-2147483648
    jl        L3021
    cmp       %rax,	2147483647
    jg        L3021
    mov       %rdi,	%rbx
    jmp       L3020
L3021:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L3020:
    jmp       L3004
L3008:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	%r14
    call      mc_libmcl.mgenrealmem
    mov       %rdi,	%rax
    jmp       L3004
L3009:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L3004
L3010:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L3004
L3011:
#mc_stackmcl.getopnd.error:
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L10690]
    mov       %rdx,	%r10
    call      pc_api.merror
L3004:
    mov       %rax,	%rdi
L2999:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadopnd
mc_stackmcl.loadopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L3025
    test      %r12,	%r12
    jnz       L3027
    mov       %rcx,	%rsi
    call      mc_stackmcl.getworkreg
    mov       %r12,	%rax
L3027:
L3025:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.loadtoreg
    mov       %rdi,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rdi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
L3023:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadparam
mc_stackmcl.loadparam:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.loadtoreg_m
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L3028:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushopnd
mc_stackmcl.pushopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%r12
    mov       %rsi,	[%rax + %r10*8-8]
    test      %r13,	%r13
    jnz       L3031
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r13,	%rax
L3031:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L3033
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	1
    jz        L3035
    cmp       %rax,	4
    jz        L3036
    cmp       %rax,	5
    jz        L3037
    jmp       L3038
L3035:
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	8
    jnz       L3040
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    jmp       L3041
L3040:
    jmp       L3034
L3036:
    mov       %rax,	[%rsi+8]
    cmp       %rax,	-2147483648
    jl        L3043
    cmp       %rax,	2147483647
    jg        L3043
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rdi,	%rax
    jmp       L3041
L3043:
    jmp       L3034
L3037:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      mc_libmcl.mgenrealmem
    mov       %rdi,	%rax
    jmp       L3041
L3038:
L3034:
L3033:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L3045
    mov       %rbx,	%rdi
    cmp       %r13,	4
    jnz       L3047
    mov       %rax,	5
    jmp       L3046
L3047:
    mov       %rax,	6
L3046:
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L3045:
#mc_stackmcl.pushopnd.pushit:
L3041:
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    inc       qword ptr[%rip+mc_decls.mstackdepth]
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg
mc_stackmcl.loadtoreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3051
    cmp       %rax,	5
    jnz       L3050
L3051:
    test      %r12,	%r12
    jz        L3054
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	%r12
    jnz       L3053
L3054:
    mov       %rax,	%rbx
    jmp       L3048
L3053:
L3050:
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_stackmcl.loadtoreg_common
    mov       %rax,	%rdi
L3048:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_m
mc_stackmcl.loadtoreg_m:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3058
    cmp       %rax,	5
    jnz       L3057
L3058:
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	%r12
    jnz       L3060
    mov       %rax,	%rbx
    jmp       L3055
L3060:
L3057:
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_stackmcl.loadtoreg_common
    mov       %rax,	%rdi
L3055:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_common
mc_stackmcl.loadtoreg_common:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L3063
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L3063
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3063
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    jmp       L3062
L3063:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L3062:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl
mc_stackmcl.pushpcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	50
    jl        L3066
    lea       %rcx,	[%rip+L10691]
    lea       %rdx,	[%rip+L10692]
    call      pc_api.merror
L3066:
    inc       qword ptr[%rip+mc_decls.noperands]
    mov       %rdi,	[%rip+mc_decls.noperands]
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rbx+3]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	1
    jnz       L3068
    mov       %rax,	[%rbx+8]
    mov       %al,	[%rax+90]
    test      %al,	%al
    jz        L3068
    mov       %rax,	[%rbx+8]
    mov       %al,	[%rax+90]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	2
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L3068:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl_reg
mc_stackmcl.pushpcl_reg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	50
    jl        L3071
    lea       %rcx,	[%rip+L10693]
    lea       %rdx,	[%rip+L10694]
    call      pc_api.merror
L3071:
    test      %rsi,	%rsi
    jnz       L3073
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkreg
    mov       %rsi,	%rax
L3073:
    inc       qword ptr[%rip+mc_decls.noperands]
    mov       %rdi,	[%rip+mc_decls.noperands]
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	%sil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%bl
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    cmp       %rbx,	2
    jg        L3075
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    jmp       L3074
L3075:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L3074:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.poppcl
mc_stackmcl.poppcl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+mc_decls.noperands]
    cmp       %rdi,	0
    jg        L3078
    lea       %rcx,	[%rip+L10695]
    lea       %rdx,	[%rip+L10696]
    call      pc_api.merror
L3078:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jle       L3080
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rdi
    lea       %rax,	[%rax + %r10-1]
    dec       byte ptr[%rax]
    jmp       L3076
L3080:
    dec       qword ptr[%rip+mc_decls.noperands]
L3076:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.duplpcl
mc_stackmcl.duplpcl:
#?>>
    .set mc_stackmcl.duplpcl.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_stackmcl.duplpcl.$T1],	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.duplpcl.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkireg
mc_stackmcl.getworkireg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rbx,	10
L3083:
    mov       %rdi,	1
L3086:
    lea       %rax,	[%rip+mc_decls.workregs]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L3090
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L3090
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
    jmp       L3082
L3090:
    inc       %rdi
    cmp       %rdi,	14
    jle       L3086
    call      mc_stackmcl.savenextopnd
    dec       %rbx
    jnz       L3083
    lea       %rcx,	[%rip+L10697]
    lea       %rdx,	[%rip+L10698]
    call      pc_api.merror
    xor       %eax,	%eax
L3082:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkxreg
mc_stackmcl.getworkxreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	5
L3092:
    lea       %rax,	[%rip+mc_decls.workxregs]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L3096
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L3096
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
    jmp       L3091
L3096:
    inc       %rdi
    cmp       %rdi,	16
    jle       L3092
    lea       %rcx,	[%rip+L10699]
    lea       %rdx,	[%rip+L10700]
    call      pc_api.merror
    xor       %eax,	%eax
L3091:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkregm
mc_stackmcl.getworkregm:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_stackmcl.getworkreg
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mc_libmcl.mgenreg
L3097:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg
mc_stackmcl.getworkreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    cmp       %rdi,	2
    jg        L3100
    call      mc_stackmcl.getworkxreg
    jmp       L3099
L3100:
    call      mc_stackmcl.getworkireg
L3099:
L3098:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg_rm
mc_stackmcl.getworkreg_rm:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	%rdi
    test      %rax,	%rax
    jz        L3104
    cmp       %rax,	15
    jnz       L3103
L3104:
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkregm
    jmp       L3101
L3103:
    cmp       %rbx,	2
    jle       L3108
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L3107
L3108:
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L3106
L3107:
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkregm
    jmp       L3101
L3106:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
L3101:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnd
mc_stackmcl.saveopnd:
#?>>
    .set mc_stackmcl.saveopnd.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L3109
L3111:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jle       L3113
    test      %r12,	%r12
    jnz       L3116
    mov       %rax,	%rdi
    cmp       %rax,	4
    jl        L3117
    cmp       %rax,	10
    jle       L3115
L3117:
L3116:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.saveopnd.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgentemp
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3115:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L3112
L3113:
    test      %r12,	%r12
    jnz       L3120
    mov       %rax,	%rdi
    cmp       %rax,	1
    jl        L3119
    cmp       %rax,	6
    jg        L3119
L3120:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_stackmcl.saveopnd.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgentemp
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3119:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L3112:
    mov       %al,	3
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L3109:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnds
mc_stackmcl.saveopnds:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%rsi
    mov       %rdi,	%rax
    cmp       %rdi,	1
    jl        L3124
L3122:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_stackmcl.saveopnd
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L3122
L3124:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.savenextopnd
mc_stackmcl.savenextopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L3128
L3126:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L3130
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jle       L3130
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3125
L3130:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L3126
L3128:
L3125:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.savenextxopnd
mc_stackmcl.savenextxopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L3134
L3132:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L3136
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L3136
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3131
L3136:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L3132
L3134:
L3131:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.movetoreg
mc_stackmcl.movetoreg:
#?>>
    .set mc_stackmcl.movetoreg.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
#mc_stackmcl.movetoreg.retry:
L3138:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    cmp       %rdi,	%r12
    jz        L3137
L3140:
    cmp       %rbx,	2
    jg        L3142
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L3144
    lea       %rcx,	[%rip+L10701]
    lea       %rdx,	[%rip+L10702]
    call      pc_api.merror
L3144:
    jmp       L3141
L3142:
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L3146
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L3149
L3147:
    cmp       %rbx,	2
    jle       L3151
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%r12
    jnz       L3151
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%r12
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.movetoreg.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    jmp       L3138
L3151:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.noperands]
    jle       L3147
L3149:
L3146:
L3141:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.movetoreg.$T1],	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    mov       %al,	%r12b
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    cmp       %rbx,	2
    jg        L3153
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    jmp       L3152
L3153:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
L3152:
L3137:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind
mc_stackmcl.getopnd_ind:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L3156
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	2
    jnz       L3158
    mov       %rbx,	[%rdi+8]
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	5
    jnz       L3161
    movzx     %rax,	byte ptr[%rbx+82]
    cmp       %rax,	11
    jz        L3160
L3161:
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      mc_libmcl.mgenmem
    jmp       L3154
L3160:
L3158:
L3156:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L3163
    mov       %rcx,	%rsi
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L3163:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L3154:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind_simp
mc_stackmcl.getopnd_ind_simp:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L3166
    mov       %rcx,	%rdi
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L3166:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L3164:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.swapopnds
mc_stackmcl.swapopnds:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11*8-8]
    mov       %r11,	[%rax]
    mov       %r9,	[%r10]
    mov       [%r10],	%r11
    mov       [%rax],	%r9
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
#---------------
    ret       
# End 
# Proc mc_stackmcl.isimmload
mc_stackmcl.isimmload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    mov       %rdi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L3170
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	1
    jnz       L3170
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	4
    jnz       L3170
    mov       %rax,	%rdi
    jmp       L3169
L3170:
    xor       %eax,	%eax
L3169:
L3168:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.setnewzz
mc_stackmcl.setnewzz:
#?>>
#?]]
#---------------
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	%cl
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%dl
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    ret       
# End 
# Proc mc_stackmcl.freeworkregs
mc_stackmcl.freeworkregs:
#?>>
    .set mc_stackmcl.freeworkregs.p, 32
    push      %rdi
    push      %rbx
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L3175
L3173:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L3177
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L3179
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L3178
L3179:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L3178:
L3177:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L3173
L3175:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.swapopndregs
mc_stackmcl.swapopndregs:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L3182
    lea       %rcx,	[%rip+L10703]
    lea       %rdx,	[%rip+L10704]
    call      pc_api.merror
L3182:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    cmp       %rdi,	%rsi
    jz        L3180
L3184:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rbx,	%rax
    cmp       %rbx,	1
    jl        L3188
L3185:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L3190
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%rsi
    jnz       L3190
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rbx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    jmp       L3180
L3190:
    dec       %rbx
    cmp       %rbx,	1
    jge       L3185
L3188:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%sil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L3180:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.makeopndind
mc_stackmcl.makeopndind:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3193
    lea       %rcx,	[%rip+L10705]
    lea       %rdx,	[%rip+L10706]
    call      pc_api.merror
L3193:
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L3191:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.makesimpleaddr
mc_stackmcl.makesimpleaddr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+10]
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%r13+11]
    mov       %r12,	%rax
    cmp       %rsi,	15
    jnz       L3196
    xor       %rsi,	%rsi
L3196:
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L3198
    lea       %rcx,	[%rip+L10707]
    lea       %rdx,	[%rip+L10708]
    call      pc_api.merror
L3198:
    test      %rsi,	%rsi
    jnz       L3200
    test      %r12,	%r12
    jnz       L3200
    call      mc_stackmcl.getworkireg
    mov       %rbx,	%rax
    jmp       L3199
L3200:
    test      %rsi,	%rsi
    jz        L3201
    mov       %rax,	%r13
    jmp       L3194
L3201:
    test      %r12,	%r12
    jz        L3202
    mov       %rbx,	%r12
    jmp       L3199
L3202:
    mov       %rbx,	%r12
L3199:
    mov       %rcx,	%rbx
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	%r13
    call      mc_libmcl.genmc
    mov       %rax,	%rdi
L3194:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.checkallloaded
mc_stackmcl.checkallloaded:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L3206
L3204:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L3208
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	1
    jnz       L3208
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L3208:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L3204
L3206:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.stropndstack
mc_stackmcl.stropndstack:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    lea       %rax,	[%rip+mc_stackmcl.stropndstack.str]
    mov       %rdi,	%rax
    test      %r13,	%r13
    jz        L3211
    mov       %rcx,	%rdi
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10709]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L3210
L3211:
    mov       %rcx,	%rdi
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10710]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3210:
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L3214
L3212:
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%rsi
    inc       %rax
    sub       %rax,	1
    cmp       %rax,	4
    jae       L3217
    lea       %r10,	[%rip+L3216]
    jmp       [%r10 + %rax*8]
    .data
L3216:
    .quad     L3218
    .quad     L3219
    .quad     L3220
    .quad     L3221
    .text
L3218:
    lea       %rax,	[%rip+L10711]
    jmp       L3215
L3219:
    lea       %rax,	[%rip+L10712]
    jmp       L3215
L3220:
    lea       %rax,	[%rip+L10713]
    jmp       L3215
L3221:
    lea       %rax,	[%rip+L10714]
    jmp       L3215
L3217:
    lea       %rax,	[%rip+L10715]
L3215:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L3223
    cmp       %rax,	2
    jz        L3223
    cmp       %rax,	3
    jz        L3224
    jmp       L3225
L3223:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L3227
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.xregnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
    jmp       L3226
L3227:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.regnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
L3226:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L3229
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10716]
    call      strcat
L3229:
    jmp       L3222
L3224:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10717]
    call      strcat
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    jmp       L3222
L3225:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10718]
    call      strcat
    movzx     %rax,	byte ptr[%rip+pc_api.fpshortnames]
    mov       %rbx,	%rax
    mov       %al,	1
    mov       [%rip+pc_api.fpshortnames],	%al
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    call      pc_diags.stropnd
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       [%rip+pc_api.fpshortnames],	%bl
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10719]
    call      strcat
L3222:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jle       L3231
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10720]
    call      strcat
L3231:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10721]
    call      strcat
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+pc_tables.pstdnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10722]
    call      strcat
    cmp       %rsi,	[%rip+mc_decls.noperands]
    jge       L3233
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10723]
    call      strcat
L3233:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.noperands]
    jle       L3212
L3214:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10724]
    call      strcat
    lea       %rcx,	[%rip+mc_stackmcl.stropndstack.str]
    mov       %rdx,	50
    lea       %r8,	[%rip+L10725]
    call      mlib.ipadstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10726]
    call      strcat
    mov       %r12,	1
L3234:
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L3238
    lea       %rax,	[%rip+L10727]
    jmp       L3237
L3238:
    lea       %rax,	[%rip+L10728]
L3237:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    inc       %r12
    cmp       %r12,	10
    jle       L3234
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10729]
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10730]
    call      strcat
    mov       %r12,	1
    mov       %rax,	[%rip+mc_decls.xregmax]
    cmp       %rax,	1
    jl        L3241
L3239:
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L3243
    lea       %rax,	[%rip+L10731]
    jmp       L3242
L3243:
    lea       %rax,	[%rip+L10732]
L3242:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    inc       %r12
    cmp       %r12,	[%rip+mc_decls.xregmax]
    jle       L3239
L3241:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10733]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.mstackdepth]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10734]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.noperands]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L10735]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.ncalldepth]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rax,	%rdi
L3209:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.showopndstack
mc_stackmcl.showopndstack:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	1
    call      mc_stackmcl.stropndstack
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_optim.peephole
mc_optim.peephole:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L3245
L3247:
    mov       %rax,	[%rip+mc_decls.mccode]
    mov       %rdi,	[%rax+8]
    jmp       L3251
L3248:
    mov       %rbx,	[%rdi+8]
    mov       %rsi,	[%rbx+8]
    movzx     %rax,	byte ptr[%rdi+33]
    cmp       %rax,	8
    jz        L3253
    cmp       %rax,	11
    jz        L3254
    cmp       %rax,	38
    jz        L3255
    cmp       %rax,	40
    jz        L3256
    cmp       %rax,	26
    jz        L3257
    jmp       L3258
L3253:
    jmp       L3250
L3254:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	11
    jz        L3260
    cmp       %rax,	41
    jz        L3261
    cmp       %rax,	42
    jz        L3262
    cmp       %rax,	28
    jz        L3263
    cmp       %rax,	29
    jz        L3263
    cmp       %rax,	52
    jz        L3264
    cmp       %rax,	53
    jz        L3264
    cmp       %rax,	25
    jz        L3265
    jmp       L3266
L3260:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3268
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+24]
    cmp       %rax,	%r10
    jnz       L3268
    mov       %rcx,	%rbx
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L3268
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg10
    test      %rax,	%rax
    jnz       L3269
L3270:
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jnz       L3272
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3271
L3272:
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L3271:
L3269:
    jmp       L3267
L3268:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3273
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+24]
    cmp       %rax,	%r10
    jnz       L3273
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg10
    test      %rax,	%rax
    jz        L3273
    movzx     %rax,	byte ptr[%rsi+33]
    cmp       %rax,	21
    jnz       L3273
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L3273
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L3273:
L3267:
    jmp       L3259
L3261:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3275
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %r10,	%rax
    jnz       L3276
    mov       %rax,	[%rbx+24]
    cmp       %r10,	%rax
    jnz       L3276
    mov       %rax,	1
    jmp       L3277
L3276:
    xor       %eax,	%eax
L3277:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L3275
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3275
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L3275
    mov       %al,	41
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L3275:
    jmp       L3259
L3262:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3279
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L3279
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3279
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L3279
    mov       %al,	42
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rbx+24]
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L3279:
    jmp       L3259
L3263:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3281
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L3281
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3281
    mov       %rax,	[%rbx+24]
    mov       %rcx,	%rax
    call      mc_optim.isconst
    test      %rax,	%rax
    jz        L3281
    mov       %al,	14
    mov       [%rdi+33],	%al
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	28
    jnz       L3283
    mov       %rax,	[%rbx+24]
    mov       %rax,	[%rax]
    jmp       L3282
L3283:
    mov       %rax,	[%rbx+24]
    mov       %rax,	[%rax]
    neg       %rax
L3282:
    mov       %r10,	[%rdi+24]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L3281:
    jmp       L3259
L3264:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3285
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L3285
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3285
    mov       %al,	14
    mov       [%rdi+33],	%al
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	52
    jnz       L3287
    mov       %rax,	1
    jmp       L3286
L3287:
    mov       %rax,	-1
L3286:
    mov       %r10,	[%rdi+24]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L3285:
    jmp       L3259
L3265:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3289
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3289
    mov       %al,	25
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    xor       %eax,	%eax
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L3289:
L3266:
L3259:
    jmp       L3252
L3255:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	41
    jnz       L3291
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3293
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %r10,	%rax
    jnz       L3294
    mov       %rax,	[%rbx+24]
    cmp       %r10,	%rax
    jnz       L3294
    mov       %rax,	1
    jmp       L3295
L3294:
    xor       %eax,	%eax
L3295:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L3293
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L3293
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L3293:
L3291:
    jmp       L3252
L3256:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	11
    jnz       L3297
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3299
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+24]
    cmp       %rax,	%r10
    jnz       L3299
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3299
    mov       %rax,	[%rbx+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L3299
    mov       %rcx,	%rbx
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L3299
    mov       %rax,	[%rbx+16]
    mov       [%rdi+24],	%rax
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L3299:
L3297:
    jmp       L3252
L3257:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	25
    jnz       L3301
    movzx     %rax,	byte ptr[%rsi+33]
    cmp       %rax,	9
    jnz       L3301
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax]
    mov       %r10,	[%rsi+16]
    mov       %r10,	[%r10]
    cmp       %rax,	%r10
    jnz       L3301
    mov       %rcx,	%rdi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L3301
    movzx     %rax,	byte ptr[%rdi+34]
    lea       %r10,	[%rip+mc_decls.asmrevcond]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdi+34],	%r10b
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L3301:
L3258:
L3252:
    mov       %rdi,	[%rdi+8]
L3251:
    test      %rdi,	%rdi
    jnz       L3248
L3250:
L3245:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.isreg
mc_optim.isreg:
#?>>
#?]]
#---------------
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    setz      %al
    movzx     %eax,	%al
L3302:
#---------------
    ret       
# End 
# Proc mc_optim.isreg0
mc_optim.isreg0:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L3305
    xor       %eax,	%eax
    jmp       L3303
L3305:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L3307
    movzx     %rax,	byte ptr[%rcx+10]
    cmp       %rax,	1
    jnz       L3307
    mov       %rax,	1
    jmp       L3303
L3307:
    xor       %eax,	%eax
L3303:
#---------------
    ret       
# End 
# Proc mc_optim.isreg10
mc_optim.isreg10:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L3310
    xor       %eax,	%eax
    jmp       L3308
L3310:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L3312
    movzx     %rax,	byte ptr[%rcx+10]
    cmp       %rax,	11
    jnz       L3312
    mov       %rax,	1
    jmp       L3308
L3312:
    xor       %eax,	%eax
L3308:
#---------------
    ret       
# End 
# Proc mc_optim.isreg00
mc_optim.isreg00:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L3315
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+24]
    cmp       %rax,	%r10
    jnz       L3315
    mov       %rax,	1
    jmp       L3313
L3315:
    xor       %eax,	%eax
L3313:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_optim.isconst
mc_optim.isconst:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L3318
    xor       %eax,	%eax
    jmp       L3316
L3318:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L3320
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L3320
    mov       %rax,	1
    jmp       L3316
L3320:
    xor       %eax,	%eax
L3316:
#---------------
    ret       
# End 
# Proc mc_optim.sameoperand
mc_optim.sameoperand:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	16
    call      memcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L3321:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.sameregopnd
mc_optim.sameregopnd:
#?>>
#?]]
#---------------
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    movzx     %r10,	word ptr[%rdx+8]
    shr       %r10,	9
    and       %r10,	7
    cmp       %r10,	%rax
    jnz       L3325
    cmp       %r10,	1
    jz        L3324
L3325:
    xor       %eax,	%eax
    jmp       L3322
L3324:
    movzx     %rax,	byte ptr[%rcx+10]
    movzx     %r10,	byte ptr[%rdx+10]
    cmp       %rax,	%r10
    setz      %al
    movzx     %eax,	%al
L3322:
#---------------
    ret       
# End 
# Proc mc_optim.deletemcl
mc_optim.deletemcl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rsi]
    mov       %rbx,	[%rsi+8]
    test      %rdi,	%rdi
    jz        L3329
    test      %rbx,	%rbx
    jnz       L3328
L3329:
    lea       %rcx,	[%rip+L10736]
    lea       %rdx,	[%rip+L10737]
    call      pc_api.merror
L3328:
    mov       [%rdi+8],	%rbx
    mov       [%rbx],	%rdi
    mov       %rax,	%rbx
L3326:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.endr0
mc_optim.endr0:
#?>>
#?]]
#---------------
    lea       %rax,	[%rcx+48]
    movzx     %rax,	byte ptr[%rax]
L3330:
#---------------
    ret       
# End 
# Proc mc_genss.genss
mc_genss.genss:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %al,	[%rip+pc_decls.ssdone]
    test      %al,	%al
    jnz       L3331
L3333:
    call      mwindows.os_clock
    mov       [%rip+pc_decls.sstime],	%rax
    mov       %rcx,	[%rip+pc_api.mlabelno]
    call      mc_genss.initlib
    xor       %eax,	%eax
    mov       [%rip+mc_decls.ss_zdatalen],	%rax
    mov       %rcx,	1024
    call      mc_genss.buffercreate
    mov       [%rip+mc_decls.ss_zdata],	%rax
    mov       %rcx,	1024
    call      mc_genss.buffercreate
    mov       [%rip+mc_decls.ss_idata],	%rax
    mov       %rcx,	1024
    call      mc_genss.buffercreate
    mov       [%rip+mc_decls.ss_code],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.ss_idatarelocs],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.ss_coderelocs],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.ss_nsymbols],	%rax
    mov       %rcx,	1
    call      mc_genss.switchseg
    mov       %rax,	9999
    mov       [%rip+mc_decls.aaseqno],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_genss.extraparam],	%rax
    mov       %rbx,	[%rip+mc_decls.mccode]
    xor       %rdi,	%rdi
    jmp       L3335
L3334:
    inc       %rdi
    mov       %rax,	%rdi
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genss.doinstr
    mov       %rbx,	[%rbx+8]
L3335:
    test      %rbx,	%rbx
    jnz       L3334
    xor       %ecx,	%ecx
    call      mc_genss.switchseg
    mov       %rcx,	[%rip+mc_decls.ss_zdata]
    call      mc_genss.bufferlength
    test      %rax,	%rax
    jz        L3338
    lea       %rcx,	[%rip+L10738]
    call      mc_libmcl.axerror
L3338:
    test      %r14,	%r14
    jz        L3340
    mov       %rcx,	[%rip+mc_decls.ss_code]
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       %r12,	%rax
    mov       %rsi,	[%rip+mc_decls.riplist]
    jmp       L3344
L3341:
    mov       %eax,	[%rsi+8]
    lea       %r10,	[%r12 + %rax]
    mov       %r13,	%r10
    movsxd    %rax,	dword ptr[%rsi+12]
    mov       %r10,	%r13
    sub       [%r10],	%eax
    mov       %rsi,	[%rsi]
L3344:
    test      %rsi,	%rsi
    jnz       L3341
L3340:
    mov       %al,	1
    mov       [%rip+pc_decls.ssdone],	%al
    call      mwindows.os_clock
    sub       %rax,	[%rip+pc_decls.sstime]
    mov       [%rip+pc_decls.sstime],	%rax
L3331:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.doinstr
mc_genss.doinstr:
#?>>
    .set mc_genss.doinstr.m, 64
    .set mc_genss.doinstr.index, 72
    .set mc_genss.doinstr.n, -8
    .set mc_genss.doinstr.av_1, -16
    .set mc_genss.doinstr.av_2, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rip+mc_genss.currdata]
    mov       %rax,	[%rax+16]
    mov       %r10,	[%rip+mc_genss.currdata]
    mov       %r10,	[%r10+8]
    sub       %rax,	%r10
    cmp       %rax,	1024
    jge       L3347
    mov       %rcx,	[%rip+mc_genss.currdata]
    call      mc_genss.bufferexpand
L3347:
    xor       %eax,	%eax
    mov       [%rip+mc_genss.usesizeb],	%al
    mov       [%rip+mc_genss.nowmask],	%al
    mov       [%rip+mc_genss.f3override],	%al
    mov       [%rip+mc_genss.f2override],	%al
    mov       [%rip+mc_genss.addroverride],	%al
    mov       [%rip+mc_genss.sizeoverride],	%al
    mov       [%rip+mc_genss.rex],	%al
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    mov       %rbx,	[%rax+24]
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    mov       %eax,	[%rax+36]
    mov       [%rip+mc_decls.aaseqno],	%rax
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    mov       %eax,	[%rax+40]
    mov       [%rip+mc_decls.aapos],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_genss.ripentry],	%rax
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    mov       [%rip+mc_genss.currmcl],	%rax
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    sub       %rax,	1
    cmp       %rax,	152
    jae       L3350
    lea       %r10,	[%rip+L3349]
    jmp       [%r10 + %rax*8]
    .data
L3349:
    .quad     L3351
    .quad     L3352
    .quad     L3474
    .quad     L3355
    .quad     L3353
    .quad     L3354
    .quad     L3350
    .quad     L3474
    .quad     L3362
    .quad     L3383
    .quad     L3397
    .quad     L3392
    .quad     L3393
    .quad     L3398
    .quad     L3456
    .quad     L3440
    .quad     L3441
    .quad     L3399
    .quad     L3400
    .quad     L3401
    .quad     L3367
    .quad     L3388
    .quad     L3350
    .quad     L3389
    .quad     L3368
    .quad     L3369
    .quad     L3402
    .quad     L3396
    .quad     L3396
    .quad     L3396
    .quad     L3396
    .quad     L3395
    .quad     L3395
    .quad     L3403
    .quad     L3350
    .quad     L3395
    .quad     L3395
    .quad     L3396
    .quad     L3396
    .quad     L3396
    .quad     L3434
    .quad     L3396
    .quad     L3433
    .quad     L3433
    .quad     L3433
    .quad     L3433
    .quad     L3433
    .quad     L3433
    .quad     L3433
    .quad     L3395
    .quad     L3395
    .quad     L3394
    .quad     L3394
    .quad     L3384
    .quad     L3385
    .quad     L3386
    .quad     L3387
    .quad     L3439
    .quad     L3470
    .quad     L3470
    .quad     L3473
    .quad     L3473
    .quad     L3442
    .quad     L3443
    .quad     L3442
    .quad     L3443
    .quad     L3442
    .quad     L3443
    .quad     L3442
    .quad     L3443
    .quad     L3442
    .quad     L3443
    .quad     L3446
    .quad     L3447
    .quad     L3447
    .quad     L3444
    .quad     L3445
    .quad     L3444
    .quad     L3445
    .quad     L3445
    .quad     L3445
    .quad     L3450
    .quad     L3451
    .quad     L3452
    .quad     L3453
    .quad     L3454
    .quad     L3455
    .quad     L3449
    .quad     L3448
    .quad     L3466
    .quad     L3466
    .quad     L3350
    .quad     L3350
    .quad     L3458
    .quad     L3458
    .quad     L3458
    .quad     L3459
    .quad     L3459
    .quad     L3459
    .quad     L3460
    .quad     L3460
    .quad     L3460
    .quad     L3460
    .quad     L3457
    .quad     L3457
    .quad     L3457
    .quad     L3457
    .quad     L3457
    .quad     L3457
    .quad     L3457
    .quad     L3457
    .quad     L3442
    .quad     L3442
    .quad     L3443
    .quad     L3443
    .quad     L3376
    .quad     L3377
    .quad     L3378
    .quad     L3379
    .quad     L3376
    .quad     L3381
    .quad     L3382
    .quad     L3380
    .quad     L3417
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3438
    .quad     L3435
    .quad     L3435
    .quad     L3435
    .quad     L3436
    .quad     L3437
    .quad     L3461
    .quad     L3462
    .quad     L3463
    .quad     L3464
    .quad     L3465
    .quad     L3469
    .quad     L3472
    .quad     L3467
    .quad     L3468
    .quad     L3468
    .quad     L3468
    .quad     L3468
    .quad     L3468
    .quad     L3468
    .quad     L3468
    .quad     L3471
    .quad     L3350
    .quad     L3383
    .text
L3351:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax]
    mov       [%rip+mc_decls.currasmproc],	%rax
    jmp       L3348
L3352:
    jmp       L3348
L3353:
    jmp       L3348
L3354:
    jmp       L3348
L3355:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	4
    jz        L3357
    cmp       %rax,	5
    jz        L3358
    jmp       L3359
L3357:
    jmp       L3356
L3358:
    mov       %rsi,	[%rdi]
    mov       %al,	2
    mov       [%rsi+93],	%al
    mov       %al,	[%rip+mc_genss.currseg]
    mov       [%rsi+94],	%al
    mov       %rcx,	6
    call      mc_genss.getcurrdatalen
    mov       [%rsi+76],	%eax
    mov       %al,	[%rsi+81]
    test      %al,	%al
    jz        L3361
    mov       %rcx,	%rsi
    call      mc_genss.getstindex
L3361:
    mov       %rcx,	%rsi
    call      mc_genss.dofwdrefs
L3359:
L3356:
    jmp       L3348
L3362:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jnz       L3364
    mov       %rsi,	[%rdi]
    jmp       L3363
L3364:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rip+mc_decls.labeldeftable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rsi,	%r10
L3363:
    mov       %al,	2
    mov       [%rsi+93],	%al
    mov       %al,	[%rip+mc_genss.currseg]
    mov       [%rsi+94],	%al
    mov       %rcx,	6
    call      mc_genss.getcurrdatalen
    mov       [%rsi+76],	%eax
    mov       %al,	[%rsi+81]
    test      %al,	%al
    jz        L3366
    mov       %rcx,	%rsi
    call      mc_genss.getstindex
L3366:
    mov       %rcx,	%rsi
    call      mc_genss.dofwdrefs
    jmp       L3348
L3367:
    mov       %rcx,	%rdi
    call      mc_genss.do_call
    jmp       L3348
L3368:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + mc_genss.doinstr.m]
    call      mc_genss.do_jmp
    jmp       L3348
L3369:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_genss.getdef
    mov       %rsi,	%rax
    mov       %rcx,	7
    call      mc_genss.getcurrdatalen
    inc       %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genss.getrel32
    mov       %r13,	%rax
    cmp       %r13,	0
    jge       L3371
    cmp       %r13,	-126
    jge       L3373
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	15
    mov       [%r10],	%al
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %r10,	128
    add       %r10,	%rax
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    lea       %rax,	[%r13-4]
    mov       %rcx,	%rax
    call      mc_genss.gendword
    jmp       L3372
L3373:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %r10,	112
    add       %r10,	%rax
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%r13b
L3372:
    jmp       L3370
L3371:
    mov       %rcx,	[%rbp + mc_genss.doinstr.m]
    mov       %rdx,	%rsi
    call      mc_genss.checkshortjump
    mov       %r14,	%rax
    test      %r14,	%r14
    jnz       L3375
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	15
    mov       [%r10],	%al
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %r10,	128
    add       %r10,	%rax
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    mov       %rcx,	%rdi
    call      mc_genss.genrel32
    jmp       L3374
L3375:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %r10,	112
    add       %r10,	%rax
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    mov       %rcx,	%rdi
    call      mc_genss.genrel8
L3374:
L3370:
    jmp       L3348
L3376:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_genss.genopnd
    jmp       L3348
L3377:
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_genss.genopnd
    jmp       L3348
L3378:
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_genss.genopnd
    jmp       L3348
L3379:
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_genss.genopnd
    jmp       L3348
L3380:
    mov       %rcx,	1
    call      mc_genss.switchseg
    jmp       L3348
L3381:
    mov       %rcx,	2
    call      mc_genss.switchseg
    jmp       L3348
L3382:
    mov       %rcx,	3
    call      mc_genss.switchseg
    jmp       L3348
L3383:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    mov       %r10b,	[%r10 + %rax-1]
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    jmp       L3348
L3384:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	102
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	152
    mov       [%r10],	%al
    jmp       L3348
L3385:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	102
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	153
    mov       [%r10],	%al
    jmp       L3348
L3386:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	153
    mov       [%r10],	%al
    jmp       L3348
L3387:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	72
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	153
    mov       [%r10],	%al
    jmp       L3348
L3388:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	195
    mov       [%r10],	%al
    jmp       L3348
L3389:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jz        L3391
    lea       %rcx,	[%rip+L10739]
    call      mc_libmcl.axerror
L3391:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	194
    mov       [%r10],	%al
    mov       %rcx,	[%rdi]
    call      mc_genss.genword
    jmp       L3348
L3392:
    mov       %rcx,	%rdi
    call      mc_genss.do_push
    jmp       L3348
L3393:
    mov       %rcx,	%rdi
    call      mc_genss.do_pop
    jmp       L3348
L3394:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mc_genss.do_inc
    jmp       L3348
L3395:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mc_genss.do_neg
    jmp       L3348
L3396:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r10
    call      mc_genss.do_arith
    jmp       L3348
L3397:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_mov
    jmp       L3348
L3398:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_lea
    jmp       L3348
L3399:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	190
    call      mc_genss.do_movsx
    jmp       L3348
L3400:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	182
    call      mc_genss.do_movsx
    jmp       L3348
L3401:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_movsxd
    jmp       L3348
L3402:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_exch
    jmp       L3348
L3403:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_imul2
    jmp       L3348
L3404:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L3406
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbp + mc_genss.doinstr.m]
    movzx     %r10,	byte ptr[%r10+33]
    lea       %r11,	[%rip+mc_decls.mclcodes]
    movzx     %r11,	byte ptr[%r11 + %r10-1]
    imul      %rax,	%r11
    mov       [%rbp + mc_genss.doinstr.n],	%rax
    mov       %rax,	[%rip+mc_genss.currseg]
    cmp       %rax,	1
    jz        L3408
    cmp       %rax,	2
    jz        L3409
    jmp       L3410
L3408:
    mov       %rax,	[%rbp + mc_genss.doinstr.n]
    mov       [%rbp + mc_genss.doinstr.av_1],	%rax
    mov       %rax,	[%rbp + mc_genss.doinstr.av_1]
    cmp       %rax,	0
    jle       L3413
L3411:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	144
    mov       [%r10],	%al
    dec       qword ptr[%rbp + mc_genss.doinstr.av_1]
    jnz       L3411
L3413:
    jmp       L3407
L3409:
    mov       %rax,	[%rbp + mc_genss.doinstr.n]
    mov       [%rbp + mc_genss.doinstr.av_2],	%rax
    mov       %rax,	[%rbp + mc_genss.doinstr.av_2]
    cmp       %rax,	0
    jle       L3416
L3414:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    xor       %eax,	%eax
    mov       [%r10],	%al
    dec       qword ptr[%rbp + mc_genss.doinstr.av_2]
    jnz       L3414
L3416:
    jmp       L3407
L3410:
    mov       %rax,	[%rbp + mc_genss.doinstr.n]
    add       [%rip+mc_decls.ss_zdatalen],	%rax
L3407:
    jmp       L3405
L3406:
    lea       %rcx,	[%rip+L10740]
    call      mc_libmcl.axerror
L3405:
    jmp       L3348
L3417:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L3419
    mov       %r12,	[%rdi]
    cmp       %r12,	1
    jl        L3422
    cmp       %r12,	16384
    jle       L3421
L3422:
    lea       %rcx,	[%rip+L10741]
    call      mc_libmcl.axerror
L3421:
    mov       %rcx,	[%rip+mc_genss.currdata]
    mov       %rdx,	%r12
    call      mc_genss.buffercheck
    mov       %rax,	[%rip+mc_genss.currseg]
    cmp       %rax,	3
    jz        L3424
    jmp       L3426
L3425:
    mov       %rax,	[%rip+mc_genss.currseg]
    cmp       %rax,	1
    jnz       L3429
    mov       %rax,	144
    jmp       L3428
L3429:
    xor       %eax,	%eax
L3428:
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
L3426:
    mov       %rcx,	[%rip+mc_genss.currdata]
    call      mc_genss.bufferlength
    mov       %r10,	%r12
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    test      %rax,	%rax
    jnz       L3425
    jmp       L3423
L3424:
    jmp       L3431
L3430:
    inc       qword ptr[%rip+mc_decls.ss_zdatalen]
L3431:
    mov       %rax,	[%rip+mc_decls.ss_zdatalen]
    mov       %r10,	%r12
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    test      %rax,	%rax
    jnz       L3430
L3423:
    jmp       L3418
L3419:
    lea       %rcx,	[%rip+L10742]
    call      mc_libmcl.axerror
L3418:
    jmp       L3348
L3433:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r10
    call      mc_genss.do_shift
    jmp       L3348
L3434:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_test
    jmp       L3348
L3435:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mc_genss.do_loop
    jmp       L3348
L3436:
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_genss.do_jcxz
    jmp       L3348
L3437:
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_genss.do_jcxz
    jmp       L3348
L3438:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	215
    mov       [%r10],	%al
    jmp       L3348
L3439:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mc_genss.do_setcc
    jmp       L3348
L3440:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	4
    call      mc_genss.do_movxmm
    jmp       L3348
L3441:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	8
    call      mc_genss.do_movxmm
    jmp       L3348
L3442:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	243
    mov       %r9,	%r10
    call      mc_genss.do_arithxmm
    jmp       L3348
L3443:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	242
    mov       %r9,	%r10
    call      mc_genss.do_arithxmm
    jmp       L3348
L3444:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r10
    mov       %r9,	4
    call      mc_genss.do_logicxmm
    jmp       L3348
L3445:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r10
    mov       %r9,	8
    call      mc_genss.do_logicxmm
    jmp       L3348
L3446:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	47
    call      mc_genss.do_arithxmm
    jmp       L3348
L3447:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	102
    mov       %r9,	%r10
    call      mc_genss.do_arithxmm
    jmp       L3348
L3448:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	243
    call      mc_genss.do_convertfloat
    jmp       L3348
L3449:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	242
    call      mc_genss.do_convertfloat
    jmp       L3348
L3450:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	243
    mov       %r9,	45
    call      mc_genss.do_fix
    jmp       L3348
L3451:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	242
    mov       %r9,	45
    call      mc_genss.do_fix
    jmp       L3348
L3452:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	243
    mov       %r9,	44
    call      mc_genss.do_fix
    jmp       L3348
L3453:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	242
    mov       %r9,	44
    call      mc_genss.do_fix
    jmp       L3348
L3454:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	243
    call      mc_genss.do_float
    jmp       L3348
L3455:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	242
    call      mc_genss.do_float
    jmp       L3348
L3456:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.do_cmovcc
    jmp       L3348
L3457:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	217
    mov       [%r10],	%al
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    mov       %r10b,	[%r10 + %rax-1]
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    jmp       L3348
L3458:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	1
    mov       %r8,	%r10
    call      mc_genss.do_fmem
    jmp       L3348
L3459:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      mc_genss.do_fmem
    jmp       L3348
L3460:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	222
    mov       [%r10],	%al
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    mov       %r10b,	[%r10 + %rax-1]
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    jmp       L3348
L3461:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	166
    mov       [%r10],	%al
    jmp       L3348
L3462:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	102
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	167
    mov       [%r10],	%al
    jmp       L3348
L3463:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	167
    mov       [%r10],	%al
    jmp       L3348
L3464:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	72
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	167
    mov       [%r10],	%al
    jmp       L3348
L3465:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	15
    mov       [%r10],	%al
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    mov       %r10b,	[%r10 + %rax-1]
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    jmp       L3348
L3466:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r10
    call      mc_genss.do_movdqx
    jmp       L3348
L3467:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	219
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	227
    mov       [%r10],	%al
    jmp       L3348
L3468:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	217
    mov       [%r10],	%al
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    mov       %r10b,	[%r10 + %rax-1]
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r11,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r11],	%r10b
    jmp       L3348
L3469:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_popcnt
    jmp       L3348
L3470:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r10
    call      mc_genss.do_bsf
    jmp       L3348
L3471:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	15
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	162
    mov       [%r10],	%al
    jmp       L3348
L3472:
    mov       %rcx,	%rdi
    call      mc_genss.do_bswap
    jmp       L3348
L3473:
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+32]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	%r10
    call      mc_genss.do_dshift
    jmp       L3348
L3474:
    jmp       L3348
L3350:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10743]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    lea       %r10,	[%rip+mc_decls.mclnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L10744]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L10745]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbp + mc_genss.doinstr.m]
    movzx     %rax,	byte ptr[%rax+33]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L10746]
    call      msys.m$print_str_nf
    mov       %rcx,	152
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10747]
    call      mc_libmcl.axerror
L3348:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.start
mc_genss.start:
#?>>
#?]]
#---------------
    mov       %al,	64
    lea       %r10,	[%rip+mc_genss.ishighreg]
    mov       [%r10+3],	%al
    mov       %al,	64
    lea       %r10,	[%rip+mc_genss.ishighreg]
    mov       [%r10+5],	%al
    mov       %al,	64
    lea       %r10,	[%rip+mc_genss.ishighreg]
    mov       [%r10+14],	%al
    mov       %al,	64
    lea       %r10,	[%rip+mc_genss.ishighreg]
    mov       [%r10+15],	%al
#---------------
    ret       
# End 
# Proc mc_genss.genword
mc_genss.genword:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+mc_genss.currdata]
    mov       %rdx,	%rdi
    call      mc_genss.addword
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genss.gendword
mc_genss.gendword:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+mc_genss.currdata]
    mov       %rdx,	%rdi
    call      mc_genss.adddword
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genqword
mc_genss.genqword:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+mc_genss.currdata]
    mov       %rdx,	%rdi
    call      mc_genss.addqword
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genopnd
mc_genss.genopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    test      %r12,	%r12
    jnz       L3481
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    mov       %r12,	%rax
L3481:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	4
    jz        L3483
    cmp       %rax,	7
    jz        L3484
    jmp       L3485
L3483:
    mov       %rdi,	[%rsi]
    mov       %rcx,	%rdi
    call      strlen
    mov       %rbx,	%rax
    cmp       %rbx,	100
    jle       L3487
    lea       %rax,	[%rbx+1]
    mov       %r10,	1024
    cmp       %r10,	%rax
    cmovl     %r10,	%rax
    mov       %rcx,	[%rip+mc_genss.currdata]
    mov       %rdx,	%r10
    call      mc_genss.buffercheck
L3487:
    jmp       L3489
L3488:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %al,	[%rax]
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
L3489:
    mov       %al,	[%rdi]
    test      %al,	%al
    jnz       L3488
    jmp       L3479
L3484:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10748]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3485:
L3482:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      mc_genss.getdef
    test      %rax,	%rax
    jz        L3492
    cmp       %r12,	2
    jg        L3492
    lea       %rcx,	[%rip+L10749]
    call      mc_libmcl.axerror
L3492:
    mov       %rax,	%r12
    cmp       %rax,	1
    jz        L3494
    cmp       %rax,	2
    jz        L3495
    cmp       %rax,	4
    jz        L3496
    cmp       %rax,	8
    jz        L3497
    jmp       L3498
L3494:
    mov       %rax,	[%rsi]
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    jmp       L3493
L3495:
    mov       %rcx,	[%rsi]
    call      mc_genss.genword
    jmp       L3493
L3496:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jz        L3500
    cmp       %rax,	2
    jz        L3501
    cmp       %rax,	5
    jz        L3502
    cmp       %rax,	6
    jz        L3502
    jmp       L3503
L3500:
    mov       %rcx,	[%rsi]
    call      mc_genss.gendword
    jmp       L3499
L3501:
    movq      %XMM4,	[%rsi]
    cvtsd2ss  %XMM4,	%XMM4
    movq      %XMM15,	%XMM4
    movq      %XMM4,	%XMM15
    movd      %eax,	%XMM4
    mov       %ecx,	%eax
    call      mc_genss.gendword
    jmp       L3499
L3502:
    mov       %rcx,	%rsi
    call      mc_genss.genabs32
    jmp       L3499
L3503:
    call      msys.m$print_startcon
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    lea       %r10,	[%rip+mc_decls.valtypenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10750]
    call      mc_libmcl.axerror
L3499:
    jmp       L3493
L3497:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jz        L3505
    cmp       %rax,	2
    jz        L3506
    cmp       %rax,	5
    jz        L3507
    cmp       %rax,	6
    jz        L3507
    jmp       L3508
L3505:
    mov       %rcx,	[%rsi]
    call      mc_genss.genqword
    jmp       L3504
L3506:
    movq      %XMM4,	[%rsi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    call      mc_genss.genqword
    jmp       L3504
L3507:
    mov       %rcx,	%rsi
    call      mc_genss.genabs64
    jmp       L3504
L3508:
    call      msys.m$print_startcon
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    lea       %r10,	[%rip+mc_decls.valtypenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10751]
    call      mc_libmcl.axerror
L3504:
L3498:
L3493:
L3479:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.addrelocitem
mc_genss.addrelocitem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rcx,	%r13
    call      mc_genss.getstindex
    mov       %rbx,	%rax
    mov       %rsi,	4
    cmp       %r12,	1
    jnz       L3511
    mov       %rsi,	8
L3511:
    mov       %rcx,	32
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_genss.currrelocs]
    mov       [%rdi],	%rax
    mov       [%rdi+8],	%r12
    mov       %rcx,	1
    call      mc_genss.getcurrdatalen
    sub       %rax,	%rsi
    mov       [%rdi+16],	%rax
    mov       [%rdi+24],	%rbx
    inc       qword ptr[%rip+mc_genss.nrelocs]
    mov       [%rip+mc_genss.currrelocs],	%rdi
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.getstindex
mc_genss.getstindex:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsx     %rax,	word ptr[%rdi+96]
    test      %rax,	%rax
    jnz       L3514
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	[%rip+mc_decls.ss_symboltablesize]
    jl        L3516
    call      mc_genss.extendsymboltable
L3516:
    inc       qword ptr[%rip+mc_decls.ss_nsymbols]
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    mov       [%rdi+96],	%ax
    movsx     %rax,	word ptr[%rdi+96]
    mov       %r10,	%rdi
    mov       %r11,	[%rip+mc_decls.ss_symboltable]
    mov       [%r11 + %rax*8-8],	%r10
    movzx     %rax,	byte ptr[%rdi+94]
    test      %rax,	%rax
    jnz       L3518
    mov       %al,	[%rdi+80]
    test      %al,	%al
    jz        L3520
    mov       %al,	1
    mov       [%rdi+94],	%al
L3520:
L3518:
L3514:
    movsx     %rax,	word ptr[%rdi+96]
L3512:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genrel32
mc_genss.genrel32:
#?>>
    .set mc_genss.genrel32.$T1, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_genss.getdef
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L3523
    mov       %rcx,	[%rbx]
    call      mc_genss.gendword
    jmp       L3521
L3523:
    movzx     %rax,	byte ptr[%rdi+93]
    cmp       %rax,	2
    jz        L3525
    cmp       %rax,	1
    jz        L3526
    jmp       L3527
L3525:
    movzx     %rax,	byte ptr[%rdi+94]
    cmp       %rax,	[%rip+mc_genss.currseg]
    jz        L3529
    lea       %rcx,	[%rip+L10752]
    call      mc_libmcl.axerror
L3529:
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       [%rbp + mc_genss.genrel32.$T1],	%rax
    mov       %rcx,	2
    call      mc_genss.getcurrdatalen
    add       %rax,	4
    mov       %r10,	[%rbp + mc_genss.genrel32.$T1]
    sub       %r10,	%rax
    movsxd    %rax,	dword ptr[%rbx+12]
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_genss.gendword
    jmp       L3524
L3526:
    mov       %rcx,	3
    call      mc_genss.getcurrdatalen
    mov       %r10,	[%rdi+64]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	4
    xor       %r9d,	%r9d
    call      mc_genss.addfwdref
    mov       [%rdi+64],	%rax
    movsxd    %rax,	dword ptr[%rbx+12]
    mov       %rcx,	%rax
    call      mc_genss.gendword
    jmp       L3524
L3527:
    movsxd    %rax,	dword ptr[%rbx+12]
    mov       %rcx,	%rax
    call      mc_genss.gendword
    mov       %rcx,	4
    mov       %rdx,	%rdi
    call      mc_genss.addrelocitem
L3524:
L3521:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.getdef
mc_genss.getdef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L3533
    cmp       %rax,	2
    jnz       L3532
L3533:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	6
    jz        L3535
    cmp       %rax,	5
    jz        L3536
    jmp       L3537
L3535:
    mov       %rax,	[%rbx]
    mov       %r10,	[%rip+mc_decls.labeldeftable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rax,	%r10
    jmp       L3530
L3536:
    mov       %rdi,	[%rbx]
    movzx     %rax,	byte ptr[%rdi+93]
    test      %rax,	%rax
    jnz       L3539
    mov       %al,	[%rdi+80]
    test      %al,	%al
    jnz       L3541
    mov       %al,	1
    mov       [%rdi+93],	%al
L3541:
L3539:
    mov       %rax,	%rdi
    jmp       L3530
L3537:
L3534:
L3532:
    test      %rsi,	%rsi
    jz        L3543
    call      msys.m$print_startcon
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    lea       %r10,	[%rip+mc_decls.opndnames_ma]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    lea       %r10,	[%rip+mc_decls.valtypenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10753]
    call      mc_libmcl.axerror
L3543:
    xor       %eax,	%eax
L3530:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genabs32
mc_genss.genabs32:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_genss.getdef
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi+93]
    cmp       %rax,	2
    jz        L3546
    cmp       %rax,	1
    jz        L3547
    jmp       L3548
L3546:
    movsxd    %rax,	dword ptr[%rdi+76]
    movsxd    %r10,	dword ptr[%rbx+12]
    add       %rax,	%r10
    mov       %rcx,	%rax
    call      mc_genss.gendword
    mov       %rcx,	2
    mov       %rdx,	%rdi
    call      mc_genss.addrelocitem
    jmp       L3545
L3547:
    mov       %rcx,	4
    call      mc_genss.getcurrdatalen
    mov       %r10,	[%rdi+64]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	2
    mov       %r9,	[%rip+mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       [%rdi+64],	%rax
    movzx     %rax,	byte ptr[%rdi+72]
    cmp       %rax,	4
    jz        L3551
    cmp       %rax,	5
    jnz       L3550
L3551:
    movsxd    %rax,	dword ptr[%rdi+76]
    movsxd    %r10,	dword ptr[%rbx+12]
    add       %rax,	%r10
    mov       %rcx,	%rax
    call      mc_genss.gendword
    jmp       L3549
L3550:
    movsxd    %rax,	dword ptr[%rbx+12]
    mov       %rcx,	%rax
    call      mc_genss.gendword
    mov       %rcx,	2
    mov       %rdx,	%rdi
    call      mc_genss.addrelocitem
L3549:
    jmp       L3545
L3548:
    movsxd    %rax,	dword ptr[%rbx+12]
    mov       %rcx,	%rax
    call      mc_genss.gendword
    mov       %rcx,	2
    mov       %rdx,	%rdi
    call      mc_genss.addrelocitem
L3545:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genabs64
mc_genss.genabs64:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_genss.getdef
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi+93]
    cmp       %rax,	2
    jz        L3554
    cmp       %rax,	1
    jz        L3555
    jmp       L3556
L3554:
    movsxd    %rax,	dword ptr[%rdi+76]
    movsxd    %r10,	dword ptr[%rbx+12]
    add       %rax,	%r10
    mov       %rcx,	%rax
    call      mc_genss.genqword
    mov       %rcx,	1
    mov       %rdx,	%rdi
    call      mc_genss.addrelocitem
    jmp       L3553
L3555:
    mov       %rcx,	5
    call      mc_genss.getcurrdatalen
    mov       %r10,	[%rdi+64]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       [%rdi+64],	%rax
    movzx     %rax,	byte ptr[%rdi+72]
    cmp       %rax,	4
    jz        L3559
    cmp       %rax,	5
    jnz       L3558
L3559:
    movsxd    %rax,	dword ptr[%rdi+76]
    movsxd    %r10,	dword ptr[%rbx+12]
    add       %rax,	%r10
    mov       %rcx,	%rax
    call      mc_genss.genqword
    jmp       L3557
L3558:
    movsxd    %rax,	dword ptr[%rbx+12]
    mov       %rcx,	%rax
    call      mc_genss.genqword
    mov       %rcx,	1
    mov       %rdx,	%rdi
    call      mc_genss.addrelocitem
L3557:
    jmp       L3553
L3556:
    movsxd    %rax,	dword ptr[%rbx+12]
    mov       %rcx,	%rax
    call      mc_genss.genqword
    mov       %rcx,	1
    mov       %rdx,	%rdi
    call      mc_genss.addrelocitem
L3553:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.getrel32
mc_genss.getrel32:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rdi+93]
    cmp       %rax,	2
    jnz       L3562
    movzx     %rax,	byte ptr[%rdi+94]
    cmp       %rax,	[%rip+mc_genss.currseg]
    jz        L3564
    lea       %rcx,	[%rip+L10754]
    call      mc_libmcl.axerror
L3564:
    movsxd    %rax,	dword ptr[%rdi+76]
    lea       %r10,	[%rbx+1]
    sub       %rax,	%r10
    jmp       L3561
L3562:
    mov       %rax,	2147483647
L3561:
L3560:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.dofwdrefs
mc_genss.dofwdrefs:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
    mov       %rax,	[%r15+64]
    test      %rax,	%rax
    jz        L3565
L3567:
    mov       %rdi,	[%r15+64]
    jmp       L3569
L3568:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %rbx,	%rax
    movsx     %rax,	word ptr[%rdi+12]
    cmp       %rax,	4
    jz        L3572
    cmp       %rax,	2
    jz        L3573
    cmp       %rax,	1
    jz        L3573
    cmp       %rax,	6
    jz        L3574
    jmp       L3575
L3572:
    mov       %rcx,	[%rip+mc_genss.currdata]
    mov       %rdx,	%rbx
    call      mc_genss.bufferelemptr
    mov       %r12,	%rax
    movsxd    %rax,	dword ptr[%r15+76]
    sub       %rax,	%rbx
    sub       %rax,	4
    mov       [%r12],	%eax
    jmp       L3571
L3573:
    movsx     %rax,	word ptr[%rdi+14]
    cmp       %rax,	1
    jz        L3577
    cmp       %rax,	3
    jz        L3578
    cmp       %rax,	2
    jz        L3579
    jmp       L3580
L3577:
    mov       %r14,	[%rip+mc_decls.ss_code]
    jmp       L3576
L3578:
    lea       %rcx,	[%rip+L10755]
    call      mc_libmcl.axerror
    jmp       L3576
L3579:
    mov       %r14,	[%rip+mc_decls.ss_idata]
L3580:
L3576:
    mov       %rcx,	%r14
    mov       %rdx,	%rbx
    call      mc_genss.bufferelemptr
    mov       %r12,	%rax
    movsx     %rax,	word ptr[%rdi+12]
    cmp       %rax,	2
    jnz       L3582
    movsxd    %rax,	dword ptr[%r12]
    movsxd    %r10,	dword ptr[%r15+76]
    add       %rax,	%r10
    mov       [%r12],	%eax
    jmp       L3581
L3582:
    mov       %r13,	%r12
    mov       %rax,	[%r13]
    movsxd    %r10,	dword ptr[%r15+76]
    add       %rax,	%r10
    mov       [%r13],	%rax
L3581:
    jmp       L3571
L3574:
    mov       %rcx,	[%rip+mc_genss.currdata]
    mov       %rdx,	%rbx
    call      mc_genss.bufferelemptr
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%r15+76]
    sub       %rax,	%rbx
    dec       %rax
    mov       [%rsi],	%al
    jmp       L3571
L3575:
    call      msys.m$print_startcon
    movsx     %rax,	word ptr[%rdi+12]
    lea       %r10,	[%rip+mc_objdecls.relocnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%r15]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10756]
    call      mc_libmcl.axerror
L3571:
    mov       %rdi,	[%rdi]
L3569:
    test      %rdi,	%rdi
    jnz       L3568
L3565:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genrex
mc_genss.genrex:
#?>>
#?]]
#---------------
    mov       %al,	[%rip+mc_genss.f2override]
    test      %al,	%al
    jz        L3585
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	242
    mov       [%r10],	%al
L3585:
    mov       %al,	[%rip+mc_genss.f3override]
    test      %al,	%al
    jz        L3587
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	243
    mov       [%r10],	%al
L3587:
    mov       %al,	[%rip+mc_genss.sizeoverride]
    test      %al,	%al
    jz        L3589
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	102
    mov       [%r10],	%al
L3589:
    mov       %al,	[%rip+mc_genss.addroverride]
    test      %al,	%al
    jz        L3591
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	103
    mov       [%r10],	%al
L3591:
    mov       %al,	[%rip+mc_genss.nowmask]
    test      %al,	%al
    jz        L3593
    and       byte ptr[%rip+mc_genss.rex],	247
L3593:
    mov       %al,	[%rip+mc_genss.rex]
    test      %al,	%al
    jz        L3595
    movzx     %rax,	byte ptr[%rip+mc_genss.rex]
    and       %rax,	15
    add       %rax,	64
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
L3595:
#---------------
    ret       
# End 
# Proc mc_genss.isbytesized
mc_genss.isbytesized:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	-128
    jl        L3597
    cmp       %rax,	127
    jg        L3597
    mov       %rax,	1
    jmp       L3598
L3597:
    xor       %eax,	%eax
L3598:
L3596:
#---------------
    ret       
# End 
# Proc mc_genss.isdwordsized
mc_genss.isdwordsized:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	-2147483648
    jl        L3600
    cmp       %rax,	2147483647
    jg        L3600
    mov       %rax,	1
    jmp       L3601
L3600:
    xor       %eax,	%eax
L3601:
L3599:
#---------------
    ret       
# End 
# Proc mc_genss.genamode
mc_genss.genamode:
#?>>
    .set mc_genss.genamode.am, 40
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %rbx,	%rcx
    mov       [%rbp+40],	%rdx
#---------------
    mov       %al,	[%rbp + mc_genss.genamode.am]
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    movsx     %rax,	byte ptr[%rbp + mc_genss.genamode.am+2]
    cmp       %rax,	1
    jnz       L3604
    mov       %al,	[%rbp + mc_genss.genamode.am+1]
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
L3604:
    movzx     %rax,	byte ptr[%rbp + mc_genss.genamode.am+3]
    test      %rax,	%rax
    jz        L3606
    cmp       %rax,	1
    jz        L3607
    cmp       %rax,	4
    jz        L3608
    jmp       L3609
L3606:
    jmp       L3605
L3607:
    mov       %eax,	[%rbp + mc_genss.genamode.am+4]
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    jmp       L3605
L3608:
    movsx     %rax,	byte ptr[%rbp + mc_genss.genamode.am+2]
    cmp       %rax,	-1
    jnz       L3611
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.riplist]
    mov       [%rdi],	%rax
    mov       %rax,	[%rip+mc_genss.currdata]
    mov       %rax,	[%rax+8]
    mov       %r10,	[%rip+mc_genss.currdata]
    mov       %r10,	[%r10]
    sub       %rax,	%r10
    mov       [%rdi+8],	%eax
    mov       %rax,	%rdi
    mov       [%rip+mc_decls.riplist],	%rax
    mov       [%rip+mc_genss.ripentry],	%rax
L3611:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L3614
L3613:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L3616
    cmp       %rax,	6
    jz        L3616
    test      %rax,	%rax
    jz        L3617
    cmp       %rax,	8
    jz        L3617
    jmp       L3618
L3616:
    mov       %rcx,	%rbx
    call      mc_genss.genabs32
    jmp       L3615
L3617:
    movsxd    %rax,	dword ptr[%rbp + mc_genss.genamode.am+4]
    mov       %rcx,	%rax
    call      mc_genss.gendword
    jmp       L3615
L3618:
    lea       %rcx,	[%rip+L10757]
    call      mc_libmcl.axerror
L3615:
    jmp       L3612
L3614:
    call      msys.m$print_startcon
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    lea       %r10,	[%rip+mc_decls.opndnames_ma]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10758]
    call      mc_libmcl.axerror
L3612:
    jmp       L3605
L3609:
    lea       %rcx,	[%rip+L10759]
    call      mc_libmcl.axerror
L3605:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.setopsize
mc_genss.setopsize:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jz        L3621
    cmp       %rax,	4
    jz        L3622
    cmp       %rax,	1
    jz        L3623
    cmp       %rax,	2
    jz        L3624
    jmp       L3625
L3621:
    mov       %al,	8
    or        [%rip+mc_genss.rex],	%al
    jmp       L3620
L3622:
    jmp       L3620
L3623:
    jmp       L3620
L3624:
    mov       %al,	1
    mov       [%rip+mc_genss.sizeoverride],	%al
    jmp       L3620
L3625:
    lea       %rcx,	[%rip+L10760]
    call      mc_libmcl.axerror
L3620:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genss.getdispsize
mc_genss.getdispsize:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_genss.getdef
    mov       %rdi,	%rax
    mov       %eax,	[%rbx+12]
    mov       [%rsi],	%eax
    test      %rdi,	%rdi
    jz        L3628
    movzx     %rax,	byte ptr[%rdi+72]
    cmp       %rax,	4
    jz        L3631
    cmp       %rax,	5
    jnz       L3630
L3631:
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %r10,	%rsi
    add       [%r10],	%eax
    jmp       L3629
L3630:
    mov       %rax,	4
    jmp       L3626
L3629:
L3628:
    mov       %eax,	[%rsi]
    test      %eax,	%eax
    jz        L3633
    movsxd    %rax,	dword ptr[%rsi]
    mov       %rcx,	%rax
    call      mc_genss.isbytesized
    test      %rax,	%rax
    jz        L3635
    mov       %rax,	1
    jmp       L3634
L3635:
    mov       %rax,	4
L3634:
    jmp       L3632
L3633:
    xor       %eax,	%eax
L3632:
L3626:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.checkhighreg
mc_genss.checkhighreg:
#?>>
#?]]
#---------------
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L3638
    movzx     %rax,	byte ptr[%rcx+10]
    lea       %r10,	[%rip+mc_genss.ishighreg]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    or        [%rip+mc_genss.rex],	%r10b
L3638:
#---------------
    ret       
# End 
# Proc mc_genss.do_loop
mc_genss.do_loop:
#?>>
    .set mc_genss.do_loop.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	9
    call      mc_genss.getcurrdatalen
    inc       %rax
    mov       [%rbp + mc_genss.do_loop.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_genss.getdef
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genss.do_loop.$T1]
    call      mc_genss.getrel32
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jge       L3641
    cmp       %rdi,	-126
    jge       L3643
    lea       %rcx,	[%rip+L10761]
    call      mc_libmcl.axerror
L3643:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%sil
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%dil
    jmp       L3640
L3641:
    lea       %rcx,	[%rip+L10762]
    call      mc_libmcl.axerror
L3640:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_jcxz
mc_genss.do_jcxz:
#?>>
    .set mc_genss.do_jcxz.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	10
    call      mc_genss.getcurrdatalen
    inc       %rax
    mov       [%rbp + mc_genss.do_jcxz.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_genss.getdef
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genss.do_jcxz.$T1]
    call      mc_genss.getrel32
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jge       L3646
    cmp       %rdi,	-126
    jge       L3648
    lea       %rcx,	[%rip+L10763]
    call      mc_libmcl.axerror
L3648:
    cmp       %rsi,	4
    jnz       L3650
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	103
    mov       [%r10],	%al
L3650:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	227
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%dil
    jmp       L3645
L3646:
    lea       %rcx,	[%rip+L10764]
    call      mc_libmcl.axerror
L3645:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_call
mc_genss.do_call:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L3654
L3653:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	232
    mov       [%r10],	%al
    mov       %rcx,	%rdi
    call      mc_genss.genrel32
    jmp       L3652
L3654:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    test      %rax,	%rax
    jz        L3656
    cmp       %rax,	1
    jz        L3657
    cmp       %rax,	2
    jz        L3657
    cmp       %rax,	4
    jz        L3657
    jmp       L3658
L3656:
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    jmp       L3655
L3657:
    lea       %rcx,	[%rip+L10765]
    call      mc_libmcl.axerror
L3658:
L3655:
    mov       %rcx,	255
    mov       %rdx,	2
    mov       %r8,	%rdi
    call      mc_genss.genxrm
L3652:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_jmp
mc_genss.do_jmp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      mc_genss.getdef
    mov       %rsi,	%rax
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L3662
L3661:
    mov       %rcx,	11
    call      mc_genss.getcurrdatalen
    inc       %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genss.getrel32
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jge       L3664
    cmp       %rdi,	-126
    jle       L3664
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	235
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%dil
    jmp       L3663
L3664:
    xor       %rbx,	%rbx
    mov       %rax,	%rdi
    cmp       %rax,	0
    jle       L3666
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      mc_genss.checkshortjump
    mov       %rbx,	%rax
L3666:
    test      %rbx,	%rbx
    jnz       L3668
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	233
    mov       [%r10],	%al
    mov       %rcx,	%r12
    call      mc_genss.genrel32
    jmp       L3667
L3668:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	235
    mov       [%r10],	%al
    mov       %rcx,	%r12
    call      mc_genss.genrel8
L3667:
L3663:
    jmp       L3660
L3662:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    test      %rax,	%rax
    jz        L3670
    cmp       %rax,	1
    jz        L3671
    cmp       %rax,	2
    jz        L3671
    cmp       %rax,	4
    jz        L3671
    jmp       L3672
L3670:
    lea       %rax,	[%r12+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    jmp       L3669
L3671:
    lea       %rcx,	[%rip+L10766]
    call      mc_libmcl.axerror
L3672:
L3669:
    mov       %rcx,	255
    mov       %rdx,	4
    mov       %r8,	%r12
    call      mc_genss.genxrm
L3660:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.getcurrdatalen
mc_genss.getcurrdatalen:
#?>>
    .set mc_genss.getcurrdatalen.id, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_genss.currseg]
    cmp       %rax,	3
    jnz       L3675
    mov       %rax,	[%rip+mc_decls.ss_zdatalen]
    jmp       L3673
L3675:
    mov       %rcx,	[%rip+mc_genss.currdata]
    call      mc_genss.bufferlength
L3673:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genss.do_cmovcc
mc_genss.do_cmovcc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%rsi+8]
    and       %r10,	31
    cmp       %rax,	%r10
    jz        L3678
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    jz        L3678
    lea       %rcx,	[%rip+L10767]
    call      mc_libmcl.axerror
L3678:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L3680
    lea       %rcx,	[%rip+L10768]
    call      mc_libmcl.axerror
L3680:
    mov       %rax,	3904
    add       %rax,	%rdi
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_genss.genrrm
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_fmem
mc_genss.do_fmem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L3683
    lea       %rcx,	[%rip+L10769]
    call      mc_libmcl.axerror
L3683:
    test      %rsi,	%rsi
    jz        L3685
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jz        L3687
    cmp       %rax,	8
    jz        L3688
    cmp       %rax,	10
    jz        L3689
    cmp       %rax,	16
    jz        L3689
    jmp       L3690
L3687:
    xor       %rdi,	%rdi
    jmp       L3686
L3688:
    mov       %rdi,	2
    jmp       L3686
L3689:
    mov       %rdi,	1
    mov       %rax,	%r12
    test      %rax,	%rax
    jz        L3692
    cmp       %rax,	3
    jz        L3693
    jmp       L3694
L3692:
    mov       %r12,	5
    jmp       L3691
L3693:
    mov       %r12,	7
    jmp       L3691
L3694:
    lea       %rcx,	[%rip+L10770]
    call      mc_libmcl.axerror
L3691:
    jmp       L3686
L3690:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10771]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10772]
    call      mc_libmcl.axerror
L3686:
    jmp       L3684
L3685:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	2
    jz        L3696
    cmp       %rax,	4
    jz        L3697
    cmp       %rax,	8
    jz        L3698
    jmp       L3699
L3696:
    mov       %rdi,	3
    jmp       L3695
L3697:
    mov       %rdi,	1
    jmp       L3695
L3698:
    mov       %rdi,	3
    mov       %rax,	%r12
    test      %rax,	%rax
    jz        L3701
    cmp       %rax,	3
    jz        L3702
    jmp       L3703
L3701:
    mov       %r12,	5
    jmp       L3700
L3702:
    mov       %r12,	7
    jmp       L3700
L3703:
    lea       %rcx,	[%rip+L10773]
    call      mc_libmcl.axerror
L3700:
    jmp       L3695
L3699:
    lea       %rcx,	[%rip+L10774]
    call      mc_libmcl.axerror
L3695:
L3684:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %r10,	217
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%r12
    mov       %r8,	%rbx
    call      mc_genss.genxrm
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genrel8
mc_genss.genrel8:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_genss.getdef
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi+93]
    cmp       %rax,	1
    jnz       L3706
    mov       %rcx,	3
    call      mc_genss.getcurrdatalen
    mov       %r10,	[%rdi+64]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	6
    xor       %r9d,	%r9d
    call      mc_genss.addfwdref
    mov       [%rdi+64],	%rax
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    xor       %eax,	%eax
    mov       [%r10],	%al
    jmp       L3705
L3706:
    lea       %rcx,	[%rip+L10775]
    call      mc_libmcl.axerror
L3705:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.checkshortjump
mc_genss.checkshortjump:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rcx+8]
    mov       %rcx,	%rax
    jmp       L3709
L3708:
    movzx     %rax,	byte ptr[%rcx+33]
    cmp       %rax,	9
    jz        L3712
    cmp       %rax,	3
    jz        L3713
    cmp       %rax,	8
    jz        L3713
    cmp       %rax,	125
    jz        L3714
    jmp       L3715
L3712:
    mov       %rbx,	[%rcx+16]
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	6
    jz        L3717
    cmp       %rax,	5
    jz        L3718
    jmp       L3719
L3717:
    mov       %rax,	[%rbx]
    movsxd    %r10,	dword ptr[%rdx+100]
    cmp       %rax,	%r10
    jnz       L3721
    mov       %rax,	1
    jmp       L3707
L3721:
    jmp       L3716
L3718:
    mov       %rax,	[%rbx]
    cmp       %rax,	%rdx
    jnz       L3723
    mov       %rax,	1
    jmp       L3707
L3723:
L3719:
L3716:
    jmp       L3711
L3713:
    jmp       L3711
L3714:
    xor       %eax,	%eax
    jmp       L3707
L3715:
    inc       %rdi
L3711:
    mov       %rax,	[%rcx+8]
    mov       %rcx,	%rax
L3709:
    test      %rcx,	%rcx
    jz        L3724
    cmp       %rdi,	8
    jle       L3708
L3724:
    xor       %eax,	%eax
L3707:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.addfwdref
mc_genss.addfwdref:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi],	%rbx
    mov       [%rdi+8],	%esi
    mov       [%rdi+12],	%r12w
    mov       [%rdi+14],	%r13w
    mov       %rax,	%rdi
L3725:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.switchseg
mc_genss.switchseg:
#?>>
#?]]
#---------------
    cmp       %rcx,	[%rip+mc_genss.currseg]
    jz        L3726
L3728:
    mov       %rax,	[%rip+mc_genss.currseg]
    cmp       %rax,	1
    jz        L3730
    cmp       %rax,	2
    jz        L3731
    jmp       L3732
L3730:
    mov       %rax,	[%rip+mc_genss.currrelocs]
    mov       [%rip+mc_decls.ss_coderelocs],	%rax
    mov       %rax,	[%rip+mc_genss.nrelocs]
    mov       [%rip+mc_decls.ss_ncoderelocs],	%rax
    jmp       L3729
L3731:
    mov       %rax,	[%rip+mc_genss.currrelocs]
    mov       [%rip+mc_decls.ss_idatarelocs],	%rax
    mov       %rax,	[%rip+mc_genss.nrelocs]
    mov       [%rip+mc_decls.ss_nidatarelocs],	%rax
L3732:
L3729:
    mov       [%rip+mc_genss.currseg],	%rcx
    mov       %rax,	[%rip+mc_genss.currseg]
    cmp       %rax,	1
    jz        L3734
    cmp       %rax,	2
    jz        L3735
    cmp       %rax,	3
    jz        L3736
    jmp       L3737
L3734:
    mov       %rax,	[%rip+mc_decls.ss_code]
    mov       [%rip+mc_genss.currdata],	%rax
    mov       %rax,	[%rip+mc_decls.ss_coderelocs]
    mov       [%rip+mc_genss.currrelocs],	%rax
    mov       %rax,	[%rip+mc_decls.ss_ncoderelocs]
    mov       [%rip+mc_genss.nrelocs],	%rax
    jmp       L3733
L3735:
    mov       %rax,	[%rip+mc_decls.ss_idata]
    mov       [%rip+mc_genss.currdata],	%rax
    mov       %rax,	[%rip+mc_decls.ss_idatarelocs]
    mov       [%rip+mc_genss.currrelocs],	%rax
    mov       %rax,	[%rip+mc_decls.ss_nidatarelocs]
    mov       [%rip+mc_genss.nrelocs],	%rax
    jmp       L3733
L3736:
    mov       %rax,	[%rip+mc_decls.ss_zdata]
    mov       [%rip+mc_genss.currdata],	%rax
L3737:
L3733:
L3726:
#---------------
    ret       
# End 
# Proc mc_genss.do_popcnt
mc_genss.do_popcnt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L3740
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    jnz       L3742
    lea       %rax,	[%rbx+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L3742:
L3740:
    mov       %al,	1
    mov       [%rip+mc_genss.f3override],	%al
    mov       %rcx,	4024
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_bsf
mc_genss.do_bsf:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L3745
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    jnz       L3747
    lea       %rax,	[%rbx+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L3747:
L3745:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%rbx+8]
    and       %r10,	31
    cmp       %rax,	%r10
    jz        L3749
    lea       %rcx,	[%rip+L10776]
    call      mc_libmcl.axerror
L3749:
    mov       %rax,	3840
    add       %rax,	%rsi
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.extendsymboltable
mc_genss.extendsymboltable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rbx,	[%rip+mc_decls.ss_symboltablesize]
    mov       %rdi,	[%rip+mc_decls.ss_symboltable]
    mov       %rax,	[%rip+mc_decls.ss_symboltablesize]
    shl       %rax,	1
    mov       [%rip+mc_decls.ss_symboltablesize],	%rax
    mov       %rax,	8
    mov       %r10,	[%rip+mc_decls.ss_symboltablesize]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+mc_decls.ss_symboltable],	%rax
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L3753
L3751:
    mov       %rax,	[%rdi + %rsi*8-8]
    mov       %r10,	[%rip+mc_decls.ss_symboltable]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.ss_nsymbols]
    jle       L3751
L3753:
    mov       %rax,	8
    mov       %r10,	%rbx
    imul      %rax,	%r10
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.initlib
mc_genss.initlib:
#?>>
    .set mc_genss.initlib.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	262144
    call      mlib.pcm_alloc
    mov       [%rip+mc_decls.ss_symboltable],	%rax
    mov       %rax,	32768
    mov       [%rip+mc_decls.ss_symboltablesize],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.ss_nsymbols],	%rax
    mov       %rax,	%rsi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+mc_decls.labeldeftable],	%rax
    mov       %rbx,	1
    cmp       %rsi,	1
    jl        L3757
L3755:
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %r10,	[%rip+mc_decls.labeldeftable]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rdi,	%rax
    mov       [%rdi+100],	%ebx
    lea       %rcx,	[%rbp + mc_genss.initlib.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10777]
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_genss.initlib.str]
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    mov       %al,	1
    mov       [%rdi+93],	%al
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L3755
L3757:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.buffercreate
mc_genss.buffercreate:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       [%rdi+24],	%rbx
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rdi+8],	%rax
    mov       [%rdi],	%rax
    mov       %rax,	[%rdi]
    mov       %r10,	[%rdi+24]
    lea       %rax,	[%rax + %r10]
    mov       [%rdi+16],	%rax
    mov       %rax,	%rdi
L3758:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.bufferexpand
mc_genss.bufferexpand:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rax,	[%r12+24]
    shl       %rax,	1
    mov       %rdi,	%rax
    mov       %rax,	[%r12+8]
    mov       %r10,	[%r12]
    sub       %rax,	%r10
    mov       %rbx,	%rax
    mov       %rax,	[%r12+24]
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jle       L3761
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10778]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    call      exit
L3761:
    mov       %rcx,	%rdi
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      memcpy
    mov       [%r12],	%rsi
    lea       %rax,	[%rsi + %rbx]
    mov       [%r12+8],	%rax
    mov       [%r12+24],	%rdi
    lea       %rax,	[%rsi + %rdi]
    mov       [%r12+16],	%rax
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.buffercheck
mc_genss.buffercheck:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    jmp       L3764
L3763:
    mov       %rcx,	%rdi
    call      mc_genss.bufferexpand
L3764:
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+8]
    sub       %rax,	%r10
    cmp       %rax,	%rbx
    jl        L3763
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.bufferlength
mc_genss.bufferlength:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx+8]
    mov       %r10,	[%rcx]
    sub       %rax,	%r10
L3766:
#---------------
    ret       
# End 
# Proc mc_genss.bufferelemptr
mc_genss.bufferelemptr:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    mov       %r10,	%rdx
    lea       %rax,	[%rax + %r10]
L3767:
#---------------
    ret       
# End 
# Proc mc_genss.addword
mc_genss.addword:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx+8]
    mov       %r10w,	%dx
    mov       [%rax],	%r10w
    lea       %rax,	[%rcx+8]
    add       qword ptr[%rax],	2
#---------------
    ret       
# End 
# Proc mc_genss.adddword
mc_genss.adddword:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx+8]
    mov       %r10d,	%edx
    mov       [%rax],	%r10d
    lea       %rax,	[%rcx+8]
    add       qword ptr[%rax],	4
#---------------
    ret       
# End 
# Proc mc_genss.addqword
mc_genss.addqword:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx+8]
    mov       %r10,	%rdx
    mov       [%rax],	%r10
    lea       %rax,	[%rcx+8]
    add       qword ptr[%rax],	8
#---------------
    ret       
# End 
# Proc mc_genss.genxrm
mc_genss.genxrm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%r12
    call      mc_genss.setopsize
    xor       %ecx,	%ecx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_genss.genrm
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_genss.currmcl]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	12
    jz        L3773
    cmp       %rax,	13
    jnz       L3774
L3773:
    and       byte ptr[%rip+mc_genss.rex],	247
L3774:
L3772:
    mov       %rax,	%rbx
    shr       %rax,	16
    and       %rax,	255
    jz        L3776
    mov       %rax,	%rbx
    shr       %rax,	16
    and       %rax,	511
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
L3776:
    call      mc_genss.genrex
    mov       %rax,	%rbx
    shr       %rax,	8
    and       %rax,	255
    jz        L3778
    mov       %rax,	%rbx
    shr       %rax,	8
    and       %rax,	255
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
L3778:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%bl
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_genss.genamode
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genrrm
mc_genss.genrrm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L3781
    movzx     %rax,	byte ptr[%rsi+10]
    lea       %r10,	[%rip+mc_genss.ishighreg]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    or        [%rip+mc_genss.rex],	%r10b
L3781:
    mov       %rcx,	%rsi
    call      mc_genss.setopsize
    mov       %al,	[%rip+mc_genss.usesizeb]
    test      %al,	%al
    jz        L3783
    and       byte ptr[%rip+mc_genss.rex],	247
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L3785
    mov       %al,	8
    or        [%rip+mc_genss.rex],	%al
L3785:
L3783:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	%r12
    mov       %r9,	%rax
    call      mc_genss.genrm
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    shr       %rax,	16
    and       %rax,	255
    jz        L3787
    mov       %rax,	%rbx
    shr       %rax,	16
    and       %rax,	511
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
L3787:
    call      mc_genss.genrex
    mov       %rax,	%rbx
    shr       %rax,	8
    and       %rax,	255
    jz        L3789
    mov       %rax,	%rbx
    shr       %rax,	8
    and       %rax,	255
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
L3789:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%bl
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_genss.genamode
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.getregcode
mc_genss.getregcode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    test      %r8,	%r8
    jnz       L3792
    lea       %rax,	[%rip+mc_decls.regcodes]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rdi,	%rax
    jmp       L3791
L3792:
    lea       %rax,	[%rcx-1]
    mov       %rdi,	%rax
L3791:
    cmp       %rdi,	8
    jl        L3794
    mov       %rax,	8
    sub       %rdi,	%rax
    mov       %al,	%dl
    or        [%rip+mc_genss.rex],	%al
L3794:
    mov       %rax,	%rdi
L3790:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_genss.checkimmrange
mc_genss.checkimmrange:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L3797
    cmp       %rax,	2
    jz        L3798
    jmp       L3799
L3797:
    mov       %rax,	%rdi
    cmp       %rax,	-128
    jl        L3802
    cmp       %rax,	255
    jle       L3801
L3802:
    lea       %rcx,	[%rip+L10779]
    call      mc_libmcl.axerror
L3801:
    jmp       L3796
L3798:
    mov       %rax,	%rdi
    cmp       %rax,	-32768
    jl        L3805
    cmp       %rax,	65535
    jle       L3804
L3805:
    lea       %rcx,	[%rip+L10780]
    call      mc_libmcl.axerror
L3804:
    jmp       L3796
L3799:
    mov       %rax,	%rdi
    cmp       %rax,	-2147483648
    jl        L3808
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jle       L3807
L3808:
    lea       %rcx,	[%rip+L10781]
    call      mc_libmcl.axerror
L3807:
L3796:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.genrm
mc_genss.genrm:
#?>>
    .set mc_genss.genrm.b, 80
    .set mc_genss.genrm.isxreg, 88
    .set mc_genss.genrm.base, -8
    .set mc_genss.genrm.regix, -16
    .set mc_genss.genrm.ismem, -24
    .set mc_genss.genrm.am, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    lea       %rax,	[%rbp + mc_genss.genrm.am]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    test      %r13,	%r13
    jz        L3811
    mov       %rcx,	%r13
    mov       %rdx,	4
    mov       %r8,	[%rbp + mc_genss.genrm.isxreg]
    call      mc_genss.getregcode
    mov       %r14,	%rax
L3811:
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3813
    cmp       %rax,	5
    jz        L3813
    cmp       %rax,	3
    jz        L3814
    jmp       L3815
L3813:
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    mov       %r10,	[%rbp + mc_genss.genrm.b]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    mov       %rdx,	1
    mov       %r8,	%rax
    call      mc_genss.getregcode
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	byte ptr[%rax+10]
    lea       %r10,	[%rip+mc_genss.ishighreg]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    or        [%rip+mc_genss.rex],	%r10b
    mov       %rax,	%r14
    shl       %rax,	3
    mov       %r10,	192
    add       %r10,	%rax
    add       %r10,	%rbx
    mov       [%rbp + mc_genss.genrm.am],	%r10b
    mov       %rax,	[%rbp + mc_genss.genrm.am]
    jmp       L3809
L3814:
    mov       %rax,	1
    mov       [%rbp + mc_genss.genrm.ismem],	%rax
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L3817
    cmp       %rax,	3
    jz        L3818
    cmp       %rax,	6
    jz        L3819
    jmp       L3820
L3817:
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	3
    jnz       L3822
    mov       %rax,	2
    mov       [%rbp + mc_genss.genrm.ismem],	%rax
L3822:
    jmp       L3816
L3818:
    mov       %rax,	2
    mov       [%rbp + mc_genss.genrm.ismem],	%rax
    jmp       L3816
L3819:
    mov       %rax,	2
    mov       [%rbp + mc_genss.genrm.ismem],	%rax
L3820:
L3816:
    jmp       L3812
L3815:
    lea       %rcx,	[%rip+L10782]
    call      mc_libmcl.axerror
L3812:
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %r13,	%rax
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	byte ptr[%rax+11]
    mov       [%rbp + mc_genss.genrm.regix],	%rax
    mov       %rax,	[%rbp + mc_genss.genrm.regix]
    cmp       %rax,	%r13
    jnz       L3824
    test      %rax,	%rax
    jnz       L3824
    xor       %rdi,	%rdi
    mov       %rax,	4
    mov       %rbx,	%rax
    mov       %rsi,	1
    mov       %r12,	4
    mov       %rax,	5
    mov       [%rbp + mc_genss.genrm.base],	%rax
    mov       %al,	4
    mov       [%rbp + mc_genss.genrm.am+3],	%al
    jmp       L3823
L3824:
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	5
    and       %rax,	15
    cmp       %rax,	1
    jg        L3825
    mov       %rax,	[%rbp + mc_genss.genrm.regix]
    test      %rax,	%rax
    jnz       L3825
#mc_genss.genrm.simple:
L3826:
    lea       %rax,	[%rbp + mc_genss.genrm.am+4]
    mov       %rcx,	[%rbp + mc_genss.genrm.b]
    mov       %rdx,	%rax
    call      mc_genss.getdispsize
    mov       [%rbp + mc_genss.genrm.am+3],	%al
    mov       %al,	[%rbp + mc_genss.genrm.am+3]
    test      %al,	%al
    jz        L3828
    movzx     %rax,	byte ptr[%rbp + mc_genss.genrm.am+3]
    cmp       %rax,	1
    jnz       L3830
    mov       %rax,	1
    jmp       L3829
L3830:
    mov       %rax,	2
L3829:
    mov       %rdi,	%rax
L3828:
    mov       %rcx,	%r13
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       [%rbp + mc_genss.genrm.base],	%rax
    mov       %rbx,	%rax
    cmp       %rbx,	4
    jz        L3832
    cmp       %rbx,	5
    jnz       L3834
    movzx     %rax,	byte ptr[%rbp + mc_genss.genrm.am+3]
    test      %rax,	%rax
    jnz       L3834
    mov       %rdi,	1
    mov       %al,	1
    mov       [%rbp + mc_genss.genrm.am+3],	%al
L3834:
    xor       %r12,	%r12
    jmp       L3831
L3832:
    mov       %r12,	4
    mov       %rsi,	1
L3831:
    jmp       L3823
L3825:
    mov       %rax,	[%rbp + mc_genss.genrm.regix]
    test      %rax,	%rax
    jz        L3835
    test      %r13,	%r13
    jnz       L3835
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	5
    and       %rax,	15
    cmp       %rax,	1
    jg        L3837
    mov       %rax,	%r13
    mov       %r10,	[%rbp + mc_genss.genrm.regix]
    mov       [%rbp + mc_genss.genrm.regix],	%rax
    mov       %r13,	%r10
    jmp       L3826
L3837:
    mov       %al,	4
    mov       [%rbp + mc_genss.genrm.am+3],	%al
    xor       %rdi,	%rdi
    mov       %rax,	4
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	5
    and       %rax,	15
    jz        L3839
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	5
    and       %rax,	15
    jmp       L3838
L3839:
    mov       %rax,	1
L3838:
    mov       %rsi,	%rax
    mov       %rax,	5
    mov       [%rbp + mc_genss.genrm.base],	%rax
    mov       %rcx,	[%rbp + mc_genss.genrm.regix]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mc_genss.genrm.regix]
    cmp       %rax,	16
    jnz       L3841
    lea       %rcx,	[%rip+L10783]
    call      mc_libmcl.axerror
L3841:
    jmp       L3823
L3835:
    lea       %rax,	[%rbp + mc_genss.genrm.am+4]
    mov       %rcx,	[%rbp + mc_genss.genrm.b]
    mov       %rdx,	%rax
    call      mc_genss.getdispsize
    mov       [%rbp + mc_genss.genrm.am+3],	%al
    mov       %al,	[%rbp + mc_genss.genrm.am+3]
    test      %al,	%al
    jz        L3843
    movzx     %rax,	byte ptr[%rbp + mc_genss.genrm.am+3]
    cmp       %rax,	1
    jnz       L3845
    mov       %rax,	1
    jmp       L3844
L3845:
    mov       %rax,	2
L3844:
    mov       %rdi,	%rax
L3843:
    mov       %rbx,	4
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	5
    and       %rax,	15
    jz        L3847
    mov       %rax,	[%rbp + mc_genss.genrm.b]
    movzx     %rax,	word ptr[%rax+8]
    shr       %rax,	5
    and       %rax,	15
    jmp       L3846
L3847:
    mov       %rax,	1
L3846:
    mov       %rsi,	%rax
    test      %r13,	%r13
    jnz       L3849
    mov       %rax,	5
    mov       [%rbp + mc_genss.genrm.base],	%rax
    jmp       L3848
L3849:
    mov       %rax,	%r13
    cmp       %rax,	15
    jz        L3852
    cmp       %rax,	8
    jnz       L3851
L3852:
    movzx     %rax,	byte ptr[%rbp + mc_genss.genrm.am+3]
    test      %rax,	%rax
    jnz       L3851
    mov       %rdi,	1
    mov       %al,	1
    mov       [%rbp + mc_genss.genrm.am+3],	%al
L3851:
    mov       %rcx,	%r13
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       [%rbp + mc_genss.genrm.base],	%rax
L3848:
    mov       %rax,	[%rbp + mc_genss.genrm.regix]
    test      %rax,	%rax
    jnz       L3854
    mov       %r12,	4
    jmp       L3853
L3854:
    mov       %rcx,	[%rbp + mc_genss.genrm.regix]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       %r12,	%rax
    test      %r13,	%r13
    jnz       L3856
    mov       %al,	4
    mov       [%rbp + mc_genss.genrm.am+3],	%al
L3856:
    mov       %rax,	[%rbp + mc_genss.genrm.regix]
    cmp       %rax,	16
    jnz       L3858
    cmp       %rsi,	1
    jle       L3858
    lea       %rcx,	[%rip+L10784]
    call      mc_libmcl.axerror
L3858:
L3853:
L3823:
    test      %rsi,	%rsi
    jz        L3860
    lea       %rax,	[%rip+mc_genss.genrm.scaletable]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    shl       %rax,	6
    mov       %r10,	%r12
    shl       %r10,	3
    add       %rax,	%r10
    add       %rax,	[%rbp + mc_genss.genrm.base]
    mov       [%rbp + mc_genss.genrm.am+1],	%al
    mov       %al,	1
    mov       [%rbp + mc_genss.genrm.am+2],	%al
L3860:
    movzx     %rax,	byte ptr[%rbp + mc_genss.genrm.am+3]
    cmp       %rax,	4
    jnz       L3862
    mov       %rax,	[%rbp + mc_genss.genrm.ismem]
    test      %rax,	%rax
    jz        L3862
    test      %r13,	%r13
    jnz       L3865
    mov       %rax,	[%rbp + mc_genss.genrm.regix]
    test      %rax,	%rax
    jz        L3864
L3865:
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L3867
    mov       %rax,	[%rbp + mc_genss.genrm.ismem]
    cmp       %rax,	2
    jnz       L3867
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10785]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+mc_genss.currmcl]
    call      mc_writeasm.strmclstr
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3867:
    jmp       L3863
L3864:
    mov       %al,	[%rip+pc_api.phighmem]
    test      %al,	%al
    jz        L3868
    mov       %al,	-1
    mov       [%rbp + mc_genss.genrm.am+2],	%al
    xor       %rdi,	%rdi
    mov       %rax,	5
    mov       %rbx,	%rax
L3868:
L3863:
L3862:
    mov       %rax,	%rdi
    shl       %rax,	6
    mov       %r10,	%r14
    shl       %r10,	3
    add       %rax,	%r10
    add       %rax,	%rbx
    mov       [%rbp + mc_genss.genrm.am],	%al
    mov       %rax,	[%rbp + mc_genss.genrm.am]
L3809:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_arith
mc_genss.do_arith:
#?>>
    .set mc_genss.do_arith.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3871
    cmp       %rax,	3
    jz        L3872
    jmp       L3873
L3871:
    movzx     %rax,	word ptr[%r14+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3875
    cmp       %rax,	3
    jz        L3875
    cmp       %rax,	2
    jz        L3876
    jmp       L3877
L3875:
    mov       %rax,	%r15
    shl       %rax,	3
    mov       [%rbp + mc_genss.do_arith.$T1],	%rax
    movzx     %rax,	word ptr[%r13+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L3879
    mov       %rax,	2
    jmp       L3878
L3879:
    mov       %rax,	3
L3878:
    mov       %r10,	[%rbp + mc_genss.do_arith.$T1]
    or        %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      mc_genss.genrrm
    jmp       L3874
L3876:
#mc_genss.do_arith.doregimm:
L3880:
    mov       %rcx,	%r14
    xor       %edx,	%edx
    call      mc_genss.getdef
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L3882
    movzx     %rax,	word ptr[%r13+8]
    and       %rax,	31
    cmp       %rax,	4
    jge       L3884
    lea       %rcx,	[%rip+L10786]
    call      mc_libmcl.axerror
L3884:
    mov       %rcx,	129
    mov       %rdx,	%r15
    mov       %r8,	%r13
    call      mc_genss.genxrm
    mov       %rcx,	%r14
    mov       %rdx,	4
    call      mc_genss.genopnd
    jmp       L3869
L3882:
    mov       %r12,	[%r14]
    mov       %rsi,	1
    movzx     %rax,	word ptr[%r13+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L3886
    mov       %rbx,	128
    mov       %rcx,	%r12
    mov       %rdx,	1
    call      mc_genss.checkimmrange
    mov       %rax,	%r12
    cmp       %rax,	-128
    jl        L3889
    cmp       %rax,	255
    jle       L3888
L3889:
    lea       %rcx,	[%rip+L10787]
    call      mc_libmcl.axerror
L3888:
    jmp       L3885
L3886:
    mov       %rax,	%r12
    cmp       %rax,	-128
    jl        L3890
    cmp       %rax,	127
    jg        L3890
    mov       %rbx,	131
    jmp       L3885
L3890:
    mov       %rcx,	%r12
    mov       %rdx,	4
    call      mc_genss.checkimmrange
    mov       %rbx,	129
    movzx     %rax,	word ptr[%r13+8]
    and       %rax,	31
    cmp       %rax,	2
    jnz       L3892
    mov       %rax,	2
    jmp       L3891
L3892:
    mov       %rax,	4
L3891:
    mov       %rsi,	%rax
L3885:
    mov       %rcx,	%rbx
    mov       %rdx,	%r15
    mov       %r8,	%r13
    call      mc_genss.genxrm
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L3894
    cmp       %rax,	2
    jz        L3895
    cmp       %rax,	4
    jz        L3896
    jmp       L3897
L3894:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%r12b
    jmp       L3893
L3895:
    mov       %rcx,	%r12
    call      mc_genss.genword
    jmp       L3893
L3896:
    mov       %rcx,	%r12
    call      mc_genss.gendword
L3897:
L3893:
    mov       %rcx,	%rsi
    call      mc_genss.fixrip
    jmp       L3874
L3877:
    lea       %rcx,	[%rip+L10788]
    call      mc_libmcl.axerror
L3874:
    jmp       L3870
L3872:
    movzx     %rax,	word ptr[%r14+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3899
    cmp       %rax,	2
    jz        L3900
    jmp       L3901
L3899:
    mov       %rax,	%r15
    shl       %rax,	3
    mov       [%rbp + mc_genss.do_arith.$T1],	%rax
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L3903
    xor       %eax,	%eax
    jmp       L3902
L3903:
    mov       %rax,	1
L3902:
    mov       %r10,	[%rbp + mc_genss.do_arith.$T1]
    or        %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    mov       %r8,	%r13
    call      mc_genss.genrrm
    jmp       L3898
L3900:
    jmp       L3880
L3901:
    lea       %rcx,	[%rip+L10789]
    call      mc_libmcl.axerror
L3898:
    jmp       L3870
L3873:
    call      msys.m$print_startcon
    lea       %rax,	[%rip+mc_decls.opndnames_ma]
    mov       %r10,	%r15
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L10790]
    call      msys.m$print_str_nf
    mov       %rcx,	%r15
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10791]
    call      mc_libmcl.axerror
L3870:
L3869:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_mov
mc_genss.do_mov:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r14,	%rcx
    mov       %r15,	%rdx
#---------------
    mov       %rcx,	%r15
    xor       %edx,	%edx
    call      mc_genss.getdef
    mov       %r13,	%rax
    movzx     %rax,	word ptr[%r14+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3906
    cmp       %rax,	3
    jz        L3907
    jmp       L3908
L3906:
    movzx     %rax,	word ptr[%r15+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3910
    cmp       %rax,	3
    jz        L3910
    cmp       %rax,	2
    jz        L3911
    jmp       L3912
L3910:
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%r15+8]
    and       %r10,	31
    cmp       %rax,	%r10
    jz        L3914
    movzx     %rax,	word ptr[%r15+8]
    and       %rax,	31
    jz        L3914
    lea       %rcx,	[%rip+L10792]
    call      mc_libmcl.axerror
L3914:
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L3916
    mov       %rax,	138
    jmp       L3915
L3916:
    mov       %rax,	139
L3915:
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    mov       %r8,	%r15
    call      mc_genss.genrrm
    jmp       L3909
L3911:
    mov       %r12,	[%r15]
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%rax
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    call      mc_genss.setopsize
    test      %r13,	%r13
    jz        L3918
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    cmp       %rax,	2
    jg        L3918
    lea       %rcx,	[%rip+L10793]
    call      mc_libmcl.axerror
L3918:
    mov       %rcx,	%r14
    call      mc_genss.checkhighreg
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    cmp       %rax,	1
    jz        L3920
    cmp       %rax,	2
    jz        L3921
    cmp       %rax,	4
    jz        L3922
    jmp       L3923
L3920:
    mov       %rax,	%r12
    cmp       %rax,	-128
    jl        L3926
    cmp       %rax,	255
    jle       L3925
L3926:
    lea       %rcx,	[%rip+L10794]
    call      mc_libmcl.axerror
L3925:
    call      mc_genss.genrex
    mov       %rax,	176
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%r12b
    jmp       L3919
L3921:
    mov       %rax,	%r12
    cmp       %rax,	-32768
    jl        L3929
    cmp       %rax,	65535
    jle       L3928
L3929:
    lea       %rcx,	[%rip+L10795]
    call      mc_libmcl.axerror
L3928:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	102
    mov       [%r10],	%al
    call      mc_genss.genrex
    mov       %rax,	184
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    mov       %rcx,	%r12
    call      mc_genss.genword
    jmp       L3919
L3922:
    test      %r13,	%r13
    jz        L3931
    call      mc_genss.genrex
    mov       %rax,	184
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    mov       %rcx,	%r15
    mov       %rdx,	4
    call      mc_genss.genopnd
    jmp       L3930
L3931:
    mov       %rax,	%r12
    cmp       %rax,	-2147483648
    jl        L3934
    mov       %r10d,	4294967295
    mov       %r10d,	%r10d
    cmp       %rax,	%r10
    jle       L3933
L3934:
    call      msys.m$print_startcon
    mov       %rcx,	%r12
    call      msys.m$print_i64_nf
    mov       %rcx,	%r12
    call      msys.m$print_ptr_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10796]
    call      mc_libmcl.axerror
L3933:
#mc_genss.do_mov.doreg32:
L3935:
    call      mc_genss.genrex
    mov       %rax,	184
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    mov       %rcx,	%r12
    call      mc_genss.gendword
L3930:
    jmp       L3919
L3923:
    test      %r13,	%r13
    jz        L3937
    mov       %al,	8
    or        [%rip+mc_genss.rex],	%al
    call      mc_genss.genrex
    mov       %rax,	184
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    mov       %rcx,	%r15
    mov       %rdx,	8
    call      mc_genss.genopnd
    jmp       L3936
L3937:
    cmp       %r12,	0
    jl        L3939
    mov       %rax,	%r12
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jg        L3939
    and       byte ptr[%rip+mc_genss.rex],	247
    jmp       L3935
L3939:
    mov       %al,	8
    or        [%rip+mc_genss.rex],	%al
    call      mc_genss.genrex
    mov       %rax,	184
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    mov       %rcx,	%r12
    call      mc_genss.genqword
L3936:
L3919:
    jmp       L3909
L3912:
    lea       %rcx,	[%rip+L10797]
    call      mc_libmcl.axerror
L3909:
    jmp       L3905
L3907:
    movzx     %rax,	word ptr[%r15+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3941
    cmp       %rax,	2
    jz        L3942
    jmp       L3943
L3941:
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    jnz       L3945
    movzx     %rax,	word ptr[%r15+8]
    and       %rax,	31
    lea       %r10,	[%r14+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
L3945:
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%r15+8]
    and       %r10,	31
    cmp       %rax,	%r10
    jz        L3947
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    jz        L3947
    lea       %rcx,	[%rip+L10798]
    call      mc_libmcl.axerror
L3947:
    movzx     %rax,	word ptr[%r15+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L3949
    mov       %rax,	136
    jmp       L3948
L3949:
    mov       %rax,	137
L3948:
    mov       %rcx,	%rax
    mov       %rdx,	%r15
    mov       %r8,	%r14
    call      mc_genss.genrrm
    jmp       L3940
L3942:
    mov       %r12,	[%r15]
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    jnz       L3951
    lea       %rax,	[%r14+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L3951:
    test      %r13,	%r13
    jz        L3953
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    cmp       %rax,	2
    jg        L3953
    lea       %rcx,	[%rip+L10799]
    call      mc_libmcl.axerror
L3953:
    mov       %rcx,	%r14
    call      mc_genss.setopsize
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L3955
    mov       %rax,	198
    jmp       L3954
L3955:
    mov       %rax,	199
L3954:
    mov       %rbx,	%rax
    test      %r13,	%r13
    jnz       L3957
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mc_genss.checkimmrange
L3957:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    mov       %r8,	%r14
    call      mc_genss.genxrm
    mov       %r12,	[%r15]
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    mov       %rsi,	%rax
    movzx     %rax,	word ptr[%r14+8]
    and       %rax,	31
    cmp       %rax,	1
    jz        L3959
    cmp       %rax,	2
    jz        L3960
    cmp       %rax,	4
    jz        L3961
    cmp       %rax,	8
    jz        L3961
    jmp       L3962
L3959:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%r12b
    jmp       L3958
L3960:
    mov       %rcx,	%r12
    call      mc_genss.genword
    jmp       L3958
L3961:
    mov       %rcx,	%r15
    mov       %rdx,	4
    call      mc_genss.genopnd
    mov       %rsi,	4
L3962:
L3958:
    mov       %rcx,	%rsi
    call      mc_genss.fixrip
    jmp       L3940
L3943:
    lea       %rcx,	[%rip+L10800]
    call      mc_libmcl.axerror
L3940:
    jmp       L3905
L3908:
    lea       %rcx,	[%rip+L10801]
    call      mc_libmcl.axerror
L3905:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_push
mc_genss.do_push:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    jnz       L3965
    lea       %rax,	[%rbx+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L3965:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3967
    cmp       %rax,	2
    jz        L3968
    cmp       %rax,	3
    jz        L3969
    jmp       L3970
L3967:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	8
    jz        L3972
    lea       %rcx,	[%rip+L10802]
    call      mc_libmcl.axerror
L3972:
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       %rdi,	%rax
    and       byte ptr[%rip+mc_genss.rex],	247
    call      mc_genss.genrex
    mov       %rax,	80
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    jmp       L3966
L3968:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_genss.getdef
    test      %rax,	%rax
    jz        L3974
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	104
    mov       [%r10],	%al
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_genss.genopnd
    jmp       L3973
L3974:
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      mc_genss.isbytesized
    test      %rax,	%rax
    jz        L3975
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	106
    mov       [%r10],	%al
    mov       %rax,	[%rbx]
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    jmp       L3973
L3975:
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      mc_genss.isdwordsized
    test      %rax,	%rax
    jz        L3976
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	104
    mov       [%r10],	%al
    mov       %rcx,	[%rbx]
    call      mc_genss.gendword
    jmp       L3973
L3976:
    lea       %rcx,	[%rip+L10803]
    call      mc_libmcl.axerror
L3973:
    jmp       L3966
L3969:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	8
    jz        L3978
    lea       %rcx,	[%rip+L10804]
    call      mc_libmcl.axerror
L3978:
    mov       %rcx,	255
    mov       %rdx,	6
    mov       %r8,	%rbx
    call      mc_genss.genxrm
    jmp       L3966
L3970:
    lea       %rcx,	[%rip+L10805]
    call      mc_libmcl.axerror
L3966:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_pop
mc_genss.do_pop:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    jnz       L3981
    lea       %rax,	[%rbx+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L3981:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3983
    cmp       %rax,	3
    jz        L3984
    jmp       L3985
L3983:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	8
    jz        L3987
    lea       %rcx,	[%rip+L10806]
    call      mc_libmcl.axerror
L3987:
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       %rdi,	%rax
    call      mc_genss.genrex
    mov       %rax,	88
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    jmp       L3982
L3984:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	8
    jz        L3989
    lea       %rcx,	[%rip+L10807]
    call      mc_libmcl.axerror
L3989:
    mov       %rcx,	143
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      mc_genss.genxrm
    jmp       L3982
L3985:
    lea       %rcx,	[%rip+L10808]
    call      mc_libmcl.axerror
L3982:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_inc
mc_genss.do_inc:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3992
    cmp       %rax,	3
    jnz       L3993
L3992:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L3995
    mov       %rax,	254
    jmp       L3994
L3995:
    mov       %rax,	255
L3994:
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_genss.genxrm
    jmp       L3991
L3993:
    lea       %rcx,	[%rip+L10809]
    call      mc_libmcl.axerror
L3991:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_neg
mc_genss.do_neg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3998
    cmp       %rax,	3
    jnz       L3999
L3998:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L4001
    mov       %rax,	246
    jmp       L4000
L4001:
    mov       %rax,	247
L4000:
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_genss.genxrm
    jmp       L3997
L3999:
    lea       %rcx,	[%rip+L10810]
    call      mc_libmcl.axerror
L3997:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_lea
mc_genss.do_lea:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4005
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4004
L4005:
    lea       %rcx,	[%rip+L10811]
    call      mc_libmcl.axerror
L4004:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	4
    jge       L4007
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10812]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10813]
    call      mc_libmcl.axerror
L4007:
    mov       %rcx,	141
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_movsx
mc_genss.do_movsx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4010
    lea       %rcx,	[%rip+L10814]
    call      mc_libmcl.axerror
L4010:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L4012
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L4012
    cmp       %rsi,	190
    jnz       L4014
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_movsxd
    jmp       L4013
L4014:
    movzx     %rax,	byte ptr[%rdi+10]
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rax
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       %r10,	[%r10+24]
    mov       %rdi,	%r10
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_genss.do_mov
L4013:
    jmp       L4008
L4012:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	1
    jz        L4017
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%rbx+8]
    and       %r10,	31
    cmp       %rax,	%r10
    ja        L4016
L4017:
    lea       %rcx,	[%rip+L10815]
    call      mc_libmcl.axerror
L4016:
    cmp       %rsi,	182
    jnz       L4019
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L4019
    lea       %rcx,	[%rip+L10816]
    call      mc_libmcl.axerror
L4019:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4021
    cmp       %rax,	3
    jz        L4022
    jmp       L4023
L4021:
    jmp       L4020
L4022:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    jnz       L4025
    lea       %rcx,	[%rip+L10817]
    call      mc_libmcl.axerror
L4025:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L4027
    lea       %rcx,	[%rip+L10818]
    call      mc_libmcl.axerror
L4027:
    jmp       L4020
L4023:
    lea       %rcx,	[%rip+L10819]
    call      mc_libmcl.axerror
L4020:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L4029
    mov       %rax,	%rsi
    jmp       L4028
L4029:
    lea       %rax,	[%rsi+1]
L4028:
    mov       %r10,	3840
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
L4008:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_exch
mc_genss.do_exch:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4032
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4032
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	1
    jz        L4033
    movzx     %rax,	byte ptr[%rsi+10]
    cmp       %rax,	1
    jnz       L4032
L4033:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jz        L4032
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	1
    jz        L4035
    mov       %rax,	%rbx
    mov       %r10,	%rsi
    mov       %rsi,	%rax
    mov       %rbx,	%r10
L4035:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%rsi+8]
    and       %r10,	31
    cmp       %rax,	%r10
    jz        L4037
    lea       %rcx,	[%rip+L10820]
    call      mc_libmcl.axerror
L4037:
    mov       %rcx,	%rbx
    call      mc_genss.setopsize
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       %rdi,	%rax
    call      mc_genss.genrex
    mov       %rax,	144
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    jmp       L4030
L4032:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L4039
    mov       %rax,	%rbx
    mov       %r10,	%rsi
    mov       %rsi,	%rax
    mov       %rbx,	%r10
L4039:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4042
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4041
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4041
L4042:
    lea       %rcx,	[%rip+L10821]
    call      mc_libmcl.axerror
L4041:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    jnz       L4044
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L4044
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    lea       %r10,	[%rsi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
L4044:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%rsi+8]
    and       %r10,	31
    cmp       %rax,	%r10
    jz        L4046
    lea       %rcx,	[%rip+L10822]
    call      mc_libmcl.axerror
L4046:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L4048
    mov       %rax,	134
    jmp       L4047
L4048:
    mov       %rax,	135
L4047:
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_genss.genrrm
L4030:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_movsxd
mc_genss.do_movsxd:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L4051
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    jnz       L4051
    lea       %rax,	[%rbx+8]
    mov       %r10w,	4
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L4051:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L4054
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jle       L4053
L4054:
    lea       %rcx,	[%rip+L10823]
    call      mc_libmcl.axerror
L4053:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4057
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4056
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4056
L4057:
    lea       %rcx,	[%rip+L10824]
    call      mc_libmcl.axerror
L4056:
    mov       %rcx,	99
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_imul2
mc_genss.do_imul2:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4060
    lea       %rcx,	[%rip+L10825]
    call      mc_libmcl.axerror
L4060:
    movzx     %rax,	word ptr[%r13+8]
    and       %rax,	31
    jnz       L4062
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    lea       %r10,	[%r13+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
L4062:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L4064
    lea       %rcx,	[%rip+L10826]
    call      mc_libmcl.axerror
L4064:
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4066
    cmp       %rax,	3
    jz        L4066
    cmp       %rax,	2
    jz        L4067
    jmp       L4068
L4066:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%r13+8]
    and       %r10,	31
    cmp       %rax,	%r10
    jz        L4070
    lea       %rcx,	[%rip+L10827]
    call      mc_libmcl.axerror
L4070:
    mov       %rcx,	4015
    mov       %rdx,	%r12
    mov       %r8,	%r13
    call      mc_genss.genrrm
    jmp       L4065
L4067:
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      mc_genss.getdef
    test      %rax,	%rax
    jz        L4072
    lea       %rcx,	[%rip+L10828]
    call      mc_libmcl.axerror
L4072:
    mov       %rsi,	[%r13]
    mov       %rax,	%rsi
    cmp       %rax,	-128
    jl        L4074
    cmp       %rax,	127
    jg        L4074
    mov       %rdi,	107
    jmp       L4073
L4074:
    mov       %rdi,	105
L4073:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    mov       %r8,	%r12
    call      mc_genss.genrrm
    mov       %rax,	%rsi
    cmp       %rax,	-128
    jl        L4076
    cmp       %rax,	127
    jg        L4076
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%sil
    mov       %rbx,	1
    jmp       L4075
L4076:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	2
    jnz       L4077
    mov       %rcx,	%rsi
    call      mc_genss.genword
    mov       %rbx,	2
    jmp       L4075
L4077:
    mov       %rcx,	%rsi
    call      mc_genss.gendword
    mov       %rbx,	4
L4075:
    mov       %rcx,	%rbx
    call      mc_genss.fixrip
    jmp       L4065
L4068:
    lea       %rcx,	[%rip+L10829]
    call      mc_libmcl.axerror
L4065:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_shift
mc_genss.do_shift:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4080
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4080
    lea       %rcx,	[%rip+L10830]
    call      mc_libmcl.axerror
L4080:
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      mc_genss.getdef
    test      %rax,	%rax
    jz        L4082
    lea       %rcx,	[%rip+L10831]
    call      mc_libmcl.axerror
L4082:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L4084
    xor       %eax,	%eax
    jmp       L4083
L4084:
    mov       %rax,	1
L4083:
    mov       %rdi,	%rax
    xor       %rsi,	%rsi
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jz        L4086
    cmp       %rax,	1
    jz        L4087
    jmp       L4088
L4086:
    mov       %rax,	[%r13]
    cmp       %rax,	1
    jnz       L4090
    mov       %rax,	208
    add       %rax,	%rdi
    mov       %rbx,	%rax
    jmp       L4089
L4090:
    mov       %rax,	192
    add       %rax,	%rdi
    mov       %rbx,	%rax
    mov       %rsi,	1
L4089:
    jmp       L4085
L4087:
    movzx     %rax,	byte ptr[%r13+10]
    cmp       %rax,	11
    jnz       L4093
    movzx     %rax,	word ptr[%r13+8]
    and       %rax,	31
    cmp       %rax,	1
    jz        L4092
L4093:
    lea       %rcx,	[%rip+L10832]
    call      mc_libmcl.axerror
L4092:
    mov       %rax,	210
    add       %rax,	%rdi
    mov       %rbx,	%rax
    jmp       L4085
L4088:
    lea       %rcx,	[%rip+L10833]
    call      mc_libmcl.axerror
L4085:
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    mov       %r8,	%r12
    call      mc_genss.genxrm
    test      %rsi,	%rsi
    jz        L4095
    mov       %rax,	[%r13]
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
    mov       %rcx,	1
    call      mc_genss.fixrip
L4095:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_test
mc_genss.do_test:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4098
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	1
    jnz       L4098
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L4098
    mov       %rdi,	[%rsi]
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jz        L4100
    cmp       %rax,	2
    jz        L4101
    cmp       %rax,	4
    jz        L4102
    jmp       L4103
L4100:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	168
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%dil
    jmp       L4099
L4101:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	102
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	169
    mov       [%r10],	%al
    mov       %rcx,	%rdi
    call      mc_genss.genword
    jmp       L4099
L4102:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	169
    mov       [%r10],	%al
    mov       %rcx,	%rdi
    call      mc_genss.gendword
    jmp       L4099
L4103:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	72
    mov       [%r10],	%al
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	169
    mov       [%r10],	%al
    mov       %rcx,	%rdi
    call      mc_genss.gendword
L4099:
    jmp       L4097
L4098:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4105
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L4104
L4105:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L4104
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L4107
    mov       %rax,	246
    jmp       L4106
L4107:
    mov       %rax,	247
L4106:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      mc_genss.genxrm
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jz        L4109
    cmp       %rax,	2
    jz        L4110
    jmp       L4111
L4109:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%dil
    jmp       L4108
L4110:
    mov       %rcx,	%rdi
    call      mc_genss.genword
    jmp       L4108
L4111:
    mov       %rcx,	%rdi
    call      mc_genss.gendword
L4108:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    mov       %rcx,	%rax
    call      mc_genss.fixrip
    jmp       L4097
L4104:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4113
    cmp       %rax,	3
    jnz       L4112
L4113:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4112
#mc_genss.do_test.domemreg:
L4114:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jnz       L4116
    mov       %rax,	132
    jmp       L4115
L4116:
    mov       %rax,	133
L4115:
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_genss.genrrm
    jmp       L4097
L4112:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4117
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L4117
    mov       %rax,	%rbx
    mov       %r10,	%rsi
    mov       %rsi,	%rax
    mov       %rbx,	%r10
    jmp       L4114
L4117:
    lea       %rcx,	[%rip+L10834]
    call      mc_libmcl.axerror
L4097:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_setcc
mc_genss.do_setcc:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4122
    cmp       %rax,	3
    jnz       L4121
L4122:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	1
    jle       L4120
L4121:
    lea       %rcx,	[%rip+L10835]
    call      mc_libmcl.axerror
L4120:
    mov       %rax,	3984
    add       %rax,	%rdi
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      mc_genss.genxrm
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.checksize
mc_genss.checksize:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    jnz       L4125
    lea       %rcx,	[%rip+L10836]
    call      mc_libmcl.axerror
L4125:
    test      %rbx,	%rbx
    jz        L4127
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	%rbx
    jz        L4127
    cmp       %rax,	%rsi
    jz        L4127
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10837]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10838]
    call      mc_libmcl.axerror
L4127:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_arithxmm
mc_genss.do_arithxmm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L4131
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L4130
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4130
L4131:
    lea       %rcx,	[%rip+L10839]
    call      mc_libmcl.axerror
L4130:
    test      %rsi,	%rsi
    jz        L4133
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%sil
L4133:
    mov       %rax,	3840
    add       %rax,	%r12
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_logicxmm
mc_genss.do_logicxmm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L4137
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L4136
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4136
L4137:
    lea       %rcx,	[%rip+L10840]
    call      mc_libmcl.axerror
L4136:
    cmp       %r12,	8
    jnz       L4139
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	102
    mov       [%r10],	%al
L4139:
    mov       %rax,	3840
    add       %rax,	%rsi
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_convertfloat
mc_genss.do_convertfloat:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L4143
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L4142
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4142
L4143:
    lea       %rcx,	[%rip+L10841]
    call      mc_libmcl.axerror
L4142:
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%sil
    mov       %al,	1
    mov       [%rip+mc_genss.nowmask],	%al
    mov       %rcx,	3930
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_fix
mc_genss.do_fix:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4147
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L4146
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4146
L4147:
    lea       %rcx,	[%rip+L10842]
    call      mc_libmcl.axerror
L4146:
    mov       %rcx,	%rdi
    mov       %rdx,	4
    mov       %r8,	8
    call      mc_genss.checksize
    cmp       %rsi,	243
    jnz       L4149
    mov       %rax,	4
    jmp       L4148
L4149:
    mov       %rax,	8
L4148:
    lea       %r10,	[%rbx+8]
    mov       %r15w,	[%r10]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%ax
    mov       [%r10],	%r15w
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%sil
    mov       %rax,	3840
    add       %rax,	%r12
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_float
mc_genss.do_float:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L4153
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4152
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L4152
L4153:
    lea       %rcx,	[%rip+L10843]
    call      mc_libmcl.axerror
L4152:
    mov       %rcx,	%rbx
    mov       %rdx,	4
    mov       %r8,	8
    call      mc_genss.checksize
    cmp       %rsi,	243
    jnz       L4155
    mov       %rax,	4
    jmp       L4154
L4155:
    mov       %rax,	8
L4154:
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%sil
    mov       %al,	1
    mov       [%rip+mc_genss.usesizeb],	%al
    mov       %rcx,	3882
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_movxmm
mc_genss.do_movxmm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4158
    cmp       %rax,	5
    jz        L4159
    cmp       %rax,	3
    jz        L4160
    jmp       L4161
L4158:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L4164
L4163:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	%rsi
    jz        L4166
    lea       %rcx,	[%rip+L10844]
    call      mc_libmcl.axerror
L4166:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    lea       %r10,	[%rbx+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %al,	1
    mov       [%rip+mc_genss.sizeoverride],	%al
    mov       %rcx,	3966
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_genss.genrrm
    jmp       L4162
L4164:
    lea       %rcx,	[%rip+L10845]
    call      mc_libmcl.axerror
L4162:
    jmp       L4157
L4159:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4168
    cmp       %rax,	5
    jz        L4169
    cmp       %rax,	3
    jz        L4170
    jmp       L4171
L4168:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	%rsi
    jz        L4173
    lea       %rcx,	[%rip+L10846]
    call      mc_libmcl.axerror
L4173:
    mov       %al,	1
    mov       [%rip+mc_genss.sizeoverride],	%al
    mov       %rcx,	3950
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
    jmp       L4167
L4169:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %al,	1
    mov       [%rip+mc_genss.f3override],	%al
    mov       %rcx,	3966
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
    jmp       L4167
L4170:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    jnz       L4175
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    lea       %r10,	[%rbx+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
L4175:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	%rsi
    jz        L4177
    lea       %rcx,	[%rip+L10847]
    call      mc_libmcl.axerror
L4177:
    cmp       %rsi,	4
    jnz       L4179
    mov       %al,	1
    mov       [%rip+mc_genss.sizeoverride],	%al
    mov       %al,	1
    mov       [%rip+mc_genss.nowmask],	%al
    mov       %rcx,	3950
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
    jmp       L4178
L4179:
    mov       %al,	1
    mov       [%rip+mc_genss.f3override],	%al
    mov       %al,	1
    mov       [%rip+mc_genss.nowmask],	%al
    mov       %rcx,	3966
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
L4178:
    jmp       L4167
L4171:
    lea       %rcx,	[%rip+L10848]
    call      mc_libmcl.axerror
L4167:
    jmp       L4157
L4160:
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L4182
L4181:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    jz        L4184
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	%rsi
    jz        L4184
    lea       %rcx,	[%rip+L10849]
    call      mc_libmcl.axerror
L4184:
    mov       %al,	1
    mov       [%rip+mc_genss.sizeoverride],	%al
    cmp       %rsi,	4
    jnz       L4186
    mov       %rax,	3966
    jmp       L4185
L4186:
    mov       %rax,	4054
L4185:
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_genss.genrrm
    jmp       L4180
L4182:
    lea       %rcx,	[%rip+L10850]
    call      mc_libmcl.axerror
L4180:
    jmp       L4157
L4161:
    lea       %rcx,	[%rip+L10851]
    call      mc_libmcl.axerror
L4157:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.fixrip
mc_genss.fixrip:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_genss.ripentry]
    test      %rax,	%rax
    jz        L4187
L4189:
    mov       %rax,	%rdi
    test      %rax,	%rax
    jz        L4191
    cmp       %rax,	1
    jz        L4192
    cmp       %rax,	2
    jz        L4192
    cmp       %rax,	4
    jz        L4192
    jmp       L4193
L4191:
    jmp       L4187
L4192:
    jmp       L4190
L4193:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10852]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10853]
    call      mc_libmcl.axerror
L4190:
    mov       %eax,	%edi
    mov       %r10,	[%rip+mc_genss.ripentry]
    mov       [%r10+12],	%eax
L4187:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_bswap
mc_genss.do_bswap:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4197
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jge       L4196
L4197:
    lea       %rcx,	[%rip+L10854]
    call      mc_libmcl.axerror
L4196:
    mov       %rcx,	%rbx
    call      mc_genss.setopsize
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      mc_genss.getregcode
    mov       %rdi,	%rax
    call      mc_genss.genrex
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       %al,	15
    mov       [%r10],	%al
    mov       %rax,	200
    add       %rax,	%rdi
    mov       %r10,	[%rip+mc_genss.currdata]
    lea       %r10,	[%r10+8]
    mov       %r11,	[%r10]
    inc       qword ptr[%r10]
    mov       [%r11],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_movdqx
mc_genss.do_movdqx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rax,	%rsi
    shl       %rax,	16
    add       %rax,	3840
    mov       %rsi,	%rax
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    jnz       L4200
    lea       %rax,	[%rdi+8]
    mov       %r10w,	16
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L4200:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    jnz       L4202
    lea       %rax,	[%rbx+8]
    mov       %r10w,	16
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L4202:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L4204
    lea       %rax,	[%rsi+127]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_genss.genrrm
    jmp       L4203
L4204:
    lea       %rax,	[%rsi+111]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_genss.genrrm
L4203:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genss.do_dshift
mc_genss.do_dshift:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    jnz       L4207
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    lea       %r10,	[%rdi+8]
    mov       %r15w,	[%r10]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%ax
    mov       [%r10],	%r15w
L4207:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    movzx     %r10,	word ptr[%rbx+8]
    and       %r10,	31
    cmp       %rax,	%r10
    jnz       L4210
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	1
    jg        L4209
L4210:
    lea       %rcx,	[%rip+L10855]
    call      mc_libmcl.axerror
L4209:
    xor       %eax,	%eax
    mov       [%rip+mc_genss.sizeoverride],	%al
    mov       %rax,	3840
    add       %rax,	%r12
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_genss.genrrm
    mov       %rax,	[%rip+mc_genss.currdata]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%sil
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_decls.start
mc_decls.start:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    xor       %rbx,	%rbx
    mov       %rax,	13
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jl        L4214
L4212:
    mov       %al,	10
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       %r11,	%rbx
    mov       [%r10 + %r11],	%al
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L4212
L4214:
    mov       %al,	19
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+5],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+4],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+3],	%al
    mov       %al,	18
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+9],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+8],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+7],	%al
    mov       %al,	16
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+1],	%al
    mov       %al,	17
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+2],	%al
    mov       %al,	11
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+10],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+6],	%al
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.writemcl
mc_writeasm.writemcl:
#?>>
    .set mc_writeasm.writemcl.index, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rdi+33]
    cmp       %rax,	3
    jnz       L4217
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	63
    jz        L4216
L4217:
    mov       %rcx,	%rdi
    call      mc_writeasm.strmcl
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_line
L4216:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.strmcl
mc_writeasm.strmcl:
#?>>
    .set mc_writeasm.strmcl.mcl, 64
    .set mc_writeasm.strmcl.opcname, -128
    .set mc_writeasm.strmcl.d, -136
    .set mc_writeasm.strmcl.first, -144
    .set mc_writeasm.strmcl.r, -152
    .set mc_writeasm.strmcl.$T1, -160
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	192
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_writeasm.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+33]
    mov       %rsi,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_writeasm.strmcl.str]
    mov       [%r10],	%al
    mov       %rax,	[%rbp + mc_writeasm.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mc_writeasm.strmcl.mcl]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rbp + mc_writeasm.strmcl.mcl]
    mov       %rbx,	[%rax+24]
    xor       %r14,	%r14
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L4220
    cmp       %rax,	2
    jz        L4221
    cmp       %rax,	3
    jz        L4222
    cmp       %rax,	8
    jz        L4223
    cmp       %rax,	4
    jz        L4224
    cmp       %rax,	9
    jz        L4225
    cmp       %rax,	5
    jz        L4226
    cmp       %rax,	6
    jz        L4227
    jmp       L4228
L4220:
    lea       %rcx,	[%rip+L10856]
    call      mc_writeasm.asmstr
    mov       %rax,	[%rdi]
    mov       %rcx,	[%rax]
    call      mc_writeasm.asmstr
    mov       %rax,	[%rdi]
    mov       [%rip+mc_decls.currasmproc],	%rax
    lea       %rax,	[%rip+mc_writeasm.regvars]
    xor       %r10d,	%r10d
    mov       %r11,	4
L10857:
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    add       %rax,	32
    dec       %r11
    jnz       L10857
    lea       %rax,	[%rip+mc_writeasm.xregvars]
    xor       %r10d,	%r10d
    mov       %r11,	4
L10858:
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    add       %rax,	32
    dec       %r11
    jnz       L10858
    jmp       L4218
L4221:
    lea       %rcx,	[%rip+L10859]
    call      mc_writeasm.asmstr
    xor       %eax,	%eax
    mov       [%rip+mc_decls.currasmproc],	%rax
    jmp       L4218
L4222:
    mov       %rcx,	59
    call      mc_writeasm.asmchar
    mov       %rcx,	[%rdi]
    call      mc_writeasm.asmstr
    jmp       L4218
L4223:
    jmp       L4218
L4224:
    mov       %rax,	[%rdi]
    mov       [%rbp + mc_writeasm.strmcl.d],	%rax
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L4230
    cmp       %rax,	4
    jz        L4231
    jmp       L4232
L4230:
    mov       %rcx,	[%rbp + mc_writeasm.strmcl.d]
    call      mc_writeasm.getdispname
    mov       %rcx,	%rax
    call      mc_writeasm.asmstr
    jmp       L4229
L4231:
    mov       %rcx,	[%rdi]
    call      mc_writeasm.asmstr
    jmp       L4218
L4232:
    lea       %rcx,	[%rip+L10860]
    lea       %rdx,	[%rip+L10861]
    call      pc_api.merror
L4229:
    lea       %rcx,	[%rip+L10862]
    call      mc_writeasm.asmstr
    mov       %rax,	[%rbp + mc_writeasm.strmcl.d]
    mov       %al,	[%rax+81]
    test      %al,	%al
    jz        L4234
    mov       %rax,	[%rbp + mc_writeasm.strmcl.d]
    mov       %rax,	[%rax]
    mov       [%rbp + mc_writeasm.strmcl.$T1],	%rax
    mov       %rax,	[%rbp + mc_writeasm.strmcl.d]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_writeasm.strmcl.$T1]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4236
    lea       %rcx,	[%rip+L10862]
    call      mc_writeasm.asmstr
    jmp       L4235
L4236:
    lea       %rcx,	[%rip+L10863]
    call      mc_writeasm.asmstr
    mov       %rax,	[%rbp + mc_writeasm.strmcl.d]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    call      mc_writeasm.asmstr
    lea       %rcx,	[%rip+L10864]
    call      mc_writeasm.asmstr
L4235:
L4234:
    jmp       L4218
L4225:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	6
    jnz       L4238
    lea       %rcx,	[%rip+mc_writeasm.strmcl.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10865]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rdi]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L4237
L4238:
    jmp       L4224
L4237:
    lea       %rcx,	[%rip+mc_writeasm.strmcl.str]
    call      mc_writeasm.asmstr
    jmp       L4218
L4226:
    lea       %rcx,	[%rip+L10866]
    call      mc_writeasm.asmstr
    mov       %rcx,	[%rdi]
    call      mc_writeasm.asmstr
    lea       %rcx,	[%rip+L10867]
    call      mc_writeasm.asmstr
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_writeasm.asmopnd
    jmp       L4218
L4227:
    mov       %rax,	[%rdi]
    mov       [%rbp + mc_writeasm.strmcl.d],	%rax
    lea       %rcx,	[%rip+L10868]
    call      mc_writeasm.asmstr
    mov       %rcx,	[%rbp + mc_writeasm.strmcl.d]
    call      mc_writeasm.getdispname
    mov       %rcx,	%rax
    call      mc_writeasm.asmstr
    mov       %rax,	[%rbp + mc_writeasm.strmcl.d]
    movzx     %rax,	byte ptr[%rax+82]
    cmp       %rax,	2
    jg        L4240
    mov       %rax,	[%rbp + mc_writeasm.strmcl.d]
    movzx     %rax,	byte ptr[%rax+90]
    mov       %r10,	[%rbp + mc_writeasm.strmcl.d]
    lea       %r11,	[%rip+mc_writeasm.xregvars]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L4239
L4240:
    mov       %rax,	[%rbp + mc_writeasm.strmcl.d]
    movzx     %rax,	byte ptr[%rax+90]
    mov       %r10,	[%rbp + mc_writeasm.strmcl.d]
    lea       %r11,	[%rip+mc_writeasm.regvars]
    mov       [%r11 + %rax*8-8],	%r10
L4239:
    lea       %rcx,	[%rip+L10869]
    call      mc_writeasm.asmstr
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L4243
L4242:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writeasm.getregname
    mov       %rcx,	%rax
    call      mc_writeasm.asmstr
    jmp       L4241
L4243:
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writeasm.getxregname
    mov       %rcx,	%rax
    call      mc_writeasm.asmstr
L4241:
    jmp       L4218
L4228:
L4219:
    mov       %rax,	%rsi
    cmp       %rax,	26
    jz        L4245
    cmp       %rax,	58
    jz        L4246
    cmp       %rax,	15
    jz        L4247
    cmp       %rax,	38
    jz        L4248
    cmp       %rax,	39
    jz        L4249
    cmp       %rax,	40
    jz        L4250
    cmp       %rax,	51
    jz        L4251
    cmp       %rax,	120
    jz        L4252
    jmp       L4253
L4245:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10870]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4244
L4246:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10871]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4244
L4247:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10872]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4244
L4248:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    lea       %rdx,	[%rip+L10873]
    call      strcpy
    jmp       L4244
L4249:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    lea       %rdx,	[%rip+L10874]
    call      strcpy
    jmp       L4244
L4250:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    lea       %rdx,	[%rip+L10875]
    call      strcpy
    jmp       L4244
L4251:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    lea       %rdx,	[%rip+L10876]
    call      strcpy
    jmp       L4244
L4252:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    lea       %rdx,	[%rip+L10877]
    call      strcpy
    jmp       L4244
L4253:
    cmp       %rsi,	152
    jle       L4255
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L4254
L4255:
    lea       %rax,	[%rip+mc_decls.mclnames]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rax,	[%rax+2]
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    mov       %rdx,	%rax
    call      strcpy
L4254:
L4244:
    cmp       %rsi,	119
    jnz       L4257
    mov       %rax,	4
    jmp       L4256
L4257:
    mov       %rax,	10
L4256:
    lea       %rcx,	[%rbp + mc_writeasm.strmcl.opcname]
    mov       %rdx,	%rax
    lea       %r8,	[%rip+L10878]
    call      mlib.ipadstr
    lea       %rcx,	[%rip+mc_writeasm.strmcl.str]
    mov       %rdx,	4
    lea       %r8,	[%rip+L10878]
    call      mlib.ipadstr
    lea       %rcx,	[%rip+mc_writeasm.strmcl.str]
    lea       %rdx,	[%rbp + mc_writeasm.strmcl.opcname]
    call      strcat
    lea       %rcx,	[%rip+mc_writeasm.strmcl.str]
    call      mc_writeasm.asmstr
    test      %rdi,	%rdi
    jz        L4259
    test      %rbx,	%rbx
    jz        L4259
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_writeasm.needsizeprefix
    mov       %r13,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_writeasm.asmopnd
    lea       %rcx,	[%rip+L10879]
    call      mc_writeasm.asmstr
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_writeasm.asmopnd
    mov       %rax,	[%rbp + mc_writeasm.strmcl.mcl]
    mov       %al,	[%rax+32]
    test      %al,	%al
    jz        L4261
    lea       %rcx,	[%rip+L10880]
    call      mc_writeasm.asmstr
    mov       %rax,	[%rbp + mc_writeasm.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+32]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rax
    call      mc_writeasm.asmstr
L4261:
    jmp       L4258
L4259:
    test      %rdi,	%rdi
    jz        L4262
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    jz        L4262
    cmp       %rsi,	21
    jnz       L4264
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rsi
    call      mc_writeasm.asmopnd
    jmp       L4263
L4264:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    mov       %r8,	%rsi
    call      mc_writeasm.asmopnd
L4263:
L4262:
L4258:
L4218:
#---------------
    add       %rsp,	192
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.strmclstr
mc_writeasm.strmclstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_init
    mov       %rcx,	%rdi
    call      mc_writeasm.strmcl
    mov       %rax,	[%rip+pc_decls.pdest]
    mov       %rax,	[%rax]
L4265:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.mstropnd
mc_writeasm.mstropnd:
#?>>
    .set mc_writeasm.mstropnd.str2, -128
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	168
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_writeasm.mstropnd.str]
    mov       [%r10],	%al
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4268
    cmp       %rax,	2
    jz        L4269
    cmp       %rax,	3
    jz        L4270
    cmp       %rax,	5
    jz        L4271
    jmp       L4272
L4268:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writeasm.strreg
    jmp       L4266
L4269:
    cmp       %r13,	119
    jnz       L4274
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L4274
    mov       %rax,	[%rsi]
    cmp       %rax,	0
    jl        L4276
    cmp       %rax,	9
    jg        L4276
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L4275
L4276:
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    lea       %rdx,	[%rip+L10881]
    call      strcat
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10882]
    call      msys.strword
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
L4275:
    jmp       L4273
L4274:
    mov       %rcx,	%rsi
    call      mc_writeasm.strvalue
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rax
    call      strcpy
L4273:
    jmp       L4267
L4270:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      mc_writeasm.getsizeprefix
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    lea       %rdx,	[%rip+L10883]
    call      strcat
    lea       %rax,	[%rip+L10884]
    mov       %rdi,	%rax
    mov       %al,	[%rsi+10]
    test      %al,	%al
    jz        L4278
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_writeasm.strreg
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+L10885]
    mov       %rdi,	%rax
L4278:
    mov       %al,	[%rsi+11]
    test      %al,	%al
    jz        L4280
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rdi
    call      strcat
    movzx     %rax,	byte ptr[%rsi+11]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_writeasm.strreg
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+L10885]
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	5
    and       %rax,	15
    cmp       %rax,	1
    jle       L4282
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    lea       %rdx,	[%rip+L10886]
    call      strcat
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	5
    and       %rax,	15
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
L4282:
L4280:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L4285
    cmp       %rax,	6
    jz        L4285
    cmp       %rax,	8
    jnz       L4284
L4285:
    mov       %al,	[%rdi]
    test      %al,	%al
    jz        L4287
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rdi
    call      strcat
L4287:
    mov       %rcx,	%rsi
    call      mc_writeasm.strvalue
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L4283
L4284:
    movsxd    %rax,	dword ptr[%rsi+12]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L4288
    lea       %rcx,	[%rbp + mc_writeasm.mstropnd.str2]
    call      msys.m$print_startstr
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L10887]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    lea       %rdx,	[%rbp + mc_writeasm.mstropnd.str2]
    call      strcat
L4288:
L4283:
    lea       %rcx,	[%rip+mc_writeasm.mstropnd.str]
    lea       %rdx,	[%rip+L10888]
    call      strcat
    jmp       L4267
L4271:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writeasm.strxreg
    jmp       L4266
L4272:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10889]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+L10890]
    jmp       L4266
L4267:
    lea       %rax,	[%rip+mc_writeasm.mstropnd.str]
L4266:
#---------------
    add       %rsp,	168
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.strvalue
mc_writeasm.strvalue:
#?>>
    .set mc_writeasm.strvalue.str2, -128
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	160
    mov       %r12,	%rcx
#---------------
    mov       %rdi,	[%r12]
    mov       %rbx,	[%r12]
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    lea       %rdx,	[%rip+L10891]
    call      strcpy
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L4291
    cmp       %rax,	1
    jz        L4292
    cmp       %rax,	2
    jz        L4293
    cmp       %rax,	3
    jz        L4294
    cmp       %rax,	4
    jz        L4295
    cmp       %rax,	7
    jz        L4296
    cmp       %rax,	6
    jz        L4297
    cmp       %rax,	8
    jz        L4298
    jmp       L4299
L4291:
    mov       %rcx,	%rdi
    call      mc_writeasm.getdispname
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
#mc_writeasm.strvalue.addoffset:
L4300:
    movsxd    %rax,	dword ptr[%r12+12]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4302
    lea       %rcx,	[%rbp + mc_writeasm.strvalue.str2]
    call      msys.m$print_startstr
    cmp       %rsi,	0
    jle       L4304
    lea       %rax,	[%rip+L10892]
    jmp       L4303
L4304:
    lea       %rax,	[%rip+L10893]
L4303:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    lea       %rdx,	[%rbp + mc_writeasm.strvalue.str2]
    call      strcat
L4302:
    jmp       L4290
L4292:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L4290
L4293:
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    call      msys.m$print_startstr
    movq      %XMM4,	[%r12]
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L10894]
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L4290
L4294:
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    lea       %rdx,	[%rip+L10895]
    call      strcat
    movq      %XMM4,	[%r12]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.strreal
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L4290
L4295:
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    lea       %rdx,	[%rip+L10896]
    call      strcat
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    lea       %rdx,	[%rip+L10896]
    call      strcat
    jmp       L4290
L4296:
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L4290
L4297:
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    lea       %rdx,	[%rip+L10897]
    call      strcat
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writeasm.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L4300
L4298:
    mov       %rax,	[%r12]
    mov       %rcx,	[%rip+mc_decls.currasmproc]
    mov       %rdx,	%rax
    call      mc_writeasm.gettempname
    jmp       L4289
L4299:
    lea       %rcx,	[%rip+L10898]
    lea       %rdx,	[%rip+L10899]
    call      pc_api.merror
L4290:
    lea       %rax,	[%rip+mc_writeasm.strvalue.str]
L4289:
#---------------
    add       %rsp,	160
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.asmopnd
mc_writeasm.asmopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_writeasm.mstropnd
    mov       %rcx,	%rax
    call      mc_writeasm.asmstr
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.getregname
mc_writeasm.getregname:
#?>>
    .set mc_writeasm.getregname.str2, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rbx,	%r12
    cmp       %rbx,	16
    jle       L4308
    mov       %rbx,	17
L4308:
    mov       %rax,	%rsi
    test      %rax,	%rax
    jz        L4310
    cmp       %rax,	15
    jz        L4311
    cmp       %rax,	16
    jz        L4312
    jmp       L4313
L4310:
    lea       %rax,	[%rip+L10900]
    jmp       L4306
L4311:
    lea       %rax,	[%rip+L10901]
    mov       %rdi,	%rax
    jmp       L4309
L4312:
    lea       %rax,	[%rip+L10902]
    mov       %rdi,	%rax
    jmp       L4309
L4313:
    lea       %rax,	[%rsi-1]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + mc_writeasm.getregname.str2]
    call      msys.getstrint
    lea       %rax,	[%rbp + mc_writeasm.getregname.str2]
    mov       %rdi,	%rax
L4309:
    lea       %rcx,	[%rip+mc_writeasm.getregname.str]
    call      msys.m$print_startstr
    lea       %rax,	[%rip+mc_writeasm.getregname.prefix]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+mc_writeasm.getregname.str]
L4306:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.getxregname
mc_writeasm.getxregname:
#?>>
    .set mc_writeasm.getxregname.size, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jnz       L4316
    lea       %rax,	[%rip+L10903]
    jmp       L4314
L4316:
    lea       %rcx,	[%rip+mc_writeasm.getxregname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10904]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rdi-1]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+mc_writeasm.getxregname.str]
L4314:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.asmstr
mc_writeasm.asmstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.asmchar
mc_writeasm.asmchar:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    mov       %rdx,	%rdi
    call      mlib.gs_char
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.getdispname
mc_writeasm.getdispname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jz        L4321
    lea       %rcx,	[%rip+mc_writeasm.getdispname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10905]
    call      msys.m$print_setfmt
    mov       %al,	[%rip+pc_api.fpshortnames]
    test      %al,	%al
    jz        L4323
    lea       %rax,	[%rip+L10906]
    jmp       L4322
L4323:
    lea       %rax,	[%rip+L10907]
L4322:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L4325
    lea       %rax,	[%rip+L10908]
    jmp       L4324
L4325:
    lea       %rax,	[%rip+L10909]
L4324:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %al,	[%rip+pc_api.fpshortnames]
    test      %al,	%al
    jz        L4327
    mov       %rax,	[%rdi]
    jmp       L4326
L4327:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      pc_api.getfullname
L4326:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+mc_writeasm.getdispname.str]
    jmp       L4319
L4321:
    mov       %al,	[%rip+pc_api.fpshortnames]
    test      %al,	%al
    jz        L4329
    mov       %rax,	[%rdi]
    jmp       L4328
L4329:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      pc_api.getfullname
L4328:
L4319:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.gettempname
mc_writeasm.gettempname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rip+pc_api.fpshortnames]
    test      %al,	%al
    jnz       L4333
    test      %rdi,	%rdi
    jnz       L4332
L4333:
    lea       %rcx,	[%rip+mc_writeasm.gettempname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10910]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L4331
L4332:
    lea       %rcx,	[%rip+mc_writeasm.gettempname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L10911]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      mc_writeasm.getdispname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L4331:
    lea       %rax,	[%rip+mc_writeasm.gettempname.str]
L4330:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.strreg
mc_writeasm.strreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+mc_writeasm.regvars]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8-8]
    test      %rdi,	%rdi
    jz        L4336
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	%rsi
    jnz       L4336
    mov       %rcx,	%rdi
    call      mc_writeasm.getdispname
    jmp       L4334
L4336:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_writeasm.getregname
L4334:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.strxreg
mc_writeasm.strxreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+mc_writeasm.xregvars]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8-8]
    cmp       %rsi,	8
    jnz       L4339
    test      %rdi,	%rdi
    jz        L4339
    mov       %rcx,	%rdi
    call      mc_writeasm.getdispname
    jmp       L4338
L4339:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_writeasm.getxregname
L4338:
L4337:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.getassemstr
mc_writeasm.getassemstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_init
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	1
    jz        L4342
    cmp       %rax,	2
    jz        L4343
    jmp       L4344
L4342:
    lea       %rcx,	[%rip+L10912]
    call      mc_writeasm.asmstr
    jmp       L4341
L4343:
    lea       %rcx,	[%rip+L10913]
    call      mc_writeasm.asmstr
L4344:
L4341:
    mov       %rdi,	[%rip+mc_decls.mccode]
    mov       %rbx,	1
    jmp       L4346
L4345:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    call      mc_writeasm.writemcl
    inc       %rbx
    mov       %rdi,	[%rdi+8]
L4346:
    test      %rdi,	%rdi
    jnz       L4345
    mov       %rax,	[%rip+pc_decls.pdest]
L4340:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeasm.needsizeprefix
mc_writeasm.needsizeprefix:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	18
    jz        L4350
    cmp       %rax,	19
    jz        L4350
    cmp       %rax,	86
    jz        L4350
    cmp       %rax,	87
    jz        L4350
    cmp       %rax,	82
    jz        L4351
    cmp       %rax,	83
    jz        L4351
    cmp       %rax,	84
    jz        L4351
    cmp       %rax,	85
    jz        L4351
    cmp       %rax,	43
    jz        L4352
    cmp       %rax,	45
    jz        L4352
    cmp       %rax,	44
    jz        L4352
    jmp       L4353
L4350:
    mov       %rax,	1
    jmp       L4348
L4351:
    mov       %rax,	1
    jmp       L4348
L4352:
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L4355
    mov       %rax,	1
    jmp       L4348
L4355:
    xor       %eax,	%eax
    jmp       L4348
L4353:
L4349:
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4358
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L4358
    movzx     %rax,	word ptr[%r8+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L4358
    movzx     %rax,	word ptr[%r8+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L4357
L4358:
    xor       %eax,	%eax
    jmp       L4348
L4357:
    mov       %rax,	1
L4348:
#---------------
    ret       
# End 
# Proc mc_writeasm.getsizeprefix
mc_writeasm.getsizeprefix:
#?>>
#?]]
#---------------
    test      %rdx,	%rdx
    jnz       L4361
    lea       %rax,	[%rip+L10914]
    jmp       L4359
L4361:
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L4363
    cmp       %rax,	2
    jz        L4364
    cmp       %rax,	4
    jz        L4365
    cmp       %rax,	8
    jz        L4366
    jmp       L4367
L4363:
    lea       %rax,	[%rip+L10915]
    jmp       L4359
L4364:
    lea       %rax,	[%rip+L10916]
    jmp       L4359
L4365:
    lea       %rax,	[%rip+L10917]
    jmp       L4359
L4366:
    lea       %rax,	[%rip+L10918]
    jmp       L4359
L4367:
L4362:
    lea       %rax,	[%rip+L10919]
L4359:
#---------------
    ret       
# End 
# Proc mc_writeasm.start
mc_writeasm.start:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	16705
    mov       [%rip+pc_decls.assemtype],	%rax
#---------------
    add       %rsp,	16
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.writeexe
mc_writeexe.writeexe:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %al,	[%rip+pc_decls.exedone]
    test      %al,	%al
    jnz       L4369
L4371:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_writeexe.genexe1
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_writeexe.genexe2
    mov       %al,	1
    mov       [%rip+pc_decls.exedone],	%al
L4369:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.genexe1
mc_writeexe.genexe1:
#?>>
    .set mc_writeexe.genexe1.dodll, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
#---------------
    call      mc_writeexe.initsectiontable
    mov       %rcx,	%r14
    call      mlib.extractfile
    mov       [%rip+mc_writeexe.dllfilename],	%rax
    mov       %rax,	[%rbp + mc_writeexe.genexe1.dodll]
    mov       [%rip+mc_writeexe.isdll],	%rax
    mov       %rax,	[%rip+mc_writeexe.isdll]
    test      %rax,	%rax
    jz        L4374
    mov       %rax,	268435456
    jmp       L4373
L4374:
    mov       %rax,	4194304
L4373:
    mov       [%rip+mc_writeexe.imagebase],	%rax
    mov       [%rip+mc_writeexe.userentrypoint],	%r13
    call      mc_writeexe.loadlibs
    call      mc_writeexe.scanst
    call      mc_writeexe.getoffsets
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rcx,	%rax
    call      mc_writeexe.relocdata
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      mc_writeexe.relocdata
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       %rbx,	%rax
    mov       %al,	[%rip+pc_api.phighmem]
    test      %al,	%al
    jz        L4376
    mov       %r12,	[%rip+mc_decls.riplist]
    jmp       L4380
L4377:
    mov       %eax,	[%r12+8]
    lea       %r10,	[%rbx + %rax]
    mov       %rsi,	%r10
    movsxd    %rax,	dword ptr[%r12+12]
    mov       %r10d,	[%rsi]
    sub       %r10,	[%rip+mc_writeexe.imagebase]
    mov       %r11d,	[%r12+8]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mc_writeexe.getripoffset
    mov       %rdi,	%rax
    mov       [%rsi],	%edi
    mov       %r12,	[%r12]
L4380:
    test      %r12,	%r12
    jnz       L4377
L4376:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.genexe2
mc_writeexe.genexe2:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      mlib.extractfile
    mov       [%rip+mc_writeexe.dllfilename],	%rax
    mov       [%rip+mc_writeexe.isdll],	%rsi
    mov       %rcx,	[%rip+mc_writeexe.filesize]
    call      mlib.pcm_allocz
    mov       [%rip+mc_writeexe.dataptr],	%rax
    mov       [%rip+mc_writeexe.datastart],	%rax
    call      mc_writeexe.writedosstub
    call      mc_writeexe.writepesig
    call      mc_writeexe.writefileheader
    call      mc_writeexe.writeoptheader
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_writeexe.nsections]
    cmp       %rax,	1
    jl        L4384
L4382:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rdi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %rcx,	%rax
    call      mc_writeexe.writesectionheader
    inc       %rdi
    cmp       %rdi,	[%rip+mc_writeexe.nsections]
    jle       L4382
L4384:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rcx,	[%rax+32]
    call      mc_writeexe.writepadding
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_writeexe.nsections]
    cmp       %rax,	1
    jl        L4387
L4385:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rdi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %rcx,	%rax
    call      mc_writeexe.writesectiondata
    inc       %rdi
    cmp       %rdi,	[%rip+mc_writeexe.nsections]
    jle       L4385
L4387:
    movzx     %rax,	byte ptr[%rip+pc_decls.pverbose]
    cmp       %rax,	2
    jnz       L4389
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10920]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+mc_writeexe.dataptr]
    sub       %rax,	[%rip+mc_writeexe.datastart]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10921]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L4389:
    mov       %rax,	[%rip+mc_writeexe.dataptr]
    sub       %rax,	[%rip+mc_writeexe.datastart]
    mov       %rcx,	%rbx
    mov       %rdx,	[%rip+mc_writeexe.datastart]
    mov       %r8,	%rax
    call      mlib.writefile
    test      %rax,	%rax
    jnz       L4391
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10922]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L4391:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.loadlibs
mc_writeexe.loadlibs:
#?>>
    .set mc_writeexe.loadlibs.filename, -304
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L4395
L4393:
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L4397
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rbp + mc_writeexe.loadlibs.filename]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + mc_writeexe.loadlibs.filename]
    call      mwindows.os_getdllinst
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4399
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10923]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + mc_writeexe.loadlibs.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10924]
    call      mc_libmcl.axerror
L4399:
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mc_writeexe.libinsttable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    lea       %rcx,	[%rbp + mc_writeexe.loadlibs.filename]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+mc_writeexe.libinstnames]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
L4397:
    inc       %rdi
    cmp       %rdi,	[%rip+pc_decls.nplibfiles]
    jle       L4393
L4395:
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.initsectiontable
mc_writeexe.initsectiontable:
#?>>
    .set mc_writeexe.initsectiontable.$T2, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %r10,	[%rip+L10925]
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	1
    mov       [%rax+16],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	[%rip+mc_decls.ss_code]
    mov       [%rax],	%r10
    mov       %rcx,	[%rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    mov       [%r10+40],	%rax
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L4402
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10926]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10927]
    call      msys.m$print_i64
    lea       %rcx,	[%rip+L10928]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    movzx     %rax,	byte ptr[%rip+pc_decls.pverbose]
    cmp       %rax,	2
    jnz       L4404
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10929]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10930]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10931]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [%rbp + mc_writeexe.initsectiontable.$T2],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       %r10,	[%rbp + mc_writeexe.initsectiontable.$T2]
    add       %r10,	%rax
    mov       %rcx,	%r10
    lea       %rdx,	[%rip+L10932]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10933]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.ss_zdatalen]
    lea       %rdx,	[%rip+L10934]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
L4404:
L4402:
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    test      %rax,	%rax
    jnz       L4406
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    xor       %edx,	%edx
    call      mc_genss.addqword
L4406:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    lea       %r10,	[%rip+L10935]
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %r10,	2
    mov       [%rax+16],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %r10,	[%rip+mc_decls.ss_idata]
    mov       [%rax],	%r10
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    lea       %r10,	[%r10+72]
    mov       [%r10+40],	%rax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %rax,	[%rax+40]
    mov       %rcx,	%rax
    mov       %rdx,	512
    call      mlib.roundtoblock
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    lea       %r10,	[%r10+72]
    mov       [%r10+24],	%rax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %r10,	[%rip+mc_decls.ss_nidatarelocs]
    mov       [%rax+64],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %r10,	[%rip+mc_decls.ss_idatarelocs]
    mov       [%rax+56],	%r10
    mov       %rax,	[%rip+mc_decls.ss_zdatalen]
    test      %rax,	%rax
    jnz       L4408
    mov       %rax,	16
    mov       [%rip+mc_decls.ss_zdatalen],	%rax
L4408:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+144]
    lea       %r10,	[%rip+L10936]
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+144]
    mov       %r10,	3
    mov       [%rax+16],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+144]
    mov       %r10,	[%rip+mc_decls.ss_zdatalen]
    mov       [%rax+40],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rax,	[%rax+40]
    mov       %rcx,	%rax
    mov       %rdx,	512
    call      mlib.roundtoblock
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    mov       [%r10+24],	%rax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	[%rip+mc_decls.ss_ncoderelocs]
    mov       [%rax+64],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	[%rip+mc_decls.ss_coderelocs]
    mov       [%rax+56],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+216]
    lea       %r10,	[%rip+L10937]
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+216]
    mov       %r10,	5
    mov       [%rax+16],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+216]
    xor       %r10d,	%r10d
    mov       [%rax+40],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+216]
    xor       %r10d,	%r10d
    mov       [%rax+24],	%r10
    mov       %rax,	4
    mov       [%rip+mc_writeexe.nsections],	%rax
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_writeexe.extractlibname
mc_writeexe.extractlibname:
#?>>
    .set mc_writeexe.extractlibname.moduleno, 88
    .set mc_writeexe.extractlibname.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    xor       %rbx,	%rbx
#mc_writeexe.extractlibname.reenter:
    mov       %rdi,	%r13
    xor       %eax,	%eax
    mov       [%r14],	%rax
    jmp       L4412
L4411:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	46
    jnz       L4415
    mov       %rax,	%rdi
    sub       %rax,	%r13
    lea       %rcx,	[%rbp + mc_writeexe.extractlibname.str]
    mov       %rdx,	%r13
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rdi
    sub       %rax,	%r13
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mc_writeexe.extractlibname.str],	%r10b
    lea       %rcx,	[%rbp + mc_writeexe.extractlibname.str]
    lea       %rdx,	[%rip+L10938]
    call      strcat
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    cmp       %rax,	1
    jl        L4418
L4416:
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + mc_writeexe.extractlibname.str]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4420
    mov       [%r14],	%rsi
    mov       %rax,	[%r14]
    lea       %r10,	[%rip+mc_writeexe.dlltable]
    mov       %r11,	%rax
    shl       %r11,	4
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11-40]
    inc       qword ptr[%r10]
    test      %rbx,	%rbx
    jz        L4422
    mov       %rax,	%rbx
    jmp       L4421
L4422:
    lea       %rax,	[%rdi+1]
L4421:
    jmp       L4409
L4420:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.ndlls]
    jle       L4416
L4418:
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    cmp       %rax,	50
    jl        L4424
    lea       %rcx,	[%rip+L10939]
    call      mc_libmcl.axerror
L4424:
    inc       qword ptr[%rip+mc_writeexe.ndlls]
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    mov       [%r14],	%rax
    lea       %rcx,	[%rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       %r10,	[%r14]
    lea       %r11,	[%rip+mc_writeexe.dlltable]
    mov       %r15,	%r10
    shl       %r15,	4
    lea       %r15,	[%r15 + %r15*2]
    lea       %r11,	[%r11 + %r15-48]
    mov       [%r11],	%rax
    mov       %rax,	[%r14]
    lea       %r10,	[%rip+mc_writeexe.dlltable]
    mov       %r11,	%rax
    shl       %r11,	4
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11-48]
    mov       %rax,	1
    mov       [%r10+8],	%rax
    test      %rbx,	%rbx
    jz        L4426
    mov       %rax,	%rbx
    jmp       L4425
L4426:
    lea       %rax,	[%rdi+1]
L4425:
    jmp       L4409
L4415:
    inc       %rdi
L4412:
    mov       %al,	[%rdi]
    test      %al,	%al
    jnz       L4411
    mov       %rsi,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L4430
L4427:
    lea       %rax,	[%rip+mc_writeexe.libinsttable]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    test      %rax,	%rax
    jz        L4432
    lea       %rax,	[%rip+mc_writeexe.libinsttable]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    call      mwindows.os_getdllprocaddr
    test      %rax,	%rax
    jz        L4434
    mov       %r12,	%rsi
    jmp       L4429
L4434:
L4432:
    inc       %rsi
    cmp       %rsi,	[%rip+pc_decls.nplibfiles]
    jle       L4427
L4430:
    call      msys.m$print_startcon
    mov       %rcx,	%r13
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10940]
    call      mc_libmcl.axerror
L4429:
    lea       %rax,	[%rip+mc_writeexe.libnotable]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%r14],	%rax
    test      %rax,	%rax
    jz        L4436
    mov       %rax,	[%r14]
    lea       %r10,	[%rip+mc_writeexe.dlltable]
    mov       %r11,	%rax
    shl       %r11,	4
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11-40]
    inc       qword ptr[%r10]
    mov       %rax,	%r13
    jmp       L4409
L4436:
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rbp + mc_writeexe.extractlibname.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + mc_writeexe.extractlibname.str]
    lea       %rdx,	[%rip+L10941]
    call      strcat
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    cmp       %rax,	50
    jl        L4438
    lea       %rcx,	[%rip+L10942]
    call      mc_libmcl.axerror
L4438:
    inc       qword ptr[%rip+mc_writeexe.ndlls]
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    mov       [%r14],	%rax
    lea       %rcx,	[%rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       %r10,	[%r14]
    lea       %r11,	[%rip+mc_writeexe.dlltable]
    mov       %r15,	%r10
    shl       %r15,	4
    lea       %r15,	[%r15 + %r15*2]
    lea       %r11,	[%r11 + %r15-48]
    mov       [%r11],	%rax
    mov       %rax,	[%r14]
    lea       %r10,	[%rip+mc_writeexe.dlltable]
    mov       %r11,	%rax
    shl       %r11,	4
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11-48]
    mov       %rax,	1
    mov       [%r10+8],	%rax
    mov       %rax,	[%r14]
    lea       %r10,	[%rip+mc_writeexe.libnotable]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%r13
L4409:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.scanst
mc_writeexe.scanst:
#?>>
    .set mc_writeexe.scanst.libno, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L4442
L4440:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8-8]
    mov       %al,	[%rbx+80]
    test      %al,	%al
    jz        L4444
    mov       %rax,	[%rip+mc_writeexe.nimports]
    cmp       %rax,	3000
    jl        L4446
    lea       %rcx,	[%rip+L10943]
    call      mc_libmcl.axerror
L4446:
    inc       qword ptr[%rip+mc_writeexe.nimports]
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + mc_writeexe.scanst.libno]
    mov       %r8,	1
    call      mc_writeexe.extractlibname
    mov       %rsi,	%rax
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	[%rip+mc_writeexe.nimports]
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %r10,	[%rbp + mc_writeexe.scanst.libno]
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	[%rip+mc_writeexe.nimports]
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    mov       [%rax+16],	%r10
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	[%rip+mc_writeexe.nimports]
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rbx
    mov       [%rax],	%r10
    mov       %ax,	[%rip+mc_writeexe.nimports]
    mov       [%rbx+98],	%ax
    jmp       L4443
L4444:
    mov       %al,	[%rbx+81]
    test      %al,	%al
    jz        L4447
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %r12,	%rax
    mov       %rax,	[%rip+mc_writeexe.userentrypoint]
    test      %rax,	%rax
    jz        L4449
    mov       %rcx,	%r12
    mov       %rdx,	[%rip+mc_writeexe.userentrypoint]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4451
    mov       [%rip+mc_writeexe.stentrypoint],	%rbx
L4451:
    jmp       L4448
L4449:
    mov       %al,	[%rbx+83]
    test      %al,	%al
    jz        L4453
    mov       %rax,	[%rip+mc_writeexe.isdll]
    test      %rax,	%rax
    jnz       L4453
    mov       [%rip+mc_writeexe.stentrypoint],	%rbx
L4453:
L4448:
    mov       %rax,	[%rip+mc_writeexe.nexports]
    cmp       %rax,	1000
    jl        L4455
    lea       %rcx,	[%rip+L10944]
    call      mc_libmcl.axerror
L4455:
    inc       qword ptr[%rip+mc_writeexe.nexports]
    lea       %rax,	[%rip+mc_writeexe.exporttable]
    mov       %r10,	[%rip+mc_writeexe.nexports]
    shl       %r10,	4
    lea       %rax,	[%rax + %r10-16]
    mov       %r10,	%rbx
    mov       [%rax],	%r10
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    lea       %r10,	[%rip+mc_writeexe.exporttable]
    mov       %r11,	[%rip+mc_writeexe.nexports]
    shl       %r11,	4
    lea       %r10,	[%r10 + %r11-16]
    mov       [%r10+8],	%rax
L4447:
L4443:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.ss_nsymbols]
    jle       L4440
L4442:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.relocdata
mc_writeexe.relocdata:
#?>>
    .set mc_writeexe.relocdata.s, 72
    .set mc_writeexe.relocdata.thunkoffset, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_writeexe.relocdata.s]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mc_writeexe.relocdata.s]
    mov       %rbx,	[%rax+56]
    jmp       L4458
L4457:
    mov       %rax,	[%rbx+24]
    mov       %r10,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %r14,	%r10
    movsx     %rax,	word ptr[%r14+98]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	%r15
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %rax,	[%rax+40]
    mov       [%rbp + mc_writeexe.relocdata.thunkoffset],	%rax
    mov       %rax,	[%rbx+8]
    cmp       %rax,	4
    jz        L4461
    cmp       %rax,	2
    jz        L4462
    cmp       %rax,	1
    jz        L4462
    jmp       L4463
L4461:
    mov       %al,	[%r14+80]
    test      %al,	%al
    jnz       L4465
    lea       %rcx,	[%rip+L10945]
    call      mc_libmcl.axerror
L4465:
    mov       %rax,	[%rbx+16]
    mov       %r10,	[%rbp + mc_writeexe.relocdata.thunkoffset]
    sub       %r10,	%rax
    sub       %r10,	4
    mov       %rax,	[%rbx+16]
    mov       [%rsi + %rax],	%r10d
    jmp       L4460
L4462:
    mov       %al,	[%r14+80]
    test      %al,	%al
    jz        L4467
    mov       %rax,	[%rip+mc_writeexe.imagebase]
    add       %rax,	[%rbp + mc_writeexe.relocdata.thunkoffset]
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	[%r10+48]
    add       %rax,	%r10
    mov       %r10,	[%rbx+16]
    mov       [%rsi + %r10],	%eax
    jmp       L4466
L4467:
    xor       %rdi,	%rdi
    movzx     %rax,	byte ptr[%r14+94]
    cmp       %rax,	3
    jz        L4469
    cmp       %rax,	2
    jz        L4470
    cmp       %rax,	1
    jz        L4471
    jmp       L4472
L4469:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+144]
    mov       %rdi,	%rax
    jmp       L4468
L4470:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %rdi,	%rax
    jmp       L4468
L4471:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rdi,	%rax
    jmp       L4468
L4472:
    call      msys.m$print_startcon
    mov       %rcx,	[%r14]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%r14+94]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10946]
    call      mc_libmcl.axerror
L4468:
    mov       %rax,	[%rbx+16]
    lea       %r10,	[%rsi + %rax]
    mov       %r12,	%r10
    mov       %rax,	[%rbx+8]
    cmp       %rax,	2
    jnz       L4474
    mov       %eax,	[%r12]
    mov       %r10,	[%rdi+48]
    add       %rax,	%r10
    add       %rax,	[%rip+mc_writeexe.imagebase]
    mov       [%r12],	%eax
    jmp       L4473
L4474:
    mov       %r13,	%r12
    mov       %rax,	[%r13]
    mov       %r10,	[%rdi+48]
    add       %rax,	%r10
    add       %rax,	[%rip+mc_writeexe.imagebase]
    mov       [%r13],	%rax
L4473:
L4466:
    jmp       L4460
L4463:
    call      msys.m$print_startcon
    mov       %rax,	[%rbx+8]
    lea       %r10,	[%rip+mc_objdecls.relocnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10947]
    call      mc_libmcl.axerror
L4460:
    mov       %rbx,	[%rbx]
L4458:
    test      %rbx,	%rbx
    jnz       L4457
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.getbaserelocs
mc_writeexe.getbaserelocs:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       %rbx,	%rax
    mov       %rdi,	[%r12+56]
    jmp       L4477
L4476:
    mov       %rax,	[%rdi+24]
    mov       %r10,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rsi,	%r10
    mov       %rax,	[%rdi+8]
    cmp       %rax,	2
    jz        L4480
    cmp       %rax,	1
    jnz       L4481
L4480:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jnz       L4482
L4483:
    mov       %rax,	[%rdi+8]
    cmp       %rax,	2
    jz        L4484
L4485:
    mov       %rax,	[%rdi+8]
    mov       %r10,	[%r12+48]
    mov       %r11,	[%rdi+16]
    add       %r10,	%r11
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writeexe.newbasereloc
L4484:
L4482:
L4481:
L4479:
    mov       %rdi,	[%rdi]
L4477:
    test      %rdi,	%rdi
    jnz       L4476
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.writerecordx
mc_writeexe.writerecordx:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	[%rip+mc_writeexe.dataptr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rbx
    add       [%rip+mc_writeexe.dataptr],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.writedosstub
mc_writeexe.writedosstub:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+mc_writeexe.writedosstub.stubdata]
    mov       %rdx,	128
    call      mc_writeexe.writerecordx
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_writeexe.writepesig
mc_writeexe.writepesig:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+mc_writeexe.dataptr]
    inc       qword ptr[%rip+mc_writeexe.dataptr]
    mov       %r10b,	80
    mov       [%rax],	%r10b
    mov       %rax,	[%rip+mc_writeexe.dataptr]
    inc       qword ptr[%rip+mc_writeexe.dataptr]
    mov       %r10b,	69
    mov       [%rax],	%r10b
    mov       %rax,	[%rip+mc_writeexe.dataptr]
    inc       qword ptr[%rip+mc_writeexe.dataptr]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    mov       %rax,	[%rip+mc_writeexe.dataptr]
    inc       qword ptr[%rip+mc_writeexe.dataptr]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
#---------------
    ret       
# End 
# Proc mc_writeexe.writepadding
mc_writeexe.writepadding:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+mc_writeexe.datastart]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10]
    mov       [%rip+mc_writeexe.dataptr],	%rax
#---------------
    ret       
# End 
# Proc mc_writeexe.writefileheader
mc_writeexe.writefileheader:
#?>>
    .set mc_writeexe.writefileheader.header, -24
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    lea       %rax,	[%rbp + mc_writeexe.writefileheader.header]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10d
    mov       %ax,	34404
    mov       [%rbp + mc_writeexe.writefileheader.header],	%ax
    mov       %ax,	[%rip+mc_writeexe.nsections]
    mov       [%rbp + mc_writeexe.writefileheader.header+2],	%ax
    mov       %ax,	240
    mov       [%rbp + mc_writeexe.writefileheader.header+16],	%ax
    mov       %ax,	559
    mov       [%rbp + mc_writeexe.writefileheader.header+18],	%ax
    mov       %rax,	[%rip+mc_writeexe.isdll]
    test      %rax,	%rax
    jz        L4492
    mov       %ax,	8750
    mov       [%rbp + mc_writeexe.writefileheader.header+18],	%ax
L4492:
    lea       %rcx,	[%rbp + mc_writeexe.writefileheader.header]
    mov       %rdx,	20
    call      mc_writeexe.writerecordx
#---------------
    add       %rsp,	64
    pop       %rbp
    ret       
# End 
# Proc mc_writeexe.writeoptheader
mc_writeexe.writeoptheader:
#?>>
    .set mc_writeexe.writeoptheader.header, -240
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	272
#---------------
    lea       %rax,	[%rbp + mc_writeexe.writeoptheader.header]
    xor       %r10d,	%r10d
    mov       %r11,	30
L10948:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L10948
    mov       %ax,	523
    mov       [%rbp + mc_writeexe.writeoptheader.header],	%ax
    mov       %al,	1
    mov       [%rbp + mc_writeexe.writeoptheader.header+2],	%al
    xor       %eax,	%eax
    mov       [%rbp + mc_writeexe.writeoptheader.header+3],	%al
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_writeexe.writeoptheader.header+4],	%eax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %rax,	[%rax+24]
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    lea       %r10,	[%r10+216]
    mov       %r10,	[%r10+24]
    add       %rax,	%r10
    mov       [%rbp + mc_writeexe.writeoptheader.header+8],	%eax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+144]
    mov       %rax,	[%rax+40]
    mov       %rcx,	%rax
    mov       %rdx,	512
    call      mlib.roundtoblock
    mov       [%rbp + mc_writeexe.writeoptheader.header+12],	%eax
    mov       %rax,	[%rip+mc_writeexe.stentrypoint]
    test      %rax,	%rax
    jnz       L4495
    mov       %rax,	[%rip+mc_writeexe.stentrypoint2]
    mov       [%rip+mc_writeexe.stentrypoint],	%rax
L4495:
    mov       %rax,	[%rip+mc_writeexe.stentrypoint]
    test      %rax,	%rax
    jnz       L4497
    mov       %rax,	[%rip+mc_writeexe.userentrypoint]
    test      %rax,	%rax
    jz        L4499
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+mc_writeexe.userentrypoint]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L10949]
    call      mc_libmcl.axerror
    jmp       L4498
L4499:
    mov       %rax,	[%rip+mc_writeexe.isdll]
    test      %rax,	%rax
    jnz       L4501
    lea       %rcx,	[%rip+L10950]
    call      mc_libmcl.axerror
L4501:
L4498:
    jmp       L4496
L4497:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rax,	[%rax+48]
    mov       %r10,	[%rip+mc_writeexe.stentrypoint]
    movsxd    %r10,	dword ptr[%r10+76]
    add       %rax,	%r10
    mov       [%rbp + mc_writeexe.writeoptheader.header+16],	%eax
L4496:
    mov       %eax,	4096
    mov       [%rbp + mc_writeexe.writeoptheader.header+20],	%eax
    mov       %rax,	[%rip+mc_writeexe.imagebase]
    mov       [%rbp + mc_writeexe.writeoptheader.header+24],	%rax
    mov       %eax,	4096
    mov       [%rbp + mc_writeexe.writeoptheader.header+32],	%eax
    mov       %eax,	512
    mov       [%rbp + mc_writeexe.writeoptheader.header+36],	%eax
    mov       %ax,	4
    mov       [%rbp + mc_writeexe.writeoptheader.header+40],	%ax
    xor       %eax,	%eax
    mov       [%rbp + mc_writeexe.writeoptheader.header+42],	%ax
    mov       %ax,	5
    mov       [%rbp + mc_writeexe.writeoptheader.header+48],	%ax
    mov       %ax,	2
    mov       [%rbp + mc_writeexe.writeoptheader.header+50],	%ax
    mov       %eax,	[%rip+mc_writeexe.imagesize]
    mov       [%rbp + mc_writeexe.writeoptheader.header+56],	%eax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rax,	[%rax+32]
    mov       [%rbp + mc_writeexe.writeoptheader.header+60],	%eax
    mov       %ax,	3
    mov       [%rbp + mc_writeexe.writeoptheader.header+68],	%ax
    mov       %rax,	4194304
    mov       [%rbp + mc_writeexe.writeoptheader.header+72],	%rax
    mov       %rax,	2097152
    mov       [%rbp + mc_writeexe.writeoptheader.header+80],	%rax
    mov       %rax,	1048576
    mov       [%rbp + mc_writeexe.writeoptheader.header+88],	%rax
    mov       %rax,	4096
    mov       [%rbp + mc_writeexe.writeoptheader.header+96],	%rax
    mov       %eax,	16
    mov       [%rbp + mc_writeexe.writeoptheader.header+108],	%eax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+216]
    mov       %rax,	[%rax+48]
    mov       [%rbp + mc_writeexe.writeoptheader.header+120],	%eax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+216]
    mov       %rax,	[%rax+40]
    sub       %rax,	[%rip+mc_writeexe.exportdirvirtsize]
    sub       %rax,	[%rip+mc_writeexe.blockdirvirtsize]
    mov       [%rbp + mc_writeexe.writeoptheader.header+124],	%eax
    mov       %rax,	[%rip+mc_writeexe.isdll]
    test      %rax,	%rax
    jz        L4503
    mov       %ax,	64
    mov       [%rbp + mc_writeexe.writeoptheader.header+70],	%ax
    mov       %eax,	[%rip+mc_writeexe.exportdirvirtaddr]
    mov       [%rbp + mc_writeexe.writeoptheader.header+112],	%eax
    mov       %eax,	[%rip+mc_writeexe.exportdirvirtsize]
    mov       [%rbp + mc_writeexe.writeoptheader.header+116],	%eax
    mov       %eax,	[%rip+mc_writeexe.blockdirvirtaddr]
    mov       [%rbp + mc_writeexe.writeoptheader.header+152],	%eax
    mov       %eax,	[%rip+mc_writeexe.blockdirvirtsize]
    mov       [%rbp + mc_writeexe.writeoptheader.header+156],	%eax
L4503:
    mov       %eax,	[%rip+mc_writeexe.fileiatoffset]
    mov       [%rbp + mc_writeexe.writeoptheader.header+208],	%eax
    mov       %eax,	[%rip+mc_writeexe.fileiatsize]
    mov       [%rbp + mc_writeexe.writeoptheader.header+212],	%eax
    lea       %rcx,	[%rbp + mc_writeexe.writeoptheader.header]
    mov       %rdx,	240
    call      mc_writeexe.writerecordx
#---------------
    add       %rsp,	272
    pop       %rbp
    ret       
# End 
# Proc mc_writeexe.writesectionheader
mc_writeexe.writesectionheader:
#?>>
    .set mc_writeexe.writesectionheader.sheader, -40
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rbp + mc_writeexe.writesectionheader.sheader]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    mov       [%rax+32],	%r10
    mov       %rax,	[%rbx+8]
    lea       %r10,	[%rbp + mc_writeexe.writesectionheader.sheader]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcpy
    mov       %rax,	[%rbx+40]
    mov       [%rbp + mc_writeexe.writesectionheader.sheader+8],	%eax
    mov       %rax,	[%rbx+48]
    mov       [%rbp + mc_writeexe.writesectionheader.sheader+12],	%eax
    mov       %rax,	[%rbx+32]
    mov       [%rbp + mc_writeexe.writesectionheader.sheader+20],	%eax
    mov       %rax,	[%rbx+24]
    mov       [%rbp + mc_writeexe.writesectionheader.sheader+16],	%eax
    mov       %rax,	[%rbx+16]
    cmp       %rax,	3
    jz        L4506
    cmp       %rax,	2
    jz        L4507
    cmp       %rax,	1
    jz        L4508
    cmp       %rax,	5
    jz        L4509
    jmp       L4510
L4506:
    mov       %rdi,	3226468480
    mov       [%rbp + mc_writeexe.writesectionheader.sheader+36],	%edi
    jmp       L4505
L4507:
    mov       %rdi,	3226468416
    mov       [%rbp + mc_writeexe.writesectionheader.sheader+36],	%edi
    jmp       L4505
L4508:
    mov       %rdi,	1615855648
    mov       [%rbp + mc_writeexe.writesectionheader.sheader+36],	%edi
    jmp       L4505
L4509:
    mov       %rdi,	3224371264
    mov       [%rbp + mc_writeexe.writesectionheader.sheader+36],	%edi
L4510:
L4505:
    lea       %rcx,	[%rbp + mc_writeexe.writesectionheader.sheader]
    mov       %rdx,	40
    call      mc_writeexe.writerecordx
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.writesectiondata
mc_writeexe.writesectiondata:
#?>>
    .set mc_writeexe.writesectiondata.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+16]
    cmp       %rax,	5
    jz        L4513
    cmp       %rax,	3
    jz        L4514
    jmp       L4515
L4513:
    mov       %rax,	[%rdi+40]
    mov       %r10,	[%rdi]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writeexe.writerecordx
    mov       %rax,	[%rdi+24]
    mov       %r10,	[%rdi+40]
    cmp       %rax,	%r10
    jle       L4517
    mov       %rax,	[%rdi+24]
    mov       %r10,	[%rdi+40]
    sub       %rax,	%r10
    add       [%rip+mc_writeexe.dataptr],	%rax
L4517:
    jmp       L4512
L4514:
    jmp       L4512
L4515:
    mov       %rax,	[%rdi+24]
    mov       [%rbp + mc_writeexe.writesectiondata.$T1],	%rax
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_writeexe.writesectiondata.$T1]
    call      mc_writeexe.writerecordx
L4512:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.writeexporttable
mc_writeexe.writeexporttable:
#?>>
    .set mc_writeexe.writeexporttable.pstart, 72
    .set mc_writeexe.writeexporttable.sortindex, -16000
    .set mc_writeexe.writeexporttable.nametableoffset, -16008
    .set mc_writeexe.writeexporttable.ordtableoffset, -16016
    .set mc_writeexe.writeexporttable.dllnameoffset, -16024
    .set mc_writeexe.writeexporttable.namesoffset, -16032
    .set mc_writeexe.writeexporttable.virtoffset, -16040
    .set mc_writeexe.writeexporttable.sectionno, -16048
    .set mc_writeexe.writeexporttable.d, -16056
    .set mc_writeexe.writeexporttable.basename, -16064
    .set mc_writeexe.writeexporttable.i, -16072
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	16104
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rdi,	[%rbp + mc_writeexe.writeexporttable.pstart]
    mov       %eax,	1602876664
    mov       [%rdi+4],	%eax
    mov       %eax,	1
    mov       [%rdi+16],	%eax
    mov       %eax,	[%rip+mc_writeexe.nexports]
    mov       [%rdi+20],	%eax
    mov       %eax,	[%rip+mc_writeexe.nexports]
    mov       [%rdi+24],	%eax
    mov       %r15,	40
    mov       %rax,	[%rip+mc_writeexe.nexports]
    shl       %rax,	2
    mov       %r10,	%r15
    add       %r10,	%rax
    mov       [%rbp + mc_writeexe.writeexporttable.nametableoffset],	%r10
    mov       %rax,	[%rip+mc_writeexe.nexports]
    shl       %rax,	2
    mov       %r10,	[%rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       %r10,	%rax
    mov       [%rbp + mc_writeexe.writeexporttable.ordtableoffset],	%r10
    mov       %rax,	[%rip+mc_writeexe.nexports]
    shl       %rax,	1
    mov       %r10,	[%rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       %r10,	%rax
    mov       [%rbp + mc_writeexe.writeexporttable.dllnameoffset],	%r10
    mov       %rcx,	[%rip+mc_writeexe.dllfilename]
    call      strlen
    mov       %r10,	[%rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       %r10,	%rax
    inc       %r10
    mov       [%rbp + mc_writeexe.writeexporttable.namesoffset],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+216]
    mov       %rax,	[%rax+48]
    add       %rax,	[%rip+mc_writeexe.exportdiroffset]
    mov       [%rbp + mc_writeexe.writeexporttable.virtoffset],	%rax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.pstart]
    mov       %r10,	%r15
    lea       %rax,	[%rax + %r10]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.pstart]
    mov       %r10,	[%rbp + mc_writeexe.writeexporttable.nametableoffset]
    lea       %rax,	[%rax + %r10]
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.pstart]
    mov       %r10,	[%rbp + mc_writeexe.writeexporttable.ordtableoffset]
    lea       %rax,	[%rax + %r10]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.pstart]
    mov       %r10,	[%rbp + mc_writeexe.writeexporttable.dllnameoffset]
    lea       %rax,	[%rax + %r10]
    mov       %r13,	%rax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.pstart]
    mov       %r10,	[%rbp + mc_writeexe.writeexporttable.namesoffset]
    lea       %rax,	[%rax + %r10]
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       %rax,	[%rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [%rdi+12],	%eax
    mov       %rax,	%r15
    add       %rax,	[%rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [%rdi+28],	%eax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       %rax,	[%rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [%rdi+32],	%eax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       %rax,	[%rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [%rdi+36],	%eax
    mov       %rcx,	%r13
    mov       %rdx,	[%rip+mc_writeexe.dllfilename]
    call      strcpy
    mov       %rax,	[%rip+mc_writeexe.nexports]
    cmp       %rax,	2000
    jle       L4520
    lea       %rcx,	[%rip+L10951]
    call      mc_libmcl.axerror
L4520:
    lea       %rcx,	[%rbp + mc_writeexe.writeexporttable.sortindex]
    call      mc_writeexe.sortexports
    mov       %rax,	1
    mov       [%rbp + mc_writeexe.writeexporttable.i],	%rax
    mov       %rax,	[%rip+mc_writeexe.nexports]
    cmp       %rax,	1
    jl        L4523
L4521:
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.i]
    mov       %rax,	[%rbp + %rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       %r10,	[%rip+mc_writeexe.exporttable]
    lea       %r11,	[%rax + %rax]
    lea       %r10,	[%r10 + %r11*8-16]
    mov       %r10,	[%r10]
    mov       [%rbp + mc_writeexe.writeexporttable.d],	%r10
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.i]
    mov       %rax,	[%rbp + %rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       %r10,	[%rip+mc_writeexe.exporttable]
    lea       %r11,	[%rax + %rax]
    lea       %r10,	[%r10 + %r11*8-16]
    mov       %r10,	[%r10+8]
    mov       [%rbp + mc_writeexe.writeexporttable.basename],	%r10
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.d]
    movzx     %rax,	byte ptr[%rax+94]
    mov       %rcx,	%rax
    call      mc_writeexe.getsectionno
    mov       [%rbp + mc_writeexe.writeexporttable.sectionno],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_writeexe.writeexporttable.basename]
    call      strcpy
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.namesoffset]
    add       %rax,	[%rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [%rsi],	%eax
    add       %rsi,	4
    mov       %rcx,	[%rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    inc       %rax
    add       [%rbp + mc_writeexe.writeexporttable.namesoffset],	%rax
    mov       %rcx,	[%rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    inc       %rax
    add       %r14,	%rax
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.d]
    movsxd    %rax,	dword ptr[%rax+76]
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    mov       %r11,	[%rbp + mc_writeexe.writeexporttable.sectionno]
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*8]
    lea       %r10,	[%r10 + %r11-72]
    mov       %r10,	[%r10+48]
    add       %rax,	%r10
    mov       [%rbx],	%eax
    add       %rbx,	4
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.i]
    dec       %rax
    mov       [%r12],	%ax
    add       %r12,	2
    mov       %rax,	[%rbp + mc_writeexe.writeexporttable.i]
    inc       %rax
    mov       [%rbp + mc_writeexe.writeexporttable.i],	%rax
    cmp       %rax,	[%rip+mc_writeexe.nexports]
    jle       L4521
L4523:
#---------------
    add       %rsp,	16104
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.getexporttablesize
mc_writeexe.getexporttablesize:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rdi,	40
    mov       %rax,	[%rip+mc_writeexe.nexports]
    shl       %rax,	2
    add       %rdi,	%rax
    mov       %rax,	[%rip+mc_writeexe.nexports]
    shl       %rax,	2
    add       %rdi,	%rax
    mov       %rax,	[%rip+mc_writeexe.nexports]
    shl       %rax,	1
    add       %rdi,	%rax
    mov       %rcx,	[%rip+mc_writeexe.dllfilename]
    call      strlen
    inc       %rax
    add       %rdi,	%rax
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_writeexe.nexports]
    cmp       %rax,	1
    jl        L4527
L4525:
    lea       %rax,	[%rip+mc_writeexe.exporttable]
    mov       %r10,	%rbx
    shl       %r10,	4
    lea       %rax,	[%rax + %r10-16]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    inc       %rax
    add       %rdi,	%rax
    inc       %rbx
    cmp       %rbx,	[%rip+mc_writeexe.nexports]
    jle       L4525
L4527:
    mov       %rax,	%rdi
L4524:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.newbasereloc
mc_writeexe.newbasereloc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi+8],	%ebx
    mov       [%rdi+12],	%esi
    mov       %rax,	[%rip+mc_writeexe.basereloclist]
    mov       [%rdi],	%rax
    mov       [%rip+mc_writeexe.basereloclist],	%rdi
    inc       qword ptr[%rip+mc_writeexe.nbaserelocs]
    mov       %rax,	%rbx
    cmp       [%rip+mc_writeexe.maxrelocaddr],	%rax
    jge       L10952
    mov       [%rip+mc_writeexe.maxrelocaddr],	%rax
L10952:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.scanbaserelocs
mc_writeexe.scanbaserelocs:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	4096
    xor       %eax,	%eax
    mov       [%rip+mc_writeexe.nbaseblocks],	%rax
L4530:
    lea       %rax,	[%rdi+4096]
    mov       %rsi,	%rax
    mov       %rax,	[%rip+mc_writeexe.nbaseblocks]
    cmp       %rax,	500
    jl        L4534
    lea       %rcx,	[%rip+L10953]
    call      mc_libmcl.axerror
L4534:
    inc       qword ptr[%rip+mc_writeexe.nbaseblocks]
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_writeexe.blockbases]
    mov       %r11,	[%rip+mc_writeexe.nbaseblocks]
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_writeexe.blockcounts]
    mov       %r11,	[%rip+mc_writeexe.nbaseblocks]
    mov       [%r10 + %r11*4-4],	%eax
    mov       %r12,	[%rip+mc_writeexe.basereloclist]
    jmp       L4536
L4535:
    mov       %eax,	[%r12+8]
    mov       %rbx,	%rax
    cmp       %rbx,	%rdi
    jl        L4539
    cmp       %rbx,	%rsi
    jge       L4539
    lea       %rax,	[%rip+mc_writeexe.blockcounts]
    mov       %r10,	[%rip+mc_writeexe.nbaseblocks]
    lea       %rax,	[%rax + %r10*4-4]
    inc       dword ptr[%rax]
L4539:
    mov       %r12,	[%r12]
L4536:
    test      %r12,	%r12
    jnz       L4535
    mov       %rdi,	%rsi
    cmp       %rdi,	[%rip+mc_writeexe.maxrelocaddr]
    jle       L4530
    mov       %r13,	1
    mov       %rax,	[%rip+mc_writeexe.nbaseblocks]
    cmp       %rax,	1
    jl        L4542
L4540:
    lea       %rax,	[%rip+mc_writeexe.blockcounts]
    mov       %r10,	%r13
    mov       %eax,	[%rax + %r10*4-4]
    test      %eax,	%eax
    jz        L4544
    lea       %rax,	[%rip+mc_writeexe.blockcounts]
    mov       %r10,	%r13
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    and       %eax,	1
    test      %rax,	%rax
    jz        L4546
    lea       %rax,	[%rip+mc_writeexe.blockcounts]
    mov       %r10,	%r13
    lea       %rax,	[%rax + %r10*4-4]
    inc       dword ptr[%rax]
    lea       %rax,	[%rip+mc_writeexe.blockpadding]
    mov       %r10,	%r13
    lea       %rax,	[%rax + %r10-1]
    inc       byte ptr[%rax]
L4546:
    lea       %rax,	[%rip+mc_writeexe.blockcounts]
    mov       %r10,	%r13
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    shl       %rax,	1
    add       %rax,	8
    lea       %r10,	[%rip+mc_writeexe.blockbytes]
    mov       %r11,	%r13
    mov       [%r10 + %r11*4-4],	%eax
    lea       %rax,	[%rip+mc_writeexe.blockbytes]
    mov       %r10,	%r13
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    add       [%rip+mc_writeexe.basetablesize],	%rax
L4544:
    inc       %r13
    cmp       %r13,	[%rip+mc_writeexe.nbaseblocks]
    jle       L4540
L4542:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.writebasereloctable
mc_writeexe.writebasereloctable:
#?>>
    .set mc_writeexe.writebasereloctable.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	8
#---------------
    mov       %rdi,	%rcx
    mov       %r15,	1
    mov       %rax,	[%rip+mc_writeexe.nbaseblocks]
    cmp       %rax,	1
    jl        L4550
L4548:
    lea       %rax,	[%rip+mc_writeexe.blockcounts]
    mov       %r10,	%r15
    mov       %eax,	[%rax + %r10*4-4]
    test      %eax,	%eax
    jz        L4552
    lea       %rax,	[%rip+mc_writeexe.blockbases]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rdi],	%eax
    add       %rdi,	4
    lea       %rax,	[%rip+mc_writeexe.blockbytes]
    mov       %r10,	%r15
    mov       %eax,	[%rax + %r10*4-4]
    mov       [%rdi],	%eax
    add       %rdi,	4
    mov       %rbx,	%rdi
    mov       %r14,	[%rip+mc_writeexe.basereloclist]
    lea       %rax,	[%rip+mc_writeexe.blockbases]
    mov       %r10,	%r15
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rsi+4096]
    mov       %r13,	%rax
    jmp       L4554
L4553:
    mov       %eax,	[%r14+8]
    mov       %r12,	%rax
    cmp       %r12,	%rsi
    jl        L4557
    cmp       %r12,	%r13
    jge       L4557
    mov       %rax,	%r12
    sub       %rax,	%rsi
    mov       [%rbp + mc_writeexe.writebasereloctable.$T1],	%rax
    movsxd    %rax,	dword ptr[%r14+12]
    cmp       %rax,	2
    jnz       L4559
    mov       %rax,	3
    jmp       L4558
L4559:
    mov       %rax,	10
L4558:
    shl       %rax,	12
    mov       %r10,	[%rbp + mc_writeexe.writebasereloctable.$T1]
    add       %r10,	%rax
    mov       [%rbx],	%r10w
    add       %rbx,	2
L4557:
    mov       %r14,	[%r14]
L4554:
    test      %r14,	%r14
    jnz       L4553
    lea       %rax,	[%rip+mc_writeexe.blockpadding]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L4561
    mov       %rax,	%rbx
    add       %rbx,	2
    xor       %r10d,	%r10d
    mov       [%rax],	%r10w
L4561:
    mov       %rdi,	%rbx
L4552:
    inc       %r15
    cmp       %r15,	[%rip+mc_writeexe.nbaseblocks]
    jle       L4548
L4550:
#---------------
    add       %rsp,	8
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.sortexports
mc_writeexe.sortexports:
#?>>
    .set mc_writeexe.sortexports.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r14,	%rcx
#---------------
    mov       %r13,	1
    mov       %rax,	[%rip+mc_writeexe.nexports]
    cmp       %rax,	1
    jl        L4565
L4563:
    mov       [%r14 + %r13*8-8],	%r13
    inc       %r13
    cmp       %r13,	[%rip+mc_writeexe.nexports]
    jle       L4563
L4565:
L4566:
    xor       %rsi,	%rsi
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rax,	[%rip+mc_writeexe.nexports]
    dec       %rax
    mov       %r12,	%rax
    cmp       %r12,	1
    jl        L4571
L4569:
    mov       %rax,	[%r14 + %r13*8-8]
    lea       %r10,	[%rip+mc_writeexe.exporttable]
    lea       %r11,	[%rax + %rax]
    lea       %r10,	[%r10 + %r11*8-16]
    mov       %r10,	[%r10]
    mov       %rdi,	%r10
    mov       %rax,	[%r14 + %r13*8]
    lea       %r10,	[%rip+mc_writeexe.exporttable]
    lea       %r11,	[%rax + %rax]
    lea       %r10,	[%r10 + %r11*8-16]
    mov       %r10,	[%r10]
    mov       %rbx,	%r10
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       [%rbp + mc_writeexe.sortexports.$T1],	%rax
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_writeexe.sortexports.$T1]
    call      strcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    jle       L4573
    mov       %rsi,	1
    lea       %rax,	[%r14 + %r13*8-8]
    lea       %r10,	[%r14 + %r13*8]
    mov       %r11,	[%rax]
    mov       %r9,	[%r10]
    mov       [%r10],	%r11
    mov       [%rax],	%r9
L4573:
    inc       %r13
    cmp       %r13,	%r12
    jle       L4569
L4571:
    test      %rsi,	%rsi
    jnz       L4566
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.getsectionno
mc_writeexe.getsectionno:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L4576
    cmp       %rax,	2
    jz        L4577
    cmp       %rax,	1
    jz        L4578
    jmp       L4579
L4576:
    mov       %rax,	3
    jmp       L4575
L4577:
    mov       %rax,	2
    jmp       L4575
L4578:
    mov       %rax,	1
    jmp       L4575
L4579:
    lea       %rcx,	[%rip+L10954]
    call      mc_libmcl.axerror
    xor       %eax,	%eax
L4575:
L4574:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.getoffsets
mc_writeexe.getoffsets:
#?>>
    .set mc_writeexe.getoffsets.j, -8
    .set mc_writeexe.getoffsets.codesize, -16
    .set mc_writeexe.getoffsets.length, -24
    .set mc_writeexe.getoffsets.thunkoffset, -32
    .set mc_writeexe.getoffsets.offset, -40
    .set mc_writeexe.getoffsets.dirstartoffset, -48
    .set mc_writeexe.getoffsets.pcode, -56
    .set mc_writeexe.getoffsets.pimpdir, -64
    .set mc_writeexe.getoffsets.pdir, -72
    .set mc_writeexe.getoffsets.paddr, -80
    .set mc_writeexe.getoffsets.pname, -88
    .set mc_writeexe.getoffsets.iatoffset, -96
    .set mc_writeexe.getoffsets.phint, -104
    .set mc_writeexe.getoffsets.pextra, -112
    .set mc_writeexe.getoffsets.xxx, -120
    .set mc_writeexe.getoffsets.av_1, -128
    .set mc_writeexe.getoffsets.thunkptr, -136
    .set mc_writeexe.getoffsets.codebase, -144
    .set mc_writeexe.getoffsets.thunkaddr, -152
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	192
#---------------
    mov       %rdi,	392
    mov       %rax,	40
    mov       %r10,	[%rip+mc_writeexe.nsections]
    imul      %rax,	%r10
    add       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	512
    call      mlib.roundtoblock
    mov       %rdi,	%rax
    mov       %rbx,	4096
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rax,	[%rax+40]
    mov       [%rbp + mc_writeexe.getoffsets.codesize],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_code]
    mov       %rdx,	[%rbp + mc_writeexe.getoffsets.codesize]
    call      mc_genss.bufferelemptr
    mov       [%rbp + mc_writeexe.getoffsets.pcode],	%rax
    jmp       L4582
L4581:
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.pcode]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.pcode]
    mov       %r10b,	144
    mov       [%rax],	%r10b
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.codesize]
L4582:
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.codesize]
    and       %rax,	7
    jnz       L4581
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.codesize]
    mov       [%rbp + mc_writeexe.getoffsets.thunkoffset],	%rax
    mov       %rax,	[%rip+mc_writeexe.nimports]
    shl       %rax,	3
    add       [%rbp + mc_writeexe.getoffsets.codesize],	%rax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.codesize]
    mov       [%rax+40],	%r10
    mov       %rcx,	[%rbp + mc_writeexe.getoffsets.codesize]
    mov       %rdx,	512
    call      mlib.roundtoblock
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    mov       [%r10+24],	%rax
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.codesize]
    sub       %rax,	[%rbp + mc_writeexe.getoffsets.thunkoffset]
    add       %rax,	16
    mov       %rcx,	[%rip+mc_decls.ss_code]
    mov       %rdx,	%rax
    call      mc_genss.buffercheck
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.nsections]
    cmp       %rax,	1
    jl        L4586
L4584:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rsi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %rax,	[%rax+16]
    cmp       %rax,	3
    jz        L4588
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rsi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %r10,	%rdi
    mov       [%rax+32],	%r10
L4588:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rsi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %rax,	[%rax+16]
    cmp       %rax,	3
    jz        L4590
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rsi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %rax,	[%rax+40]
    mov       %r10,	%rdi
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	512
    call      mlib.roundtoblock
    mov       %rdi,	%rax
L4590:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rsi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %r10,	%rbx
    mov       [%rax+48],	%r10
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rsi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %rax,	[%rax+16]
    cmp       %rax,	5
    jnz       L4592
    mov       %r12,	%rbx
    mov       %r13,	%rsi
L4592:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%rsi
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %rax,	[%rax+40]
    mov       %r10,	%rbx
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	4096
    call      mlib.roundtoblock
    mov       %rbx,	%rax
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.nsections]
    jle       L4584
L4586:
    mov       %rax,	[%rip+mc_writeexe.isdll]
    test      %rax,	%rax
    jz        L4594
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rcx,	%rax
    call      mc_writeexe.getbaserelocs
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    lea       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      mc_writeexe.getbaserelocs
L4594:
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    inc       %rax
    shl       %rax,	2
    lea       %rax,	[%rax + %rax*4]
    add       %r12,	%rax
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    cmp       %rax,	1
    jl        L4597
L4595:
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %r10,	%r12
    mov       [%rax+16],	%r10
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+8]
    inc       %rax
    shl       %rax,	3
    add       %r12,	%rax
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.ndlls]
    jle       L4595
L4597:
    mov       [%rip+mc_writeexe.fileiatoffset],	%r12
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    cmp       %rax,	1
    jl        L4600
L4598:
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %r10,	%r12
    mov       [%rax+24],	%r10
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+8]
    inc       %rax
    shl       %rax,	3
    add       %r12,	%rax
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.ndlls]
    jle       L4598
L4600:
    mov       %rax,	%r12
    sub       %rax,	[%rip+mc_writeexe.fileiatoffset]
    mov       [%rip+mc_writeexe.fileiatsize],	%rax
    mov       %r14,	%r12
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.nimports]
    cmp       %rax,	1
    jl        L4603
L4601:
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %rax,	[%rax+16]
    mov       %rcx,	%rax
    call      strlen
    add       %rax,	3
    mov       [%rbp + mc_writeexe.getoffsets.length],	%rax
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.length]
    and       %rax,	1
    jz        L4605
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.length]
L4605:
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%r12
    mov       [%rax+24],	%r10
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.length]
    add       %r12,	%rax
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.nimports]
    jle       L4601
L4603:
    mov       %rcx,	%r12
    mov       %rdx,	4
    call      mlib.roundtoblock
    mov       %r12,	%rax
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    cmp       %rax,	1
    jl        L4608
L4606:
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    inc       %rax
    mov       [%rbp + mc_writeexe.getoffsets.length],	%rax
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.length]
    and       %rax,	1
    jz        L4610
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.length]
L4610:
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %r10,	%r12
    mov       [%rax+40],	%r10
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+8]
    shl       %rax,	2
    add       %r12,	%rax
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %r10,	%r12
    mov       [%rax+32],	%r10
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.length]
    add       %r12,	%rax
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.ndlls]
    jle       L4606
L4608:
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%r13
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %rax,	[%rax+48]
    mov       [%rbp + mc_writeexe.getoffsets.dirstartoffset],	%rax
    mov       %rax,	[%rip+mc_writeexe.isdll]
    test      %rax,	%rax
    jz        L4612
    mov       [%rip+mc_writeexe.exportdirvirtaddr],	%r12
    mov       %rax,	%r12
    sub       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [%rip+mc_writeexe.exportdiroffset],	%rax
    call      mc_writeexe.getexporttablesize
    mov       [%rip+mc_writeexe.exportdirvirtsize],	%rax
    mov       %rax,	[%rip+mc_writeexe.exportdirvirtsize]
    add       %r12,	%rax
    call      mc_writeexe.scanbaserelocs
    mov       [%rip+mc_writeexe.blockdirvirtaddr],	%r12
    mov       %rax,	%r12
    sub       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [%rip+mc_writeexe.blockdiroffset],	%rax
    mov       %rax,	[%rip+mc_writeexe.basetablesize]
    mov       [%rip+mc_writeexe.blockdirvirtsize],	%rax
    mov       %rax,	[%rip+mc_writeexe.blockdirvirtsize]
    add       %r12,	%rax
L4612:
    mov       %rax,	%r12
    sub       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [%rbp + mc_writeexe.getoffsets.offset],	%rax
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %r10,	%r13
    shl       %r10,	3
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10-72]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.offset]
    mov       [%rax+40],	%r10
    mov       %rcx,	[%rbp + mc_writeexe.getoffsets.offset]
    mov       %rdx,	512
    call      mlib.roundtoblock
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    mov       %r11,	%r13
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*8]
    lea       %r10,	[%r10 + %r11-72]
    mov       [%r10+24],	%rax
    mov       %rax,	%rdi
    add       %rax,	[%rbp + mc_writeexe.getoffsets.offset]
    mov       %rcx,	%rax
    mov       %rdx,	512
    call      mlib.roundtoblock
    mov       [%rip+mc_writeexe.filesize],	%rax
    mov       %rax,	%r12
    sub       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       %r10,	%rbx
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	4096
    call      mlib.roundtoblock
    mov       [%rip+mc_writeexe.imagesize],	%rax
    mov       %rcx,	[%rbp + mc_writeexe.getoffsets.offset]
    call      mlib.pcm_allocz
    lea       %r10,	[%rip+mc_writeexe.sectiontable]
    mov       %r11,	%r13
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*8]
    lea       %r10,	[%r10 + %r11-72]
    mov       [%r10],	%rax
    mov       [%rbp + mc_writeexe.getoffsets.pimpdir],	%rax
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.pimpdir]
    mov       [%rbp + mc_writeexe.getoffsets.pdir],	%rax
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    cmp       %rax,	1
    jl        L4615
L4613:
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+16]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pdir]
    mov       [%r10],	%eax
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+24]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pdir]
    mov       [%r10+16],	%eax
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+32]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pdir]
    mov       [%r10+12],	%eax
    add       qword ptr[%rbp + mc_writeexe.getoffsets.pdir],	20
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_writeexe.getoffsets.iatoffset],	%rax
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.pimpdir]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.iatoffset]
    lea       %rax,	[%rax + %r10]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       %rax,	%r10
    mov       [%rbp + mc_writeexe.getoffsets.paddr],	%rax
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+16]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pimpdir]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       %r10,	%rax
    mov       [%rbp + mc_writeexe.getoffsets.pname],	%r10
    mov       %rax,	1
    mov       [%rbp + mc_writeexe.getoffsets.j],	%rax
    mov       %rax,	[%rip+mc_writeexe.nimports]
    cmp       %rax,	1
    jl        L4618
L4616:
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.j]
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %rax,	[%rax+8]
    cmp       %rax,	%rsi
    jnz       L4620
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.j]
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %rax,	[%rax+24]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.paddr]
    mov       [%r10],	%rax
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pname]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.j]
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.iatoffset]
    mov       [%rax+32],	%r10
    mov       %rax,	8
    add       [%rbp + mc_writeexe.getoffsets.iatoffset],	%rax
    add       qword ptr[%rbp + mc_writeexe.getoffsets.pname],	8
    add       qword ptr[%rbp + mc_writeexe.getoffsets.paddr],	8
L4620:
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.j]
    inc       %rax
    mov       [%rbp + mc_writeexe.getoffsets.j],	%rax
    cmp       %rax,	[%rip+mc_writeexe.nimports]
    jle       L4616
L4618:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.ndlls]
    jle       L4613
L4615:
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.nimports]
    cmp       %rax,	1
    jl        L4623
L4621:
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %rax,	[%rax+24]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pimpdir]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       %r10,	%rax
    mov       [%rbp + mc_writeexe.getoffsets.phint],	%r10
    add       qword ptr[%rbp + mc_writeexe.getoffsets.phint],	2
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %rax,	[%rax+16]
    mov       %rcx,	[%rbp + mc_writeexe.getoffsets.phint]
    mov       %rdx,	%rax
    call      strcpy
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.nimports]
    jle       L4621
L4623:
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [%rbp + mc_writeexe.getoffsets.xxx],	%rax
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.ndlls]
    cmp       %rax,	1
    jl        L4626
L4624:
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+40]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pimpdir]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       %r10,	%rax
    mov       [%rbp + mc_writeexe.getoffsets.pextra],	%r10
    mov       %rax,	1
    mov       [%rbp + mc_writeexe.getoffsets.j],	%rax
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+8]
    mov       [%rbp + mc_writeexe.getoffsets.av_1],	%rax
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.av_1]
    cmp       %rax,	1
    jl        L4629
L4627:
    mov       %eax,	[%rbp + mc_writeexe.getoffsets.xxx]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pextra]
    mov       [%r10],	%eax
    add       qword ptr[%rbp + mc_writeexe.getoffsets.pextra],	4
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.j]
    inc       %rax
    mov       [%rbp + mc_writeexe.getoffsets.j],	%rax
    cmp       %rax,	[%rbp + mc_writeexe.getoffsets.av_1]
    jle       L4627
L4629:
    mov       %rax,	20
    add       [%rbp + mc_writeexe.getoffsets.xxx],	%rax
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax+32]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.pimpdir]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       %r10,	%rax
    mov       [%rbp + mc_writeexe.getoffsets.phint],	%r10
    lea       %rax,	[%rip+mc_writeexe.dlltable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-48]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rbp + mc_writeexe.getoffsets.phint]
    mov       %rdx,	%rax
    call      strcpy
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.ndlls]
    jle       L4624
L4626:
    mov       %rax,	[%rip+mc_writeexe.isdll]
    test      %rax,	%rax
    jz        L4631
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.pimpdir]
    mov       %r10,	[%rip+mc_writeexe.exportdiroffset]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    call      mc_writeexe.writeexporttable
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.pimpdir]
    mov       %r10,	[%rip+mc_writeexe.blockdiroffset]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    call      mc_writeexe.writebasereloctable
L4631:
    mov       %rcx,	[%rip+mc_decls.ss_code]
    mov       %rdx,	[%rbp + mc_writeexe.getoffsets.thunkoffset]
    call      mc_genss.bufferelemptr
    mov       [%rbp + mc_writeexe.getoffsets.thunkptr],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_code]
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       [%rbp + mc_writeexe.getoffsets.codebase],	%rax
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_writeexe.nimports]
    cmp       %rax,	1
    jl        L4634
L4632:
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    sub       %rax,	[%rbp + mc_writeexe.getoffsets.codebase]
    lea       %r10,	[%rip+mc_writeexe.importtable]
    mov       %r11,	%rsi
    shl       %r11,	4
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11]
    mov       [%r10+40],	%rax
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    test      %rax,	%rax
    jnz       L4636
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       %r10b,	72
    mov       [%rax],	%r10b
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       %r10b,	255
    mov       [%rax],	%r10b
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       %r10b,	36
    mov       [%rax],	%r10b
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       %r10b,	37
    mov       [%rax],	%r10b
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %rax,	[%rax+32]
    mov       %r10,	[%rip+mc_writeexe.imagebase]
    add       %r10,	%rax
    mov       [%rbp + mc_writeexe.getoffsets.thunkaddr],	%r10
    mov       %eax,	[%rbp + mc_writeexe.getoffsets.thunkaddr]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [%r10],	%eax
    add       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr],	4
    jmp       L4635
L4636:
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       %r10b,	72
    mov       [%rax],	%r10b
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       %r10b,	255
    mov       [%rax],	%r10b
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       %r10b,	37
    mov       [%rax],	%r10b
    lea       %rax,	[%rip+mc_writeexe.importtable]
    mov       %r10,	%rsi
    shl       %r10,	4
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10]
    mov       %rax,	[%rax+32]
    mov       %r10,	[%rip+mc_writeexe.imagebase]
    add       %r10,	%rax
    mov       [%rbp + mc_writeexe.getoffsets.thunkaddr],	%r10
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkaddr]
    sub       %rax,	[%rip+mc_writeexe.imagebase]
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    sub       %r10,	[%rbp + mc_writeexe.getoffsets.codebase]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_writeexe.getripoffset
    mov       %r10,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [%r10],	%eax
    add       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr],	4
    mov       %rax,	[%rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[%rbp + mc_writeexe.getoffsets.thunkptr]
    mov       %r10b,	144
    mov       [%rax],	%r10b
L4635:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_writeexe.nimports]
    jle       L4632
L4634:
#---------------
    add       %rsp,	192
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeexe.getripoffset
mc_writeexe.getripoffset:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mc_writeexe.sectiontable]
    mov       %rax,	[%rax+48]
    add       %rcx,	%rax
    lea       %rax,	[%rcx+4]
    mov       %r10,	%rdx
    sub       %r10,	%rax
    sub       %r10,	%r8
    mov       %rax,	%r10
L4637:
#---------------
    ret       
# End 
# Proc mc_writeobj.writecoff
mc_writeobj.writecoff:
#?>>
    .set mc_writeobj.writecoff.header, -24
    .set mc_writeobj.writecoff.zsection, -64
    .set mc_writeobj.writecoff.isection, -104
    .set mc_writeobj.writecoff.csection, -144
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	176
    mov       %rbx,	%rcx
#---------------
    mov       %al,	[%rip+pc_decls.objdone]
    test      %al,	%al
    jnz       L4638
L4640:
    lea       %rax,	[%rbp + mc_writeobj.writecoff.header]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10d
    lea       %rax,	[%rbp + mc_writeobj.writecoff.zsection]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    mov       [%rax+32],	%r10
    lea       %rax,	[%rbp + mc_writeobj.writecoff.isection]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    mov       [%rax+32],	%r10
    lea       %rax,	[%rbp + mc_writeobj.writecoff.csection]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    mov       [%rax+32],	%r10
    mov       %ax,	34404
    mov       [%rbp + mc_writeobj.writecoff.header],	%ax
    mov       %ax,	3
    mov       [%rbp + mc_writeobj.writecoff.header+2],	%ax
    lea       %rax,	[%rbp + mc_writeobj.writecoff.zsection]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10955]
    call      strcpy
    mov       %eax,	[%rip+mc_decls.ss_zdatalen]
    mov       [%rbp + mc_writeobj.writecoff.zsection+16],	%eax
    mov       %eax,	3225419904
    mov       [%rbp + mc_writeobj.writecoff.zsection+36],	%eax
    mov       %rax,	[%rip+mc_decls.ss_nidatarelocs]
    cmp       %rax,	65536
    jge       L4643
    mov       %rax,	[%rip+mc_decls.ss_ncoderelocs]
    cmp       %rax,	65536
    jl        L4642
L4643:
    lea       %rcx,	[%rip+L10956]
    call      mc_libmcl.axerror
L4642:
    lea       %rax,	[%rbp + mc_writeobj.writecoff.isection]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10957]
    call      strcpy
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [%rbp + mc_writeobj.writecoff.isection+16],	%eax
    mov       %ax,	[%rip+mc_decls.ss_nidatarelocs]
    mov       [%rbp + mc_writeobj.writecoff.isection+32],	%ax
    mov       %eax,	3226468416
    mov       [%rbp + mc_writeobj.writecoff.isection+36],	%eax
    lea       %rax,	[%rbp + mc_writeobj.writecoff.csection]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10958]
    call      strcpy
    mov       %rcx,	[%rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [%rbp + mc_writeobj.writecoff.csection+16],	%eax
    mov       %ax,	[%rip+mc_decls.ss_ncoderelocs]
    mov       [%rbp + mc_writeobj.writecoff.csection+32],	%ax
    mov       %eax,	1615855648
    mov       [%rbp + mc_writeobj.writecoff.csection+36],	%eax
    mov       %rcx,	%rbx
    call      mc_writeobj.initsymboltable
    call      mc_writeobj.convertsymboltable
    mov       %rdi,	20
    mov       %rax,	120
    add       %rdi,	%rax
    mov       %ax,	[%rbp + mc_writeobj.writecoff.isection+32]
    test      %ax,	%ax
    jz        L4645
    mov       [%rbp + mc_writeobj.writecoff.isection+24],	%edi
    movzx     %rax,	word ptr[%rbp + mc_writeobj.writecoff.isection+32]
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rdi,	%rax
L4645:
    mov       %ax,	[%rbp + mc_writeobj.writecoff.csection+32]
    test      %ax,	%ax
    jz        L4647
    mov       [%rbp + mc_writeobj.writecoff.csection+24],	%edi
    movzx     %rax,	word ptr[%rbp + mc_writeobj.writecoff.csection+32]
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rdi,	%rax
L4647:
    mov       [%rbp + mc_writeobj.writecoff.isection+20],	%edi
    mov       %eax,	[%rbp + mc_writeobj.writecoff.isection+16]
    add       %rdi,	%rax
    mov       [%rbp + mc_writeobj.writecoff.csection+20],	%edi
    mov       %eax,	[%rbp + mc_writeobj.writecoff.csection+16]
    add       %rdi,	%rax
    mov       [%rbp + mc_writeobj.writecoff.header+8],	%edi
    mov       %rax,	[%rip+mc_writeobj.nsymbols]
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*8]
    add       %rdi,	%rax
    mov       %eax,	[%rip+mc_writeobj.nsymbols]
    mov       [%rbp + mc_writeobj.writecoff.header+12],	%eax
    mov       %rax,	[%rip+mc_writeobj.nextstringoffset]
    add       %rdi,	%rax
    mov       %rcx,	%rdi
    call      malloc
    mov       [%rip+mc_writeobj.dataptr],	%rax
    mov       [%rip+mc_writeobj.datastart],	%rax
    lea       %rcx,	[%rbp + mc_writeobj.writecoff.header]
    mov       %rdx,	20
    call      mc_writeobj.writerecord
    lea       %rcx,	[%rbp + mc_writeobj.writecoff.zsection]
    mov       %rdx,	40
    call      mc_writeobj.writerecord
    lea       %rcx,	[%rbp + mc_writeobj.writecoff.isection]
    mov       %rdx,	40
    call      mc_writeobj.writerecord
    lea       %rcx,	[%rbp + mc_writeobj.writecoff.csection]
    mov       %rdx,	40
    call      mc_writeobj.writerecord
    mov       %rcx,	[%rip+mc_decls.ss_idatarelocs]
    mov       %rdx,	[%rip+mc_decls.ss_nidatarelocs]
    call      mc_writeobj.writerelocs
    mov       %rcx,	[%rip+mc_decls.ss_coderelocs]
    mov       %rdx,	[%rip+mc_decls.ss_ncoderelocs]
    call      mc_writeobj.writerelocs
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    call      mc_writeobj.writedata
    mov       %rcx,	[%rip+mc_decls.ss_code]
    call      mc_writeobj.writedata
    call      mc_writeobj.writesymboltable
    call      mc_writeobj.writestringtable
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L4649
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10959]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4649:
    mov       %rax,	[%rip+mc_writeobj.dataptr]
    sub       %rax,	[%rip+mc_writeobj.datastart]
    mov       %rcx,	%rbx
    mov       %rdx,	[%rip+mc_writeobj.datastart]
    mov       %r8,	%rax
    call      mlib.writefile
    mov       %al,	1
    mov       [%rip+pc_decls.objdone],	%al
L4638:
#---------------
    add       %rsp,	176
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.writerecord
mc_writeobj.writerecord:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	[%rip+mc_writeobj.dataptr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rbx
    add       [%rip+mc_writeobj.dataptr],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.writerelocs
mc_writeobj.writerelocs:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rsi,	%rsi
    jnz       L4653
    jmp       L4651
L4653:
    jmp       L4655
L4654:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	2
    jz        L4658
    cmp       %rax,	1
    jnz       L4659
L4658:
    mov       %rax,	[%rbx+24]
    mov       %r10,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    movzx     %rax,	byte ptr[%rdi+94]
    cmp       %rax,	3
    jz        L4661
    cmp       %rax,	2
    jz        L4662
    cmp       %rax,	1
    jz        L4663
    test      %rax,	%rax
    jz        L4664
    jmp       L4665
L4661:
    mov       %eax,	2
    lea       %r10,	[%rip+mc_writeobj.writerelocs.s]
    mov       [%r10+4],	%eax
    jmp       L4660
L4662:
    mov       %eax,	4
    lea       %r10,	[%rip+mc_writeobj.writerelocs.s]
    mov       [%r10+4],	%eax
    jmp       L4660
L4663:
    mov       %eax,	6
    lea       %r10,	[%rip+mc_writeobj.writerelocs.s]
    mov       [%r10+4],	%eax
    jmp       L4660
L4664:
    mov       %rax,	[%rbx+24]
    add       %rax,	[%rip+mc_writeobj.stoffset]
    lea       %r10,	[%rip+mc_writeobj.writerelocs.s]
    mov       [%r10+4],	%eax
    jmp       L4660
L4665:
    lea       %rcx,	[%rip+L10960]
    call      mc_libmcl.axerror
L4660:
    jmp       L4657
L4659:
    mov       %rax,	[%rbx+24]
    add       %rax,	[%rip+mc_writeobj.stoffset]
    lea       %r10,	[%rip+mc_writeobj.writerelocs.s]
    mov       [%r10+4],	%eax
L4657:
    mov       %rax,	[%rbx+8]
    lea       %r10,	[%rip+mc_writeobj.writerelocs.s]
    mov       [%r10+8],	%ax
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    test      %rax,	%rax
    jz        L4667
    cmp       %rax,	2
    jz        L4668
    jmp       L4669
L4667:
    jmp       L4666
L4668:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	2
    jnz       L4671
    mov       %ax,	4
    lea       %r10,	[%rip+mc_writeobj.writerelocs.s]
    mov       [%r10+8],	%ax
    mov       %rax,	4
    mov       [%rbx+8],	%rax
L4671:
    jmp       L4666
L4669:
    lea       %rcx,	[%rip+L10961]
    call      mc_libmcl.axerror
L4666:
    mov       %rax,	[%rbx+16]
    lea       %r10,	[%rip+mc_writeobj.writerelocs.s]
    mov       [%r10],	%eax
    mov       %rcx,	[%rip+mc_writeobj.dataptr]
    lea       %rdx,	[%rip+mc_writeobj.writerelocs.s]
    mov       %r8,	10
    call      memcpy
    add       qword ptr[%rip+mc_writeobj.dataptr],	10
    mov       %rbx,	[%rbx]
L4655:
    test      %rbx,	%rbx
    jnz       L4654
L4651:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.writedata
mc_writeobj.writedata:
#?>>
    .set mc_writeobj.writedata.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genss.bufferlength
    mov       [%rbp + mc_writeobj.writedata.$T1],	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       %rcx,	[%rip+mc_writeobj.dataptr]
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_writeobj.writedata.$T1]
    call      memcpy
    mov       %rcx,	%rdi
    call      mc_genss.bufferlength
    add       [%rip+mc_writeobj.dataptr],	%rax
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.writesymboltable
mc_writeobj.writesymboltable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_writeobj.nsymbols]
    cmp       %rax,	1
    jl        L4676
L4674:
    lea       %rax,	[%rip+mc_writeobj.symboltable]
    mov       %r10,	%rdi
    shl       %r10,	1
    lea       %r10,	[%r10 + %r10*8]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	18
    call      mc_writeobj.writerecord
    inc       %rdi
    cmp       %rdi,	[%rip+mc_writeobj.nsymbols]
    jle       L4674
L4676:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.writestringtable
mc_writeobj.writestringtable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+mc_writeobj.dataptr]
    mov       %eax,	[%rip+mc_writeobj.nextstringoffset]
    mov       [%rdi],	%eax
    add       qword ptr[%rip+mc_writeobj.dataptr],	4
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_writeobj.nstrings]
    cmp       %rax,	1
    jl        L4680
L4678:
    lea       %rax,	[%rip+mc_writeobj.stringlengths]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    inc       %rax
    mov       %rsi,	%rax
    lea       %rax,	[%rip+mc_writeobj.stringtable]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	[%rip+mc_writeobj.dataptr]
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rsi
    add       [%rip+mc_writeobj.dataptr],	%rax
    inc       %rbx
    cmp       %rbx,	[%rip+mc_writeobj.nstrings]
    jle       L4678
L4680:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.makesymbol
mc_writeobj.makesymbol:
#?>>
    .set mc_writeobj.makesymbol.storage, 88
    .set mc_writeobj.makesymbol.naux, 96
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rcx,	%rbx
    call      strlen
    mov       %rdi,	%rax
    cmp       %rdi,	8
    jge       L4683
    lea       %rax,	[%rip+mc_writeobj.makesymbol.r]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    call      strcpy
    jmp       L4682
L4683:
    cmp       %rdi,	8
    jnz       L4684
    lea       %rax,	[%rip+mc_writeobj.makesymbol.r]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      memcpy
    jmp       L4682
L4684:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_writeobj.makesymbol.r]
    mov       [%r10],	%eax
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    call      mc_writeobj.addstringentry
    lea       %r10,	[%rip+mc_writeobj.makesymbol.r]
    mov       [%r10+4],	%eax
L4682:
    mov       %eax,	%esi
    lea       %r10,	[%rip+mc_writeobj.makesymbol.r]
    mov       [%r10+8],	%eax
    mov       %ax,	%r12w
    lea       %r10,	[%rip+mc_writeobj.makesymbol.r]
    mov       [%r10+12],	%ax
    mov       %ax,	%r13w
    lea       %r10,	[%rip+mc_writeobj.makesymbol.r]
    mov       [%r10+14],	%ax
    mov       %al,	[%rbp + mc_writeobj.makesymbol.storage]
    lea       %r10,	[%rip+mc_writeobj.makesymbol.r]
    mov       [%r10+16],	%al
    mov       %al,	[%rbp + mc_writeobj.makesymbol.naux]
    lea       %r10,	[%rip+mc_writeobj.makesymbol.r]
    mov       [%r10+17],	%al
    lea       %rax,	[%rip+mc_writeobj.makesymbol.r]
L4681:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.addsymbol
mc_writeobj.addsymbol:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_writeobj.nsymbols]
    cmp       %rax,	13000
    jl        L4687
    lea       %rcx,	[%rip+L10962]
    call      mc_libmcl.axerror
L4687:
    inc       qword ptr[%rip+mc_writeobj.nsymbols]
    mov       %rax,	[%rip+mc_writeobj.nsymbols]
    lea       %r10,	[%rip+mc_writeobj.symboltable]
    mov       %r11,	%rax
    shl       %r11,	1
    lea       %r11,	[%r11 + %r11*8]
    lea       %r10,	[%r10 + %r11]
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	18
    call      memcpy
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.initsymboltable
mc_writeobj.initsymboltable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %eax,	%eax
    mov       [%rip+mc_writeobj.nsymbols],	%rax
    push      1
    push      103
    lea       %rcx,	[%rip+L10963]
    xor       %edx,	%edx
    mov       %r8,	-2
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_writeobj.makesymbol
    add       %rsp,	48
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
    mov       %rcx,	%rdi
    call      mc_writeobj.strtoaux
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       %rcx,	[%rip+L10964]
    xor       %edx,	%edx
    mov       %r8,	1
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_writeobj.makesymbol
    add       %rsp,	48
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
    xor       %ecx,	%ecx
    xor       %edx,	%edx
    call      mc_writeobj.sectiontoaux
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       %rcx,	[%rip+L10965]
    xor       %edx,	%edx
    mov       %r8,	2
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_writeobj.makesymbol
    add       %rsp,	48
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    mov       %rdx,	[%rip+mc_decls.ss_nidatarelocs]
    call      mc_writeobj.sectiontoaux
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       %rcx,	[%rip+L10966]
    xor       %edx,	%edx
    mov       %r8,	3
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_writeobj.makesymbol
    add       %rsp,	48
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
    mov       %rcx,	[%rip+mc_decls.ss_code]
    mov       %rdx,	[%rip+mc_decls.ss_ncoderelocs]
    call      mc_writeobj.sectiontoaux
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.strtoaux
mc_writeobj.strtoaux:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+mc_writeobj.strtoaux.r]
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	18
    call      memset
    xor       %rbx,	%rbx
    jmp       L4691
L4690:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %al,	[%rax]
    mov       %r10,	%rdi
    inc       %rdi
    mov       [%r10],	%al
    inc       %rbx
L4691:
    movzx     %rax,	byte ptr[%rsi]
    test      %rax,	%rax
    jz        L4693
    cmp       %rbx,	18
    jl        L4690
L4693:
    lea       %rax,	[%rip+mc_writeobj.strtoaux.r]
L4689:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.sectiontoaux
mc_writeobj.sectiontoaux:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mc_writeobj.sectiontoaux.r]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10w
    test      %rdi,	%rdi
    jnz       L4696
    mov       %eax,	[%rip+mc_decls.ss_zdatalen]
    lea       %r10,	[%rip+mc_writeobj.sectiontoaux.r]
    mov       [%r10],	%eax
    jmp       L4695
L4696:
    mov       %rcx,	%rdi
    call      mc_genss.bufferlength
    lea       %r10,	[%rip+mc_writeobj.sectiontoaux.r]
    mov       [%r10],	%eax
L4695:
    mov       %ax,	%bx
    lea       %r10,	[%rip+mc_writeobj.sectiontoaux.r]
    mov       [%r10+4],	%ax
    lea       %rax,	[%rip+mc_writeobj.sectiontoaux.r]
L4694:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.addstringentry
mc_writeobj.addstringentry:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	[%rip+mc_writeobj.nextstringoffset]
    mov       %rax,	[%rip+mc_writeobj.nstrings]
    cmp       %rax,	5000
    jle       L4699
    lea       %rcx,	[%rip+L10967]
    call      mc_libmcl.axerror
L4699:
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+mc_writeobj.nstrings]
    mov       %r10,	[%rip+mc_writeobj.nstrings]
    lea       %r11,	[%rip+mc_writeobj.stringtable]
    mov       [%r11 + %r10*8-8],	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mc_writeobj.stringlengths]
    mov       %r11,	[%rip+mc_writeobj.nstrings]
    mov       [%r10 + %r11*8-8],	%rax
    lea       %rax,	[%rsi+1]
    add       [%rip+mc_writeobj.nextstringoffset],	%rax
    mov       %rax,	%rdi
L4697:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writeobj.convertsymboltable
mc_writeobj.convertsymboltable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mc_writeobj.nsymbols]
    dec       %rax
    mov       [%rip+mc_writeobj.stoffset],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_writeobj.nstrings],	%rax
    mov       %rax,	4
    mov       [%rip+mc_writeobj.nextstringoffset],	%rax
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L4703
L4701:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rbx,	[%rdi]
    movzx     %rax,	byte ptr[%rdi+94]
    cmp       %rax,	3
    jz        L4705
    cmp       %rax,	2
    jz        L4706
    cmp       %rax,	1
    jz        L4707
    jmp       L4708
L4705:
    mov       %r12,	1
    jmp       L4704
L4706:
    mov       %r12,	2
    jmp       L4704
L4707:
    mov       %r12,	3
    jmp       L4704
L4708:
    xor       %r12,	%r12
L4704:
    mov       %al,	[%rdi+80]
    test      %al,	%al
    jz        L4710
    xor       %r12,	%r12
L4710:
    xor       %r13,	%r13
    mov       %al,	[%rdi+80]
    test      %al,	%al
    jnz       L4713
    mov       %al,	[%rdi+81]
    test      %al,	%al
    jz        L4712
L4713:
    mov       %r13,	2
    jmp       L4711
L4712:
    mov       %r13,	3
L4711:
    mov       %al,	[%rdi+81]
    test      %al,	%al
    jz        L4715
    mov       %rcx,	%rbx
    call      pc_api.getbasename
    mov       %rbx,	%rax
L4715:
    push      0
    mov       %rax,	%r13
    push      %rax
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_writeobj.makesymbol
    add       %rsp,	48
    mov       %rcx,	%rax
    call      mc_writeobj.addsymbol
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.ss_nsymbols]
    jle       L4701
L4703:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writess_dummy.writessdata
mc_writess_dummy.writessdata:
#?>>
    .set mc_writess_dummy.writessdata.fexe, 16
#?]]
#---------------
    xor       %eax,	%eax
L4716:
#---------------
    ret       
# End 
# Proc mx_run.writememlib
mx_run.writememlib:
#?>>
    .set mx_run.writememlib.lib, -216
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	256
    mov       %r14,	%rcx
#---------------
    lea       %rax,	[%rbp + mx_run.writememlib.lib]
    xor       %r10d,	%r10d
    mov       %r11,	27
L10968:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L10968
    mov       %rcx,	[%rip+mc_decls.ss_zdatalen]
    mov       %rdx,	8
    call      mlib.roundtoblock
    mov       [%rip+mc_decls.ss_zdatalen],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_code]
    mov       %rdx,	8
    mov       %r8,	144
    call      mx_run.roundsegment
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mx_run.roundsegment
    lea       %rax,	[%rip+L10969]
    mov       [%rbp + mx_run.writememlib.lib],	%rax
    mov       [%rbp + mx_run.writememlib.lib+184],	%r14
    mov       %rcx,	%r14
    call      mlib.extractbasefile
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rbp + mx_run.writememlib.lib+192],	%rax
    mov       %rax,	1
    mov       [%rbp + mx_run.writememlib.lib+208],	%rax
    call      mx_run.countsymbols
    lea       %rcx,	[%rbp + mx_run.writememlib.lib]
    call      mx_run.writerelocs
    mov       %rax,	[%rip+mc_decls.ss_zdatalen]
    mov       [%rbp + mx_run.writememlib.lib+24],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [%rbp + mx_run.writememlib.lib+8],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [%rbp + mx_run.writememlib.lib+16],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_code]
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       [%rbp + mx_run.writememlib.lib+72],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       [%rbp + mx_run.writememlib.lib+80],	%rax
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r12,	%rax
    mov       %r13,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L4720
L4718:
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L4722
    inc       %rsi
L4722:
    inc       %r13
    cmp       %r13,	[%rip+pc_decls.nplibfiles]
    jle       L4718
L4720:
    mov       [%rbp + mx_run.writememlib.lib+40],	%rsi
    mov       [%rbp + mx_run.writememlib.lib+48],	%r12
    mov       %rax,	8
    mov       %r10,	%rsi
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + mx_run.writememlib.lib+96],	%rax
    mov       %rax,	8
    mov       %r10,	%r12
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + mx_run.writememlib.lib+104],	%rax
    xor       %rbx,	%rbx
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L4725
L4723:
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L4727
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8-8]
    mov       %r10,	[%rbp + mx_run.writememlib.lib+96]
    inc       %rbx
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
L4727:
    inc       %r13
    cmp       %r13,	[%rip+pc_decls.nplibfiles]
    jle       L4723
L4725:
    lea       %rcx,	[%rbp + mx_run.writememlib.lib]
    call      mx_run.addsymbols
    mov       %rcx,	216
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + mx_run.writememlib.lib]
    mov       %r8,	216
    call      memcpy
    mov       %rax,	%rdi
L4717:
#---------------
    add       %rsp,	256
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_run.roundsegment
mx_run.roundsegment:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rcx,	%r12
    call      mc_genss.bufferlength
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    call      mlib.roundtoblock
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      mc_genss.buffercheck
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L4731
L4729:
    lea       %rax,	[%r12+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%r14b
    dec       %rsi
    jnz       L4729
L4731:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_run.writerelocs
mx_run.writerelocs:
#?>>
    .set mx_run.writerelocs.newr, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r14,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.ss_nidatarelocs]
    add       %rax,	[%rip+mc_decls.ss_ncoderelocs]
    mov       [%r14+32],	%rax
    mov       %rax,	[%r14+32]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%r14+88],	%rax
    xor       %rbx,	%rbx
    mov       %rax,	1
    mov       %r13,	%rax
L4733:
    cmp       %r13,	1
    jnz       L4737
    mov       %rax,	[%rip+mc_decls.ss_idatarelocs]
    jmp       L4736
L4737:
    mov       %rax,	[%rip+mc_decls.ss_coderelocs]
L4736:
    mov       %rdi,	%rax
    jmp       L4741
L4738:
    lea       %rax,	[%rbp + mx_run.writerelocs.newr]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       %rax,	[%rdi+16]
    mov       [%rbp + mx_run.writerelocs.newr],	%eax
    cmp       %r13,	1
    jnz       L4743
    mov       %rax,	2
    jmp       L4742
L4743:
    mov       %rax,	1
L4742:
    mov       [%rbp + mx_run.writerelocs.newr+6],	%al
    mov       %rax,	[%rdi+24]
    mov       %r10,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rsi,	%r10
    mov       %rax,	[%rdi+8]
    cmp       %rax,	4
    jz        L4745
    cmp       %rax,	2
    jz        L4746
    cmp       %rax,	1
    jz        L4746
    jmp       L4747
L4745:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L4749
    mov       %ax,	[%rsi+116]
    mov       [%rbp + mx_run.writerelocs.newr+4],	%ax
    mov       %al,	5
    mov       [%rbp + mx_run.writerelocs.newr+7],	%al
    jmp       L4748
L4749:
    lea       %rcx,	[%rip+L10970]
    call      mc_libmcl.axerror
L4748:
    jmp       L4744
L4746:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L4751
    mov       %rax,	[%rdi+8]
    cmp       %rax,	2
    jnz       L4753
    mov       %rax,	3
    jmp       L4752
L4753:
    mov       %rax,	4
L4752:
    mov       [%rbp + mx_run.writerelocs.newr+7],	%al
    mov       %ax,	[%rsi+116]
    mov       [%rbp + mx_run.writerelocs.newr+4],	%ax
    jmp       L4750
L4751:
    mov       %rax,	[%rdi+8]
    cmp       %rax,	2
    jnz       L4755
    mov       %al,	1
    mov       [%rbp + mx_run.writerelocs.newr+7],	%al
    jmp       L4754
L4755:
    mov       %al,	2
    mov       [%rbp + mx_run.writerelocs.newr+7],	%al
L4754:
    mov       %al,	[%rsi+94]
    mov       [%rbp + mx_run.writerelocs.newr+4],	%al
L4750:
    jmp       L4744
L4747:
    lea       %rcx,	[%rip+L10971]
    call      mc_libmcl.axerror
L4744:
    mov       %rax,	[%r14+88]
    inc       %rbx
    mov       %r10,	%rbx
    mov       %r11,	[%rbp + mx_run.writerelocs.newr]
    mov       [%rax + %r10*8-8],	%r11
    mov       %rdi,	[%rdi]
L4741:
    test      %rdi,	%rdi
    jnz       L4738
    inc       %r13
    cmp       %r13,	2
    jle       L4733
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_run.addsymbols
mx_run.addsymbols:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    xor       %rbx,	%rbx
    mov       %rax,	-1
    mov       %rsi,	%rax
    mov       %rax,	[%rip+mx_decls.nsymimports]
    mov       [%r14+56],	%rax
    mov       %rax,	[%rip+mx_decls.nsymexports]
    mov       [%r14+64],	%rax
    mov       %rax,	[%rip+mx_decls.nsymimports]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%r14+112],	%rax
    mov       %rax,	[%rip+mx_decls.nsymexports]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%r14+120],	%rax
    mov       %rcx,	[%rip+mx_decls.nsymexports]
    call      mlib.pcm_alloc
    mov       [%r14+128],	%rax
    mov       %rax,	[%rip+mx_decls.nsymexports]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%r14+136],	%rax
    xor       %r12,	%r12
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L4759
L4757:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8-8]
    mov       %ax,	[%rax+116]
    test      %ax,	%ax
    jz        L4761
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%r13
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rax,	[%rdi]
    mov       %r10,	[%r14+112]
    inc       %r12
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
L4761:
    inc       %r13
    cmp       %r13,	[%rip+mc_decls.ss_nsymbols]
    jle       L4757
L4759:
    xor       %r12,	%r12
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L4764
L4762:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%r13
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %ax,	[%rdi+118]
    test      %ax,	%ax
    jz        L4766
    mov       %al,	[%rdi+83]
    test      %al,	%al
    jz        L4768
    mov       %rbx,	%rdi
L4768:
    mov       %rax,	[%rdi]
    mov       %r10,	[%r14+120]
    inc       %r12
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rdi+94]
    mov       %r10,	[%r14+128]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %r10,	[%r14+136]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
L4766:
    inc       %r13
    cmp       %r13,	[%rip+mc_decls.ss_nsymbols]
    jle       L4762
L4764:
    test      %rbx,	%rbx
    jz        L4770
    movsxd    %rax,	dword ptr[%rbx+76]
    mov       [%r14+144],	%rax
    jmp       L4769
L4770:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10972]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	-1
    mov       [%r14+144],	%rax
L4769:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_run.countsymbols
mx_run.countsymbols:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L4774
L4772:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %al,	[%rdi+81]
    test      %al,	%al
    jz        L4776
    inc       qword ptr[%rip+mx_decls.nsymexports]
    mov       %rax,	[%rip+mx_decls.nsymexports]
    mov       [%rdi+118],	%ax
L4776:
    mov       %al,	[%rdi+80]
    test      %al,	%al
    jz        L4778
    inc       qword ptr[%rip+mx_decls.nsymimports]
    mov       %rax,	[%rip+mx_decls.nsymimports]
    mov       [%rdi+116],	%ax
L4778:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.ss_nsymbols]
    jle       L4772
L4774:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_run.runlibfile
mx_run.runlibfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      mx_run.writememlib
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mx_lib.loadmemmcu
    mov       %rcx,	%rdi
    call      mx_lib.fixuplib
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      mx_lib.runprogram
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.readlibfile
mx_lib.readlibfile:
#?>>
    .set mx_lib.readlibfile.p, 72
    .set mx_lib.readlibfile.lib, -216
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	256
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    lea       %rax,	[%rbp + mx_lib.readlibfile.lib]
    xor       %r10d,	%r10d
    mov       %r11,	27
L10973:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L10973
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %rbx,	%rax
    cmp       %rbx,	441992013
    jz        L4782
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10974]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L4782:
    mov       %rcx,	%r14
    call      mlib.pcm_copyheapstring
    mov       [%rbp + mx_lib.readlibfile.lib+184],	%rax
    mov       %rcx,	%r14
    call      mlib.extractbasefile
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rbp + mx_lib.readlibfile.lib+192],	%rax
L4783:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       %rsi,	%rax
    cmp       %rax,	14
    jae       L4786
    lea       %r10,	[%rip+L4785]
    jmp       [%r10 + %rax*8]
    .data
L4785:
    .quad     L4818
    .quad     L4787
    .quad     L4790
    .quad     L4789
    .quad     L4788
    .quad     L4815
    .quad     L4791
    .quad     L4795
    .quad     L4799
    .quad     L4803
    .quad     L4807
    .quad     L4811
    .quad     L4816
    .quad     L4817
    .text
L4787:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       [%rbp + mx_lib.readlibfile.lib],	%rax
    jmp       L4783
L4788:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [%rbp + mx_lib.readlibfile.lib+24],	%rax
    jmp       L4783
L4789:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       [%rbp + mx_lib.readlibfile.lib+16],	%rax
    mov       %rcx,	%r12
    call      mlib.pcm_alloc
    mov       [%rbp + mx_lib.readlibfile.lib+80],	%rax
    mov       %rax,	[%rbp + mx_lib.readlibfile.lib+80]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mx_lib.readlibfile.p]
    mov       %r8,	%r12
    call      memcpy
    mov       %rax,	%r12
    add       [%rbp + mx_lib.readlibfile.p],	%rax
    jmp       L4783
L4790:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       [%rbp + mx_lib.readlibfile.lib+8],	%rax
    mov       %rax,	[%rbp + mx_lib.readlibfile.p]
    mov       [%rbp + mx_lib.readlibfile.lib+72],	%rax
    mov       %rax,	%r12
    add       [%rbp + mx_lib.readlibfile.p],	%rax
    jmp       L4783
L4791:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       [%rbp + mx_lib.readlibfile.lib+40],	%rax
    mov       %rax,	8
    mov       %r10,	%r12
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + mx_lib.readlibfile.lib+96],	%rax
    mov       %r13,	1
    cmp       %r12,	1
    jl        L4794
L4792:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       %r10,	[%rbp + mx_lib.readlibfile.lib+96]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L4792
L4794:
    jmp       L4783
L4795:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       [%rbp + mx_lib.readlibfile.lib+48],	%rax
    mov       %rax,	8
    mov       %r10,	%r12
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + mx_lib.readlibfile.lib+104],	%rax
    mov       %r13,	1
    cmp       %r12,	1
    jl        L4798
L4796:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       %r10,	[%rbp + mx_lib.readlibfile.lib+104]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L4796
L4798:
    jmp       L4783
L4799:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       [%rbp + mx_lib.readlibfile.lib+56],	%rax
    mov       %rax,	8
    mov       %r10,	%r12
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + mx_lib.readlibfile.lib+112],	%rax
    mov       %r13,	1
    cmp       %r12,	1
    jl        L4802
L4800:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       %r10,	[%rbp + mx_lib.readlibfile.lib+112]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L4800
L4802:
    jmp       L4783
L4803:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       [%rbp + mx_lib.readlibfile.lib+64],	%rax
    mov       %rax,	8
    mov       %r10,	%r12
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + mx_lib.readlibfile.lib+120],	%rax
    mov       %r13,	1
    cmp       %r12,	1
    jl        L4806
L4804:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       %r10,	[%rbp + mx_lib.readlibfile.lib+120]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L4804
L4806:
    jmp       L4783
L4807:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       %rcx,	%r12
    call      mlib.pcm_alloc
    mov       [%rbp + mx_lib.readlibfile.lib+128],	%rax
    mov       %r13,	1
    cmp       %r12,	1
    jl        L4810
L4808:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       %r10,	[%rbp + mx_lib.readlibfile.lib+128]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    inc       %r13
    cmp       %r13,	%r12
    jle       L4808
L4810:
    jmp       L4783
L4811:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       %rax,	8
    mov       %r10,	%r12
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + mx_lib.readlibfile.lib+136],	%rax
    mov       %r13,	1
    cmp       %r12,	1
    jl        L4814
L4812:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r10,	[%rbp + mx_lib.readlibfile.lib+136]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L4812
L4814:
    jmp       L4783
L4815:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       %r12,	%rax
    mov       [%rbp + mx_lib.readlibfile.lib+32],	%rax
    mov       %rax,	[%rbp + mx_lib.readlibfile.lib+32]
    shl       %rax,	3
    mov       %r12,	%rax
    mov       %rcx,	%r12
    call      mlib.pcm_alloc
    mov       [%rbp + mx_lib.readlibfile.lib+88],	%rax
    mov       %rax,	[%rbp + mx_lib.readlibfile.lib+88]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mx_lib.readlibfile.p]
    mov       %r8,	%r12
    call      memcpy
    mov       %rax,	%r12
    add       [%rbp + mx_lib.readlibfile.p],	%rax
    jmp       L4783
L4816:
    lea       %rcx,	[%rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [%rbp + mx_lib.readlibfile.lib+144],	%rax
    jmp       L4783
L4817:
    jmp       L4784
L4818:
    jmp       L4783
L4786:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10975]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+mx_decls.mcxdirnames]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    call      exit
    jmp       L4783
L4784:
    mov       %rcx,	216
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + mx_lib.readlibfile.lib]
    mov       %r8,	216
    call      memcpy
    mov       %rax,	%rdi
L4780:
#---------------
    add       %rsp,	256
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.readbyte
mx_lib.readbyte:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    movzx     %r10,	byte ptr[%r10]
    mov       %rax,	%r10
L4819:
#---------------
    ret       
# End 
# Proc mx_lib.readu32
mx_lib.readu32:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rcx]
    mov       %eax,	[%rax]
    mov       %rdi,	%rax
    mov       %rax,	%rcx
    add       qword ptr[%rax],	4
    mov       %rax,	%rdi
L4820:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mx_lib.readstring
mx_lib.readstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
L4822:
L4823:
    mov       %rax,	%rbx
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %al,	[%rax]
    test      %al,	%al
    jnz       L4822
    mov       %rax,	%rbx
    inc       qword ptr[%rax]
    mov       %rax,	%rdi
L4821:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.alloclibdata
mx_lib.alloclibdata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rax,	[%r12+24]
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%r12+152],	%rax
    mov       %rax,	[%r12+56]
    shl       %rax,	4
    mov       %rdi,	%rax
    mov       %rbx,	[%r12+8]
    mov       %rax,	%rbx
    add       %rax,	%rdi
    mov       %rcx,	%rax
    call      mwindows.os_allocexecmem
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L4827
    lea       %rcx,	[%rip+L10976]
    lea       %rdx,	[%rip+L10977]
    call      mx_lib.error
L4827:
    mov       %rax,	[%r12+72]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      memcpy
    lea       %rax,	[%rsi + %rbx]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%rdi
    call      memset
    mov       [%r12+72],	%rsi
    mov       [%r12+160],	%rdi
    mov       %rax,	[%r12+64]
    mov       %r10,	8
    imul      %r10,	%rax
    mov       %rcx,	%r10
    call      mlib.pcm_alloc
    mov       [%r12+168],	%rax
    mov       %rax,	[%r12+56]
    mov       %r10,	2
    imul      %r10,	%rax
    mov       %rcx,	%r10
    call      mlib.pcm_alloc
    mov       [%r12+176],	%rax
    mov       %rax,	[%r12+144]
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jz        L4829
    mov       %rax,	[%r12+72]
    mov       %r10,	[%r12+144]
    lea       %rax,	[%rax + %r10]
    mov       [%r12+200],	%rax
L4829:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.error
mx_lib.error:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rbx]
    test      %al,	%al
    jz        L4832
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4831
L4832:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4831:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10978]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.loadmemmcu
mx_lib.loadmemmcu:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	[%rsi+192]
    mov       %rax,	[%rsi+184]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mx_lib.checknew
    mov       %rcx,	%rbx
    call      mx_lib.mxaddlib
    mov       %rdi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mx_decls.libtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rcx,	%rsi
    call      mx_lib.loadimports
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.checknew
mx_lib.checknew:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    call      mx_lib.findlib
    test      %rax,	%rax
    jz        L4836
    lea       %rcx,	[%rip+L10979]
    mov       %rdx,	%rbx
    call      mx_lib.error
L4836:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.findlib
mx_lib.findlib:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mx_decls.nlibs]
    cmp       %rax,	1
    jl        L4840
L4838:
    lea       %rax,	[%rip+mx_decls.libnametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4842
    mov       %rax,	%rdi
    jmp       L4837
L4842:
    inc       %rdi
    cmp       %rdi,	[%rip+mx_decls.nlibs]
    jle       L4838
L4840:
    xor       %eax,	%eax
L4837:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.mxaddlib
mx_lib.mxaddlib:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mx_decls.nlibs]
    cmp       %rax,	20
    jl        L4845
    lea       %rcx,	[%rip+L10980]
    lea       %rdx,	[%rip+L10981]
    call      mx_lib.error
L4845:
    inc       qword ptr[%rip+mx_decls.nlibs]
    mov       %rax,	[%rip+mx_decls.nlibs]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+mx_decls.libnametable]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rax,	[%rip+mx_decls.nlibs]
L4843:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mx_lib.fixuplib
mx_lib.fixuplib:
#?>>
    .set mx_lib.fixuplib.lib, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mx_lib.loaddlls
    call      mx_lib.checksymbols
    call      mx_lib.dorelocations
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mx_lib.loaddlls
mx_lib.loaddlls:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rbx,	1
    mov       %rax,	[%rip+mx_decls.ndlllibs]
    cmp       %rax,	1
    jl        L4850
L4848:
    lea       %rax,	[%rip+mx_decls.dllinsttable]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    test      %rax,	%rax
    jnz       L4852
    lea       %rax,	[%rip+mx_decls.dllnametable]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    call      mwindows.os_getdllinst
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L4854
    lea       %rax,	[%rip+mx_decls.dllnametable]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+L10982]
    mov       %rdx,	%rax
    call      mx_lib.error
L4854:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mx_decls.dllinsttable]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
L4852:
    inc       %rbx
    cmp       %rbx,	[%rip+mx_decls.ndlllibs]
    jle       L4848
L4850:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.finddllsymbol
mx_lib.finddllsymbol:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %eax,	%eax
    mov       [%r12],	%rax
    mov       %rbx,	1
    mov       %rax,	[%rip+mx_decls.ndlllibs]
    cmp       %rax,	1
    jl        L4858
L4856:
    lea       %rax,	[%rip+mx_decls.dllinsttable]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mwindows.os_getdllprocaddr
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4860
    mov       [%r12],	%rbx
    mov       %rax,	%rdi
    jmp       L4855
L4860:
    inc       %rbx
    cmp       %rbx,	[%rip+mx_decls.ndlllibs]
    jle       L4856
L4858:
    xor       %eax,	%eax
L4855:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.checksymbols
mx_lib.checksymbols:
#?>>
    .set mx_lib.checksymbols.dllindex, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	1
    mov       %rsi,	%rax
    mov       %rax,	[%rip+mx_decls.nsymbols]
    cmp       %rax,	1
    jl        L4864
L4862:
    lea       %rax,	[%rip+mx_decls.symboldefined]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L4866
    lea       %rax,	[%rip+mx_decls.symbolnametable]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + mx_lib.checksymbols.dllindex]
    call      mx_lib.finddllsymbol
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L4868
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mx_decls.symboladdress]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rbp + mx_lib.checksymbols.dllindex]
    lea       %r10,	[%rip+mx_decls.symboldllindex]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mx_decls.symboldefined]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    jmp       L4867
L4868:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10983]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+mx_decls.symbolnametable]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
L4867:
L4866:
    inc       %rsi
    cmp       %rsi,	[%rip+mx_decls.nsymbols]
    jle       L4862
L4864:
    test      %rdi,	%rdi
    jz        L4870
L4870:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.dorelocations
mx_lib.dorelocations:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mx_decls.nlibs]
    cmp       %rax,	1
    jl        L4874
L4872:
    lea       %rax,	[%rip+mx_decls.librelocated]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L4876
    lea       %rax,	[%rip+mx_decls.libtable]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      mx_lib.reloclib
L4876:
    inc       %rdi
    cmp       %rdi,	[%rip+mx_decls.nlibs]
    jle       L4872
L4874:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mx_lib.reloclib
mx_lib.reloclib:
#?>>
    .set mx_lib.reloclib.lib, 72
    .set mx_lib.reloclib.r, -8
    .set mx_lib.reloclib.av_2, -16
    .set mx_lib.reloclib.i, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+72]
    mov       %r10,	[%rbp + mx_lib.reloclib.lib]
    mov       %r10,	[%r10+8]
    lea       %rax,	[%rax + %r10]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+56]
    shl       %rax,	3
    lea       %r10,	[%r12 + %rax]
    mov       %r14,	%r10
    mov       %rax,	1
    mov       [%rbp + mx_lib.reloclib.i],	%rax
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %r15,	[%rax+56]
    cmp       %r15,	1
    jl        L4880
L4878:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+112]
    mov       %r10,	[%rbp + mx_lib.reloclib.i]
    mov       %rsi,	[%rax + %r10*8-8]
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	72
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	255
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	36
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	37
    mov       [%rax],	%r10b
    mov       [%r12],	%r14d
    add       %r12,	4
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+176]
    mov       %r10,	[%rbp + mx_lib.reloclib.i]
    movsx     %rax,	word ptr[%rax + %r10*2-2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mx_decls.symboladdress]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %r10,	%r14
    add       %r14,	8
    mov       [%r10],	%rax
    mov       %rax,	[%rbp + mx_lib.reloclib.i]
    inc       %rax
    mov       [%rbp + mx_lib.reloclib.i],	%rax
    cmp       %rax,	%r15
    jle       L4878
L4880:
    mov       %rax,	1
    mov       [%rbp + mx_lib.reloclib.i],	%rax
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+32]
    mov       [%rbp + mx_lib.reloclib.av_2],	%rax
    mov       %rax,	[%rbp + mx_lib.reloclib.av_2]
    cmp       %rax,	1
    jl        L4883
L4881:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+88]
    mov       %r10,	[%rbp + mx_lib.reloclib.i]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + mx_lib.reloclib.r],	%rax
    movzx     %rax,	byte ptr[%rbp + mx_lib.reloclib.r+6]
    cmp       %rax,	1
    jz        L4885
    cmp       %rax,	2
    jz        L4886
    cmp       %rax,	3
    jz        L4887
    jmp       L4888
L4885:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+72]
    mov       %r10d,	[%rbp + mx_lib.reloclib.r]
    lea       %rax,	[%rax + %r10]
    mov       %r12,	%rax
    jmp       L4884
L4886:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+80]
    mov       %r10d,	[%rbp + mx_lib.reloclib.r]
    lea       %rax,	[%rax + %r10]
    mov       %r12,	%rax
    jmp       L4884
L4887:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+152]
    mov       %r10d,	[%rbp + mx_lib.reloclib.r]
    lea       %rax,	[%rax + %r10]
    mov       %r12,	%rax
L4888:
L4884:
    movzx     %rax,	byte ptr[%rbp + mx_lib.reloclib.r+7]
    cmp       %rax,	1
    jz        L4890
    cmp       %rax,	2
    jz        L4891
    cmp       %rax,	4
    jz        L4892
    cmp       %rax,	3
    jz        L4893
    cmp       %rax,	5
    jz        L4894
    jmp       L4895
L4890:
    mov       %eax,	[%r12]
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbp + mx_lib.reloclib.r+4]
    cmp       %rax,	1
    jz        L4897
    cmp       %rax,	2
    jz        L4898
    cmp       %rax,	3
    jz        L4899
    jmp       L4900
L4897:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+72]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       [%r12],	%eax
    jmp       L4896
L4898:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+80]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       [%r12],	%eax
    jmp       L4896
L4899:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+152]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       [%r12],	%eax
L4900:
L4896:
    jmp       L4889
L4891:
    mov       %eax,	[%r12]
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbp + mx_lib.reloclib.r+4]
    cmp       %rax,	1
    jz        L4902
    cmp       %rax,	2
    jz        L4903
    cmp       %rax,	3
    jz        L4904
    jmp       L4905
L4902:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+72]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       [%r12],	%rax
    jmp       L4901
L4903:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+80]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       [%r12],	%rax
    jmp       L4901
L4904:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+152]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       [%r12],	%rax
L4905:
L4901:
    jmp       L4889
L4892:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+176]
    movzx     %r10,	word ptr[%rbp + mx_lib.reloclib.r+4]
    movsx     %rax,	word ptr[%rax + %r10*2-2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mx_decls.symboladdress]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %r10,	%r12
    add       [%r10],	%rax
    jmp       L4889
L4893:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+176]
    movzx     %r10,	word ptr[%rbp + mx_lib.reloclib.r+4]
    movsx     %rax,	word ptr[%rax + %r10*2-2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mx_decls.symboladdress]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %r10,	%r12
    add       [%r10],	%eax
    jmp       L4889
L4894:
    movzx     %rax,	byte ptr[%rbp + mx_lib.reloclib.r+6]
    cmp       %rax,	1
    jz        L4907
    lea       %rcx,	[%rip+L10984]
    lea       %rdx,	[%rip+L10985]
    call      mx_lib.error
L4907:
    movzx     %rax,	word ptr[%rbp + mx_lib.reloclib.r+4]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+72]
    mov       %r10,	[%rbp + mx_lib.reloclib.lib]
    mov       %r10,	[%r10+8]
    lea       %rax,	[%rax + %r10]
    lea       %r10,	[%rdi-1]
    shl       %r10,	3
    lea       %rax,	[%rax + %r10]
    mov       %r13,	%rax
    lea       %rax,	[%r12+4]
    mov       %r10,	%r13
    sub       %r10,	%rax
    mov       [%r12],	%r10d
L4895:
L4889:
    mov       %rax,	[%rbp + mx_lib.reloclib.i]
    inc       %rax
    mov       [%rbp + mx_lib.reloclib.i],	%rax
    cmp       %rax,	[%rbp + mx_lib.reloclib.av_2]
    jle       L4881
L4883:
    mov       %rax,	[%rbp + mx_lib.reloclib.lib]
    mov       %rax,	[%rax+208]
    mov       %r10b,	1
    lea       %r11,	[%rip+mx_decls.librelocated]
    mov       [%r11 + %rax-1],	%r10b
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.loadimports
mx_lib.loadimports:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rdi,	[%rsi+48]
    cmp       %rdi,	1
    jl        L4911
L4909:
    mov       %rax,	[%rsi+104]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8-8]
    call      mx_lib.dosublib
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L4909
L4911:
    mov       %rcx,	%rsi
    call      mx_lib.alloclibdata
    mov       %rcx,	%rsi
    call      mx_lib.dosymbols
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.dosublib
mx_lib.dosublib:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      mx_lib.findlib
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4914
    mov       %rcx,	%rsi
    call      mx_lib.mxaddlib
    mov       %rbx,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10986]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L10987]
    call      mlib.addext
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    call      mx_lib.loadlibfile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mx_lib.loadimports
L4914:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.loadlibfile
mx_lib.loadlibfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    call      mx_lib.readmxfile
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4917
    lea       %rcx,	[%rip+L10988]
    mov       %rdx,	%rsi
    call      mx_lib.error
L4917:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mx_lib.readlibfile
    mov       %rdi,	%rax
    mov       [%rdi+208],	%r12
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mx_decls.libtable]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
L4915:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.dosymbols
mx_lib.dosymbols:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
    mov       %r14,	1
    mov       %rsi,	[%r15+40]
    cmp       %rsi,	1
    jl        L4921
L4919:
    mov       %rax,	[%r15+96]
    mov       %r10,	%r14
    mov       %rcx,	[%rax + %r10*8-8]
    call      mx_lib.adddll
    inc       %r14
    cmp       %r14,	%rsi
    jle       L4919
L4921:
    mov       %r14,	1
    mov       %r12,	[%r15+56]
    cmp       %r12,	1
    jl        L4924
L4922:
    mov       %rax,	[%r15+112]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    call      mx_lib.addsymbol
    mov       %rdi,	%rax
    mov       %rax,	[%r15+176]
    mov       %r10w,	%di
    mov       %r11,	%r14
    mov       [%rax + %r11*2-2],	%r10w
    inc       %r14
    cmp       %r14,	%r12
    jle       L4922
L4924:
    mov       %r14,	1
    mov       %r13,	[%r15+64]
    cmp       %r13,	1
    jl        L4927
L4925:
    mov       %rax,	[%r15+120]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    call      mx_lib.addsymbol
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mx_decls.symboldefined]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L4929
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L10989]
    call      msys.m$print_str_nf
    mov       %rax,	[%r15+120]
    mov       %r10,	%r14
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4926
L4929:
    mov       %al,	1
    lea       %r10,	[%rip+mx_decls.symboldefined]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%r15+128]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L4931
    cmp       %rax,	2
    jz        L4932
    cmp       %rax,	3
    jz        L4933
    jmp       L4934
L4931:
    mov       %rbx,	[%r15+72]
    jmp       L4930
L4932:
    mov       %rbx,	[%r15+80]
    jmp       L4930
L4933:
    mov       %rbx,	[%r15+152]
    jmp       L4930
L4934:
    xor       %rbx,	%rbx
L4930:
    mov       %rax,	[%r15+136]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rbx + %rax]
    lea       %rax,	[%rip+mx_decls.symboladdress]
    mov       %r11,	%rdi
    mov       [%rax + %r11*8-8],	%r10
    mov       %rax,	[%r15+208]
    lea       %r10,	[%rip+mx_decls.symbollibindex]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2-2],	%ax
L4926:
    inc       %r14
    cmp       %r14,	%r13
    jle       L4925
L4927:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.readmxfile
mx_lib.readmxfile:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mlib.readfile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L4937
    xor       %eax,	%eax
    jmp       L4935
L4937:
    mov       %al,	13
    mov       %r10,	[%rip+mlib.rfsize]
    mov       [%rdi + %r10],	%al
    mov       %rax,	%rdi
L4935:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.adddll
mx_lib.adddll:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mx_decls.ndlllibs]
    cmp       %rax,	1
    jl        L4941
L4939:
    lea       %rax,	[%rip+mx_decls.dllnametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L4938
L4943:
    inc       %rdi
    cmp       %rdi,	[%rip+mx_decls.ndlllibs]
    jle       L4939
L4941:
    mov       %rax,	[%rip+mx_decls.ndlllibs]
    cmp       %rax,	20
    jl        L4945
    lea       %rcx,	[%rip+L10990]
    lea       %rdx,	[%rip+L10991]
    call      mx_lib.error
L4945:
    inc       qword ptr[%rip+mx_decls.ndlllibs]
    mov       %rax,	[%rip+mx_decls.ndlllibs]
    mov       %r10,	%rbx
    lea       %r11,	[%rip+mx_decls.dllnametable]
    mov       [%r11 + %rax*8-8],	%r10
L4938:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.addsymbol
mx_lib.addsymbol:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mx_decls.nsymbols]
    cmp       %rax,	1
    jl        L4949
L4947:
    lea       %rax,	[%rip+mx_decls.symbolnametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4951
    mov       %rax,	%rdi
    jmp       L4946
L4951:
    inc       %rdi
    cmp       %rdi,	[%rip+mx_decls.nsymbols]
    jle       L4947
L4949:
    mov       %rax,	[%rip+mx_decls.nsymbols]
    cmp       %rax,	3000
    jl        L4953
    lea       %rcx,	[%rip+L10992]
    lea       %rdx,	[%rip+L10993]
    call      mx_lib.error
L4953:
    inc       qword ptr[%rip+mx_decls.nsymbols]
    mov       %rax,	[%rip+mx_decls.nsymbols]
    mov       %r10,	%rbx
    lea       %r11,	[%rip+mx_decls.symbolnametable]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rax,	[%rip+mx_decls.nsymbols]
L4946:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.setspecialglobals
mx_lib.setspecialglobals:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mx_decls.nsymbols]
    cmp       %rax,	1
    jl        L4957
L4955:
    lea       %rax,	[%rip+mx_decls.symbolnametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10994]
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L4960
    lea       %rax,	[%rip+mx_decls.symbolnametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L10995]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4959
L4960:
    lea       %rax,	[%rip+mx_decls.symboladdress]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
L4959:
    inc       %rdi
    cmp       %rdi,	[%rip+mx_decls.nsymbols]
    jle       L4955
L4957:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.runprogram
mx_lib.runprogram:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rbx,	[%r12+208]
    mov       %rsi,	1
    mov       %rax,	[%rip+mx_decls.nlibs]
    cmp       %rax,	1
    jl        L4964
L4962:
    cmp       %rsi,	%rbx
    jz        L4966
    lea       %rax,	[%rip+mx_decls.libinitdone]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L4966
    lea       %rax,	[%rip+mx_decls.libtable]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8-8]
    call      mx_lib.calllibinit
L4966:
    inc       %rsi
    cmp       %rsi,	[%rip+mx_decls.nlibs]
    jle       L4962
L4964:
    mov       %rax,	[%r12+200]
    test      %rax,	%rax
    jnz       L4968
    lea       %rcx,	[%rip+L10996]
    lea       %rdx,	[%rip+L10997]
    call      mx_lib.error
L4968:
    mov       %rcx,	%r13
    call      mx_lib.setspecialglobals
    mov       %rdi,	[%r12+200]
    mov       %rax,	%rdi
    call      %rax
    mov       %al,	1
    lea       %r10,	[%rip+mx_decls.libinitdone]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.calllibinit
mx_lib.calllibinit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	[%rsi+208]
    mov       %rax,	[%rsi+200]
    test      %rax,	%rax
    jz        L4971
    mov       %rdi,	[%rsi+200]
    mov       %rax,	%rdi
    call      %rax
L4971:
    mov       %rax,	[%rsi+208]
    mov       %r10b,	1
    lea       %r11,	[%rip+mx_decls.libinitdone]
    mov       [%r11 + %rax-1],	%r10b
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.findsymbol
mx_lib.findsymbol:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mx_decls.nsymbols]
    cmp       %rax,	1
    jl        L4975
L4973:
    lea       %rax,	[%rip+mx_decls.symbolnametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4977
    lea       %rax,	[%rip+mx_decls.symboladdress]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L4972
L4977:
    inc       %rdi
    cmp       %rdi,	[%rip+mx_decls.nsymbols]
    jle       L4973
L4975:
    xor       %eax,	%eax
L4972:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.loadmx
mx_lib.loadmx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      mlib.extractbasefile
    mov       %rcx,	%rax
    call      mlib.convlcstring
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       %rsi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mx_lib.checknew
    mov       %rcx,	%rsi
    call      mx_lib.mxaddlib
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      mx_lib.loadlibfile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mx_lib.loadimports
    mov       %rax,	%rdi
L4978:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_lib.loadmemmcb
mx_lib.loadmemmcb:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rcx,	%r12
    call      mlib.extractbasefile
    mov       %rcx,	%rax
    call      mlib.convlcstring
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       %rsi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mx_lib.checknew
    mov       %rcx,	%rsi
    call      mx_lib.mxaddlib
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      mx_lib.readlibfile
    mov       %rdi,	%rax
    mov       [%rdi+208],	%rbx
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mx_decls.libtable]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rcx,	%rdi
    call      mx_lib.loadimports
    mov       %rax,	%rdi
L4979:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_write.writemcx
mx_write.writemcx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	[%rip+mc_decls.ss_zdatalen]
    mov       %rdx,	8
    call      mlib.roundtoblock
    mov       [%rip+mc_decls.ss_zdatalen],	%rax
    mov       %rcx,	[%rip+mc_decls.ss_code]
    mov       %rdx,	8
    mov       %r8,	144
    call      mx_write.roundsegment
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mx_write.roundsegment
    mov       %rcx,	1024
    call      mc_genss.buffercreate
    mov       [%rip+mx_write.dest],	%rax
    mov       %rcx,	441992013
    call      mx_write.genu32
    mov       %rcx,	1
    call      mx_write.genbyte
    lea       %rcx,	[%rip+L10998]
    call      mx_write.genstring
    call      mx_run.countsymbols
    call      mx_write.writerelocs
    mov       %rcx,	4
    call      mx_write.genbyte
    mov       %rcx,	[%rip+mc_decls.ss_zdatalen]
    call      mx_write.genu32
    mov       %rcx,	2
    call      mx_write.genbyte
    mov       %rcx,	[%rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rax
    call      mx_write.genu32
    mov       %rcx,	[%rip+mc_decls.ss_code]
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mx_write.genblock
    mov       %rcx,	3
    call      mx_write.genbyte
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rax
    call      mx_write.genu32
    mov       %rcx,	[%rip+mc_decls.ss_idata]
    xor       %edx,	%edx
    call      mc_genss.bufferelemptr
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mx_write.genblock
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %rsi,	%rax
    mov       %r12,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L4983
L4981:
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L4985
    inc       %rbx
L4985:
    inc       %r12
    cmp       %r12,	[%rip+pc_decls.nplibfiles]
    jle       L4981
L4983:
    mov       %rcx,	6
    call      mx_write.genbyte
    mov       %rcx,	%rbx
    call      mx_write.genu32
    mov       %r12,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L4988
L4986:
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L4990
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8-8]
    call      mx_write.genstring
L4990:
    inc       %r12
    cmp       %r12,	[%rip+pc_decls.nplibfiles]
    jle       L4986
L4988:
    call      mx_write.writesymbols
    mov       %rcx,	13
    call      mx_write.genbyte
    mov       %rax,	[%rip+mx_write.dest]
    mov       %rax,	[%rax+8]
    mov       %r10,	[%rip+mx_write.dest]
    mov       %r10,	[%r10]
    sub       %rax,	%r10
    mov       %r10,	[%rip+mx_write.dest]
    mov       %r10,	[%r10]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_write.writerelocs
mx_write.writerelocs:
#?>>
    .set mx_write.writerelocs.newr, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rcx,	5
    call      mx_write.genbyte
    mov       %rax,	[%rip+mc_decls.ss_nidatarelocs]
    add       %rax,	[%rip+mc_decls.ss_ncoderelocs]
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	%rax
    call      mx_write.genu32
    xor       %rsi,	%rsi
    mov       %rax,	1
    mov       %r14,	%rax
L4992:
    cmp       %r14,	1
    jnz       L4996
    mov       %rax,	[%rip+mc_decls.ss_idatarelocs]
    jmp       L4995
L4996:
    mov       %rax,	[%rip+mc_decls.ss_coderelocs]
L4995:
    mov       %rdi,	%rax
    jmp       L5000
L4997:
    inc       %rsi
    lea       %rax,	[%rbp + mx_write.writerelocs.newr]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       %rax,	[%rdi+16]
    mov       [%rbp + mx_write.writerelocs.newr],	%eax
    cmp       %r14,	1
    jnz       L5002
    mov       %rax,	2
    jmp       L5001
L5002:
    mov       %rax,	1
L5001:
    mov       [%rbp + mx_write.writerelocs.newr+6],	%al
    mov       %rax,	[%rdi+24]
    mov       %r10,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %r12,	%r10
    mov       %rax,	[%rdi+8]
    cmp       %rax,	4
    jz        L5004
    cmp       %rax,	2
    jz        L5005
    cmp       %rax,	1
    jz        L5005
    jmp       L5006
L5004:
    mov       %al,	[%r12+80]
    test      %al,	%al
    jz        L5008
    mov       %ax,	[%r12+116]
    mov       [%rbp + mx_write.writerelocs.newr+4],	%ax
    mov       %al,	5
    mov       [%rbp + mx_write.writerelocs.newr+7],	%al
    jmp       L5007
L5008:
    lea       %rcx,	[%rip+L10999]
    call      mc_libmcl.axerror
L5007:
    jmp       L5003
L5005:
    mov       %al,	[%r12+80]
    test      %al,	%al
    jz        L5010
    mov       %rax,	[%rdi+8]
    cmp       %rax,	2
    jnz       L5012
    mov       %rax,	3
    jmp       L5011
L5012:
    mov       %rax,	4
L5011:
    mov       [%rbp + mx_write.writerelocs.newr+7],	%al
    mov       %ax,	[%r12+116]
    mov       [%rbp + mx_write.writerelocs.newr+4],	%ax
    jmp       L5009
L5010:
    mov       %rax,	[%rdi+8]
    cmp       %rax,	2
    jnz       L5014
    mov       %al,	1
    mov       [%rbp + mx_write.writerelocs.newr+7],	%al
    jmp       L5013
L5014:
    mov       %al,	2
    mov       [%rbp + mx_write.writerelocs.newr+7],	%al
L5013:
    mov       %al,	[%r12+94]
    mov       [%rbp + mx_write.writerelocs.newr+4],	%al
L5009:
    jmp       L5003
L5006:
    lea       %rcx,	[%rip+L11000]
    call      mc_libmcl.axerror
L5003:
    lea       %rcx,	[%rbp + mx_write.writerelocs.newr]
    mov       %rdx,	8
    call      mx_write.genblock
    mov       %rdi,	[%rdi]
L5000:
    test      %rdi,	%rdi
    jnz       L4997
    inc       %r14
    cmp       %r14,	2
    jle       L4992
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_write.writesymbols
mx_write.writesymbols:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	8
    call      mx_write.genbyte
    mov       %rcx,	[%rip+mx_decls.nsymimports]
    call      mx_write.genu32
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L5018
L5016:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %ax,	[%rax+116]
    test      %ax,	%ax
    jz        L5020
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	[%rdi]
    call      mx_write.genstring
L5020:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.ss_nsymbols]
    jle       L5016
L5018:
    mov       %rcx,	9
    call      mx_write.genbyte
    mov       %rcx,	[%rip+mx_decls.nsymexports]
    call      mx_write.genu32
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L5023
L5021:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %ax,	[%rdi+118]
    test      %ax,	%ax
    jz        L5025
    mov       %al,	[%rdi+83]
    test      %al,	%al
    jz        L5027
    mov       [%rip+mx_write.entrypoint],	%rdi
L5027:
    mov       %rcx,	[%rdi]
    call      mx_write.genstring
L5025:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.ss_nsymbols]
    jle       L5021
L5023:
    mov       %rcx,	10
    call      mx_write.genbyte
    mov       %rcx,	[%rip+mx_decls.nsymexports]
    call      mx_write.genu32
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L5030
L5028:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %ax,	[%rdi+118]
    test      %ax,	%ax
    jz        L5032
    movzx     %rax,	byte ptr[%rdi+94]
    mov       %rcx,	%rax
    call      mx_write.genbyte
L5032:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.ss_nsymbols]
    jle       L5028
L5030:
    mov       %rcx,	11
    call      mx_write.genbyte
    mov       %rcx,	[%rip+mx_decls.nsymexports]
    call      mx_write.genu32
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.ss_nsymbols]
    cmp       %rax,	1
    jl        L5035
L5033:
    mov       %rax,	[%rip+mc_decls.ss_symboltable]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %ax,	[%rdi+118]
    test      %ax,	%ax
    jz        L5037
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %rcx,	%rax
    call      mx_write.genu32
L5037:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.ss_nsymbols]
    jle       L5033
L5035:
    mov       %rcx,	12
    call      mx_write.genbyte
    mov       %rax,	[%rip+mx_write.entrypoint]
    test      %rax,	%rax
    jz        L5039
    mov       %rax,	[%rip+mx_write.entrypoint]
    movsxd    %rax,	dword ptr[%rax+76]
    mov       %rcx,	%rax
    call      mx_write.genu32
    jmp       L5038
L5039:
    mov       %rcx,	4294967295
    call      mx_write.genu32
L5038:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_write.roundsegment
mx_write.roundsegment:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rcx,	%r12
    call      mc_genss.bufferlength
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    call      mlib.roundtoblock
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      mc_genss.buffercheck
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L5043
L5041:
    lea       %rax,	[%r12+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%r14b
    dec       %rsi
    jnz       L5041
L5043:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mx_write.genbyte
mx_write.genbyte:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+mx_write.dest]
    mov       %rdx,	1
    call      mc_genss.buffercheck
    mov       %rax,	[%rip+mx_write.dest]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    inc       qword ptr[%rax]
    mov       [%r10],	%dil
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mx_write.genu32
mx_write.genu32:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+mx_write.dest]
    mov       %rdx,	4
    call      mc_genss.buffercheck
    mov       %rax,	[%rip+mx_write.dest]
    lea       %rax,	[%rax+8]
    mov       %r10,	[%rax]
    add       qword ptr[%rax],	4
    mov       [%r10],	%edi
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mx_write.genstring
mx_write.genstring:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      strlen
    inc       %rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mx_write.genblock
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mx_write.genblock
mx_write.genblock:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	[%rip+mx_write.dest]
    mov       %rdx,	%rbx
    call      mc_genss.buffercheck
    mov       %rax,	[%rip+mx_write.dest]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	[%rip+mx_write.dest]
    lea       %rax,	[%rax+8]
    mov       %r10,	%rbx
    add       [%rax],	%r10
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.main
cc_cli.main:
main:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msyswin.start
    call      pcl.start
    call      mwindows.os_clock
    mov       [%rip+cc_cli.startclock],	%rax
    mov       %rax,	[%rip+cc_cli.startclock]
    mov       [%rip+pc_decls.pstartclock],	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11001]
    call      msys.m$print_str_nf
    mov       %rcx,	138
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.starttiming
    call      cc_cli.initdata
    call      cc_cli.getinputoptions
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11001]
    call      msys.m$print_str_nf
    mov       %rcx,	144
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.initsearchdirs
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11001]
    call      msys.m$print_str_nf
    mov       %rcx,	147
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L5050
    call      cc_cli.showsearchdirs
L5050:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11001]
    call      msys.m$print_str_nf
    mov       %rcx,	151
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.initlogfile
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11001]
    call      msys.m$print_str_nf
    mov       %rcx,	153
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.inittime],	%rax
    mov       %al,	[%rip+cc_cli.fverbose]
    test      %al,	%al
    jz        L5052
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11002]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5052:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11003]
    call      msys.m$print_str_nf
    mov       %rcx,	160
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+pc_decls.$pmodulename],	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11003]
    call      msys.m$print_str_nf
    mov       %rcx,	162
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.do_loadmodule
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11003]
    call      msys.m$print_str_nf
    mov       %rcx,	165
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.do_preprocess
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11003]
    call      msys.m$print_str_nf
    mov       %rcx,	168
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.do_parsemodule
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11003]
    call      msys.m$print_str_nf
    mov       %rcx,	171
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.do_genpcl
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11003]
    call      msys.m$print_str_nf
    mov       %rcx,	174
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	6
    jz        L5054
    cmp       %rax,	7
    jz        L5055
    cmp       %rax,	8
    jz        L5056
    cmp       %rax,	10
    jz        L5057
    cmp       %rax,	11
    jz        L5058
    cmp       %rax,	12
    jz        L5059
    cmp       %rax,	9
    jz        L5060
    cmp       %rax,	13
    jz        L5061
    jmp       L5062
L5054:
    call      pc_run.pcl_runpcl
    jmp       L5053
L5055:
    call      cc_cli.do_genmcl
    jmp       L5053
L5056:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11003]
    call      msys.m$print_str_nf
    mov       %rcx,	185
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.do_asm
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11003]
    call      msys.m$print_str_nf
    mov       %rcx,	187
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L5053
L5057:
    call      cc_cli.do_obj
    jmp       L5053
L5058:
    call      cc_cli.do_dll
    jmp       L5053
L5059:
    call      cc_cli.do_exe
    jmp       L5053
L5060:
    call      cc_cli.do_mx
    jmp       L5053
L5061:
    call      cc_cli.do_run
    jmp       L5053
L5062:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L5064
    call      msys.m$print_startcon
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    lea       %r10,	[%rip+cc_cli.passnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11004]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5064:
L5053:
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	2
    jl        L5066
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11005]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5066:
    mov       %al,	[%rip+cc_cli.fshowtiming]
    test      %al,	%al
    jz        L5068
    call      cc_cli.showtiming
L5068:
    call      cc_cli.closelogfile
    xor       %ecx,	%ecx
    call      exit
    xor       %ecx,	%ecx
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_preprocess
cc_cli.do_preprocess:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	2
    jnz       L5071
    movzx     %rax,	byte ptr[%rip+cc_cli.fstdout]
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_cli.outfile]
    mov       %r8,	%rax
    call      cc_lex.lex_preprocess_only
    xor       %ecx,	%ecx
    call      exit
L5071:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_loadmodule
cc_cli.do_loadmodule:
#?>>
    .set cc_cli.do_loadmodule.path, -304
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L5074
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11006]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5074:
    call      cc_cli.starttiming
    lea       %rax,	[%rip+L11007]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+L11008]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+L11009]
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       [%r10],	%eax
    lea       %rcx,	[%rip+L11010]
    call      cc_lex.addnamestr
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	2
    call      cc_lib.createdupldef
    mov       [%rip+cc_decls.stprogram],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.checkfile
    test      %rax,	%rax
    jnz       L5076
    lea       %rcx,	[%rip+L11011]
    mov       %rdx,	[%rip+cc_decls.inputfile]
    call      cc_support.loaderror
L5076:
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_decls.inputfile]
    call      cc_support.loadsourcefile
    mov       [%rip+cc_decls.mainfileno],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_lex.addnamestr
    mov       %rcx,	[%rip+cc_decls.stprogram]
    mov       %rdx,	%rax
    mov       %r8,	3
    call      cc_lib.createdupldef
    mov       [%rip+cc_decls.stmodule],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractpath
    lea       %rcx,	[%rbp + cc_cli.do_loadmodule.path]
    mov       %rdx,	%rax
    call      strcpy
    mov       %al,	[%rbp + cc_cli.do_loadmodule.path]
    test      %al,	%al
    jz        L5078
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rbx,	[%rip+cc_decls.nsearchdirs]
    cmp       %rbx,	2
    jl        L5081
L5079:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-16]
    lea       %r10,	[%rip+cc_decls.searchdirs]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    dec       %rbx
    cmp       %rbx,	2
    jge       L5079
L5081:
    lea       %rcx,	[%rbp + cc_cli.do_loadmodule.path]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.searchdirs]
    mov       [%r10],	%rax
L5078:
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.loadtime],	%rax
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_parsemodule
cc_cli.do_parsemodule:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_cli.starttiming
    call      cc_parse.parsemodule
    call      cc_cli.gettiming
    mov       %rdi,	%rax
    mov       [%rip+cc_cli.parsetime],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_genpcl
cc_cli.do_genpcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jl        L5083
L5085:
    call      cc_cli.starttiming
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11012]
    call      msys.m$print_str_nf
    mov       %rcx,	290
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_genpcl.codegen_pcl
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11012]
    call      msys.m$print_str_nf
    mov       %rcx,	292
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.pcltime],	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11012]
    call      msys.m$print_str_nf
    mov       %rcx,	294
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jnz       L5088
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L5087
L5088:
    call      pc_reduce.pcl_reducetest
L5087:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11012]
    call      msys.m$print_str_nf
    mov       %rcx,	297
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jnz       L5090
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11012]
    call      msys.m$print_str_nf
    mov       %rcx,	303
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writepcl
L5090:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11012]
    call      msys.m$print_str_nf
    mov       %rcx,	306
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5083:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_genmcl
cc_cli.do_genmcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L5091
L5093:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jnz       L5095
    mov       %rcx,	[%rip+cc_cli.outfile]
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
L5095:
L5091:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_asm
cc_cli.do_asm:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	8
    jl        L5096
L5098:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11012]
    call      msys.m$print_str_nf
    mov       %rcx,	324
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_cli.outfile]
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11012]
    call      msys.m$print_str_nf
    mov       %rcx,	326
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5096:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_obj
cc_cli.do_obj:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	10
    jnz       L5099
L5101:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writeobj
L5099:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_dll
cc_cli.do_dll:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	11
    jnz       L5102
L5104:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writedll
L5102:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_exe
cc_cli.do_exe:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	12
    jnz       L5105
L5107:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writeexe
L5105:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_mx
cc_cli.do_mx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	9
    jnz       L5108
L5110:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writemx
L5108:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_run
cc_cli.do_run:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	13
    jnz       L5111
L5113:
    call      pc_api.pcl_exec
L5111:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.initlogfile
cc_cli.initlogfile:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.debugmode]
    cmp       %rax,	2
    jl        L5116
    lea       %rcx,	[%rip+L11013]
    call      remove
    lea       %rcx,	[%rip+L11013]
    lea       %rdx,	[%rip+L11014]
    call      fopen
    mov       [%rip+cc_decls.logdev],	%rax
L5116:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.closelogfile
cc_cli.closelogfile:
#?>>
    .set cc_cli.closelogfile.str, -104
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	144
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.debugmode]
    cmp       %rax,	2
    jl        L5117
L5119:
    mov       %al,	[%rip+cc_cli.fshowmcl]
    test      %al,	%al
    jz        L5121
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L5121
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11015]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       %ecx,	%ecx
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5121:
    mov       %al,	[%rip+cc_cli.fshowpcl]
    test      %al,	%al
    jz        L5123
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jl        L5123
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11016]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       %ecx,	%ecx
    call      pc_api.pcl_writepcl
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+cc_cli.fshowpst]
    test      %al,	%al
    jz        L5125
    lea       %rcx,	[%rip+L11017]
    call      pc_api.pcl_writepst
    lea       %rcx,	[%rip+L11017]
    mov       %rdx,	[%rip+cc_decls.logdev]
    call      cc_lib.addtolog
L5125:
L5123:
    call      cc_cli.showast
    mov       %al,	[%rip+cc_cli.fshowst]
    test      %al,	%al
    jz        L5127
    lea       %rcx,	[%rip+L11018]
    call      cc_cli.showst
L5127:
    mov       %al,	[%rip+cc_cli.fshowstflat]
    test      %al,	%al
    jz        L5129
    lea       %rcx,	[%rip+L11019]
    call      cc_cli.showstflat
L5129:
    mov       %al,	[%rip+cc_cli.fshowtypes]
    test      %al,	%al
    jz        L5131
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      cc_show.printmodelist
L5131:
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      fclose
    lea       %rcx,	[%rip+L11020]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L5133
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11021]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_getch
    cmp       %rax,	27
    jnz       L5135
    xor       %ecx,	%ecx
    call      exit
L5135:
    lea       %rcx,	[%rbp + cc_cli.closelogfile.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11022]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11023]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_cli.closelogfile.str]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mwindows.os_execwait
    jmp       L5132
L5133:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11024]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11025]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5132:
L5117:
#---------------
    add       %rsp,	144
    pop       %rbp
    ret       
# End 
# Proc cc_cli.initdata
cc_cli.initdata:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.pcm_init
    call      cc_lex.lexsetup
    call      cc_lib.inittypetables
    call      cc_lib.initcclib
    xor       %eax,	%eax
    mov       [%rip+cc_decls.nlibfiles],	%rax
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L11026]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L11027]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L11028]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L11029]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    lea       %rax,	[%rip+cc_cli.cgetsourceinfo]
    mov       [%rip+pc_decls.igetmsourceinfo],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.cgetsourceinfo
cc_cli.cgetsourceinfo:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    shr       %rax,	24
    and       %rax,	511
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdx],	%r10
    lea       %rax,	[%rip+L11030]
    mov       [%r8],	%rax
    mov       %rax,	%rcx
    and       %rax,	16777215
L5137:
#---------------
    ret       
# End 
# Proc cc_cli.initsearchdirs
cc_cli.initsearchdirs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    lea       %r10,	[%rip+L11031]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %rax*8-8],	%r10
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    lea       %r10,	[%rip+L11032]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %rax*8-8],	%r10
    call      mwindows.os_gethostname
    mov       %rcx,	%rax
    call      mlib.extractpath
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %r10,	[%rip+cc_decls.nsearchdirs]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %r10*8-8],	%rax
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	1
    jl        L5141
L5139:
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L5143
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %r10,	[%rip+cc_decls.nsearchdirs]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %r10*8-8],	%rax
L5143:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nincludepaths]
    jle       L5139
L5141:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showsearchdirs
cc_cli.showsearchdirs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11033]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+cc_cli.dointheaders]
    test      %al,	%al
    jz        L5146
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11034]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5146:
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    cmp       %rax,	1
    jl        L5149
L5147:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L5151
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11035]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L5150
L5151:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11036]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5150:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsearchdirs]
    jle       L5147
L5149:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showast
cc_cli.showast:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+cc_cli.fshowast]
    test      %al,	%al
    jz        L5154
    mov       %rcx,	[%rip+cc_decls.logdev]
    lea       %rdx,	[%rip+L11037]
    call      cc_show.printcode
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L5154:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showstflat
cc_cli.showstflat:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11038]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      cc_show.printstflat
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showst
cc_cli.showst:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11038]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    mov       %rdx,	[%rip+cc_decls.stmodule]
    xor       %r8d,	%r8d
    call      cc_show.printst
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showfiles
cc_cli.showfiles:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11039]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L5160
L5158:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L11040]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11041]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilesizes]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsourcefiles]
    jle       L5158
L5160:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showtime
cc_cli.showtime:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11042]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11043]
    call      msys.m$print_str
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L11044]
    call      msys.m$print_i64
    mov       %rax,	%rbx
    cvtsi2sd  %XMM4,	%rax
    mulsd     %XMM4,	[%rip+L11045]
    mov       %rax,	[%rip+cc_cli.compiletime]
    cvtsi2sd  %XMM5,	%rax
    divsd     %XMM4,	%XMM5
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L11046]
    call      msys.m$print_r64
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showtiming
cc_cli.showtiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mwindows.os_clock
    sub       %rax,	[%rip+cc_cli.startclock]
    mov       [%rip+cc_cli.compiletime],	%rax
    lea       %rcx,	[%rip+L11047]
    mov       %rdx,	[%rip+cc_cli.inittime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L11048]
    mov       %rdx,	[%rip+cc_cli.loadtime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L11049]
    mov       %rdx,	[%rip+cc_cli.parsetime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L11050]
    mov       %rdx,	[%rip+cc_cli.pcltime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L11051]
    mov       %rdx,	[%rip+pc_decls.mcltime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L11052]
    mov       %rdx,	[%rip+pc_decls.sstime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L11053]
    mov       %rdx,	[%rip+pc_decls.exetime]
    call      cc_cli.showtime
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11054]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11055]
    mov       %rdx,	[%rip+cc_cli.compiletime]
    call      cc_cli.showtime
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.getinputoptions
cc_cli.getinputoptions:
#?>>
    .set cc_cli.getinputoptions.paramno, -8
    .set cc_cli.getinputoptions.name, -16
    .set cc_cli.getinputoptions.value, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    mov       %rax,	1
    mov       [%rbp + cc_cli.getinputoptions.paramno],	%rax
    xor       %rsi,	%rsi
    mov       %al,	[%rip+pcl.pc_userunpcl]
    test      %al,	%al
    jz        L5165
    mov       %al,	6
    mov       [%rip+cc_cli.cc_pass],	%al
    xor       %eax,	%eax
    mov       [%rip+cc_cli.fverbose],	%al
L5165:
    call      mwindows.os_gethostname
    mov       %rcx,	%rax
    call      mlib.extractfile
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11056]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5167
    xor       %eax,	%eax
    mov       [%rip+cc_cli.fverbose],	%al
    mov       %rcx,	17
    lea       %rdx,	[%rip+L11057]
    call      cc_cli.do_option
L5167:
L5168:
    lea       %rcx,	[%rbp + cc_cli.getinputoptions.paramno]
    lea       %rdx,	[%rbp + cc_cli.getinputoptions.name]
    lea       %r8,	[%rbp + cc_cli.getinputoptions.value]
    lea       %r9,	[%rip+L11058]
    call      mlib.nextcmdparamnew
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L5171
    cmp       %rax,	2
    jz        L5172
    cmp       %rax,	3
    jz        L5173
    test      %rax,	%rax
    jz        L5174
    jmp       L5175
L5171:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       %rbx,	1
    mov       %r12,	49
    cmp       %r12,	1
    jl        L5179
L5176:
    lea       %rax,	[%rip+cc_cli.optionnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5181
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_cli.getinputoptions.value]
    call      cc_cli.do_option
    jmp       L5178
L5181:
    inc       %rbx
    cmp       %rbx,	%r12
    jle       L5176
L5179:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11059]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L5178:
    jmp       L5170
L5172:
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jz        L5183
    lea       %rcx,	[%rip+L11060]
    lea       %rdx,	[%rip+L11061]
    call      cc_support.loaderror
L5183:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_decls.inputfile],	%rax
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	13
    jz        L5186
    cmp       %rax,	6
    jnz       L5185
L5186:
    mov       %rax,	[%rbp + cc_cli.getinputoptions.paramno]
    dec       %rax
    add       %rax,	[%rip+msys.$cmdskip]
    mov       [%rip+cc_cli.cmdskip],	%rax
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	6
    setz      %al
    movzx     %eax,	%al
    mov       [%rip+cc_decls.pci_target],	%al
    jmp       L5169
L5185:
    jmp       L5170
L5173:
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	200
    jl        L5188
    lea       %rcx,	[%rip+L11062]
    lea       %rdx,	[%rip+L11063]
    call      cc_support.loaderror
L5188:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %r10,	[%rip+cc_decls.nlibfiles]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %r10*8],	%rax
    jmp       L5170
L5174:
    jmp       L5169
L5175:
L5170:
    jmp       L5168
L5169:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    test      %rax,	%rax
    jnz       L5190
    mov       %al,	12
    mov       [%rip+cc_cli.cc_pass],	%al
    mov       %al,	[%rip+pcl.asmonly]
    test      %al,	%al
    jz        L5192
    mov       %al,	8
    mov       [%rip+cc_cli.cc_pass],	%al
L5192:
L5190:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	11
    jz        L5195
    cmp       %rax,	10
    jnz       L5194
L5195:
    mov       %al,	2
    mov       [%rip+cc_cli.highmem],	%al
    jmp       L5193
L5194:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	9
    jz        L5197
    cmp       %rax,	13
    jnz       L5196
L5197:
    xor       %eax,	%eax
    mov       [%rip+cc_cli.highmem],	%al
L5196:
L5193:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    lea       %r10,	[%rip+cc_cli.extnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       [%rip+cc_cli.outext],	%r10
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jz        L5200
    cmp       %rax,	8
    jnz       L5199
L5200:
    mov       %rax,	[%rip+mc_writeasm.asmext]
    mov       [%rip+cc_cli.outext],	%rax
L5199:
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jnz       L5202
    mov       %al,	[%rip+cc_cli.fwriteheaders]
    test      %al,	%al
    jnz       L5202
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11064]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11065]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11066]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11067]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11068]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11069]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11070]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11071]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11072]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L5202:
    mov       %al,	[%rip+cc_cli.fwriteheaders]
    test      %al,	%al
    jz        L5204
    call      cc_headers.writeheaders
    mov       %rcx,	20
    call      exit
L5204:
    mov       %rax,	[%rip+cc_cli.outfile]
    test      %rax,	%rax
    jnz       L5206
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_cli.outext]
    call      mlib.changeext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_cli.outfile],	%rax
L5206:
    movzx     %rax,	byte ptr[%rip+cc_cli.fshortnames]
    movzx     %r10,	byte ptr[%rip+cc_cli.highmem]
    mov       %rcx,	%r10
    mov       %rdx,	-1
    mov       %r8,	%rax
    call      pc_api.pcl_setflags
    mov       %rcx,	[%rip+cc_cli.cmdskip]
    xor       %edx,	%edx
    call      pc_api.pcl_cmdskip
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_option
cc_cli.do_option:
#?>>
    .set cc_cli.do_option.str, -304
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+cc_cli.optvars]
    mov       %r10,	%rsi
    mov       %rbx,	[%rax + %r10*8-8]
    test      %rbx,	%rbx
    jz        L5209
    lea       %rax,	[%rip+cc_cli.optvalues]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    mov       [%rbx],	%al
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L5211
    cmp       %rax,	9
    jg        L5211
    mov       %al,	1
    or        [%rip+cc_cli.debugmode],	%al
L5211:
    mov       %rax,	%rsi
    cmp       %rax,	25
    jl        L5213
    cmp       %rax,	33
    jg        L5213
    mov       %al,	2
    or        [%rip+cc_cli.debugmode],	%al
L5213:
    cmp       %rsi,	8
    jnz       L5215
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jz        L5215
    lea       %rcx,	[%rip+L11073]
    lea       %rdx,	[%rip+L11074]
    call      cc_support.loaderror
L5215:
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L5218
    cmp       %rax,	7
    jnz       L5217
L5218:
    mov       %al,	1
    mov       [%rip+cc_decls.pci_target],	%al
L5217:
    jmp       L5207
L5209:
    mov       %rax,	%rsi
    cmp       %rax,	23
    jz        L5220
    cmp       %rax,	41
    jz        L5221
    cmp       %rax,	42
    jz        L5221
    cmp       %rax,	45
    jz        L5222
    cmp       %rax,	20
    jz        L5223
    jmp       L5224
L5220:
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	20
    jle       L5226
    lea       %rcx,	[%rip+L11075]
    lea       %rdx,	[%rip+L11076]
    call      cc_support.loaderror
L5226:
    mov       %rcx,	%r12
    call      strlen
    mov       %rdi,	%rax
    lea       %rax,	[%r12 + %rdi]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	92
    jz        L5228
    cmp       %rax,	47
    jnz       L5229
L5228:
    jmp       L5227
L5229:
    lea       %rcx,	[%rbp + cc_cli.do_option.str]
    mov       %rdx,	%r12
    call      strcpy
    lea       %rcx,	[%rbp + cc_cli.do_option.str]
    lea       %rdx,	[%rip+L11077]
    call      strcat
    lea       %rax,	[%rbp + cc_cli.do_option.str]
    mov       %r12,	%rax
L5227:
    mov       %rcx,	%r12
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nincludepaths]
    mov       %r10,	[%rip+cc_decls.nincludepaths]
    lea       %r11,	[%rip+cc_decls.includepaths]
    mov       [%r11 + %r10*8-8],	%rax
    jmp       L5219
L5221:
    call      cc_cli.showhelp
    jmp       L5219
L5222:
    mov       %rcx,	%r12
    mov       %rdx,	[%rip+cc_cli.outext]
    call      mlib.addext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_cli.outfile],	%rax
    jmp       L5219
L5223:
    xor       %eax,	%eax
    mov       [%rip+pc_decls.fpeephole],	%al
    mov       [%rip+pc_decls.fregoptim],	%al
L5224:
L5219:
L5207:
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showincludepaths
cc_cli.showincludepaths:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11078]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nincludepaths]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	1
    jl        L5233
L5231:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nincludepaths]
    jle       L5231
L5233:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showhelp
cc_cli.showhelp:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11079]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	23
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showextrainfo
cc_cli.showextrainfo:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+cc_cli.showextrainfo.infotext]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	24
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showcaption
cc_cli.showcaption:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11080]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11081]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11082]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.starttiming
cc_cli.starttiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mwindows.os_clock
    mov       [%rip+cc_cli.ttt],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.gettiming
cc_cli.gettiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mwindows.os_clock
    sub       %rax,	[%rip+cc_cli.ttt]
L5238:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.lex_preprocess_only
cc_lex.lex_preprocess_only:
#?>>
    .set cc_lex.lex_preprocess_only.outfile, 80
    .set cc_lex.lex_preprocess_only.toconsole, 88
    .set cc_lex.lex_preprocess_only.hashtot, -8
    .set cc_lex.lex_preprocess_only.symtot, -16
    .set cc_lex.lex_preprocess_only.f, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	1
    mov       [%rip+cc_lex.dowhitespace],	%rax
    mov       %rcx,	%r15
    mov       %rdx,	%r15
    call      cc_support.loadsourcefile
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%r12
    mov       %rdi,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.sourcefilesizes]
    mov       %r10,	%r12
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r13,	%rax
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %rsi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.lex_preprocess_only.symtot],	%rax
    mov       [%rbp + cc_lex.lex_preprocess_only.hashtot],	%rax
    call      mwindows.os_clock
    mov       %r14,	%rax
    mov       %rax,	[%rip+cc_lex.lex_preprocess_only.dest]
    mov       [%rip+cc_lex.destcopy],	%rax
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    call      mlib.gs_init
    mov       [%rip+cc_lex.lxsptr],	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    mov       %rcx,	1
    call      cc_lex.setfileno
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    lea       %rcx,	[%rip+L11083]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5240:
    call      cc_lex.lexm
    inc       %rbx
    lea       %rcx,	[%rip+cc_decls.nextlx]
    mov       %rdx,	[%rip+cc_lex.lex_preprocess_only.dest]
    xor       %r8d,	%r8d
    call      cc_lex.emittoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L5240
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jz        L5244
    lea       %rcx,	[%rip+L11084]
    call      cc_lex.lxerror
L5244:
    lea       %rax,	[%rip+cc_lex.showtokens]
    test      %rax,	%rax
    jz        L5246
    mov       %rax,	[%rbp + cc_lex.lex_preprocess_only.toconsole]
    test      %rax,	%rax
    jz        L5248
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    xor       %edx,	%edx
    call      mlib.gs_println
    jmp       L5247
L5248:
    mov       %rcx,	[%rbp + cc_lex.lex_preprocess_only.outfile]
    lea       %rdx,	[%rip+L11085]
    call      fopen
    mov       [%rbp + cc_lex.lex_preprocess_only.f],	%rax
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    mov       %rdx,	[%rbp + cc_lex.lex_preprocess_only.f]
    call      mlib.gs_println
    mov       %rcx,	[%rbp + cc_lex.lex_preprocess_only.f]
    call      fclose
L5247:
L5246:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexreadtoken
cc_lex.lexreadtoken:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+23],	%al
    jmp       L5251
L5250:
    inc       qword ptr[%rip+cc_lex.lxsptr]
L5251:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L5250
    cmp       %rax,	9
    jz        L5250
L5253:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	240
    jae       L5256
    lea       %r10,	[%rip+L5255]
    jmp       [%r10 + %rax*8]
    .data
L5255:
    .quad     L5390
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5375
    .quad     L5376
    .quad     L5256
    .quad     L5394
    .quad     L5384
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5375
    .quad     L5385
    .quad     L5374
    .quad     L5283
    .quad     L5257
    .quad     L5347
    .quad     L5368
    .quad     L5373
    .quad     L5313
    .quad     L5314
    .quad     L5338
    .quad     L5327
    .quad     L5307
    .quad     L5332
    .quad     L5299
    .quad     L5341
    .quad     L5274
    .quad     L5270
    .quad     L5270
    .quad     L5270
    .quad     L5270
    .quad     L5270
    .quad     L5270
    .quad     L5270
    .quad     L5270
    .quad     L5270
    .quad     L5309
    .quad     L5308
    .quad     L5354
    .quad     L5350
    .quad     L5361
    .quad     L5325
    .quad     L5389
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5315
    .quad     L5287
    .quad     L5316
    .quad     L5322
    .quad     L5257
    .quad     L5256
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5257
    .quad     L5297
    .quad     L5317
    .quad     L5298
    .quad     L5326
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5256
    .quad     L5395
    .text
L5257:
#cc_lex.lexreadtoken.doname:
L5258:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       [%rip+cc_lex.lxsvalue],	%rax
    mov       %rax,	[%rip+cc_lex.lxsvalue]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    jmp       L5260
L5259:
    mov       %rax,	%rbx
    shl       %rax,	4
    sub       %rax,	%rbx
    add       %rax,	%rdi
    mov       %rbx,	%rax
L5260:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5259
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	67
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rip+cc_lex.lxsvalue]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	%rdi
    cmp       %rax,	39
    jz        L5263
    cmp       %rax,	34
    jnz       L5264
L5263:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	1
    jnz       L5266
    mov       %rax,	[%rip+cc_lex.lxsvalue]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	108
    jz        L5268
    cmp       %rax,	76
    jz        L5268
    cmp       %rax,	117
    jz        L5268
    cmp       %rax,	85
    jnz       L5269
L5268:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lex.lxreadstring
    jmp       L5249
L5269:
L5267:
L5266:
L5264:
L5262:
    mov       %rax,	%rbx
    shl       %rax,	5
    sub       %rax,	%rbx
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    call      cc_lex.lookup
    jmp       L5249
L5270:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L5272
    cmp       %rax,	41
    jz        L5272
    cmp       %rax,	13
    jz        L5272
    cmp       %rax,	44
    jz        L5272
    cmp       %rax,	59
    jnz       L5273
L5272:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	48
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    jmp       L5271
L5273:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readdecimal
L5271:
    jmp       L5249
L5274:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	10
    cmp       %rax,	116
    jae       L5277
    lea       %r10,	[%rip+L5276]
    jmp       [%r10 + %rax*8]
    .data
L5276:
    .quad     L5282
    .quad     L5277
    .quad     L5277
    .quad     L5282
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5282
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5282
    .quad     L5277
    .quad     L5277
    .quad     L5282
    .quad     L5277
    .quad     L5277
    .quad     L5282
    .quad     L5277
    .quad     L5280
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5282
    .quad     L5282
    .quad     L5277
    .quad     L5282
    .quad     L5277
    .quad     L5282
    .quad     L5277
    .quad     L5277
    .quad     L5279
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5281
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5281
    .quad     L5277
    .quad     L5277
    .quad     L5278
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5282
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5279
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5281
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5281
    .quad     L5277
    .quad     L5277
    .quad     L5278
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5277
    .quad     L5282
    .text
L5278:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      cc_lex.readhex
    jmp       L5249
L5279:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      cc_lex.readbinary
    jmp       L5249
L5280:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %r10,	[%rip+cc_lex.lxsptr]
    sub       %r10,	1
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L5249
L5281:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readdecimal
    jmp       L5249
L5282:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    jmp       L5249
L5277:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readoctal
    jmp       L5249
L5275:
    jmp       L5253
L5283:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jnz       L5285
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5285:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	35
    jnz       L5286
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	7
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5286:
    mov       %al,	5
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5284:
    jmp       L5253
L5287:
L5288:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L5290
    cmp       %rax,	10
    jz        L5290
    cmp       %rax,	32
    jz        L5291
    cmp       %rax,	9
    jz        L5291
    jmp       L5292
L5290:
    jmp       L5289
L5291:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5288
L5292:
    mov       %al,	22
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5289:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %r10b,	32
    mov       [%rax],	%r10b
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L5294
    cmp       %rax,	10
    jz        L5295
    jmp       L5296
L5294:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %r10b,	32
    mov       [%rax],	%r10b
    jmp       L5293
L5295:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %r10b,	32
    mov       [%rax],	%r10b
L5296:
L5293:
    jmp       L5253
L5297:
    mov       %al,	17
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5298:
    mov       %al,	18
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5299:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	46
    cmp       %rax,	12
    jae       L5302
    lea       %r10,	[%rip+L5301]
    jmp       [%r10 + %rax*8]
    .data
L5301:
    .quad     L5303
    .quad     L5302
    .quad     L5306
    .quad     L5306
    .quad     L5306
    .quad     L5306
    .quad     L5306
    .quad     L5306
    .quad     L5306
    .quad     L5306
    .quad     L5306
    .quad     L5306
    .text
L5303:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L5305
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	21
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5304
L5305:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	2
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5304:
    jmp       L5249
L5306:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rip+cc_lex.lxsptr]
    mov       %rdx,	[%rip+cc_lex.lxsptr]
    xor       %r8d,	%r8d
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L5249
L5302:
    mov       %al,	2
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5300:
    jmp       L5253
L5307:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5308:
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5309:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L5312
L5311:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5310
L5312:
    mov       %al,	10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5310:
    jmp       L5249
L5313:
    mov       %al,	13
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5314:
    mov       %al,	14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5315:
    mov       %al,	15
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5316:
    mov       %al,	16
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5317:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	124
    jz        L5319
    cmp       %rax,	61
    jz        L5320
    jmp       L5321
L5319:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	31
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5318
L5320:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	51
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5318
L5321:
    mov       %al,	28
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5318:
    jmp       L5249
L5322:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L5324
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	53
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5323
L5324:
    mov       %al,	30
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5323:
    jmp       L5249
L5325:
    mov       %al,	19
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5326:
    mov       %al,	35
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5327:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	43
    jz        L5329
    cmp       %rax,	61
    jz        L5330
    jmp       L5331
L5329:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	37
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5328
L5330:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	46
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5328
L5331:
    mov       %al,	23
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5328:
    jmp       L5249
L5332:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	45
    jz        L5334
    cmp       %rax,	62
    jz        L5335
    cmp       %rax,	61
    jz        L5336
    jmp       L5337
L5334:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	38
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5333
L5335:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5333
L5336:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	47
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5333
L5337:
    mov       %al,	24
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5333:
    jmp       L5249
L5338:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L5340
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	48
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5339
L5340:
    mov       %al,	25
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5339:
    jmp       L5249
L5341:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L5343
    cmp       %rax,	42
    jz        L5344
    cmp       %rax,	61
    jz        L5345
    jmp       L5346
L5343:
    call      cc_lex.readlinecomment
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    jmp       L5249
L5344:
    call      cc_lex.readblockcomment
    jmp       L5342
L5345:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	49
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5346:
    mov       %al,	26
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5342:
    jmp       L5253
L5347:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L5349
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	50
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5348
L5349:
    mov       %al,	27
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5348:
    jmp       L5249
L5350:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L5353
L5352:
    mov       %al,	40
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5351
L5353:
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5351:
    jmp       L5249
L5354:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jz        L5356
    cmp       %rax,	60
    jz        L5357
    jmp       L5358
L5356:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	43
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5355
L5357:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L5360
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	54
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5359
L5360:
    mov       %al,	33
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5359:
    jmp       L5355
L5358:
    mov       %al,	42
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5355:
    jmp       L5249
L5361:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jz        L5363
    cmp       %rax,	62
    jz        L5364
    jmp       L5365
L5363:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	44
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5362
L5364:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L5367
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	55
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5366
L5367:
    mov       %al,	34
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5366:
    jmp       L5362
L5365:
    mov       %al,	45
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5362:
    jmp       L5249
L5368:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	38
    jz        L5370
    cmp       %rax,	61
    jz        L5371
    jmp       L5372
L5370:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	32
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5369
L5371:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	52
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5369
L5372:
    mov       %al,	29
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5369:
    jmp       L5249
L5373:
    mov       %rcx,	39
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L5249
L5374:
    mov       %rcx,	34
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L5249
L5375:
    jmp       L5253
L5376:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.dowhitespace]
    test      %rax,	%rax
    jz        L5378
    mov       %rax,	[%rip+cc_lex.lxsptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
L5379:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	9
    cmp       %rax,	24
    jae       L5382
    lea       %r10,	[%rip+L5381]
    jmp       [%r10 + %rax*8]
    .data
L5381:
    .quad     L5383
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5382
    .quad     L5383
    .text
L5383:
    jmp       L5379
L5382:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5380
L5380:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10,	[%rip+cc_lex.lxsptr]
    sub       %r10,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       [%rax+24],	%r10d
L5378:
    jmp       L5249
L5384:
    jmp       L5253
L5385:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L5388
L5387:
    mov       %al,	41
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5386
L5388:
    mov       %al,	36
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5386:
    jmp       L5249
L5389:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11086]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L5253
L5390:
#cc_lex.lexreadtoken.doeof:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jz        L5393
    call      cc_lex.unstacksourcefile
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5392
L5393:
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5392:
    jmp       L5249
L5394:
    jmp       L5253
L5395:
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    jmp       L5253
L5256:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	128
    jl        L5397
    cmp       %rax,	255
    jle       L5258
L5397:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11087]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_c8
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11087]
    call      cc_lex.lxerror
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5249
L5249:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readrealnumber
cc_lex.readrealnumber:
#?>>
    .set cc_lex.readrealnumber.intlen, 104
    .set cc_lex.readrealnumber.base, 112
    .set cc_lex.readrealnumber.badexpon, -8
    .set cc_lex.readrealnumber.realstr, -520
    .set cc_lex.readrealnumber.rs, -528
    .set cc_lex.readrealnumber.expstr, -560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    movq      %rax,	%XMM13
    push      %rax
    movq      %rax,	%XMM14
    push      %rax
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	600
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+104],	%r8
    mov       [%rbp+112],	%r9
#---------------
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jz        L5400
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.readrealnumber.intlen]
    mov       %r9,	[%rbp + cc_lex.readrealnumber.base]
    call      cc_lex.old_readrealnumber
    jmp       L5398
L5400:
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L5402
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rbp + cc_lex.readrealnumber.base]
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
L5402:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readrealnumber.badexpon],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	101
    jz        L5404
    cmp       %rax,	69
    jz        L5404
    cmp       %rax,	112
    jz        L5405
    cmp       %rax,	80
    jz        L5405
    jmp       L5406
L5404:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jz        L5408
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L5408:
    jmp       L5403
L5405:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jnz       L5410
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L5410:
L5406:
L5403:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.badexpon]
    test      %rax,	%rax
    jz        L5412
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L5398
L5412:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	102
    jz        L5414
    cmp       %rax,	70
    jz        L5414
    cmp       %rax,	108
    jz        L5414
    cmp       %rax,	76
    jnz       L5415
L5414:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5413
L5415:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L5417
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L5398
L5417:
L5413:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jnz       L5419
    mov       %al,	48
    mov       [%rbp + cc_lex.readrealnumber.realstr],	%al
    mov       %al,	120
    mov       [%rbp + cc_lex.readrealnumber.realstr+1],	%al
    lea       %rax,	[%rbp + cc_lex.readrealnumber.realstr+2]
    mov       [%rbp + cc_lex.readrealnumber.rs],	%rax
    mov       %r12,	2
    jmp       L5418
L5419:
    lea       %rax,	[%rbp + cc_lex.readrealnumber.realstr]
    mov       [%rbp + cc_lex.readrealnumber.rs],	%rax
    xor       %r12,	%r12
L5418:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    add       %rax,	%rbx
    cmp       %rax,	500
    jle       L5421
    lea       %rcx,	[%rip+L11088]
    call      cc_lex.lxerror
L5421:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    test      %rax,	%rax
    jz        L5423
    mov       %rcx,	[%rbp + cc_lex.readrealnumber.rs]
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.readrealnumber.intlen]
    call      memcpy
L5423:
    test      %rbx,	%rbx
    jz        L5425
    mov       %rax,	[%rbp + cc_lex.readrealnumber.rs]
    mov       %r10,	[%rbp + cc_lex.readrealnumber.intlen]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
L5425:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cvtsi2sd  %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM13,	%XMM4
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jnz       L5427
    mov       %rax,	%rbx
    sub       %rsi,	%rax
    jmp       L5426
L5427:
    mov       %rax,	%rbx
    shl       %rax,	2
    sub       %rsi,	%rax
    movq      %XMM4,	[%rip+L11089]
    movq      %XMM13,	%XMM4
L5426:
    mov       %rax,	%r12
    add       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    add       %rax,	%rbx
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + cc_lex.readrealnumber.realstr],	%r10b
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.expstr]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jnz       L5429
    lea       %rax,	[%rip+L11090]
    jmp       L5428
L5429:
    lea       %rax,	[%rip+L11091]
L5428:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.realstr]
    lea       %rdx,	[%rbp + cc_lex.readrealnumber.expstr]
    call      strcat
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jz        L5431
    lea       %rcx,	[%rip+L11092]
    call      cc_lex.lxerror
L5431:
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.realstr]
    xor       %edx,	%edx
    call      strtod
    movq      %XMM14,	%XMM0
    mov       %al,	60
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    movq      %XMM4,	%XMM14
    lea       %rax,	[%rip+cc_decls.nextlx]
    movq      [%rax],	%XMM4
    mov       %rax,	%r14
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
L5398:
#---------------
    add       %rsp,	600
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rcx
    movq      %XMM14,	%rcx
    pop       %rcx
    movq      %XMM13,	%rcx
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readexponent
cc_lex.readexponent:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	43
    jz        L5434
    cmp       %rax,	45
    jz        L5435
    jmp       L5436
L5434:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5433
L5435:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rsi,	1
L5436:
L5433:
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	10
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L5438
    mov       %rax,	1
    mov       [%r15],	%rax
    xor       %eax,	%eax
    jmp       L5432
L5438:
    xor       %r13,	%r13
    mov       %rax,	%rbx
    mov       %r14,	%rax
    cmp       %r14,	0
    jle       L5441
L5439:
    mov       %rax,	%rdi
    inc       %rdi
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    mov       %rax,	%r13
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%r12
    sub       %rax,	48
    mov       %r13,	%rax
    dec       %r14
    jnz       L5439
L5441:
    test      %rsi,	%rsi
    jz        L5443
    mov       %rax,	%r13
    neg       %rax
    jmp       L5442
L5443:
    mov       %rax,	%r13
L5442:
L5432:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lxerror
cc_lex.lxerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11093]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11094]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    call      cc_lex.getfileno
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11095]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	11
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.printsymbol
cc_lex.printsymbol:
#?>>
    .set cc_lex.printsymbol.l, -32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    lea       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %rcx,	[%rip+L11096]
    mov       %rdx,	%r10
    call      printf
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+21]
    cmp       %rax,	67
    jz        L5447
    cmp       %rax,	59
    jz        L5448
    cmp       %rax,	60
    jz        L5449
    cmp       %rax,	63
    jz        L5450
    cmp       %rax,	61
    jz        L5451
    jmp       L5452
L5447:
    mov       %rax,	[%rbp + cc_lex.printsymbol.l]
    movzx     %rax,	byte ptr[%rax+106]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    jmp       L5446
L5448:
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_lex.printsymbol.l]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11097]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_lex.shownumberstr
    jmp       L5446
L5449:
    call      msys.m$print_startcon
    movq      %XMM4,	[%rbp + cc_lex.printsymbol.l]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.m$print_r64
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11097]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_lex.shownumberstr
    jmp       L5446
L5450:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11098]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%rbp + cc_lex.printsymbol.l+24]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11098]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L5446
L5451:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11099]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%rbp + cc_lex.printsymbol.l+24]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11099]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L5446
L5452:
    mov       %al,	[%rbp + cc_lex.printsymbol.l+22]
    test      %al,	%al
    jz        L5454
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11100]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+22]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L5454:
L5446:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexsetup
cc_lex.lexsetup:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.inithashtable
    call      cc_lex.fillhashtable
    xor       %rdi,	%rdi
L5456:
    lea       %rax,	[%rdi-36]
    cmp       %rax,	220
    jae       L5461
    lea       %r10,	[%rip+L5460]
    jmp       [%r10 + %rax*8]
    .data
L5460:
    .quad     L5462
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5462
    .quad     L5461
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5461
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .quad     L5462
    .text
L5462:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L5461:
L5459:
    lea       %rax,	[%rdi-48]
    cmp       %rax,	10
    jae       L5465
    lea       %r10,	[%rip+L5464]
    jmp       [%r10 + %rax*8]
    .data
L5464:
    .quad     L5466
    .quad     L5466
    .quad     L5466
    .quad     L5466
    .quad     L5466
    .quad     L5466
    .quad     L5466
    .quad     L5466
    .quad     L5466
    .quad     L5466
    .text
L5466:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.digitmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L5465:
L5463:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    inc       %rdi
    cmp       %rdi,	255
    jle       L5456
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10+42],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10+10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10+92],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       [%r10+32],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       [%r10+9],	%al
    mov       %al,	56
    lea       %r10,	[%rip+cc_lex.normaltkx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    mov       [%rip+cc_lex.npastedtokens],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.printstrn
cc_lex.printstrn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rbx,	%rbx
    jz        L5469
    test      %rsi,	%rsi
    jnz       L5471
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L11101]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11102]
    call      msys.m$print_str
    call      msys.m$print_end
    jmp       L5470
L5471:
    mov       %rcx,	%rsi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L11103]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11104]
    call      msys.m$print_str
    call      msys.m$print_end
L5470:
L5469:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.scannumber
cc_lex.scannumber:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+cc_lex.lxsptr]
L5473:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	39
    cmp       %rax,	64
    jae       L5476
    lea       %r10,	[%rip+L5475]
    jmp       [%r10 + %rax*8]
    .data
L5475:
    .quad     L5483
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5477
    .quad     L5477
    .quad     L5477
    .quad     L5477
    .quad     L5477
    .quad     L5477
    .quad     L5477
    .quad     L5477
    .quad     L5477
    .quad     L5477
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5480
    .quad     L5480
    .quad     L5480
    .quad     L5480
    .quad     L5480
    .quad     L5480
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5476
    .quad     L5483
    .quad     L5483
    .quad     L5480
    .quad     L5480
    .quad     L5480
    .quad     L5480
    .quad     L5480
    .quad     L5480
    .text
L5477:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
    mov       %rax,	48
    add       %rax,	%rsi
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jl        L5479
    lea       %rcx,	[%rip+L11105]
    call      cc_lex.lxerror
L5479:
    jmp       L5473
L5480:
    cmp       %rsi,	16
    jnz       L5482
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
    jmp       L5481
L5482:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5474
L5481:
    jmp       L5473
L5483:
    jmp       L5473
L5476:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5474
L5474:
    mov       %rax,	%rdi
L5472:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lookup
cc_lex.lookup:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#cc_lex.lookup.retry:
L5485:
    mov       %rax,	[%rip+cc_lex.lxhashvalue]
    and       %rax,	[%rip+cc_decls.hstmask]
    mov       %rdi,	%rax
    xor       %rbx,	%rbx
L5486:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+106]
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L5489
    jmp       L5487
L5489:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jnz       L5491
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+cc_lex.lxsvalue]
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L5493
    mov       %rax,	1
    jmp       L5484
L5493:
L5491:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstsize]
    jl        L5495
    test      %rbx,	%rbx
    jz        L5497
    lea       %rcx,	[%rip+L11106]
    call      mlib.abortprogram
L5497:
    mov       %rbx,	1
    xor       %rdi,	%rdi
L5495:
    jmp       L5486
L5487:
    mov       %rax,	[%rip+cc_lex.nhstsymbols]
    cmp       %rax,	[%rip+cc_lex.hstthreshold]
    jl        L5499
    call      cc_lex.newhashtable
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    jmp       L5485
L5499:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      mlib.pcm_copyheapstringn
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+106],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10b,	67
    mov       [%rax+107],	%r10b
    inc       qword ptr[%rip+cc_lex.nhstsymbols]
    xor       %eax,	%eax
L5484:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.gethashvalue
cc_lex.gethashvalue:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    cmp       %r12,	-1
    jnz       L5502
    mov       %rcx,	%rsi
    call      strlen
    mov       %r12,	%rax
L5502:
    xor       %rdi,	%rdi
    mov       %rax,	%r12
    mov       %rbx,	%rax
    cmp       %rbx,	0
    jle       L5505
L5503:
    mov       %rax,	%rdi
    shl       %rax,	4
    sub       %rax,	%rdi
    mov       %r10,	%rsi
    inc       %rsi
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    mov       %rdi,	%rax
    dec       %rbx
    jnz       L5503
L5505:
    mov       %rax,	%rdi
    shl       %rax,	5
    sub       %rax,	%rdi
L5500:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.inithashtable
cc_lex.inithashtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_decls.hashtable],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       [%rip+cc_decls.hstmask],	%rax
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L5509
L5507:
    mov       %rcx,	128
    call      mlib.pcm_allocz
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstmask]
    jle       L5507
L5509:
    xor       %eax,	%eax
    mov       [%rip+cc_lex.nhstsymbols],	%rax
    mov       %rax,	6
    mov       %r10,	[%rip+cc_decls.hstsize]
    imul      %rax,	%r10
    mov       %r10,	10
    cqo       
    idiv      %r10
    mov       [%rip+cc_lex.hstthreshold],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.fillhashtable
cc_lex.fillhashtable:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rdi,	1
    mov       %rbx,	63
    cmp       %rbx,	1
    jl        L5513
L5511:
    lea       %rax,	[%rip+cc_tables.stnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+cc_lex.lxsvalue],	%rax
    lea       %rax,	[%rip+cc_tables.stsymbols]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    cmp       %rax,	68
    jnz       L5515
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_lex.lxsvalue],	%rax
L5515:
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    call      strlen
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    call      cc_lex.lookup
    test      %rax,	%rax
    jz        L5517
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_tables.stnames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11107]
    call      mlib.abortprogram
L5517:
    lea       %rax,	[%rip+cc_tables.stsymbols]
    mov       %r10,	%rdi
    mov       %eax,	[%rax + %r10*4-4]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+107],	%al
    lea       %rax,	[%rip+cc_tables.stsubcodes]
    mov       %r10,	%rdi
    mov       %eax,	[%rax + %r10*4-4]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+100],	%ax
    inc       %rdi
    cmp       %rdi,	%rbx
    jle       L5511
L5513:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dolexdirective
cc_lex.dolexdirective:
#?>>
    .set cc_lex.dolexdirective.dir, -8
    .set cc_lex.dolexdirective.length, -16
    .set cc_lex.dolexdirective.allowmacros, -24
    .set cc_lex.dolexdirective.filename, -328
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	360
#---------------
    mov       %rsi,	[%rip+cc_lex.lxsptr]
    call      cc_lex.getlexdirective
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    test      %rax,	%rax
    jnz       L5520
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%rsi
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11108]
    call      cc_lex.lxerror
L5520:
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	7
    jz        L5522
    cmp       %rax,	1
    jz        L5523
    cmp       %rax,	10
    jz        L5524
    cmp       %rax,	8
    jz        L5525
    cmp       %rax,	9
    jz        L5526
    cmp       %rax,	3
    jz        L5527
    cmp       %rax,	4
    jz        L5528
    cmp       %rax,	5
    jz        L5528
    cmp       %rax,	6
    jz        L5529
    cmp       %rax,	13
    jz        L5530
    cmp       %rax,	14
    jz        L5531
    cmp       %rax,	11
    jz        L5532
    cmp       %rax,	15
    jz        L5533
    jmp       L5534
L5522:
    mov       %rax,	1
    mov       [%rip+cc_lex.isincludefile],	%rax
    jmp       L5536
L5535:
    inc       qword ptr[%rip+cc_lex.lxsptr]
L5536:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L5535
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	9
    jz        L5535
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	60
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_lex.dolexdirective.allowmacros],	%rax
    call      cc_lex.lexm
    xor       %eax,	%eax
    mov       [%rip+cc_lex.isincludefile],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	42
    jnz       L5539
    mov       %r15,	1
    lea       %rax,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.allowmacros]
    test      %rax,	%rax
    jz        L5541
L5542:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jz        L5545
    cmp       %rax,	56
    jz        L5545
    cmp       %rax,	45
    jz        L5546
    jmp       L5547
L5545:
    lea       %rcx,	[%rip+L11109]
    call      cc_lex.lxerror
    jmp       L5544
L5546:
    jmp       L5543
L5547:
    lea       %rcx,	[%rip+cc_decls.nextlx]
    lea       %rdx,	[%rbp + cc_lex.dolexdirective.length]
    call      cc_lex.strtoken
    mov       %r12,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	[%rbp + cc_lex.dolexdirective.length]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.dolexdirective.length]
    add       %rbx,	%rax
L5544:
    jmp       L5542
L5543:
    jmp       L5540
L5541:
L5548:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	62
    jz        L5551
    cmp       %rax,	10
    jz        L5552
    test      %rax,	%rax
    jz        L5552
    jmp       L5553
L5551:
    jmp       L5549
L5552:
    lea       %rcx,	[%rip+L11110]
    call      cc_lex.lxerror
    jmp       L5550
L5553:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r10b,	%r14b
    mov       [%rax],	%r10b
L5550:
    jmp       L5548
L5549:
L5540:
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L5538
L5539:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jnz       L5554
    xor       %r15,	%r15
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L5538
L5554:
    lea       %rcx,	[%rip+L11111]
    call      cc_lex.lxerror
L5538:
    call      cc_lex.lexm
    mov       %al,	[%rip+cc_cli.fshowincludes]
    test      %al,	%al
    jz        L5556
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11112]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11113]
    call      msys.m$print_str_nf
    call      cc_lex.getfileno
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L11114]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5556:
    inc       qword ptr[%rip+cc_lex.nincludes]
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rdx,	%r15
    call      cc_lex.stacksourcefile
    jmp       L5521
L5523:
    call      cc_lex.dodefine
    jmp       L5521
L5524:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5558
    lea       %rcx,	[%rip+L11115]
    call      cc_lex.lxerror
L5558:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L5559
L5560:
    xor       %eax,	%eax
    mov       [%rdi+109],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %al,	[%rax+88]
    mov       [%rdi+107],	%al
    xor       %eax,	%eax
    mov       [%rdi+80],	%rax
    lea       %rax,	[%rdi+108]
    and       byte ptr[%rax],	251
L5559:
    jmp       L5521
L5525:
    call      cc_lex.getifdef
    mov       %r13,	%rax
    jmp       L5561
L5526:
    call      cc_lex.getifdef
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       %r13,	%rax
    jmp       L5561
L5527:
    call      cc_lex.getifexpr
    mov       %r13,	%rax
#cc_lex.dolexdirective.doif:
L5561:
    inc       qword ptr[%rip+cc_lex.ifcondlevel]
    test      %r13,	%r13
    jz        L5563
    xor       %eax,	%eax
    jmp       L5518
L5563:
#cc_lex.dolexdirective.doskipcode:
L5564:
    call      cc_lex.skipcode
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	4
    jz        L5566
    cmp       %rax,	5
    jz        L5567
    cmp       %rax,	6
    jz        L5568
    jmp       L5569
L5566:
    call      cc_lex.getifexpr
    mov       %r13,	%rax
    test      %r13,	%r13
    jz        L5571
    xor       %eax,	%eax
    jmp       L5518
L5571:
    jmp       L5564
L5567:
    jmp       L5565
L5568:
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
L5569:
L5565:
L5562:
    jmp       L5521
L5528:
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jnz       L5573
    lea       %rcx,	[%rip+L11116]
    call      cc_lex.lxerror
L5573:
L5574:
    call      cc_lex.skipcode
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	6
    jnz       L5574
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
    jmp       L5521
L5529:
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jnz       L5578
    lea       %rcx,	[%rip+L11117]
    call      cc_lex.lxerror
L5578:
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
    jmp       L5521
L5530:
    jmp       L5521
L5531:
L5579:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jnz       L5579
    jmp       L5521
L5532:
    call      cc_lex.lexm
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11118]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.showtoken
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11119]
    call      cc_lex.lxerror
    jmp       L5521
L5533:
    call      cc_lex.dopragmadir
    jmp       L5521
L5534:
#cc_lex.dolexdirective.skip:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11120]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_tables.sourcedirnames]
    mov       %r10,	[%rbp + cc_lex.dolexdirective.dir]
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       [%rip+cc_lex.lxsptr],	%rsi
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	1
    jmp       L5518
    lea       %rcx,	[%rip+L11121]
    call      cc_lex.lxerror
L5521:
    xor       %eax,	%eax
L5518:
#---------------
    add       %rsp,	360
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getlexdirective
cc_lex.getlexdirective:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5585
    cmp       %rax,	56
    jz        L5586
    cmp       %rax,	59
    jz        L5587
    jmp       L5588
L5585:
    jmp       L5584
L5586:
    mov       %rax,	13
    jmp       L5583
L5587:
L5589:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L5592
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L5589
L5592:
    mov       %rax,	13
    jmp       L5583
L5588:
    xor       %eax,	%eax
    jmp       L5583
L5584:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	68
    jz        L5594
    cmp       %rax,	71
    jz        L5595
    cmp       %rax,	72
    jz        L5596
    cmp       %rax,	56
    jz        L5597
    jmp       L5598
L5594:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movsx     %rax,	word ptr[%rax+100]
    jmp       L5583
L5595:
    mov       %rax,	3
    jmp       L5583
L5596:
    mov       %rax,	5
    jmp       L5583
L5597:
    mov       %rax,	13
    jmp       L5583
L5598:
L5593:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L5600
    movzx     %rax,	byte ptr[%rdi+88]
    cmp       %rax,	68
    jnz       L5602
    movsx     %rax,	word ptr[%rdi+100]
    jmp       L5583
L5602:
L5600:
    xor       %eax,	%eax
L5583:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.startlex
cc_lex.startlex:
#?>>
    .set cc_lex.startlex.caption, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    lea       %rax,	[%rip+cc_lex.normaltkx]
    mov       [%rip+cc_lex.normaltk],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    mov       %rax,	1
    mov       [%rip+cc_lex.firstsymbol],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.npastedtokens],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.isincludefile],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.tkptr],	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rcx,	%rdi
    call      cc_lex.setfileno
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    call      cc_lex.lex
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.endlex
cc_lex.endlex:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jz        L5606
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+cc_lex.ifcondlevel]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11122]
    call      cc_lex.lxerror
L5606:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.ps
cc_lex.ps:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11123]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.lx]
    call      cc_lex.printsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.psnext
cc_lex.psnext:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11124]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.gethashtablesize
cc_lex.gethashtablesize:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %rdi,	%rax
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L5612
L5610:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jz        L5614
    inc       %rbx
L5614:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstmask]
    jle       L5610
L5612:
    mov       %rax,	%rbx
L5609:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readlinecomment
cc_lex.readlinecomment:
#?>>
#?]]
#---------------
L5616:
L5618:
L5619:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5618
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L5622
    test      %rax,	%rax
    jz        L5623
    cmp       %rax,	92
    jz        L5624
    jmp       L5625
L5622:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5617
L5623:
    jmp       L5617
L5624:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L5627
    cmp       %rax,	10
    jz        L5628
    jmp       L5629
L5627:
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L5626
L5628:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
L5629:
L5626:
L5625:
L5621:
    jmp       L5616
L5617:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
#---------------
    ret       
# End 
# Proc cc_lex.readblockcomment
cc_lex.readblockcomment:
#?>>
#?]]
    sub       %rsp,	40
#---------------
L5631:
L5633:
L5634:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5633
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L5637
    test      %rax,	%rax
    jz        L5638
    cmp       %rax,	42
    jz        L5639
    jmp       L5640
L5637:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L5636
L5638:
    lea       %rcx,	[%rip+L11125]
    call      cc_lex.lxerror
    jmp       L5636
L5639:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	47
    jnz       L5642
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    jmp       L5632
L5642:
L5640:
L5636:
    jmp       L5631
L5632:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.readhex
cc_lex.readhex:
#?>>
    .set cc_lex.readhex.pstart, 64
    .set cc_lex.readhex.p, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readhex.p],	%rax
    mov       %r12,	1
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %r13,	%rax
    xor       %rsi,	%rsi
L5644:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L5647
    lea       %r10,	[%rip+L5646]
    jmp       [%r10 + %rax*8]
    .data
L5646:
    .quad     L5654
    .quad     L5647
    .quad     L5649
    .quad     L5648
    .quad     L5648
    .quad     L5648
    .quad     L5648
    .quad     L5648
    .quad     L5648
    .quad     L5648
    .quad     L5648
    .quad     L5648
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5652
    .quad     L5652
    .quad     L5652
    .quad     L5652
    .quad     L5652
    .quad     L5652
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5655
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5654
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5658
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5653
    .quad     L5653
    .quad     L5653
    .quad     L5653
    .quad     L5653
    .quad     L5653
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5655
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5654
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5647
    .quad     L5658
    .text
L5648:
    xor       %r12,	%r12
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-48]
    add       %rax,	%r10
    mov       %rdi,	%rax
    inc       %rsi
    jmp       L5644
L5649:
    test      %r12,	%r12
    jz        L5651
    inc       qword ptr[%rbp + cc_lex.readhex.p]
    jmp       L5650
L5651:
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    mov       %rdi,	%rax
L5650:
    jmp       L5644
L5652:
    xor       %r12,	%r12
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-65]
    add       %r10,	10
    add       %rax,	%r10
    mov       %rdi,	%rax
    jmp       L5644
L5653:
    xor       %r12,	%r12
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-97]
    add       %r10,	10
    add       %rax,	%r10
    mov       %rdi,	%rax
    jmp       L5644
L5654:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readhex.p]
    mov       %rcx,	[%rbp + cc_lex.readhex.pstart]
    mov       %rdx,	[%rbp + cc_lex.readhex.p]
    mov       %r8,	%rax
    mov       %r9,	16
    call      cc_lex.readrealnumber
    jmp       L5643
L5655:
    inc       %r13
    cmp       %r13,	2
    jle       L5657
    lea       %rcx,	[%rip+L11126]
    call      cc_lex.lxerror
L5657:
    jmp       L5644
L5658:
    test      %r14,	%r14
    jz        L5660
    lea       %rcx,	[%rip+L11127]
    call      cc_lex.lxerror
L5660:
    mov       %r14,	1
    jmp       L5644
L5647:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5645
L5645:
    mov       %rax,	[%rbp + cc_lex.readhex.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readhex.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	16
    jle       L5662
    lea       %rcx,	[%rip+L11128]
    call      cc_lex.lxerror
L5662:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	%rdi
    mov       %r10,	9223372036854775807
    cmp       %rax,	%r10
    jbe       L5664
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L5663
L5664:
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jbe       L5665
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L5663
L5665:
    cmp       %rdi,	2147483647
    jbe       L5666
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L5663
L5666:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5663:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
L5643:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readbinary
cc_lex.readbinary:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       %r13,	%rax
    mov       %r12,	1
L5668:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	12
    jae       L5671
    lea       %r10,	[%rip+L5670]
    jmp       [%r10 + %rax*8]
    .data
L5670:
    .quad     L5677
    .quad     L5671
    .quad     L5673
    .quad     L5672
    .quad     L5676
    .quad     L5676
    .quad     L5676
    .quad     L5676
    .quad     L5676
    .quad     L5676
    .quad     L5676
    .quad     L5676
    .text
L5672:
    xor       %r12,	%r12
    jmp       L5668
L5673:
    test      %r12,	%r12
    jz        L5675
    inc       %r13
L5675:
    jmp       L5668
L5676:
    lea       %rcx,	[%rip+L11129]
    call      cc_lex.lxerror
    jmp       L5668
L5677:
    lea       %rcx,	[%rip+L11130]
    call      cc_lex.lxerror
    jmp       L5668
L5671:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5669
L5669:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r13
    mov       %rsi,	%rax
    mov       %rax,	%r15
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r15
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	64
    jle       L5679
    lea       %rcx,	[%rip+L11131]
    call      cc_lex.lxerror
L5679:
    mov       %r14,	%rsi
    cmp       %r14,	0
    jle       L5682
L5680:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %r10,	%r13
    inc       %r13
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    sub       %rax,	48
    mov       %rdi,	%rax
    dec       %r14
    jnz       L5680
L5682:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    cmp       %rdi,	2147483647
    jb        L5684
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5684:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readoctal
cc_lex.readoctal:
#?>>
    .set cc_lex.readoctal.pstart, 64
    .set cc_lex.readoctal.usigned, -8
    .set cc_lex.readoctal.p, -16
    .set cc_lex.readoctal.av_1, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readoctal.p],	%rax
    mov       %r13,	1
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readoctal.usigned],	%rax
    mov       %r14,	%rax
    xor       %rsi,	%rsi
L5686:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L5689
    lea       %r10,	[%rip+L5688]
    jmp       [%r10 + %rax*8]
    .data
L5688:
    .quad     L5694
    .quad     L5689
    .quad     L5691
    .quad     L5690
    .quad     L5690
    .quad     L5690
    .quad     L5690
    .quad     L5690
    .quad     L5690
    .quad     L5690
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5695
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5698
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5695
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5689
    .quad     L5698
    .text
L5690:
    xor       %r13,	%r13
    inc       %rsi
    jmp       L5686
L5691:
    test      %r13,	%r13
    jz        L5693
    inc       qword ptr[%rbp + cc_lex.readoctal.p]
    jmp       L5692
L5693:
    inc       %rsi
L5692:
    jmp       L5686
L5694:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readoctal.p]
    mov       %rcx,	[%rbp + cc_lex.readoctal.pstart]
    mov       %rdx,	[%rbp + cc_lex.readoctal.p]
    mov       %r8,	%rax
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L5685
L5695:
    inc       %r14
    cmp       %r14,	2
    jle       L5697
    lea       %rcx,	[%rip+L11132]
    call      cc_lex.lxerror
L5697:
    jmp       L5686
L5698:
    mov       %rax,	[%rbp + cc_lex.readoctal.usigned]
    test      %rax,	%rax
    jz        L5700
    lea       %rcx,	[%rip+L11133]
    call      cc_lex.lxerror
L5700:
    mov       %rax,	1
    mov       [%rbp + cc_lex.readoctal.usigned],	%rax
    jmp       L5686
L5689:
    lea       %rax,	[%rip+cc_lex.alphamap]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5702
#cc_lex.readoctal.doalpha:
    mov       %rcx,	[%rbp + cc_lex.readoctal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L5685
L5702:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5687
L5687:
    mov       %rax,	[%rbp + cc_lex.readoctal.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readoctal.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	22
    jg        L5706
    cmp       %rsi,	22
    jnz       L5705
    mov       %rcx,	[%rbp + cc_lex.readoctal.p]
    lea       %rdx,	[%rip+L11134]
    mov       %r8,	22
    call      mlib.cmpstringn
    mov       %r12,	%rax
    cmp       %rax,	0
    jle       L5705
L5706:
    lea       %rcx,	[%rip+L11135]
    call      cc_lex.lxerror
L5705:
    mov       [%rbp + cc_lex.readoctal.av_1],	%rsi
    mov       %rax,	[%rbp + cc_lex.readoctal.av_1]
    cmp       %rax,	0
    jle       L5709
L5707:
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %r10,	[%rbp + cc_lex.readoctal.p]
    inc       qword ptr[%rbp + cc_lex.readoctal.p]
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    sub       %rax,	48
    mov       %rdi,	%rax
    dec       qword ptr[%rbp + cc_lex.readoctal.av_1]
    jnz       L5707
L5709:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    cmp       %rdi,	2147483647
    jb        L5711
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5711:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
L5685:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readdecimal
cc_lex.readdecimal:
#?>>
    .set cc_lex.readdecimal.pstart, 64
    .set cc_lex.readdecimal.p, -8
    .set cc_lex.readdecimal.av_1, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %r14b,	%al
    mov       %r13b,	%al
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readdecimal.p],	%rax
L5713:
L5714:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.digitmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5713
    jmp       L5717
L5716:
    inc       qword ptr[%rbp + cc_lex.readdecimal.p]
L5717:
    mov       %rax,	[%rbp + cc_lex.readdecimal.p]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	48
    jz        L5716
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.p]
    mov       %rsi,	%rax
L5719:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L5722
    lea       %r10,	[%rip+L5721]
    jmp       [%r10 + %rax*8]
    .data
L5721:
    .quad     L5723
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5723
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5724
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5727
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5723
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5724
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5722
    .quad     L5727
    .text
L5723:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.p]
    mov       %rcx,	[%rbp + cc_lex.readdecimal.pstart]
    mov       %rdx,	[%rbp + cc_lex.readdecimal.p]
    mov       %r8,	%rax
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L5712
L5724:
    inc       %r13b
    movzx     %rax,	%r13b
    cmp       %rax,	2
    jle       L5726
    lea       %rcx,	[%rip+L11136]
    call      cc_lex.lxerror
L5726:
    jmp       L5719
L5727:
    test      %r14b,	%r14b
    jz        L5729
    lea       %rcx,	[%rip+L11137]
    call      cc_lex.lxerror
L5729:
    mov       %r14b,	1
    jmp       L5719
L5722:
    lea       %rax,	[%rip+cc_lex.alphamap]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5731
    mov       %rcx,	[%rbp + cc_lex.readdecimal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L5712
L5731:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5720
L5720:
    mov       %rax,	[%rbp + cc_lex.readdecimal.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	20
    jg        L5734
    cmp       %rsi,	20
    jnz       L5733
    mov       %rcx,	[%rbp + cc_lex.readdecimal.p]
    lea       %rdx,	[%rip+L11138]
    mov       %r8,	20
    call      mlib.cmpstringn
    mov       %r12,	%rax
    cmp       %rax,	0
    jle       L5733
L5734:
    lea       %rcx,	[%rip+L11139]
    call      cc_lex.lxerror
L5733:
    mov       [%rbp + cc_lex.readdecimal.av_1],	%rsi
    mov       %rax,	[%rbp + cc_lex.readdecimal.av_1]
    cmp       %rax,	0
    jle       L5737
L5735:
    mov       %rax,	%rdi
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    mov       %r10,	[%rbp + cc_lex.readdecimal.p]
    inc       qword ptr[%rbp + cc_lex.readdecimal.p]
    movzx     %r10,	byte ptr[%r10]
    sub       %r10,	48
    add       %rax,	%r10
    mov       %rdi,	%rax
    dec       qword ptr[%rbp + cc_lex.readdecimal.av_1]
    jnz       L5735
L5737:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    movzx     %rax,	%r13b
    test      %rax,	%rax
    jz        L5739
    cmp       %rax,	1
    jz        L5740
    cmp       %rax,	2
    jz        L5741
    jmp       L5742
L5739:
    cmp       %rdi,	2147483647
    jl        L5744
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L5743
L5744:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5743:
    test      %r14b,	%r14b
    jz        L5746
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jb        L5748
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L5747
L5748:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5747:
    jmp       L5745
L5746:
    cmp       %rdi,	2147483647
    jb        L5750
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5750:
L5745:
    jmp       L5738
L5740:
    test      %r14b,	%r14b
    jz        L5752
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jb        L5754
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L5753
L5754:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5753:
    jmp       L5751
L5752:
    cmp       %rdi,	2147483647
    jb        L5756
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5756:
L5751:
    jmp       L5738
L5741:
    test      %r14b,	%r14b
    jz        L5758
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L5757
L5758:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L5757:
L5742:
L5738:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
L5712:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.checknumbersuffix
cc_lex.checknumbersuffix:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
L5760:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %dil,	%al
    sub       %rax,	76
    cmp       %rax,	42
    jae       L5763
    lea       %r10,	[%rip+L5762]
    jmp       [%r10 + %rax*8]
    .data
L5762:
    .quad     L5764
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5764
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5764
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5763
    .quad     L5764
    .text
L5764:
    jmp       L5760
L5763:
    movzx     %rax,	%dil
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L5766
L5766:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5761
L5761:
    mov       %rax,	3
L5759:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lex.stacksourcefile
cc_lex.stacksourcefile:
#?>>
    .set cc_lex.stacksourcefile.info, -24
    .set cc_lex.stacksourcefile.fullpath, -528
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	568
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_lex.getsourcefile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L5769
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      strlen
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11140]
    call      cc_lex.lxerror
L5769:
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    cmp       %rax,	20
    jl        L5771
    lea       %rcx,	[%rip+L11141]
    call      cc_lex.lxerror
L5771:
    inc       qword ptr[%rip+cc_lex.lx_stackindex]
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.stacksourcefile.fullpath],	%al
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    cmp       %rax,	1
    jle       L5773
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	[%rip+cc_lex.lx_stackindex]
    mov       %rax,	[%rax + %r10*8-16]
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    mov       %rdx,	%rax
    call      strcpy
L5773:
    lea       %rax,	[%rip+cc_lex.headerpath]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L5775
    lea       %rcx,	[%rip+cc_lex.headerpath]
    call      mlib.pcm_copyheapstring
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    mov       %rdx,	%rax
    call      strcat
L5775:
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_lex.headerpathlist]
    mov       %r11,	[%rip+cc_lex.lx_stackindex]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+cc_lex.lxstart]
    mov       [%rbp + cc_lex.stacksourcefile.info],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.stacksourcefile.info+8],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rbp + cc_lex.stacksourcefile.info+16],	%eax
    call      cc_lex.getfileno
    mov       [%rbp + cc_lex.stacksourcefile.info+20],	%eax
    lea       %rax,	[%rbp + cc_lex.stacksourcefile.info]
    lea       %r10,	[%rip+cc_lex.lx_stack]
    mov       %r11,	[%rip+cc_lex.lx_stackindex]
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*2]
    mov       %r8,	[%rax]
    mov       [%r10 + %r11-24],	%r8
    mov       %r8,	[%rax+8]
    mov       [%r10 + %r11-16],	%r8
    mov       %r8,	[%rax+16]
    mov       [%r10 + %r11-8],	%r8
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rcx,	%rdi
    call      cc_lex.setfileno
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
#---------------
    add       %rsp,	568
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.unstacksourcefile
cc_lex.unstacksourcefile:
#?>>
    .set cc_lex.unstacksourcefile.info, -24
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	[%rip+cc_lex.lx_stackindex]
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	%rdi
    call      strlen
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    dec       qword ptr[%rip+cc_lex.lx_stackindex]
    lea       %r10,	[%rip+cc_lex.lx_stack]
    mov       %r11,	%rax
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11-24]
    lea       %rax,	[%rbp + cc_lex.unstacksourcefile.info]
    mov       %r11,	[%r10]
    mov       [%rax],	%r11
    mov       %r11,	[%r10+8]
    mov       [%rax+8],	%r11
    mov       %r11,	[%r10+16]
    mov       [%rax+16],	%r11
    mov       %rax,	[%rbp + cc_lex.unstacksourcefile.info]
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rax,	[%rbp + cc_lex.unstacksourcefile.info+8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       %eax,	[%rbp + cc_lex.unstacksourcefile.info+16]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    movsxd    %rax,	dword ptr[%rbp + cc_lex.unstacksourcefile.info+20]
    mov       %rcx,	%rax
    call      cc_lex.setfileno
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getsourcefile
cc_lex.getsourcefile:
#?>>
    .set cc_lex.getsourcefile.syshdr, 48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.headerpath]
    mov       [%r10],	%al
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.convlcstring
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L5780
L5778:
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5782
    mov       %rax,	%rbx
    jmp       L5777
L5782:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_decls.nsourcefiles]
    jle       L5778
L5780:
    mov       %al,	[%rip+cc_cli.dointheaders]
    test      %al,	%al
    jz        L5784
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      cc_headers.findheader
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5786
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rdi
    call      cc_support.loadbuiltin
    jmp       L5777
L5786:
L5784:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L11142]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5788
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    lea       %rdx,	[%rip+L11143]
    call      cc_support.loadbuiltin
    jmp       L5777
L5788:
    mov       %rcx,	%rsi
    call      mlib.extractpath
    lea       %rcx,	[%rip+cc_lex.headerpath]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rax,	[%rip+cc_lex.headerpath]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L5790
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L5793
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	58
    jnz       L5792
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax+2]
    cmp       %rax,	47
    jnz       L5792
L5793:
    mov       %rcx,	%rsi
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L5795
    mov       %rcx,	%rsi
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L5777
L5795:
    xor       %eax,	%eax
    jmp       L5777
L5792:
L5790:
    mov       %rbx,	[%rip+cc_lex.lx_stackindex]
    cmp       %rbx,	1
    jl        L5798
L5796:
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcat
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L5800
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L5777
L5800:
    dec       %rbx
    cmp       %rbx,	1
    jge       L5796
L5798:
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    cmp       %rax,	1
    jl        L5803
L5801:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcat
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L5805
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.extractpath
    lea       %rcx,	[%rip+cc_lex.headerpath]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L5777
L5805:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_decls.nsearchdirs]
    jle       L5801
L5803:
    xor       %eax,	%eax
L5777:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lex
cc_lex.lex:
#?>>
#?]]
    sub       %rsp,	40
#---------------
#cc_lex.lex.reenter:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L5809
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jnz       L5809
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+cc_decls.lx]
    movsxd    %r10,	dword ptr[%r10+24]
    xor       %r11d,	%r11d
    mov       [%rax + %r10],	%r11b
L5809:
L5810:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5812
    cmp       %rax,	56
    jz        L5813
    jmp       L5814
L5812:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %al,	[%rax+107]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	68
    jnz       L5816
    mov       %al,	67
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5816:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %ax,	[%rax+100]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L5806
L5813:
    call      cc_lex.lexm
    jmp       L5810
L5814:
    jmp       L5806
L5806:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.shownumberstr
cc_lex.shownumberstr:
#?>>
    .set cc_lex.shownumberstr.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.getfilenox
    test      %rax,	%rax
    jz        L5819
    mov       %rcx,	%rbx
    call      cc_lex.getfilenox
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_lex.shownumberstr.$T1],	%r10
    mov       %rcx,	%rbx
    call      cc_lex.getnumberoffsetx
    mov       %r10,	[%rbp + cc_lex.shownumberstr.$T1]
    lea       %r10,	[%r10 + %rax]
    mov       %rdi,	%r10
    jmp       L5818
L5819:
    movsx     %rax,	word ptr[%rbx+28]
    lea       %r10,	[%rip+cc_lex.pastedtokenlist]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
L5818:
    movsxd    %rax,	dword ptr[%rbx+24]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      cc_lex.printstrn
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addnamestr
cc_lex.addnamestr:
#?>>
    .set cc_lex.addnamestr.oldlx, -32
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.addnamestr.oldlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    inc       %rax
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_lex.lxsvalue],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    inc       %rax
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      memcpy
    call      cc_lex.lookup
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    lea       %rax,	[%rbp + cc_lex.addnamestr.oldlx]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	%rdi
L5820:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lxreadstring
cc_lex.lxreadstring:
#?>>
    .set cc_lex.lxreadstring.termchar, 72
    .set cc_lex.lxreadstring.fwide, 80
    .set cc_lex.lxreadstring.str, -2048
    .set cc_lex.lxreadstring.useheap, -2056
    .set cc_lex.lxreadstring.av_1, -2064
    .set cc_lex.lxreadstring.av_2, -2072
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2104
    mov       [%rbp+72],	%rcx
    mov       [%rbp+80],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.lxreadstring.termchar]
    cmp       %rax,	34
    jnz       L5823
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jz        L5825
    mov       %rax,	64
    jmp       L5824
L5825:
    mov       %rax,	63
L5824:
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5822
L5823:
    mov       %al,	61
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L5822:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jnz       L5827
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jnz       L5827
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rbx,	%rdi
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.lxreadstring.useheap],	%rax
    jmp       L5826
L5827:
    lea       %rax,	[%rbp + cc_lex.lxreadstring.str]
    mov       %rdi,	%rax
    mov       %rbx,	%rdi
    mov       %rax,	1
    mov       [%rbp + cc_lex.lxreadstring.useheap],	%rax
L5826:
    xor       %r15,	%r15
L5828:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r13,	%rax
    cmp       %rax,	92
    jz        L5831
    cmp       %rax,	34
    jz        L5832
    cmp       %rax,	39
    jz        L5832
    test      %rax,	%rax
    jz        L5833
    jmp       L5834
L5831:
    mov       %rax,	[%rip+cc_lex.isincludefile]
    test      %rax,	%rax
    jz        L5836
    mov       %r13,	47
    jmp       L5837
L5836:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r13,	%rax
#cc_lex.lxreadstring.reenter:
    lea       %rax,	[%r13-10]
    cmp       %rax,	111
    jae       L5841
    lea       %r10,	[%rip+L5840]
    jmp       [%r10 + %rax*8]
    .data
L5840:
    .quad     L5871
    .quad     L5841
    .quad     L5841
    .quad     L5868
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5865
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5867
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5858
    .quad     L5858
    .quad     L5858
    .quad     L5858
    .quad     L5858
    .quad     L5858
    .quad     L5858
    .quad     L5858
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5866
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5842
    .quad     L5843
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5844
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5845
    .quad     L5841
    .quad     L5841
    .quad     L5841
    .quad     L5846
    .quad     L5841
    .quad     L5847
    .quad     L5841
    .quad     L5848
    .quad     L5841
    .quad     L5849
    .text
L5842:
    mov       %r13,	7
    jmp       L5839
L5843:
    mov       %r13,	8
    jmp       L5839
L5844:
    mov       %r13,	12
    jmp       L5839
L5845:
    mov       %r13,	10
    jmp       L5839
L5846:
    mov       %r13,	13
    jmp       L5839
L5847:
    mov       %r13,	9
    jmp       L5839
L5848:
    mov       %r13,	11
    jmp       L5839
L5849:
    xor       %r13,	%r13
L5850:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    sub       %rax,	48
    cmp       %rax,	55
    jae       L5854
    lea       %r10,	[%rip+L5853]
    jmp       [%r10 + %rax*8]
    .data
L5853:
    .quad     L5857
    .quad     L5857
    .quad     L5857
    .quad     L5857
    .quad     L5857
    .quad     L5857
    .quad     L5857
    .quad     L5857
    .quad     L5857
    .quad     L5857
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5855
    .quad     L5855
    .quad     L5855
    .quad     L5855
    .quad     L5855
    .quad     L5855
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5854
    .quad     L5856
    .quad     L5856
    .quad     L5856
    .quad     L5856
    .quad     L5856
    .quad     L5856
    .text
L5855:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	65
    add       %rax,	10
    mov       %r13,	%rax
    jmp       L5852
L5856:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	97
    add       %rax,	10
    mov       %r13,	%rax
    jmp       L5852
L5857:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	48
    mov       %r13,	%rax
    jmp       L5852
L5854:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5851
L5852:
    jmp       L5850
L5851:
    jmp       L5839
L5858:
    mov       %rax,	48
    sub       %r13,	%rax
    mov       %rax,	2
    mov       [%rbp + cc_lex.lxreadstring.av_1],	%rax
L5859:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    cmp       %rax,	48
    jz        L5863
    cmp       %rax,	49
    jz        L5863
    cmp       %rax,	50
    jz        L5863
    cmp       %rax,	51
    jz        L5863
    cmp       %rax,	52
    jz        L5863
    cmp       %rax,	53
    jz        L5863
    cmp       %rax,	54
    jz        L5863
    cmp       %rax,	55
    jnz       L5864
L5863:
    mov       %rax,	%r13
    shl       %rax,	3
    add       %rax,	%r14
    sub       %rax,	48
    mov       %r13,	%rax
    jmp       L5862
L5864:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L5861
L5862:
    dec       qword ptr[%rbp + cc_lex.lxreadstring.av_1]
    jnz       L5859
L5861:
    jmp       L5839
L5865:
    mov       %r13,	34
    jmp       L5839
L5866:
    mov       %r13,	92
    jmp       L5839
L5867:
    mov       %r13,	39
    jmp       L5839
L5868:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jnz       L5870
    inc       qword ptr[%rip+cc_lex.lxsptr]
L5870:
    jmp       L5828
L5871:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L5828
L5841:
L5839:
    jmp       L5830
L5832:
    cmp       %r13,	[%rbp + cc_lex.lxreadstring.termchar]
    jz        L5829
L5873:
    jmp       L5830
L5833:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11144]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11145]
    call      cc_lex.lxerror
L5834:
L5830:
#cc_lex.lxreadstring.normalchar:
L5837:
    mov       %rax,	[%rbp + cc_lex.lxreadstring.useheap]
    test      %rax,	%rax
    jnz       L5875
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%r13b
    mov       [%rax],	%r10b
    jmp       L5874
L5875:
    inc       %r15
    cmp       %r15,	2048
    jge       L5876
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%r13b
    mov       [%rax],	%r10b
    jmp       L5874
L5876:
    lea       %rcx,	[%rip+L11146]
    call      cc_lex.lxerror
L5874:
    jmp       L5828
L5829:
    xor       %eax,	%eax
    mov       [%rdi],	%al
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jz        L5878
    mov       %rax,	%r15
    shl       %rax,	1
    add       %rax,	2
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %r12,	%rax
    mov       [%rbp + cc_lex.lxreadstring.av_2],	%r15
    mov       %rax,	[%rbp + cc_lex.lxreadstring.av_2]
    cmp       %rax,	0
    jle       L5881
L5879:
    mov       %rax,	%rbx
    inc       %rbx
    movzx     %rax,	byte ptr[%rax]
    mov       %r10,	%rsi
    add       %rsi,	2
    mov       [%r10],	%ax
    dec       qword ptr[%rbp + cc_lex.lxreadstring.av_2]
    jnz       L5879
L5881:
    xor       %eax,	%eax
    mov       [%rsi],	%ax
    mov       %rax,	%r12
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    jmp       L5877
L5878:
    mov       %rax,	[%rbp + cc_lex.lxreadstring.useheap]
    test      %rax,	%rax
    jz        L5882
    mov       %eax,	%r15d
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%r15+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    lea       %rax,	[%r15+1]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    lea       %rdx,	[%rbp + cc_lex.lxreadstring.str]
    mov       %r8,	%rax
    call      memcpy
    jmp       L5877
L5882:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    sub       %r10,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       [%rax+24],	%r10d
L5877:
#---------------
    add       %rsp,	2104
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlisttoken
cc_lex.addlisttoken:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L5885
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L5884
L5885:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L5884:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lex.addlisttoken_copy
cc_lex.addlisttoken_copy:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    mov       %rax,	%r12
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L5888
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L5887
L5888:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L5887:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlist_nextlx
cc_lex.addlist_nextlx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L5891
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L5890
L5891:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L5890:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlisttoken_seq
cc_lex.addlisttoken_seq:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    jmp       L5894
L5893:
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    mov       %rax,	%r12
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L5897
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L5896
L5897:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L5896:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
    mov       %r12,	[%r12+8]
L5894:
    test      %r12,	%r12
    jnz       L5893
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlistmparam
cc_lex.addlistmparam:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L5900
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L5899
L5900:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L5899:
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lex.dodefine
cc_lex.dodefine:
#?>>
    .set cc_lex.dodefine.stlist, -8
    .set cc_lex.dodefine.stlistx, -16
    .set cc_lex.dodefine.tklist, -24
    .set cc_lex.dodefine.tklistx, -32
    .set cc_lex.dodefine.ntokens, -40
    .set cc_lex.dodefine.paramno, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
#---------------
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5903
    lea       %rcx,	[%rip+L11147]
    call      cc_lex.lxerror
L5903:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rsi,	[%rax]
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rsi+92],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %al,	[%rax+20]
    mov       [%rsi+113],	%al
    mov       %al,	[%rsi+107]
    mov       [%rsi+88],	%al
    mov       %al,	67
    mov       [%rsi+107],	%al
    mov       %al,	1
    mov       [%rsi+109],	%al
    xor       %r14,	%r14
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	40
    jnz       L5905
    inc       qword ptr[%rip+cc_lex.lxsptr]
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.stlistx],	%rax
    mov       [%rbp + cc_lex.dodefine.stlist],	%rax
    lea       %rax,	[%rsi+108]
    or        byte ptr[%rax],	4
    call      cc_lex.lexreadtoken
L5906:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5909
    cmp       %rax,	14
    jz        L5910
    cmp       %rax,	21
    jz        L5911
    jmp       L5912
L5909:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r12,	[%rax]
    mov       %rdi,	[%rbp + cc_lex.dodefine.stlist]
    jmp       L5914
L5913:
    mov       %rax,	[%rdi]
    cmp       %rax,	%r12
    jnz       L5917
    lea       %rcx,	[%rip+L11148]
    call      cc_lex.lxerror
L5917:
    mov       %rdi,	[%rdi+8]
L5914:
    test      %rdi,	%rdi
    jnz       L5913
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    xor       %eax,	%eax
    mov       [%rbx+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.dodefine.stlist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.stlistx]
    mov       %r8,	%rbx
    call      cc_lex.addlistmparam
    inc       %r14
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5919
    call      cc_lex.lexreadtoken
L5919:
    jmp       L5908
L5910:
    jmp       L5907
L5911:
    lea       %rcx,	[%rip+L11149]
    call      cc_lex.addnamestr
    mov       %r12,	%rax
    lea       %rax,	[%rsi+108]
    or        byte ptr[%rax],	2
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L5921
    lea       %rcx,	[%rip+L11150]
    call      cc_lex.lxerror
L5921:
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    xor       %eax,	%eax
    mov       [%rbx+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.dodefine.stlist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.stlistx]
    mov       %r8,	%rbx
    call      cc_lex.addlistmparam
    inc       %r14
    jmp       L5907
L5912:
    lea       %rcx,	[%rip+L11151]
    call      cc_lex.lxerror
L5908:
    jmp       L5906
L5907:
    mov       %rax,	[%rbp + cc_lex.dodefine.stlist]
    mov       [%rsi+80],	%rax
L5905:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.tklistx],	%rax
    mov       [%rbp + cc_lex.dodefine.tklist],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.ntokens],	%rax
L5922:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L5925
    cmp       %rax,	57
    jz        L5925
    cmp       %rax,	67
    jz        L5926
    jmp       L5927
L5925:
    jmp       L5923
L5926:
    mov       %rdi,	[%rsi+80]
    mov       %rax,	1
    mov       [%rbp + cc_lex.dodefine.paramno],	%rax
    jmp       L5929
L5928:
    mov       %rax,	[%rdi]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    cmp       %rax,	%r10
    jnz       L5932
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	2
    or        [%rax],	%r10b
    mov       %ax,	[%rbp + cc_lex.dodefine.paramno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%ax
    jmp       L5930
L5932:
    mov       %rdi,	[%rdi+8]
    inc       qword ptr[%rbp + cc_lex.dodefine.paramno]
L5929:
    test      %rdi,	%rdi
    jnz       L5928
L5930:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    cmp       %rax,	%rsi
    jnz       L5934
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	1
    or        [%rax],	%r10b
L5934:
L5927:
L5924:
    inc       qword ptr[%rbp + cc_lex.dodefine.ntokens]
    call      cc_lex.alloctoken
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%rax]
    mov       [%r13],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r13+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r13+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r13+24],	%r10
    lea       %rcx,	[%rbp + cc_lex.dodefine.tklist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.tklistx]
    mov       %r8,	%r13
    call      cc_lex.addlisttoken
    jmp       L5922
L5923:
    mov       %rax,	[%rbp + cc_lex.dodefine.tklist]
    mov       [%rsi+72],	%rax
    mov       [%rsi+111],	%r14b
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readalphanumeric
cc_lex.readalphanumeric:
#?>>
#?]]
#---------------
L5936:
L5937:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5936
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	%rcx
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %al,	58
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%rcx
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.inmacrostack
cc_lex.inmacrostack:
#?>>
#?]]
#---------------
    jmp       L5941
L5940:
    mov       %rax,	[%rdx]
    cmp       %rax,	%rcx
    jnz       L5944
    mov       %rax,	1
    jmp       L5939
L5944:
    mov       %rdx,	[%rdx+8]
L5941:
    test      %rdx,	%rdx
    jnz       L5940
    xor       %eax,	%eax
L5939:
#---------------
    ret       
# End 
# Proc cc_lex.showtokens
cc_lex.showtokens:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11152]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L5947
L5946:
    mov       %rcx,	%rbx
    call      cc_lex.showtoken
    mov       %rbx,	[%rbx+8]
L5947:
    test      %rbx,	%rbx
    jnz       L5946
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11153]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexa
cc_lex.lexa:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi]
    cmp       %rax,	[%rip+cc_lex.normaltk]
    jnz       L5951
    call      cc_lex.lexreadtoken
    jmp       L5949
L5951:
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L5953
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L5949
L5953:
    mov       %rax,	[%rdi]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	[%rdi]
    mov       %rax,	[%rax+8]
    mov       [%rdi],	%rax
L5949:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexm
cc_lex.lexm:
#?>>
    .set cc_lex.lexm.newlineno, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
L5955:
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jz        L5958
    mov       %rax,	[%rip+cc_lex.tkptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	[%rip+cc_lex.tkptr]
    mov       %rax,	[%rax+8]
    mov       [%rip+cc_lex.tkptr],	%rax
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jnz       L5960
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L5962
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jnz       L5962
    call      cc_lex.peeklb
    test      %rax,	%rax
    jz        L5962
    mov       %rcx,	[%rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       %eax,	[%rip+cc_decls.slineno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lexm.doreset],	%rax
    jmp       L5963
L5962:
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L5960:
    jmp       L5954
L5958:
    mov       %rax,	[%rip+cc_lex.lexm.doreset]
    test      %rax,	%rax
    jz        L5965
    mov       %rcx,	[%rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       %eax,	[%rip+cc_decls.slineno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L5965:
    mov       %rax,	[%rip+cc_lex.firstsymbol]
    test      %rax,	%rax
    jz        L5967
    xor       %eax,	%eax
    mov       [%rip+cc_lex.firstsymbol],	%rax
    call      cc_lex.dospecialinclude
L5967:
    call      cc_lex.lexreadtoken
#cc_lex.lexm.test1:
L5963:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	4
    jz        L5969
    cmp       %rax,	67
    jz        L5970
    jmp       L5971
L5969:
    call      cc_lex.dolexdirective
    test      %rax,	%rax
    jnz       L5954
L5973:
    jmp       L5955
L5970:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+107]
    cmp       %rax,	69
    jnz       L5976
L5975:
    call      cc_lex.getfileno
    mov       [%rip+cc_decls.sfileno],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rip+cc_decls.slineno],	%rax
    movsx     %rax,	word ptr[%rdi+100]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+cc_decls.nextlx]
    mov       %r8,	[%rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
    jmp       L5954
L5976:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L5979
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jz        L5978
L5979:
    jmp       L5954
L5978:
L5974:
    jmp       L5968
L5971:
    jmp       L5954
L5968:
    call      cc_lex.getfileno
    mov       [%rip+cc_decls.sfileno],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rip+cc_decls.slineno],	%rax
    movzx     %rax,	byte ptr[%rdi+108]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L5981
    call      cc_lex.peeklb
    test      %rax,	%rax
    jz        L5954
L5983:
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_lex.lexm.newlineno]
    push      %rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    lea       %r8,	[%rip+cc_lex.normaltk]
    mov       %r9,	1
    sub       %rsp,	32
    call      cc_lex.expandfnmacro
    add       %rsp,	48
    mov       [%rip+cc_lex.tkptr],	%rax
    mov       %rax,	[%rbp + cc_lex.lexm.newlineno]
    mov       [%rip+cc_decls.slineno],	%rax
    jmp       L5980
L5981:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    lea       %r8,	[%rip+cc_lex.normaltk]
    mov       %r9,	1
    call      cc_lex.expandobjmacro
    mov       [%rip+cc_lex.tkptr],	%rax
L5980:
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jnz       L5985
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L5985:
    jmp       L5955
L5954:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.peeklb
cc_lex.peeklb:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	40
    jz        L5989
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jnz       L5988
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	40
    jnz       L5988
L5989:
    mov       %rax,	1
    jmp       L5986
L5988:
    xor       %eax,	%eax
L5986:
#---------------
    ret       
# End 
# Proc cc_lex.peektk
cc_lex.peektk:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx+8]
    mov       %rcx,	%rax
    test      %rcx,	%rcx
    jnz       L5992
    xor       %eax,	%eax
    jmp       L5990
L5992:
    movzx     %rax,	byte ptr[%rcx+21]
    cmp       %rax,	13
    jnz       L5994
    mov       %rax,	1
    jmp       L5990
L5994:
    xor       %eax,	%eax
L5990:
#---------------
    ret       
# End 
# Proc cc_lex.expandobjmacro
cc_lex.expandobjmacro:
#?>>
    .set cc_lex.expandobjmacro.m, 64
    .set cc_lex.expandobjmacro.macrostack, 72
    .set cc_lex.expandobjmacro.tksource, 80
    .set cc_lex.expandobjmacro.frombaselevel, 88
    .set cc_lex.expandobjmacro.newmacro, -32
    .set cc_lex.expandobjmacro.expanded, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       %rax,	[%rax+72]
    mov       %rdi,	%rax
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L5997
L5996:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	67
    jnz       L6000
    mov       %r14,	[%rbx]
    movzx     %rax,	byte ptr[%r14+109]
    cmp       %rax,	1
    jz        L6003
    movzx     %rax,	byte ptr[%r14+107]
    cmp       %rax,	69
    jnz       L6002
L6003:
    mov       %r12,	1
    jmp       L5998
L6002:
    jmp       L5999
L6000:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	7
    jnz       L6004
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L5998
L6004:
L5999:
    mov       %rbx,	[%rbx+8]
L5997:
    test      %rbx,	%rbx
    jnz       L5996
L5998:
    test      %r12,	%r12
    jnz       L6006
    mov       %rax,	%rdi
    jmp       L5995
L6006:
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       [%rbp + cc_lex.expandobjmacro.newmacro],	%rax
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.macrostack]
    mov       [%rbp + cc_lex.expandobjmacro.newmacro+8],	%rax
    test      %r13,	%r13
    jz        L6008
    sub       %rsp,	8
    push      0
    mov       %rcx,	[%rbp + cc_lex.expandobjmacro.m]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_lex.substituteargs
    add       %rsp,	48
    mov       %rsi,	%rax
    jmp       L6007
L6008:
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       %rsi,	[%rax+72]
L6007:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + cc_lex.expandobjmacro.newmacro]
    lea       %r8,	[%rbp + cc_lex.expandobjmacro.expanded]
    call      cc_lex.scantokenseq
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L5995:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.expandfnmacro
cc_lex.expandfnmacro:
#?>>
    .set cc_lex.expandfnmacro.frombaselevel, 88
    .set cc_lex.expandfnmacro.endlineno, 96
    .set cc_lex.expandfnmacro.args, -1600
    .set cc_lex.expandfnmacro.expargs, -3200
    .set cc_lex.expandfnmacro.newmacro, -3232
    .set cc_lex.expandfnmacro.expanded, -3240
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	3280
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.args]
    mov       %r8,	%r14
    call      cc_lex.readmacrocall
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_lex.expandfnmacro.frombaselevel]
    test      %rax,	%rax
    jz        L6011
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %r10,	[%rbp + cc_lex.expandfnmacro.endlineno]
    mov       [%r10],	%rax
L6011:
    mov       %rsi,	1
    cmp       %rbx,	1
    jl        L6014
L6012:
    xor       %eax,	%eax
    mov       [%rbp + %rsi*8 + cc_lex.expandfnmacro.expargs-8],	%rax
    inc       %rsi
    cmp       %rsi,	%rbx
    jle       L6012
L6014:
    sub       %rsp,	8
    mov       %rax,	%r13
    push      %rax
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.args]
    lea       %r8,	[%rbp + cc_lex.expandfnmacro.expargs]
    mov       %r9,	%rbx
    sub       %rsp,	32
    call      cc_lex.substituteargs
    add       %rsp,	48
    mov       %rdi,	%rax
    mov       [%rbp + cc_lex.expandfnmacro.newmacro],	%r12
    mov       [%rbp + cc_lex.expandfnmacro.newmacro+8],	%r13
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.newmacro]
    lea       %r8,	[%rbp + cc_lex.expandfnmacro.expanded]
    call      cc_lex.scantokenseq
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L6009:
#---------------
    add       %rsp,	3280
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.scantokenseq
cc_lex.scantokenseq:
#?>>
    .set cc_lex.scantokenseq.tk, 64
    .set cc_lex.scantokenseq.expanded, 80
    .set cc_lex.scantokenseq.newtk, -8
    .set cc_lex.scantokenseq.newtkx, -16
    .set cc_lex.scantokenseq.dummy, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
#---------------
#cc_lex.scantokenseq.reenter:
L6016:
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.scantokenseq.newtkx],	%rax
    mov       [%rbp + cc_lex.scantokenseq.newtk],	%rax
    xor       %r12,	%r12
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rbx,	[%rbp + cc_lex.scantokenseq.tk]
    jmp       L6018
L6017:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L6022
L6021:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jz        L6025
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	69
    jnz       L6024
L6025:
    xor       %r13,	%r13
    jmp       L6019
L6024:
L6022:
L6020:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jz        L6019
L6027:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
L6018:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jnz       L6017
L6019:
    test      %r13,	%r13
    jz        L6029
    mov       %rax,	%rbx
    jmp       L6015
L6029:
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rbx
    jmp       L6031
L6030:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L6035
L6034:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rsi,	[%rax]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	1
    jnz       L6037
    test      %r12,	%r12
    jnz       L6037
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+23]
    and       %rax,	4
    jnz       L6040
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jz        L6039
L6040:
    jmp       L6041
L6039:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    call      cc_lex.inmacrostack
    test      %rax,	%rax
    jz        L6043
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtkx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	4
    or        [%rax],	%r10b
    jmp       L6044
L6043:
    xor       %r13,	%r13
    movzx     %rax,	byte ptr[%rsi+108]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L6046
    mov       %rcx,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.peektk
    test      %rax,	%rax
    jz        L6041
L6048:
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.lexa
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_lex.scantokenseq.dummy]
    push      %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    lea       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %r9,	1
    sub       %rsp,	32
    call      cc_lex.expandfnmacro
    add       %rsp,	48
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_seq
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    jmp       L6031
L6046:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    lea       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    xor       %r9d,	%r9d
    call      cc_lex.expandobjmacro
    mov       %rdi,	%rax
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_seq
L6045:
    jmp       L6036
L6037:
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	92
    jnz       L6049
    mov       %r12,	1
    jmp       L6041
L6049:
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	69
    jnz       L6050
    call      cc_lex.alloctokenz
    mov       %rdi,	%rax
    movsx     %rax,	word ptr[%rsi+100]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_copy
    jmp       L6051
L6050:
    xor       %r12,	%r12
    jmp       L6041
L6036:
    jmp       L6033
L6035:
#cc_lex.scantokenseq.simpletoken:
L6041:
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
L6033:
#cc_lex.scantokenseq.skip:
L6044:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jz        L6032
L6053:
#cc_lex.scantokenseq.skip2:
L6051:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
L6031:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jnz       L6030
L6032:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jz        L6055
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtk]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
    jmp       L6016
L6055:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtk]
L6015:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readmacrocall
cc_lex.readmacrocall:
#?>>
    .set cc_lex.readmacrocall.args, 80
    .set cc_lex.readmacrocall.tksource, 88
    .set cc_lex.readmacrocall.tklist, -8
    .set cc_lex.readmacrocall.tklistx, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L6058
    lea       %rcx,	[%rip+L11154]
    call      cc_lex.lxerror
L6058:
    movzx     %rax,	byte ptr[%r15+111]
    mov       %rdi,	%rax
    xor       %r12,	%r12
    mov       %rax,	%rdi
    test      %rax,	%rax
    jnz       L6060
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L6062
    lea       %rcx,	[%rip+L11155]
    call      cc_lex.lxerror
L6062:
    xor       %eax,	%eax
    jmp       L6056
L6060:
    mov       %rsi,	1
    mov       %rbx,	1
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readmacrocall.tklistx],	%rax
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    movzx     %rax,	byte ptr[%r15+108]
    shr       %eax,	1
    and       %eax,	1
    mov       %r13,	%rax
    xor       %r14,	%r14
L6063:
    cmp       %rsi,	%rdi
    jnz       L6066
    test      %r13,	%r13
    jz        L6066
    mov       %r14,	1
L6066:
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L6068
    cmp       %rax,	57
    jz        L6069
    cmp       %rax,	13
    jz        L6070
    cmp       %rax,	14
    jz        L6071
    jmp       L6072
L6068:
    cmp       %rbx,	1
    jnz       L6074
    test      %r14,	%r14
    jnz       L6074
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    test      %rax,	%rax
    jnz       L6076
    call      cc_lex.alloctokenz
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    call      cc_lex.getfileno
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %rdx,	%rax
    call      cc_lex.setfilenox
    mov       %al,	66
    mov       %r10,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       [%r10+21],	%al
L6076:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readmacrocall.tklistx],	%rax
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    inc       %rsi
    jmp       L6073
L6074:
    jmp       L6077
L6073:
    jmp       L6067
L6069:
    lea       %rcx,	[%rip+L11156]
    call      cc_lex.lxerror
    jmp       L6067
L6070:
    inc       %rbx
    jmp       L6077
L6071:
    cmp       %rbx,	1
    jle       L6079
    dec       %rbx
    lea       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    lea       %rdx,	[%rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
    jmp       L6078
L6079:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    test      %rax,	%rax
    jnz       L6081
    call      cc_lex.alloctokenz
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    call      cc_lex.getfileno
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %rdx,	%rax
    call      cc_lex.setfilenox
    mov       %al,	66
    mov       %r10,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       [%r10+21],	%al
L6081:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    jmp       L6064
L6078:
    jmp       L6067
L6072:
#cc_lex.readmacrocall.addtoken:
L6077:
    lea       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    lea       %rdx,	[%rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
L6067:
    jmp       L6063
L6064:
    cmp       %rsi,	%rdi
    jz        L6083
    lea       %rax,	[%rsi+1]
    cmp       %rax,	%rdi
    jnz       L6085
    test      %r13,	%r13
    jz        L6085
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    jmp       L6084
L6085:
    lea       %rcx,	[%rip+L11157]
    call      cc_lex.lxerror
L6084:
L6083:
    mov       %rax,	%rdi
L6056:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.substituteargs
cc_lex.substituteargs:
#?>>
    .set cc_lex.substituteargs.expargs, 80
    .set cc_lex.substituteargs.nargs, 88
    .set cc_lex.substituteargs.macrostack, 96
    .set cc_lex.substituteargs.newtk, -8
    .set cc_lex.substituteargs.newtkx, -16
    .set cc_lex.substituteargs.niltk, -24
    .set cc_lex.substituteargs.tkexp, -32
    .set cc_lex.substituteargs.tk, -64
    .set cc_lex.substituteargs.n, -72
    .set cc_lex.substituteargs.i, -80
    .set cc_lex.substituteargs.expanded, -88
    .set cc_lex.substituteargs.hhpoints, -2088
    .set cc_lex.substituteargs.nhashhash, -2096
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2128
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rdi,	[%r13+80]
    mov       %rax,	[%r13+72]
    mov       %rsi,	%rax
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.newtkx],	%rax
    mov       [%rbp + cc_lex.substituteargs.newtk],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.nhashhash],	%rax
    xor       %r12,	%r12
    jmp       L6088
L6087:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	5
    jz        L6091
    cmp       %rax,	7
    jz        L6092
    jmp       L6093
L6091:
    mov       %rax,	[%rbp + cc_lex.substituteargs.nargs]
    test      %rax,	%rax
    jz        L6095
    mov       %rbx,	[%rbx+8]
    test      %rbx,	%rbx
    jnz       L6097
    lea       %rcx,	[%rip+L11158]
    call      cc_lex.lxerror
L6097:
    movzx     %rax,	byte ptr[%rbx+23]
    and       %rax,	2
    jnz       L6099
    lea       %rcx,	[%rip+L11159]
    call      cc_lex.lxerror
L6099:
    movsx     %rax,	word ptr[%rbx+28]
    mov       [%rbp + cc_lex.substituteargs.n],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_lex.substituteargs.tk]
    call      cc_lex.stringify
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    lea       %r8,	[%rbp + cc_lex.substituteargs.tk]
    call      cc_lex.addlisttoken_copy
    jmp       L6094
L6095:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rbx
    call      cc_lex.addlisttoken
    mov       %al,	6
    mov       %r10,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       [%r10+21],	%al
L6094:
    jmp       L6090
L6092:
    cmp       %rbx,	%rsi
    jnz       L6101
    lea       %rcx,	[%rip+L11160]
    call      cc_lex.lxerror
L6101:
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    cmp       %rax,	250
    jl        L6103
    lea       %rcx,	[%rip+L11161]
    call      cc_lex.lxerror
L6103:
    inc       qword ptr[%rbp + cc_lex.substituteargs.nhashhash]
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    mov       %r10,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       [%rbp + %rax*8 + cc_lex.substituteargs.hhpoints-8],	%r10
    jmp       L6090
L6093:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	67
    jnz       L6105
    movzx     %rax,	byte ptr[%rbx+23]
    and       %rax,	2
    jz        L6105
    mov       %rax,	[%rbp + cc_lex.substituteargs.nargs]
    test      %rax,	%rax
    jz        L6105
    movsx     %rax,	word ptr[%rbx+28]
    mov       [%rbp + cc_lex.substituteargs.n],	%rax
    mov       %rax,	[%rbx+8]
    test      %rax,	%rax
    jz        L6109
    mov       %rax,	[%rbx+8]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	7
    jz        L6108
L6109:
    test      %r12,	%r12
    jz        L6107
    movzx     %rax,	byte ptr[%r12+21]
    cmp       %rax,	7
    jnz       L6107
L6108:
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rax
    call      cc_lex.addlisttoken_seq
    jmp       L6106
L6107:
    mov       %rax,	[%rbp + cc_lex.substituteargs.expargs]
    mov       %r10,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + cc_lex.substituteargs.tkexp],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.tkexp]
    test      %rax,	%rax
    jnz       L6111
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_lex.substituteargs.macrostack]
    lea       %r8,	[%rbp + cc_lex.substituteargs.expanded]
    call      cc_lex.scantokenseq
    mov       %r10,	[%rbp + cc_lex.substituteargs.expargs]
    mov       %r11,	[%rbp + cc_lex.substituteargs.n]
    mov       [%r10 + %r11*8-8],	%rax
    mov       [%rbp + cc_lex.substituteargs.tkexp],	%rax
L6111:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	[%rbp + cc_lex.substituteargs.tkexp]
    call      cc_lex.addlisttoken_seq
L6106:
    jmp       L6104
L6105:
#cc_lex.substituteargs.doother:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rbx
    call      cc_lex.addlisttoken_copy
L6104:
L6090:
    mov       %r12,	%rbx
    mov       %rbx,	[%rbx+8]
L6088:
    test      %rbx,	%rbx
    jnz       L6087
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    test      %rax,	%rax
    jz        L6114
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.niltk],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_lex.substituteargs.i],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    cmp       %rax,	1
    jl        L6117
L6115:
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    cmp       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    jge       L6119
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    lea       %r10,	[%rbp + %rax*8 + cc_lex.substituteargs.hhpoints]
    mov       %rax,	%r10
    jmp       L6118
L6119:
    lea       %rax,	[%rbp + cc_lex.substituteargs.niltk]
L6118:
    mov       %r10,	[%rbp + cc_lex.substituteargs.i]
    mov       %r10,	[%rbp + %r10*8 + cc_lex.substituteargs.hhpoints-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lex.pastetokens
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    inc       %rax
    mov       [%rbp + cc_lex.substituteargs.i],	%rax
    cmp       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    jle       L6115
L6117:
L6114:
    mov       %rax,	[%rbp + cc_lex.substituteargs.newtk]
L6086:
#---------------
    add       %rsp,	2128
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.strtoken
cc_lex.strtoken:
#?>>
    .set cc_lex.strtoken.l, -32
    .set cc_lex.strtoken.$T1, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rax,	%rsi
    lea       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    cmp       %rax,	67
    jz        L6122
    cmp       %rax,	59
    jz        L6123
    cmp       %rax,	60
    jz        L6123
    cmp       %rax,	58
    jz        L6124
    cmp       %rax,	63
    jz        L6125
    cmp       %rax,	64
    jz        L6125
    cmp       %rax,	61
    jz        L6126
    cmp       %rax,	56
    jz        L6127
    cmp       %rax,	57
    jz        L6128
    cmp       %rax,	70
    jz        L6129
    cmp       %rax,	86
    jz        L6129
    cmp       %rax,	85
    jz        L6129
    cmp       %rax,	88
    jz        L6129
    jmp       L6130
L6122:
#cc_lex.strtoken.doname:
L6131:
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    movzx     %rax,	byte ptr[%rax+106]
    mov       [%r12],	%rax
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    mov       %rax,	[%rax]
    jmp       L6120
L6123:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       [%r12],	%rax
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    test      %rax,	%rax
    jz        L6133
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_lex.strtoken.$T1],	%r10
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getnumberoffsetx
    mov       %r10,	[%rbp + cc_lex.strtoken.$T1]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	%r10
    jmp       L6120
L6133:
    movsx     %rax,	word ptr[%rbp + cc_lex.strtoken.l+28]
    lea       %r10,	[%rip+cc_lex.pastedtokenlist]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rax,	%r10
    jmp       L6120
L6132:
    jmp       L6121
L6124:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       [%r12],	%rax
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    jmp       L6120
L6125:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	34
    call      cc_lex.strstring
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L6120
L6126:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	39
    call      cc_lex.strstring
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L6120
L6127:
    mov       %rax,	[%rip+cc_lex.dowhitespace]
    test      %rax,	%rax
    jz        L6135
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    inc       %rax
    mov       [%r12],	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %al,	10
    mov       [%rbx],	%al
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    lea       %r11,	[%rbx+1]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    jmp       L6134
L6135:
    mov       %rax,	1
    mov       [%r12],	%rax
    lea       %rax,	[%rip+L11162]
    jmp       L6120
L6134:
    mov       %rax,	%rbx
    jmp       L6120
L6128:
    xor       %eax,	%eax
    mov       [%r12],	%rax
    lea       %rax,	[%rip+L11163]
    jmp       L6120
L6129:
    jmp       L6131
L6130:
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r12],	%rax
    test      %rax,	%rax
    jz        L6137
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	107
    jz        L6139
    mov       %rax,	%rdi
    jmp       L6120
L6139:
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+1]
    mov       %rcx,	%r10
    call      strlen
    mov       [%r12],	%rax
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+1]
    mov       %rax,	%r10
    jmp       L6120
L6138:
    jmp       L6136
L6137:
    lea       %rax,	[%rip+L11163]
    jmp       L6120
L6136:
L6121:
    lea       %rax,	[%rip+L11163]
L6120:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.strstring
cc_lex.strstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    mov       %rax,	%r12
    shl       %rax,	1
    add       %rax,	4
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    test      %r14,	%r14
    jz        L6142
    mov       [%rbx],	%r14b
    inc       %rbx
L6142:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      cc_lib.convertstringc
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r13],	%rax
    test      %r14,	%r14
    jz        L6144
    mov       %rax,	[%r13]
    mov       %r10b,	%r14b
    mov       [%rdi + %rax],	%r10b
    mov       %rax,	%r13
    inc       qword ptr[%rax]
L6144:
    mov       %rax,	%rdi
L6140:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.emittoken
cc_lex.emittoken:
#?>>
    .set cc_lex.emittoken.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	56
    jnz       L6147
    mov       %rax,	[%rip+cc_lex.lasttoken]
    cmp       %rax,	56
    jz        L6145
L6147:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_lex.emittoken.length]
    call      cc_lex.strtoken
    mov       %rdi,	%rax
    test      %r12,	%r12
    jnz       L6150
    movzx     %rax,	byte ptr[%rbx+21]
    mov       %rcx,	[%rip+cc_lex.lasttoken]
    mov       %rdx,	%rax
    call      cc_lex.needspace
    test      %rax,	%rax
    jz        L6149
L6150:
    mov       %rcx,	%rsi
    mov       %rdx,	32
    call      mlib.gs_char
L6149:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_lex.emittoken.length]
    call      mlib.gs_strn
    movzx     %rax,	byte ptr[%rbx+21]
    mov       [%rip+cc_lex.lasttoken],	%rax
L6145:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.showtoken
cc_lex.showtoken:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_lex.showtoken.dest]
    call      mlib.gs_init
    mov       %rcx,	%rdi
    mov       %rdx,	[%rip+cc_lex.showtoken.dest]
    xor       %r8d,	%r8d
    call      cc_lex.emittoken
    call      msys.m$print_startcon
    mov       %rax,	[%rip+cc_lex.showtoken.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11164]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rax,	[%rip+cc_lex.showtoken.dest]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11165]
    call      msys.m$print_str
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.stringify
cc_lex.stringify:
#?>>
    .set cc_lex.stringify.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %al,	63
    mov       [%r12+21],	%al
    xor       %eax,	%eax
    mov       [%r12+8],	%rax
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jnz       L6154
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + cc_lex.stringify.length]
    call      cc_lex.strtoken
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_lex.stringify.length]
    mov       [%r12+24],	%eax
    mov       [%r12],	%rdi
    jmp       L6152
L6154:
    mov       %rcx,	[%rip+cc_lex.stringify.deststr]
    call      mlib.gs_init
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lasttoken],	%rax
    xor       %rbx,	%rbx
    jmp       L6156
L6155:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+cc_lex.stringify.deststr]
    mov       %r8,	%rbx
    call      cc_lex.emittoken
    mov       %rbx,	1
    mov       %rsi,	[%rsi+8]
L6156:
    test      %rsi,	%rsi
    jnz       L6155
    mov       %eax,	[%rbp + cc_lex.stringify.length]
    mov       [%r12+24],	%eax
    mov       %rax,	[%rip+cc_lex.stringify.deststr]
    mov       %rax,	[%rax]
    mov       [%r12],	%rax
    mov       %rax,	[%rip+cc_lex.stringify.deststr]
    mov       %eax,	[%rax+8]
    mov       [%r12+24],	%eax
L6152:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.pastetokens
cc_lex.pastetokens:
#?>>
    .set cc_lex.pastetokens.tk, 64
    .set cc_lex.pastetokens.tknext, 72
    .set cc_lex.pastetokens.length1, -8
    .set cc_lex.pastetokens.length2, -16
    .set cc_lex.pastetokens.oldtoken, -48
    .set cc_lex.pastetokens.token, -80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	112
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %rdi,	[%rax+8]
    mov       %rax,	[%rbp + cc_lex.pastetokens.tknext]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    cmp       %r10,	%rax
    jnz       L6160
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tknext]
    mov       [%r10],	%rax
L6160:
    mov       %rax,	[%rdi+8]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       [%r10+8],	%rax
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	66
    jnz       L6162
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	66
    jz        L6163
L6164:
    mov       %rax,	%rdi
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
L6163:
    jmp       L6161
L6162:
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	66
    jz        L6161
L6165:
    mov       %rcx,	[%rbp + cc_lex.pastetokens.tk]
    lea       %rdx,	[%rbp + cc_lex.pastetokens.length1]
    call      cc_lex.strtoken
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_lex.pastetokens.length2]
    call      cc_lex.strtoken
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    add       %rax,	[%rbp + cc_lex.pastetokens.length2]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %r12,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_lex.pastetokens.length1]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    lea       %r10,	[%r12 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rsi
    mov       %r8,	[%rbp + cc_lex.pastetokens.length2]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    lea       %r10,	[%r12 + %rax]
    xor       %eax,	%eax
    mov       %r11,	[%rbp + cc_lex.pastetokens.length2]
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    cmp       %rax,	87000
    jl        L6167
    lea       %rcx,	[%rip+L11166]
    call      cc_lex.lxerror
L6167:
    inc       qword ptr[%rip+cc_lex.npastedtokens]
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    mov       %r10,	%r12
    lea       %r11,	[%rip+cc_lex.pastedtokenlist]
    mov       [%r11 + %rax*8-8],	%r10
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.pastetokens.oldtoken]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %r13,	[%rip+cc_lex.lxsptr]
    mov       %r14,	[%rip+cc_lex.lx_stackindex]
    mov       [%rip+cc_lex.lxsptr],	%r12
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %ecx,	%ecx
    call      cc_lex.setfileno
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.pastetokens.token]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jz        L6169
L6169:
    lea       %rax,	[%rbp + cc_lex.pastetokens.oldtoken]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       [%rip+cc_lex.lxsptr],	%r13
    mov       [%rip+cc_lex.lx_stackindex],	%r14
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.pastetokens.token+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.pastetokens.token]
    xor       %edx,	%edx
    call      cc_lex.setfilenox
    mov       %ax,	[%rip+cc_lex.npastedtokens]
    mov       [%rbp + cc_lex.pastetokens.token+28],	%ax
    lea       %rax,	[%rbp + cc_lex.pastetokens.token+23]
    mov       %r10b,	8
    or        [%rax],	%r10b
    lea       %rax,	[%rbp + cc_lex.pastetokens.token]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
L6161:
#---------------
    add       %rsp,	112
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getifexpr
cc_lex.getifexpr:
#?>>
    .set cc_lex.getifexpr.sx, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.getifexpr.sx]
    call      cc_lex.evalcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L6172
    lea       %rcx,	[%rip+L11167]
    call      cc_lex.lxerror
L6172:
    mov       %rax,	%rdi
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
L6170:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalcondexpr
cc_lex.evalcondexpr:
#?>>
    .set cc_lex.evalcondexpr.sy, -8
    .set cc_lex.evalcondexpr.sz, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalorexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	19
    jnz       L6175
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcondexpr.sy]
    call      cc_lex.evalcondexpr
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jz        L6177
    lea       %rcx,	[%rip+L11168]
    call      cc_lex.lxerror
L6177:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcondexpr.sz]
    call      cc_lex.evalcondexpr
    mov       %rsi,	%rax
    test      %rdi,	%rdi
    jz        L6179
    mov       %rax,	[%rbp + cc_lex.evalcondexpr.sy]
    mov       [%r12],	%rax
    mov       %rdi,	%rbx
    jmp       L6178
L6179:
    mov       %rax,	[%rbp + cc_lex.evalcondexpr.sz]
    mov       [%r12],	%rax
    mov       %rdi,	%rsi
L6178:
L6175:
    mov       %rax,	%rdi
L6173:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalorexpr
cc_lex.evalorexpr:
#?>>
    .set cc_lex.evalorexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      cc_lex.evalandexpr
    mov       %rdi,	%rax
    jmp       L6182
L6181:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalorexpr.sy]
    call      cc_lex.evalandexpr
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jnz       L6186
    test      %rbx,	%rbx
    jz        L6185
L6186:
    mov       %rax,	1
    jmp       L6184
L6185:
    xor       %eax,	%eax
L6184:
    mov       %rdi,	%rax
L6182:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	31
    jz        L6181
    mov       %rax,	%rdi
L6180:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalandexpr
cc_lex.evalandexpr:
#?>>
    .set cc_lex.evalandexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      cc_lex.evaliorexpr
    mov       %rdi,	%rax
    jmp       L6189
L6188:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalandexpr.sy]
    call      cc_lex.evaliorexpr
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jz        L6192
    test      %rbx,	%rbx
    jz        L6192
    mov       %rax,	1
    jmp       L6191
L6192:
    xor       %eax,	%eax
L6191:
    mov       %rdi,	%rax
L6189:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	32
    jz        L6188
    mov       %rax,	%rdi
L6187:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaliorexpr
cc_lex.evaliorexpr:
#?>>
    .set cc_lex.evaliorexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evalixorexpr
    mov       %rdi,	%rax
    jmp       L6195
L6194:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaliorexpr.sy]
    call      cc_lex.evalixorexpr
    or        %rdi,	%rax
L6195:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	28
    jz        L6194
    mov       %rax,	%rdi
L6193:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalixorexpr
cc_lex.evalixorexpr:
#?>>
    .set cc_lex.evalixorexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evaliandexpr
    mov       %rdi,	%rax
    jmp       L6199
L6198:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalixorexpr.sy]
    call      cc_lex.evaliandexpr
    xor       %rdi,	%rax
L6199:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	30
    jz        L6198
    mov       %rax,	%rdi
L6197:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaliandexpr
cc_lex.evaliandexpr:
#?>>
    .set cc_lex.evaliandexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evaleqexpr
    mov       %rdi,	%rax
    jmp       L6203
L6202:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaliandexpr.sy]
    call      cc_lex.evaleqexpr
    and       %rdi,	%rax
L6203:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	29
    jz        L6202
    mov       %rax,	%rdi
L6201:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaleqexpr
cc_lex.evaleqexpr:
#?>>
    .set cc_lex.evaleqexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalcmpexpr
    mov       %rdi,	%rax
    jmp       L6207
L6206:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaleqexpr.sy]
    call      cc_lex.evalcmpexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	40
    jz        L6210
    cmp       %rax,	41
    jz        L6211
    jmp       L6212
L6210:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setz      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L6209
L6211:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setnz     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
L6212:
L6209:
L6207:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	40
    jz        L6206
    cmp       %rsi,	41
    jz        L6206
    mov       %rax,	%rdi
L6205:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalcmpexpr
cc_lex.evalcmpexpr:
#?>>
    .set cc_lex.evalcmpexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalshiftexpr
    mov       %rdi,	%rax
    jmp       L6215
L6214:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcmpexpr.sy]
    call      cc_lex.evalshiftexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L6218
    cmp       %rax,	43
    jz        L6219
    cmp       %rax,	44
    jz        L6220
    cmp       %rax,	45
    jz        L6221
    jmp       L6222
L6218:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setl      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L6217
L6219:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setle     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L6217
L6220:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setge     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L6217
L6221:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setg      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
L6222:
L6217:
L6215:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	42
    jz        L6214
    cmp       %rsi,	43
    jz        L6214
    cmp       %rsi,	44
    jz        L6214
    cmp       %rsi,	45
    jz        L6214
    mov       %rax,	%rdi
L6213:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalshiftexpr
cc_lex.evalshiftexpr:
#?>>
    .set cc_lex.evalshiftexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evaladdexpr
    mov       %rdi,	%rax
    jmp       L6225
L6224:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalshiftexpr.sy]
    call      cc_lex.evaladdexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	34
    jz        L6228
    cmp       %rax,	33
    jz        L6229
    jmp       L6230
L6228:
    mov       %rax,	%rdi
    mov       %cl,	%bl
    sar       %rax,	%cl
    mov       %rdi,	%rax
    jmp       L6227
L6229:
    mov       %rax,	%rdi
    mov       %cl,	%bl
    shl       %rax,	%cl
    mov       %rdi,	%rax
L6230:
L6227:
L6225:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	33
    jz        L6224
    cmp       %rsi,	34
    jz        L6224
    mov       %rax,	%rdi
L6223:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaladdexpr
cc_lex.evaladdexpr:
#?>>
    .set cc_lex.evaladdexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalmulexpr
    mov       %rdi,	%rax
    jmp       L6233
L6232:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaladdexpr.sy]
    call      cc_lex.evalmulexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	23
    jz        L6236
    cmp       %rax,	24
    jz        L6237
    jmp       L6238
L6236:
    mov       %rax,	%rbx
    add       %rdi,	%rax
    jmp       L6235
L6237:
    mov       %rax,	%rbx
    sub       %rdi,	%rax
L6238:
L6235:
L6233:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	23
    jz        L6232
    cmp       %rsi,	24
    jz        L6232
    mov       %rax,	%rdi
L6231:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalmulexpr
cc_lex.evalmulexpr:
#?>>
    .set cc_lex.evalmulexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalunaryexpr
    mov       %rdi,	%rax
    jmp       L6241
L6240:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalmulexpr.sy]
    call      cc_lex.evalunaryexpr
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L6244
    cmp       %rsi,	25
    jz        L6244
    lea       %rcx,	[%rip+L11169]
    call      cc_lex.lxerror
L6244:
    mov       %rax,	%rsi
    cmp       %rax,	25
    jz        L6246
    cmp       %rax,	26
    jz        L6247
    cmp       %rax,	27
    jz        L6248
    jmp       L6249
L6246:
    mov       %rax,	%rdi
    imul      %rax,	%rbx
    mov       %rdi,	%rax
    jmp       L6245
L6247:
    mov       %rax,	%rdi
    mov       %r10,	%rbx
    cqo       
    idiv      %r10
    mov       %rdi,	%rax
    jmp       L6245
L6248:
    mov       %rax,	%rdi
    mov       %r10,	%rbx
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       %rdi,	%rax
L6249:
L6245:
L6241:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	25
    jz        L6240
    cmp       %rsi,	26
    jz        L6240
    cmp       %rsi,	27
    jz        L6240
    mov       %rax,	%rdi
L6239:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalunaryexpr
cc_lex.evalunaryexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	23
    jz        L6252
    cmp       %rax,	24
    jz        L6252
    cmp       %rax,	36
    jz        L6252
    cmp       %rax,	35
    jnz       L6253
L6252:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rbx,	%rax
    call      cc_lex.lexm
    mov       %rcx,	%rsi
    call      cc_lex.evalunaryexpr
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	23
    jz        L6255
    cmp       %rax,	24
    jz        L6256
    cmp       %rax,	36
    jz        L6257
    cmp       %rax,	35
    jz        L6258
    jmp       L6259
L6255:
    mov       %rax,	%rdi
    jmp       L6250
L6256:
    mov       %rax,	%rdi
    neg       %rax
    jmp       L6250
L6257:
    mov       %rax,	%rdi
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    jmp       L6250
L6258:
    mov       %rax,	%rdi
    not       %rax
    jmp       L6250
L6259:
L6254:
L6253:
L6251:
    mov       %rcx,	%rsi
    call      cc_lex.evalterm
L6250:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalterm
cc_lex.evalterm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	1
    mov       [%rsi],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L6262
    cmp       %rax,	59
    jz        L6263
    cmp       %rax,	61
    jz        L6264
    cmp       %rax,	13
    jz        L6265
    jmp       L6266
L6262:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	92
    jz        L6268
    cmp       %rax,	91
    jz        L6269
    jmp       L6270
L6268:
    mov       %rax,	1
    mov       [%rip+cc_lex.noexpand],	%rax
    xor       %rbx,	%rbx
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L6272
    mov       %rbx,	1
    call      cc_lex.lexm
L6272:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L6274
    lea       %rcx,	[%rip+L11170]
    call      cc_lex.lxerror
L6274:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    setz      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    call      cc_lex.lexm
    test      %rbx,	%rbx
    jz        L6276
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L6278
    lea       %rcx,	[%rip+L11171]
    call      cc_lex.lxerror
L6278:
    call      cc_lex.lexm
L6276:
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    jmp       L6267
L6269:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L6280
    lea       %rcx,	[%rip+L11172]
    call      cc_lex.lxerror
L6280:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L6282
    lea       %rcx,	[%rip+L11173]
    call      cc_lex.lxerror
L6282:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	70
    jnz       L6285
L6284:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movsx     %rax,	word ptr[%rax+100]
    lea       %r10,	[%rip+cc_tables.typespecsizes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    jmp       L6283
L6285:
    lea       %rcx,	[%rip+L11174]
    call      cc_lex.lxerror
L6283:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L6287
    lea       %rcx,	[%rip+L11175]
    call      cc_lex.lxerror
L6287:
    call      cc_lex.lexm
    jmp       L6267
L6270:
    call      cc_lex.lexm
    xor       %eax,	%eax
    jmp       L6260
L6267:
    jmp       L6261
L6263:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    call      cc_lex.lexm
    jmp       L6261
L6264:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    test      %rax,	%rax
    jnz       L6289
    xor       %rdi,	%rdi
    jmp       L6288
L6289:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
L6288:
    call      cc_lex.lexm
    jmp       L6261
L6265:
    call      cc_lex.lexm
    mov       %rcx,	%rsi
    call      cc_lex.evalcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L6291
    lea       %rcx,	[%rip+L11176]
    call      cc_lex.lxerror
L6291:
    call      cc_lex.lexm
    jmp       L6261
L6266:
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11177]
    call      cc_lex.lxerror
L6261:
    mov       %rax,	%rdi
L6260:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getifdef
cc_lex.getifdef:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	1
    mov       [%rip+cc_lex.noexpand],	%rax
    call      cc_lex.lexreadtoken
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L6294
    lea       %rcx,	[%rip+L11178]
    call      cc_lex.lxerror
L6294:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rbx,	[%rax]
    xor       %rdi,	%rdi
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	1
    jnz       L6296
    mov       %rdi,	1
    jmp       L6295
L6296:
    movzx     %rax,	byte ptr[%rbx+107]
    cmp       %rax,	69
    jnz       L6297
    mov       %rdi,	1
L6297:
L6295:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L6299
    lea       %rcx,	[%rip+L11179]
    call      cc_lex.lxerror
L6299:
    mov       %rax,	%rdi
L6292:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.skipcode
cc_lex.skipcode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    xor       %rdi,	%rdi
L6301:
    call      cc_lex.fastreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	4
    jz        L6304
    cmp       %rax,	57
    jz        L6305
    jmp       L6306
L6304:
    call      cc_lex.getlexdirective
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L6308
    cmp       %rax,	8
    jz        L6308
    cmp       %rax,	9
    jz        L6308
    cmp       %rax,	4
    jz        L6309
    cmp       %rax,	5
    jz        L6309
    cmp       %rax,	6
    jz        L6310
    jmp       L6311
L6308:
    inc       %rdi
    jmp       L6307
L6309:
    test      %rdi,	%rdi
    jnz       L6313
    mov       %rax,	%rbx
    jmp       L6300
L6313:
    jmp       L6307
L6310:
    test      %rdi,	%rdi
    jnz       L6315
    mov       %rax,	%rbx
    jmp       L6300
L6315:
    dec       %rdi
L6311:
L6307:
    jmp       L6303
L6305:
    lea       %rcx,	[%rip+L11180]
    call      cc_lex.lxerror
L6306:
L6303:
    jmp       L6301
    xor       %eax,	%eax
L6300:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.freetokens
cc_lex.freetokens:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    jmp       L6318
L6317:
    mov       %rdi,	[%rcx+8]
    mov       %rax,	%rdi
    mov       %rcx,	%rax
L6318:
    test      %rcx,	%rcx
    jnz       L6317
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lex.fastreadtoken
cc_lex.fastreadtoken:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
L6321:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rax,	48
    jae       L6324
    lea       %r10,	[%rip+L6323]
    jmp       [%r10 + %rax*8]
    .data
L6323:
    .quad     L6346
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6345
    .quad     L6324
    .quad     L6349
    .quad     L6344
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6343
    .quad     L6325
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6342
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6324
    .quad     L6337
    .text
L6325:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rsi,	%rax
    xor       %rbx,	%rbx
    jmp       L6327
L6326:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	10
    jz        L6330
    cmp       %rax,	9
    jz        L6331
    cmp       %rax,	32
    jz        L6331
    jmp       L6332
L6330:
    mov       %rbx,	1
    jmp       L6328
L6331:
    jmp       L6329
L6332:
    jmp       L6328
L6329:
    dec       %rsi
L6327:
    cmp       %rsi,	[%rip+cc_lex.lxstart]
    jae       L6326
L6328:
    test      %rbx,	%rbx
    jnz       L6335
    cmp       %rsi,	[%rip+cc_lex.lxstart]
    jae       L6334
L6335:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L6320
L6334:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	35
    jnz       L6336
    inc       qword ptr[%rip+cc_lex.lxsptr]
L6336:
L6333:
    jmp       L6321
L6337:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L6339
    cmp       %rax,	42
    jz        L6340
    jmp       L6341
L6339:
    call      cc_lex.readlinecomment
    jmp       L6338
L6340:
    call      cc_lex.readblockcomment
L6341:
L6338:
    jmp       L6321
L6342:
    mov       %rcx,	39
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L6321
L6343:
    mov       %rcx,	34
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L6321
L6344:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L6321
L6345:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    jmp       L6321
L6346:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jz        L6348
    call      cc_lex.unstacksourcefile
    jmp       L6347
L6348:
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L6320
L6347:
    jmp       L6321
L6349:
    jmp       L6321
L6324:
    jmp       L6321
L6320:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.alloctoken
cc_lex.alloctoken:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L6350:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.alloctokenz
cc_lex.alloctokenz:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	%rdi
L6351:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.expandpredefmacro
cc_lex.expandpredefmacro:
#?>>
    .set cc_lex.expandpredefmacro.str, -256
    .set cc_lex.expandpredefmacro.tm, -272
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	312
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jnz       L6352
L6354:
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L6356
    cmp       %rax,	2
    jz        L6357
    cmp       %rax,	3
    jz        L6358
    cmp       %rax,	5
    jz        L6359
    cmp       %rax,	4
    jz        L6360
    cmp       %rax,	9
    jz        L6361
    cmp       %rax,	7
    jz        L6362
    cmp       %rax,	8
    jz        L6363
    jmp       L6364
L6356:
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.tm]
    call      mwindows.os_getsystime
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11181]
    call      msys.m$print_setfmt
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+6]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+2]
    lea       %r10,	[%rip+cc_lex.expandpredefmacro.monthnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11182]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	63
    mov       [%r12+21],	%al
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [%r12],	%rax
    jmp       L6355
L6357:
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.tm]
    call      mwindows.os_getsystime
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11183]
    call      msys.m$print_setfmt
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11184]
    call      msys.m$print_i64
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+10]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11185]
    call      msys.m$print_i64
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+12]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11185]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	63
    mov       [%r12+21],	%al
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [%r12],	%rax
    jmp       L6355
L6358:
    mov       %al,	63
    mov       [%r12+21],	%al
    mov       %rcx,	%r12
    call      cc_lex.getfilenox
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L6366
    mov       %rbx,	[%rip+cc_decls.sfileno]
L6366:
    mov       %rax,	[%rip+cc_decls.sfileno]
    test      %rax,	%rax
    jz        L6368
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%rip+cc_decls.sfileno]
    mov       %rax,	[%rax + %r10*8]
    mov       [%r12],	%rax
    jmp       L6367
L6368:
    lea       %rax,	[%rip+L11186]
    mov       [%r12],	%rax
L6367:
    jmp       L6355
L6359:
    mov       %al,	63
    mov       [%r12+21],	%al
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6370
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rax,	[%rax]
    mov       [%r12],	%rax
    jmp       L6369
L6370:
    lea       %rax,	[%rip+L11187]
    mov       [%r12],	%rax
L6369:
    jmp       L6355
L6360:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       [%r12],	%r13
    jmp       L6355
L6361:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       %rax,	1
    mov       [%r12],	%rax
    jmp       L6355
L6362:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       %rax,	1
    mov       [%r12],	%rax
    jmp       L6355
L6363:
    mov       %al,	59
    mov       [%r12+21],	%al
    movzx     %rax,	byte ptr[%rip+cc_decls.pci_target]
    mov       [%r12],	%rax
    jmp       L6355
L6364:
    call      msys.m$print_startcon
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11188]
    call      cc_lex.lxerror
L6355:
    movzx     %rax,	byte ptr[%r12+21]
    cmp       %rax,	63
    jnz       L6372
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    call      strlen
    mov       [%r12+24],	%eax
    mov       %al,	[%rip+cc_decls.trefchar]
    mov       [%r12+22],	%al
    jmp       L6371
L6372:
    mov       %al,	3
    mov       [%r12+22],	%al
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      msys.getstrint
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r12+24],	%eax
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    cmp       %rax,	87000
    jl        L6374
    lea       %rcx,	[%rip+L11189]
    call      cc_lex.lxerror
L6374:
    inc       qword ptr[%rip+cc_lex.npastedtokens]
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_lex.pastedtokenlist]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_lex.setfilenox
    mov       %ax,	[%rip+cc_lex.npastedtokens]
    mov       [%r12+28],	%ax
L6371:
L6352:
#---------------
    add       %rsp,	312
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dopragmadir
cc_lex.dopragmadir:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L6377
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11190]
    mov       %r8,	4
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L6379
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L6381
    lea       %rcx,	[%rip+L11191]
    call      cc_lex.lxerror
L6381:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	59
    jnz       L6383
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    cmp       %rax,	1
    jnz       L6386
L6385:
    xor       %eax,	%eax
    mov       [%rip+cc_decls.structpadding],	%rax
    jmp       L6384
L6386:
    jmp       L6387
    lea       %rcx,	[%rip+L11192]
    call      cc_lex.lxerror
L6384:
    call      cc_lex.lexm
    jmp       L6382
L6383:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L6388
    mov       %rax,	1
    mov       [%rip+cc_decls.structpadding],	%rax
L6388:
L6382:
    jmp       L6378
L6379:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11193]
    mov       %r8,	6
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L6389
    mov       %rcx,	77
    call      cc_lex.addbuildinfo
    jmp       L6378
L6389:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11194]
    mov       %r8,	6
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L6390
    mov       %rcx,	72
    call      cc_lex.addbuildinfo
    jmp       L6378
L6390:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11195]
    mov       %r8,	4
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L6391
    mov       %rcx,	76
    call      cc_lex.addbuildinfo
L6391:
L6378:
L6377:
#cc_lex.dopragmadir.finish:
L6387:
    jmp       L6393
L6392:
    call      cc_lex.lexm
L6393:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L6395
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L6392
L6395:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.addbuildinfo
cc_lex.addbuildinfo:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L6398
    lea       %rcx,	[%rip+L11196]
    call      cc_lex.lxerror
L6398:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	77
    jz        L6400
    cmp       %rax,	72
    jz        L6401
    cmp       %rax,	76
    jz        L6402
    jmp       L6403
L6400:
    mov       %rax,	[%rip+cc_decls.npmodules]
    cmp       %rax,	199
    jl        L6405
    lea       %rcx,	[%rip+L11197]
    call      cc_lex.lxerror
L6405:
    inc       qword ptr[%rip+cc_decls.npmodules]
    mov       %rax,	[%rip+cc_decls.npmodules]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pmodulelist]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L6399
L6401:
    mov       %rax,	[%rip+cc_decls.npheaders]
    cmp       %rax,	100
    jl        L6407
    lea       %rcx,	[%rip+L11198]
    call      cc_lex.lxerror
L6407:
    inc       qword ptr[%rip+cc_decls.npheaders]
    mov       %rax,	[%rip+cc_decls.npheaders]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pheaderlist]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L6399
L6402:
    mov       %rax,	[%rip+cc_decls.nplibs]
    cmp       %rax,	100
    jl        L6409
    lea       %rcx,	[%rip+L11199]
    call      cc_lex.lxerror
L6409:
    inc       qword ptr[%rip+cc_decls.nplibs]
    mov       %rax,	[%rip+cc_decls.nplibs]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pliblist]
    mov       [%r11 + %rax*8-8],	%r10
L6403:
L6399:
    call      cc_lex.lexm
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.needspace
cc_lex.needspace:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L6412
    xor       %eax,	%eax
    jmp       L6410
L6412:
    lea       %rax,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	%rcx
    mov       %rdi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	%rdx
    mov       %rbx,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	110
    jz        L6414
    cmp       %rax,	107
    jz        L6414
    cmp       %rax,	45
    jz        L6415
    cmp       %rax,	43
    jz        L6415
    jmp       L6416
L6414:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	110
    jz        L6418
    cmp       %rax,	107
    jnz       L6419
L6418:
    mov       %rax,	1
    jmp       L6410
L6419:
L6417:
    jmp       L6413
L6415:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	45
    jz        L6421
    cmp       %rax,	43
    jnz       L6422
L6421:
    mov       %rax,	1
    jmp       L6410
L6422:
L6420:
L6416:
L6413:
    xor       %eax,	%eax
L6410:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dospecialinclude
cc_lex.dospecialinclude:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L11200]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
    mov       %rax,	[%rip+cc_decls.dheaderfile]
    test      %rax,	%rax
    jz        L6425
    mov       %rcx,	[%rip+cc_decls.dheaderfile]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
L6425:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.setnumberoffset
cc_lex.setnumberoffset:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    mov       %r10,	4278190080
    and       %rax,	%r10
    mov       %r10,	%rcx
    and       %r10,	16777215
    or        %rax,	%r10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.setfileno
cc_lex.setfileno:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    and       %rax,	255
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+20],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    and       %rax,	16777215
    mov       %r10,	%rcx
    and       %r10,	65280
    shl       %r10,	16
    or        %rax,	%r10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.setfilenox
cc_lex.setfilenox:
#?>>
#?]]
#---------------
    mov       %rax,	%rdx
    and       %rax,	255
    mov       [%rcx+20],	%al
    movsxd    %rax,	dword ptr[%rcx+28]
    and       %rax,	16777215
    mov       %r10,	%rdx
    and       %r10,	65280
    shl       %r10,	16
    or        %rax,	%r10
    mov       [%rcx+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.getfileno
cc_lex.getfileno:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    sar       %rax,	24
    shl       %rax,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    movzx     %r10,	byte ptr[%r10+20]
    or        %rax,	%r10
L6429:
#---------------
    ret       
# End 
# Proc cc_lex.getfilenox
cc_lex.getfilenox:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+28]
    sar       %rax,	24
    shl       %rax,	8
    movzx     %r10,	byte ptr[%rcx+20]
    or        %rax,	%r10
L6430:
#---------------
    ret       
# End 
# Proc cc_lex.getnumberoffsetx
cc_lex.getnumberoffsetx:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+28]
    and       %rax,	16777215
L6431:
#---------------
    ret       
# End 
# Proc cc_lex.freehashtable
cc_lex.freehashtable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    xor       %r12,	%r12
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L6435
L6433:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%r12
    mov       %rdi,	[%rax + %r10*8]
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L6437
    movzx     %rax,	byte ptr[%rdi+107]
    cmp       %rax,	67
    jnz       L6437
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L6439
    mov       %rcx,	[%rdi+72]
    call      cc_lex.freetokens
L6439:
    mov       %rsi,	[%rdi+40]
    jmp       L6441
L6440:
    mov       %rbx,	[%rsi+40]
    mov       %rcx,	%rsi
    mov       %rdx,	128
    call      mlib.pcm_free
    mov       %rsi,	%rbx
L6441:
    test      %rsi,	%rsi
    jnz       L6440
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	128
    call      mlib.pcm_clearmem
    jmp       L6436
L6437:
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L6443
    xor       %eax,	%eax
    mov       [%rdi+40],	%rax
L6443:
L6436:
    inc       %r12
    cmp       %r12,	[%rip+cc_decls.hstmask]
    jle       L6433
L6435:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.regenlookup
cc_lex.regenlookup:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+106]
    mov       %r10,	[%r13]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    and       %rax,	[%rip+cc_decls.hstmask]
    mov       %rdi,	%rax
    xor       %rbx,	%rbx
L6445:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %r12,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%r12+106]
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L6448
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	128
    call      mlib.pcm_free
    mov       %rax,	%r13
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    inc       qword ptr[%rip+cc_lex.nhstsymbols]
    jmp       L6444
L6448:
    movzx     %rax,	byte ptr[%r13+106]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jnz       L6450
    mov       %rax,	[%r13]
    mov       %r10,	[%r12]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L6452
    lea       %rcx,	[%rip+L11201]
    call      cc_lex.lxerror
L6452:
L6450:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstsize]
    jl        L6454
    test      %rbx,	%rbx
    jz        L6456
    lea       %rcx,	[%rip+L11202]
    call      mlib.abortprogram
L6456:
    mov       %rbx,	1
    xor       %rdi,	%rdi
L6454:
    jmp       L6445
L6444:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.newhashtable
cc_lex.newhashtable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+cc_decls.hashtable]
    mov       %rbx,	[%rip+cc_decls.hstsize]
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	1
    mov       [%rip+cc_decls.hstsize],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       [%rip+cc_decls.hstmask],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.nhstsymbols],	%rax
    mov       %rax,	6
    mov       %r10,	[%rip+cc_decls.hstsize]
    imul      %rax,	%r10
    mov       %r10,	10
    cqo       
    idiv      %r10
    mov       [%rip+cc_lex.hstthreshold],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_decls.hashtable],	%rax
    xor       %r13,	%r13
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L6460
L6458:
    mov       %rcx,	128
    call      mlib.pcm_allocz
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    inc       %r13
    cmp       %r13,	[%rip+cc_decls.hstmask]
    jle       L6458
L6460:
    xor       %r13,	%r13
    mov       %rax,	%rbx
    dec       %rax
    mov       %r12,	%rax
    cmp       %r12,	0
    jl        L6463
L6461:
    mov       %rsi,	[%rdi + %r13*8]
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L6465
    mov       %rcx,	%rsi
    call      cc_lex.regenlookup
L6465:
    inc       %r13
    cmp       %r13,	%r12
    jle       L6461
L6463:
    mov       %rax,	%rbx
    shl       %rax,	3
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.old_readrealnumber
cc_lex.old_readrealnumber:
#?>>
    .set cc_lex.old_readrealnumber.intlen, 104
    .set cc_lex.old_readrealnumber.base, 112
    .set cc_lex.old_readrealnumber.c, -8
    .set cc_lex.old_readrealnumber.badexpon, -16
    .set cc_lex.old_readrealnumber.realstr, -520
    .set cc_lex.old_readrealnumber.av_1, -528
    .set cc_lex.old_readrealnumber.av_2, -536
    .set cc_lex.old_readrealnumber.av_3, -544
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    movq      %rax,	%XMM13
    push      %rax
    movq      %rax,	%XMM14
    push      %rax
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	584
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+104],	%r8
    mov       [%rbp+112],	%r9
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L6468
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rbp + cc_lex.old_readrealnumber.base]
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
L6468:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.old_readrealnumber.badexpon],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	101
    jz        L6470
    cmp       %rax,	69
    jz        L6470
    cmp       %rax,	112
    jz        L6471
    cmp       %rax,	80
    jz        L6471
    jmp       L6472
L6470:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	16
    jz        L6474
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L6474:
    jmp       L6469
L6471:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	16
    jnz       L6476
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L6476:
L6472:
L6469:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    test      %rax,	%rax
    jz        L6478
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L6466
L6478:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	102
    jz        L6480
    cmp       %rax,	70
    jz        L6480
    cmp       %rax,	108
    jz        L6480
    cmp       %rax,	76
    jnz       L6481
L6480:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L6479
L6481:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L6483
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L6466
L6483:
L6479:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    add       %rax,	%rbx
    cmp       %rax,	500
    jle       L6485
    lea       %rcx,	[%rip+L11203]
    call      cc_lex.lxerror
L6485:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    test      %rax,	%rax
    jz        L6487
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.realstr]
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.old_readrealnumber.intlen]
    call      memcpy
L6487:
    test      %rbx,	%rbx
    jz        L6489
    lea       %rax,	[%rbp + cc_lex.old_readrealnumber.realstr]
    mov       %r10,	[%rbp + cc_lex.old_readrealnumber.intlen]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
L6489:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cvtsi2sd  %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM13,	%XMM4
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	10
    jnz       L6491
    mov       %rax,	%rbx
    sub       %rsi,	%rax
    jmp       L6490
L6491:
    mov       %rax,	%rbx
    shl       %rax,	2
    sub       %rsi,	%rax
    movq      %XMM4,	[%rip+L11204]
    movq      %XMM13,	%XMM4
L6490:
    movq      %XMM4,	[%rip+L11205]
    movq      %XMM14,	%XMM4
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    add       %rax,	%rbx
    mov       [%rbp + cc_lex.old_readrealnumber.av_1],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_1]
    cmp       %rax,	1
    jl        L6494
L6492:
    movzx     %rax,	byte ptr[%rbp + %r12 + cc_lex.old_readrealnumber.realstr-1]
    mov       [%rbp + cc_lex.old_readrealnumber.c],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	48
    jl        L6496
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	57
    jg        L6496
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    sub       %rax,	48
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    movq      %XMM14,	%XMM4
    jmp       L6495
L6496:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	97
    jle       L6497
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    mov       %rax,	97
    cmp       %rax,	0
    jl        L11206
    cvtsi2sd  %XMM5,	%rax
    jmp       L11207
L11206:
    and       %rax,	[%rip+L10547]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM5,	[%rip+L10548]
L11207:
    subsd     %XMM4,	%XMM5
    addsd     %XMM4,	[%rip+L11208]
    movq      %XMM14,	%XMM4
    jmp       L6495
L6497:
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    mov       %rax,	65
    cmp       %rax,	0
    jl        L11209
    cvtsi2sd  %XMM5,	%rax
    jmp       L11210
L11209:
    and       %rax,	[%rip+L10547]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM5,	[%rip+L10548]
L11210:
    subsd     %XMM4,	%XMM5
    addsd     %XMM4,	[%rip+L11211]
    movq      %XMM14,	%XMM4
L6495:
    inc       %r12
    cmp       %r12,	[%rbp + cc_lex.old_readrealnumber.av_1]
    jle       L6492
L6494:
    cmp       %rsi,	0
    jl        L6499
    mov       [%rbp + cc_lex.old_readrealnumber.av_2],	%rsi
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_2]
    cmp       %rax,	0
    jle       L6502
L6500:
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM13
    movq      %XMM14,	%XMM4
    dec       qword ptr[%rbp + cc_lex.old_readrealnumber.av_2]
    jnz       L6500
L6502:
    jmp       L6498
L6499:
    mov       %rax,	%rsi
    neg       %rax
    mov       [%rbp + cc_lex.old_readrealnumber.av_3],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_3]
    cmp       %rax,	0
    jle       L6505
L6503:
    movq      %XMM4,	%XMM14
    divsd     %XMM4,	%XMM13
    movq      %XMM14,	%XMM4
    dec       qword ptr[%rbp + cc_lex.old_readrealnumber.av_3]
    jnz       L6503
L6505:
L6498:
    mov       %al,	60
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    movq      %XMM4,	%XMM14
    lea       %rax,	[%rip+cc_decls.nextlx]
    movq      [%rax],	%XMM4
    mov       %rax,	%r14
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
L6466:
#---------------
    add       %rsp,	584
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rcx
    movq      %XMM14,	%rcx
    pop       %rcx
    movq      %XMM13,	%rcx
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.issimpleconstmacro
cc_lex.issimpleconstmacro:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rsi,	1
    mov       %rbx,	3
    cmp       %rbx,	1
    jl        L6509
L6507:
    mov       %rax,	[%r12]
    lea       %r10,	[%rip+cc_lex.issimpleconstmacro.specialnames]
    mov       %r11,	%rsi
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6511
    mov       %rax,	2
    jmp       L6506
L6511:
    inc       %rsi
    cmp       %rsi,	%rbx
    jle       L6507
L6509:
    mov       %rdi,	[%r12+72]
    test      %rdi,	%rdi
    jz        L6513
    mov       %rax,	[%rdi+8]
    test      %rax,	%rax
    jnz       L6513
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	59
    jz        L6516
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	60
    jnz       L6515
L6516:
    mov       %rax,	1
    jmp       L6506
L6515:
L6513:
    xor       %eax,	%eax
L6506:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmodule
cc_parse.readmodule:
#?>>
    .set cc_parse.readmodule.linkage, -8
    .set cc_parse.readmodule.wasdef, -16
    .set cc_parse.readmodule.d, -24
    .set cc_parse.readmodule.pm, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
    jmp       L6519
L6518:
    xor       %r12,	%r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jnz       L6523
L6522:
    lea       %rcx,	[%rip+L11212]
    call      cc_support.serror
L6523:
L6521:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r13,	%rax
    mov       %rcx,	[%rip+cc_decls.stmodule]
    lea       %rdx,	[%rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readdeclspec
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
L6524:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L6526
    cmp       %rax,	25
    jz        L6526
    cmp       %rax,	13
    jnz       L6527
L6526:
    inc       %r12
    mov       %rcx,	[%rip+cc_decls.stmodule]
    lea       %rdx,	[%rbp + cc_parse.readmodule.d]
    mov       %r8,	%rbx
    lea       %r9,	[%rbp + cc_parse.readmodule.pm]
    call      cc_parse.readtype
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readmodule.d]
    test      %rax,	%rax
    jnz       L6529
    lea       %rcx,	[%rip+L11213]
    call      cc_support.serror
L6529:
    mov       %rax,	[%rbp + cc_parse.readmodule.linkage]
    cmp       %rax,	5
    jnz       L6531
    mov       %rax,	[%rbp + cc_parse.readmodule.pm]
    test      %rax,	%rax
    jz        L6533
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readmodule.pm]
    call      cc_lib.createprocmode
    mov       %rdi,	%rax
L6533:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	[%rbp + cc_parse.readmodule.d]
    mov       %r8,	%rdi
    call      cc_parse.createtypedef
    mov       [%rbp + cc_parse.readmodule.d],	%rax
    jmp       L6530
L6531:
    mov       %rax,	[%rbp + cc_parse.readmodule.pm]
    test      %rax,	%rax
    jz        L6534
#cc_parse.readmodule.readfn:
L6535:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L6537
    test      %rsi,	%rsi
    jz        L6537
    lea       %rcx,	[%rip+L11214]
    call      cc_support.serror
L6537:
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readmodule.wasdef]
    push      %rax
    mov       %rcx,	[%rbp + cc_parse.readmodule.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readmodule.linkage]
    mov       %r9,	[%rbp + cc_parse.readmodule.pm]
    sub       %rsp,	32
    call      cc_parse.readfunction
    add       %rsp,	48
    mov       [%rbp + cc_parse.readmodule.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readmodule.wasdef]
    test      %rax,	%rax
    jnz       L6525
L6539:
    jmp       L6530
L6534:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L6540
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readmodule.pm],	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    jmp       L6535
L6540:
    mov       %rcx,	[%rbp + cc_parse.readmodule.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readmodulevar
    mov       [%rbp + cc_parse.readmodule.d],	%rax
L6530:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L6543
L6542:
    mov       %rsi,	1
    call      cc_lex.lex
    jmp       L6541
L6543:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L6525
L6541:
    jmp       L6524
L6527:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	12
    jz        L6545
    cmp       %rax,	18
    jz        L6545
    cmp       %rax,	19
    jz        L6545
    cmp       %rax,	3
    jz        L6546
    jmp       L6547
L6545:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L6525
L6546:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L6525
L6547:
    mov       %rcx,	%rbx
    call      cc_lib.typename
    lea       %rcx,	[%rip+L11215]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L6544:
    jmp       L6524
L6525:
L6519:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L6518
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.parsemodule
cc_parse.parsemodule:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L6550
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11216]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6550:
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ingeneric],	%al
    mov       [%rip+cc_parse.loopindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ist_symptr],	%rax
    lea       %rcx,	[%rip+cc_parse.casevaluestack]
    xor       %edx,	%edx
    mov       %r8,	512
    call      memset
    lea       %rcx,	[%rip+L11217]
    mov       %rdx,	[%rip+cc_decls.mainfileno]
    call      cc_lex.startlex
    mov       %rdi,	[%rip+cc_decls.stmodule]
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currproc],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_parse.loopindex],	%rax
    call      cc_lex.lex
    call      cc_parse.readmodule
    call      cc_lex.endlex
    mov       %rax,	1
L6548:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readdeclspec
cc_parse.readdeclspec:
#?>>
    .set cc_parse.readdeclspec.d, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_parse.readdeclspec.d]
    xor       %edx,	%edx
    mov       %r8,	15
    call      memset
    mov       %eax,	20
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %r12,	%rax
L6552:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	67
    cmp       %rax,	24
    jae       L6555
    lea       %r10,	[%rip+L6554]
    jmp       [%r10 + %rax*8]
    .data
L6554:
    .quad     L6603
    .quad     L6555
    .quad     L6555
    .quad     L6557
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6555
    .quad     L6597
    .quad     L6597
    .quad     L6590
    .quad     L6584
    .quad     L6556
    .quad     L6593
    .quad     L6555
    .quad     L6600
    .text
L6556:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    call      cc_lex.lex
    jmp       L6552
L6557:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    sub       %rax,	1
    cmp       %rax,	10
    jae       L6560
    lea       %r10,	[%rip+L6559]
    jmp       [%r10 + %rax*8]
    .data
L6559:
    .quad     L6561
    .quad     L6561
    .quad     L6567
    .quad     L6571
    .quad     L6561
    .quad     L6561
    .quad     L6561
    .quad     L6576
    .quad     L6580
    .quad     L6561
    .text
L6561:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L6563
    test      %r12,	%r12
    jz        L6565
    mov       %rcx,	9
    call      cc_lib.checksymbol
    jmp       L6564
L6565:
    jmp       L6566
L6564:
L6563:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_tables.typespectypes]
    mov       %r10d,	[%r10 + %rax*4-4]
    mov       [%rbp + cc_parse.readdeclspec.d],	%r10d
    jmp       L6558
L6567:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L6570
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jnz       L6570
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L6569
L6570:
    jmp       L6566
L6569:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+9],	%al
    jmp       L6558
L6571:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jnz       L6574
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jz        L6573
L6574:
    jmp       L6566
L6573:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jz        L6575
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readdeclspec.d+10],	%al
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+11],	%al
    jmp       L6572
L6575:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+10],	%al
L6572:
    mov       %rbx,	1
    jmp       L6558
L6576:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L6579
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L6578
L6579:
    jmp       L6566
L6578:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+12],	%al
    jmp       L6558
L6580:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L6583
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L6582
L6583:
    jmp       L6566
L6582:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+13],	%al
    jmp       L6558
L6560:
#cc_parse.readdeclspec.tserror:
L6566:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_tables.typespecnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %rcx,	[%rip+L11218]
    mov       %rdx,	%r10
    call      cc_support.serror_s
L6558:
    call      cc_lex.lex
    jmp       L6552
L6584:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jz        L6586
    cmp       %rax,	2
    jz        L6587
    cmp       %rax,	3
    jz        L6588
    jmp       L6589
L6586:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+4],	%al
    jmp       L6585
L6587:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+5],	%al
    jmp       L6585
L6588:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+6],	%al
L6589:
L6585:
    call      cc_lex.lex
    jmp       L6552
L6590:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+7]
    test      %al,	%al
    jz        L6592
    lea       %rcx,	[%rip+L11219]
    call      cc_support.serror
L6592:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+22]
    mov       [%rbp + cc_parse.readdeclspec.d+7],	%al
    call      cc_lex.lex
    jmp       L6552
L6593:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jnz       L6596
L6595:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+8],	%al
L6596:
L6594:
    call      cc_lex.lex
    jmp       L6552
L6597:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L6599
    lea       %rcx,	[%rip+L11220]
    call      cc_support.serror
L6599:
    mov       %rcx,	%r13
    call      cc_parse.readstructdecl
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    mov       %r12,	1
    jmp       L6552
L6600:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L6602
    lea       %rcx,	[%rip+L11221]
    call      cc_support.serror
L6602:
    mov       %rcx,	%r13
    call      cc_parse.readenumdecl
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    jmp       L6552
L6603:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L6605
    mov       %rcx,	%r13
    call      cc_parse.isusertype
    mov       %rsi,	%rax
    cmp       %rax,	20
    jz        L6605
    test      %rbx,	%rbx
    jz        L6607
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    jmp       L6553
L6607:
    mov       [%rbp + cc_parse.readdeclspec.d],	%esi
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    call      cc_lex.lex
    jmp       L6604
L6605:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L6609
    test      %rbx,	%rbx
    jnz       L6609
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L11222]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L6609:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L6611
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
L6611:
    jmp       L6553
L6604:
    jmp       L6552
L6555:
    jmp       L6553
L6553:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L6613
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    jmp       L6612
L6613:
    mov       %rax,	3
L6612:
    mov       %rdi,	%rax
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+14]
    test      %al,	%al
    jnz       L6615
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L6617
    cmp       %rax,	1
    jz        L6618
    cmp       %rax,	11
    jz        L6619
    jmp       L6620
L6617:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jz        L6622
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L6624
    mov       %rax,	7
    jmp       L6623
L6624:
    mov       %rax,	2
L6623:
    mov       %rdi,	%rax
    jmp       L6621
L6622:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jz        L6625
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L6627
    mov       %rax,	8
    jmp       L6626
L6627:
    mov       %rax,	3
L6626:
    mov       %rdi,	%rax
    jmp       L6621
L6625:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L6628
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L6630
    mov       %rax,	9
    jmp       L6629
L6630:
    mov       %rax,	4
L6629:
    mov       %rdi,	%rax
    jmp       L6621
L6628:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L6631
    mov       %rdi,	8
L6631:
L6621:
    jmp       L6616
L6618:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L6634
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jnz       L6634
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L6633
L6634:
    lea       %rcx,	[%rip+L11223]
    call      cc_support.serror
L6633:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L6636
    mov       %rax,	6
    jmp       L6635
L6636:
    mov       %rax,	1
L6635:
    mov       %rdi,	%rax
    jmp       L6616
L6619:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L6639
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jnz       L6639
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L6639
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L6638
L6639:
    lea       %rcx,	[%rip+L11224]
    call      cc_support.serror
L6638:
    jmp       L6616
L6620:
    test      %rbx,	%rbx
    jz        L6641
    lea       %rcx,	[%rip+L11225]
    call      cc_support.serror
L6641:
L6616:
L6615:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+4]
    test      %al,	%al
    jz        L6643
    mov       %rcx,	%rdi
    call      cc_lib.createconstmode
    mov       %rdi,	%rax
L6643:
    movzx     %rax,	byte ptr[%rbp + cc_parse.readdeclspec.d+7]
    mov       [%r14],	%rax
    mov       %rax,	%rdi
L6551:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.istypestarter
cc_parse.istypestarter:
#?>>
    .set cc_parse.istypestarter.$T3, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	70
    jz        L6646
    cmp       %rax,	87
    jz        L6646
    cmp       %rax,	86
    jz        L6647
    cmp       %rax,	67
    jz        L6648
    cmp       %rax,	83
    jz        L6649
    cmp       %rax,	84
    jz        L6649
    cmp       %rax,	90
    jz        L6649
    jmp       L6650
L6646:
    mov       %rax,	1
    jmp       L6644
L6647:
    mov       %rax,	1
    jmp       L6644
L6648:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.istypestarter.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6652
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L6651
L6652:
    mov       %rax,	[%rip+cc_decls.stmodule]
L6651:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.istypestarter.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L6654
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.lx]
    mov       [%r10],	%rax
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    jmp       L6644
L6654:
    jmp       L6645
L6649:
    mov       %rax,	1
    jmp       L6644
L6650:
L6645:
    xor       %eax,	%eax
L6644:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.istypestarter_next
cc_parse.istypestarter_next:
#?>>
    .set cc_parse.istypestarter_next.$T3, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	70
    jz        L6657
    cmp       %rax,	87
    jz        L6657
    cmp       %rax,	86
    jz        L6658
    cmp       %rax,	67
    jz        L6659
    cmp       %rax,	83
    jz        L6660
    cmp       %rax,	84
    jz        L6660
    cmp       %rax,	90
    jz        L6660
    jmp       L6661
L6657:
    mov       %rax,	1
    jmp       L6655
L6658:
    mov       %rax,	1
    jmp       L6655
L6659:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.istypestarter_next.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6663
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L6662
L6663:
    mov       %rax,	[%rip+cc_decls.stmodule]
L6662:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.istypestarter_next.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L6665
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    jmp       L6655
L6665:
    jmp       L6656
L6660:
    mov       %rax,	1
    jmp       L6655
L6661:
L6656:
    xor       %eax,	%eax
L6655:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexpression
cc_parse.readexpression:
#?>>
    .set cc_parse.readexpression.ulist, -8
    .set cc_parse.readexpression.ulistx, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L6668
    cmp       %rax,	14
    jnz       L6669
L6668:
    call      cc_parse.readterm
    jmp       L6666
L6669:
L6667:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L6671
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readexpression.ulistx],	%rax
    mov       [%rbp + cc_parse.readexpression.ulist],	%rax
L6672:
    lea       %rcx,	[%rbp + cc_parse.readexpression.ulist]
    lea       %rdx,	[%rbp + cc_parse.readexpression.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L6673
L6675:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    jmp       L6672
L6673:
    mov       %rcx,	29
    mov       %rdx,	[%rbp + cc_parse.readexpression.ulist]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readexpression.ulistx]
    test      %rax,	%rax
    jz        L6677
    mov       %rax,	[%rbp + cc_parse.readexpression.ulistx]
    mov       %eax,	[%rax+52]
    mov       [%rdi+52],	%eax
L6677:
    mov       %rax,	%rdi
    jmp       L6666
L6671:
    mov       %rax,	%rdi
L6666:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readassignexpr
cc_parse.readassignexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L6680
    cmp       %rax,	9
    jz        L6680
    cmp       %rax,	14
    jz        L6680
    cmp       %rax,	11
    jz        L6681
    jmp       L6682
L6680:
    call      cc_parse.readterm
    jmp       L6678
L6681:
    call      cc_parse.readterm
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    jmp       L6683
L6682:
L6679:
    call      cc_parse.readcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    sub       %rax,	11
    cmp       %rax,	45
    jae       L6686
    lea       %r10,	[%rip+L6685]
    jmp       [%r10 + %rax*8]
    .data
L6685:
    .quad     L6687
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6686
    .quad     L6687
    .quad     L6687
    .quad     L6687
    .quad     L6687
    .quad     L6687
    .quad     L6687
    .quad     L6687
    .quad     L6687
    .quad     L6687
    .quad     L6687
    .text
L6687:
#cc_parse.readassignexpr.gotp:
L6683:
    call      cc_lex.lex
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %r13,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_parse.checklvalue
    call      cc_parse.readassignexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L6689
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_parse.createassignopref
    jmp       L6678
L6689:
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6691
    lea       %rcx,	[%rip+L11226]
    call      cc_support.terror
L6691:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	52
    jnz       L6693
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L6693
    lea       %rcx,	[%rip+L11227]
    call      cc_support.terror
L6693:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rsi,	%rax
    mov       [%rsi+52],	%r13d
    mov       %rax,	%rsi
    jmp       L6678
L6686:
L6684:
    mov       %rax,	%rdi
L6678:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcondexpr
cc_parse.readcondexpr:
#?>>
    .set cc_parse.readcondexpr.u, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    call      cc_parse.readorlexpr
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	19
    jnz       L6696
    mov       %rcx,	%rsi
    call      cc_parse.coercecond
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readcondexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    test      %rax,	%rax
    jz        L6698
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L6700
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6700
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6700
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L6702
    mov       %rax,	%rdi
    jmp       L6701
L6702:
    mov       %rax,	%rbx
L6701:
    jmp       L6694
L6700:
    jmp       L6697
L6698:
    cmp       %r12,	13
    jnz       L6703
    cmp       %r13,	13
    jnz       L6703
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L6697
L6703:
    cmp       %r12,	13
    jnz       L6704
    cmp       %r13,	3
    jnz       L6704
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6704
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L6704
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L6697
L6704:
    cmp       %r12,	3
    jnz       L6705
    cmp       %r13,	13
    jnz       L6705
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6705
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L6705
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L6697
L6705:
    cmp       %r12,	18
    jnz       L6706
    cmp       %r13,	18
    jnz       L6706
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L6697
L6706:
    cmp       %r12,	19
    jnz       L6707
    cmp       %r13,	19
    jnz       L6707
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L6697
L6707:
    mov       %rax,	%r13
    cmp       %rax,	%r12
    jnz       L6708
    test      %rax,	%rax
    jnz       L6708
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L6697
L6708:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11228]
    call      cc_support.terror
L6697:
    mov       %rcx,	31
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      cc_lib.createunit3
    mov       %rsi,	%rax
    mov       %eax,	[%rbp + cc_parse.readcondexpr.u]
    mov       [%rsi+52],	%eax
L6696:
    mov       %rax,	%rsi
L6694:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readorlexpr
cc_parse.readorlexpr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readandlexpr
    mov       %rdi,	%rax
    jmp       L6711
L6710:
    call      cc_lex.lex
    call      cc_parse.readandlexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6714
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6714
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L6717
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L6716
L6717:
    mov       %rax,	1
    jmp       L6715
L6716:
    xor       %eax,	%eax
L6715:
    mov       [%rdi],	%rax
    jmp       L6711
L6714:
    mov       %rcx,	25
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L6711:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	31
    jz        L6710
    mov       %rax,	%rdi
L6709:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readandlexpr
cc_parse.readandlexpr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readiorexpr
    mov       %rdi,	%rax
    jmp       L6720
L6719:
    call      cc_lex.lex
    call      cc_parse.readiorexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6723
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6723
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L6725
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L6725
    mov       %rax,	1
    jmp       L6724
L6725:
    xor       %eax,	%eax
L6724:
    mov       [%rdi],	%rax
    jmp       L6720
L6723:
    mov       %rcx,	24
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L6720:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	32
    jz        L6719
    mov       %rax,	%rdi
L6718:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readiorexpr
cc_parse.readiorexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readixorexpr
    mov       %rdi,	%rax
    jmp       L6728
L6727:
    call      cc_lex.lex
    call      cc_parse.readixorexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L6731
    cmp       %rsi,	10
    jl        L6733
    lea       %rcx,	[%rip+L11229]
    call      cc_support.terror
L6733:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L6730
L6731:
    lea       %rcx,	[%rip+L11230]
    call      cc_support.terror
L6730:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6735
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6735
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L6737
    cmp       %rax,	4
    jz        L6737
    cmp       %rax,	8
    jz        L6737
    cmp       %rax,	9
    jnz       L6738
L6737:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    or        [%r10],	%rax
    jmp       L6728
L6738:
L6736:
L6735:
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L6728:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	28
    jz        L6727
    mov       %rax,	%rdi
L6726:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readixorexpr
cc_parse.readixorexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readiandexpr
    mov       %rdi,	%rax
    jmp       L6741
L6740:
    call      cc_lex.lex
    call      cc_parse.readiandexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L6744
    cmp       %rsi,	10
    jl        L6746
    lea       %rcx,	[%rip+L11231]
    call      cc_support.terror
L6746:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L6743
L6744:
    lea       %rcx,	[%rip+L11232]
    call      cc_support.terror
L6743:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6748
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6748
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L6750
    cmp       %rax,	4
    jz        L6750
    cmp       %rax,	8
    jz        L6750
    cmp       %rax,	9
    jnz       L6751
L6750:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    xor       [%r10],	%rax
    jmp       L6741
L6751:
L6749:
L6748:
    mov       %rcx,	46
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L6741:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	30
    jz        L6740
    mov       %rax,	%rdi
L6739:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readiandexpr
cc_parse.readiandexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readeqexpr
    mov       %rdi,	%rax
    jmp       L6754
L6753:
    call      cc_lex.lex
    call      cc_parse.readeqexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L6757
    cmp       %rsi,	10
    jl        L6759
    lea       %rcx,	[%rip+L11233]
    call      cc_support.terror
L6759:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L6756
L6757:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11234]
    call      cc_support.terror
L6756:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6761
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6761
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L6763
    cmp       %rax,	4
    jz        L6763
    cmp       %rax,	8
    jz        L6763
    cmp       %rax,	9
    jnz       L6764
L6763:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    and       [%r10],	%rax
    jmp       L6754
L6764:
L6762:
L6761:
    mov       %rcx,	44
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L6754:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	29
    jz        L6753
    mov       %rax,	%rdi
L6752:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readeqexpr
cc_parse.readeqexpr:
#?>>
    .set cc_parse.readeqexpr.ss, -8
    .set cc_parse.readeqexpr.tt, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    call      cc_parse.readrelexpr
    mov       %rdi,	%rax
    jmp       L6767
L6766:
    call      cc_lex.lex
    call      cc_parse.readrelexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %r14,	%rax
    test      %rax,	%rax
    jz        L6770
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L6769
L6770:
    cmp       %r12,	13
    jnz       L6771
    cmp       %r13,	13
    jnz       L6771
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rbp + cc_parse.readeqexpr.ss],	%r10
    movsxd    %rax,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %rax*2]
    mov       [%rbp + cc_parse.readeqexpr.tt],	%r11
    cmp       %r10,	%r11
    jz        L6773
    mov       %rax,	[%rbp + cc_parse.readeqexpr.ss]
    test      %rax,	%rax
    jz        L6775
    mov       %rax,	[%rbp + cc_parse.readeqexpr.tt]
    test      %rax,	%rax
    jz        L6775
    movsxd    %rax,	dword ptr[%rbx+52]
    movsxd    %r10,	dword ptr[%rdi+52]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jnz       L6777
    lea       %rcx,	[%rip+L11235]
    call      cc_support.terror
L6777:
L6775:
L6773:
    jmp       L6769
L6771:
    cmp       %r12,	13
    jnz       L6778
    cmp       %r13,	3
    jnz       L6778
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6781
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L6780
L6781:
    lea       %rcx,	[%rip+L11236]
    call      cc_support.terror
L6780:
    jmp       L6769
L6778:
    cmp       %r12,	3
    jnz       L6782
    cmp       %r13,	13
    jnz       L6782
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6785
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L6784
L6785:
    lea       %rcx,	[%rip+L11237]
    call      cc_support.terror
L6784:
    jmp       L6769
L6782:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11238]
    call      msys.m$print_str_nf
    mov       %rcx,	%r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11239]
    call      cc_support.terror
L6769:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6787
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6787
    mov       %rax,	%r14
    cmp       %rax,	3
    jz        L6789
    cmp       %rax,	4
    jz        L6789
    cmp       %rax,	8
    jz        L6789
    cmp       %rax,	9
    jz        L6789
    test      %rax,	%rax
    jnz       L6790
L6789:
    cmp       %rsi,	40
    jnz       L6792
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    cmp       %rax,	%r10
    setz      %al
    movzx     %eax,	%al
    mov       [%rdi],	%rax
    jmp       L6791
L6792:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    cmp       %rax,	%r10
    setnz     %al
    movzx     %eax,	%al
    mov       [%rdi],	%rax
L6791:
    jmp       L6767
L6790:
L6788:
L6787:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L6767:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	40
    jz        L6766
    cmp       %rsi,	41
    jz        L6766
    mov       %rax,	%rdi
L6765:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readrelexpr
cc_parse.readrelexpr:
#?>>
    .set cc_parse.readrelexpr.a, -8
    .set cc_parse.readrelexpr.b, -16
    .set cc_parse.readrelexpr.c, -24
    .set cc_parse.readrelexpr.aa, -32
    .set cc_parse.readrelexpr.bb, -40
    .set cc_parse.readrelexpr.cc, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
#---------------
    call      cc_parse.readshiftexpr
    mov       %rdi,	%rax
    jmp       L6795
L6794:
    call      cc_lex.lex
    call      cc_parse.readshiftexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %r14,	%rax
    test      %rax,	%rax
    jz        L6798
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L6797
L6798:
    cmp       %r12,	13
    jnz       L6799
    cmp       %r13,	13
    jnz       L6799
    movsxd    %rax,	dword ptr[%rbx+52]
    movsxd    %r10,	dword ptr[%rdi+52]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jnz       L6801
    lea       %rcx,	[%rip+L11240]
    call      cc_support.terror
L6801:
    jmp       L6797
L6799:
    lea       %rcx,	[%rip+L11241]
    call      cc_support.terror
L6797:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6803
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6803
    mov       %rax,	[%rdi]
    mov       [%rbp + cc_parse.readrelexpr.a],	%rax
    mov       %rax,	[%rbx]
    mov       [%rbp + cc_parse.readrelexpr.b],	%rax
    mov       %rax,	%r14
    cmp       %rax,	3
    jz        L6805
    cmp       %rax,	4
    jz        L6805
    cmp       %rax,	8
    jz        L6806
    cmp       %rax,	9
    jz        L6806
    jmp       L6807
L6805:
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L6809
    cmp       %rax,	43
    jz        L6810
    cmp       %rax,	44
    jz        L6811
    jmp       L6812
L6809:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setl      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L6808
L6810:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setle     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L6808
L6811:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setge     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L6808
L6812:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setg      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
L6808:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.c]
    mov       [%rdi],	%rax
    jmp       L6795
L6806:
    mov       %rax,	[%rdi]
    mov       [%rbp + cc_parse.readrelexpr.aa],	%rax
    mov       %rax,	[%rbx]
    mov       [%rbp + cc_parse.readrelexpr.bb],	%rax
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L6814
    cmp       %rax,	43
    jz        L6815
    cmp       %rax,	44
    jz        L6816
    jmp       L6817
L6814:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setb      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L6813
L6815:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setbe     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L6813
L6816:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setae     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L6813
L6817:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    seta      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
L6813:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.cc]
    mov       [%rdi],	%rax
    jmp       L6795
L6807:
L6804:
L6803:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L6795:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	42
    jz        L6794
    cmp       %rsi,	43
    jz        L6794
    cmp       %rsi,	44
    jz        L6794
    cmp       %rsi,	45
    jz        L6794
    mov       %rax,	%rdi
L6793:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readshiftexpr
cc_parse.readshiftexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readaddexpr
    mov       %rdi,	%rax
    jmp       L6820
L6819:
    call      cc_lex.lex
    call      cc_parse.readaddexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercebasetype
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    cmp       %r10,	1
    jl        L6824
    cmp       %r12,	9
    jle       L6823
L6824:
    lea       %rcx,	[%rip+L11242]
    call      cc_support.terror
L6823:
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6826
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L6826
    mov       %rax,	%r12
    cmp       %rax,	3
    jz        L6828
    cmp       %rax,	4
    jz        L6828
    cmp       %rax,	8
    jz        L6829
    cmp       %rax,	9
    jz        L6829
    jmp       L6830
L6828:
    cmp       %rsi,	33
    jnz       L6832
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shl       %rax,	%cl
    mov       [%rdi],	%rax
    jmp       L6831
L6832:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    sar       %rax,	%cl
    mov       [%rdi],	%rax
L6831:
    jmp       L6820
L6829:
    cmp       %rsi,	33
    jnz       L6834
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shl       %rax,	%cl
    mov       [%rdi],	%rax
    jmp       L6833
L6834:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shr       %rax,	%cl
    mov       [%rdi],	%rax
L6833:
    jmp       L6820
L6830:
L6827:
L6826:
    cmp       %rsi,	33
    jnz       L6836
    mov       %rax,	47
    jmp       L6835
L6836:
    mov       %rax,	48
L6835:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
L6820:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	33
    jz        L6819
    cmp       %rsi,	34
    jz        L6819
    mov       %rax,	%rdi
L6818:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readaddexpr
cc_parse.readaddexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readmulexpr
    mov       %rdi,	%rax
    jmp       L6839
L6838:
    call      cc_lex.lex
    call      cc_parse.readmulexpr
    mov       %rbx,	%rax
    cmp       %rsi,	23
    jnz       L6842
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createaddop
    mov       %rdi,	%rax
    jmp       L6841
L6842:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createsubop
    mov       %rdi,	%rax
L6841:
L6839:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	23
    jz        L6838
    cmp       %rsi,	24
    jz        L6838
    mov       %rax,	%rdi
L6837:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmulexpr
cc_parse.readmulexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L6845
L6844:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	25
    jz        L6848
    cmp       %rax,	26
    jz        L6849
    cmp       %rax,	27
    jz        L6850
    jmp       L6851
L6848:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createmulop
    mov       %rdi,	%rax
    jmp       L6847
L6849:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createdivop
    mov       %rdi,	%rax
    jmp       L6847
L6850:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createremop
    mov       %rdi,	%rax
L6851:
L6847:
L6845:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	25
    jz        L6844
    cmp       %rsi,	26
    jz        L6844
    cmp       %rsi,	27
    jz        L6844
    mov       %rax,	%rdi
L6843:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readterm
cc_parse.readterm:
#?>>
    .set cc_parse.readterm.slength, -8
    .set cc_parse.readterm.fwide, -16
    .set cc_parse.readterm.tag, -24
    .set cc_parse.readterm.pbyte, -32
    .set cc_parse.readterm.a, -40
    .set cc_parse.readterm.d, -48
    .set cc_parse.readterm.ss, -56
    .set cc_parse.readterm.s, -64
    .set cc_parse.readterm.pm, -72
    .set cc_parse.readterm.av_1, -80
    .set cc_parse.readterm.$T3, -88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	120
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	13
    cmp       %rax,	83
    jae       L6855
    lea       %r10,	[%rip+L6854]
    jmp       [%r10 + %rax*8]
    .data
L6854:
    .quad     L6902
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6889
    .quad     L6890
    .quad     L6899
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6895
    .quad     L6855
    .quad     L6855
    .quad     L6898
    .quad     L6855
    .quad     L6855
    .quad     L6894
    .quad     L6891
    .quad     L6900
    .quad     L6900
    .quad     L6901
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6856
    .quad     L6856
    .quad     L6881
    .quad     L6855
    .quad     L6875
    .quad     L6875
    .quad     L6855
    .quad     L6855
    .quad     L6857
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6855
    .quad     L6907
    .quad     L6855
    .quad     L6918
    .quad     L6919
    .quad     L6920
    .text
L6856:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L6853
L6857:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jg        L6859
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6861
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L6860
L6861:
    mov       %rax,	[%rip+cc_decls.stmodule]
L6860:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.readterm.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       [%rbp + cc_parse.readterm.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    test      %rax,	%rax
    jnz       L6863
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      cc_lib.getstname
    lea       %rcx,	[%rip+L11243]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L6863:
    jmp       L6858
L6859:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.d],	%rax
L6858:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	11
    jz        L6865
    cmp       %rax,	6
    jz        L6866
    jmp       L6867
L6865:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L6864
L6866:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L6869
    mov       %rcx,	5
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    mov       [%rdi],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    mov       %rax,	[%rax+80]
    mov       %r10,	[%rbp + cc_parse.readterm.d]
    movzx     %r10,	word ptr[%r10+102]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%rdi+52],	%eax
    jmp       L6868
L6869:
    jmp       L6870
L6868:
    jmp       L6864
L6867:
#cc_parse.readterm.doname:
L6870:
    mov       %rcx,	[%rbp + cc_parse.readterm.d]
    call      cc_lib.createname
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L6872
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rdi+48],	%eax
    mov       %rcx,	%rdi
    call      cc_parse.createaddrofop
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%rdi+52],	%eax
    jmp       L6871
L6872:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L6873
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L6873
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    jmp       L6871
L6873:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	9
    jnz       L6874
L6874:
L6871:
L6864:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    call      cc_lex.lex
    jmp       L6853
L6875:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	64
    setz      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readterm.fwide],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.s],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       [%rbp + cc_parse.readterm.slength],	%rax
    jmp       L6877
L6876:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %r10,	[%rbp + cc_parse.readterm.slength]
    add       %r10,	%rax
    mov       %r14,	%r10
    lea       %rax,	[%r14+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + cc_parse.readterm.ss],	%rax
    mov       %rcx,	[%rbp + cc_parse.readterm.ss]
    mov       %rdx,	[%rbp + cc_parse.readterm.s]
    mov       %r8,	[%rbp + cc_parse.readterm.slength]
    call      memcpy
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %r11,	[%rbp + cc_parse.readterm.ss]
    mov       %r15,	[%rbp + cc_parse.readterm.slength]
    lea       %r11,	[%r11 + %r15]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readterm.ss]
    mov       %r11,	%r14
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rbp + cc_parse.readterm.ss]
    mov       [%rbp + cc_parse.readterm.s],	%rax
    mov       [%rbp + cc_parse.readterm.slength],	%r14
    call      cc_lex.lex
L6877:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L6876
    mov       %rax,	[%rbp + cc_parse.readterm.fwide]
    test      %rax,	%rax
    jz        L6880
    mov       %rcx,	[%rbp + cc_parse.readterm.s]
    mov       %rdx,	[%rbp + cc_parse.readterm.slength]
    call      cc_lib.createwstringconstunit
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.readterm.slength]
    mov       [%rdi+48],	%eax
    mov       %eax,	[%rip+cc_decls.trefwchar]
    mov       [%rdi+52],	%eax
    jmp       L6879
L6880:
    mov       %rcx,	[%rbp + cc_parse.readterm.s]
    mov       %rdx,	[%rbp + cc_parse.readterm.slength]
    call      cc_lib.createstringconstunit
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.readterm.slength]
    mov       [%rdi+48],	%eax
    mov       %eax,	[%rip+cc_decls.trefchar]
    mov       [%rdi+52],	%eax
L6879:
    call      cc_lex.lex
    jmp       L6853
L6881:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readterm.a],	%rax
    xor       %r13,	%r13
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.pbyte],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	8
    jle       L6883
    lea       %rcx,	[%rip+L11244]
    call      cc_support.serror
L6883:
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       [%rbp + cc_parse.readterm.av_1],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.av_1]
    cmp       %rax,	0
    jle       L6886
L6884:
    mov       %rax,	[%rbp + cc_parse.readterm.pbyte]
    movzx     %rax,	byte ptr[%rax]
    mov       %cl,	%r13b
    shl       %rax,	%cl
    mov       %r10,	[%rbp + cc_parse.readterm.a]
    or        %r10,	%rax
    mov       [%rbp + cc_parse.readterm.a],	%r10
    mov       %rax,	8
    add       %r13,	%rax
    inc       qword ptr[%rbp + cc_parse.readterm.pbyte]
    dec       qword ptr[%rbp + cc_parse.readterm.av_1]
    jnz       L6884
L6886:
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	4
    jg        L6888
    mov       %rax,	3
    jmp       L6887
L6888:
    mov       %rax,	4
L6887:
    mov       %rcx,	[%rbp + cc_parse.readterm.a]
    mov       %rdx,	%rax
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L6853
L6889:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L6853
L6890:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createnegop
    mov       %rdi,	%rax
    jmp       L6853
L6891:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	26
    mov       %rdx,	%rdi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	26
    jnz       L6893
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	26
    jnz       L6893
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax+16]
    mov       [%rdi+16],	%rax
L6893:
    jmp       L6853
L6894:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createinotop
    mov       %rdi,	%rax
    jmp       L6853
L6895:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	25
    jnz       L6897
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L6896
L6897:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createaddrofop
    mov       %rdi,	%rax
L6896:
    jmp       L6853
L6898:
    lea       %rcx,	[%rip+L11245]
    call      cc_support.serror
    jmp       L6853
L6899:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createptrop
    mov       %rdi,	%rax
    jmp       L6853
L6900:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symboltojtag]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %r12,	%r10
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L6853
L6901:
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       %rcx,	%rax
    call      cc_parse.createabsop
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    jmp       L6853
L6902:
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L6904
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L6906
    lea       %rcx,	[%rip+L11246]
    call      cc_support.serror
    jmp       L6905
L6906:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_parse.docast
    mov       %rdi,	%rax
L6905:
    jmp       L6903
L6904:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L6903:
    jmp       L6853
L6907:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+22]
    test      %al,	%al
    jz        L6909
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L6911
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L6913
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L6912
L6913:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L6912:
    jmp       L6910
L6911:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L6910:
    jmp       L6908
L6909:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L6915
    call      cc_parse.istypestarter_next
    test      %rax,	%rax
    jz        L6917
    call      cc_lex.lex
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L6916
L6917:
    call      cc_parse.readterm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L6916:
    jmp       L6914
L6915:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L6914:
L6908:
    jmp       L6853
L6918:
    call      cc_parse.readgeneric
    mov       %rdi,	%rax
    jmp       L6853
L6919:
    lea       %rcx,	[%rip+L11247]
    call      cc_support.serror
    jmp       L6853
L6920:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    mov       [%rbp + cc_parse.readterm.tag],	%rax
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.tag]
    cmp       %rax,	76
    jnz       L6922
    mov       %rcx,	8
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rbx,	%rax
    jmp       L6921
L6922:
    xor       %rbx,	%rbx
L6921:
    mov       %rcx,	[%rbp + cc_parse.readterm.tag]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    jmp       L6853
L6855:
    lea       %rcx,	[%rip+L11248]
    call      cc_lex.ps
    lea       %rcx,	[%rip+L11249]
    call      cc_support.serror
L6853:
L6923:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	2
    cmp       %rax,	37
    jae       L6926
    lea       %r10,	[%rip+L6925]
    jmp       [%r10 + %rax*8]
    .data
L6925:
    .quad     L6928
    .quad     L6928
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6929
    .quad     L6926
    .quad     L6927
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6926
    .quad     L6932
    .quad     L6933
    .text
L6927:
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       %rbx,	%rax
    mov       %rcx,	16
    call      cc_lib.skipsymbol
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createindexop
    mov       %rdi,	%rax
    jmp       L6923
L6928:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symboltojtag]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %r12,	%r10
    call      cc_lex.lex
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.d],	%rax
    call      cc_lex.lex
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readterm.d]
    call      cc_parse.createdotop
    mov       %rdi,	%rax
    jmp       L6923
L6929:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L6931
    xor       %rbx,	%rbx
    call      cc_lex.lex
    jmp       L6930
L6931:
    xor       %ecx,	%ecx
    call      cc_parse.readexprlist
    mov       %rbx,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L6930:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createcall
    mov       %rdi,	%rax
    jmp       L6923
L6932:
    call      cc_lex.lex
    mov       %rcx,	73
    mov       %rdx,	%rdi
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L6923
L6933:
    call      cc_lex.lex
    mov       %rcx,	74
    mov       %rdx,	%rdi
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L6923
L6926:
    jmp       L6924
L6924:
    mov       %rax,	%rdi
L6852:
#---------------
    add       %rsp,	120
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexprlist
cc_parse.readexprlist:
#?>>
    .set cc_parse.readexprlist.ulist, -8
    .set cc_parse.readexprlist.ulistx, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    mov       [%rbp + cc_parse.readexprlist.ulistx],	%rax
    mov       [%rbp + cc_parse.readexprlist.ulist],	%rax
L6935:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + cc_parse.readexprlist.ulist]
    lea       %rdx,	[%rbp + cc_parse.readexprlist.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L6936
L6938:
    call      cc_lex.lex
    jmp       L6935
L6936:
    mov       %rax,	[%rbp + cc_parse.readexprlist.ulist]
L6934:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmodulevar
cc_parse.readmodulevar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%r12
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L6941
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L6943
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11250]
    mov       %rdx,	%rax
    mov       %r8,	%r10
    call      cc_support.serror_ss
L6943:
    movzx     %rax,	word ptr[%rdi+102]
    mov       %rsi,	%rax
    cmp       %rsi,	%r13
    jz        L6945
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L6947
#cc_parse.readmodulevar.redef:
L6948:
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11251]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L6947:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L6951
L6950:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jnz       L6953
    mov       [%rdi+102],	%r13w
    jmp       L6952
L6953:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6954
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%r13
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L6948
L6954:
L6952:
L6951:
L6949:
L6945:
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jnz       L6958
    test      %r14,	%r14
    jz        L6957
L6958:
    cmp       %rbx,	4
    jnz       L6959
    cmp       %r14,	1
    jz        L6957
L6959:
    cmp       %rbx,	3
    jnz       L6956
    cmp       %r14,	1
    jnz       L6956
L6957:
    jmp       L6955
L6956:
    cmp       %rbx,	3
    jnz       L6960
    test      %r14,	%r14
    jnz       L6960
    mov       %rbx,	4
L6960:
L6955:
    jmp       L6940
L6941:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%r12
    mov       %r8,	7
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L6962
    cmp       %rax,	4
    jz        L6963
    jmp       L6964
L6962:
    mov       %rbx,	2
    jmp       L6961
L6963:
    mov       %rbx,	3
    jmp       L6961
L6964:
    mov       %rbx,	4
L6961:
L6940:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L6966
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L6968
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L11252]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L6968:
    cmp       %rbx,	3
    jnz       L6970
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L11253]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L6970:
    call      cc_lex.lex
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%rax
    call      cc_parse.readinitexpr
    mov       [%r12+72],	%rax
L6966:
    mov       [%r12+110],	%bl
    mov       %rax,	%r12
L6939:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readframevar
cc_parse.readframevar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%r12
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl_inproc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L6973
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11254]
    mov       %rdx,	%rax
    call      cc_support.serror_s
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jnz       L6977
    test      %r14,	%r14
    jz        L6976
L6977:
    cmp       %rbx,	4
    jnz       L6978
    cmp       %r14,	1
    jz        L6976
L6978:
    cmp       %rbx,	3
    jnz       L6975
    cmp       %r14,	1
    jnz       L6975
L6976:
    jmp       L6974
L6975:
    cmp       %rbx,	3
    jnz       L6979
    test      %r14,	%r14
    jnz       L6979
    mov       %rbx,	4
L6979:
L6974:
    jmp       L6972
L6973:
    mov       %rsi,	8
    mov       %rbx,	1
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L6981
    cmp       %rax,	4
    jz        L6982
    jmp       L6983
L6981:
    mov       %rsi,	7
    jmp       L6980
L6982:
    mov       %rbx,	3
    mov       %rsi,	7
L6983:
L6980:
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%r12
    mov       %r8,	%rsi
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%r12+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L6972:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L6985
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L6987
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L11255]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L6987:
    cmp       %rbx,	3
    jnz       L6989
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L11256]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L6989:
    call      cc_lex.lex
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    call      cc_parse.readinitexpr
    mov       [%r12+72],	%rax
L6985:
    mov       [%r12+110],	%bl
    mov       %rax,	%r12
L6971:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readtype
cc_parse.readtype:
#?>>
    .set cc_parse.readtype.modtype, -256
    .set cc_parse.readtype.modvalue, -512
    .set cc_parse.readtype.nmodifiers, -520
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	560
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readtype.nmodifiers],	%rax
    xor       %eax,	%eax
    mov       [%r14],	%rax
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readtype.nmodifiers]
    push      %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    lea       %r8,	[%rbp + cc_parse.readtype.modtype]
    lea       %r9,	[%rbp + cc_parse.readtype.modvalue]
    sub       %rsp,	32
    call      cc_parse.readnamedtype
    add       %rsp,	48
    mov       %rbx,	[%rbp + cc_parse.readtype.nmodifiers]
    cmp       %rbx,	1
    jl        L6993
L6991:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readtype.modtype-8]
    cmp       %rax,	65
    jz        L6995
    cmp       %rax,	82
    jz        L6996
    cmp       %rax,	67
    jz        L6997
    cmp       %rax,	70
    jz        L6998
    jmp       L6999
L6995:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readtype.modvalue-8]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      cc_lib.createarraymode
    mov       %r13,	%rax
    jmp       L6994
L6996:
    mov       %rcx,	%r13
    call      cc_lib.createrefmode
    mov       %r13,	%rax
    jmp       L6994
L6997:
    mov       %rcx,	%r13
    call      cc_lib.createconstmode
    mov       %r13,	%rax
    jmp       L6994
L6998:
    mov       %rdi,	[%rbp + %rbx*8 + cc_parse.readtype.modvalue-8]
    cmp       %rbx,	1
    jnz       L7001
    mov       [%r14],	%rdi
    jmp       L7000
L7001:
    mov       %rcx,	%r13
    mov       %rdx,	%rdi
    call      cc_lib.createprocmode
    mov       %r13,	%rax
L7000:
L6999:
L6994:
    dec       %rbx
    cmp       %rbx,	1
    jge       L6991
L6993:
    mov       %rax,	%r13
L6990:
#---------------
    add       %rsp,	560
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readnamedtype
cc_parse.readnamedtype:
#?>>
    .set cc_parse.readnamedtype.modvalue, 88
    .set cc_parse.readnamedtype.nmodifiers, 96
    .set cc_parse.readnamedtype.fconst, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%r13],	%rax
    xor       %rbx,	%rbx
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	88
    jnz       L7004
    call      cc_lex.lex
L7004:
    jmp       L7006
L7005:
    inc       %rbx
    xor       %eax,	%eax
    mov       [%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8],	%rax
    call      cc_lex.lex
    jmp       L7009
L7008:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jz        L7012
    cmp       %rax,	2
    jz        L7013
    cmp       %rax,	3
    jz        L7013
    jmp       L7014
L7012:
    mov       %rax,	1
    mov       [%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8],	%rax
    jmp       L7011
L7013:
    jmp       L7011
L7014:
    lea       %rcx,	[%rip+L11257]
    call      cc_support.serror
L7011:
    call      cc_lex.lex
L7009:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	86
    jz        L7008
L7006:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	25
    jz        L7005
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L7016
    cmp       %rax,	13
    jz        L7017
    jmp       L7018
L7016:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%r13],	%rax
    call      cc_lex.lex
    jmp       L7015
L7017:
    call      cc_lex.lex
    sub       %rsp,	8
    push      qword ptr[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%r14
    mov       %r9,	[%rbp + cc_parse.readnamedtype.modvalue]
    sub       %rsp,	32
    call      cc_parse.readnamedtype
    add       %rsp,	48
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L7018:
L7015:
L7019:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	15
    jz        L7021
    cmp       %rax,	13
    jz        L7022
    jmp       L7023
L7021:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	16
    jnz       L7025
    xor       %rdi,	%rdi
    jmp       L7024
L7025:
    call      cc_parse.readassignexpr
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L7027
    mov       %rdi,	[%rsi]
    jmp       L7026
L7027:
    lea       %rcx,	[%rip+L11258]
    call      cc_support.serror
L7026:
    mov       %rcx,	16
    call      cc_lib.checksymbol
    test      %rdi,	%rdi
    jnz       L7029
    lea       %rcx,	[%rip+L11259]
    call      cc_support.serror
L7029:
L7024:
    cmp       %rdi,	0
    jge       L7031
    lea       %rcx,	[%rip+L11260]
    call      cc_support.terror
L7031:
    call      cc_lex.lex
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	65
    mov       [%r14 + %rax*8-8],	%r10
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    mov       %r11,	[%rbp + cc_parse.readnamedtype.modvalue]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L7019
L7022:
    call      cc_lex.lex
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	70
    mov       [%r14 + %rax*8-8],	%r10
    mov       %rcx,	%r12
    call      cc_parse.readparams
    mov       %r10,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %r10,	[%r10]
    mov       %r11,	[%rbp + cc_parse.readnamedtype.modvalue]
    mov       [%r11 + %r10*8-8],	%rax
    jmp       L7019
L7023:
    jmp       L7020
L7020:
    jmp       L7033
L7032:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8]
    test      %rax,	%rax
    jz        L7036
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	67
    mov       [%r14 + %rax*8-8],	%r10
L7036:
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	82
    mov       [%r14 + %rax*8-8],	%r10
    dec       %rbx
L7033:
    test      %rbx,	%rbx
    jnz       L7032
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readconstintexpr
cc_parse.readconstintexpr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L7040
L7039:
    mov       %rax,	[%rdi]
    jmp       L7037
L7040:
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L11261]
    mov       %rdx,	%r10
    call      cc_support.serror_s
L7038:
    xor       %eax,	%eax
L7037:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readinitexpr
cc_parse.readinitexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    call      cc_parse.readinitexpr2
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L7041:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readinitexpr2
cc_parse.readinitexpr2:
#?>>
    .set cc_parse.readinitexpr2.m, 80
    .set cc_parse.readinitexpr2.istop, 88
    .set cc_parse.readinitexpr2.ulist, -8
    .set cc_parse.readinitexpr2.ulistx, -16
    .set cc_parse.readinitexpr2.d, -24
    .set cc_parse.readinitexpr2.e, -32
    .set cc_parse.readinitexpr2.braces, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L7044
    call      cc_lex.lex
    xor       %r14,	%r14
    mov       %rax,	%rbx
    cmp       %rax,	17
    jz        L7046
    cmp       %rax,	18
    jz        L7047
    cmp       %rax,	19
    jz        L7047
    jmp       L7048
L7046:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %r13,	[%rax + %r10*8]
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.istop]
    test      %rax,	%rax
    jnz       L7050
    test      %r13,	%r13
    jnz       L7050
    lea       %rcx,	[%rip+L11262]
    call      cc_support.terror
L7050:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	1
    jnz       L7052
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jnz       L7052
    mov       %rax,	1
    mov       [%rbp + cc_parse.readinitexpr2.braces],	%rax
    jmp       L7053
L7052:
    jmp       L7045
L7047:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readinitexpr2.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.d]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_parse.readinitexpr2.e],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    test      %rax,	%rax
    jnz       L7055
    lea       %rcx,	[%rip+L11263]
    call      cc_support.terror
L7055:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
    jmp       L7045
L7048:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
    jmp       L7042
L7045:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readinitexpr2.ulistx],	%rax
    mov       [%rbp + cc_parse.readinitexpr2.ulist],	%rax
L7056:
    mov       %rcx,	%r15
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      cc_parse.readinitexpr2
    mov       %rdi,	%rax
    inc       %r14
    mov       %rax,	%rbx
    cmp       %rax,	17
    jz        L7059
    cmp       %rax,	18
    jz        L7060
    cmp       %rax,	19
    jz        L7061
    jmp       L7062
L7059:
    test      %r13,	%r13
    jz        L7064
    cmp       %r14,	%r13
    jle       L7064
    lea       %rcx,	[%rip+L11264]
    call      cc_support.terror
L7064:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7066
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	1
    jnz       L7066
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L7065
L7066:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L7065:
    jmp       L7058
L7060:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7068
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	6
    jnz       L7068
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L7067
L7068:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L7067:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    mov       %rax,	[%rax+32]
    mov       [%rbp + cc_parse.readinitexpr2.e],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    test      %rax,	%rax
    jnz       L7070
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L7072
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jz        L7072
    lea       %rcx,	[%rip+L11265]
    call      cc_support.terror
L7072:
    jmp       L7069
L7070:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
L7069:
    jmp       L7058
L7061:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    mov       [%rbp + cc_parse.readinitexpr2.ulistx],	%rax
    mov       [%rbp + cc_parse.readinitexpr2.ulist],	%rax
    jmp       L7073
L7062:
L7058:
    lea       %rcx,	[%rbp + cc_parse.readinitexpr2.ulist]
    lea       %rdx,	[%rbp + cc_parse.readinitexpr2.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L7057
L7075:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L7077
    call      cc_lex.lex
    jmp       L7057
L7077:
    call      cc_lex.lex
    jmp       L7056
L7057:
    cmp       %rbx,	17
    jnz       L7079
    test      %r13,	%r13
    jnz       L7079
    mov       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	%r14
    imul      %r10,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rax + %r11*8],	%r10
L7079:
#cc_parse.readinitexpr2.donestruct:
L7073:
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rcx,	28
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.ulist]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+48],	%r14d
    mov       %eax,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rdi+52],	%eax
    jmp       L7043
L7044:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readinitexpr2.braces],	%rax
    cmp       %rbx,	17
    jnz       L7082
L7081:
#cc_parse.readinitexpr2.doarraystring:
L7053:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L7084
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	64
    jz        L7084
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	1
    jz        L7084
    lea       %rcx,	[%rip+L11266]
    call      cc_support.terror
L7084:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L7086
    cmp       %rax,	[%rip+cc_decls.trefwchar]
    jz        L7087
    jmp       L7088
L7086:
    jmp       L7085
L7087:
    jmp       L7085
L7088:
    lea       %rcx,	[%rip+L11267]
    call      cc_support.terror
L7085:
    mov       %eax,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %rax,	[%rax + %r10*8]
    mov       %r13,	%rax
    test      %rax,	%rax
    jnz       L7090
    movsxd    %rax,	dword ptr[%rdi+48]
    inc       %rax
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    jmp       L7089
L7090:
    movsxd    %rax,	dword ptr[%rdi+48]
    cmp       %rax,	%r13
    jle       L7092
    lea       %rcx,	[%rip+L11268]
    call      cc_support.terror
L7092:
L7089:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.braces]
    test      %rax,	%rax
    jz        L7094
    mov       %rcx,	18
    call      cc_lib.skipsymbol
L7094:
    mov       %rax,	%rdi
    jmp       L7042
L7082:
L7080:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L7043:
    mov       %rax,	%rdi
L7042:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.pushblock
cc_parse.pushblock:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_decls.blocklevel]
    cmp       %rax,	100
    jl        L7097
    lea       %rcx,	[%rip+L11269]
    call      cc_support.serror
L7097:
    mov       %rax,	[%rip+cc_decls.nextblockno]
    cmp       %rax,	2100
    jl        L7099
    lea       %rcx,	[%rip+L11270]
    call      cc_support.serror
L7099:
    inc       qword ptr[%rip+cc_decls.blocklevel]
    inc       qword ptr[%rip+cc_decls.nextblockno]
    mov       %rdi,	[%rip+cc_decls.currblockno]
    mov       %rbx,	[%rip+cc_decls.blocklevel]
    jmp       L7101
L7100:
    dec       %rbx
    lea       %rax,	[%rip+cc_decls.blockstack]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rdi,	%rax
L7101:
    test      %rbx,	%rbx
    jz        L7103
    lea       %rax,	[%rip+cc_decls.blockstack]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    lea       %r10,	[%rip+cc_decls.blockcounts]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    test      %r10,	%r10
    jz        L7100
L7103:
    mov       %eax,	%edi
    lea       %r10,	[%rip+cc_decls.blockowner]
    mov       %r11,	[%rip+cc_decls.nextblockno]
    mov       [%r10 + %r11*4],	%eax
    mov       %eax,	[%rip+cc_decls.nextblockno]
    lea       %r10,	[%rip+cc_decls.blockstack]
    mov       %r11,	[%rip+cc_decls.blocklevel]
    mov       [%r10 + %r11*4],	%eax
    mov       [%rip+cc_decls.currblockno],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.popblock
cc_parse.popblock:
#?>>
#?]]
#---------------
    dec       qword ptr[%rip+cc_decls.blocklevel]
    mov       %rax,	[%rip+cc_decls.blocklevel]
    lea       %r10,	[%rip+cc_decls.blockstack]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       [%rip+cc_decls.currblockno],	%r10
#---------------
    ret       
# End 
# Proc cc_parse.readcompoundstmt
cc_parse.readcompoundstmt:
#?>>
    .set cc_parse.readcompoundstmt.ulist, -8
    .set cc_parse.readcompoundstmt.ulistx, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rsi,	%rcx
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcompoundstmt.ulistx],	%rax
    mov       [%rbp + cc_parse.readcompoundstmt.ulist],	%rax
    call      cc_lex.lex
    call      cc_parse.pushblock
    test      %rsi,	%rsi
    jz        L7107
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       [%r10+4],	%eax
L7107:
    jmp       L7109
L7108:
    call      cc_parse.readstatement
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L7112
    jmp       L7109
L7112:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	7
    jnz       L7114
L7115:
    mov       %rbx,	[%rdi+8]
    mov       %rax,	[%rdi]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L7119
    mov       %rax,	[%rdi]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jz        L7119
    mov       %eax,	8
    mov       [%rdi+40],	%eax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    lea       %rcx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
L7119:
    mov       %rdi,	%rbx
    test      %rdi,	%rdi
    jnz       L7115
    jmp       L7113
L7114:
    lea       %rcx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
L7113:
L7109:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L7108
    call      cc_lex.lex
    call      cc_parse.popblock
    mov       %rcx,	6
    mov       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    call      cc_lib.createunit3
L7105:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readblock
cc_parse.readblock:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      cc_parse.readstatement
    jmp       L7120
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	71
    jnz       L7122
    test      %rdi,	%rdi
    jz        L7122
    call      cc_parse.readstatement
    jmp       L7120
L7122:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L7124
    lea       %rcx,	[%rip+L11271]
    call      cc_support.serror
L7124:
    xor       %ecx,	%ecx
    call      cc_parse.readcompoundstmt
L7120:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readstatement
cc_parse.readstatement:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	9
    cmp       %rax,	82
    jae       L7128
    lea       %r10,	[%rip+L7127]
    jmp       [%r10 + %rax*8]
    .data
L7127:
    .quad     L7151
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7135
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7128
    .quad     L7152
    .quad     L7128
    .quad     L7128
    .quad     L7168
    .quad     L7129
    .quad     L7128
    .quad     L7149
    .quad     L7150
    .quad     L7130
    .quad     L7131
    .quad     L7132
    .quad     L7133
    .quad     L7137
    .quad     L7142
    .quad     L7136
    .quad     L7134
    .quad     L7168
    .quad     L7168
    .quad     L7168
    .quad     L7168
    .quad     L7168
    .quad     L7168
    .quad     L7128
    .quad     L7168
    .text
L7129:
    call      cc_parse.readifstmt
    jmp       L7125
L7130:
    call      cc_parse.readforstmt
    jmp       L7125
L7131:
    call      cc_parse.readwhilestmt
    jmp       L7125
L7132:
    call      cc_parse.readdostmt
    jmp       L7125
L7133:
    call      cc_parse.readreturnstmt
    jmp       L7125
L7134:
    call      cc_parse.readswitchstmt
    jmp       L7125
L7135:
    xor       %ecx,	%ecx
    call      cc_parse.readcompoundstmt
    jmp       L7125
L7136:
    call      cc_parse.readgotostmt
    jmp       L7125
L7137:
    mov       %rax,	[%rip+cc_parse.loopindex]
    test      %rax,	%rax
    jz        L7139
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	[%rip+cc_parse.loopindex]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	76
    jnz       L7141
    mov       %rcx,	20
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L7140
L7141:
    mov       %rcx,	23
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
L7140:
    jmp       L7138
L7139:
    lea       %rcx,	[%rip+L11272]
    call      cc_support.serror
L7138:
    jmp       L7126
L7142:
    mov       %rsi,	[%rip+cc_parse.loopindex]
    jmp       L7144
L7143:
    dec       %rsi
L7144:
    test      %rsi,	%rsi
    jz        L7146
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	76
    jnz       L7143
L7146:
    test      %rsi,	%rsi
    jnz       L7148
    lea       %rcx,	[%rip+L11273]
    call      cc_support.serror
L7148:
    mov       %rcx,	21
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L7126
L7149:
    call      cc_parse.readcaselabel
    jmp       L7125
L7150:
    call      cc_lex.lex
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       %rcx,	19
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    jmp       L7125
L7151:
    call      cc_lex.lex
    xor       %eax,	%eax
    jmp       L7125
L7152:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jnz       L7154
    mov       %rcx,	17
    xor       %edx,	%edx
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      cc_lib.resolvename
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L7156
    movsxd    %rax,	dword ptr[%rbx+88]
    cmp       %rax,	-1
    jnz       L7158
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11274]
    call      cc_support.terror
L7158:
    jmp       L7155
L7156:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	14
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       [%rbx+102],	%ax
L7155:
    mov       %eax,	4294967295
    mov       [%rbx+88],	%eax
    mov       [%rdi],	%rbx
    call      cc_lex.lex
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jz        L7159
L7160:
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jnz       L7162
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	85
    jnz       L7161
L7162:
    jmp       L7159
L7161:
    call      cc_parse.readstatement
    mov       [%rdi+16],	%rax
L7159:
    mov       %rax,	%rdi
    jmp       L7125
L7154:
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ist_symptr],	%rax
    mov       %rcx,	[%rip+cc_decls.currproc]
    call      cc_parse.isusertype
    cmp       %rax,	20
    jnz       L7165
L7164:
    mov       %rax,	[%rip+cc_parse.ist_symptr]
    test      %rax,	%rax
    jz        L7167
    mov       %rax,	[%rip+cc_parse.ist_symptr]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       [%r10],	%rax
L7167:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L7153:
    jmp       L7126
L7168:
#cc_parse.readstatement.doreaddecl:
L7165:
    call      cc_parse.readlocaldecl
    jmp       L7125
L7128:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L7126:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
L7125:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readifstmt
cc_parse.readifstmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %r13,	%rax
    call      cc_parse.readcond
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rsi,	%rax
    xor       %r12,	%r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	72
    jnz       L7171
    call      cc_lex.lex
    mov       %rcx,	1
    call      cc_parse.readblock
    mov       %r12,	%rax
L7171:
    mov       %rcx,	12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      cc_lib.createunit3
    mov       %rdi,	%rax
    mov       [%rdi+44],	%r13d
    mov       %rcx,	%rbx
    call      cc_parse.iscondtrue
    test      %rax,	%rax
    jz        L7173
    test      %rsi,	%rsi
    jnz       L7175
    mov       %rcx,	6
    call      cc_lib.createunit0
    mov       %rsi,	%rax
L7175:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.deleteunit
    jmp       L7172
L7173:
    mov       %rcx,	%rbx
    call      cc_parse.iscondfalse
    test      %rax,	%rax
    jz        L7176
    test      %r12,	%r12
    jnz       L7178
    mov       %rcx,	6
    call      cc_lib.createunit0
    mov       %r12,	%rax
L7178:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      cc_parse.deleteunit
L7176:
L7172:
    mov       %rax,	%rdi
L7169:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.iscondtrue
cc_parse.iscondtrue:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	1
    jnz       L7180
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jz        L7180
    mov       %rax,	1
    jmp       L7181
L7180:
    xor       %eax,	%eax
L7181:
L7179:
#---------------
    ret       
# End 
# Proc cc_parse.iscondfalse
cc_parse.iscondfalse:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	1
    jnz       L7183
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L7183
    mov       %rax,	1
    jmp       L7184
L7183:
    xor       %eax,	%eax
L7184:
L7182:
#---------------
    ret       
# End 
# Proc cc_parse.deleteunit
cc_parse.deleteunit:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	[%rcx+8]
    mov       %rax,	%rdx
    push      %rcx
    mov       %r11,	8
L11275:
    mov       %r10,	[%rax]
    mov       [%rcx],	%r10
    add       %rcx,	8
    add       %rax,	8
    dec       %r11
    jnz       L11275
    pop       %rcx
    mov       [%rcx+8],	%rdi
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readforstmt
cc_parse.readforstmt:
#?>>
    .set cc_parse.readforstmt.ulist, -8
    .set cc_parse.readforstmt.ulistx, -16
    .set cc_parse.readforstmt.linkage, -24
    .set cc_parse.readforstmt.m, -32
    .set cc_parse.readforstmt.mbase, -40
    .set cc_parse.readforstmt.pm, -48
    .set cc_parse.readforstmt.d, -56
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
#---------------
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L7188
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L7190
    mov       %r14,	1
    call      cc_parse.pushblock
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readdeclspec
    mov       [%rbp + cc_parse.readforstmt.mbase],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readforstmt.ulistx],	%rax
    mov       [%rbp + cc_parse.readforstmt.ulist],	%rax
L7191:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L7193
    cmp       %rax,	25
    jz        L7193
    cmp       %rax,	13
    jnz       L7194
L7193:
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.d]
    mov       %r8,	[%rbp + cc_parse.readforstmt.mbase]
    lea       %r9,	[%rbp + cc_parse.readforstmt.pm]
    call      cc_parse.readtype
    mov       [%rbp + cc_parse.readforstmt.m],	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    test      %rax,	%rax
    jnz       L7196
    lea       %rcx,	[%rip+L11276]
    call      cc_support.serror
L7196:
    mov       %rax,	[%rbp + cc_parse.readforstmt.linkage]
    cmp       %rax,	5
    jz        L7199
    mov       %rax,	[%rbp + cc_parse.readforstmt.pm]
    test      %rax,	%rax
    jz        L7198
L7199:
    lea       %rcx,	[%rip+L11277]
    call      cc_support.serror
L7198:
    mov       %rcx,	[%rbp + cc_parse.readforstmt.d]
    mov       %rdx,	[%rbp + cc_parse.readforstmt.m]
    mov       %r8,	[%rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readframevar
    mov       [%rbp + cc_parse.readforstmt.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L7201
    mov       %rcx,	8
    call      cc_lib.createunit0
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    mov       [%r13],	%rax
    lea       %rcx,	[%rbp + cc_parse.readforstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.ulistx]
    mov       %r8,	%r13
    call      cc_lib.addlistunit
L7201:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L7204
L7203:
    call      cc_lex.lex
    jmp       L7202
L7204:
    jmp       L7192
L7202:
    jmp       L7191
L7194:
    lea       %rcx,	[%rip+L11278]
    call      cc_support.serror
    jmp       L7191
L7192:
    mov       %rcx,	6
    mov       %rdx,	[%rbp + cc_parse.readforstmt.ulist]
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_parse.readforstmt.ulistx]
    call      cc_lib.createunit3
    mov       %rdi,	%rax
    jmp       L7189
L7190:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L7189:
    jmp       L7187
L7188:
    mov       %rcx,	2
    call      cc_lib.createunit0
    mov       %rdi,	%rax
L7187:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L7206
    call      cc_parse.readexpression
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    jmp       L7205
L7206:
    mov       %rcx,	2
    call      cc_lib.createunit0
    mov       %rbx,	%rax
L7205:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L7208
    call      cc_parse.readexprstmt
    mov       %rsi,	%rax
    jmp       L7207
L7208:
    xor       %rsi,	%rsi
L7207:
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %r12,	%rax
    call      cc_parse.poploop
    test      %r14,	%r14
    jz        L7210
    call      cc_parse.popblock
L7210:
    mov       [%rdi+8],	%rbx
    mov       [%rbx+8],	%rsi
    mov       %rcx,	13
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    call      cc_lib.createunit2
L7186:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readwhilestmt
cc_parse.readwhilestmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rbx,	%rax
    call      cc_parse.poploop
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
L7211:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readdostmt
cc_parse.readdostmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rdi,	%rax
    call      cc_parse.poploop
    mov       %rcx,	76
    call      cc_lib.skipsymbol
    call      cc_parse.readcond
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rcx,	15
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
L7212:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readreturnstmt
cc_parse.readreturnstmt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L7215
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jnz       L7217
    lea       %rcx,	[%rip+L11279]
    call      cc_support.terror
L7217:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	9
    call      cc_lib.checksymbol
    jmp       L7214
L7215:
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jz        L7218
    lea       %rcx,	[%rip+L11280]
    call      cc_support.terror
L7218:
L7214:
    call      cc_lex.lex
    mov       %rcx,	9
    mov       %rdx,	%rdi
    call      cc_lib.createunit1
L7213:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readgotostmt
cc_parse.readgotostmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L7221
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	14
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rdi+102],	%ax
L7221:
    mov       %rcx,	16
    xor       %edx,	%edx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       [%rbx],	%rdi
    call      cc_lex.lex
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rax,	%rbx
L7219:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readswitchstmt
cc_parse.readswitchstmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rcx,	83
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rbx,	%rax
    mov       %rcx,	22
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_parse.casevaluestack]
    mov       %r10,	[%rip+cc_parse.loopindex]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rsi],	%rax
    call      cc_parse.poploop
    mov       %rax,	%rsi
L7222:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcaselabel
cc_parse.readcaselabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       %rbx,	%rax
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       %rcx,	18
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi],	%rbx
    mov       %rcx,	%rbx
    call      cc_parse.addcasevalue
    mov       %rax,	%rdi
L7223:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexprstmt
cc_parse.readexprstmt:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readexpression
L7224:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_parse.readcond
cc_parse.readcond:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
L7225:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.isusertype
cc_parse.isusertype:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L7228
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    jnz       L7230
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L7226
L7230:
    mov       [%rip+cc_parse.ist_symptr],	%rdi
L7228:
    mov       %rax,	20
L7226:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readlocaldecl
cc_parse.readlocaldecl:
#?>>
    .set cc_parse.readlocaldecl.linkage, -8
    .set cc_parse.readlocaldecl.wasdef, -16
    .set cc_parse.readlocaldecl.d, -24
    .set cc_parse.readlocaldecl.ulist, -32
    .set cc_parse.readlocaldecl.ulistx, -40
    .set cc_parse.readlocaldecl.pm, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readlocaldecl.ulistx],	%rax
    mov       [%rbp + cc_parse.readlocaldecl.ulist],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readdeclspec
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
L7232:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L7234
    cmp       %rax,	25
    jz        L7234
    cmp       %rax,	13
    jnz       L7235
L7234:
    inc       %rsi
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %r8,	%rbx
    lea       %r9,	[%rbp + cc_parse.readlocaldecl.pm]
    call      cc_parse.readtype
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.d]
    test      %rax,	%rax
    jnz       L7237
    lea       %rcx,	[%rip+L11281]
    call      cc_support.serror
L7237:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.linkage]
    cmp       %rax,	5
    jnz       L7239
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %r8,	%rdi
    call      cc_parse.createtypedef
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    jmp       L7238
L7239:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.pm]
    test      %rax,	%rax
    jz        L7240
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L7242
    lea       %rcx,	[%rip+L11282]
    call      cc_support.serror
L7242:
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readlocaldecl.wasdef]
    push      %rax
    mov       %rcx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readlocaldecl.linkage]
    mov       %r9,	[%rbp + cc_parse.readlocaldecl.pm]
    sub       %rsp,	32
    call      cc_parse.readfunction
    add       %rsp,	48
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    jmp       L7238
L7240:
    mov       %rcx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readframevar
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    mov       %rcx,	7
    call      cc_lib.createunit0
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.d]
    mov       [%r13],	%rax
    lea       %rcx,	[%rbp + cc_parse.readlocaldecl.ulist]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.ulistx]
    mov       %r8,	%r13
    call      cc_lib.addlistunit
L7238:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L7245
L7244:
    call      cc_lex.lex
    jmp       L7243
L7245:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7233
L7243:
    jmp       L7232
L7235:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	12
    jz        L7247
    cmp       %rax,	18
    jz        L7247
    cmp       %rax,	19
    jz        L7247
    cmp       %rax,	3
    jz        L7248
    jmp       L7249
L7247:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7233
L7248:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7233
L7249:
    mov       %rcx,	%rdi
    call      cc_lib.typename
    lea       %rcx,	[%rip+L11283]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7246:
    jmp       L7232
L7233:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.ulist]
L7231:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createtypedef
cc_parse.createtypedef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L7252
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    jz        L7254
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11284]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7254:
    movzx     %rax,	word ptr[%rdi+102]
    cmp       %rax,	%r12
    jz        L7256
    movzx     %rax,	word ptr[%rdi+102]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L7258
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11285]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7258:
L7256:
    mov       %rax,	%rdi
    jmp       L7250
L7252:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	5
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       [%rdi+102],	%r12w
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.tttypedef]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8],	%rax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    mov       %rax,	%rdi
L7250:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readparams
cc_parse.readparams:
#?>>
    .set cc_parse.readparams.owner, 64
    .set cc_parse.readparams.ulist, -8
    .set cc_parse.readparams.ulistx, -16
    .set cc_parse.readparams.pm, -24
    .set cc_parse.readparams.lastbasetype, -32
    .set cc_parse.readparams.d, -40
    .set cc_parse.readparams.names, -48
    .set cc_parse.readparams.nonames, -56
    .set cc_parse.readparams.reported, -64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.d],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.ulistx],	%rax
    mov       [%rbp + cc_parse.readparams.ulist],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %rsi,	%rax
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.lastbasetype],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.names],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.nonames],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.reported],	%rax
    jmp       L7261
L7260:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	21
    jnz       L7264
    mov       %r12,	1
    call      cc_lex.lex
    jmp       L7262
L7264:
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L7266
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readparams.lastbasetype]
    push      %rax
    lea       %rcx,	[%rbp + cc_parse.readparams.d]
    mov       %rdx,	1
    lea       %r8,	[%rbp + cc_parse.readparams.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_parse.readparams.pm]
    test      %rax,	%rax
    jz        L7268
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readparams.pm]
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
L7268:
    jmp       L7265
L7266:
    mov       %rax,	[%rbp + cc_parse.readparams.lastbasetype]
    test      %rax,	%rax
    jnz       L7270
    lea       %rcx,	[%rip+L11286]
    call      cc_support.serror
L7270:
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readparams.d]
    mov       %rdx,	1
    lea       %r8,	[%rbp + cc_parse.readparams.pm]
    mov       %r9,	[%rbp + cc_parse.readparams.lastbasetype]
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rbx,	%rax
L7265:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jz        L7272
    cmp       %rax,	14
    jz        L7273
    jmp       L7274
L7272:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
    jmp       L7271
L7273:
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
L7274:
L7271:
    mov       %rcx,	24
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readparams.pm],	%rax
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    mov       %r10,	[%rbp + cc_parse.readparams.pm]
    mov       [%r10],	%rax
    mov       %eax,	%ebx
    mov       %r10,	[%rbp + cc_parse.readparams.pm]
    mov       [%r10+16],	%eax
    inc       %rsi
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    test      %rax,	%rax
    jz        L7276
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.names],	%rax
    jmp       L7275
L7276:
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.nonames],	%rax
L7275:
    mov       %rax,	[%rbp + cc_parse.readparams.names]
    test      %rax,	%rax
    jz        L7278
    mov       %rax,	[%rbp + cc_parse.readparams.nonames]
    test      %rax,	%rax
    jz        L7278
    mov       %rax,	[%rbp + cc_parse.readparams.reported]
    test      %rax,	%rax
    jnz       L7278
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.reported],	%rax
L7278:
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    test      %rax,	%rax
    jz        L7280
    inc       %r14
    mov       %rdi,	[%rbp + cc_parse.readparams.ulist]
    jmp       L7282
L7281:
    mov       %rax,	[%rdi]
    cmp       %rax,	[%rbp + cc_parse.readparams.d]
    jnz       L7285
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    movzx     %rax,	byte ptr[%rax+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L11287]
    mov       %rdx,	%rax
    mov       %r8,	%r10
    call      cc_support.serror_ss
L7285:
    mov       %rdi,	[%rdi+8]
L7282:
    test      %rdi,	%rdi
    jnz       L7281
L7280:
    lea       %rcx,	[%rbp + cc_parse.readparams.ulist]
    lea       %rdx,	[%rbp + cc_parse.readparams.ulistx]
    mov       %r8,	[%rbp + cc_parse.readparams.pm]
    call      cc_lib.addlistparam
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L7287
    cmp       %rax,	21
    jz        L7288
    cmp       %rax,	14
    jz        L7288
    jmp       L7289
L7287:
    call      cc_lex.lex
    jmp       L7286
L7288:
    jmp       L7286
L7289:
    lea       %rcx,	[%rip+L11288]
    call      cc_support.serror
L7286:
L7261:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L7260
L7262:
    xor       %r13,	%r13
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    test      %r12,	%r12
    jz        L7291
    mov       %r13,	3
    jmp       L7290
L7291:
    test      %rsi,	%rsi
    jnz       L7292
    mov       %r13,	1
    jmp       L7290
L7292:
    cmp       %rsi,	1
    jnz       L7293
    test      %rbx,	%rbx
    jnz       L7293
    mov       %r13,	2
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+16],	%eax
L7293:
L7290:
    mov       %rax,	[%rbp + cc_parse.readparams.ulist]
    test      %rax,	%rax
    jnz       L7295
    mov       %rcx,	24
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readparams.ulist],	%rax
L7295:
    mov       %ax,	%si
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+20],	%ax
    mov       %ax,	%r13w
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+22],	%ax
    mov       %rax,	[%rbp + cc_parse.readparams.ulist]
L7259:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcasttype
cc_parse.readcasttype:
#?>>
    .set cc_parse.readcasttype.mbase, 88
    .set cc_parse.readcasttype.linkage, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L7298
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L7297
L7298:
    mov       %rax,	[%rip+cc_decls.stmodule]
L7297:
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcasttype.linkage],	%rax
    xor       %eax,	%eax
    mov       [%rbx],	%rax
    test      %r13,	%r13
    jnz       L7300
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_parse.readcasttype.linkage]
    call      cc_parse.readdeclspec
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readcasttype.mbase]
    test      %rax,	%rax
    jz        L7302
    mov       %rax,	%r13
    mov       %r10,	[%rbp + cc_parse.readcasttype.mbase]
    mov       [%r10],	%rax
L7302:
L7300:
    xor       %eax,	%eax
    mov       [%r12],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L7304
    cmp       %rax,	25
    jz        L7304
    cmp       %rax,	13
    jz        L7304
    cmp       %rax,	15
    jnz       L7305
L7304:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r13
    mov       %r9,	%r12
    call      cc_parse.readtype
    mov       %r13,	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L7307
    test      %rsi,	%rsi
    jnz       L7307
    mov       %rax,	[%rbx]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L11289]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7307:
L7305:
L7303:
    mov       %rax,	%r13
L7296:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readfunction
cc_parse.readfunction:
#?>>
    .set cc_parse.readfunction.pm, 88
    .set cc_parse.readfunction.wasdef, 96
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rbx,	[%rip+cc_decls.stmodule]
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readfunction.wasdef]
    mov       [%r10],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L7310
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jz        L7312
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L11290]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7312:
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rsi,	%rax
    cmp       %rsi,	3
    jnz       L7314
    test      %r14,	%r14
    jnz       L7314
    mov       %rsi,	4
    jmp       L7313
L7314:
    cmp       %r14,	1
    jnz       L7315
    mov       %rsi,	2
L7315:
L7313:
    jmp       L7309
L7310:
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	6
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L7317
    cmp       %rax,	4
    jz        L7318
    jmp       L7319
L7317:
    mov       %rsi,	2
    jmp       L7316
L7318:
    mov       %rsi,	3
    jmp       L7316
L7319:
    mov       %rsi,	4
L7316:
L7309:
    mov       %rax,	[%rbp + cc_parse.readfunction.pm]
    mov       [%r12+80],	%rax
    mov       [%r12+110],	%sil
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L7321
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_parse.readfunction.wasdef]
    mov       [%r10],	%rax
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L7323
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L11291]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7323:
    cmp       %rsi,	3
    jnz       L7325
    mov       %al,	4
    mov       [%r12+110],	%al
L7325:
    mov       %rcx,	%r12
    call      cc_parse.readfunctionbody
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jnz       L7327
    lea       %rcx,	[%rip+L11292]
    call      cc_support.serror
L7327:
L7321:
    mov       %rax,	%r12
L7308:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readfunctionbody
cc_parse.readfunctionbody:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       [%rip+cc_decls.currproc],	%r14
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currblockno],	%rax
    mov       [%rip+cc_decls.nextblockno],	%rax
    xor       %r12,	%r12
    mov       %rax,	[%r14+80]
    mov       %rsi,	%rax
    movsx     %rax,	word ptr[%rsi+20]
    mov       %r13,	%rax
    cmp       %r13,	0
    jle       L7331
L7329:
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L7332
L7333:
    mov       %rax,	[%rsi]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	9
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rax,	[%rdi]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jnz       L7335
    mov       %al,	1
    mov       [%rdi+122],	%al
L7335:
    mov       %ax,	1
    mov       [%rdi+96],	%ax
    mov       %eax,	[%rsi+16]
    mov       [%rdi+102],	%ax
L7332:
    mov       %rsi,	[%rsi+8]
    mov       %r12,	1
    dec       %r13
    jnz       L7329
L7331:
    mov       %rcx,	%r12
    call      cc_parse.readcompoundstmt
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    mov       %r10,	[%rip+cc_decls.currproc]
    mov       [%r10+72],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currproc],	%rax
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createnegop
cc_parse.createnegop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L7338
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L7340
    cmp       %rax,	4
    jz        L7340
    cmp       %rax,	9
    jz        L7340
    cmp       %rax,	8
    jz        L7341
    cmp       %rax,	11
    jz        L7342
    jmp       L7343
L7340:
    mov       %rax,	[%rsi]
    neg       %rax
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L7336
L7341:
    mov       %rax,	[%rsi]
    neg       %rax
    mov       %r10,	4294967295
    and       %rax,	%r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L7336
L7342:
    movq      %XMM4,	[%rsi]
    xorpd     %XMM4,	[%rip+L10538]
    movq      [%rsi],	%XMM4
    mov       %rax,	%rsi
    jmp       L7336
L7343:
L7339:
L7338:
#cc_parse.createnegop.retry:
L7344:
    cmp       %rbx,	1
    jl        L7346
    cmp       %rbx,	11
    jg        L7346
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	58
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L7345
L7346:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7347
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    jmp       L7344
L7347:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11293]
    call      cc_support.terror
L7345:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L7336:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createabsop
cc_parse.createabsop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L7350
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L7352
    cmp       %rax,	4
    jnz       L7353
L7352:
    mov       %rax,	[%rsi]
    cmp       %rax,	0
    jge       L11294
    neg       %rax
L11294:
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L7348
L7353:
L7351:
L7350:
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L7355
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	59
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L7354
L7355:
    lea       %rcx,	[%rip+L11295]
    call      cc_support.terror
L7354:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L7348:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createinotop
cc_parse.createinotop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L7358
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L7360
    cmp       %rax,	4
    jz        L7360
    cmp       %rax,	8
    jz        L7360
    cmp       %rax,	9
    jnz       L7361
L7360:
    mov       %rax,	[%rsi]
    not       %rax
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L7356
L7361:
L7359:
L7358:
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L7363
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	60
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L7362
L7363:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11296]
    call      cc_support.terror
L7362:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L7356:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createptrop
cc_parse.createptrop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L7366
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L11297]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L11298]
    call      cc_support.terror
L7366:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	55
    jnz       L7369
L7368:
    mov       %rdi,	[%r12+16]
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rdi+52],	%r10d
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %rax,	%rdi
    jmp       L7364
L7369:
L7367:
    mov       %rcx,	52
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
    mov       %rcx,	%rdi
    call      cc_parse.arraytopointer
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %rax,	%rdi
L7364:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createincrop
cc_parse.createincrop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	1
    call      cc_parse.checklvalue
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L7373
    cmp       %rbx,	5
    jnz       L7372
L7373:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jnz       L7372
    lea       %rcx,	[%rip+L11299]
    call      cc_support.terror
L7372:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %eax,	[%r12+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L7370:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createaddrofop
cc_parse.createaddrofop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    xor       %rsi,	%rsi
#cc_parse.createaddrofop.restartx:
L7375:
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    mov       %ax,	[%r12+56]
    test      %ax,	%ax
    jz        L7377
    movsx     %rax,	word ptr[%r12+56]
    mov       %rbx,	%rax
L7377:
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	3
    jz        L7379
    cmp       %rax,	55
    jz        L7380
    cmp       %rax,	49
    jz        L7381
    cmp       %rax,	53
    jz        L7382
    cmp       %rax,	4
    jz        L7383
    cmp       %rax,	5
    jz        L7384
    jmp       L7385
L7379:
    mov       %rax,	[%r12]
    lea       %rax,	[%rax+108]
    or        byte ptr[%rax],	1
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L7387
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
L7387:
    jmp       L7378
L7380:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L7389
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    test      %eax,	%eax
    jz        L7389
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    mov       [%r12+48],	%eax
    mov       %rax,	%r12
    jmp       L7374
L7389:
    jmp       L7378
L7381:
    mov       %rdi,	[%r12+16]
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	52
    jnz       L7391
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7391
    movsxd    %rax,	dword ptr[%r12]
    mov       %r10,	[%rdi+16]
    mov       %r10,	[%r10]
    add       %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %r12,	%rax
    mov       %rax,	%r12
    jmp       L7374
L7391:
    jmp       L7392
L7382:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L7394
    movsxd    %rax,	dword ptr[%r12+48]
    movsxd    %r10,	dword ptr[%r12+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_lib.createarraymode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       %rax,	%r12
    jmp       L7374
L7394:
    jmp       L7378
L7383:
    mov       %r12,	[%r12+16]
    jmp       L7375
L7384:
    mov       %rax,	%r12
    jmp       L7374
L7385:
#cc_parse.createaddrofop.cad1:
L7392:
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_parse.checklvalue
L7378:
    mov       %rcx,	55
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %r12,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       [%r12+48],	%esi
    mov       %rax,	%r12
L7374:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createaddop
cc_parse.createaddop:
#?>>
    .set cc_parse.createaddop.x, 56
    .set cc_parse.createaddop.y, 64
    .set cc_parse.createaddop.elemsize, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createaddop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	39
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L7397
    mov       %rcx,	[%rbp + cc_parse.createaddop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    jmp       L7396
L7397:
    cmp       %rbx,	13
    jnz       L7398
#cc_parse.createaddop.doaddref:
L7399:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_parse.createaddop.elemsize],	%r10
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7401
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7401
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_parse.createaddop.elemsize]
    imul      %rax,	%r10
    mov       %r10,	[%rbp + cc_parse.createaddop.x]
    add       [%r10],	%rax
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    jmp       L7395
L7401:
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       %rcx,	53
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %eax,	[%rbp + cc_parse.createaddop.elemsize]
    mov       [%rdi],	%eax
    mov       %rax,	%rdi
    jmp       L7395
L7398:
    cmp       %rsi,	13
    jnz       L7402
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    mov       %r10,	[%rbp + cc_parse.createaddop.y]
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       [%rbp + cc_parse.createaddop.x],	%r10
    jmp       L7399
    lea       %rcx,	[%rip+L11300]
    call      cc_support.terror
L7402:
L7396:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7404
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7406
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_add
    jmp       L7395
L7406:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    mov       %r10,	[%rbp + cc_parse.createaddop.y]
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       [%rbp + cc_parse.createaddop.x],	%r10
L7405:
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L7408
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    jmp       L7395
L7408:
L7404:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L7395:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createsubop
cc_parse.createsubop:
#?>>
    .set cc_parse.createsubop.x, 56
    .set cc_parse.createsubop.y, 64
    .set cc_parse.createsubop.elemsize, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createsubop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	40
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L7411
    mov       %rcx,	[%rbp + cc_parse.createsubop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    jmp       L7410
L7411:
    cmp       %rbx,	13
    jnz       L7412
    cmp       %rsi,	13
    jz        L7414
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_parse.createsubop.elemsize],	%r10
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    mov       %rcx,	54
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %eax,	[%rbp + cc_parse.createsubop.elemsize]
    mov       [%rdi],	%eax
    mov       %rax,	%rdi
    jmp       L7409
L7414:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7416
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7416
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    movsxd    %r10,	dword ptr[%r10+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %r11*8]
    cqo       
    idiv      %r10
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    sub       [%r10],	%rax
    mov       %eax,	3
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    mov       [%r10+52],	%eax
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    jmp       L7409
L7416:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	4
    mov       [%rdi+52],	%eax
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      cc_parse.divunit
    mov       %rdi,	%rax
    mov       %eax,	4
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
    jmp       L7409
L7415:
L7413:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	%r10
    call      cc_parse.mulunit
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    jmp       L7410
L7412:
    lea       %rcx,	[%rip+L11300]
    call      cc_support.terror
L7410:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7418
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7418
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_sub
    jmp       L7409
L7418:
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7420
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L7420
L7420:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L7409:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createmulop
cc_parse.createmulop:
#?>>
    .set cc_parse.createmulop.x, 56
    .set cc_parse.createmulop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createmulop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createmulop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	41
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L7423
    mov       %rcx,	[%rbp + cc_parse.createmulop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createmulop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createmulop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createmulop.y],	%rax
    jmp       L7422
L7423:
    lea       %rcx,	[%rip+L11301]
    call      cc_support.terror
L7422:
    mov       %rax,	[%rbp + cc_parse.createmulop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7425
    mov       %rax,	[%rbp + cc_parse.createmulop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7427
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createmulop.x]
    mov       %r8,	[%rbp + cc_parse.createmulop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_mul
    jmp       L7421
L7427:
    mov       %rax,	[%rbp + cc_parse.createmulop.x]
    mov       %r10,	[%rbp + cc_parse.createmulop.y]
    mov       [%rbp + cc_parse.createmulop.y],	%rax
    mov       [%rbp + cc_parse.createmulop.x],	%r10
L7426:
L7425:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createmulop.x]
    mov       %r8,	[%rbp + cc_parse.createmulop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L7421:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createdivop
cc_parse.createdivop:
#?>>
    .set cc_parse.createdivop.x, 56
    .set cc_parse.createdivop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createdivop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createdivop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	42
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L7430
    mov       %rcx,	[%rbp + cc_parse.createdivop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createdivop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createdivop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createdivop.y],	%rax
    jmp       L7429
L7430:
    lea       %rcx,	[%rip+L11302]
    call      cc_support.terror
L7429:
    mov       %rax,	[%rbp + cc_parse.createdivop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7432
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7432
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createdivop.x]
    mov       %r8,	[%rbp + cc_parse.createdivop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_div
    jmp       L7428
L7432:
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7433
    cmp       %r12,	11
    jnz       L7433
    mov       %r13,	41
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movq      %XMM4,	[%rax]
    movq      %XMM5,	[%rip+L11303]
    divsd     %XMM5,	%XMM4
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movq      [%rax],	%XMM5
L7433:
L7431:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createdivop.x]
    mov       %r8,	[%rbp + cc_parse.createdivop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L7428:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createremop
cc_parse.createremop:
#?>>
    .set cc_parse.createremop.x, 56
    .set cc_parse.createremop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_parse.createremop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rax,	[%rbp + cc_parse.createremop.y]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	43
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L7436
    cmp       %r12,	11
    jz        L7439
    cmp       %r12,	10
    jnz       L7438
L7439:
    mov       %r12,	3
L7438:
    mov       %rcx,	[%rbp + cc_parse.createremop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createremop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createremop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createremop.y],	%rax
    jmp       L7435
L7436:
    lea       %rcx,	[%rip+L11304]
    call      cc_support.terror
L7435:
    mov       %rax,	[%rbp + cc_parse.createremop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7441
    mov       %rax,	[%rbp + cc_parse.createremop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7441
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createremop.x]
    mov       %r8,	[%rbp + cc_parse.createremop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_rem
    jmp       L7434
L7441:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createremop.x]
    mov       %r8,	[%rbp + cc_parse.createremop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L7434:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.insertunit
cc_parse.insertunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    push      %rdi
    mov       %r11,	8
L11305:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L11305
    pop       %rdi
    mov       [%rbx+40],	%esi
    mov       [%rbx+16],	%rdi
    xor       %eax,	%eax
    mov       [%rbx+32],	%rax
    mov       [%rbx+24],	%rax
    mov       %eax,	[%rdi+44]
    mov       [%rbx+44],	%eax
    mov       %rax,	[%rdi+8]
    mov       [%rbx+8],	%rax
    xor       %eax,	%eax
    mov       [%rbx+56],	%ax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_add
cc_parse.eval_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L7445
    cmp       %rax,	4
    jz        L7445
    cmp       %rax,	8
    jz        L7445
    cmp       %rax,	9
    jz        L7445
    cmp       %rax,	11
    jz        L7446
    jmp       L7447
L7445:
    mov       %rax,	[%r12]
    mov       %r10,	%rsi
    add       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L7443
L7446:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    addsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L7443
L7447:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L7449
    mov       %rax,	[%r12]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r13
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       %r10,	%rsi
    add       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L7443
L7449:
L7444:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L7443:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_sub
cc_parse.eval_sub:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L7452
    cmp       %rax,	4
    jz        L7452
    cmp       %rax,	8
    jz        L7452
    cmp       %rax,	9
    jz        L7452
    cmp       %rax,	11
    jz        L7453
    jmp       L7454
L7452:
    mov       %rax,	[%r12]
    mov       %r10,	%rsi
    sub       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L7450
L7453:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    subsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L7450
L7454:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L7456
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jnz       L7458
    lea       %rcx,	[%rip+L11306]
    call      cc_support.terror
L7458:
    mov       %rax,	%rsi
    jmp       L7450
L7456:
L7451:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L7450:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_mul
cc_parse.eval_mul:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L7461
    cmp       %rax,	4
    jz        L7461
    cmp       %rax,	2
    jz        L7461
    cmp       %rax,	1
    jz        L7461
    cmp       %rax,	8
    jz        L7462
    cmp       %rax,	9
    jz        L7462
    cmp       %rax,	7
    jz        L7462
    cmp       %rax,	6
    jz        L7462
    cmp       %rax,	11
    jz        L7463
    jmp       L7464
L7461:
    mov       %rax,	[%r12]
    mov       %r11,	%rsi
    mov       %r10,	[%r11]
    imul      %r10,	%rax
    mov       [%r11],	%r10
    mov       %rax,	%rsi
    jmp       L7459
L7462:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    imul      %rax,	%r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L7459
L7463:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    mulsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L7459
L7464:
L7460:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L7459:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_div
cc_parse.eval_div:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L7467
    cmp       %rax,	4
    jz        L7467
    cmp       %rax,	8
    jz        L7468
    cmp       %rax,	9
    jz        L7468
    cmp       %rax,	11
    jz        L7469
    jmp       L7470
L7467:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L7472
    lea       %rcx,	[%rip+L11307]
    call      cc_support.serror
L7472:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    cqo       
    idiv      %r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L7465
L7468:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L7474
    lea       %rcx,	[%rip+L11307]
    call      cc_support.serror
L7474:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    xor       %edx,	%edx
    div       %r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L7465
L7469:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    divsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L7465
L7470:
L7466:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L7465:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_rem
cc_parse.eval_rem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L7477
    cmp       %rax,	4
    jnz       L7478
L7477:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L7480
    lea       %rcx,	[%rip+L11308]
    call      cc_support.serror
L7480:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L7475
L7478:
L7476:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L7475:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_convert
cc_parse.eval_convert:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    cmp       %r8,	1
    jnz       L7483
#cc_parse.eval_convert.dosoft:
L7484:
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L7481
L7483:
    movsxd    %rax,	dword ptr[%rcx+52]
    mov       %rdi,	%rax
    cmp       %rdi,	%rdx
    jnz       L7486
    mov       %rax,	1
    jmp       L7481
L7486:
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L7488
    cmp       %rax,	2
    jz        L7488
    cmp       %rax,	1
    jz        L7488
    cmp       %rax,	4
    jz        L7488
    cmp       %rax,	8
    jz        L7489
    cmp       %rax,	6
    jz        L7489
    cmp       %rax,	7
    jz        L7489
    cmp       %rax,	9
    jz        L7489
    cmp       %rax,	11
    jz        L7490
    jmp       L7491
L7488:
    mov       %rax,	%rdx
    cmp       %rax,	11
    jz        L7493
    cmp       %rax,	10
    jz        L7493
    cmp       %rax,	9
    jz        L7494
    cmp       %rax,	4
    jz        L7494
    cmp       %rax,	8
    jz        L7494
    cmp       %rax,	3
    jz        L7494
    cmp       %rax,	2
    jz        L7494
    cmp       %rax,	1
    jz        L7494
    cmp       %rax,	6
    jz        L7494
    cmp       %rax,	7
    jz        L7494
    jmp       L7495
L7493:
    mov       %rax,	[%rcx]
    cvtsi2sd  %XMM4,	%rax
    movq      [%rcx],	%XMM4
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L7481
L7494:
#cc_parse.eval_convert.dotrunc:
L7496:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	1
    jz        L7498
    cmp       %rax,	2
    jz        L7499
    cmp       %rax,	4
    jz        L7500
    jmp       L7501
L7498:
    mov       %rax,	%rcx
    mov       %r10,	255
    and       [%rax],	%r10
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7503
    mov       %rax,	[%rcx]
    movsx     %rax,	%al
    mov       [%rcx],	%rax
L7503:
    jmp       L7497
L7499:
    mov       %rax,	%rcx
    mov       %r10,	65535
    and       [%rax],	%r10
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7505
    mov       %rax,	[%rcx]
    movsx     %rax,	%ax
    mov       [%rcx],	%rax
L7505:
    jmp       L7497
L7500:
    mov       %rax,	[%rcx]
    mov       %r10,	4294967295
    and       %rax,	%r10
    mov       [%rcx],	%rax
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7507
    mov       %rax,	[%rcx]
    movsxd    %rax,	%eax
    mov       [%rcx],	%rax
L7507:
L7501:
L7497:
    jmp       L7484
L7495:
L7492:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7509
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L7481
L7509:
    jmp       L7487
L7489:
    mov       %rax,	%rdx
    cmp       %rax,	11
    jz        L7511
    cmp       %rax,	10
    jz        L7511
    cmp       %rax,	9
    jz        L7512
    cmp       %rax,	4
    jz        L7512
    cmp       %rax,	3
    jz        L7512
    cmp       %rax,	8
    jz        L7512
    cmp       %rax,	9
    jz        L7512
    cmp       %rax,	7
    jz        L7512
    cmp       %rax,	1
    jz        L7512
    cmp       %rax,	6
    jz        L7512
    cmp       %rax,	2
    jz        L7512
    jmp       L7513
L7511:
    xor       %eax,	%eax
    jmp       L7481
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L7481
L7512:
    jmp       L7496
L7513:
L7510:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7515
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L7481
L7515:
    jmp       L7487
L7490:
    mov       %rax,	%rdx
    cmp       %rax,	3
    jz        L7517
    cmp       %rax,	4
    jz        L7517
    cmp       %rax,	8
    jz        L7518
    cmp       %rax,	9
    jz        L7518
    cmp       %rax,	10
    jz        L7519
    jmp       L7520
L7517:
    movq      %XMM4,	[%rcx]
    cvttsd2si %rax,	%XMM4
    mov       [%rcx],	%rax
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L7481
L7518:
    movq      %XMM4,	[%rcx]
    cvttsd2si %rax,	%XMM4
    mov       [%rcx],	%rax
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L7481
L7519:
    mov       %eax,	10
    mov       [%rcx+52],	%eax
    mov       %rax,	1
    jmp       L7481
L7520:
L7516:
    jmp       L7487
L7491:
    movsxd    %rax,	dword ptr[%rcx+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L7522
    mov       %al,	[%rcx+61]
    test      %al,	%al
    jnz       L7524
    mov       %rax,	%rdx
    cmp       %rax,	3
    jz        L7526
    cmp       %rax,	4
    jz        L7526
    cmp       %rax,	8
    jz        L7526
    cmp       %rax,	9
    jnz       L7527
L7526:
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L7481
L7527:
L7525:
L7524:
L7522:
L7487:
    xor       %eax,	%eax
L7481:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercecond
cc_parse.coercecond:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    cmp       %rax,	3
    jz        L7528
L7530:
#cc_parse.coercecond.retry:
L7531:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	10
    jz        L7533
    cmp       %rax,	11
    jz        L7533
    cmp       %rax,	13
    jnz       L7534
L7533:
    jmp       L7535
L7534:
    mov       %rcx,	%rdi
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L7537
#cc_parse.coercecond.doint:
L7535:
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L7539
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L7539
    mov       %rax,	1
    mov       [%rbx],	%rax
    jmp       L7538
L7539:
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L7540
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L7540
    xor       %eax,	%eax
    mov       [%rbx],	%rax
    jmp       L7538
L7540:
    mov       %rcx,	%rbx
    mov       %rdx,	27
    call      cc_parse.insertunit
L7538:
    jmp       L7536
L7537:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7541
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    jmp       L7531
L7541:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    lea       %rcx,	[%rip+L11309]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7536:
L7532:
    mov       %eax,	3
    mov       [%rbx+52],	%eax
L7528:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercebasetype
cc_parse.coercebasetype:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jl        L7544
    cmp       %rdi,	2
    jg        L7544
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L7543
L7544:
    cmp       %rdi,	5
    jl        L7545
    cmp       %rdi,	7
    jg        L7545
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      cc_parse.coercemode
    mov       %rbx,	%rax
L7545:
L7543:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.checklvalue
cc_parse.checklvalue:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	3
    jz        L7548
    cmp       %rax,	52
    jz        L7549
    cmp       %rax,	5
    jz        L7550
    cmp       %rax,	4
    jz        L7551
    cmp       %rax,	49
    jz        L7552
    cmp       %rax,	1
    jz        L7553
    cmp       %rax,	56
    jz        L7554
    jmp       L7555
L7548:
    jmp       L7547
L7549:
    jmp       L7547
L7550:
    test      %rbx,	%rbx
    jz        L7557
    jmp       L7558
L7557:
    jmp       L7547
L7551:
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jz        L7560
    cmp       %rax,	52
    jz        L7560
    cmp       %rax,	49
    jnz       L7561
L7560:
    mov       %rax,	[%rdi+16]
    push      %rdi
    mov       %r11,	8
L11310:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L11310
    pop       %rdi
    jmp       L7559
L7561:
    lea       %rcx,	[%rip+L11311]
    call      cc_support.terror
L7559:
    jmp       L7547
L7552:
    jmp       L7547
L7553:
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L7563
    jmp       L7558
L7563:
    jmp       L7547
L7554:
    test      %rbx,	%rbx
    jz        L7565
    jmp       L7558
L7565:
    jmp       L7547
L7555:
#cc_parse.checklvalue.notlv:
L7558:
    xor       %ecx,	%ecx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L11312]
    call      cc_show.printunit
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L11313]
    mov       %rdx,	%r10
    call      cc_support.terror_s
L7547:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createcall
cc_parse.createcall:
#?>>
    .set cc_parse.createcall.p, 64
    .set cc_parse.createcall.q, 72
    .set cc_parse.createcall.aparams, -8
    .set cc_parse.createcall.retmode, -16
    .set cc_parse.createcall.mproc, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	52
    jz        L7568
    cmp       %rax,	3
    jz        L7569
    cmp       %rax,	5
    jz        L7569
    cmp       %rax,	49
    jz        L7570
    cmp       %rax,	30
    jz        L7570
    cmp       %rax,	31
    jz        L7570
    cmp       %rax,	56
    jz        L7570
    cmp       %rax,	29
    jz        L7570
    jmp       L7571
L7568:
#cc_parse.createcall.doptr:
L7572:
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       [%rbp + cc_parse.createcall.mproc],	%rax
    jmp       L7574
L7573:
    mov       %rcx,	52
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_parse.createcall.mproc],	%rax
    mov       %eax,	[%rbp + cc_parse.createcall.mproc]
    mov       [%rdi+52],	%eax
    mov       [%rbp + cc_parse.createcall.p],	%rdi
L7574:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jz        L7573
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jz        L7577
    mov       %rcx,	[%rbp + cc_parse.createcall.mproc]
    call      cc_lib.typename
    lea       %rcx,	[%rip+L11314]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7577:
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    mov       %r12,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_parse.createcall.retmode],	%rax
    jmp       L7567
L7569:
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    mov       %rsi,	[%rax]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L7579
    mov       %r12,	[%rsi+80]
    movzx     %rax,	word ptr[%rsi+102]
    mov       [%rbp + cc_parse.createcall.retmode],	%rax
    jmp       L7578
L7579:
    jmp       L7572
L7578:
    jmp       L7567
L7570:
    mov       %rcx,	52
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rdi+52],	%r10d
    mov       [%rbp + cc_parse.createcall.p],	%rdi
    jmp       L7572
L7571:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11315]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L11316]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L11317]
    call      cc_support.serror
L7567:
    movsx     %rax,	word ptr[%r12+20]
    mov       %r14,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.createcall.aparams],	%rax
    mov       %rbx,	[%rbp + cc_parse.createcall.q]
    jmp       L7581
L7580:
    inc       qword ptr[%rbp + cc_parse.createcall.aparams]
    mov       %rbx,	[%rbx+8]
L7581:
    test      %rbx,	%rbx
    jnz       L7580
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	%r14
    jge       L7584
    lea       %rcx,	[%rip+L11318]
    call      cc_support.terror
    jmp       L7583
L7584:
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	%r14
    jle       L7585
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	3
    jz        L7585
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	1
    jz        L7585
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	1
    jz        L7587
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_parse.createcall.aparams]
    call      msys.m$print_i64_nf
    mov       %rcx,	%r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11319]
    call      cc_support.terror
L7587:
L7585:
L7583:
    mov       %rbx,	[%rbp + cc_parse.createcall.q]
    mov       %r13,	1
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	1
    jl        L7590
L7588:
    cmp       %r13,	%r14
    jg        L7592
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_parse.coercemode_inplace
    mov       %r12,	[%r12+8]
    jmp       L7591
L7592:
    movsxd    %rax,	dword ptr[%rbx+52]
    test      %rax,	%rax
    jnz       L7594
    lea       %rcx,	[%rip+L11320]
    call      cc_support.terror
L7594:
    mov       %rcx,	%rbx
    call      cc_parse.coercebasetype
L7591:
    mov       %rbx,	[%rbx+8]
    inc       %r13
    cmp       %r13,	[%rbp + cc_parse.createcall.aparams]
    jle       L7588
L7590:
    mov       %rcx,	30
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    mov       %r8,	[%rbp + cc_parse.createcall.q]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.createcall.retmode]
    mov       [%rdi+52],	%eax
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %eax,	[%rbp + cc_parse.createcall.aparams]
    mov       [%rdi+48],	%eax
    mov       %rax,	%rdi
L7566:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.arraytopointer
cc_parse.arraytopointer:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7597
    mov       %rcx,	%r12
    call      cc_lib.createrefmode
    mov       %r13,	%rax
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	52
    jz        L7599
    cmp       %rax,	49
    jz        L7600
    jmp       L7601
L7599:
    mov       %r14,	[%r14+16]
    jmp       L7598
L7600:
    movsxd    %rax,	dword ptr[%r14]
    mov       %rbx,	%rax
    mov       %eax,	53
    mov       [%r14+40],	%eax
    mov       %eax,	1
    mov       [%r14],	%eax
    mov       %rax,	[%r14+16]
    mov       %rcx,	55
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       [%r14+16],	%rdi
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       [%r14+24],	%rax
    jmp       L7598
L7601:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11321]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L11322]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L11323]
    call      cc_support.terror
L7598:
    mov       [%r14+52],	%r13d
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       [%r14+48],	%eax
L7597:
    mov       %rax,	%r14
L7595:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createindexop
cc_parse.createindexop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.createaddop
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.createptrop
L7602:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readstructdecl
cc_parse.readstructdecl:
#?>>
    .set cc_parse.readstructdecl.owner, 64
    .set cc_parse.readstructdecl.d, -8
    .set cc_parse.readstructdecl.ulist, -16
    .set cc_parse.readstructdecl.ulistx, -24
    .set cc_parse.readstructdecl.linkage, -32
    .set cc_parse.readstructdecl.offset, -40
    .set cc_parse.readstructdecl.recsize, -48
    .set cc_parse.readstructdecl.maxsize, -56
    .set cc_parse.readstructdecl.maxalignment, -64
    .set cc_parse.readstructdecl.alignment, -72
    .set cc_parse.readstructdecl.size, -80
    .set cc_parse.readstructdecl.pm, -88
    .set cc_parse.readstructdecl.fieldlist, -96
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	128
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	84
    setz      %al
    movzx     %eax,	%al
    mov       %r12,	%rax
    call      cc_lex.lex
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L7605
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L7604
L7605:
    mov       %rax,	[%rip+cc_decls.stmodule]
L7604:
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L7607
    call      cc_lib.nextautotype
    mov       %rcx,	%rax
    call      cc_lex.addnamestr
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    jmp       L7606
L7607:
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L7609
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L7611
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	13
    jz        L7613
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11324]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7613:
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L7603
L7611:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	13
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L7615
    mov       %rax,	19
    jmp       L7614
L7615:
    mov       %rax,	18
L7614:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_lib.createstructmode
    mov       [%rdi+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L7603
L7609:
L7606:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L7617
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	13
    jz        L7619
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11324]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7619:
    mov       %rax,	[%rdi+16]
    test      %rax,	%rax
    jz        L7621
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11325]
    call      msys.m$print_str_nf
    mov       %eax,	[%rdi+92]
    and       %rax,	1677215
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %eax,	[%rdi+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %eax,	[%rdi+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11326]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7621:
    jmp       L7616
L7617:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	13
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L7623
    mov       %rax,	19
    jmp       L7622
L7623:
    mov       %rax,	18
L7622:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_lib.createstructmode
    mov       [%rdi+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L7616:
    call      cc_lex.lex
    mov       %rbx,	%rdi
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.ulistx],	%rax
    mov       [%rbp + cc_parse.readstructdecl.ulist],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.recsize],	%rax
    mov       [%rbp + cc_parse.readstructdecl.maxsize],	%rax
    mov       [%rbp + cc_parse.readstructdecl.offset],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_parse.readstructdecl.maxalignment],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.fieldlist],	%rax
    mov       %r14,	-1
    jmp       L7625
L7624:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.linkage]
    call      cc_parse.readdeclspec
    mov       %r13,	%rax
L7627:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L7629
    cmp       %rax,	25
    jz        L7629
    cmp       %rax,	13
    jz        L7629
    cmp       %rax,	10
    jz        L7630
    jmp       L7631
L7629:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	%r13
    lea       %r9,	[%rbp + cc_parse.readstructdecl.pm]
    call      cc_parse.readtype
    mov       %r14,	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    test      %rax,	%rax
    jnz       L7633
    lea       %rcx,	[%rip+L11327]
    call      cc_support.serror
L7633:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.linkage]
    cmp       %rax,	5
    jz        L7636
    mov       %rax,	[%rbp + cc_parse.readstructdecl.pm]
    test      %rax,	%rax
    jz        L7635
L7636:
    lea       %rcx,	[%rip+L11328]
    call      cc_support.serror
L7635:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	4
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L7638
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11329]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7638:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.linkage]
    test      %rax,	%rax
    jz        L7640
    lea       %rcx,	[%rip+L11330]
    call      cc_support.serror
L7640:
#cc_parse.readstructdecl.addanonfield:
L7641:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	10
    call      cc_lib.createdupldef
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    mov       %ax,	%r14w
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+102],	%ax
    lea       %rcx,	[%rbp + cc_parse.readstructdecl.ulist]
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.ulistx]
    mov       %r8,	[%rbp + cc_parse.readstructdecl.d]
    call      cc_lib.addlistdef
    mov       %rax,	[%rbp + cc_parse.readstructdecl.ulist]
    mov       [%rbx+16],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.ulistx]
    mov       [%rbx+24],	%rax
    mov       %rax,	%rbx
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+8],	%rax
    mov       %rcx,	%r14
    call      cc_lib.getalignment
    mov       [%rbp + cc_parse.readstructdecl.alignment],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.alignment]
    cmp       %rax,	[%rbp + cc_parse.readstructdecl.maxalignment]
    jle       L7643
    mov       %rax,	[%rbp + cc_parse.readstructdecl.alignment]
    mov       [%rbp + cc_parse.readstructdecl.maxalignment],	%rax
L7643:
    mov       %rcx,	[%rbp + cc_parse.readstructdecl.offset]
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.alignment]
    call      cc_parse.roundoffset
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+88],	%eax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readstructdecl.size],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    movsxd    %rax,	dword ptr[%rax+88]
    sub       %rax,	[%rbp + cc_parse.readstructdecl.offset]
    add       [%rbp + cc_parse.readstructdecl.recsize],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       [%rbp + cc_parse.readstructdecl.offset],	%rax
    lea       %rcx,	[%rbp + cc_parse.readstructdecl.fieldlist]
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	[%rbp + cc_parse.readstructdecl.offset]
    call      cc_parse.addnewfield
    test      %r12,	%r12
    jz        L7645
    mov       %rax,	[%rbp + cc_parse.readstructdecl.maxsize]
    mov       %r10,	[%rbp + cc_parse.readstructdecl.size]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       [%rbp + cc_parse.readstructdecl.maxsize],	%rax
    jmp       L7644
L7645:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.size]
    add       [%rbp + cc_parse.readstructdecl.offset],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.size]
    add       [%rbp + cc_parse.readstructdecl.recsize],	%rax
L7644:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jnz       L7647
    call      cc_lex.lex
    call      cc_parse.readassignexpr
L7647:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L7650
L7649:
    call      cc_lex.lex
    jmp       L7648
L7650:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7628
L7648:
    jmp       L7627
L7630:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7628
L7631:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	18
    jz        L7652
    cmp       %rax,	19
    jnz       L7653
L7652:
    call      cc_lib.getautofieldname
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    mov       %r14,	%r13
    jmp       L7641
L7653:
    cmp       %r14,	-1
    jnz       L7655
    lea       %rcx,	[%rip+L11331]
    call      cc_support.serror
    jmp       L7654
L7655:
    mov       %rcx,	%r14
    call      cc_lib.typename
    lea       %rcx,	[%rip+L11332]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7654:
L7651:
    jmp       L7627
L7628:
L7625:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L7624
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rax,	[%rbp + cc_parse.readstructdecl.fieldlist]
    mov       [%rbx+64],	%rax
    test      %r12,	%r12
    jz        L7657
    mov       %rax,	[%rbp + cc_parse.readstructdecl.maxsize]
    jmp       L7656
L7657:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.recsize]
L7656:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.maxalignment]
    call      cc_parse.roundoffset
    movzx     %r10,	word ptr[%rbx+102]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       [%r11 + %r10*8],	%rax
    mov       %al,	[%rbp + cc_parse.readstructdecl.maxalignment]
    mov       [%rbx+112],	%al
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    cmp       %r10,	1
    jz        L7660
    cmp       %r10,	2
    jz        L7660
    cmp       %r10,	4
    jz        L7660
    cmp       %r10,	8
    jnz       L7659
L7660:
    movzx     %rax,	word ptr[%rbx+102]
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_decls.ttisblock]
    mov       [%r11 + %rax],	%r10b
L7659:
    movzx     %rax,	word ptr[%rbx+102]
L7603:
#---------------
    add       %rsp,	128
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.checkpointertypes
cc_parse.checkpointertypes:
#?>>
    .set cc_parse.checkpointertypes.t, 80
    .set cc_parse.checkpointertypes.hard, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    xor       %r13,	%r13
    xor       %eax,	%eax
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7663
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    mov       %r13,	1
L7663:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7665
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    mov       %r14,	1
L7665:
    mov       %rax,	[%rbp + cc_parse.checkpointertypes.hard]
    test      %rax,	%rax
    jnz       L7667
    test      %r13,	%r13
    jz        L7667
    test      %r14,	%r14
    jnz       L7667
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11333]
    call      cc_support.terror
L7667:
    cmp       %rdi,	%rbx
    jnz       L7669
    mov       %rax,	1
    jmp       L7661
L7669:
    mov       %r15,	%rdi
    mov       [%rbp + cc_parse.checkpointertypes.t],	%rbx
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L7671
    cmp       %rax,	9
    jg        L7671
    mov       %rax,	%r12
    cmp       %rax,	1
    jl        L7671
    cmp       %rax,	9
    jg        L7671
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	%r12
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L7673
    mov       %rax,	1
    jmp       L7661
L7673:
L7671:
    test      %rsi,	%rsi
    jz        L7676
    test      %r12,	%r12
    jnz       L7675
L7676:
    mov       %rax,	1
    jmp       L7661
L7675:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7678
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7678
    mov       %rcx,	%r15
    mov       %rdx,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L7661
L7678:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7679
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7679
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jz        L7681
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L7683
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L7683
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11334]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	1
    jmp       L7661
    xor       %eax,	%eax
    jmp       L7661
L7683:
L7681:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    cmp       %rdi,	%rbx
    jnz       L7685
    mov       %rax,	1
    jmp       L7661
L7685:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7687
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7687
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L7661
L7687:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7689
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7689
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L7661
L7689:
    jmp       L7677
L7679:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L7690
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L7690
    mov       %rax,	1
    jmp       L7661
L7690:
L7677:
    xor       %eax,	%eax
L7661:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.comparemode
cc_parse.comparemode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    cmp       %rdi,	%rbx
    jnz       L7693
    mov       %rax,	1
    jmp       L7691
L7693:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7695
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7695
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L7697
    xor       %eax,	%eax
    jmp       L7691
L7697:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L7700
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L7700
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%rbx
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L7699
L7700:
    mov       %rax,	1
    jmp       L7691
L7699:
L7695:
    xor       %eax,	%eax
L7691:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readenumdecl
cc_parse.readenumdecl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L7703
    mov       %rcx,	%rsi
    call      cc_parse.readenumnames
    mov       %rax,	12
    jmp       L7701
L7703:
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rdi,	[%rax]
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L7705
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L7707
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	12
    jz        L7709
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L11335]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7709:
L7707:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	12
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createenummode
    mov       [%rbx+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rbx+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    movzx     %rax,	word ptr[%rbx+102]
    jmp       L7701
L7705:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L7711
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	12
    jz        L7713
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L11335]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7713:
    mov       %rax,	[%rbx+16]
    test      %rax,	%rax
    jz        L7715
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L11336]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7715:
    jmp       L7710
L7711:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	12
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createenummode
    mov       [%rbx+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rbx+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L7710:
    mov       %rcx,	%rsi
    call      cc_parse.readenumnames
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r10,	%rbx
    lea       %r11,	[%rip+cc_decls.ttnamedef]
    mov       [%r11 + %rax*8],	%r10
    movzx     %rax,	word ptr[%rbx+102]
L7701:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readenumnames
cc_parse.readenumnames:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    xor       %eax,	%eax
    mov       %rsi,	%rax
    mov       %rbx,	%rax
    xor       %r12,	%r12
    call      cc_lex.lex
    movzx     %rax,	byte ptr[%r13+109]
    cmp       %rax,	6
    jz        L7718
    cmp       %rax,	3
    jnz       L7719
L7718:
    jmp       L7717
L7719:
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L7721
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L7720
L7721:
    mov       %rax,	[%rip+cc_decls.stmodule]
L7720:
    mov       %r13,	%rax
L7717:
    jmp       L7723
L7722:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L7726
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11337]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L7726:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	11
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L7728
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       %r12,	%rax
L7728:
    mov       [%rdi+88],	%r12d
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    inc       %r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L7730
    call      cc_lex.lex
L7730:
L7723:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L7722
    mov       %rcx,	18
    call      cc_lib.skipsymbol
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createdotop
cc_parse.createdotop:
#?>>
    .set cc_parse.createdotop.p, 80
    .set cc_parse.createdotop.d, 88
    .set cc_parse.createdotop.fl, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	[%rbp + cc_parse.createdotop.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r13,	%rax
    cmp       %r15,	50
    jnz       L7733
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jnz       L7735
    lea       %rcx,	[%rip+L11338]
    call      cc_support.serror
L7735:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
L7733:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	18
    jz        L7737
    cmp       %rax,	19
    jnz       L7738
L7737:
    jmp       L7736
L7738:
    lea       %rcx,	[%rip+L11339]
    call      cc_support.serror
L7736:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8]
    mov       %rbx,	[%rbp + cc_parse.createdotop.d]
    jmp       L7740
L7739:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L7743
    movsxd    %rax,	dword ptr[%rbx+88]
    mov       %r14,	%rax
    jmp       L7741
L7743:
L7740:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L7739
L7741:
    test      %rbx,	%rbx
    jnz       L7745
    mov       %r12,	[%rbp + cc_parse.createdotop.d]
    jmp       L7747
L7746:
    mov       %r12,	[%r12+48]
L7747:
    mov       %rax,	[%r12+48]
    test      %rax,	%rax
    jnz       L7746
    mov       %rax,	[%rsi+64]
    mov       [%rbp + cc_parse.createdotop.fl],	%rax
    jmp       L7750
L7749:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rax,	[%rax+8]
    cmp       %rax,	%r12
    jnz       L7753
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rbx,	[%rax]
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %r14,	[%rax+24]
    jmp       L7751
L7753:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_parse.createdotop.fl],	%rax
L7750:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    test      %rax,	%rax
    jnz       L7749
L7751:
L7745:
    test      %rbx,	%rbx
    jnz       L7755
    mov       %rcx,	%r13
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %r10,	[%rbp + cc_parse.createdotop.d]
    mov       %r10,	[%r10]
    lea       %rcx,	[%rip+L11340]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      cc_support.terror_ss
L7755:
    mov       %rcx,	%r14
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    cmp       %r15,	50
    jnz       L7757
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.createptrop
    mov       [%rbp + cc_parse.createdotop.p],	%rax
L7757:
    mov       %rcx,	49
    mov       %rdx,	[%rbp + cc_parse.createdotop.p]
    call      cc_lib.createunit1
    mov       [%rbp + cc_parse.createdotop.p],	%rax
    mov       %eax,	%r14d
    mov       %r10,	[%rbp + cc_parse.createdotop.p]
    mov       [%r10],	%eax
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r10,	[%rbp + cc_parse.createdotop.p]
    mov       [%r10+52],	%eax
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.arraytopointer
    mov       [%rbp + cc_parse.createdotop.p],	%rax
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.fixmemopnd
    mov       %rax,	[%rbp + cc_parse.createdotop.p]
L7731:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.mulunit
cc_parse.mulunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jz        L7760
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L7762
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    imul      %rax,	%r10
    mov       [%rbx],	%rax
    jmp       L7761
L7762:
    mov       %rcx,	57
    mov       %rdx,	%rbx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       [%rbx+48],	%edi
    mov       %eax,	4
    mov       [%rbx+52],	%eax
L7761:
L7760:
    mov       %rax,	%rbx
L7758:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.divunit
cc_parse.divunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jz        L7765
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L7767
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    mov       [%rbx],	%rax
    jmp       L7766
L7767:
    mov       %rcx,	57
    mov       %rdx,	%rbx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       %rax,	%rdi
    neg       %rax
    mov       [%rbx+48],	%eax
    mov       %eax,	4
    mov       [%rbx+52],	%eax
L7766:
L7765:
    mov       %rax,	%rbx
L7763:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createassignopref
cc_parse.createassignopref:
#?>>
    .set cc_parse.createassignopref.q, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r14,	%rcx
    mov       %r15,	%rdx
    mov       [%rbp+88],	%r8
#---------------
    movsxd    %rax,	dword ptr[%r15+52]
    mov       %rsi,	%rax
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + cc_parse.createassignopref.q]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rbx,	%rax
    mov       %rax,	%r14
    cmp       %rax,	11
    jz        L7770
    cmp       %rax,	46
    jz        L7771
    cmp       %rax,	47
    jz        L7772
    jmp       L7773
L7770:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%rdi
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createassignopref.q],	%rax
    mov       %rcx,	11
    mov       %rdx,	%r15
    mov       %r8,	[%rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       %r13,	%rax
    jmp       L7769
L7771:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7775
    lea       %rcx,	[%rip+L11341]
    call      cc_support.serror
L7775:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createassignopref.q],	%rax
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%r12
    call      cc_parse.mulunit
    mov       %rcx,	61
    mov       %rdx,	%r15
    mov       %r8,	%rax
    call      cc_lib.createunit2
    mov       %r13,	%rax
    jmp       L7769
L7772:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7777
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L7779
    lea       %rcx,	[%rip+L11342]
    call      cc_support.serror
L7779:
    mov       %rcx,	40
    mov       %rdx,	%r15
    mov       %r8,	[%rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      cc_parse.divunit
    mov       %r13,	%rax
    mov       %rsi,	3
    jmp       L7776
L7777:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%r12
    call      cc_parse.mulunit
    mov       %rcx,	62
    mov       %rdx,	%r15
    mov       %r8,	%rax
    call      cc_lib.createunit2
    mov       %r13,	%rax
L7776:
    jmp       L7769
L7773:
    lea       %rcx,	[%rip+L11343]
    call      cc_support.serror
L7769:
    mov       [%r13+52],	%esi
    mov       %rax,	%r13
L7768:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.addnewfield
cc_parse.addnewfield:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%r12]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L7782
    mov       %rcx,	32
    call      mlib.pcm_allocz
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    jmp       L7784
L7783:
    mov       %r12,	[%r12+48]
L7784:
    mov       %rax,	[%r12+48]
    test      %rax,	%rax
    jnz       L7783
    mov       [%rbx+8],	%r12
    mov       [%rbx+24],	%r13
    mov       %rax,	[%rsi]
    mov       [%rbx+16],	%rax
    mov       [%rsi],	%rbx
    jmp       L7781
L7782:
    movzx     %rax,	word ptr[%r12+102]
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	[%r10 + %rax*8]
    mov       %r10,	[%r10+16]
    mov       %rdi,	%r10
    jmp       L7787
L7786:
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %r10,	%r13
    add       %r10,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%r10
    call      cc_parse.addnewfield
    mov       %rdi,	[%rdi+32]
L7787:
    test      %rdi,	%rdi
    jnz       L7786
L7781:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.pushloop
cc_parse.pushloop:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_parse.loopindex]
    cmp       %rax,	64
    jl        L7791
    lea       %rcx,	[%rip+L11344]
    call      cc_support.serror
L7791:
    inc       qword ptr[%rip+cc_parse.loopindex]
    mov       %al,	%dil
    lea       %r10,	[%rip+cc_parse.looptypestack]
    mov       %r11,	[%rip+cc_parse.loopindex]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_parse.casevaluestack]
    mov       %r11,	[%rip+cc_parse.loopindex]
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.poploop
cc_parse.poploop:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_parse.loopindex]
    test      %rax,	%rax
    jz        L7794
    dec       qword ptr[%rip+cc_parse.loopindex]
    jmp       L7793
L7794:
    lea       %rcx,	[%rip+L11345]
    call      cc_support.serror
L7793:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_parse.addcasevalue
cc_parse.addcasevalue:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	[%rip+cc_parse.loopindex]
    jmp       L7797
L7796:
    dec       %rbx
L7797:
    test      %rbx,	%rbx
    jz        L7799
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	83
    jnz       L7796
L7799:
    test      %rbx,	%rbx
    jnz       L7801
    lea       %rcx,	[%rip+L11346]
    call      cc_support.serror
L7801:
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rsi
    lea       %rax,	[%rip+cc_parse.casevaluestack]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rdi],	%rax
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_parse.casevaluestack]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.roundoffset
cc_parse.roundoffset:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+cc_decls.structpadding]
    test      %rax,	%rax
    jz        L7804
    cmp       %rdx,	1
    jnz       L7806
    mov       %rax,	%rcx
    jmp       L7802
L7806:
    lea       %rax,	[%rdx-1]
    mov       %rdi,	%rax
    jmp       L7808
L7807:
    inc       %rcx
L7808:
    mov       %rax,	%rcx
    and       %rax,	%rdi
    jnz       L7807
L7804:
    mov       %rax,	%rcx
L7802:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.fixmemopnd
cc_parse.fixmemopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %al,	[%rip+cc_parse.ingeneric]
    test      %al,	%al
    jnz       L7810
L7812:
    movsxd    %rax,	dword ptr[%rcx+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rdi,	%r10
    cmp       %r10,	1
    jz        L7814
    cmp       %r10,	2
    jz        L7814
    cmp       %r10,	6
    jz        L7814
    cmp       %r10,	7
    jz        L7814
    cmp       %r10,	5
    jz        L7814
    jmp       L7815
L7814:
    mov       [%rcx+56],	%di
    mov       %eax,	3
    mov       [%rcx+52],	%eax
L7815:
L7813:
L7810:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.docast
cc_parse.docast:
#?>>
    .set cc_parse.docast.inplace, 88
    .set cc_parse.docast.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
#cc_parse.docast.retry:
L7817:
    cmp       %rbx,	%r13
    jnz       L7819
    mov       %rax,	%r12
    jmp       L7816
L7819:
    xor       %rsi,	%rsi
    mov       %rax,	%rbx
    cmp       %rax,	16
    jge       L7821
    cmp       %r13,	16
    jge       L7821
    lea       %rax,	[%rip+cc_tables.conversionops]
    mov       %r10,	%rbx
    shl       %r10,	4
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rsi,	%rax
    jmp       L7820
L7821:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7822
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7822
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jz        L7824
    mov       [%r12+52],	%r13d
    mov       %rax,	%r12
    jmp       L7816
L7824:
    jmp       L7820
L7822:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7825
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    jmp       L7817
L7825:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7826
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
    jmp       L7817
L7826:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7827
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L7827
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jnz       L7827
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L7827
    mov       %rsi,	1
L7827:
L7820:
    test      %rsi,	%rsi
    jnz       L7829
    test      %r14,	%r14
    jnz       L7831
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       %rcx,	%r13
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L11347]
    call      cc_show.printunit
    mov       %rcx,	%r13
    call      cc_lib.typename
    mov       [%rbp + cc_parse.docast.$T1],	%rax
    mov       %rcx,	%rbx
    call      cc_lib.typename
    lea       %rcx,	[%rip+L11348]
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + cc_parse.docast.$T1]
    call      cc_support.terror_ss
L7831:
    mov       %rsi,	2
L7829:
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jz        L7833
    cmp       %rax,	5
    jz        L7834
    cmp       %rax,	39
    jz        L7835
    jmp       L7836
L7833:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%rsi
    call      cc_parse.eval_convert
    test      %rax,	%rax
    jz        L7838
    mov       %rax,	%r12
    jmp       L7816
L7838:
    jmp       L7832
L7834:
    mov       [%r12+52],	%r13d
    mov       %rax,	%r12
    jmp       L7816
L7835:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7840
    mov       %rax,	[%r12+24]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7840
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    mov       %r10,	[%r12+24]
    mov       %r10,	[%r10]
    add       %rax,	%r10
    mov       [%r12],	%rax
    mov       [%r12+52],	%r13d
    mov       %eax,	1
    mov       [%r12+40],	%eax
    mov       %rax,	%r12
    jmp       L7816
L7840:
L7836:
L7832:
    mov       %rax,	[%rbp + cc_parse.docast.inplace]
    test      %rax,	%rax
    jz        L7842
    mov       %rcx,	%r12
    mov       %rdx,	56
    call      cc_parse.insertunit
    mov       [%r12+58],	%r13w
    mov       %rcx,	%r13
    call      cc_parse.getpromotedtype
    mov       [%r12+52],	%eax
    mov       [%r12+48],	%esi
    xor       %eax,	%eax
    jmp       L7816
L7842:
    mov       %rcx,	56
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+48],	%esi
    mov       [%rdi+58],	%r13w
    mov       %rcx,	%r13
    call      cc_parse.getpromotedtype
    mov       [%rdi+52],	%eax
L7841:
    mov       %rax,	%rdi
L7816:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercemode
cc_parse.coercemode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	%rbx
    jnz       L7845
    mov       %rax,	%rdi
    jmp       L7843
L7845:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      cc_parse.docast
    mov       %rax,	%rdi
L7843:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercemode_inplace
cc_parse.coercemode_inplace:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	%rbx
    jz        L7846
L7848:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      cc_parse.docast
L7846:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createsizeofop
cc_parse.createsizeofop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    test      %r13,	%r13
    jz        L7851
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	53
    jz        L7851
    cmp       %rax,	55
    jz        L7851
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L11349]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L11350]
    call      cc_support.serror
L7851:
    mov       %rcx,	%r12
    call      cc_parse.getmemmode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	3
    jz        L7853
    cmp       %rax,	1
    jz        L7854
    cmp       %rax,	52
    jz        L7855
    cmp       %rax,	53
    jz        L7856
    cmp       %rax,	55
    jz        L7857
    cmp       %rax,	4
    jz        L7858
    jmp       L7859
L7853:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L7861
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    xchg      %r10,	%rax
    cqo       
    idiv      %r10
    mov       %rsi,	%rax
    jmp       L7860
L7861:
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rsi,	%r10
L7860:
    jmp       L7852
L7854:
    mov       %rax,	%rbx
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L7863
    cmp       %rax,	[%rip+cc_decls.trefwchar]
    jz        L7864
    jmp       L7865
L7863:
    movsxd    %rax,	dword ptr[%r12+48]
    inc       %rax
    mov       %rsi,	%rax
    jmp       L7862
L7864:
    movsxd    %rax,	dword ptr[%r12+48]
    inc       %rax
    shl       %rax,	1
    mov       %rsi,	%rax
    jmp       L7862
L7865:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L7862:
    jmp       L7852
L7855:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L7867
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L7867
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    imul      %r10,	%rax
    mov       %rsi,	%r10
    jmp       L7866
L7867:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L7866:
    jmp       L7852
L7856:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L7869
    test      %r13,	%r13
    jz        L7871
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
    jmp       L7870
L7871:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    imul      %r10,	%rax
    mov       %rsi,	%r10
L7870:
    jmp       L7868
L7869:
    jmp       L7872
L7868:
    jmp       L7852
L7857:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L7874
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    test      %eax,	%eax
    jz        L7874
    test      %r13,	%r13
    jz        L7876
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %rsi,	%rax
    jmp       L7875
L7876:
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rsi,	%r10
L7875:
    jmp       L7873
L7874:
    mov       %rsi,	8
L7873:
    jmp       L7852
L7858:
    mov       %rax,	[%r12+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    jmp       L7849
L7859:
#cc_parse.createsizeofop.cad1:
L7872:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L7852:
    mov       %rcx,	%rsi
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L7849:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readgeneric
cc_parse.readgeneric:
#?>>
    .set cc_parse.readgeneric.pm, -8
    .set cc_parse.readgeneric.oldingeneric, -16
    .set cc_parse.readgeneric.count, -24
    .set cc_parse.readgeneric.d, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    movzx     %rax,	byte ptr[%rip+cc_parse.ingeneric]
    mov       [%rbp + cc_parse.readgeneric.oldingeneric],	%rax
    mov       %al,	1
    mov       [%rip+cc_parse.ingeneric],	%al
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %al,	[%rbp + cc_parse.readgeneric.oldingeneric]
    mov       [%rip+cc_parse.ingeneric],	%al
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %r12,	%rax
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %r14,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readgeneric.count],	%rax
    mov       %rcx,	8
    call      cc_lib.checksymbol
L7878:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	74
    jnz       L7882
    test      %r14,	%r14
    jz        L7884
    lea       %rcx,	[%rip+L11351]
    call      cc_support.serror
L7884:
    mov       %r14,	1
    mov       %rax,	[%rbp + cc_parse.readgeneric.count]
    test      %rax,	%rax
    jnz       L7886
    mov       %r13,	-1
    jmp       L7885
L7886:
    mov       %r13,	-2
L7885:
    call      cc_lex.lex
    jmp       L7881
L7882:
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readgeneric.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readgeneric.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %r13,	%rax
L7881:
    mov       %rcx,	10
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rsi,	%rax
    cmp       %r13,	-1
    jz        L7889
    cmp       %r13,	%r12
    jnz       L7888
L7889:
    mov       %rbx,	%rsi
    inc       qword ptr[%rbp + cc_parse.readgeneric.count]
L7888:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L7878
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    test      %rbx,	%rbx
    jnz       L7891
    lea       %rcx,	[%rip+L11352]
    call      cc_support.serror
L7891:
    mov       %rax,	[%rbp + cc_parse.readgeneric.count]
    cmp       %rax,	1
    jle       L7893
    lea       %rcx,	[%rip+L11353]
    call      cc_support.serror
L7893:
    mov       %rax,	%rbx
L7877:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.getmemmode
cc_parse.getmemmode:
#?>>
#?]]
#---------------
    mov       %ax,	[%rcx+56]
    test      %ax,	%ax
    jz        L7896
    movsx     %rax,	word ptr[%rcx+56]
    jmp       L7895
L7896:
    movsxd    %rax,	dword ptr[%rcx+52]
L7895:
L7894:
#---------------
    ret       
# End 
# Proc cc_parse.getpromotedtype
cc_parse.getpromotedtype:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L7899
    xor       %eax,	%eax
    jmp       L7897
L7899:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L7901
    mov       %rax,	3
    jmp       L7897
L7901:
    mov       %rax,	%rcx
L7897:
#---------------
    ret       
# End 
# Proc cc_genpcl.codegen_pcl
cc_genpcl.codegen_pcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L7904
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11354]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L7904:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11355]
    call      msys.m$print_str_nf
    mov       %rcx,	24
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	[%rip+cc_decls.nunits]
    call      pc_api.pcl_start
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11355]
    call      msys.m$print_str_nf
    mov       %rcx,	27
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_genpcl.dolibs
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11355]
    call      msys.m$print_str_nf
    mov       %rcx,	30
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11356]
    call      pc_api.gencomment
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L7906
L7905:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L7909
    cmp       %rax,	6
    jz        L7910
    jmp       L7911
L7909:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11357]
    call      msys.m$print_str_nf
    mov       %rcx,	39
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      cc_genpcl.dostaticvar
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11357]
    call      msys.m$print_str_nf
    mov       %rcx,	41
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L7908
L7910:
    movzx     %rax,	byte ptr[%rdi+110]
    cmp       %rax,	4
    jz        L7913
    cmp       %rax,	2
    jz        L7914
    jmp       L7915
L7913:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jnz       L7917
    mov       %al,	3
    mov       [%rdi+110],	%al
L7917:
    jmp       L7912
L7914:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jnz       L7919
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11358]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L7919:
L7915:
L7912:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11359]
    call      msys.m$print_str_nf
    mov       %rcx,	49
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rdi+16]
    jmp       L7921
L7920:
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	7
    jz        L7924
    cmp       %rax,	8
    jz        L7925
    jmp       L7926
L7924:
    mov       %rcx,	%rbx
    call      cc_genpcl.dostaticvar
    jmp       L7923
L7925:
    mov       %rax,	[%rbx+72]
    test      %rax,	%rax
    jz        L7928
    mov       %rax,	[%rbx+72]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	28
    jz        L7931
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	17
    jnz       L7930
    mov       %rax,	[%rbx+72]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L7930
L7931:
    mov       %rcx,	%rbx
    call      cc_genpcl.dostaticvar
L7930:
L7928:
L7926:
L7923:
    mov       %rbx,	[%rbx+32]
L7921:
    test      %rbx,	%rbx
    jnz       L7920
L7911:
L7908:
    mov       %rdi,	[%rdi+32]
L7906:
    test      %rdi,	%rdi
    jnz       L7905
    lea       %rcx,	[%rip+L11360]
    call      pc_api.gencomment
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L7933
L7932:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jnz       L7937
L7936:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L7939
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11361]
    call      msys.m$print_str_nf
    mov       %rcx,	78
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      cc_genpcl.genprocdef
L7939:
L7937:
L7935:
    mov       %rdi,	[%rdi+32]
L7933:
    test      %rdi,	%rdi
    jnz       L7932
    call      pc_api.pcl_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.genprocdef
cc_genpcl.genprocdef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11362]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L7942
    mov       %rsi,	1
    lea       %rax,	[%r12+108]
    or        byte ptr[%rax],	8
L7942:
    mov       [%rip+cc_decls.currproc],	%r12
    mov       %rcx,	%r12
    call      cc_libpcl.getpsymbol
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      pc_api.pc_defproc
    mov       %rax,	[%r12+80]
    movsx     %rax,	word ptr[%rax+22]
    cmp       %rax,	3
    setz      %al
    movzx     %eax,	%al
    mov       [%rbx+113],	%al
    mov       %rdi,	[%r12+16]
    jmp       L7946
L7943:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	9
    jz        L7948
    cmp       %rax,	8
    jz        L7949
    jmp       L7950
L7948:
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.pc_addparam
    jmp       L7947
L7949:
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.pc_addlocal
L7950:
L7947:
    mov       %rdi,	[%rdi+32]
L7946:
    test      %rdi,	%rdi
    jnz       L7943
    call      cc_libpcl.createfwdlabel
    mov       [%rip+cc_genpcl.retindex],	%rax
    lea       %rcx,	[%rip+L11363]
    call      pc_api.gencomment
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11364]
    call      msys.m$print_str_nf
    mov       %rcx,	122
    call      msys.m$print_i64_nf
    mov       %rcx,	[%r12]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%r12+72]
    call      cc_blockpcl.do_stmt
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11364]
    call      msys.m$print_str_nf
    mov       %rcx,	124
    call      msys.m$print_i64_nf
    mov       %rcx,	[%r12]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11365]
    call      pc_api.gencomment
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      cc_libpcl.definefwdlabel
    test      %rsi,	%rsi
    jz        L7952
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	32
    xor       %edx,	%edx
    call      pc_api.pc_gen
L7952:
    movzx     %rax,	word ptr[%r12+102]
    test      %rax,	%rax
    jz        L7954
    mov       %rax,	23
    jmp       L7953
L7954:
    mov       %rax,	20
L7953:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    call      pc_api.pc_endproc
    lea       %rcx,	[%rip+L11366]
    call      pc_api.gencomment
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.dostaticvar
cc_genpcl.dostaticvar:
#?>>
    .set cc_genpcl.dostaticvar.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r12+110]
    cmp       %rax,	3
    jz        L7955
L7957:
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_lib.getalignment
    mov       %rdi,	%rax
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L7959
    movzx     %rax,	byte ptr[%r12+109]
    cmp       %rax,	8
    jnz       L7961
    lea       %rcx,	[%rbp + cc_genpcl.dostaticvar.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11367]
    call      msys.m$print_setfmt
    mov       %rax,	[%r12+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r12]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%r12+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_genpcl.dostaticvar.str]
    call      cc_lex.addnamestr
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	7
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_libpcl.getpsymbol
    mov       %rsi,	%rax
    mov       [%r12+114],	%rsi
    mov       %rcx,	%rsi
    call      pc_api.genmem
    mov       %rcx,	123
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L7960
L7961:
    mov       %rcx,	%r12
    call      cc_libpcl.genmem_d
    mov       %rcx,	123
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L7960:
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      pc_api.pc_setalign
    mov       %rax,	[%r12+72]
    mov       %rcx,	%rax
    mov       %rdx,	1
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    jmp       L7958
L7959:
    mov       %rcx,	%r12
    call      cc_libpcl.genmem_d
    mov       %rcx,	124
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      pc_api.pc_setalign
L7958:
L7955:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.genidata
cc_genpcl.genidata:
#?>>
    .set cc_genpcl.genidata.p, 64
    .set cc_genpcl.genidata.doterm, 72
    .set cc_genpcl.genidata.am, 80
    .set cc_genpcl.genidata.offset, 88
    .set cc_genpcl.genidata.size, -8
    .set cc_genpcl.genidata.padding, -16
    .set cc_genpcl.genidata.isunion, -24
    .set cc_genpcl.genidata.q, -32
    .set cc_genpcl.genidata.a, -40
    .set cc_genpcl.genidata.b, -48
    .set cc_genpcl.genidata.d, -56
    .set cc_genpcl.genidata.sx, -64
    .set cc_genpcl.genidata.str, -320
    .set cc_genpcl.genidata.str2, -336
    .set cc_genpcl.genidata.av_1, -344
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	384
    mov       [%rbp+64],	%rcx
    mov       [%rbp+88],	%r9
#---------------
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_genpcl.genidata.a],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax+24]
    mov       [%rbp + cc_genpcl.genidata.b],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	28
    jz        L7964
    cmp       %rax,	1
    jz        L7965
    cmp       %rax,	3
    jz        L7966
    cmp       %rax,	5
    jz        L7966
    cmp       %rax,	39
    jz        L7967
    cmp       %rax,	55
    jz        L7968
    cmp       %rax,	53
    jz        L7969
    cmp       %rax,	54
    jz        L7969
    cmp       %rax,	56
    jz        L7970
    jmp       L7971
L7964:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7973
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    mov       %r12,	1
    cmp       %rsi,	1
    jl        L7976
L7974:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.q]
    mov       %rdx,	1
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    inc       %r12
    cmp       %r12,	%rsi
    jle       L7974
L7976:
    cmp       %rsi,	%rbx
    jge       L7978
    mov       %rax,	%rbx
    sub       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
L7978:
    jmp       L7972
L7973:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	19
    setz      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_genpcl.genidata.isunion],	%rax
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_genpcl.genidata.size],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    mov       %r12,	1
    cmp       %rsi,	1
    jl        L7981
L7979:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.q]
    xor       %edx,	%edx
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    add       %r13,	%r10
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    mov       %rax,	[%rax+32]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    test      %rax,	%rax
    jz        L7983
    mov       %rax,	[%rbp + cc_genpcl.genidata.isunion]
    test      %rax,	%rax
    jnz       L7983
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %r14,	%rax
    jmp       L7982
L7983:
    mov       %r14,	[%rbp + cc_genpcl.genidata.size]
L7982:
    mov       %rax,	%r14
    sub       %rax,	%r13
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.padding]
    cmp       %rax,	0
    jle       L7985
    mov       %rax,	%r14
    sub       %rax,	%r13
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
    mov       %r13,	%r14
L7985:
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    inc       %r12
    cmp       %r12,	%rsi
    jle       L7979
L7981:
    cmp       %r14,	[%rbp + cc_genpcl.genidata.size]
    jge       L7987
    mov       %rax,	[%rbp + cc_genpcl.genidata.size]
    sub       %rax,	%r14
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
L7987:
L7972:
    jmp       L7962
L7965:
    mov       %rcx,	%rdi
    call      cc_lib.isintcc
    test      %rax,	%rax
    jnz       L7990
    mov       %rcx,	%rdi
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L7989
L7990:
    cmp       %rdi,	10
    jnz       L7992
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movq      %XMM4,	[%rax]
    cvtsd2ss  %XMM4,	%XMM4
    movd      [%rbp + cc_genpcl.genidata.sx],	%XMM4
    mov       %eax,	[%rbp + cc_genpcl.genidata.sx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L7991
L7992:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L7991:
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    jmp       L7988
L7989:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L7993
    xor       %eax,	%eax
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
#cc_genpcl.genidata.doref:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L7996
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L7995
L7996:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %al,	[%rax+61]
    test      %al,	%al
    jz        L7997
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genstring
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L7995
L7997:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %al,	[%rax+62]
    test      %al,	%al
    jz        L7998
    lea       %rcx,	[%rip+L11368]
    xor       %edx,	%edx
    call      cc_support.gerror
    mov       %rcx,	[%rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L7995
L7998:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L7995:
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    jmp       L7988
L7993:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L7999
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %r10,	dword ptr[%r10+48]
    sub       %rax,	%r10
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       [%rbp + cc_genpcl.genidata.av_1],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.av_1]
    cmp       %rax,	1
    jl        L8002
L8000:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %r10,	%r12
    lea       %rax,	[%rax + %r10]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	6
    call      cc_libpcl.setmode
    inc       %r12
    cmp       %r12,	[%rbp + cc_genpcl.genidata.av_1]
    jle       L8000
L8002:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L7988
L7999:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11369]
    xor       %edx,	%edx
    call      cc_support.gerror
L7988:
    jmp       L7962
L7966:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jz        L8004
    cmp       %rax,	6
    jnz       L8005
L8004:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.d]
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L8003
L8005:
    lea       %rcx,	[%rip+L11370]
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L8003:
    jmp       L7962
L7967:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L8007
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L8007
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jnz       L8010
L8009:
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L11371]
    call      strcpy
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+110]
    cmp       %rax,	1
    jnz       L8012
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L11372]
    call      strcat
L8012:
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L11373]
    call      strcat
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_genpcl.genidata.str2]
    call      msys.getstrint
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rbp + cc_genpcl.genidata.str2]
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8008
L8010:
    lea       %rcx,	[%rip+L11374]
    xor       %edx,	%edx
    call      cc_support.gerror
L8008:
    jmp       L8006
L8007:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L8013
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L8013
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jnz       L8013
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rcx,	[%rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11375]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rcx,	[%rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8006
L8013:
    lea       %rcx,	[%rip+L11376]
    xor       %edx,	%edx
    call      cc_support.gerror
L8006:
    jmp       L7962
L7968:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	52
    jnz       L8015
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rax,	[%rax+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L8014
L8015:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
L8014:
    jmp       L7963
L7969:
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jz        L8017
    lea       %rcx,	[%rip+L11377]
    xor       %edx,	%edx
    call      cc_support.gerror
L8017:
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %r10,	dword ptr[%r10]
    imul      %rax,	%r10
    add       %rax,	[%rbp + cc_genpcl.genidata.offset]
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	%rax
    call      cc_genpcl.genidata
    jmp       L7963
L7970:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L7963
L7971:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L11378]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L11379]
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L7963:
L7962:
#---------------
    add       %rsp,	384
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.doresb
cc_genpcl.doresb:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    jmp       L8020
L8019:
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	8
    sub       %rbx,	%rax
    mov       %rcx,	9
    call      cc_libpcl.setmode
L8020:
    cmp       %rbx,	8
    jge       L8019
    mov       %rdi,	%rbx
    cmp       %rdi,	0
    jle       L8024
L8022:
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	6
    call      cc_libpcl.setmode
    dec       %rdi
    jnz       L8022
L8024:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.pushint
cc_genpcl.pushint:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.dolibs
cc_genpcl.dolibs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	1
    jl        L8029
L8027:
    lea       %rax,	[%rip+cc_decls.libfiles]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      pc_api.pc_addplib
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nlibfiles]
    jle       L8027
L8029:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_stmt
cc_blockpcl.do_stmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    test      %r12,	%r12
    jnz       L8032
    jmp       L8030
L8032:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %eax,	[%r12+44]
    mov       [%rip+cc_decls.clineno],	%rax
    movzx     %rax,	byte ptr[%r12+60]
    mov       [%rip+cc_decls.cfileno],	%rax
    mov       %rax,	[%rip+cc_decls.cfileno]
    shl       %rax,	24
    add       %rax,	[%rip+cc_decls.clineno]
    mov       [%rip+pc_decls.mmpos],	%rax
    mov       %rbx,	[%r12+16]
    mov       %rsi,	[%r12+24]
    movsxd    %rax,	dword ptr[%r12+40]
    sub       %rax,	6
    cmp       %rax,	69
    jae       L8035
    lea       %r10,	[%rip+L8034]
    jmp       [%r10 + %rax*8]
    .data
L8034:
    .quad     L8036
    .quad     L8035
    .quad     L8040
    .quad     L8042
    .quad     L8035
    .quad     L8043
    .quad     L8044
    .quad     L8045
    .quad     L8046
    .quad     L8047
    .quad     L8048
    .quad     L8049
    .quad     L8050
    .quad     L8051
    .quad     L8053
    .quad     L8054
    .quad     L8055
    .quad     L8052
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8070
    .quad     L8041
    .quad     L8044
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8035
    .quad     L8056
    .quad     L8057
    .quad     L8058
    .quad     L8059
    .quad     L8062
    .quad     L8063
    .quad     L8064
    .quad     L8065
    .quad     L8066
    .quad     L8067
    .quad     L8068
    .quad     L8069
    .quad     L8068
    .quad     L8069
    .text
L8036:
    jmp       L8038
L8037:
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rbx,	[%rbx+8]
L8038:
    test      %rbx,	%rbx
    jnz       L8037
    jmp       L8033
L8040:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_decl
    jmp       L8033
L8041:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_call
    jmp       L8033
L8042:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_return
    jmp       L8033
L8043:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      cc_blockpcl.do_assign
    jmp       L8033
L8044:
    mov       %rax,	[%r12+32]
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      cc_blockpcl.do_if
    jmp       L8033
L8045:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_for
    jmp       L8033
L8046:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_while
    jmp       L8033
L8047:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_dowhile
    jmp       L8033
L8048:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_goto
    jmp       L8033
L8049:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_labeldef
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    jmp       L8033
L8050:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_casestmt
    jmp       L8033
L8051:
    mov       %al,	1
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       %rcx,	[%rip+cc_blockpcl.sw_defaultlabel]
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    jmp       L8033
L8052:
    mov       %rcx,	[%rip+cc_blockpcl.sw_breaklabel]
    call      cc_blockpcl.genjumpl
    jmp       L8033
L8053:
    lea       %rax,	[%rip+cc_blockpcl.breakstack]
    mov       %r10,	[%rip+cc_blockpcl.loopindex]
    mov       %rcx,	[%rax + %r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L8033
L8054:
    lea       %rax,	[%rip+cc_blockpcl.continuestack]
    mov       %r10,	[%rip+cc_blockpcl.loopindex]
    mov       %rcx,	[%rax + %r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L8033
L8055:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      cc_blockpcl.do_switch
    jmp       L8033
L8056:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	90
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8057:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	91
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8058:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	92
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8059:
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L8061
    mov       %rax,	93
    jmp       L8060
L8061:
    mov       %rax,	94
L8060:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8062:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	95
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8063:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	96
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8064:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	97
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8065:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	98
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8066:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	99
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8067:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	100
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L8033
L8068:
    mov       %rcx,	%rbx
    mov       %rdx,	84
    call      cc_blockpcl.do_preincr
    jmp       L8033
L8069:
    mov       %rcx,	%rbx
    mov       %rdx,	85
    call      cc_blockpcl.do_preincr
    jmp       L8033
L8070:
    jmp       L8072
L8071:
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rbx,	[%rbx+8]
L8072:
    test      %rbx,	%rbx
    jnz       L8071
    jmp       L8033
L8035:
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	11
    xor       %edx,	%edx
    call      pc_api.pc_gen
    test      %rbx,	%rbx
    jz        L8075
    mov       %rax,	%rbx
    jmp       L8074
L8075:
    mov       %rax,	%r12
L8074:
    mov       %rcx,	%rax
    call      cc_libpcl.setmode_u
L8033:
L8030:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_expr
cc_blockpcl.dx_expr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    test      %r13,	%r13
    jnz       L8078
    jmp       L8076
L8078:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %eax,	[%r13+44]
    mov       [%rip+cc_decls.clineno],	%rax
    movzx     %rax,	byte ptr[%r13+60]
    mov       [%rip+cc_decls.cfileno],	%rax
    mov       %rsi,	[%r13+16]
    mov       %r12,	[%r13+24]
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r13+40]
    sub       %rax,	1
    cmp       %rax,	76
    jae       L8081
    lea       %r10,	[%rip+L8080]
    jmp       [%r10 + %rax*8]
    .data
L8080:
    .quad     L8082
    .quad     L8081
    .quad     L8083
    .quad     L8084
    .quad     L8085
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8086
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8081
    .quad     L8087
    .quad     L8087
    .quad     L8088
    .quad     L8091
    .quad     L8081
    .quad     L8092
    .quad     L8103
    .quad     L8104
    .quad     L8081
    .quad     L8105
    .quad     L8105
    .quad     L8105
    .quad     L8105
    .quad     L8105
    .quad     L8105
    .quad     L8106
    .quad     L8109
    .quad     L8110
    .quad     L8111
    .quad     L8114
    .quad     L8115
    .quad     L8116
    .quad     L8117
    .quad     L8118
    .quad     L8119
    .quad     L8142
    .quad     L8081
    .quad     L8081
    .quad     L8120
    .quad     L8121
    .quad     L8122
    .quad     L8141
    .quad     L8123
    .quad     L8126
    .quad     L8127
    .quad     L8081
    .quad     L8128
    .quad     L8131
    .quad     L8132
    .quad     L8133
    .quad     L8134
    .quad     L8135
    .quad     L8136
    .quad     L8137
    .quad     L8138
    .quad     L8139
    .quad     L8140
    .quad     L8129
    .quad     L8129
    .quad     L8130
    .quad     L8130
    .quad     L8143
    .quad     L8144
    .text
L8082:
    mov       %rcx,	%r13
    call      cc_blockpcl.dx_const
    jmp       L8079
L8083:
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      cc_blockpcl.dx_name
    jmp       L8079
L8084:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    call      cc_blockpcl.dx_expr
    jmp       L8079
L8085:
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L8079
L8086:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	1
    call      cc_blockpcl.do_assign
    jmp       L8079
L8087:
    mov       %rcx,	%r13
    call      cc_blockpcl.dx_andorl
    jmp       L8079
L8088:
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	26
    jnz       L8090
    mov       %rax,	[%rsi+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	64
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	8
    call      cc_libpcl.setmode
    mov       %rax,	[%rsi+16]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode2
    jmp       L8089
L8090:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	63
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
L8089:
    jmp       L8079
L8091:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	64
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	8
    call      cc_libpcl.setmode
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode2
    jmp       L8079
L8092:
    jmp       L8096
L8093:
    mov       %r12,	[%rsi+8]
    test      %r12,	%r12
    jz        L8098
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	11
    jz        L8099
    cmp       %rax,	56
    jz        L8099
    cmp       %rax,	31
    jnz       L8098
L8099:
    mov       %rcx,	%rsi
    call      cc_blockpcl.do_stmt
    jmp       L8097
L8098:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %r12,	%r12
    jz        L8101
    movsxd    %rax,	dword ptr[%rsi+52]
    test      %rax,	%rax
    jnz       L8102
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	56
    jnz       L8101
L8102:
    mov       %rcx,	134
    xor       %edx,	%edx
    call      pc_api.pc_gen
L8101:
L8097:
    mov       %rsi,	%r12
L8096:
    test      %rsi,	%rsi
    jnz       L8093
    jmp       L8079
L8103:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	1
    call      cc_blockpcl.dx_call
    jmp       L8079
L8104:
    mov       %rax,	[%r13+32]
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	%rax
    call      cc_blockpcl.dx_ifx
    jmp       L8079
L8105:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_blockpcl.dx_eq
    jmp       L8079
L8106:
    movsxd    %rax,	dword ptr[%rsi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L8108
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    cmp       %r10,	4
    jg        L8108
    mov       %eax,	9
    mov       [%r12+52],	%eax
L8108:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	43
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8109:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	44
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8110:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	45
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8111:
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rcx,	%rax
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L8113
    mov       %rax,	46
    jmp       L8112
L8113:
    mov       %rax,	47
L8112:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8114:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	48
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8115:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	50
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8116:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	51
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8117:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	52
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8118:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	53
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8119:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	54
    call      cc_blockpcl.dx_bin
    jmp       L8079
L8120:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r14
    call      cc_blockpcl.dx_ptr
    jmp       L8079
L8121:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	57
    sub       %rsp,	32
    call      cc_blockpcl.dx_addptr
    add       %rsp,	48
    jmp       L8079
L8122:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	58
    sub       %rsp,	32
    call      cc_blockpcl.dx_addptr
    add       %rsp,	48
    jmp       L8079
L8123:
    movsx     %rax,	word ptr[%r13+58]
    test      %rax,	%rax
    jnz       L8125
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    jmp       L8124
L8125:
    movsxd    %rax,	dword ptr[%r13+48]
    movsx     %r10,	word ptr[%r13+58]
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      cc_blockpcl.dx_convert
L8124:
    jmp       L8079
L8126:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_blockpcl.dx_scale
    jmp       L8079
L8127:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	60
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
    jmp       L8079
L8128:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	62
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
    jmp       L8079
L8129:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      cc_blockpcl.dx_preincrx
    jmp       L8079
L8130:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      cc_blockpcl.dx_postincrx
    jmp       L8079
L8131:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	90
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8132:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	91
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8133:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	92
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8134:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	93
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8135:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	95
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8136:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	96
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8137:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	97
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8138:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	98
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8139:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	99
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8140:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	100
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8079
L8141:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r14
    call      cc_blockpcl.dx_addrof
    jmp       L8079
L8142:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	%r14
    call      cc_blockpcl.dx_dot
    jmp       L8079
L8143:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	129
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8079
L8144:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	130
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8079
L8081:
    movsxd    %rax,	dword ptr[%r13+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L11380]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L8079:
    mov       [%rip+cc_decls.clineno],	%rdi
L8076:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_const
cc_blockpcl.dx_const:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rdi,	%r10
    mov       %rax,	%rdi
    cmp       %rax,	1
    jl        L8147
    cmp       %rax,	9
    jg        L8147
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8146
L8147:
    mov       %rax,	%rdi
    cmp       %rax,	10
    jz        L8149
    cmp       %rax,	11
    jz        L8150
    jmp       L8151
L8149:
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8148
L8150:
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8148
L8151:
    cmp       %rdi,	10
    jl        L8153
    cmp       %rdi,	11
    jg        L8153
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8152
L8153:
    cmp       %rdi,	13
    jnz       L8154
    mov       %al,	[%rbx+61]
    test      %al,	%al
    jz        L8156
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genstring
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8155
L8156:
    mov       %al,	[%rbx+62]
    test      %al,	%al
    jz        L8157
    lea       %rcx,	[%rip+L11381]
    xor       %edx,	%edx
    call      cc_support.gerror
    jmp       L8155
L8157:
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L8155:
    jmp       L8152
L8154:
    lea       %rcx,	[%rip+L11382]
    xor       %edx,	%edx
    call      cc_support.gerror
L8152:
L8148:
L8146:
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_name
cc_blockpcl.dx_name:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	[%rbx]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L8160
    cmp       %rax,	8
    jz        L8160
    cmp       %rax,	9
    jnz       L8161
L8160:
    test      %rsi,	%rsi
    jz        L8163
    mov       %rcx,	%rdi
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L8162
L8163:
    mov       %rcx,	%rdi
    call      cc_libpcl.genmem_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
L8162:
    jmp       L8159
L8161:
    lea       %rcx,	[%rip+L11383]
    xor       %edx,	%edx
    call      cc_support.gerror
L8159:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_bin
cc_blockpcl.dx_bin:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_binto
cc_blockpcl.dx_binto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    test      %r12,	%r12
    jnz       L8167
    mov       %rax,	%rsi
    cmp       %rax,	94
    jz        L8167
    cmp       %rax,	95
    jz        L8167
    call      cc_blockpcl.do_setinplace
L8167:
    test      %r12,	%r12
    jz        L8169
    mov       %rcx,	8
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	10
    mov       %rdx,	2
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      pc_api.pc_genxy
L8169:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    test      %r12,	%r12
    jz        L8171
    mov       %rcx,	2
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
L8171:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_assign
cc_blockpcl.do_assign:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L8174
    mov       %rcx,	9
    xor       %edx,	%edx
    call      pc_api.pc_gen
L8174:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	3
    jz        L8176
    cmp       %rax,	52
    jz        L8177
    cmp       %rax,	49
    jz        L8178
    jmp       L8179
L8176:
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L8175
L8177:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    mov       %rcx,	5
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L8175
L8178:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	5
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L8175
L8179:
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L11384]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L8175:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ptr
cc_blockpcl.dx_ptr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jnz       L8182
    mov       %rcx,	2
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_blockpcl.widen
L8182:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addptr
cc_blockpcl.dx_addptr:
#?>>
    .set cc_blockpcl.dx_addptr.am, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r12
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addrof
cc_blockpcl.dx_addrof:
#?>>
    .set cc_blockpcl.dx_addrof.p, 24
    .set cc_blockpcl.dx_addrof.am, 40
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_convert
cc_blockpcl.dx_convert:
#?>>
    .set cc_blockpcl.dx_convert.p, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8]
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L8187
    cmp       %rax,	2
    jz        L8188
    cmp       %rax,	3
    jz        L8189
    cmp       %rax,	4
    jz        L8189
    cmp       %rax,	5
    jz        L8190
    cmp       %rax,	6
    jz        L8190
    cmp       %rax,	7
    jz        L8191
    cmp       %rax,	8
    jz        L8191
    cmp       %rax,	9
    jz        L8192
    cmp       %rax,	10
    jz        L8193
    cmp       %rax,	11
    jz        L8194
    cmp       %rax,	12
    jz        L8194
    jmp       L8195
L8187:
    jmp       L8185
L8188:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	10
    jz        L8198
    cmp       %rax,	11
    jnz       L8197
L8198:
    lea       %rcx,	[%rip+L11385]
    xor       %edx,	%edx
    call      cc_support.gerror
L8197:
    cmp       %rsi,	%rbx
    jle       L8200
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8199
L8200:
    cmp       %rsi,	%rbx
    jl        L8202
L8201:
L8199:
    jmp       L8186
L8189:
    cmp       %rbx,	%rsi
    jz        L8185
L8204:
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8186
L8190:
    mov       %rcx,	111
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8186
L8191:
    mov       %rcx,	112
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8186
L8192:
    mov       %rcx,	115
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8186
L8193:
    mov       %rcx,	116
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8186
L8194:
#cc_blockpcl.dx_convert.dotruncate:
L8202:
    mov       %rcx,	113
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	%r13
    call      cc_libpcl.setmode2
    jmp       L8185
L8195:
    lea       %rax,	[%rip+cc_tables.convnames]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L11386]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L8186:
    mov       %rcx,	%r13
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode2
L8185:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_if
cc_blockpcl.do_if:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    test      %r13,	%r13
    jz        L8207
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%r13
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    jmp       L8206
L8207:
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
L8206:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.genjumpcond
cc_blockpcl.genjumpcond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rdi,	[%r13+16]
    mov       %rbx,	[%r13+24]
    movsxd    %rax,	dword ptr[%r13+40]
    sub       %rax,	24
    cmp       %rax,	15
    jae       L8211
    lea       %r10,	[%rip+L8210]
    jmp       [%r10 + %rax*8]
    .data
L8210:
    .quad     L8212
    .quad     L8217
    .quad     L8222
    .quad     L8227
    .quad     L8211
    .quad     L8229
    .quad     L8211
    .quad     L8211
    .quad     L8211
    .quad     L8228
    .quad     L8228
    .quad     L8228
    .quad     L8228
    .quad     L8228
    .quad     L8228
    .text
L8212:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L8214
    cmp       %rax,	27
    jz        L8215
    jmp       L8216
L8214:
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	28
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L8213
L8215:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
L8216:
L8213:
    jmp       L8209
L8217:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L8219
    cmp       %rax,	27
    jz        L8220
    jmp       L8221
L8219:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	28
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    jmp       L8218
L8220:
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
L8221:
L8218:
    jmp       L8209
L8222:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L8224
    cmp       %rax,	27
    jz        L8225
    jmp       L8226
L8224:
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L8223
L8225:
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
L8226:
L8223:
    jmp       L8209
L8227:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L8209
L8228:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    sub       %rsp,	32
    call      cc_blockpcl.gcomparejump
    add       %rsp,	48
    jmp       L8209
L8229:
    jmp       L8231
L8230:
    mov       %rcx,	%rdi
    call      cc_blockpcl.do_stmt
    mov       %rdi,	%rbx
L8231:
    test      %rdi,	%rdi
    jz        L8233
    mov       %rax,	[%rdi+8]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L8230
L8233:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L8209
L8211:
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r14
    call      pc_api.genlabel
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_libpcl.setmode_u
L8209:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.gcomparejump
cc_blockpcl.gcomparejump:
#?>>
    .set cc_blockpcl.gcomparejump.lab, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    movsxd    %rax,	dword ptr[%rsi+40]
    mov       %rcx,	%rax
    call      cc_blockpcl.getpclcond
    mov       %rdi,	%rax
    cmp       %rbx,	28
    jnz       L8236
    mov       %rcx,	%rdi
    call      cc_blockpcl.reversecond
    mov       %rdi,	%rax
L8236:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	[%rbp + cc_blockpcl.gcomparejump.lab]
    call      pc_api.genlabel
    mov       %rcx,	26
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %al,	%dil
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.getpclcond
cc_blockpcl.getpclcond:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	33
    jz        L8239
    cmp       %rax,	34
    jz        L8240
    cmp       %rax,	35
    jz        L8241
    cmp       %rax,	36
    jz        L8242
    cmp       %rax,	38
    jz        L8243
    cmp       %rax,	37
    jz        L8244
    jmp       L8245
L8239:
    mov       %rax,	1
    jmp       L8237
L8240:
    mov       %rax,	2
    jmp       L8237
L8241:
    mov       %rax,	3
    jmp       L8237
L8242:
    mov       %rax,	4
    jmp       L8237
L8243:
    mov       %rax,	5
    jmp       L8237
L8244:
    mov       %rax,	6
    jmp       L8237
L8245:
L8238:
    xor       %eax,	%eax
L8237:
#---------------
    ret       
# End 
# Proc cc_blockpcl.reversecond
cc_blockpcl.reversecond:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L8248
    cmp       %rax,	2
    jz        L8249
    cmp       %rax,	3
    jz        L8250
    cmp       %rax,	4
    jz        L8251
    cmp       %rax,	5
    jz        L8252
    cmp       %rax,	6
    jz        L8253
    jmp       L8254
L8248:
    mov       %rax,	2
    mov       %rcx,	%rax
    jmp       L8247
L8249:
    mov       %rax,	1
    mov       %rcx,	%rax
    jmp       L8247
L8250:
    mov       %rax,	5
    mov       %rcx,	%rax
    jmp       L8247
L8251:
    mov       %rax,	6
    mov       %rcx,	%rax
    jmp       L8247
L8252:
    mov       %rax,	3
    mov       %rcx,	%rax
    jmp       L8247
L8253:
    mov       %rax,	4
    mov       %rcx,	%rax
L8254:
L8247:
    mov       %rax,	%rcx
L8246:
#---------------
    ret       
# End 
# Proc cc_blockpcl.genjumpl
cc_blockpcl.genjumpl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	24
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_while
cc_blockpcl.do_while:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jnz       L8258
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jz        L8258
    mov       %rcx,	%r13
    call      cc_blockpcl.do_while1
    jmp       L8256
L8258:
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r13
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	27
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
L8256:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_while1
cc_blockpcl.do_while1:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_dowhile
cc_blockpcl.do_dowhile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%r13
    call      cc_parse.iscondfalse
    test      %rax,	%rax
    jnz       L8262
    mov       %rcx,	27
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
L8262:
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.stacklooplabels
cc_blockpcl.stacklooplabels:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+cc_blockpcl.loopindex]
    mov       %rax,	[%rip+cc_blockpcl.loopindex]
    mov       %r10,	%rcx
    lea       %r11,	[%rip+cc_blockpcl.continuestack]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rax,	%rdx
    lea       %r10,	[%rip+cc_blockpcl.breakstack]
    mov       %r11,	[%rip+cc_blockpcl.loopindex]
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_return
cc_blockpcl.do_return:
#?>>
    .set cc_blockpcl.do_return.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    test      %rdi,	%rdi
    jz        L8266
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	3
    and       %eax,	1
    test      %rax,	%rax
    jz        L8268
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	32
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8267
L8268:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      pc_api.genlabel
    mov       %rcx,	29
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode_u
L8267:
    jmp       L8265
L8266:
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      cc_blockpcl.genjumpl
L8265:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_call
cc_blockpcl.dx_call:
#?>>
    .set cc_blockpcl.dx_call.b, 88
    .set cc_blockpcl.dx_call.res, 96
    .set cc_blockpcl.dx_call.retmode, -8
    .set cc_blockpcl.dx_call.m, -16
    .set cc_blockpcl.dx_call.nvariadics, -24
    .set cc_blockpcl.dx_call.nfixedparams, -32
    .set cc_blockpcl.dx_call.isfn, -40
    .set cc_blockpcl.dx_call.paramlist, -552
    .set cc_blockpcl.dx_call.paramconst, -616
    .set cc_blockpcl.dx_call.argattr, -680
    .set cc_blockpcl.dx_call.iparams, -688
    .set cc_blockpcl.dx_call.fparams, -696
    .set cc_blockpcl.dx_call.q, -704
    .set cc_blockpcl.dx_call.i, -712
    .set cc_blockpcl.dx_call.$T1, -720
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	760
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+88],	%r8
    mov       [%rbp+96],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r13+52]
    mov       [%rbp + cc_blockpcl.dx_call.retmode],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.retmode]
    test      %rax,	%rax
    jnz       L8271
    mov       %rax,	3
    mov       [%rbp + cc_blockpcl.dx_call.retmode],	%rax
L8271:
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	52
    jnz       L8274
L8273:
    movsxd    %rax,	dword ptr[%r14+52]
    mov       [%rbp + cc_blockpcl.dx_call.m],	%rax
    jmp       L8276
L8275:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_blockpcl.dx_call.m],	%rax
L8276:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jz        L8275
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    mov       %rdi,	[%rax + %r10*8]
    mov       %rbx,	1
    jmp       L8272
L8274:
    mov       %rax,	[%r14]
    mov       %rdi,	[%rax+80]
    xor       %rbx,	%rbx
    mov       %rax,	[%r14]
    movzx     %rax,	word ptr[%rax+102]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
L8272:
    movsx     %rax,	word ptr[%rdi+22]
    cmp       %rax,	3
    setz      %al
    movzx     %eax,	%al
    mov       %rsi,	%rax
    movsx     %rax,	word ptr[%rdi+20]
    mov       [%rbp + cc_blockpcl.dx_call.nfixedparams],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.nvariadics],	%rax
    mov       %r12,	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.b]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    jmp       L8281
L8278:
    cmp       %r12,	64
    jl        L8283
    lea       %rcx,	[%rip+L11387]
    xor       %edx,	%edx
    call      cc_support.gerror
L8283:
    inc       %r12
    mov       %rax,	%r12
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.q]
    mov       [%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8],	%r10
    xor       %eax,	%eax
    mov       [%rbp + %r12 + cc_blockpcl.dx_call.paramconst-1],	%al
    test      %rsi,	%rsi
    jz        L8285
    cmp       %r12,	[%rbp + cc_blockpcl.dx_call.nfixedparams]
    jle       L8285
    cmp       %r12,	4
    jg        L8285
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    test      %rax,	%rax
    jnz       L8285
    mov       [%rbp + cc_blockpcl.dx_call.nvariadics],	%r12
L8285:
    cmp       %r12,	[%rbp + cc_blockpcl.dx_call.nfixedparams]
    jg        L8287
    movsxd    %rax,	dword ptr[%rdi+16]
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r10b,	[%r10 + %rax]
    mov       [%rbp + %r12 + cc_blockpcl.dx_call.paramconst-1],	%r10b
    mov       %rdi,	[%rdi+8]
L8287:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
L8281:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    test      %rax,	%rax
    jnz       L8278
    mov       %rcx,	131
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_libpcl.setmode_u
    mov       %eax,	%r12d
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.fparams],	%rax
    mov       [%rbp + cc_blockpcl.dx_call.iparams],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %r12,	1
    jl        L8290
L8288:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %rax,	[%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    movsxd    %rax,	dword ptr[%rax+52]
    cmp       %rax,	10
    jz        L8293
    cmp       %rax,	11
    jnz       L8292
L8293:
    inc       qword ptr[%rbp + cc_blockpcl.dx_call.fparams]
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.fparams]
    neg       %rax
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.i]
    mov       [%rbp + %r10 + cc_blockpcl.dx_call.argattr-1],	%al
    jmp       L8291
L8292:
    inc       qword ptr[%rbp + cc_blockpcl.dx_call.iparams]
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.iparams]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.i]
    mov       [%rbp + %r10 + cc_blockpcl.dx_call.argattr-1],	%al
L8291:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %rax,	%r12
    jle       L8288
L8290:
    mov       [%rbp + cc_blockpcl.dx_call.i],	%r12
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    cmp       %rax,	1
    jl        L8296
L8294:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %rax,	[%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.dx_call.q]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    test      %rax,	%rax
    jz        L8298
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    cmp       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    jl        L8298
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    cmp       %rax,	1
    jnz       L8298
    mov       %rcx,	115
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %al,	2
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+3],	%al
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+28]
    mov       %r10d,	1
    mov       %r15d,	[%rax]
    mov       %r11,	-256
    and       %r15d,	%r11d
    or        %r15d,	%r10d
    mov       [%rax],	%r15d
L8298:
    mov       %rcx,	132
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rbp + cc_blockpcl.dx_call.q]
    call      cc_libpcl.setmode_u
    mov       %eax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    movsx     %rax,	byte ptr[%rbp + %rax + cc_blockpcl.dx_call.argattr-1]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    dec       %rax
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %rax,	1
    jge       L8294
L8296:
    test      %rbx,	%rbx
    jnz       L8300
    mov       %rax,	[%r14]
    mov       %rcx,	%rax
    call      cc_libpcl.genmemaddr_d
    mov       [%rbp + cc_blockpcl.dx_call.$T1],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L8302
    mov       %rax,	21
    jmp       L8301
L8302:
    mov       %rax,	18
L8301:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_blockpcl.dx_call.$T1]
    call      pc_api.pc_gen
    jmp       L8299
L8300:
    mov       %rax,	[%r14+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L8304
    mov       %rax,	22
    jmp       L8303
L8304:
    mov       %rax,	19
L8303:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
L8299:
    mov       %eax,	%r12d
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L8306
    mov       %rcx,	%r13
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.res]
    test      %rax,	%rax
    jnz       L8308
    mov       %rcx,	11
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L8307
L8308:
    mov       %rcx,	%r13
    call      cc_blockpcl.widen
L8307:
L8306:
#---------------
    add       %rsp,	760
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_decl
cc_blockpcl.do_decl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	[%rbx+72]
    mov       %al,	1
    mov       [%rbx+122],	%al
    mov       %rax,	[%rbx+56]
    test      %rax,	%rax
    jz        L8311
    mov       %rax,	[%rbx+56]
    mov       %r10b,	1
    mov       [%rax+92],	%r10b
L8311:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	28
    jz        L8313
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	17
    jnz       L8315
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jz        L8316
L8315:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rbx
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L8309
L8313:
#cc_blockpcl.do_decl.copyl:
L8316:
    mov       %rax,	[%rbx+114]
    mov       %rcx,	%rax
    call      pc_api.genmem
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rbx
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
L8309:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_for
cc_blockpcl.do_for:
#?>>
    .set cc_blockpcl.do_for.pbody, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
#---------------
    mov       %rdi,	[%r15+8]
    mov       %rbx,	[%rdi+8]
    call      cc_libpcl.createfwdlabel
    mov       %r12,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r13,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r14,	%rax
    movsxd    %rax,	dword ptr[%r15+40]
    cmp       %rax,	2
    jz        L8319
    mov       %rcx,	%r15
    call      cc_blockpcl.do_stmt
L8319:
    mov       %rcx,	%r14
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.do_for.pbody]
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%r12
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%r14
    call      cc_libpcl.definefwdlabel
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	2
    jz        L8321
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    jmp       L8320
L8321:
    mov       %rcx,	%rsi
    call      cc_blockpcl.genjumpl
L8320:
    mov       %rcx,	%r13
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_preincr
cc_blockpcl.do_preincr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.setincrstep
cc_blockpcl.setincrstep:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	1
    call      pc_api.pc_setincr
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L8325
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      pc_api.pc_setincr
L8325:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_preincrx
cc_blockpcl.dx_preincrx:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	71
    jnz       L8328
    mov       %rax,	86
    jmp       L8327
L8328:
    mov       %rax,	87
L8327:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_postincrx
cc_blockpcl.dx_postincrx:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	73
    jnz       L8331
    mov       %rax,	88
    jmp       L8330
L8331:
    mov       %rax,	89
L8330:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_dot
cc_blockpcl.dx_dot:
#?>>
    .set cc_blockpcl.dx_dot.b, 56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r9
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    test      %rsi,	%rsi
    jnz       L8334
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	2
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_blockpcl.widen
    jmp       L8333
L8334:
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
L8333:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_eq
cc_blockpcl.dx_eq:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	31
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+40]
    mov       %rcx,	%rax
    call      cc_blockpcl.getpclcond
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rcx,	%rbx
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_labeldef
cc_blockpcl.do_labeldef:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+88]
    cmp       %rax,	0
    jg        L8338
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+88],	%eax
L8338:
    mov       %rcx,	[%rdi]
    call      pc_api.gencomment
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_goto
cc_blockpcl.do_goto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+88]
    test      %rax,	%rax
    jnz       L8341
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L11388]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
    jmp       L8340
L8341:
    movsxd    %rax,	dword ptr[%rdi+88]
    cmp       %rax,	0
    jge       L8342
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+88],	%eax
L8342:
L8340:
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	24
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ifx
cc_blockpcl.dx_ifx:
#?>>
    .set cc_blockpcl.dx_ifx.c, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       %rsi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    test      %rsi,	%rsi
    jz        L8345
    mov       %rcx,	117
    xor       %edx,	%edx
    call      pc_api.pc_gen
L8345:
    mov       %rcx,	28
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%r14
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L8347
    mov       %rcx,	118
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
L8347:
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	[%rbp + cc_blockpcl.dx_ifx.c]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L8349
    mov       %rcx,	119
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
L8349:
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_casestmt
cc_blockpcl.do_casestmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    test      %rax,	%rax
    jnz       L8352
    mov       %rax,	[%rsi]
    sub       %rax,	[%rip+cc_blockpcl.sw_lower]
    mov       %r10,	[%rip+cc_blockpcl.sw_labeltable]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       %rcx,	%r10
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8351
L8352:
    mov       %rdi,	[%rsi]
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    cmp       %rax,	1
    jl        L8356
L8353:
    mov       %rax,	[%rip+cc_blockpcl.sw_valuetable]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    cmp       %rax,	%rdi
    jnz       L8358
    mov       %rax,	[%rip+cc_blockpcl.sw_labeltable]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L8355
L8358:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_blockpcl.sw_ncases]
    jle       L8353
L8356:
    lea       %rcx,	[%rip+L11389]
    xor       %edx,	%edx
    call      cc_support.gerror
L8355:
L8351:
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_switch
cc_blockpcl.do_switch:
#?>>
    .set cc_blockpcl.do_switch.a, 80
    .set cc_blockpcl.do_switch.b, 88
    .set cc_blockpcl.do_switch.labeltable, -2000
    .set cc_blockpcl.do_switch.valuetable, -4000
    .set cc_blockpcl.do_switch.flags, -4504
    .set cc_blockpcl.do_switch.value, -4512
    .set cc_blockpcl.do_switch.ncases, -4520
    .set cc_blockpcl.do_switch.serialsw, -4528
    .set cc_blockpcl.do_switch.i, -4536
    .set cc_blockpcl.do_switch.index, -4544
    .set cc_blockpcl.do_switch.pcase, -4552
    .set cc_blockpcl.do_switch.old_labeltable, -4560
    .set cc_blockpcl.do_switch.old_valuetable, -4568
    .set cc_blockpcl.do_switch.old_ncases, -4576
    .set cc_blockpcl.do_switch.old_lower, -4584
    .set cc_blockpcl.do_switch.old_defaultseen, -4592
    .set cc_blockpcl.do_switch.old_defaultlabel, -4600
    .set cc_blockpcl.do_switch.old_breaklabel, -4608
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	4648
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	[%r15]
    mov       [%rbp + cc_blockpcl.do_switch.pcase],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       [%rbp + cc_blockpcl.do_switch.ncases],	%rax
    jmp       L8361
L8360:
    inc       qword ptr[%rbp + cc_blockpcl.do_switch.ncases]
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	500
    jle       L8364
    lea       %rcx,	[%rip+L11390]
    xor       %edx,	%edx
    call      cc_support.gerror
L8364:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_blockpcl.do_switch.value],	%rax
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.ncases]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.valuetable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jnz       L8366
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.value]
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L8365
L8366:
    mov       %rax,	%r12
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.value]
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       %r12,	%rax
    mov       %rax,	%r13
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.value]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r13,	%rax
L8365:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_blockpcl.do_switch.pcase],	%rax
L8361:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    test      %rax,	%rax
    jnz       L8360
    mov       %rax,	[%r15]
    test      %rax,	%rax
    jz        L8368
    mov       %rax,	%r13
    sub       %rax,	%r12
    inc       %rax
    mov       %r14,	%rax
    jmp       L8367
L8368:
    xor       %r14,	%r14
L8367:
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    cmp       %r14,	500
    jg        L8371
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	8
    jg        L8370
L8371:
    mov       %al,	1
    mov       [%rbp + cc_blockpcl.do_switch.serialsw],	%al
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.a]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jl        L8374
L8372:
    call      cc_libpcl.createfwdlabel
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.i]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	26
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %al,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jge       L8376
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
L8376:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jle       L8372
L8374:
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    jmp       L8369
L8370:
    test      %r14,	%r14
    jnz       L8377
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    jmp       L8369
L8377:
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.do_switch.serialsw],	%al
    lea       %rcx,	[%rbp + cc_blockpcl.do_switch.flags]
    xor       %edx,	%edx
    mov       %r8,	%r14
    call      memset
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %r14,	1
    jl        L8380
L8378:
    mov       %eax,	%edi
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.i]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	%r14
    jle       L8378
L8380:
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jl        L8383
L8381:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       [%rbp + cc_blockpcl.do_switch.value],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.value]
    sub       %rax,	%r12
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.index],	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.index]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.index]
    mov       %al,	[%rbp + %rax + cc_blockpcl.do_switch.flags-1]
    test      %al,	%al
    jz        L8385
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.value]
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+L11391]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L8385:
    mov       %al,	1
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.index]
    mov       [%rbp + %r10 + cc_blockpcl.do_switch.flags-1],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jle       L8381
L8383:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.a]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    call      pc_api.genlabel
    mov       %rcx,	37
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rax,	%r12
    add       %rax,	%r14
    dec       %rax
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      pc_api.pc_setxy
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	12
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %r14,	1
    jl        L8388
L8386:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	39
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	%r14
    jle       L8386
L8388:
    mov       %rcx,	40
    xor       %edx,	%edx
    call      pc_api.pc_gen
L8369:
    mov       %rax,	[%rip+cc_blockpcl.sw_labeltable]
    mov       [%rbp + cc_blockpcl.do_switch.old_labeltable],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_valuetable]
    mov       [%rbp + cc_blockpcl.do_switch.old_valuetable],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_lower]
    mov       [%rbp + cc_blockpcl.do_switch.old_lower],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    mov       [%rbp + cc_blockpcl.do_switch.old_ncases],	%rax
    mov       %al,	[%rip+cc_blockpcl.sw_defaultseen]
    mov       [%rbp + cc_blockpcl.do_switch.old_defaultseen],	%al
    mov       %rax,	[%rip+cc_blockpcl.sw_defaultlabel]
    mov       [%rbp + cc_blockpcl.do_switch.old_defaultlabel],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_breaklabel]
    mov       [%rbp + cc_blockpcl.do_switch.old_breaklabel],	%rax
    lea       %rax,	[%rbp + cc_blockpcl.do_switch.labeltable]
    mov       [%rip+cc_blockpcl.sw_labeltable],	%rax
    lea       %rax,	[%rbp + cc_blockpcl.do_switch.valuetable]
    mov       [%rip+cc_blockpcl.sw_valuetable],	%rax
    mov       [%rip+cc_blockpcl.sw_lower],	%r12
    mov       %al,	[%rbp + cc_blockpcl.do_switch.serialsw]
    test      %al,	%al
    jz        L8390
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jmp       L8389
L8390:
    xor       %eax,	%eax
L8389:
    mov       [%rip+cc_blockpcl.sw_ncases],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       [%rip+cc_blockpcl.sw_defaultlabel],	%rdi
    mov       [%rip+cc_blockpcl.sw_breaklabel],	%rbx
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.b]
    call      cc_blockpcl.do_stmt
    mov       %al,	[%rip+cc_blockpcl.sw_defaultseen]
    test      %al,	%al
    jnz       L8392
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
L8392:
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_labeltable]
    mov       [%rip+cc_blockpcl.sw_labeltable],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_valuetable]
    mov       [%rip+cc_blockpcl.sw_valuetable],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_lower]
    mov       [%rip+cc_blockpcl.sw_lower],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_ncases]
    mov       [%rip+cc_blockpcl.sw_ncases],	%rax
    mov       %al,	[%rbp + cc_blockpcl.do_switch.old_defaultseen]
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_defaultlabel]
    mov       [%rip+cc_blockpcl.sw_defaultlabel],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_breaklabel]
    mov       [%rip+cc_blockpcl.sw_breaklabel],	%rax
#---------------
    add       %rsp,	4648
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_andorl
cc_blockpcl.dx_andorl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    mov       %rcx,	117
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	28
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    mov       %rcx,	1
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	118
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rsi+16]
    call      cc_libpcl.setmode_u
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	119
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rsi+16]
    call      cc_libpcl.setmode_u
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_scale
cc_blockpcl.dx_scale:
#?>>
    .set cc_blockpcl.dx_scale.b, 56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rbx+48]
    cmp       %rax,	0
    jl        L8396
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	4
    call      cc_libpcl.setmode
    mov       %rcx,	45
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L8395
L8396:
    movsxd    %rax,	dword ptr[%rbx+48]
    neg       %rax
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	4
    call      cc_libpcl.setmode
    mov       %rcx,	47
    xor       %edx,	%edx
    call      pc_api.pc_gen
L8395:
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.widen
cc_blockpcl.widen:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsx     %rax,	word ptr[%rbx+56]
    test      %rax,	%rax
    jnz       L8399
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L8397
L8399:
    mov       %rcx,	%rbx
    call      cc_parse.getmemmode
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L8401
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	1
    jz        L8402
    cmp       %rax,	2
    jz        L8402
    cmp       %rax,	3
    jz        L8402
    cmp       %rax,	86
    jz        L8402
    cmp       %rax,	87
    jz        L8402
    cmp       %rax,	88
    jz        L8402
    cmp       %rax,	89
    jz        L8402
    cmp       %rax,	21
    jnz       L8401
L8402:
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L8405
    cmp       %rax,	2
    jnz       L8404
L8405:
    mov       %rax,	3
    jmp       L8403
L8404:
    mov       %rax,	8
L8403:
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode2
L8401:
L8397:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_setinplace
cc_blockpcl.do_setinplace:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	1
    jnz       L8408
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	2
    jnz       L8408
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
L8408:
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_fixwiden
cc_blockpcl.do_fixwiden:
#?>>
    .set cc_blockpcl.do_fixwiden.a, 16
    .set cc_blockpcl.do_fixwiden.b, 24
#?]]
#---------------
L8409:
#---------------
    ret       
# End 
# Proc cc_libpcl.getpsymbol
cc_libpcl.getpsymbol:
#?>>
    .set cc_libpcl.getpsymbol.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L8412
    xor       %eax,	%eax
    jmp       L8410
L8412:
    mov       %rax,	[%rsi+56]
    test      %rax,	%rax
    jz        L8414
    mov       %rax,	[%rsi+56]
    jmp       L8410
L8414:
    mov       %rbx,	[%rsi]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	8
    jz        L8417
    cmp       %rax,	9
    jnz       L8416
L8417:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
    movzx     %rax,	word ptr[%rsi+96]
    cmp       %rax,	1
    jle       L8419
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L11392]
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
L8419:
    jmp       L8415
L8416:
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	7
    jnz       L8420
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jz        L8420
    mov       %rax,	[%rsi+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jnz       L8420
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L11392]
    call      strcat
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    cmp       %rax,	1
    jle       L8422
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L11392]
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
L8422:
    jmp       L8415
L8420:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
L8415:
    movzx     %rax,	byte ptr[%rsi+109]
    lea       %r10,	[%rip+cc_tables.name2pid]
    movzx     %r10,	byte ptr[%r10 + %rax]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%r10
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       [%rsi+56],	%rax
    movzx     %rax,	word ptr[%rsi+102]
    mov       %rcx,	%rax
    call      cc_lib.getpclmode
    mov       [%rdi+82],	%al
    movzx     %rax,	word ptr[%rsi+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdi+84],	%r10d
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jz        L8424
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jz        L8424
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      cc_libpcl.getpsymbol
    mov       [%rdi+32],	%rax
L8424:
    movzx     %rax,	byte ptr[%rsi+110]
    cmp       %rax,	4
    jnz       L8426
    mov       %al,	1
    mov       [%rdi+81],	%al
L8426:
    movzx     %rax,	byte ptr[%rsi+110]
    cmp       %rax,	3
    jnz       L8428
    mov       %al,	1
    mov       [%rdi+80],	%al
    mov       %al,	1
    mov       [%rdi+72],	%al
L8428:
    mov       %al,	[%rsi+122]
    mov       [%rdi+92],	%al
    mov       %eax,	[%rsi+88]
    mov       [%rdi+100],	%eax
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L8430
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11393]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L8430
    mov       %al,	1
    mov       [%rdi+110],	%al
    lea       %r10,	[%rsi+108]
    and       byte ptr[%r10],	247
    shl       %al,	3
    or        [%r10],	%al
L8430:
    mov       %rax,	%rdi
L8410:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode
cc_libpcl.setmode:
#?>>
    .set cc_libpcl.setmode.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_libpcl.setmode.$T1],	%rax
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_libpcl.setmode.$T1]
    call      pc_api.pc_setmode
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode2
cc_libpcl.setmode2:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    call      pc_api.pc_setmode2
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode_u
cc_libpcl.setmode_u:
#?>>
    .set cc_libpcl.setmode_u.$T1, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_libpcl.setmode_u.$T1],	%rax
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_libpcl.setmode_u.$T1]
    call      pc_api.pc_setmode
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.genmem_d
cc_libpcl.genmem_d:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.genmem
L8434:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.genmemaddr_d
cc_libpcl.genmemaddr_d:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.genmemaddr
L8435:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.definelabel
cc_libpcl.definelabel:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	[%rip+pc_api.mlabelno]
L8436:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_libpcl.createfwdlabel
cc_libpcl.createfwdlabel:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
L8437:
#---------------
    ret       
# End 
# Proc cc_libpcl.definefwdlabel
cc_libpcl.definefwdlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.newstrec
cc_lib.newstrec:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	128
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       %r11,	4
L11394:
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    add       %rax,	32
    dec       %r11
    jnz       L11394
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+92],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+113],	%al
    mov       %rax,	%rdi
L8439:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.initcclib
cc_lib.initcclib:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc cc_lib.createname
cc_lib.createname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %rax,	%rdi
L8441:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit0
cc_lib.createunit0:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       %rax,	%rdi
L8442:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit1
cc_lib.createunit1:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       %rax,	%rdi
L8443:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit2
cc_lib.createunit2:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       [%rdi+24],	%r12
    mov       %rax,	%rdi
L8444:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit3
cc_lib.createunit3:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       [%rdi+24],	%r12
    mov       [%rdi+32],	%r13
    mov       %rax,	%rdi
L8445:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createconstunit
cc_lib.createconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       [%rdi+52],	%esi
    mov       %rax,	%rdi
L8446:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createstringconstunit
cc_lib.createstringconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %eax,	[%rip+cc_decls.trefchar]
    mov       [%rdi+52],	%eax
    cmp       %rsi,	-1
    jnz       L8449
    mov       %rcx,	%rbx
    call      strlen
    mov       [%rdi+48],	%eax
    jmp       L8448
L8449:
    mov       [%rdi+48],	%esi
L8448:
    mov       %al,	1
    mov       [%rdi+61],	%al
    mov       %rax,	%rdi
L8447:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createwstringconstunit
cc_lib.createwstringconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %eax,	[%rip+cc_decls.trefwchar]
    mov       [%rdi+52],	%eax
    mov       [%rdi+48],	%esi
    mov       %al,	1
    mov       [%rdi+62],	%al
    mov       %rax,	%rdi
L8450:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getoptocode
cc_lib.getoptocode:
#?>>
    .set cc_lib.getoptocode.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%rip+cc_lib.getoptocode.opctotable]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L8453
    mov       %rax,	%rdi
    jmp       L8451
L8453:
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rbp + cc_lib.getoptocode.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + cc_lib.getoptocode.str]
    lea       %rdx,	[%rip+L11395]
    call      strcat
    xor       %rbx,	%rbx
    mov       %rax,	77
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jl        L8456
L8454:
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_lib.getoptocode.str]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L8458
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_lib.getoptocode.opctotable]
    mov       %r11,	%r12
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rbx
    jmp       L8451
L8458:
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L8454
L8456:
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11396]
    call      cc_support.serror
    xor       %eax,	%eax
L8451:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getconstvalue
cc_lib.getconstvalue:
#?>>
    .set cc_lib.getconstvalue.id, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L8461
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L8461
    mov       %rax,	[%rdi]
    jmp       L8459
L8461:
    lea       %rcx,	[%rip+L11397]
    call      cc_support.serror
    xor       %eax,	%eax
L8459:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.nextautotype
cc_lib.nextautotype:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+cc_lib.nextautotype.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11398]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[%rip+cc_lib.autotypeno]
    mov       %rcx,	[%rip+cc_lib.autotypeno]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_lib.nextautotype.str]
L8462:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lib.createconstmode
cc_lib.createconstmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L8465
    mov       %rax,	%rbx
    jmp       L8463
L8465:
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L8467
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    jmp       L8463
L8467:
    mov       %rcx,	%rbx
    call      cc_lib.copymode
    mov       %rdi,	%rax
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*2],	%ax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rdi
L8463:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createrefmode
cc_lib.createrefmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L8470
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttshared]
    lea       %r10,	[%r10 + %rax*4]
    inc       dword ptr[%r10]
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    jmp       L8468
L8470:
    mov       %rcx,	13
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttreftype]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*2],	%ax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L8468:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createprocmode
cc_lib.createprocmode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	14
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.ttparams]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rdi
L8471:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createarraymode
cc_lib.createarraymode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	17
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	%rsi
    imul      %r10,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r11,	%rdi
    mov       [%rax + %r11*8],	%r10
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L8472:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createenummode
cc_lib.createenummode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	12
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
L8473:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createstructmode
cc_lib.createstructmode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rsi
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L8474:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.setnameptr
cc_lib.setnameptr:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    mov       %r10,	%rcx
    mov       [%rax+72],	%r10
#---------------
    ret       
# End 
# Proc cc_lib.getautofieldname
cc_lib.getautofieldname:
#?>>
    .set cc_lib.getautofieldname.str, -32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
    lea       %rcx,	[%rbp + cc_lib.getautofieldname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11399]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[%rip+cc_lib.nextafindex]
    mov       %rcx,	[%rip+cc_lib.nextafindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_lib.getautofieldname.str]
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_lex.addnamestr
L8476:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lib.convertstringc
cc_lib.convertstringc:
#?>>
    .set cc_lib.convertstringc.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L8479
    mov       %rcx,	%r12
    call      strlen
    mov       %r14,	%rax
L8479:
    mov       %rbx,	%r13
    mov       %rsi,	%r14
    cmp       %rsi,	0
    jle       L8482
L8480:
    mov       %rax,	%r12
    inc       %r12
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    lea       %rax,	[%rdi-7]
    cmp       %rax,	86
    jae       L8485
    lea       %r10,	[%rip+L8484]
    jmp       [%r10 + %rax*8]
    .data
L8484:
    .quad     L8492
    .quad     L8493
    .quad     L8490
    .quad     L8488
    .quad     L8495
    .quad     L8494
    .quad     L8489
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8486
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8487
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8485
    .quad     L8491
    .text
L8486:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L8483
L8487:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	39
    mov       [%rax],	%r10b
    jmp       L8483
L8488:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L8483
L8489:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L8483
L8490:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L8483
L8491:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L8483
L8492:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	97
    mov       [%rax],	%r10b
    jmp       L8483
L8493:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	98
    mov       [%rax],	%r10b
    jmp       L8483
L8494:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	102
    mov       [%rax],	%r10b
    jmp       L8483
L8495:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	118
    mov       [%rax],	%r10b
    jmp       L8483
L8485:
    cmp       %rdi,	32
    jl        L8498
    cmp       %rdi,	127
    jl        L8497
L8498:
    lea       %rcx,	[%rbp + cc_lib.convertstringc.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11400]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11401]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + cc_lib.convertstringc.str]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+1]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+2]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+3]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    jmp       L8496
L8497:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
L8496:
L8483:
    dec       %rsi
    jnz       L8480
L8482:
    xor       %eax,	%eax
    mov       [%r13],	%al
    mov       %rax,	%r13
    sub       %rax,	%rbx
L8477:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getopcjname
cc_lib.getopcjname:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8]
    mov       %rcx,	%rdi
    mov       %rdx,	32
    call      strchr
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L8501
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    lea       %rcx,	[%rip+cc_lib.getopcjname.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_lib.getopcjname.str]
    mov       [%r11 + %rax],	%r10b
    lea       %rax,	[%rip+cc_lib.getopcjname.str]
    jmp       L8500
L8501:
    mov       %rax,	%rdi
L8500:
L8499:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.strmode
cc_lib.strmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rip+cc_lib.strmode.str]
    call      cc_lib.istrmode
    lea       %rax,	[%rip+cc_lib.strmode.str]
L8502:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.strmode2
cc_lib.strmode2:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rip+cc_lib.strmode2.str]
    call      cc_lib.istrmode
    lea       %rax,	[%rip+cc_lib.strmode2.str]
L8503:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.istrmode
cc_lib.istrmode:
#?>>
    .set cc_lib.istrmode.expand, 80
    .set cc_lib.istrmode.dest, 88
    .set cc_lib.istrmode.n, -8
    .set cc_lib.istrmode.sxx, -24
    .set cc_lib.istrmode.xx, -32
    .set cc_lib.istrmode.pm, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rbp + cc_lib.istrmode.sxx]
    mov       [%rbp + cc_lib.istrmode.xx],	%rax
    cmp       %r15,	21
    jge       L8506
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L8504
L8506:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	13
    jz        L8508
    cmp       %rax,	17
    jz        L8509
    cmp       %rax,	12
    jz        L8510
    cmp       %rax,	18
    jz        L8511
    cmp       %rax,	19
    jz        L8511
    test      %rax,	%rax
    jz        L8512
    cmp       %rax,	14
    jz        L8513
    jmp       L8514
L8508:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L8516
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11402]
    call      strcpy
    jmp       L8515
L8516:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11403]
    call      strcpy
L8515:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
    cmp       %r13,	0
    jl        L8518
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	18
    jnz       L8518
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    jmp       L8517
L8518:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
L8517:
    jmp       L8507
L8509:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L8520
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11404]
    call      msys.m$print_setfmt
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8519
L8520:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11405]
    call      strcpy
L8519:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    jmp       L8507
L8510:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11406]
    call      strcpy
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    jmp       L8507
L8511:
    mov       %rax,	[%rbp + cc_lib.istrmode.expand]
    test      %rax,	%rax
    jnz       L8522
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L8504
L8522:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11407]
    call      strcat
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%r15
    mov       %rdi,	[%rax + %r10*8]
    xor       %rsi,	%rsi
    mov       %rax,	[%rdi+16]
    mov       %rbx,	%rax
    jmp       L8524
L8523:
    test      %rsi,	%rsi
    jz        L8527
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11408]
    call      strcat
L8527:
    mov       %rsi,	1
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11409]
    call      strcat
    mov       %rax,	[%rbx]
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    mov       %rbx,	[%rbx+32]
L8524:
    test      %rbx,	%rbx
    jnz       L8523
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11410]
    call      strcat
    jmp       L8507
L8512:
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L8507
L8513:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11411]
    call      strcpy
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_lib.istrmode.pm],	%rax
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    movsx     %rax,	word ptr[%rax+20]
    mov       [%rbp + cc_lib.istrmode.n],	%rax
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_lib.istrmode.n]
    cmp       %rax,	1
    jl        L8530
L8528:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    cmp       %r12,	[%rbp + cc_lib.istrmode.n]
    jz        L8532
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11412]
    call      strcat
L8532:
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lib.istrmode.pm],	%rax
    inc       %r12
    cmp       %r12,	[%rbp + cc_lib.istrmode.n]
    jle       L8528
L8530:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L11413]
    call      strcat
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    jmp       L8507
L8514:
    cmp       %r14,	21
    jge       L8534
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L8504
L8534:
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11414]
    call      cc_support.mcerror
L8533:
L8507:
L8504:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.typename
cc_lib.typename:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	18
    jz        L8537
    cmp       %rax,	19
    jz        L8537
    cmp       %rax,	17
    jz        L8538
    cmp       %rax,	12
    jz        L8539
    jmp       L8540
L8537:
    cmp       %rdi,	18
    jnz       L8542
    lea       %rax,	[%rip+L11415]
    jmp       L8541
L8542:
    lea       %rax,	[%rip+L11416]
L8541:
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L8544
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+cc_lib.typename.str]
    lea       %rdx,	[%rip+L11417]
    call      strcat
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    movzx     %rax,	word ptr[%rax+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
L8544:
    lea       %rax,	[%rip+cc_lib.typename.str]
    jmp       L8535
L8538:
    lea       %rax,	[%rip+L11418]
    jmp       L8535
L8539:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L8546
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    jmp       L8535
L8546:
    lea       %rax,	[%rip+L11419]
    jmp       L8535
L8540:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L8548
    lea       %rcx,	[%rip+cc_lib.typename.str]
    lea       %rdx,	[%rip+L11420]
    call      strcpy
    lea       %rax,	[%rip+cc_tables.stdtypenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+cc_lib.typename.str]
    jmp       L8535
L8548:
    lea       %rax,	[%rip+cc_tables.stdtypenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    jmp       L8535
L8536:
    lea       %rax,	[%rip+L11421]
L8535:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.allocunitrec
cc_lib.allocunitrec:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    inc       qword ptr[%rip+cc_decls.nunits]
    mov       %rax,	[%rip+cc_lib.remainingunits]
    dec       qword ptr[%rip+cc_lib.remainingunits]
    test      %rax,	%rax
    jz        L8551
    mov       %rdi,	[%rip+cc_lib.unitheapptr]
    add       qword ptr[%rip+cc_lib.unitheapptr],	64
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    cmp       %rax,	255
    jg        L8553
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+60],	%al
L8553:
    mov       %rax,	%rdi
    jmp       L8549
L8551:
    mov       %rcx,	3200000
    call      mlib.pcm_alloc
    mov       [%rip+cc_lib.unitheapptr],	%rax
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	3200000
    call      memset
    mov       %rax,	49999
    mov       [%rip+cc_lib.remainingunits],	%rax
    add       qword ptr[%rip+cc_lib.unitheapptr],	64
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    cmp       %rax,	255
    jg        L8555
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+60],	%al
L8555:
    mov       %rax,	%rdi
L8549:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.copymode
cc_lib.copymode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	80000
    jl        L8558
    lea       %rcx,	[%rip+L11422]
    call      cc_support.serror
L8558:
    inc       qword ptr[%rip+cc_decls.ntypes]
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    mov       %ax,	[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    mov       %ax,	[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttparams]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+cc_decls.ttisblock]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rip+cc_decls.ntypes]
L8556:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewmode
cc_lib.createnewmode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	80000
    jl        L8561
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11423]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11424]
    call      cc_support.serror
L8561:
    inc       qword ptr[%rip+cc_decls.ntypes]
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	[%rip+cc_decls.ntypes]
L8559:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.addlistunit
cc_lib.addlistunit:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L8564
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L8563
L8564:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L8563:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistdef
cc_lib.addlistdef:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L8567
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L8566
L8567:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+32],	%r10
L8566:
    xor       %eax,	%eax
    mov       [%r8+32],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistparam
cc_lib.addlistparam:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L8570
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L8569
L8570:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L8569:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.checksymbol
cc_lib.checksymbol:
#?>>
    .set cc_lib.checksymbol.str, -256
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	%rdi
    jz        L8573
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11425]
    call      msys.m$print_setfmt
    lea       %rax,	[%rip+cc_tables.symbolnames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L8575
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    lea       %rdx,	[%rip+L11426]
    call      strcat
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      cc_lib.getstname
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    lea       %rdx,	[%rip+L11427]
    call      strcat
L8575:
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    call      cc_support.serror
L8573:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lib.skipsymbol
cc_lib.skipsymbol:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	%rdi
    jz        L8578
    mov       %rcx,	%rdi
    call      cc_lib.checksymbol
L8578:
    call      cc_lex.lex
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.inittypetables
cc_lib.inittypetables:
#?>>
    .set cc_lib.inittypetables.av_2, -8
    .set cc_lib.inittypetables.av_3, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	20
    mov       %r15,	%rax
    cmp       %r15,	0
    jl        L8582
L8580:
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_tables.stdtypewidths]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rsi,	%rax
    mov       %rax,	%rsi
    sar       %rax,	3
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
    cmp       %rax,	17
    jz        L8585
    cmp       %rax,	18
    jnz       L8584
L8585:
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L8584:
    inc       %rdi
    cmp       %rdi,	%r15
    jle       L8580
L8582:
    mov       %rax,	20
    mov       [%rip+cc_decls.ntypes],	%rax
    mov       %rcx,	1
    call      cc_lib.createrefmode
    mov       [%rip+cc_decls.trefchar],	%rax
    mov       %rcx,	7
    call      cc_lib.createrefmode
    mov       [%rip+cc_decls.trefwchar],	%rax
    mov       %rdi,	1
    mov       %rax,	121
    mov       [%rbp + cc_lib.inittypetables.av_2],	%rax
    mov       %rax,	[%rbp + cc_lib.inittypetables.av_2]
    cmp       %rax,	1
    jl        L8588
L8586:
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+1]
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+2]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%r12
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10b,	%r14b
    mov       %r11,	%r13
    mov       [%rax + %r11],	%r10b
    inc       %rdi
    cmp       %rdi,	[%rbp + cc_lib.inittypetables.av_2]
    jle       L8586
L8588:
    mov       %rdi,	1
    mov       %rax,	121
    mov       [%rbp + cc_lib.inittypetables.av_3],	%rax
    mov       %rax,	[%rbp + cc_lib.inittypetables.av_3]
    cmp       %rax,	1
    jl        L8591
L8589:
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+1]
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+2]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_tables.conversionops]
    mov       %r10,	%r12
    shl       %r10,	4
    lea       %rax,	[%rax + %r10]
    mov       %r10b,	%r14b
    mov       %r11,	%r13
    mov       [%rax + %r11],	%r10b
    inc       %rdi
    cmp       %rdi,	[%rbp + cc_lib.inittypetables.av_3]
    jle       L8589
L8591:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createdupldef
cc_lib.createdupldef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    call      cc_lib.newstrec
    mov       %rdi,	%rax
    mov       %rax,	[%r12]
    mov       [%rdi],	%rax
    mov       %al,	[%r12+106]
    mov       [%rdi+106],	%al
    mov       %al,	67
    mov       [%rdi+107],	%al
    mov       [%rdi+8],	%rsi
    mov       [%rdi+109],	%r13b
    lea       %rax,	[%rip+cc_tables.namespaces]
    mov       %r10,	%r13
    mov       %eax,	[%rax + %r10*4]
    mov       [%rdi+98],	%ax
    mov       %rax,	[%r12+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L8594
    mov       [%rbx+48],	%rdi
L8594:
    mov       [%rdi+40],	%rbx
    mov       [%rdi+48],	%r12
    mov       [%r12+40],	%rdi
    test      %rsi,	%rsi
    jz        L8596
    mov       %rax,	[%rsi+16]
    test      %rax,	%rax
    jnz       L8598
    mov       %rax,	%rdi
    mov       [%rsi+24],	%rax
    mov       [%rsi+16],	%rax
    jmp       L8597
L8598:
    mov       %rax,	[%rsi+24]
    mov       %r10,	%rdi
    mov       [%rax+32],	%r10
    mov       [%rsi+24],	%rdi
L8597:
L8596:
    mov       %rax,	%rdi
L8592:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewmoduledef
cc_lib.createnewmoduledef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	3
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L8599:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewproc
cc_lib.createnewproc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	6
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rbx,	%rdi
    jmp       L8602
L8601:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L8605
    call      msys.m$print_startcon
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11428]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11429]
    call      cc_support.serror
L8605:
L8602:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L8601
    mov       %rax,	%rdi
L8600:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.resolvename
cc_lib.resolvename:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    movzx     %rax,	byte ptr[%r12+109]
    cmp       %rax,	1
    jle       L8608
    mov       %rax,	%r12
    jmp       L8606
L8608:
    cmp       %r13,	3
    jnz       L8610
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      cc_lib.resolvelabel
    jmp       L8606
L8610:
    test      %r14,	%r14
    jz        L8612
    lea       %rax,	[%rip+cc_decls.blockcounts]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    test      %rax,	%rax
    jnz       L8612
    lea       %rax,	[%rip+cc_decls.blockowner]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r14,	%rax
L8612:
L8613:
    mov       %rax,	%r13
    shl       %rax,	16
    or        %rax,	%r14
    mov       %rdi,	%rax
    mov       %rbx,	%r12
    jmp       L8616
L8615:
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L8619
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jz        L8619
    mov       %rax,	[%rbx+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L8617
L8619:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L8621
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L8621
    movzx     %rax,	byte ptr[%rbx+122]
    cmp       %rax,	255
    jge       L8623
    lea       %rax,	[%rbx+122]
    inc       byte ptr[%rax]
L8623:
    mov       %rax,	%rbx
    jmp       L8606
L8621:
L8616:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L8615
L8617:
    test      %r14,	%r14
    jnz       L8625
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jz        L8627
    cmp       %rax,	13
    jz        L8628
    jmp       L8629
L8627:
    mov       %rsi,	[%rip+cc_decls.stmodule]
    jmp       L8613
L8628:
    mov       %rsi,	[%rsi+8]
    test      %rsi,	%rsi
    jnz       L8631
    xor       %eax,	%eax
    jmp       L8606
L8631:
    jmp       L8626
L8629:
    xor       %eax,	%eax
    jmp       L8606
L8626:
    jmp       L8624
L8625:
    lea       %rax,	[%rip+cc_decls.blockowner]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r14,	%rax
    test      %rax,	%rax
    jnz       L8632
    mov       %rsi,	[%rip+cc_decls.stmodule]
L8632:
L8624:
    jmp       L8613
    xor       %eax,	%eax
L8606:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.resolvelabel
cc_lib.resolvelabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	%rdx
    jmp       L8635
L8634:
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L8638
    mov       %rax,	[%rdi+8]
    cmp       %rax,	%rcx
    jz        L8638
    mov       %rax,	[%rdi+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L8636
L8638:
    mov       %rax,	[%rdi+8]
    cmp       %rax,	%rcx
    jnz       L8640
    movzx     %rax,	word ptr[%rdi+98]
    cmp       %rax,	3
    jnz       L8640
    mov       %rax,	%rdi
    jmp       L8633
L8640:
L8635:
    mov       %rax,	[%rdi+40]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jnz       L8634
L8636:
    xor       %eax,	%eax
L8633:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lib.checkdupl
cc_lib.checkdupl:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %rbx,	%rdx
    mov       %rax,	%r8
    shl       %rax,	16
    or        %rax,	%r9
    mov       %rdi,	%rax
    jmp       L8643
L8642:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rcx
    jnz       L8646
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L8646
    mov       %rax,	%rbx
    jmp       L8641
L8646:
L8643:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L8642
    xor       %eax,	%eax
L8641:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.checkdupl_inproc
cc_lib.checkdupl_inproc:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %rbx,	%rdx
    mov       %rax,	%r8
    shl       %rax,	16
    or        %rax,	%r9
    mov       %rdi,	%rax
    jmp       L8649
L8648:
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L8652
    mov       %rax,	%rbx
    jmp       L8647
L8652:
L8649:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L8653
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rcx
    jz        L8648
L8653:
    xor       %eax,	%eax
L8647:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getalignment
cc_lib.getalignment:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jz        L8656
    cmp       %rax,	18
    jz        L8657
    cmp       %rax,	19
    jz        L8657
    jmp       L8658
L8656:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.getalignment
    jmp       L8654
L8657:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L8660
    mov       %rax,	16
    jmp       L8654
L8660:
    mov       %rax,	%rdi
    jmp       L8654
L8658:
L8655:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8]
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L8662
    cmp       %rax,	2
    jz        L8662
    cmp       %rax,	4
    jz        L8662
    cmp       %rax,	8
    jnz       L8663
L8662:
    mov       %rax,	%rdi
    jmp       L8654
L8663:
L8661:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11430]
    call      cc_support.serror
    xor       %eax,	%eax
L8654:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.isexported
cc_lib.isexported:
#?>>
#?]]
#---------------
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L8666
    mov       %rax,	[%rcx+72]
    test      %rax,	%rax
    jz        L8668
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jz        L8669
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L8668
L8669:
    mov       %rax,	1
    jmp       L8664
L8668:
    jmp       L8665
L8666:
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L8671
    mov       %rax,	1
    jmp       L8664
L8671:
L8665:
    xor       %eax,	%eax
L8664:
#---------------
    ret       
# End 
# Proc cc_lib.isimported
cc_lib.isimported:
#?>>
#?]]
#---------------
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L8674
    mov       %rax,	[%rcx+72]
    test      %rax,	%rax
    jnz       L8676
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jz        L8677
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L8676
L8677:
    mov       %rax,	1
    jmp       L8672
L8676:
    jmp       L8673
L8674:
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jnz       L8679
    mov       %rax,	1
    jmp       L8672
L8679:
L8673:
    xor       %eax,	%eax
L8672:
#---------------
    ret       
# End 
# Proc cc_lib.getstname
cc_lib.getstname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rdi+106]
    mov       %r10,	[%rdi]
    lea       %rcx,	[%rip+cc_lib.getstname.name]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    movzx     %rax,	byte ptr[%rdi+106]
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_lib.getstname.name]
    mov       [%r11 + %rax],	%r10b
    lea       %rax,	[%rip+cc_lib.getstname.name]
L8680:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.isrealcc
cc_lib.isrealcc:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rax,	%rcx
    cmp       %rax,	10
    jl        L8682
    cmp       %rax,	11
    jg        L8682
    mov       %rax,	1
    jmp       L8683
L8682:
    xor       %eax,	%eax
L8683:
L8681:
#---------------
    ret       
# End 
# Proc cc_lib.isintcc
cc_lib.isintcc:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rax,	%rcx
    cmp       %rax,	1
    jl        L8685
    cmp       %rax,	9
    jg        L8685
    mov       %rax,	1
    jmp       L8686
L8685:
    xor       %eax,	%eax
L8686:
L8684:
#---------------
    ret       
# End 
# Proc cc_lib.writegsfile
cc_lib.writegsfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L11431]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    call      mlib.gs_println
    mov       %rcx,	%rdi
    call      fclose
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.pause
cc_lib.pause:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      mwindows.os_getch
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getpclmode
cc_lib.getpclmode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_tables.stdpcl]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rdi,	%r10
    cmp       %rdi,	11
    jnz       L8691
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	8
    jz        L8693
    cmp       %rax,	4
    jz        L8694
    cmp       %rax,	2
    jz        L8695
    cmp       %rax,	1
    jz        L8696
    jmp       L8697
L8693:
    mov       %rdi,	6
    jmp       L8692
L8694:
    mov       %rdi,	5
    jmp       L8692
L8695:
    mov       %rdi,	4
    jmp       L8692
L8696:
    mov       %rdi,	3
L8697:
L8692:
L8691:
    mov       %rax,	%rdi
L8689:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lib.addtolog
cc_lib.addtolog:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L11432]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L8700
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11433]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L8698
L8700:
L8701:
    mov       %rcx,	%rdi
    call      fgetc
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    cmp       %rbx,	-1
    jz        L8702
L8704:
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    call      fputc
    jmp       L8701
L8702:
    mov       %rcx,	%rdi
    call      fclose
L8698:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.stopcompiler
cc_support.stopcompiler:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %al,	[%rip+cc_cli.fwriteerrors]
    test      %al,	%al
    jz        L8707
    lea       %rcx,	[%rip+L11434]
    lea       %rdx,	[%rip+L11435]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      fclose
L8707:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.mcerror
cc_support.mcerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11436]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	40
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror
cc_support.serror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_support.serror_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_gen
cc_support.serror_gen:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L8712
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11437]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11438]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L8711
L8712:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11439]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L8711:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11440]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L11441]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11442]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11443]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    lea       %r10,	[%rip+cc_decls.lx]
    movzx     %r10,	byte ptr[%r10+20]
    lea       %r11,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%r11 + %r10*8]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_ss
cc_support.serror_ss:
#?>>
    .set cc_support.serror_ss.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.serror_ss.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.serror_ss.str]
    call      cc_support.serror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_s
cc_support.serror_s:
#?>>
    .set cc_support.serror_s.str, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.serror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.serror_s.str]
    call      cc_support.serror_gen
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_gen
cc_support.terror_gen:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L8717
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11444]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L8717:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11445]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11446]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    lea       %r10,	[%rip+cc_decls.lx]
    movzx     %r10,	byte ptr[%r10+20]
    lea       %r11,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%r11 + %r10*8]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror
cc_support.terror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_support.terror_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_s
cc_support.terror_s:
#?>>
    .set cc_support.terror_s.str, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.terror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.terror_s.str]
    call      cc_support.terror_gen
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_ss
cc_support.terror_ss:
#?>>
    .set cc_support.terror_ss.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.terror_ss.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.terror_ss.str]
    call      cc_support.terror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror_gen
cc_support.gerror_gen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    test      %r12,	%r12
    jz        L8723
    mov       %eax,	[%r12+44]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%r12+60]
    mov       %rbx,	%rax
    jmp       L8722
L8723:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %rbx,	[%rip+cc_decls.cfileno]
L8722:
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L8725
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11447]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11448]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8725:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11449]
    call      msys.m$print_str_nf
    mov       %rax,	%rdi
    and       %rax,	16777215
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L11450]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11451]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11452]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror
cc_support.gerror:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_support.gerror_gen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror_s
cc_support.gerror_s:
#?>>
    .set cc_support.gerror_s.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.gerror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.gerror_s.str]
    mov       %rdx,	%rsi
    call      cc_support.gerror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.nextpoweroftwo
cc_support.nextpoweroftwo:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    test      %rcx,	%rcx
    jnz       L8730
    xor       %eax,	%eax
    jmp       L8728
L8730:
    mov       %rdi,	1
    jmp       L8732
L8731:
    shl       %rdi,	1
L8732:
    cmp       %rdi,	%rcx
    jl        L8731
    mov       %rax,	%rdi
L8728:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_support.loaderror
cc_support.loaderror:
#?>>
    .set cc_support.loaderror.str, -512
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	544
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.loaderror.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11453]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + cc_support.loaderror.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11454]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	45
    call      exit
#---------------
    add       %rsp,	544
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.loadsourcefile
cc_support.loadsourcefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	200
    jle       L8737
    lea       %rcx,	[%rip+L11455]
    lea       %rdx,	[%rip+L11456]
    call      cc_support.loaderror
L8737:
    inc       qword ptr[%rip+cc_decls.nsourcefiles]
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rsi
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      mlib.readfile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L8739
    lea       %rcx,	[%rip+L11457]
    mov       %rdx,	%rbx
    call      cc_support.loaderror
L8739:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %eax,	[%rip+mlib.rfsize]
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*4],	%eax
    xor       %eax,	%eax
    mov       %r10,	[%rip+mlib.rfsize]
    mov       [%rdi + %r10],	%al
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
L8735:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.splicelines
cc_support.splicelines:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      strlen
    inc       %rax
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    jmp       L8742
L8741:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	92
    jnz       L8745
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	10
    jnz       L8745
    add       %rsi,	2
    jmp       L8744
L8745:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	92
    jnz       L8746
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	13
    jnz       L8746
    movzx     %rax,	byte ptr[%rsi+2]
    cmp       %rax,	10
    jnz       L8746
    add       %rsi,	3
    jmp       L8744
L8746:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %al,	[%rax]
    mov       %r10,	%rdi
    inc       %rdi
    mov       [%r10],	%al
L8744:
    xor       %eax,	%eax
    mov       [%rdi],	%al
L8742:
    mov       %al,	[%rsi]
    test      %al,	%al
    jnz       L8741
    mov       %rax,	%rbx
L8740:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.loadbuiltin
cc_support.loadbuiltin:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	200
    jle       L8749
    lea       %rcx,	[%rip+L11458]
    lea       %rdx,	[%rip+L11459]
    call      cc_support.loaderror
L8749:
    inc       qword ptr[%rip+cc_decls.nsourcefiles]
    lea       %rax,	[%rip+L11460]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rdi
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*4],	%eax
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
L8747:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gs_copytostr
cc_support.gs_copytostr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %eax,	[%rdi+8]
    test      %eax,	%eax
    jz        L8752
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    movsxd    %rax,	dword ptr[%rdi+8]
    xor       %r10d,	%r10d
    mov       [%rbx + %rax],	%r10b
    jmp       L8751
L8752:
    xor       %eax,	%eax
    mov       [%rbx],	%al
L8751:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gs_additem
cc_support.gs_additem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rdi,	[%r12]
    mov       %eax,	[%r12+8]
    test      %eax,	%eax
    jz        L8755
    movsxd    %rax,	dword ptr[%r12+8]
    lea       %r10,	[%rdi + %rax]
    sub       %r10,	1
    movzx     %r10,	byte ptr[%r10]
    mov       %rbx,	%r10
    movzx     %rax,	byte ptr[%r13]
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    call      cc_support.isalphanum
    test      %rax,	%rax
    jz        L8757
    mov       %rcx,	%rsi
    call      cc_support.isalphanum
    test      %rax,	%rax
    jz        L8757
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11461]
    mov       %r8,	-1
    call      mlib.strbuffer_add
L8757:
L8755:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.isalphanum
cc_support.isalphanum:
#?>>
#?]]
#---------------
    cmp       %rcx,	65
    jl        L8762
    cmp       %rcx,	90
    jle       L8761
L8762:
    cmp       %rcx,	97
    jl        L8763
    cmp       %rcx,	122
    jle       L8761
L8763:
    cmp       %rcx,	48
    jl        L8760
    cmp       %rcx,	57
    jg        L8760
L8761:
    mov       %rax,	1
    jmp       L8758
L8760:
    xor       %eax,	%eax
L8758:
#---------------
    ret       
# End 
# Proc cc_support.showmacrolineno
cc_support.showmacrolineno:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+cc_decls.slineno]
    test      %rax,	%rax
    jz        L8766
L8766:
#---------------
    ret       
# End 
# Proc cc_headers.findheader
cc_headers.findheader:
#?>>
    .set cc_headers.findheader.newname, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	%r13
    mov       %rdx,	92
    call      strchr
    test      %rax,	%rax
    jz        L8769
    mov       %rbx,	%r13
    lea       %rax,	[%rbp + cc_headers.findheader.newname]
    mov       %rsi,	%rax
    jmp       L8771
L8770:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	92
    jnz       L8774
    mov       %rax,	%rsi
    inc       %rsi
    mov       %r10b,	47
    mov       [%rax],	%r10b
    jmp       L8773
L8774:
    mov       %al,	[%rbx]
    mov       %r10,	%rsi
    inc       %rsi
    mov       [%r10],	%al
L8773:
    inc       %rbx
L8771:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L8770
    xor       %eax,	%eax
    mov       [%rsi],	%al
    lea       %rax,	[%rbp + cc_headers.findheader.newname]
    mov       %r13,	%rax
L8769:
    mov       %rdi,	1
    mov       %r12,	40
    cmp       %r12,	1
    jl        L8777
L8775:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L8779
    lea       %rax,	[%rip+cc_headers.stdhdrtext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    jmp       L8767
L8779:
    inc       %rdi
    cmp       %rdi,	%r12
    jle       L8775
L8777:
    xor       %eax,	%eax
L8767:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_headers.writeheaders
cc_headers.writeheaders:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    mov       %rsi,	1
    mov       %r12,	40
    cmp       %r12,	1
    jl        L8783
L8781:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11462]
    call      mlib.changeext
    mov       %rbx,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11463]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11464]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L11465]
    call      fopen
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_headers.stdhdrtext]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    lea       %r10,	[%rip+cc_headers.stdhdrtext]
    mov       %r11,	%rsi
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	1
    mov       %r8,	%rax
    mov       %r9,	%rdi
    call      fwrite
    mov       %rcx,	%rdi
    call      fclose
    inc       %rsi
    cmp       %rsi,	%r12
    jle       L8781
L8783:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_headers.isheaderfile
cc_headers.isheaderfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rdi,	40
    cmp       %rdi,	1
    jl        L8787
L8785:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L8789
    mov       %rax,	1
    jmp       L8784
L8789:
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L8785
L8787:
    xor       %eax,	%eax
L8784:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printcode
cc_show.printcode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L8792
L8791:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jnz       L8796
L8795:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L8798
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11466]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+110]
    lea       %r10,	[%rip+cc_tables.scopenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rdi+72]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L11467]
    call      cc_show.printunit
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L8798:
L8796:
L8794:
    mov       %rdi,	[%rdi+32]
L8792:
    test      %rdi,	%rdi
    jnz       L8791
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printunit
cc_show.printunit:
#?>>
    .set cc_show.printunit.level, 80
    .set cc_show.printunit.prefix, 88
    .set cc_show.printunit.idname, -8
    .set cc_show.printunit.pc, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    test      %r14,	%r14
    jnz       L8801
    jmp       L8799
L8801:
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	77
    jl        L8803
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L11468]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+40]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	30
    call      exit
L8803:
    mov       %eax,	[%r14+44]
    test      %eax,	%eax
    jz        L8805
    mov       %eax,	[%r14+44]
    mov       [%rip+cc_show.currlineno],	%rax
    movzx     %rax,	byte ptr[%r14+60]
    mov       [%rip+cc_show.currfileno],	%rax
L8805:
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_show.printunit.level]
    cmp       %rax,	0
    jge       L8807
    mov       %r12,	-1
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11469]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8807:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%rbp + cc_show.printunit.level]
    cmp       %rax,	0
    jge       L11470
    neg       %rax
L11470:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_show.printunit.prefix]
    mov       %r8,	%r14
    call      cc_show.getprefix
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%r14+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_show.printunit.idname],	%r10
    mov       %rax,	[%rbp + cc_show.printunit.idname]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	106
    jnz       L8809
    inc       qword ptr[%rbp + cc_show.printunit.idname]
L8809:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rbp + cc_show.printunit.idname]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11471]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	3
    jz        L8811
    cmp       %rax,	5
    jz        L8811
    cmp       %rax,	7
    jz        L8812
    cmp       %rax,	8
    jz        L8812
    cmp       %rax,	16
    jz        L8812
    cmp       %rax,	16
    jz        L8813
    cmp       %rax,	17
    jz        L8814
    cmp       %rax,	18
    jz        L8815
    cmp       %rax,	1
    jz        L8816
    cmp       %rax,	56
    jz        L8817
    cmp       %rax,	57
    jz        L8818
    cmp       %rax,	53
    jz        L8819
    cmp       %rax,	54
    jz        L8819
    cmp       %rax,	22
    jz        L8820
    cmp       %rax,	30
    jz        L8821
    cmp       %rax,	52
    jz        L8822
    cmp       %rax,	49
    jz        L8823
    jmp       L8824
L8811:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L8826
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11472]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rdi+72]
    movsxd    %rax,	dword ptr[%rax+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11473]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8826:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11474]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    call      cc_show.getdottedname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rax,	[%r14+32]
    test      %rax,	%rax
    jz        L8828
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11475]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r14+32]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L8828:
    jmp       L8810
L8812:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%rdi+72]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L11476]
    call      cc_show.printunit
    jmp       L8799
L8813:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L8810
L8814:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L8810
L8815:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11477]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8810
L8816:
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rbx,	%rax
    cmp       %rbx,	[%rip+cc_decls.trefchar]
    jnz       L8830
    mov       %al,	[%r14+61]
    test      %al,	%al
    jz        L8833
L8832:
#cc_show.printunit.dostring:
L8834:
    movsxd    %rax,	dword ptr[%r14+48]
    cmp       %rax,	256
    jle       L8836
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11478]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11479]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11480]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8835
L8836:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11481]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	[%r14]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11482]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L8835:
    jmp       L8829
L8830:
    cmp       %rbx,	[%rip+cc_decls.trefwchar]
    jnz       L8837
    mov       %al,	[%r14+62]
    test      %al,	%al
    jz        L8833
L8839:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11483]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11484]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11485]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8829
L8837:
    cmp       %rbx,	1
    jl        L8840
    cmp       %rbx,	4
    jg        L8840
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8829
L8840:
    cmp       %rbx,	6
    jl        L8841
    cmp       %rbx,	9
    jg        L8841
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_end
    jmp       L8829
L8841:
    mov       %rcx,	%rbx
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L8842
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movq      %XMM4,	[%r14]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L8829
L8842:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L8843
    mov       %al,	[%r14+61]
    test      %al,	%al
    jnz       L8834
L8845:
#cc_show.printunit.doref:
L8833:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L8829
L8843:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L8846
    mov       %al,	[%r14+61]
    test      %al,	%al
    jnz       L8834
L8848:
    lea       %rcx,	[%rip+L11486]
    call      cc_support.serror
    jmp       L8829
L8846:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11487]
    call      cc_support.serror
L8829:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11488]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %al,	[%r14+61]
    test      %al,	%al
    jz        L8850
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11489]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8850:
    mov       %al,	[%r14+62]
    test      %al,	%al
    jz        L8852
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11490]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8852:
    jmp       L8810
L8817:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movsxd    %rax,	dword ptr[%r14+48]
    lea       %r10,	[%rip+cc_tables.convnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11491]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14+16]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11492]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movsx     %rax,	word ptr[%r14+58]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L8810
L8818:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11493]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8810
L8819:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11494]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8810
L8820:
    mov       %rax,	[%r14]
    mov       [%rbp + cc_show.printunit.pc],	%rax
    xor       %rsi,	%rsi
    jmp       L8854
L8853:
    inc       %rsi
    mov       %rax,	[%rbp + cc_show.printunit.pc]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_show.printunit.pc],	%rax
L8854:
    mov       %rax,	[%rbp + cc_show.printunit.pc]
    test      %rax,	%rax
    jnz       L8853
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_ptr_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8810
L8821:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11495]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8810
L8822:
    jmp       L8810
L8823:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11496]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L8824:
L8810:
    mov       %ax,	[%r14+56]
    test      %ax,	%ax
    jz        L8857
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11497]
    call      msys.m$print_str_nf
    movsx     %rax,	word ptr[%r14+56]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8857:
    mov       %eax,	[%r14+48]
    test      %eax,	%eax
    jz        L8859
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11498]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L8859:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+16]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L11499]
    call      cc_show.printunitlist
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+24]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L11500]
    call      cc_show.printunitlist
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	6
    jz        L8861
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+32]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L11501]
    call      cc_show.printunitlist
L8861:
L8799:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printunitlist
cc_show.printunitlist:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    test      %rbx,	%rbx
    jnz       L8864
    jmp       L8862
L8864:
    jmp       L8866
L8865:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      cc_show.printunit
    mov       %rbx,	[%rbx+8]
L8866:
    test      %rbx,	%rbx
    jnz       L8865
L8862:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getprefix
cc_show.getprefix:
#?>>
    .set cc_show.getprefix.indentstr, -512
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	544
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_show.getprefix.indentstr],	%al
    cmp       %r12,	10
    jle       L8870
    mov       %r12,	10
L8870:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    lea       %rdx,	[%rip+L11502]
    call      strcpy
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_lib.strmode
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      strlen
    mov       %rbx,	%rax
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    call      strlen
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jge       L8872
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    jmp       L8871
L8872:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    mov       %rdx,	%rdi
    call      strcpy
L8871:
    mov       %rsi,	%r12
    cmp       %rsi,	0
    jle       L8875
L8873:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    lea       %rdx,	[%rip+L11503]
    call      strcat
    dec       %rsi
    jnz       L8873
L8875:
    call      cc_show.getlineinfok
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    lea       %rdx,	[%rbp + cc_show.getprefix.indentstr]
    call      strcat
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    mov       %rdx,	%r13
    call      strcat
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L8877
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    lea       %rdx,	[%rip+L11504]
    call      strcat
L8877:
    lea       %rax,	[%rip+cc_show.getprefix.str]
L8868:
#---------------
    add       %rsp,	544
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getdottedname
cc_show.getdottedname:
#?>>
    .set cc_show.getdottedname.str2, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rdi,	[%rbx+8]
    jmp       L8880
L8879:
    lea       %rcx,	[%rbp + cc_show.getdottedname.str2]
    lea       %rdx,	[%rip+cc_show.getdottedname.str]
    call      strcpy
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rip+L11505]
    call      strcat
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rbp + cc_show.getdottedname.str2]
    call      strcat
    mov       %rdi,	[%rdi+8]
L8880:
    test      %rdi,	%rdi
    jz        L8882
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	2
    jnz       L8879
L8882:
    mov       %ax,	[%rbx+96]
    test      %ax,	%ax
    jz        L8884
    lea       %rcx,	[%rbp + cc_show.getdottedname.str2]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11505]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     %rax,	word ptr[%rbx+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rbp + cc_show.getdottedname.str2]
    call      strcat
L8884:
    lea       %rax,	[%rip+cc_show.getdottedname.str]
L8878:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getlineinfok
cc_show.getlineinfok:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+cc_show.getlineinfok.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11506]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+cc_show.currfileno]
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+cc_show.currlineno]
    lea       %rdx,	[%rip+L11507]
    call      msys.m$print_i64
    call      msys.m$print_space
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_show.getlineinfok.str]
L8885:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_show.printst
cc_show.printst:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	67
    jz        L8888
    lea       %rcx,	[%rip+L11508]
    call      cc_support.mcerror
L8888:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_show.printstrec
    mov       %rdi,	[%rsi+16]
    jmp       L8890
L8889:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      cc_show.printst
    mov       %rdi,	[%rdi+32]
L8890:
    test      %rdi,	%rdi
    jnz       L8889
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printstrec
cc_show.printstrec:
#?>>
    .set cc_show.printstrec.p, 72
    .set cc_show.printstrec.level, 80
    .set cc_show.printstrec.v, -16
    .set cc_show.printstrec.str, -272
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	304
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
    mov       [%rbp+80],	%r8
#---------------
    lea       %rax,	[%rbp + cc_show.printstrec.v]
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mlib.gs_init
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + cc_show.printstrec.level]
    mov       %r13,	%rax
    cmp       %r13,	0
    jle       L8895
L8893:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11509]
    call      mlib.gs_str
    mov       %rax,	4
    add       %rsi,	%rax
    dec       %r13
    jnz       L8893
L8895:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11510]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %ax,	[%rax+96]
    test      %ax,	%ax
    jz        L8897
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11511]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rax,	28
    sub       %rax,	%rsi
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    mov       %r8,	%rax
    mov       %r9,	45
    call      mlib.gs_leftstr
    jmp       L8896
L8897:
    mov       %rax,	28
    sub       %rax,	%rsi
    mov       %r10,	[%rbp + cc_show.printstrec.p]
    mov       %r10,	[%r10]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	%rax
    mov       %r9,	45
    call      mlib.gs_leftstr
L8896:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	12
    mov       %r9,	46
    call      mlib.gs_leftstr
    mov       %rcx,	%rdi
    call      mlib.gs_getcol
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11512]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+110]
    lea       %r10,	[%rip+cc_tables.scopenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11513]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L8899
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11514]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11515]
    call      mlib.gs_str
L8899:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	1
    and       %eax,	1
    test      %rax,	%rax
    jz        L8901
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11516]
    call      mlib.gs_str
L8901:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+122]
    test      %al,	%al
    jz        L8903
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11517]
    call      mlib.gs_str
L8903:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+111]
    test      %al,	%al
    jz        L8905
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11518]
    call      msys.m$print_setfmt
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+111]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    call      mlib.gs_str
L8905:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11519]
    call      mlib.gs_str
    lea       %rax,	[%rbx+10]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	61
    call      mlib.gs_padto
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jz        L8907
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L11520]
    call      msys.m$print_setfmt
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    mov       %r8,	18
    mov       %r9,	32
    call      mlib.gs_leftstr
    jmp       L8906
L8907:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11521]
    mov       %r8,	18
    mov       %r9,	32
    call      mlib.gs_leftstr
L8906:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jnz       L8910
L8909:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11522]
    call      mlib.gs_str
    jmp       L8908
L8910:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strsp
L8908:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	10
    jz        L8912
    cmp       %rax,	8
    jz        L8913
    cmp       %rax,	9
    jz        L8913
    cmp       %rax,	6
    jz        L8914
    cmp       %rax,	11
    jz        L8915
    cmp       %rax,	7
    jz        L8916
    jmp       L8917
L8912:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11523]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L8911
L8913:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L8919
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11524]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      cc_show.strexpr
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strvar
L8919:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11525]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L8911
L8914:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11526]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L8911
L8915:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11527]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L8911
L8916:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L8921
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11528]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      cc_show.strexpr
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strvar
L8921:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11529]
    call      mlib.gs_str
L8917:
L8911:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11530]
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11531]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %eax,	[%rax+92]
    and       %rax,	16777215
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11532]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %eax,	[%rax+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jnz       L8923
    mov       %rcx,	%rdi
    call      mlib.gs_line
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %r12,	[%rax+80]
    jmp       L8925
L8924:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11533]
    call      mlib.gs_str
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jz        L8928
    mov       %rax,	[%r12]
    mov       %rax,	[%rax]
    jmp       L8927
L8928:
    lea       %rax,	[%rip+L11534]
L8927:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	10
    mov       %r9,	45
    call      mlib.gs_leftstr
    movsx     %rax,	word ptr[%r12+22]
    lea       %r10,	[%rip+cc_tables.pmflagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11535]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11536]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    call      mlib.gs_line
    mov       %r12,	[%r12+8]
L8925:
    test      %r12,	%r12
    jnz       L8924
L8923:
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      mlib.gs_println
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L8930
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	8
    jz        L8932
    cmp       %rax,	7
    jnz       L8933
L8932:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	-3
    lea       %r9,	[%rip+L11537]
    call      cc_show.printunit
L8933:
L8931:
L8930:
#---------------
    add       %rsp,	304
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printstflat
cc_show.printstflat:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11538]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jl        L8937
L8935:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L8939
    movzx     %rax,	byte ptr[%rbx+107]
    cmp       %rax,	67
    jz        L8941
    cmp       %rax,	70
    jz        L8941
    cmp       %rax,	68
    jnz       L8942
L8941:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    mov       %rcx,	%rbx
    call      msys.m$print_ptr_nf
    lea       %rcx,	[%rip+L11539]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      cc_lib.getstname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+107]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rbx+40]
    jmp       L8944
L8943:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11540]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_ptr_nf
    mov       %rcx,	%rbx
    call      cc_lib.getstname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+107]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbx+48]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11541]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbx+8]
    test      %rax,	%rax
    jz        L8947
    mov       %rcx,	[%rbx+8]
    call      cc_lib.getstname
    jmp       L8946
L8947:
    lea       %rax,	[%rip+L11542]
L8946:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11543]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rbx+40]
L8944:
    test      %rbx,	%rbx
    jnz       L8943
L8942:
L8940:
L8939:
    inc       %rdi
    cmp       %rdi,	%rsi
    jle       L8935
L8937:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.strexpr
cc_show.strexpr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_show.exprstr]
    call      mlib.gs_init
    mov       %rcx,	[%rip+cc_show.exprstr]
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rax,	[%rip+cc_show.exprstr]
L8948:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_show.jeval
cc_show.jeval:
#?>>
    .set cc_show.jeval.str, -16000
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	16040
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r13+40]
    cmp       %rax,	1
    jz        L8951
    cmp       %rax,	3
    jz        L8952
    cmp       %rax,	5
    jz        L8953
    cmp       %rax,	24
    jz        L8954
    cmp       %rax,	25
    jz        L8954
    cmp       %rax,	32
    jz        L8954
    cmp       %rax,	33
    jz        L8954
    cmp       %rax,	34
    jz        L8954
    cmp       %rax,	35
    jz        L8954
    cmp       %rax,	36
    jz        L8954
    cmp       %rax,	37
    jz        L8954
    cmp       %rax,	38
    jz        L8954
    cmp       %rax,	39
    jz        L8954
    cmp       %rax,	40
    jz        L8954
    cmp       %rax,	41
    jz        L8954
    cmp       %rax,	42
    jz        L8954
    cmp       %rax,	43
    jz        L8954
    cmp       %rax,	44
    jz        L8954
    cmp       %rax,	45
    jz        L8954
    cmp       %rax,	46
    jz        L8954
    cmp       %rax,	47
    jz        L8954
    cmp       %rax,	48
    jz        L8954
    cmp       %rax,	61
    jz        L8954
    cmp       %rax,	62
    jz        L8954
    cmp       %rax,	63
    jz        L8954
    cmp       %rax,	64
    jz        L8954
    cmp       %rax,	65
    jz        L8954
    cmp       %rax,	66
    jz        L8954
    cmp       %rax,	67
    jz        L8954
    cmp       %rax,	68
    jz        L8954
    cmp       %rax,	69
    jz        L8954
    cmp       %rax,	70
    jz        L8954
    cmp       %rax,	58
    jz        L8955
    cmp       %rax,	59
    jz        L8955
    cmp       %rax,	60
    jz        L8955
    cmp       %rax,	26
    jz        L8955
    cmp       %rax,	27
    jz        L8955
    cmp       %rax,	30
    jz        L8956
    cmp       %rax,	49
    jz        L8957
    cmp       %rax,	50
    jz        L8958
    cmp       %rax,	28
    jz        L8959
    cmp       %rax,	29
    jz        L8959
    cmp       %rax,	11
    jz        L8960
    cmp       %rax,	31
    jz        L8961
    cmp       %rax,	56
    jz        L8962
    cmp       %rax,	52
    jz        L8963
    cmp       %rax,	6
    jz        L8964
    cmp       %rax,	71
    jz        L8965
    cmp       %rax,	72
    jz        L8966
    cmp       %rax,	73
    jz        L8967
    cmp       %rax,	74
    jz        L8968
    cmp       %rax,	2
    jz        L8969
    cmp       %rax,	57
    jz        L8970
    cmp       %rax,	53
    jz        L8971
    cmp       %rax,	4
    jz        L8972
    jmp       L8973
L8951:
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rsi,	%rax
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jnz       L8975
    movsxd    %rax,	dword ptr[%r13+48]
    test      %rax,	%rax
    jz        L8978
L8977:
    mov       %al,	[%r13+61]
    test      %al,	%al
    jz        L8978
L8980:
    movsxd    %rax,	dword ptr[%r13+48]
    cmp       %rax,	8000
    jle       L8982
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    lea       %rdx,	[%rip+L11544]
    call      strcpy
    jmp       L8981
L8982:
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      pc_api.convertstring
L8981:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11545]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11545]
    call      cc_support.gs_additem
    jmp       L8949
L8975:
    cmp       %rsi,	1
    jl        L8983
    cmp       %rsi,	4
    jg        L8983
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      msys.getstrint
    jmp       L8974
L8983:
    cmp       %rsi,	6
    jl        L8984
    cmp       %rsi,	9
    jg        L8984
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strword
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L8974
L8984:
    cmp       %rsi,	11
    jz        L8986
    cmp       %rsi,	10
    jnz       L8985
L8986:
    movq      %XMM4,	[%r13]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.strreal
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L8974
L8985:
    movsxd    %rax,	dword ptr[%r13+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jz        L8988
    cmp       %r10,	17
    jz        L8989
    jmp       L8990
L8988:
#cc_show.jeval.doref:
L8978:
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    call      msys.m$print_startstr
    mov       %rcx,	[%r13]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L8987
L8989:
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    lea       %rdx,	[%rip+L11546]
    call      strcpy
    jmp       L8987
L8990:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L11547]
    call      mlib.abortprogram
L8987:
L8974:
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    jmp       L8950
L8952:
    mov       %rax,	[%r13]
    mov       %rax,	[%rax]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L8950
L8953:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11548]
    call      mlib.gs_str
    mov       %rax,	[%r13]
    mov       %rax,	[%rax]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L8950
L8954:
    movsxd    %rax,	dword ptr[%r13+40]
    mov       %rcx,	%rax
    call      cc_lib.getopcjname
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11549]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11550]
    call      cc_support.gs_additem
    jmp       L8950
L8955:
    movsxd    %rax,	dword ptr[%r13+40]
    mov       %rcx,	%rax
    call      cc_lib.getopcjname
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11551]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11552]
    call      cc_support.gs_additem
    jmp       L8950
L8956:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11553]
    call      cc_support.gs_additem
    mov       %rdi,	[%r13+24]
    jmp       L8992
L8991:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rdi,	[%rdi+8]
    test      %rdi,	%rdi
    jz        L8995
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11554]
    call      cc_support.gs_additem
L8995:
L8992:
    test      %rdi,	%rdi
    jnz       L8991
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11555]
    call      cc_support.gs_additem
    jmp       L8950
L8957:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11556]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11557]
    call      mlib.gs_str
    jmp       L8950
L8958:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11558]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L8950
L8959:
    movsxd    %rax,	dword ptr[%r13+40]
    cmp       %rax,	29
    setz      %al
    movzx     %eax,	%al
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L8997
    lea       %rax,	[%rip+L11559]
    jmp       L8996
L8997:
    lea       %rax,	[%rip+L11560]
L8996:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    mov       %rdi,	[%r13+16]
    jmp       L8999
L8998:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rdi,	[%rdi+8]
    test      %rdi,	%rdi
    jz        L9002
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11561]
    call      cc_support.gs_additem
L9002:
L8999:
    test      %rdi,	%rdi
    jnz       L8998
    test      %rbx,	%rbx
    jz        L9004
    lea       %rax,	[%rip+L11562]
    jmp       L9003
L9004:
    lea       %rax,	[%rip+L11563]
L9003:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L8950
L8960:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11564]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L8950
L8961:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11565]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11566]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+32]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L8950
L8962:
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11567]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11568]
    call      cc_support.gs_additem
    jmp       L8950
L8963:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11569]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rax,	[%r13+24]
    test      %rax,	%rax
    jz        L9006
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11570]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
L9006:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11571]
    call      cc_support.gs_additem
    jmp       L8950
L8964:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11572]
    call      cc_support.gs_additem
    jmp       L8950
L8965:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11573]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L8950
L8966:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11574]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L8950
L8967:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11575]
    call      cc_support.gs_additem
    jmp       L8950
L8968:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11576]
    call      cc_support.gs_additem
    jmp       L8950
L8969:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11577]
    call      mlib.gs_str
    jmp       L8950
L8970:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11578]
    call      mlib.gs_str
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    movsxd    %rax,	dword ptr[%r13+48]
    cmp       %rax,	0
    jle       L9008
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11579]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r13+48]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L9007
L9008:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11580]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r13+48]
    neg       %rax
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mlib.gs_strint
L9007:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11581]
    call      mlib.gs_str
    jmp       L8950
L8971:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11582]
    call      mlib.gs_str
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11583]
    call      mlib.gs_str
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11584]
    call      mlib.gs_str
    jmp       L8950
L8972:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L8950
L8973:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L11585]
    call      mlib.gs_str
L8950:
L8949:
#---------------
    add       %rsp,	16040
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printfilelist
cc_show.printfilelist:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11586]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L9012
L9010:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11587]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L11588]
    call      msys.m$print_str
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsourcefiles]
    jle       L9010
L9012:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11589]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11590]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nlibfiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	1
    jl        L9015
L9013:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.libfiles]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nlibfiles]
    jle       L9013
L9015:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printmodelist
cc_show.printmodelist:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11591]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.ntypes]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	0
    jl        L9019
L9017:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L11592]
    call      msys.m$print_i64
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.tttypedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L9021
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11593]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11594]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.tttypedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9021:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11595]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11596]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11597]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11598]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rsi,	[%rax + %r10*8]
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11599]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11600]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_ptr_nf
    call      msys.m$print_space
    call      msys.m$print_end
    test      %rsi,	%rsi
    jz        L9023
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L11601]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L9022
L9023:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11602]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L9022:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11603]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11604]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11605]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11606]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11607]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11608]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11609]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11610]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttisblock]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11611]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11612]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11613]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11614]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttsigned]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11615]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11616]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11617]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11618]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L11619]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L11620]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttshared]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.ntypes]
    jle       L9017
L9019:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msyswin.start
msyswin.start:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.start
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pcl.start
pcl.start:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mc_genss.start
    call      mc_decls.start
    call      mc_writeasm.start
#---------------
    add       %rsp,	40
    ret       
# End 
    .data
$procaddr:
    .quad     mc_genmcl.px_nop
    .quad     mc_genmcl.px_dupl
    .quad     mc_genmcl.px_double
    .quad     mc_genmcl.px_opnd
    .quad     mc_genmcl.px_type
    .quad     mc_genmcl.px_comment
    .quad     mc_genmcl.px_proc
    .quad     mc_genmcl.px_endproc
    .quad     mc_genmcl.px_endprog
    .quad     mc_genmcl.px_istatic
    .quad     mc_genmcl.px_zstatic
    .quad     mc_genmcl.px_data
    .quad     mc_genmcl.px_label
    .quad     mc_genmcl.px_load
    .quad     mc_genmcl.px_store
    .quad     mc_genmcl.px_add
    .quad     mc_genmcl.px_sub
    .quad     mc_genmcl.px_mul
    .quad     mc_genmcl.px_div
    .quad     mc_genmcl.px_eval
    .quad     mc_genmcl.px_widen
    .quad     mc_genmcl.px_jump
    .quad     mc_genmcl.px_ijump
    .quad     mc_genmcl.px_neg
    .quad     mc_genmcl.px_abs
    .quad     mc_genmcl.px_bitnot
    .quad     mc_genmcl.px_not
    .quad     mc_genmcl.px_toboolt
    .quad     mc_genmcl.px_sqr
    .quad     mc_genmcl.px_sqrt
    .quad     mc_genmcl.px_jumpcc
    .quad     mc_genmcl.px_jumpt
    .quad     mc_genmcl.px_jumpf
    .quad     mc_genmcl.px_bitand
    .quad     mc_genmcl.px_bitor
    .quad     mc_genmcl.px_bitxor
    .quad     mc_genmcl.px_shl
    .quad     mc_genmcl.px_shr
    .quad     mc_genmcl.px_retproc
    .quad     mc_genmcl.px_retfn
    .quad     mc_genmcl.px_setcall
    .quad     mc_genmcl.px_setarg
    .quad     mc_genmcl.px_callp
    .quad     mc_genmcl.px_jumpret
    .quad     mc_genmcl.px_jumpretm
    .quad     mc_genmcl.px_startmx
    .quad     mc_genmcl.px_resetmx
    .quad     mc_genmcl.px_stop
    .quad     mc_genmcl.px_incrto
    .quad     mc_genmcl.px_decrto
    .quad     mc_genmcl.px_incrload
    .quad     mc_genmcl.px_decrload
    .quad     mc_genmcl.px_loadincr
    .quad     mc_genmcl.px_loaddecr
    .quad     mc_genmcl.px_forup
    .quad     mc_genmcl.px_fordown
    .quad     mc_genmcl.px_iload
    .quad     mc_genmcl.px_iloadx
    .quad     mc_genmcl.px_istore
    .quad     mc_genmcl.px_istorex
    .quad     mc_genmcl.px_storem
    .quad     mc_genmcl.px_addpx
    .quad     mc_genmcl.px_subpx
    .quad     mc_genmcl.px_to
    .quad     mc_genmcl.px_iswap
    .quad     mc_genmcl.px_swapstk
    .quad     mc_genmcl.px_labeldef
    .quad     mc_genmcl.px_addto
    .quad     mc_genmcl.px_subto
    .quad     mc_genmcl.px_multo
    .quad     mc_genmcl.px_bitandto
    .quad     mc_genmcl.px_bitorto
    .quad     mc_genmcl.px_bitxorto
    .quad     mc_genmcl.px_shlto
    .quad     mc_genmcl.px_shrto
    .quad     mc_genmcl.px_fix
    .quad     mc_genmcl.px_float
    .quad     mc_genmcl.px_idiv
    .quad     mc_genmcl.px_irem
    .quad     mc_genmcl.px_idivrem
    .quad     mc_genmcl.px_clear
    .quad     mc_genmcl.px_subp
    .quad     mc_genmcl.px_switch
    .quad     mc_genmcl.px_switchu
    .quad     mc_genmcl.px_swlabel
    .quad     mc_genmcl.px_endsw
    .quad     mc_genmcl.px_fwiden
    .quad     mc_genmcl.px_fnarrow
    .quad     mc_genmcl.px_truncate
    .quad     mc_genmcl.px_typepun
    .quad     mc_genmcl.px_unload
    .quad     mc_genmcl.px_loadbit
    .quad     mc_genmcl.px_assem
    .quad     mc_genmcl.px_sin
    .quad     mc_genmcl.px_cos
    .quad     mc_genmcl.px_tan
    .quad     mc_genmcl.px_asin
    .quad     mc_genmcl.px_acos
    .quad     mc_genmcl.px_atan
    .quad     mc_genmcl.px_log
    .quad     mc_genmcl.px_log10
    .quad     mc_genmcl.px_exp
    .quad     mc_genmcl.px_round
    .quad     mc_genmcl.px_floor
    .quad     mc_genmcl.px_ceil
    .quad     mc_genmcl.px_atan2
    .quad     mc_genmcl.px_fmod
    .quad     mc_genmcl.px_setcc
    .quad     mc_genmcl.px_min
    .quad     mc_genmcl.px_max
    .quad     mc_genmcl.px_power
    .quad     mc_genmcl.px_minto
    .quad     mc_genmcl.px_maxto
    .quad     mc_genmcl.px_negto
    .quad     mc_genmcl.px_absto
    .quad     mc_genmcl.px_addpxto
    .quad     mc_genmcl.px_subpxto
    .quad     mc_genmcl.px_divto
    .quad     mc_genmcl.px_bitnotto
    .quad     mc_genmcl.px_notto
    .quad     mc_genmcl.px_toboolto
    .quad     mc_genmcl.px_sign
    .quad     mc_genmcl.px_loadbf
    .quad     mc_genmcl.px_storebit
    .quad     mc_genmcl.px_storebf
    .quad     mc_genmcl.px_loadall
    .quad     mc_genmcl.px_setjmp
    .quad     mc_genmcl.px_longjmp
    .quad     mc_genmcl.px_initdswx
    .quad     mc_auxmcl.do_addrmode
$procname:
    .quad     L11621
    .quad     L11622
    .quad     L11623
    .quad     L11624
    .quad     L11625
    .quad     L11626
    .quad     L11627
    .quad     L11628
    .quad     L11629
    .quad     L11630
    .quad     L11631
    .quad     L11632
    .quad     L11633
    .quad     L11634
    .quad     L11635
    .quad     L11636
    .quad     L11637
    .quad     L11638
    .quad     L11639
    .quad     L11640
    .quad     L11641
    .quad     L11642
    .quad     L11643
    .quad     L11644
    .quad     L11645
    .quad     L11646
    .quad     L11647
    .quad     L11648
    .quad     L11649
    .quad     L11650
    .quad     L11651
    .quad     L11652
    .quad     L11653
    .quad     L11654
    .quad     L11655
    .quad     L11656
    .quad     L11657
    .quad     L11658
    .quad     L11659
    .quad     L11660
    .quad     L11661
    .quad     L11662
    .quad     L11663
    .quad     L11664
    .quad     L11665
    .quad     L11666
    .quad     L11667
    .quad     L11668
    .quad     L11669
    .quad     L11670
    .quad     L11671
    .quad     L11672
    .quad     L11673
    .quad     L11674
    .quad     L11675
    .quad     L11676
    .quad     L11677
    .quad     L11678
    .quad     L11679
    .quad     L11680
    .quad     L11681
    .quad     L11682
    .quad     L11683
    .quad     L11684
    .quad     L11685
    .quad     L11686
    .quad     L11687
    .quad     L11688
    .quad     L11689
    .quad     L11690
    .quad     L11691
    .quad     L11692
    .quad     L11693
    .quad     L11694
    .quad     L11695
    .quad     L11696
    .quad     L11697
    .quad     L11698
    .quad     L11699
    .quad     L11700
    .quad     L11701
    .quad     L11702
    .quad     L11703
    .quad     L11704
    .quad     L11705
    .quad     L11706
    .quad     L11707
    .quad     L11708
    .quad     L11709
    .quad     L11710
    .quad     L11711
    .quad     L11712
    .quad     L11713
    .quad     L11714
    .quad     L11715
    .quad     L11716
    .quad     L11717
    .quad     L11718
    .quad     L11719
    .quad     L11720
    .quad     L11721
    .quad     L11722
    .quad     L11723
    .quad     L11724
    .quad     L11725
    .quad     L11726
    .quad     L11727
    .quad     L11728
    .quad     L11729
    .quad     L11730
    .quad     L11731
    .quad     L11732
    .quad     L11733
    .quad     L11734
    .quad     L11735
    .quad     L11736
    .quad     L11737
    .quad     L11738
    .quad     L11739
    .quad     L11740
    .quad     L11741
    .quad     L11742
    .quad     L11743
    .quad     L11744
    .quad     L11745
    .quad     L11746
    .quad     L11747
    .quad     L11748
    .quad     L11749
    .quad     L11750
$nprocs:
    .quad     0x82
#Real Table
    .align    8
L11303:
    .quad     0x3FF0000000000000
L11211:
    .quad     0x4024000000000000
L11208:
    .quad     0x4024000000000000
L11205:
    .quad     0
L11204:
    .quad     0x4000000000000000
L11089:
    .quad     0x4000000000000000
L11045:
    .quad     0x4059000000000000
L10649:
    .quad     0x7FF0000000000000
L10647:
    .quad     0x7FF0000000000000
L10630:
    .quad     0
L10444:
    .quad     0x7FF0000000000000
L10372:
    .quad     0x43E0000000000000
L10371:
    .quad     0x3FF0000000000000
L10370:
    .quad     0x43E0000000000000
L10347:
    .quad     0
L10345:
    .quad     0
#Real32 Table
    .align    16
#lababs64
L10539:
    .quad     0x7FFFFFFFFFFFFFFF
    .quad     0x7FFFFFFFFFFFFFFF
#labneg64
L10538:
    .quad     0x8000000000000000
    .quad     0x8000000000000000
#mask63/offset64
L10547:
    .quad     0x7FFFFFFFFFFFFFFF
L10548:
    .quad     0x43E0000000000000
#String Table
    .align    8
L11750:
    .ascii    "do_addrmode"
    .byte     0
L11749:
    .ascii    "px_initdswx"
    .byte     0
L11748:
    .ascii    "px_longjmp"
    .byte     0
L11747:
    .ascii    "px_setjmp"
    .byte     0
L11746:
    .ascii    "px_loadall"
    .byte     0
L11745:
    .ascii    "px_storebf"
    .byte     0
L11744:
    .ascii    "px_storebit"
    .byte     0
L11743:
    .ascii    "px_loadbf"
    .byte     0
L11742:
    .ascii    "px_sign"
    .byte     0
L11741:
    .ascii    "px_toboolto"
    .byte     0
L11740:
    .ascii    "px_notto"
    .byte     0
L11739:
    .ascii    "px_bitnotto"
    .byte     0
L11738:
    .ascii    "px_divto"
    .byte     0
L11737:
    .ascii    "px_subpxto"
    .byte     0
L11736:
    .ascii    "px_addpxto"
    .byte     0
L11735:
    .ascii    "px_absto"
    .byte     0
L11734:
    .ascii    "px_negto"
    .byte     0
L11733:
    .ascii    "px_maxto"
    .byte     0
L11732:
    .ascii    "px_minto"
    .byte     0
L11731:
    .ascii    "px_power"
    .byte     0
L11730:
    .ascii    "px_max"
    .byte     0
L11729:
    .ascii    "px_min"
    .byte     0
L11728:
    .ascii    "px_setcc"
    .byte     0
L11727:
    .ascii    "px_fmod"
    .byte     0
L11726:
    .ascii    "px_atan2"
    .byte     0
L11725:
    .ascii    "px_ceil"
    .byte     0
L11724:
    .ascii    "px_floor"
    .byte     0
L11723:
    .ascii    "px_round"
    .byte     0
L11722:
    .ascii    "px_exp"
    .byte     0
L11721:
    .ascii    "px_log10"
    .byte     0
L11720:
    .ascii    "px_log"
    .byte     0
L11719:
    .ascii    "px_atan"
    .byte     0
L11718:
    .ascii    "px_acos"
    .byte     0
L11717:
    .ascii    "px_asin"
    .byte     0
L11716:
    .ascii    "px_tan"
    .byte     0
L11715:
    .ascii    "px_cos"
    .byte     0
L11714:
    .ascii    "px_sin"
    .byte     0
L11713:
    .ascii    "px_assem"
    .byte     0
L11712:
    .ascii    "px_loadbit"
    .byte     0
L11711:
    .ascii    "px_unload"
    .byte     0
L11710:
    .ascii    "px_typepun"
    .byte     0
L11709:
    .ascii    "px_truncate"
    .byte     0
L11708:
    .ascii    "px_fnarrow"
    .byte     0
L11707:
    .ascii    "px_fwiden"
    .byte     0
L11706:
    .ascii    "px_endsw"
    .byte     0
L11705:
    .ascii    "px_swlabel"
    .byte     0
L11704:
    .ascii    "px_switchu"
    .byte     0
L11703:
    .ascii    "px_switch"
    .byte     0
L11702:
    .ascii    "px_subp"
    .byte     0
L11701:
    .ascii    "px_clear"
    .byte     0
L11700:
    .ascii    "px_idivrem"
    .byte     0
L11699:
    .ascii    "px_irem"
    .byte     0
L11698:
    .ascii    "px_idiv"
    .byte     0
L11697:
    .ascii    "px_float"
    .byte     0
L11696:
    .ascii    "px_fix"
    .byte     0
L11695:
    .ascii    "px_shrto"
    .byte     0
L11694:
    .ascii    "px_shlto"
    .byte     0
L11693:
    .ascii    "px_bitxorto"
    .byte     0
L11692:
    .ascii    "px_bitorto"
    .byte     0
L11691:
    .ascii    "px_bitandto"
    .byte     0
L11690:
    .ascii    "px_multo"
    .byte     0
L11689:
    .ascii    "px_subto"
    .byte     0
L11688:
    .ascii    "px_addto"
    .byte     0
L11687:
    .ascii    "px_labeldef"
    .byte     0
L11686:
    .ascii    "px_swapstk"
    .byte     0
L11685:
    .ascii    "px_iswap"
    .byte     0
L11684:
    .ascii    "px_to"
    .byte     0
L11683:
    .ascii    "px_subpx"
    .byte     0
L11682:
    .ascii    "px_addpx"
    .byte     0
L11681:
    .ascii    "px_storem"
    .byte     0
L11680:
    .ascii    "px_istorex"
    .byte     0
L11679:
    .ascii    "px_istore"
    .byte     0
L11678:
    .ascii    "px_iloadx"
    .byte     0
L11677:
    .ascii    "px_iload"
    .byte     0
L11676:
    .ascii    "px_fordown"
    .byte     0
L11675:
    .ascii    "px_forup"
    .byte     0
L11674:
    .ascii    "px_loaddecr"
    .byte     0
L11673:
    .ascii    "px_loadincr"
    .byte     0
L11672:
    .ascii    "px_decrload"
    .byte     0
L11671:
    .ascii    "px_incrload"
    .byte     0
L11670:
    .ascii    "px_decrto"
    .byte     0
L11669:
    .ascii    "px_incrto"
    .byte     0
L11668:
    .ascii    "px_stop"
    .byte     0
L11667:
    .ascii    "px_resetmx"
    .byte     0
L11666:
    .ascii    "px_startmx"
    .byte     0
L11665:
    .ascii    "px_jumpretm"
    .byte     0
L11664:
    .ascii    "px_jumpret"
    .byte     0
L11663:
    .ascii    "px_callp"
    .byte     0
L11662:
    .ascii    "px_setarg"
    .byte     0
L11661:
    .ascii    "px_setcall"
    .byte     0
L11660:
    .ascii    "px_retfn"
    .byte     0
L11659:
    .ascii    "px_retproc"
    .byte     0
L11658:
    .ascii    "px_shr"
    .byte     0
L11657:
    .ascii    "px_shl"
    .byte     0
L11656:
    .ascii    "px_bitxor"
    .byte     0
L11655:
    .ascii    "px_bitor"
    .byte     0
L11654:
    .ascii    "px_bitand"
    .byte     0
L11653:
    .ascii    "px_jumpf"
    .byte     0
L11652:
    .ascii    "px_jumpt"
    .byte     0
L11651:
    .ascii    "px_jumpcc"
    .byte     0
L11650:
    .ascii    "px_sqrt"
    .byte     0
L11649:
    .ascii    "px_sqr"
    .byte     0
L11648:
    .ascii    "px_toboolt"
    .byte     0
L11647:
    .ascii    "px_not"
    .byte     0
L11646:
    .ascii    "px_bitnot"
    .byte     0
L11645:
    .ascii    "px_abs"
    .byte     0
L11644:
    .ascii    "px_neg"
    .byte     0
L11643:
    .ascii    "px_ijump"
    .byte     0
L11642:
    .ascii    "px_jump"
    .byte     0
L11641:
    .ascii    "px_widen"
    .byte     0
L11640:
    .ascii    "px_eval"
    .byte     0
L11639:
    .ascii    "px_div"
    .byte     0
L11638:
    .ascii    "px_mul"
    .byte     0
L11637:
    .ascii    "px_sub"
    .byte     0
L11636:
    .ascii    "px_add"
    .byte     0
L11635:
    .ascii    "px_store"
    .byte     0
L11634:
    .ascii    "px_load"
    .byte     0
L11633:
    .ascii    "px_label"
    .byte     0
L11632:
    .ascii    "px_data"
    .byte     0
L11631:
    .ascii    "px_zstatic"
    .byte     0
L11630:
    .ascii    "px_istatic"
    .byte     0
L11629:
    .ascii    "px_endprog"
    .byte     0
L11628:
    .ascii    "px_endproc"
    .byte     0
L11627:
    .ascii    "px_proc"
    .byte     0
L11626:
    .ascii    "px_comment"
    .byte     0
L11625:
    .ascii    "px_type"
    .byte     0
L11624:
    .ascii    "px_opnd"
    .byte     0
L11623:
    .ascii    "px_double"
    .byte     0
L11622:
    .ascii    "px_dupl"
    .byte     0
L11621:
    .ascii    "px_nop"
    .byte     0
L11620:
    .ascii    "Shared:"
    .byte     0
L11619:
    .byte     9
    .byte     0
L11618:
    .ascii    "Constver:"
    .byte     0
L11617:
    .byte     9
    .byte     0
L11616:
    .ascii    "Ref:"
    .byte     0
L11615:
    .byte     9
    .byte     0
L11614:
    .ascii    "Signed:"
    .byte     0
L11613:
    .byte     9
    .byte     0
L11612:
    .ascii    "Const:"
    .byte     0
L11611:
    .byte     9
    .byte     0
L11610:
    .ascii    "Isblock:"
    .byte     0
L11609:
    .byte     9
    .byte     0
L11608:
    .ascii    "Length:"
    .byte     0
L11607:
    .byte     9
    .byte     0
L11606:
    .ascii    "Size:"
    .byte     0
L11605:
    .byte     9
    .byte     0
L11604:
    .ascii    "Target:"
    .byte     0
L11603:
    .byte     9
    .byte     0
L11602:
    .ascii    "-"
    .byte     0
L11601:
    .ascii    "."
    .byte     0
L11600:
    .ascii    "ttnamedef:"
    .byte     0
L11599:
    .byte     9
    .byte     0
L11598:
    .ascii    "Name:"
    .byte     0
L11597:
    .byte     9
    .byte     0
L11596:
    .ascii    "Basetype:"
    .byte     0
L11595:
    .byte     9
    .byte     0
L11594:
    .ascii    "Typedef:"
    .byte     0
L11593:
    .byte     9
    .byte     0
L11592:
    .ascii    "4"
    .byte     0
L11591:
    .ascii    "PROC MODELIST"
    .byte     0
L11590:
    .byte     10
    .ascii    "Libfiles"
    .byte     0
L11589:
    .byte     10
    .ascii    "Input file:"
    .byte     0
L11588:
    .ascii    "12jl"
    .byte     0
L11587:
    .ascii    "# # (#)"
    .byte     0
L11586:
    .ascii    "Source files"
    .byte     0
L11585:
    .ascii    "<CAN'T DO JEVAL>"
    .byte     0
L11584:
    .ascii    ")"
    .byte     0
L11583:
    .ascii    "+"
    .byte     0
L11582:
    .ascii    "("
    .byte     0
L11581:
    .ascii    ")"
    .byte     0
L11580:
    .ascii    ")/"
    .byte     0
L11579:
    .ascii    ")*"
    .byte     0
L11578:
    .ascii    "scale(("
    .byte     0
L11577:
    .ascii    "<nullunit>"
    .byte     0
L11576:
    .ascii    "--"
    .byte     0
L11575:
    .ascii    "++"
    .byte     0
L11574:
    .ascii    "--"
    .byte     0
L11573:
    .ascii    "++"
    .byte     0
L11572:
    .ascii    "<JBLOCK>"
    .byte     0
L11571:
    .ascii    ")"
    .byte     0
L11570:
    .ascii    "+"
    .byte     0
L11569:
    .ascii    "*("
    .byte     0
L11568:
    .ascii    ")"
    .byte     0
L11567:
    .ascii    "("
    .byte     0
L11566:
    .ascii    ":"
    .byte     0
L11565:
    .ascii    "?"
    .byte     0
L11564:
    .ascii    "="
    .byte     0
L11563:
    .ascii    "}"
    .byte     0
L11562:
    .ascii    ")"
    .byte     0
L11561:
    .ascii    ","
    .byte     0
L11560:
    .ascii    "{"
    .byte     0
L11559:
    .ascii    "("
    .byte     0
L11558:
    .ascii    "->"
    .byte     0
L11557:
    .ascii    "???"
    .byte     0
L11556:
    .ascii    "."
    .byte     0
L11555:
    .ascii    ")"
    .byte     0
L11554:
    .ascii    ","
    .byte     0
L11553:
    .ascii    "("
    .byte     0
L11552:
    .ascii    ")"
    .byte     0
L11551:
    .ascii    "("
    .byte     0
L11550:
    .ascii    ")"
    .byte     0
L11549:
    .ascii    "("
    .byte     0
L11548:
    .ascii    "&"
    .byte     0
L11547:
    .ascii    "EVAL/C"
    .byte     0
L11546:
    .ascii    "ARRAY"
    .byte     0
L11545:
    .byte     34
    .byte     0
L11544:
    .ascii    "LONGSTR)"
    .byte     0
L11543:
    .ascii    ")"
    .byte     0
L11542:
    .ascii    "-"
    .byte     0
L11541:
    .ascii    "(From"
    .byte     0
L11540:
    .byte     9
    .byte     0
L11539:
    .ascii    ":"
    .byte     0
L11538:
    .ascii    "GLOBAL SYMBOL TABLE:"
    .byte     0
L11537:
    .ascii    "*"
    .byte     0
L11536:
    .ascii    " Code:"
    .byte     0
L11535:
    .ascii    " Mode:"
    .byte     0
L11534:
    .ascii    "Anon"
    .byte     0
L11533:
    .byte     9
    .byte     9
    .ascii    "Param: "
    .byte     0
L11532:
    .ascii    " "
    .byte     0
L11531:
    .ascii    "Lineno:"
    .byte     0
L11530:
    .ascii    " "
    .byte     0
L11529:
    .ascii    "STATIC********"
    .byte     0
L11528:
    .ascii    "="
    .byte     0
L11527:
    .ascii    "Enum:"
    .byte     0
L11526:
    .ascii    "Index:"
    .byte     0
L11525:
    .ascii    " Offset: "
    .byte     0
L11524:
    .ascii    "="
    .byte     0
L11523:
    .ascii    "Offset:"
    .byte     0
L11522:
    .ascii    "Void "
    .byte     0
L11521:
    .ascii    "()"
    .byte     0
L11520:
    .ascii    "(#)"
    .byte     0
L11519:
    .ascii    "]"
    .byte     0
L11518:
    .ascii    "Pm:# "
    .byte     0
L11517:
    .ascii    "Used "
    .byte     0
L11516:
    .ascii    "Var "
    .byte     0
L11515:
    .ascii    " "
    .byte     0
L11514:
    .ascii    "@@"
    .byte     0
L11513:
    .ascii    " "
    .byte     0
L11512:
    .ascii    "["
    .byte     0
L11511:
    .ascii    "."
    .byte     0
L11510:
    .ascii    ":"
    .byte     0
L11509:
    .ascii    "    "
    .byte     0
L11508:
    .ascii    "PRINTST not name"
    .byte     0
L11507:
    .ascii    "z5"
    .byte     0
L11506:
    .ascii    "# "
    .byte     0
L11505:
    .ascii    "."
    .byte     0
L11504:
    .ascii    " "
    .byte     0
L11503:
    .ascii    "|---"
    .byte     0
L11502:
    .ascii    "-----------------------"
    .byte     0
L11501:
    .ascii    "3"
    .byte     0
L11500:
    .ascii    "2"
    .byte     0
L11499:
    .ascii    "1"
    .byte     0
L11498:
    .ascii    " ALENGTH="
    .byte     0
L11497:
    .ascii    " Widen from:"
    .byte     0
L11496:
    .ascii    " Offset:"
    .byte     0
L11495:
    .ascii    " Aparams:"
    .byte     0
L11494:
    .ascii    "Ptrscale:"
    .byte     0
L11493:
    .ascii    "Scale:"
    .byte     0
L11492:
    .ascii    " => "
    .byte     0
L11491:
    .ascii    " "
    .byte     0
L11490:
    .ascii    "<WSTRCONST>"
    .byte     0
L11489:
    .ascii    "<STRCONST>"
    .byte     0
L11488:
    .ascii    " "
    .byte     0
L11487:
    .ascii    "PRINTUNIT BAD CONST"
    .byte     0
L11486:
    .ascii    "PRINTUNIT/CONST/aRRAY"
    .byte     0
L11485:
    .byte     34
    .ascii    " *"
    .byte     0
L11484:
    .ascii    "(WSTRING)"
    .byte     0
L11483:
    .byte     34
    .byte     0
L11482:
    .byte     34
    .ascii    " *"
    .byte     0
L11481:
    .byte     34
    .byte     0
L11480:
    .byte     34
    .ascii    " *"
    .byte     0
L11479:
    .ascii    "(LONGSTR)"
    .byte     0
L11478:
    .byte     34
    .byte     0
L11477:
    .ascii    "Value:"
    .byte     0
L11476:
    .ascii    "1"
    .byte     0
L11475:
    .ascii    " Lastcall:"
    .byte     0
L11474:
    .ascii    " "
    .byte     0
L11473:
    .ascii    "}"
    .byte     0
L11472:
    .ascii    " {"
    .byte     0
L11471:
    .ascii    ": "
    .byte     0
L11469:
    .ascii    "             "
    .byte     0
L11468:
    .ascii    "print unit: bad tag"
    .byte     0
L11467:
    .ascii    "1"
    .byte     0
L11466:
    .ascii    "="
    .byte     0
L11465:
    .ascii    "wb"
    .byte     0
L11464:
    .ascii    "as"
    .byte     0
L11463:
    .ascii    "Writing internal"
    .byte     0
L11462:
    .ascii    "hdr"
    .byte     0
L11461:
    .ascii    " "
    .byte     0
L11460:
    .ascii    "<builtin>"
    .byte     0
L11459:
    .byte     0
L11458:
    .ascii    "Too many source files"
    .byte     0
L11457:
    .ascii    "LSF can't load "
    .byte     0
L11456:
    .byte     0
L11455:
    .ascii    "Too many source files"
    .byte     0
L11454:
    .ascii    "Stopping"
    .byte     0
L11453:
    .ascii    "Load Error:"
    .byte     0
L11452:
    .ascii    "****"
    .byte     0
L11451:
    .ascii    "**** Code Gen Error:"
    .byte     0
L11450:
    .ascii    "in file"
    .byte     0
L11449:
    .ascii    "On line"
    .byte     0
L11448:
    .ascii    " "
    .byte     0
L11447:
    .ascii    "In function"
    .byte     0
L11446:
    .ascii    "on line"
    .byte     0
L11445:
    .ascii    "Type error:"
    .byte     0
L11444:
    .byte     10
    .ascii    "In function"
    .byte     0
L11443:
    .ascii    "****"
    .byte     0
L11442:
    .ascii    "**** Syntax Error:"
    .byte     0
L11441:
    .ascii    "in file"
    .byte     0
L11440:
    .ascii    "On line"
    .byte     0
L11439:
    .ascii    "OUTSIDE PROC"
    .byte     0
L11438:
    .ascii    " "
    .byte     0
L11437:
    .byte     10
    .ascii    "In function"
    .byte     0
L11436:
    .byte     10
    .ascii    "MC Error:"
    .byte     0
L11435:
    .ascii    "w"
    .byte     0
L11434:
    .ascii    "$error.tmp"
    .byte     0
L11433:
    .ascii    "ATL ERROR"
    .byte     0
L11432:
    .ascii    "rb"
    .byte     0
L11431:
    .ascii    "w"
    .byte     0
L11430:
    .ascii    "GETALIGN SIZE NOT 1248"
    .byte     0
L11429:
    .ascii    "Dupl proc name"
    .byte     0
L11428:
    .ascii    "in"
    .byte     0
L11427:
    .byte     34
    .byte     0
L11426:
    .ascii    " "
    .byte     34
    .byte     0
L11425:
    .ascii    "# expected, not #"
    .byte     0
L11424:
    .ascii    "Too many types/cnm"
    .byte     0
L11423:
    .ascii    "STRMODE(M)="
    .byte     0
L11422:
    .ascii    "Too many types"
    .byte     0
L11421:
    .byte     0
L11420:
    .ascii    "const "
    .byte     0
L11419:
    .ascii    "<enum>"
    .byte     0
L11418:
    .ascii    "<array>"
    .byte     0
L11417:
    .ascii    "."
    .byte     0
L11416:
    .ascii    "union "
    .byte     0
L11415:
    .ascii    "struct "
    .byte     0
L11414:
    .ascii    "NEWSTRMODE"
    .byte     0
L11413:
    .ascii    ")"
    .byte     0
L11412:
    .ascii    ","
    .byte     0
L11411:
    .ascii    "proc("
    .byte     0
L11410:
    .ascii    ")"
    .byte     0
L11409:
    .ascii    " "
    .byte     0
L11408:
    .ascii    ","
    .byte     0
L11407:
    .ascii    "("
    .byte     0
L11406:
    .ascii    "enum "
    .byte     0
L11405:
    .ascii    "[]"
    .byte     0
L11404:
    .ascii    "[#]"
    .byte     0
L11403:
    .ascii    "ref "
    .byte     0
L11402:
    .ascii    "const ref "
    .byte     0
L11401:
    .ascii    "z3"
    .byte     0
L11400:
    .byte     92
    .ascii    "#o"
    .byte     0
L11399:
    .ascii    "$F"
    .byte     0
L11398:
    .ascii    "$T"
    .byte     0
L11397:
    .ascii    "GCV Not constant"
    .byte     0
L11396:
    .ascii    "Can't find -to version"
    .byte     0
L11395:
    .ascii    "to"
    .byte     0
L11393:
    .ascii    "main"
    .byte     0
L11392:
    .ascii    "."
    .byte     0
L11391:
    .ascii    "Dupl case value: #"
    .byte     0
L11390:
    .ascii    "Too many cases on one switch"
    .byte     0
L11389:
    .ascii    "case: serial switch not found"
    .byte     0
L11388:
    .ascii    "Label not defined: #"
    .byte     0
L11387:
    .ascii    "maxparams"
    .byte     0
L11386:
    .ascii    "Convert op not implem: #"
    .byte     0
L11385:
    .ascii    "Bad cast"
    .byte     0
L11384:
    .ascii    "DOASSIGN not ready: #"
    .byte     0
L11383:
    .ascii    "dxname"
    .byte     0
L11382:
    .ascii    "const?"
    .byte     0
L11381:
    .ascii    "CONST/WSTRING"
    .byte     0
L11380:
    .ascii    "DX-EXPR: can't do tag: #"
    .byte     0
L11379:
    .ascii    "2:Runtime expr in static data"
    .byte     0
L11378:
    .ascii    "*"
    .byte     0
L11377:
    .ascii    "Complex ptr expr in static data"
    .byte     0
L11376:
    .ascii    "1:Runtime or unsupported expr in static data"
    .byte     0
L11375:
    .ascii    "+"
    .byte     0
L11374:
    .ascii    "Add/Idata &frame"
    .byte     0
L11373:
    .ascii    "+"
    .byte     0
L11372:
    .ascii    ","
    .byte     0
L11371:
    .ascii    "`"
    .byte     0
L11370:
    .ascii    "Idata &frame"
    .byte     0
L11369:
    .ascii    "IDATA/SCALAR"
    .byte     0
L11368:
    .ascii    "GENIDATA/WSTRING2"
    .byte     0
L11367:
    .ascii    "$#.#.#"
    .byte     0
L11366:
    .byte     0
L11365:
    .ascii    "------------------------"
    .byte     0
L11364:
    .ascii    "GEN"
    .byte     0
L11363:
    .ascii    "------------------------"
    .byte     0
L11362:
    .ascii    "main"
    .byte     0
L11361:
    .ascii    "GEN"
    .byte     0
L11360:
    .byte     0
L11359:
    .ascii    "GEN"
    .byte     0
L11358:
    .ascii    "Static fn not defined: #"
    .byte     0
L11357:
    .ascii    "GEN"
    .byte     0
L11356:
    .ascii    "1:Start of code"
    .byte     0
L11355:
    .ascii    "GEN"
    .byte     0
L11354:
    .ascii    "GenPCL:"
    .byte     0
L11353:
    .ascii    "Generic: multiple types match"
    .byte     0
L11352:
    .ascii    "Generic: no type match"
    .byte     0
L11351:
    .ascii    "generic/default twice"
    .byte     0
L11350:
    .ascii    "Not array"
    .byte     0
L11349:
    .ascii    "*"
    .byte     0
L11348:
    .ascii    "Can't do conversion # => #"
    .byte     0
L11347:
    .ascii    "*"
    .byte     0
L11346:
    .ascii    "case not inside switch stmt"
    .byte     0
L11345:
    .ascii    "poploop?"
    .byte     0
L11344:
    .ascii    "Too many nested loop or switch"
    .byte     0
L11343:
    .ascii    "Not allowed on ptrs"
    .byte     0
L11342:
    .ascii    "-= refs don't match"
    .byte     0
L11341:
    .ascii    "ptr+=ptr"
    .byte     0
L11340:
    .ascii    "Not a field of struct # #"
    .byte     0
L11339:
    .ascii    ". -> not a struct"
    .byte     0
L11338:
    .ascii    "-> needs pointer"
    .byte     0
L11337:
    .ascii    "enum name reused #"
    .byte     0
L11336:
    .ascii    "Redefining enum #"
    .byte     0
L11335:
    .ascii    "Enum tag in use #"
    .byte     0
L11334:
    .ascii    "BAD REF[]"
    .byte     0
L11333:
    .ascii    "const to non-const pointer"
    .byte     0
L11332:
    .ascii    "Struct decl error #"
    .byte     0
L11331:
    .ascii    "Struct decl error"
    .byte     0
L11330:
    .ascii    "Can't use ss in struct"
    .byte     0
L11329:
    .ascii    "member name in use #"
    .byte     0
L11328:
    .ascii    "typedef or function inside struct"
    .byte     0
L11327:
    .ascii    "Field name expected"
    .byte     0
L11326:
    .ascii    "Redefining struct #"
    .byte     0
L11325:
    .ascii    "Prev"
    .byte     0
L11324:
    .ascii    "Struct tag in use #"
    .byte     0
L11323:
    .ascii    "ATP?"
    .byte     0
L11322:
    .ascii    "*"
    .byte     0
L11321:
    .ascii    "ATP:"
    .byte     0
L11320:
    .ascii    "Variadic param is void"
    .byte     0
L11319:
    .ascii    "Too many args"
    .byte     0
L11318:
    .ascii    "1:Too few args"
    .byte     0
L11317:
    .ascii    "ccall?"
    .byte     0
L11316:
    .ascii    "*"
    .byte     0
L11315:
    .ascii    "JTAGNAMES[P.TAG]="
    .byte     0
L11314:
    .ascii    "Not function pointer: #"
    .byte     0
L11313:
    .ascii    "value: #"
    .byte     0
L11312:
    .ascii    "*"
    .byte     0
L11311:
    .ascii    "CHECKLV/WIDEN"
    .byte     0
L11309:
    .ascii    "Invalid condition #"
    .byte     0
L11308:
    .ascii    "rem 0"
    .byte     0
L11307:
    .ascii    "div 0"
    .byte     0
L11306:
    .ascii    "EVALSUB/REF"
    .byte     0
L11304:
    .ascii    "Rem bad types"
    .byte     0
L11302:
    .ascii    "Div bad types"
    .byte     0
L11301:
    .ascii    "Mul bad types"
    .byte     0
L11300:
    .ascii    "Sub bad types"
    .byte     0
L11299:
    .ascii    "++ bad type"
    .byte     0
L11298:
    .ascii    "* not pointer"
    .byte     0
L11297:
    .ascii    "*"
    .byte     0
L11296:
    .ascii    "! bad type"
    .byte     0
L11295:
    .ascii    "abs bad type"
    .byte     0
L11293:
    .ascii    "neg bad type"
    .byte     0
L11292:
    .ascii    "; after function def"
    .byte     0
L11291:
    .ascii    "Can't define function twice #"
    .byte     0
L11290:
    .ascii    "fn: name in use #"
    .byte     0
L11289:
    .ascii    "NAME not allowed in cast type #"
    .byte     0
L11288:
    .ascii    "bad symbol in paramlist"
    .byte     0
L11287:
    .ascii    "Param name reused # #"
    .byte     0
L11286:
    .ascii    "Param type missing or misspelt"
    .byte     0
L11285:
    .ascii    "Typedef redefined or can't match types #"
    .byte     0
L11284:
    .ascii    "Typedef name in use #"
    .byte     0
L11283:
    .ascii    "Local decl error #"
    .byte     0
L11282:
    .ascii    "Nested function"
    .byte     0
L11281:
    .ascii    "Var name expected"
    .byte     0
L11280:
    .ascii    "Return value needed"
    .byte     0
L11279:
    .ascii    "Can't return value in void function"
    .byte     0
L11278:
    .ascii    "For decl error"
    .byte     0
L11277:
    .ascii    "Not allowed in for stmt"
    .byte     0
L11276:
    .ascii    "Var name expected"
    .byte     0
L11274:
    .ascii    "2:Duplicate label"
    .byte     0
L11273:
    .ascii    "continue outside loop"
    .byte     0
L11272:
    .ascii    "break outside loop/sw"
    .byte     0
L11271:
    .ascii    "{...} statement expected"
    .byte     0
L11270:
    .ascii    "Too many blocks"
    .byte     0
L11269:
    .ascii    "Too many block levels"
    .byte     0
L11268:
    .ascii    "Init str too long"
    .byte     0
L11267:
    .ascii    "Array init"
    .byte     0
L11266:
    .ascii    "{} initialiser expected"
    .byte     0
L11265:
    .ascii    "Too many struct elems"
    .byte     0
L11264:
    .ascii    "Too many array elems"
    .byte     0
L11263:
    .ascii    "init/Empty struct"
    .byte     0
L11262:
    .ascii    "init/0-size array"
    .byte     0
L11261:
    .ascii    "readconstint #"
    .byte     0
L11260:
    .ascii    "Negative array dim"
    .byte     0
L11259:
    .ascii    "ZERO LEN ARRAY"
    .byte     0
L11258:
    .ascii    "Can't do VLAs"
    .byte     0
L11257:
    .ascii    "rnt1"
    .byte     0
L11256:
    .ascii    "Can't init extern #"
    .byte     0
L11255:
    .ascii    "Can't init twice #"
    .byte     0
L11254:
    .ascii    "var: name in use #"
    .byte     0
L11253:
    .ascii    "Can't init extern #"
    .byte     0
L11252:
    .ascii    "Can't init twice #"
    .byte     0
L11251:
    .ascii    "var: redefining #"
    .byte     0
L11250:
    .ascii    "var: name in use # #"
    .byte     0
L11249:
    .ascii    "Readterm?"
    .byte     0
L11248:
    .ascii    "RT"
    .byte     0
L11247:
    .ascii    "rt/alignof"
    .byte     0
L11246:
    .ascii    "rt/compound lit"
    .byte     0
L11245:
    .ascii    "rt/&&label"
    .byte     0
L11244:
    .ascii    "char const too long"
    .byte     0
L11243:
    .ascii    "Undefined name "
    .byte     34
    .ascii    "#"
    .byte     34
    .byte     0
L11242:
    .ascii    "shift:Not an int"
    .byte     0
L11241:
    .ascii    "invalid rel operands"
    .byte     0
L11240:
    .ascii    "Comparing distinct pointers/rel"
    .byte     0
L11239:
    .ascii    "invalid == operands"
    .byte     0
L11238:
    .ascii    "U="
    .byte     0
L11237:
    .ascii    "Can't compare pointer to int2"
    .byte     0
L11236:
    .ascii    "Can't compare pointer to int"
    .byte     0
L11235:
    .ascii    "Comparing distinct pointers/eq"
    .byte     0
L11234:
    .ascii    "invalid & operands"
    .byte     0
L11233:
    .ascii    "float&float"
    .byte     0
L11232:
    .ascii    "invalid ^ operands"
    .byte     0
L11231:
    .ascii    "float^float"
    .byte     0
L11230:
    .ascii    "invalid | operands"
    .byte     0
L11229:
    .ascii    "float|float"
    .byte     0
L11228:
    .ascii    "?: incompatible types"
    .byte     0
L11227:
    .ascii    "Modifying constant?"
    .byte     0
L11226:
    .ascii    "Modifying read-only var"
    .byte     0
L11225:
    .ascii    "declspec/float"
    .byte     0
L11224:
    .ascii    "dbl decl?"
    .byte     0
L11223:
    .ascii    "char decl?"
    .byte     0
L11222:
    .ascii    "Implicit decls not allowed: #"
    .byte     0
L11221:
    .ascii    "enum?"
    .byte     0
L11220:
    .ascii    "struct?"
    .byte     0
L11219:
    .ascii    "Dual storage spec"
    .byte     0
L11218:
    .ascii    "declspec/ts #"
    .byte     0
L11217:
    .ascii    "PARSETEST"
    .byte     0
L11216:
    .ascii    "Parsing:"
    .byte     0
L11215:
    .ascii    "Decl error #"
    .byte     0
L11214:
    .ascii    "fn def after comma"
    .byte     0
L11213:
    .ascii    "Var name expected"
    .byte     0
L11212:
    .ascii    "Extra semicolon 2"
    .byte     0
L11203:
    .ascii    "Real too long"
    .byte     0
L11202:
    .ascii    "REGENHST FULL?"
    .byte     0
L11201:
    .ascii    "regenhst dupl?"
    .byte     0
L11200:
    .ascii    "mcc.h"
    .byte     0
L11199:
    .ascii    "TMLM"
    .byte     0
L11198:
    .ascii    "TMH"
    .byte     0
L11197:
    .ascii    "TMM"
    .byte     0
L11196:
    .ascii    "Str expected"
    .byte     0
L11195:
    .ascii    "link"
    .byte     0
L11194:
    .ascii    "header"
    .byte     0
L11193:
    .ascii    "module"
    .byte     0
L11192:
    .ascii    "Only pack(1) or () allowed"
    .byte     0
L11191:
    .ascii    "'(' expected"
    .byte     0
L11190:
    .ascii    "pack"
    .byte     0
L11189:
    .ascii    "2:Too many pasted tokens"
    .byte     0
L11188:
    .ascii    "PDM"
    .byte     0
L11187:
    .ascii    "???"
    .byte     0
L11186:
    .ascii    "(File not available)"
    .byte     0
L11185:
    .ascii    "z2"
    .byte     0
L11184:
    .ascii    "2"
    .byte     0
L11183:
    .ascii    "#:#:#"
    .byte     0
L11182:
    .ascii    "4"
    .byte     0
L11181:
    .ascii    "#-#-#"
    .byte     0
L11180:
    .ascii    "#if:Unexpected eof"
    .byte     0
L11179:
    .ascii    "EOL expected"
    .byte     0
L11178:
    .ascii    "Name expected"
    .byte     0
L11177:
    .ascii    "evalterm?"
    .byte     0
L11176:
    .ascii    ") expected"
    .byte     0
L11175:
    .ascii    "')' expected"
    .byte     0
L11174:
    .ascii    "sizeof2"
    .byte     0
L11173:
    .ascii    "name expected"
    .byte     0
L11172:
    .ascii    "'(' expected"
    .byte     0
L11171:
    .ascii    "')' expected"
    .byte     0
L11170:
    .ascii    "defined?"
    .byte     0
L11169:
    .ascii    "#if:div by zero"
    .byte     0
L11168:
    .ascii    ": expected"
    .byte     0
L11167:
    .ascii    "#if:eol expected"
    .byte     0
L11166:
    .ascii    "Too many pasted tokens"
    .byte     0
L11165:
    .ascii    ".*"
    .byte     0
L11164:
    .ascii    "v"
    .byte     0
L11163:
    .byte     0
L11162:
    .byte     10
    .byte     0
L11161:
    .ascii    "Too many ##"
    .byte     0
L11160:
    .ascii    "## at start"
    .byte     0
L11159:
    .ascii    "# not followed by param"
    .byte     0
L11158:
    .ascii    "# at end"
    .byte     0
L11157:
    .ascii    "Wrong # macro params"
    .byte     0
L11156:
    .ascii    "EOS in macro call"
    .byte     0
L11155:
    .ascii    "rmc: ')' expected"
    .byte     0
L11154:
    .ascii    "rmc: no '('"
    .byte     0
L11153:
    .ascii    ">"
    .byte     0
L11152:
    .ascii    "<"
    .byte     0
L11151:
    .ascii    "macro params?"
    .byte     0
L11150:
    .ascii    "')' expected"
    .byte     0
L11149:
    .ascii    "__VA_ARGS__"
    .byte     0
L11148:
    .ascii    "Dupl macro param"
    .byte     0
L11147:
    .ascii    "define: name expected"
    .byte     0
L11146:
    .ascii    "Local str too long"
    .byte     0
L11145:
    .ascii    "String not terminated"
    .byte     0
L11144:
    .ascii    "NEXTLX.LINENO="
    .byte     0
L11143:
    .ascii    "#define __attribute__(x)"
    .byte     10
    .ascii    "#define _WIN32"
    .byte     10
    .ascii    "#define WIN32"
    .byte     10
    .ascii    "#define __WIN32__"
    .byte     10
    .ascii    "#define __inline"
    .byte     10
    .ascii    "#define __dllimport(x)"
    .byte     10
    .ascii    "#define __declspec(x)"
    .byte     10
    .ascii    "#define __stdcall"
    .byte     10
    .ascii    "#define CALLBACK $callback"
    .byte     10
    .ascii    "#define __cdecl"
    .byte     10
    .ascii    "#define EXTERN_C extern"
    .byte     10
    .ascii    "#define DECLSPEC_IMPORT"
    .byte     10
    .ascii    "#define __32BIT__"
    .byte     10
    .ascii    "#define register"
    .byte     10
    .ascii    "#define __MCCC__"
    .byte     10
    .byte     10
    .ascii    "typedef signed char"
    .byte     9
    .byte     9
    .ascii    "i8;"
    .byte     10
    .ascii    "typedef short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i16;"
    .byte     10
    .ascii    "typedef int"
    .byte     9
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i32;"
    .byte     10
    .ascii    "typedef long long int"
    .byte     9
    .ascii    "i64;"
    .byte     10
    .ascii    "typedef unsigned char"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u8;"
    .byte     10
    .ascii    "typedef unsigned short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u16;"
    .byte     10
    .ascii    "typedef unsigned int"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u32;"
    .byte     10
    .ascii    "typedef unsigned long long int"
    .byte     9
    .ascii    "u64;"
    .byte     10
    .byte     10
    .ascii    "typedef unsigned char byte;"
    .byte     10
    .byte     10
    .ascii    "typedef float r32;"
    .byte     10
    .ascii    "typedef double r64;"
    .byte     10
    .byte     10
    .byte     0
L11142:
    .ascii    "mcc.h"
    .byte     0
L11141:
    .ascii    "Too many nested includes"
    .byte     0
L11140:
    .ascii    "Can't find include file"
    .byte     0
L11139:
    .ascii    "Overflow in decimal number"
    .byte     0
L11138:
    .ascii    "18446744073709551615"
    .byte     0
L11137:
    .ascii    "-U?"
    .byte     0
L11136:
    .ascii    "-LL?"
    .byte     0
L11135:
    .ascii    "Overflow in octal number"
    .byte     0
L11134:
    .ascii    "1777777777777777777777"
    .byte     0
L11133:
    .ascii    "-U?"
    .byte     0
L11132:
    .ascii    "-LL?"
    .byte     0
L11131:
    .ascii    "Overflow in binary number"
    .byte     0
L11130:
    .ascii    "Binary fp"
    .byte     0
L11129:
    .ascii    "Binary bad digit"
    .byte     0
L11128:
    .ascii    "Overflow in hex number"
    .byte     0
L11127:
    .ascii    "-U?"
    .byte     0
L11126:
    .ascii    "-LL?"
    .byte     0
L11125:
    .ascii    "block comment eof"
    .byte     0
L11124:
    .ascii    ":##"
    .byte     0
L11123:
    .ascii    ":::"
    .byte     0
L11122:
    .ascii    "#endif missing"
    .byte     0
L11121:
    .ascii    "Directive not implemented"
    .byte     0
L11120:
    .ascii    "DIRECTIVE NOT IMPL:"
    .byte     0
L11119:
    .ascii    "ABORTING"
    .byte     0
L11118:
    .ascii    "#ERROR:"
    .byte     0
L11117:
    .ascii    "#if missing/endif"
    .byte     0
L11116:
    .ascii    "#if missing/elif/else"
    .byte     0
L11115:
    .ascii    "undef: name expected"
    .byte     0
L11114:
    .ascii    "NSOURCEFILES="
    .byte     0
L11113:
    .ascii    "FROM"
    .byte     0
L11112:
    .ascii    "INCLUDE"
    .byte     0
L11111:
    .ascii    "include?"
    .byte     0
L11110:
    .ascii    "include: > expected"
    .byte     0
L11109:
    .ascii    "Bad include file"
    .byte     0
L11108:
    .ascii    "Invalid # directive"
    .byte     0
L11107:
    .ascii    "Duplicate symbol table entry"
    .byte     0
L11106:
    .ascii    "HASHTABLE FULL"
    .byte     0
L11105:
    .ascii    "Digit out of range"
    .byte     0
L11104:
    .ascii    ".*"
    .byte     0
L11103:
    .ascii    "v"
    .byte     0
L11102:
    .ascii    ".*"
    .byte     0
L11101:
    .ascii    "v"
    .byte     0
L11100:
    .ascii    "#"
    .byte     0
L11099:
    .ascii    "'"
    .byte     0
L11098:
    .byte     34
    .byte     0
L11097:
    .ascii    " "
    .byte     0
L11096:
    .ascii    "%-18s"
    .byte     0
L11095:
    .ascii    "Line:"
    .byte     0
L11094:
    .ascii    "in:"
    .byte     0
L11093:
    .byte     10
    .ascii    "Lex error"
    .byte     0
L11092:
    .ascii    "Non-base-10 floats temporarily unavailable"
    .byte     0
L11091:
    .ascii    "p"
    .byte     0
L11090:
    .ascii    "e"
    .byte     0
L11088:
    .ascii    "Real too long"
    .byte     0
L11087:
    .ascii    "ERROR CHAR"
    .byte     0
L11086:
    .ascii    "@ SEEN"
    .byte     0
L11085:
    .ascii    "wb"
    .byte     0
L11084:
    .ascii    "#endif missing"
    .byte     0
L11083:
    .ascii    "mcc.h"
    .byte     0
L11082:
    .ascii    "18:52:22"
    .byte     0
L11081:
    .ascii    "28-Sep-2025"
    .byte     0
L11080:
    .ascii    "CC C Compiler"
    .byte     0
L11079:
    .ascii    "C Subset Compiler for 64-bit Windows"
    .byte     10
    .byte     10
    .ascii    "Normal use:           Compiles prog.c to:"
    .byte     10
    .byte     10
    .ascii    "    cc      prog      prog.exe (default)"
    .byte     10
    .ascii    "    cc -r   prog      in-memory native code then execute"
    .byte     10
    .ascii    "    cc -i   prog      in-memory IL then interpret"
    .byte     10
    .byte     10
    .ascii    "    cc -exe prog      prog.exe"
    .byte     10
    .ascii    "    cc -dll prog      prog.dll"
    .byte     10
    .ascii    "    cc -obj prog      prog.obj"
    .byte     10
    .ascii    "    cc -a   prog      prog.asm"
    .byte     10
    .ascii    "    cc -n   prog      prog.nasm"
    .byte     10
    .ascii    "    cc -mx  prog      prog.mx"
    .byte     10
    .ascii    "    cc -p   prog      prog.pcl (textual IL)"
    .byte     10
    .ascii    "    cc -e   prog      prog.i   (preprocess only)"
    .byte     10
    .byte     10
    .ascii    "Other options:"
    .byte     10
    .byte     10
    .ascii    "    -incl:path        Add path to search for includes"
    .byte     10
    .ascii    "    -ext              Used std headers external to compiler"
    .byte     10
    .ascii    "    -opt              Optimise native code"
    .byte     10
    .ascii    "    -out:file         Name output file (extension can be added)"
    .byte     10
    .ascii    "    -rip              Use RIP address modes"
    .byte     10
    .ascii    "    -himem            Generate PIC code (automatic with -obj/-dll)"
    .byte     10
    .ascii    "    @file             Read files and options from a file"
    .byte     10
    .ascii    "    file.dll          Include one or more extra dynamic libs"
    .byte     10
    .ascii    "    -c                Same as -obj"
    .byte     10
    .ascii    "    -s                Same as -asm"
    .byte     10
    .ascii    "    -ei               Same as -e, but when result is interpreted"
    .byte     10
    .byte     10
    .ascii    "Notes:"
    .byte     10
    .byte     10
    .ascii    "    * Compiles single module only (use bcc driver program for multiple-modules)"
    .byte     10
    .ascii    "    * For -i and -r, options and any .dlls must appear before the C source file"
    .byte     10
    .ascii    "    * .c extension is optional on input file"
    .byte     10
    .byte     0
L11078:
    .ascii    "Include paths"
    .byte     0
L11077:
    .ascii    "/"
    .byte     0
L11076:
    .byte     0
L11075:
    .ascii    "Too many include paths"
    .byte     0
L11074:
    .byte     0
L11073:
    .ascii    "-RUNP OUT OF ORDER"
    .byte     0
L11072:
    .ascii    "-help                Show all options"
    .byte     0
L11071:
    .ascii    "    "
    .byte     0
L11070:
    .ascii    "-i prog[.c]          Compile prog.c and interpret"
    .byte     0
L11069:
    .ascii    "    "
    .byte     0
L11068:
    .ascii    "-r prog[.c]          Compile prog.c and run"
    .byte     0
L11067:
    .ascii    "    "
    .byte     0
L11066:
    .ascii    "   prog[.c]          Compile prog.c to prog.exe"
    .byte     0
L11065:
    .ascii    "    "
    .byte     0
L11064:
    .ascii    "Usage:"
    .byte     0
L11063:
    .byte     0
L11062:
    .ascii    "Too many lib files"
    .byte     0
L11061:
    .byte     0
L11060:
    .ascii    "One input file only"
    .byte     0
L11059:
    .ascii    "Unknown option:"
    .byte     0
L11058:
    .ascii    ".c"
    .byte     0
L11057:
    .byte     0
L11056:
    .ascii    "cs.exe"
    .byte     0
L11055:
    .ascii    "Total:"
    .byte     0
L11054:
    .ascii    "-----------------------------"
    .byte     0
L11053:
    .ascii    "EXE:"
    .byte     0
L11052:
    .ascii    "SS:"
    .byte     0
L11051:
    .ascii    "MCL:"
    .byte     0
L11050:
    .ascii    "PCL:"
    .byte     0
L11049:
    .ascii    "Parse:"
    .byte     0
L11048:
    .ascii    "Load:"
    .byte     0
L11047:
    .ascii    "Init:"
    .byte     0
L11046:
    .ascii    "5.1jr"
    .byte     0
L11044:
    .ascii    "5"
    .byte     0
L11043:
    .ascii    "12jl"
    .byte     0
L11042:
    .ascii    "# # ms # %"
    .byte     0
L11041:
    .ascii    "Size:"
    .byte     0
L11040:
    .ascii    ":"
    .byte     0
L11039:
    .ascii    "Sourcefiles:"
    .byte     0
L11038:
    .ascii    "PROC"
    .byte     0
L11037:
    .ascii    "PROC AST"
    .byte     0
L11036:
    .ascii    ": ."
    .byte     0
L11035:
    .ascii    ":"
    .byte     0
L11034:
    .ascii    "0: Internal standard headers (disable with -ext)"
    .byte     0
L11033:
    .ascii    "Include search paths:"
    .byte     0
L11032:
    .ascii    "c:/cx/headers/"
    .byte     0
L11031:
    .byte     0
L11030:
    .ascii    "<line>"
    .byte     0
L11029:
    .ascii    "kernel32"
    .byte     0
L11028:
    .ascii    "user32"
    .byte     0
L11027:
    .ascii    "gdi32"
    .byte     0
L11026:
    .ascii    "msvcrt"
    .byte     0
L11025:
    .ascii    "mcc.log"
    .byte     0
L11024:
    .ascii    "Diagnostic outputs written to"
    .byte     0
L11023:
    .ascii    "mcc.log"
    .byte     0
L11022:
    .byte     92
    .ascii    "m"
    .byte     92
    .ascii    "scripts"
    .byte     92
    .ascii    "med.bat "
    .byte     0
L11021:
    .ascii    "PRESS KEY"
    .byte     0
L11020:
    .ascii    "cc.m"
    .byte     0
L11019:
    .ascii    "STFLAT"
    .byte     0
L11018:
    .ascii    "ST"
    .byte     0
L11017:
    .ascii    "PSYMTAB"
    .byte     0
L11016:
    .ascii    "!PROC PCL"
    .byte     0
L11015:
    .ascii    "PROC ASM"
    .byte     0
L11014:
    .ascii    "w"
    .byte     0
L11013:
    .ascii    "mcc.log"
    .byte     0
L11012:
    .ascii    "CLI"
    .byte     0
L11011:
    .ascii    "Can't load main module: #"
    .byte     0
L11010:
    .ascii    "$prog"
    .byte     0
L11009:
    .ascii    "<sourcefile0>"
    .byte     0
L11008:
    .ascii    "<dummy path>"
    .byte     0
L11007:
    .ascii    "<dummy file>"
    .byte     0
L11006:
    .ascii    "Loading:"
    .byte     0
L11005:
    .ascii    "Done."
    .byte     0
L11004:
    .ascii    "not ready"
    .byte     0
L11003:
    .ascii    "CLI"
    .byte     0
L11002:
    .ascii    "Compiling # to #"
    .byte     0
L11001:
    .ascii    "CLI"
    .byte     0
L11000:
    .ascii    "reloc?"
    .byte     0
L10999:
    .ascii    "rel32/rel not imported"
    .byte     0
L10998:
    .ascii    "0.1234"
    .byte     0
L10997:
    .byte     0
L10996:
    .ascii    "No entry point found"
    .byte     0
L10995:
    .ascii    "$cmdskip"
    .byte     0
L10994:
    .ascii    "msys.$cmdskip"
    .byte     0
L10993:
    .byte     0
L10992:
    .ascii    "Too many Imports"
    .byte     0
L10991:
    .byte     0
L10990:
    .ascii    "Too many DLLs"
    .byte     0
L10989:
    .ascii    "Dupl symbol:"
    .byte     0
L10988:
    .ascii    "Can't find #"
    .byte     0
L10987:
    .ascii    "ml"
    .byte     0
L10986:
    .ascii    "Loading sublib"
    .byte     0
L10985:
    .byte     0
L10984:
    .ascii    "imprel32?"
    .byte     0
L10983:
    .ascii    "Undef"
    .byte     0
L10982:
    .ascii    "Can't find DLL: #"
    .byte     0
L10981:
    .byte     0
L10980:
    .ascii    "Too many libs"
    .byte     0
L10979:
    .ascii    "Lib already exists:"
    .byte     0
L10978:
    .ascii    "Aborting"
    .byte     0
L10977:
    .byte     0
L10976:
    .ascii    "Can't alloc code memory"
    .byte     0
L10975:
    .ascii    "Unknown directive:"
    .byte     0
L10974:
    .ascii    "Bad sig - not MCX file"
    .byte     0
L10972:
    .ascii    "NO MAIN FOUND"
    .byte     0
L10971:
    .ascii    "reloc?"
    .byte     0
L10970:
    .ascii    "rel32/rel not imported"
    .byte     0
L10969:
    .ascii    "0.1234"
    .byte     0
L10967:
    .ascii    "W:too many strings"
    .byte     0
L10966:
    .ascii    ".text"
    .byte     0
L10965:
    .ascii    ".data"
    .byte     0
L10964:
    .ascii    ".bss"
    .byte     0
L10963:
    .ascii    ".file"
    .byte     0
L10962:
    .ascii    "as:Too many symbols"
    .byte     0
L10961:
    .ascii    "OBJ/phighmem 1?"
    .byte     0
L10960:
    .ascii    "wrelocs/bad seg"
    .byte     0
L10959:
    .ascii    "Writing file:"
    .byte     0
L10958:
    .ascii    ".text"
    .byte     0
L10957:
    .ascii    ".data"
    .byte     0
L10956:
    .ascii    "Too many relocs (exceeds 16-bit field)"
    .byte     0
L10955:
    .ascii    ".bss"
    .byte     0
L10954:
    .ascii    "GSN"
    .byte     0
L10953:
    .ascii    "Too many blocks"
    .byte     0
L10951:
    .ascii    "Too many exports - can't sort"
    .byte     0
L10950:
    .ascii    "Entry point not found: main"
    .byte     0
L10949:
    .ascii    "User entry point not found"
    .byte     0
L10947:
    .ascii    "Can't do this rel type"
    .byte     0
L10946:
    .ascii    "RELOCDATA/SEG?"
    .byte     0
L10945:
    .ascii    "rel32/not imported"
    .byte     0
L10944:
    .ascii    "gendll: Too many exports"
    .byte     0
L10943:
    .ascii    "genexe: Too many imports"
    .byte     0
L10942:
    .ascii    "2:Too many libs"
    .byte     0
L10941:
    .ascii    ".dll"
    .byte     0
L10940:
    .ascii    "Can't find external function"
    .byte     0
L10939:
    .ascii    "Too many libs"
    .byte     0
L10938:
    .ascii    ".dll"
    .byte     0
L10937:
    .ascii    ".idata"
    .byte     0
L10936:
    .ascii    ".bss"
    .byte     0
L10935:
    .ascii    ".data"
    .byte     0
L10934:
    .ascii    "10s,jr"
    .byte     0
L10933:
    .ascii    "Zdata size:"
    .byte     0
L10932:
    .ascii    "10s,jr"
    .byte     0
L10931:
    .ascii    "Code+Idata:"
    .byte     0
L10930:
    .ascii    "10s,jr"
    .byte     0
L10929:
    .ascii    "Idata size:"
    .byte     0
L10928:
    .ascii    "bytes"
    .byte     0
L10927:
    .ascii    "10s,jr"
    .byte     0
L10926:
    .ascii    "Code size: "
    .byte     0
L10925:
    .ascii    ".text"
    .byte     0
L10924:
    .ascii    "Can't load search lib"
    .byte     0
L10923:
    .ascii    "File:"
    .byte     0
L10922:
    .ascii    "Error writing exe file (possibly still running)"
    .byte     0
L10921:
    .ascii    "10s,jr"
    .byte     0
L10920:
    .ascii    "EXE size:  "
    .byte     0
L10919:
    .byte     0
L10918:
    .ascii    "u64 "
    .byte     0
L10917:
    .ascii    "u32 "
    .byte     0
L10916:
    .ascii    "u16 "
    .byte     0
L10915:
    .ascii    "byte "
    .byte     0
L10914:
    .byte     0
L10913:
    .ascii    "    $highmem"
    .byte     10
    .byte     0
L10912:
    .ascii    "    $userip"
    .byte     10
    .byte     0
L10911:
    .ascii    "#.$T#"
    .byte     0
L10910:
    .ascii    "T"
    .byte     0
L10909:
    .byte     0
L10908:
    .ascii    "X"
    .byte     0
L10907:
    .ascii    "`"
    .byte     0
L10906:
    .byte     0
L10905:
    .ascii    "##R.#"
    .byte     0
L10904:
    .ascii    "XMM"
    .byte     0
L10903:
    .ascii    "-"
    .byte     0
L10902:
    .ascii    "sp"
    .byte     0
L10901:
    .ascii    "fp"
    .byte     0
L10900:
    .ascii    "-"
    .byte     0
L10899:
    .byte     0
L10898:
    .ascii    "Stropnd?"
    .byte     0
L10897:
    .ascii    "L"
    .byte     0
L10896:
    .byte     34
    .byte     0
L10895:
    .ascii    "M"
    .byte     0
L10894:
    .ascii    "20.20"
    .byte     0
L10893:
    .byte     0
L10892:
    .ascii    "+"
    .byte     0
L10891:
    .byte     0
L10890:
    .ascii    "<BAD OPND>"
    .byte     0
L10889:
    .ascii    "BAD OPND"
    .byte     0
L10888:
    .ascii    "]"
    .byte     0
L10887:
    .ascii    " + "
    .byte     0
L10886:
    .ascii    "*"
    .byte     0
L10885:
    .ascii    " + "
    .byte     0
L10884:
    .byte     0
L10883:
    .ascii    "["
    .byte     0
L10882:
    .ascii    "H"
    .byte     0
L10881:
    .ascii    "0x"
    .byte     0
L10880:
    .ascii    ","
    .byte     0
L10879:
    .ascii    ","
    .byte     9
    .byte     0
L10878:
    .ascii    " "
    .byte     0
L10877:
    .ascii    "dq"
    .byte     0
L10876:
    .ascii    "not"
    .byte     0
L10875:
    .ascii    "xor"
    .byte     0
L10874:
    .ascii    "or"
    .byte     0
L10873:
    .ascii    "and"
    .byte     0
L10872:
    .ascii    "cmov"
    .byte     0
L10871:
    .ascii    "set"
    .byte     0
L10870:
    .ascii    "j"
    .byte     0
L10869:
    .ascii    " = "
    .byte     0
L10868:
    .ascii    "    "
    .byte     0
L10867:
    .ascii    " = "
    .byte     0
L10866:
    .ascii    "    "
    .byte     0
L10865:
    .ascii    "L#:"
    .byte     0
L10864:
    .ascii    "::"
    .byte     0
L10863:
    .byte     10
    .ascii    "`"
    .byte     0
L10862:
    .ascii    ":"
    .byte     0
L10861:
    .byte     0
L10860:
    .ascii    "strmcl/lab"
    .byte     0
L10859:
    .ascii    ";End"
    .byte     10
    .byte     0
L10856:
    .ascii    ";Proc "
    .byte     0
L10855:
    .ascii    "dshift/size"
    .byte     0
L10854:
    .ascii    "bswap reg>"
    .byte     0
L10853:
    .ascii    "fixrip disp?"
    .byte     0
L10852:
    .ascii    "DISPSIZE="
    .byte     0
L10851:
    .ascii    "movdq opnds"
    .byte     0
L10850:
    .ascii    "movdq mem,?"
    .byte     0
L10849:
    .ascii    "5:movdq size"
    .byte     0
L10848:
    .ascii    "movdq xreg,?"
    .byte     0
L10847:
    .ascii    "31:movdq size"
    .byte     0
L10846:
    .ascii    "3:movdq size"
    .byte     0
L10845:
    .ascii    "movdq reg,?"
    .byte     0
L10844:
    .ascii    "1:movdq size"
    .byte     0
L10843:
    .ascii    "float opnds"
    .byte     0
L10842:
    .ascii    "fix opnds"
    .byte     0
L10841:
    .ascii    "convertfloat opnds"
    .byte     0
L10840:
    .ascii    "logicxmm opnds"
    .byte     0
L10839:
    .ascii    "arithxmm opnds"
    .byte     0
L10838:
    .ascii    "Wrong size"
    .byte     0
L10837:
    .ascii    "A.SIZE="
    .byte     0
L10836:
    .ascii    "Need size"
    .byte     0
L10835:
    .ascii    "setcc opnd/size"
    .byte     0
L10834:
    .ascii    "test opnds"
    .byte     0
L10833:
    .ascii    "shift opnds2?"
    .byte     0
L10832:
    .ascii    "cl or b10 needed"
    .byte     0
L10831:
    .ascii    "shift/label"
    .byte     0
L10830:
    .ascii    "shift opnds1?"
    .byte     0
L10829:
    .ascii    "imul2 opnds"
    .byte     0
L10828:
    .ascii    "mul/label"
    .byte     0
L10827:
    .ascii    "imul2 size"
    .byte     0
L10826:
    .ascii    "imul2 byte"
    .byte     0
L10825:
    .ascii    "imul2 opnds"
    .byte     0
L10824:
    .ascii    "movsxd opnds"
    .byte     0
L10823:
    .ascii    "movsxd size"
    .byte     0
L10822:
    .ascii    "exch size"
    .byte     0
L10821:
    .ascii    "exch opnds"
    .byte     0
L10820:
    .ascii    "exch size"
    .byte     0
L10819:
    .ascii    "movsx not reg/mem"
    .byte     0
L10818:
    .ascii    "movsx size 8"
    .byte     0
L10817:
    .ascii    "movsx need size prefix"
    .byte     0
L10816:
    .ascii    "movsx 4=>8 bytes?"
    .byte     0
L10815:
    .ascii    "movsx size error"
    .byte     0
L10814:
    .ascii    "movsx not reg"
    .byte     0
L10813:
    .ascii    "LEA size error"
    .byte     0
L10812:
    .ascii    "A.SIZE="
    .byte     0
L10811:
    .ascii    "LEA not reg/mem"
    .byte     0
L10810:
    .ascii    "neg/div/etc opnd?"
    .byte     0
L10809:
    .ascii    "inc/opnd?"
    .byte     0
L10808:
    .ascii    "pop opnd?"
    .byte     0
L10807:
    .ascii    "pop not 64-bit"
    .byte     0
L10806:
    .ascii    "popreg not 64-bit"
    .byte     0
L10805:
    .ascii    "push opnd?"
    .byte     0
L10804:
    .ascii    "push not 64-bit"
    .byte     0
L10803:
    .ascii    "push imm value too large"
    .byte     0
L10802:
    .ascii    "pushreg not 64-bit"
    .byte     0
L10801:
    .ascii    "MOV ?/.."
    .byte     0
L10800:
    .ascii    "MOV MEM/?"
    .byte     0
L10799:
    .ascii    "mov imm?"
    .byte     0
L10798:
    .ascii    "3:Opnd size mismatch"
    .byte     0
L10797:
    .ascii    "MOV REG/??"
    .byte     0
L10796:
    .ascii    "1:exceeding u32 value"
    .byte     0
L10795:
    .ascii    "exceeding u16 value"
    .byte     0
L10794:
    .ascii    "exceeding byte value"
    .byte     0
L10793:
    .ascii    "mov imm?"
    .byte     0
L10792:
    .ascii    "2:Opnd size mismatch"
    .byte     0
L10791:
    .ascii    "1:Can't add to this opnd"
    .byte     0
L10790:
    .ascii    "CODE="
    .byte     0
L10789:
    .ascii    "ADD mem,???"
    .byte     0
L10788:
    .ascii    "ADD reg,???"
    .byte     0
L10787:
    .ascii    "Exceeding i8/u8 range"
    .byte     0
L10786:
    .ascii    "add imm/size"
    .byte     0
L10785:
    .ascii    "Addr32 can't use RIP, line"
    .byte     0
L10784:
    .ascii    "Can't scale rstack"
    .byte     0
L10783:
    .ascii    "Scaled rstack?"
    .byte     0
L10782:
    .ascii    "genrm not mem"
    .byte     0
L10781:
    .ascii    "2:exceeding u32 value"
    .byte     0
L10780:
    .ascii    "exceeding u16 value"
    .byte     0
L10779:
    .ascii    "exceeding byte value"
    .byte     0
L10778:
    .ascii    "dbuffer error"
    .byte     0
L10777:
    .ascii    "l#"
    .byte     0
L10776:
    .ascii    "bsf size"
    .byte     0
L10775:
    .ascii    "genrel8"
    .byte     0
L10774:
    .ascii    "fmem int size"
    .byte     0
L10773:
    .ascii    "fst i64?"
    .byte     0
L10772:
    .ascii    "fmem size"
    .byte     0
L10771:
    .ascii    "SIZE="
    .byte     0
L10770:
    .ascii    "r80 not allowed"
    .byte     0
L10769:
    .ascii    "fmem/not mem"
    .byte     0
L10768:
    .ascii    "cmov/byte"
    .byte     0
L10767:
    .ascii    "1:Opnd size mismatch"
    .byte     0
L10766:
    .ascii    "jmp[]size"
    .byte     0
L10765:
    .ascii    "call[]size"
    .byte     0
L10764:
    .ascii    "Can't do jcxz fwd jump"
    .byte     0
L10763:
    .ascii    "jcxz jmp out of range"
    .byte     0
L10762:
    .ascii    "Can't do loopxx fwd jump"
    .byte     0
L10761:
    .ascii    "loop jmp out of range"
    .byte     0
L10760:
    .ascii    "Operand size not set"
    .byte     0
L10759:
    .ascii    "genamode size 2/8"
    .byte     0
L10758:
    .ascii    "GENAMODE/MODE?"
    .byte     0
L10757:
    .ascii    "genam/3"
    .byte     0
L10756:
    .ascii    "DOFWDREFS/CAN'T DO RELTYPE"
    .byte     0
L10755:
    .ascii    "Fwd ref in zdata"
    .byte     0
L10754:
    .ascii    "Rel label across segments2"
    .byte     0
L10753:
    .ascii    "getdef/no def"
    .byte     0
L10752:
    .ascii    "Rel label across segments"
    .byte     0
L10751:
    .ascii    "OPND/8/VALTYPE?"
    .byte     0
L10750:
    .ascii    "OPND/4/VALTYPE?"
    .byte     0
L10749:
    .ascii    "8/16-BIT RELOC"
    .byte     0
L10748:
    .ascii    "GENSS/NAME OPND"
    .byte     0
L10747:
    .ascii    "STOPPING"
    .byte     0
L10746:
    .ascii    "M_HALT="
    .byte     0
L10745:
    .ascii    "M.OPCODE="
    .byte     0
L10744:
    .ascii    "line"
    .byte     0
L10743:
    .ascii    "*** Can't do opcode"
    .byte     0
L10742:
    .ascii    "align?"
    .byte     0
L10741:
    .ascii    "align2"
    .byte     0
L10740:
    .ascii    "resb?"
    .byte     0
L10739:
    .ascii    "retn?"
    .byte     0
L10738:
    .ascii    "Zdata contains code or data"
    .byte     0
L10737:
    .byte     0
L10736:
    .ascii    "delmcl?"
    .byte     0
L10735:
    .ascii    " ncalldepth:"
    .byte     0
L10734:
    .ascii    " noperands:"
    .byte     0
L10733:
    .ascii    ") hwstack:"
    .byte     0
L10732:
    .ascii    "0 "
    .byte     0
L10731:
    .ascii    "1 "
    .byte     0
L10730:
    .ascii    "XWR:("
    .byte     0
L10729:
    .ascii    ") "
    .byte     0
L10728:
    .ascii    "0 "
    .byte     0
L10727:
    .ascii    "1 "
    .byte     0
L10726:
    .ascii    "WR:("
    .byte     0
L10725:
    .ascii    " "
    .byte     0
L10724:
    .ascii    ") "
    .byte     0
L10723:
    .ascii    ", "
    .byte     0
L10722:
    .ascii    ">"
    .byte     0
L10721:
    .ascii    "<"
    .byte     0
L10720:
    .ascii    "@"
    .byte     0
L10719:
    .ascii    ")"
    .byte     0
L10718:
    .ascii    "(=="
    .byte     0
L10717:
    .ascii    "T"
    .byte     0
L10716:
    .ascii    "*"
    .byte     0
L10715:
    .byte     0
L10714:
    .ascii    "W:"
    .byte     0
L10713:
    .ascii    "X:"
    .byte     0
L10712:
    .ascii    "Y:"
    .byte     0
L10711:
    .ascii    "Z:"
    .byte     0
L10710:
    .ascii    "#:("
    .byte     0
L10709:
    .ascii    "========================================#:("
    .byte     0
L10708:
    .byte     0
L10707:
    .ascii    "MSA"
    .byte     0
L10706:
    .byte     0
L10705:
    .ascii    "makeopndind"
    .byte     0
L10704:
    .byte     0
L10703:
    .ascii    "SOR1"
    .byte     0
L10702:
    .byte     0
L10701:
    .ascii    "MOVE TO REG: XREG IN USE"
    .byte     0
L10700:
    .byte     0
L10699:
    .ascii    "No more work xregs"
    .byte     0
L10698:
    .byte     0
L10697:
    .ascii    "No more work regs"
    .byte     0
L10696:
    .byte     0
L10695:
    .ascii    "poppcl/underflow"
    .byte     0
L10694:
    .byte     0
L10693:
    .ascii    "PCL stack overflow"
    .byte     0
L10692:
    .byte     0
L10691:
    .ascii    "PCL stack overflow"
    .byte     0
L10690:
    .ascii    "getopnd"
    .byte     0
L10689:
    .byte     0
L10688:
    .ascii    "Ext nametab overflow"
    .byte     0
L10687:
    .ascii    "$B#"
    .byte     0
L10686:
    .byte     0
L10685:
    .ascii    "Too many block temps"
    .byte     0
L10684:
    .ascii    "Line:"
    .byte     0
L10683:
    .ascii    "AX ERROR:"
    .byte     0
L10682:
    .ascii    "MCL Opnd not supported: # (#) [#]"
    .byte     0
L10681:
    .byte     0
L10680:
    .ascii    "2:SIZE=0"
    .byte     0
L10679:
    .byte     0
L10678:
    .ascii    "1:SIZE=0"
    .byte     0
L10677:
    .byte     0
L10676:
    .ascii    "BAD SEG CODE"
    .byte     0
L10675:
    .byte     0
L10674:
    .ascii    "CAN'T DO RODATA SEG"
    .byte     0
L10673:
    .ascii    "MCLREC>64B"
    .byte     0
L10672:
    .ascii    "__getmainargs*"
    .byte     0
L10671:
    .ascii    "$info"
    .byte     0
L10670:
    .ascii    "$env"
    .byte     0
L10669:
    .ascii    "()"
    .byte     0
L10668:
    .ascii    "High block arg not copied in"
    .byte     0
L10667:
    .ascii    "No host fn:"
    .byte     0
L10666:
    .ascii    "gethostfn?"
    .byte     0
L10665:
    .ascii    "msysc.m$power_i64"
    .byte     0
L10664:
    .ascii    "msys.m$power_i64"
    .byte     0
L10663:
    .byte     0
L10662:
    .ascii    "storebf not imm"
    .byte     0
L10661:
    .byte     0
L10660:
    .ascii    "Storebit: both vars"
    .byte     0
L10659:
    .byte     0
L10658:
    .ascii    "STOREBIT/VAR"
    .byte     0
L10657:
    .byte     0
L10656:
    .ascii    "LOADBF_VAR"
    .byte     0
L10655:
    .ascii    "mask63/offset64"
    .byte     0
L10654:
    .ascii    "labzero"
    .byte     0
L10653:
    .ascii    "labneg64"
    .byte     0
L10652:
    .ascii    "labneg32"
    .byte     0
L10651:
    .ascii    "lababs64"
    .byte     0
L10650:
    .ascii    "lababs32"
    .byte     0
L10648:
    .ascii    "Real32 Table"
    .byte     0
L10646:
    .ascii    "Real Table"
    .byte     0
L10645:
    .ascii    "String Table"
    .byte     0
L10644:
    .ascii    "ENDDATA"
    .byte     0
L10643:
    .byte     0
L10642:
    .ascii    "div/u8"
    .byte     0
L10641:
    .byte     0
L10640:
    .ascii    "Divide by zero"
    .byte     0
L10639:
    .ascii    "---------------"
    .byte     0
L10638:
    .ascii    "?]]"
    .byte     0
L10637:
    .byte     0
L10636:
    .ascii    "Threaded proc has temps"
    .byte     0
L10635:
    .byte     0
L10634:
    .ascii    "Threaded proc has locals/params"
    .byte     0
L10633:
    .byte     0
L10632:
    .ascii    "@PARAM"
    .byte     0
L10631:
    .ascii    "$1x"
    .byte     0
L10629:
    .byte     0
L10628:
    .ascii    "SUBTOREF/EXTRA"
    .byte     0
L10627:
    .ascii    "pow*"
    .byte     0
L10626:
    .byte     0
L10625:
    .ascii    "setcc/block"
    .byte     0
L10624:
    .ascii    "fmod*"
    .byte     0
L10623:
    .ascii    "atan2*"
    .byte     0
L10622:
    .ascii    "ceil*"
    .byte     0
L10621:
    .ascii    "floor*"
    .byte     0
L10620:
    .ascii    "round*"
    .byte     0
L10619:
    .ascii    "exp*"
    .byte     0
L10618:
    .ascii    "log10*"
    .byte     0
L10617:
    .ascii    "log*"
    .byte     0
L10616:
    .ascii    "atan*"
    .byte     0
L10615:
    .ascii    "acos*"
    .byte     0
L10614:
    .ascii    "asin*"
    .byte     0
L10613:
    .ascii    "tan*"
    .byte     0
L10612:
    .ascii    "cos*"
    .byte     0
L10611:
    .ascii    "sin*"
    .byte     0
L10610:
    .byte     0
L10609:
    .ascii    "No Assem handler"
    .byte     0
L10608:
    .byte     0
L10607:
    .ascii    "SUB/REF NOT POWER OF xx"
    .byte     0
L10606:
    .byte     0
L10605:
    .ascii    "float/short"
    .byte     0
L10604:
    .byte     0
L10603:
    .ascii    "multo/byte"
    .byte     0
L10602:
    .ascii    ":"
    .byte     0
L10601:
    .byte     0
L10600:
    .ascii    "swap/block"
    .byte     0
L10599:
    .byte     0
L10598:
    .ascii    "SUBREF/EXTRA"
    .byte     0
L10597:
    .ascii    "EXTRA="
    .byte     0
L10596:
    .byte     0
L10595:
    .ascii    "Storem not 16"
    .byte     0
L10594:
    .ascii    "exit*"
    .byte     0
L10593:
    .byte     0
L10592:
    .ascii    "Too many nested calls"
    .byte     0
L10591:
    .ascii    "---"
    .byte     0
L10590:
    .byte     0
L10589:
    .ascii    "JUMPCC/BLOCK"
    .byte     0
L10588:
    .byte     0
L10587:
    .ascii    "DATA/not 1248"
    .byte     0
L10586:
    .ascii    "STRPMODE(P.MODE)="
    .byte     0
L10585:
    .ascii    "P.SIZE="
    .byte     0
L10584:
    .ascii    "db/dq optype? #"
    .byte     0
L10583:
    .ascii    "PCL STACK NOT EMPTY"
    .byte     0
L10582:
    .ascii    "?>>"
    .byte     0
L10581:
    .ascii    "Unimpl: # (#)"
    .byte     0
L10580:
    .ascii    "                       "
    .byte     0
L10579:
    .ascii    "Invalid handler name:"
    .byte     0
L10578:
    .ascii    "px_"
    .byte     0
L10577:
    .ascii    "    CONV"
    .byte     0
L10576:
    .ascii    "MCL"
    .byte     0
L10575:
    .ascii    "MCL1"
    .byte     0
L10574:
    .ascii    "MCL"
    .byte     0
L10573:
    .ascii    "********* ASM HAS PCL INFO *********"
    .byte     0
L10572:
    .ascii    "$cmdskip"
    .byte     0
L10571:
    .ascii    "Can't load lib:"
    .byte     0
L10570:
    .ascii    "Can't find DLL func:"
    .byte     0
L10569:
    .ascii    "in"
    .byte     0
L10568:
    .ascii    "Unsupported operand:"
    .byte     0
L10567:
    .ascii    "seq:"
    .byte     0
L10566:
    .ascii    "PC Exec error:"
    .byte     0
L10565:
    .byte     0
L10564:
    .ascii    "Not mem"
    .byte     0
L10563:
    .ascii    "Null ptr access"
    .byte     0
L10562:
    .ascii    "Stopped"
    .byte     0
L10561:
    .ascii    "Run PCL:"
    .byte     0
L10560:
    .byte     0
L10559:
    .ascii    "No 'main' entry point"
    .byte     0
L10558:
    .byte     0
L10557:
    .ascii    "data &mem = nil"
    .byte     0
L10556:
    .byte     0
L10555:
    .ascii    "data &mem"
    .byte     0
L10554:
    .byte     0
L10553:
    .ascii    "FIX/DATA/MEM"
    .byte     0
L10552:
    .ascii    "Unimpl: # at seq: #"
    .byte     0
L10551:
    .ascii    "GETOPCODE="
    .byte     0
L10550:
    .ascii    "# Enter:  # SP=# FP=#"
    .byte     0
L10549:
    .ascii    "  "
    .byte     0
L10531:
    .byte     0
L10530:
    .ascii    "swap/block"
    .byte     0
L10529:
    .byte     0
L10528:
    .ascii    "setcc/r32"
    .byte     0
L10527:
    .byte     0
L10526:
    .ascii    "setcc/r64"
    .byte     0
L10525:
    .byte     0
L10524:
    .ascii    "ICALLF NIL PTR"
    .byte     0
L10523:
    .byte     0
L10522:
    .ascii    "ICALLP NIL PTR"
    .byte     0
L10521:
    .byte     0
L10520:
    .ascii    "RETF/SP mismatch: old=# curr=# "
    .byte     0
L10519:
    .byte     0
L10518:
    .ascii    "ref/call underflow"
    .byte     0
L10517:
    .byte     0
L10516:
    .ascii    "RETP/SP mismatch: old=# curr=# "
    .byte     0
L10515:
    .byte     0
L10514:
    .ascii    "retp/call underflow"
    .byte     0
L10513:
    .ascii    "Proc not defined:"
    .byte     0
L10512:
    .byte     0
L10511:
    .ascii    "Stack overflow"
    .byte     0
L10510:
    .ascii    "# Call:   # # SP=# FP=#"
    .byte     0
L10509:
    .ascii    "  "
    .byte     0
L10508:
    .ascii    "<Fn ptr>"
    .byte     0
L10507:
    .ascii    "  Loc: # used:#, addrof:#"
    .byte     0
L10506:
    .ascii    "  Pm: # used:#, addrof:#"
    .byte     0
L10505:
    .ascii    "  Hasblocks:#"
    .byte     0
L10504:
    .ascii    "  MCLdone:  #"
    .byte     0
L10503:
    .ascii    "  Assem:    #"
    .byte     0
L10502:
    .ascii    "  Nmaxargs: #"
    .byte     0
L10501:
    .ascii    "  Leaf:     #"
    .byte     0
L10500:
    .ascii    "  Locals:   #"
    .byte     0
L10499:
    .ascii    "  Params:   #"
    .byte     0
L10498:
    .ascii    "PROC INFO FOR: #"
    .byte     0
L10497:
    .ascii    " Has statics"
    .byte     0
L10496:
    .ascii    ")"
    .byte     0
L10495:
    .ascii    "H"
    .byte     0
L10494:
    .ascii    ") (D:"
    .byte     0
L10493:
    .ascii    " (Proc:"
    .byte     0
L10492:
    .ascii    ")"
    .byte     0
L10491:
    .ascii    " "
    .byte     0
L10490:
    .ascii    " ("
    .byte     0
L10489:
    .ascii    "H"
    .byte     0
L10488:
    .ascii    " .PCADDR ="
    .byte     0
L10487:
    .ascii    " ENTRY PT"
    .byte     0
L10486:
    .ascii    " Dot"
    .byte     0
L10485:
    .ascii    " TC"
    .byte     0
L10484:
    .ascii    " Var:"
    .byte     0
L10483:
    .ascii    " Imp"
    .byte     0
L10482:
    .ascii    " Exp"
    .byte     0
L10481:
    .ascii    " Loc:"
    .byte     0
L10480:
    .ascii    " Pm:"
    .byte     0
L10479:
    .ascii    " "
    .byte     0
L10478:
    .ascii    "4"
    .byte     0
L10477:
    .ascii    "21jl"
    .byte     0
L10476:
    .ascii    "    "
    .byte     0
L10475:
    .ascii    "21jl"
    .byte     0
L10474:
    .ascii    "    "
    .byte     0
L10473:
    .ascii    "25jl"
    .byte     0
L10472:
    .ascii    " "
    .byte     0
L10471:
    .ascii    "H"
    .byte     0
L10470:
    .ascii    "PROC PC Symbol table"
    .byte     0
L10469:
    .ascii    " "
    .byte     0
L10468:
    .ascii    "  "
    .byte     0
L10467:
    .ascii    "    data mem:"
    .byte     0
L10466:
    .ascii    " "
    .byte     0
L10465:
    .ascii    ":"
    .byte     0
L10464:
    .ascii    "#"
    .byte     0
L10463:
    .ascii    " "
    .byte     0
L10462:
    .byte     10
    .byte     0
L10461:
    .ascii    " 1"
    .byte     0
L10460:
    .ascii    "extproc    "
    .byte     0
L10459:
    .byte     34
    .byte     0
L10458:
    .ascii    "addlib    "
    .byte     34
    .byte     0
L10457:
    .ascii    "!PROC PCL"
    .byte     0
L10456:
    .ascii    "<BIGSTR>"
    .byte     0
L10455:
    .ascii    "<PCLOPND?>"
    .byte     0
L10454:
    .ascii    "---------"
    .byte     0
L10453:
    .ascii    "<Data * # (#)>"
    .byte     0
L10452:
    .byte     0
L10451:
    .ascii    "#"
    .byte     0
L10450:
    .ascii    "## "
    .byte     0
L10449:
    .ascii    "&"
    .byte     0
L10448:
    .ascii    ":"
    .byte     0
L10447:
    .byte     34
    .byte     0
L10446:
    .ascii    "e16.16"
    .byte     0
L10445:
    .ascii    "infinity"
    .byte     0
L10443:
    .byte     0
L10442:
    .ascii    " "
    .byte     0
L10441:
    .ascii    "/"
    .byte     0
L10440:
    .ascii    " "
    .byte     0
L10439:
    .ascii    "/"
    .byte     0
L10438:
    .ascii    "set"
    .byte     0
L10437:
    .ascii    "jump"
    .byte     0
L10436:
    .ascii    "    "
    .byte     0
L10435:
    .ascii    "endprog"
    .byte     0
L10434:
    .ascii    "endproc"
    .byte     0
L10433:
    .ascii    "    variadic"
    .byte     0
L10432:
    .ascii    "    rettype  "
    .byte     0
L10431:
    .ascii    "       "
    .byte     0
L10430:
    .ascii    "    local    "
    .byte     0
L10429:
    .ascii    "       "
    .byte     0
L10428:
    .ascii    "    param    "
    .byte     0
L10427:
    .ascii    ":"
    .byte     0
L10426:
    .ascii    "::"
    .byte     0
L10425:
    .ascii    " "
    .byte     0
L10424:
    .ascii    "proc"
    .byte     0
L10423:
    .ascii    "tcproc"
    .byte     0
L10422:
    .ascii    "! - - -"
    .byte     0
L10421:
    .ascii    "!"
    .byte     0
L10420:
    .ascii    ":"
    .byte     0
L10419:
    .ascii    "! "
    .byte     0
L10418:
    .ascii    " NOT USED"
    .byte     0
L10417:
    .ascii    "z2h"
    .byte     0
L10415:
    .ascii    "MCL Error: # (#) on Line: # in #, PCL:#"
    .byte     0
L10414:
    .ascii    "Proc:"
    .byte     0
L10413:
    .ascii    "?"
    .byte     0
L10412:
    .ascii    "FILENAME="
    .byte     0
L10411:
    .ascii    "LINENO="
    .byte     0
L10410:
    .ascii    "No proc"
    .byte     0
L10409:
    .ascii    "Dupl proc:"
    .byte     0
L10408:
    .ascii    "Nested proc"
    .byte     0
L10407:
    .byte     0
L10406:
    .ascii    "Too many libs"
    .byte     0
L10405:
    .ascii    "w"
    .byte     0
L10404:
    .ascii    "$error.tmp"
    .byte     0
L10403:
    .ascii    "."
    .byte     0
L10402:
    .ascii    "*"
    .byte     0
L10401:
    .ascii    "`"
    .byte     0
L10400:
    .ascii    "PCL Error:"
    .byte     0
L10399:
    .ascii    ":"
    .byte     0
L10398:
    .ascii    "PCL error:"
    .byte     0
L10397:
    .ascii    "---"
    .byte     0
L10396:
    .ascii    "mem:"
    .byte     0
L10395:
    .byte     0
L10394:
    .ascii    "dummy"
    .byte     0
L10393:
    .ascii    "PHIGHMEM="
    .byte     0
L10392:
    .ascii    "w"
    .byte     0
L10391:
    .ascii    "Writing"
    .byte     0
L10390:
    .ascii    "w"
    .byte     0
L10389:
    .byte     0
L10388:
    .ascii    "Writing PST"
    .byte     0
L10387:
    .byte     0
L10386:
    .ascii    "Writing PCL"
    .byte     0
L10385:
    .ascii    "PCL start?"
    .byte     0
L10384:
    .ascii    "C:@@@@"
    .byte     92
    .ascii    "m"
    .byte     92
    .byte     34
    .byte     0
L10383:
    .ascii    "wb"
    .byte     0
L10382:
    .ascii    "con"
    .byte     0
L10381:
    .ascii    "rb"
    .byte     0
L10380:
    .ascii    "con"
    .byte     0
L10379:
    .ascii    "W64"
    .byte     0
L10378:
    .ascii    "Regclass error: %lld %lld"
    .byte     10
    .byte     0
L10376:
    .ascii    "pcc001"
    .byte     0
L10374:
    .ascii    "Winexec error: %lld"
    .byte     10
    .byte     0
L10369:
    .ascii    "@file item too long"
    .byte     0
L10368:
    .ascii    "Unexpected EOF in @file"
    .byte     0
L10367:
    .ascii    "mcx"
    .byte     0
L10366:
    .ascii    "dll"
    .byte     0
L10365:
    .ascii    "Can't open"
    .byte     0
L10364:
    .byte     10
    .byte     0
L10363:
    .ascii    " "
    .byte     0
L10362:
    .byte     0
L10361:
    .ascii    "."
    .byte     0
L10360:
    .byte     0
L10359:
    .ascii    "."
    .byte     0
L10358:
    .ascii    "line too long"
    .byte     0
L10357:
    .ascii    "rb"
    .byte     0
L10356:
    .ascii    "wb"
    .byte     0
L10355:
    .ascii    "rb"
    .byte     0
L10354:
    .ascii    "ABORTING: Press key..."
    .byte     0
L10353:
    .ascii    "Realloc mem failure"
    .byte     0
L10352:
    .ascii    "Alloc mem failure"
    .byte     0
L10351:
    .ascii    "Can't alloc pc heap"
    .byte     0
L10350:
    .ascii    "pcm_alloc failure"
    .byte     0
L10349:
    .ascii    "%.*s"
    .byte     0
L10348:
    .ascii    "MCL-UNIMPL: %s"
    .byte     10
    .byte     0
L10346:
    .ascii    "%lf%n"
    .byte     0
L10344:
    .ascii    "READ CMDLINE"
    .byte     0
L10342:
    .ascii    "<mindint>"
    .byte     0
L10341:
    .ascii    "1000000000000000000000000000000000000000000000000000000000000000"
    .byte     0
L10340:
    .ascii    "8000000000000000"
    .byte     0
L10339:
    .ascii    "9223372036854775808"
    .byte     0
L10338:
    .ascii    "|"
    .byte     0
L10337:
    .ascii    "%.*s"
    .byte     0
L10336:
    .ascii    " "
    .byte     0
L10335:
    .byte     10
    .byte     0
L10334:
    .ascii    "PRTSL"
    .byte     0
L10333:
    .ascii    "<null>"
    .byte     0
L10332:
    .ascii    "%f"
    .byte     0
L10331:
    .ascii    "%llu"
    .byte     0
L10330:
    .ascii    "False"
    .byte     0
L10329:
    .ascii    "True"
    .byte     0
L10328:
    .ascii    "z8H"
    .byte     0
L10327:
    .ascii    "Too many io levels"
    .byte     10
    .byte     0
L10326:
    .ascii    "Too many params"
    .byte     10
    .byte     0
L10325:
    .ascii    "windowsx.h"
    .byte     0
L10324:
    .ascii    "_mingw.h"
    .byte     0
L10323:
    .ascii    "winsock2.h"
    .byte     0
L10322:
    .ascii    "conio.h"
    .byte     0
L10321:
    .ascii    "memory.h"
    .byte     0
L10320:
    .ascii    "process.h"
    .byte     0
L10319:
    .ascii    "direct.h"
    .byte     0
L10318:
    .ascii    "io.h"
    .byte     0
L10317:
    .ascii    "fcntl.h"
    .byte     0
L10316:
    .ascii    "malloc.h"
    .byte     0
L10315:
    .ascii    "sys/utime.h"
    .byte     0
L10314:
    .ascii    "sys/timeb.h"
    .byte     0
L10313:
    .ascii    "sys/stat.h"
    .byte     0
L10312:
    .ascii    "sys/types.h"
    .byte     0
L10311:
    .ascii    "wctype.h"
    .byte     0
L10310:
    .ascii    "wchar.h"
    .byte     0
L10309:
    .ascii    "safelib.h"
    .byte     0
L10308:
    .ascii    "unistd.h"
    .byte     0
L10307:
    .ascii    "utime.h"
    .byte     0
L10306:
    .ascii    "time.h"
    .byte     0
L10305:
    .ascii    "string.h"
    .byte     0
L10304:
    .ascii    "_syslist.h"
    .byte     0
L10303:
    .ascii    "stdlib.h"
    .byte     0
L10302:
    .ascii    "stdio.h"
    .byte     0
L10301:
    .ascii    "stddef.h"
    .byte     0
L10300:
    .ascii    "stdbool.h"
    .byte     0
L10299:
    .ascii    "stdarg.h"
    .byte     0
L10298:
    .ascii    "signal.h"
    .byte     0
L10297:
    .ascii    "setjmp.h"
    .byte     0
L10296:
    .ascii    "math.h"
    .byte     0
L10295:
    .ascii    "_ansi.h"
    .byte     0
L10294:
    .ascii    "locale.h"
    .byte     0
L10293:
    .ascii    "limits.h"
    .byte     0
L10292:
    .ascii    "stdint.h"
    .byte     0
L10291:
    .ascii    "inttypes.h"
    .byte     0
L10290:
    .ascii    "float.h"
    .byte     0
L10289:
    .ascii    "fenv.h"
    .byte     0
L10288:
    .ascii    "errno.h"
    .byte     0
L10287:
    .ascii    "ctype.h"
    .byte     0
L10286:
    .ascii    "assert.h"
    .byte     0
L10285:
    .ascii    "/* Header windowsx.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $windowsx"
    .byte     13
    .byte     10
    .ascii    "#define $windowsx 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))"
    .byte     13
    .byte     10
    .ascii    "#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif // windowsx"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10284:
    .ascii    "/*"
    .byte     13
    .byte     10
    .ascii    " * _mingw.h"
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This file is for TinyCC and not part of the Mingw32 package."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  THIS SOFTWARE IS NOT COPYRIGHTED"
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This source code is offered for use in the public domain. You may"
    .byte     13
    .byte     10
    .ascii    " *  use, modify or distribute it freely."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This code is distributed in the hope that it will be useful but"
    .byte     13
    .byte     10
    .ascii    " *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY"
    .byte     13
    .byte     10
    .ascii    " *  DISCLAIMED. This includes but is not limited to warranties of"
    .byte     13
    .byte     10
    .ascii    " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef __MINGW_H"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_H"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* some winapi files define these before including _mingw.h --> */"
    .byte     13
    .byte     10
    .ascii    "#undef __cdecl"
    .byte     13
    .byte     10
    .ascii    "#undef _X86_"
    .byte     13
    .byte     10
    .ascii    "#undef WIN32"
    .byte     13
    .byte     10
    .ascii    "/* <-- */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .ascii    "#include <stdarg.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __int8 char"
    .byte     13
    .byte     10
    .ascii    "#define __int16 short"
    .byte     13
    .byte     10
    .ascii    "#define __int32 int"
    .byte     13
    .byte     10
    .ascii    "#define __int64 long long"
    .byte     13
    .byte     10
    .ascii    "#define _HAVE_INT64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __cdecl"
    .byte     13
    .byte     10
    .ascii    "#define __declspec(x) __attribute__((x))"
    .byte     13
    .byte     10
    .ascii    "#define __unaligned __attribute__((packed))"
    .byte     13
    .byte     10
    .ascii    "#define __fastcall __attribute__((fastcall))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __MSVCRT__ 1"
    .byte     13
    .byte     10
    .ascii    "#undef _MSVCRT_"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_IMPORT extern __declspec(dllimport)"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_NORETURN"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_CONST"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_DEPRECATED"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_MALLOC"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_PURE"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_NONNULL(arg)"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_NOTHROW"
    .byte     13
    .byte     10
    .ascii    "#define __GNUC_VA_LIST"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _CRTIMP extern"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_INLINE extern __inline__"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _CRT_ALIGN(x) __attribute__((aligned(x)))"
    .byte     13
    .byte     10
    .ascii    "#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_PACKING 8"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_UNALIGNED"
    .byte     13
    .byte     10
    .ascii    "#define _CONST_RETURN"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TRUNCATE"
    .byte     13
    .byte     10
    .ascii    "#define _TRUNCATE ((size_t)-1)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __CRT_STRINGIZE(_Value) #_Value"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_WIDE(_String) L ## _String"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_WIDE(_String) __CRT_WIDE(_String)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifdef _WIN64"
    .byte     13
    .byte     10
    .ascii    "#define __stdcall"
    .byte     13
    .byte     10
    .ascii    "#define _AMD64_ 1"
    .byte     13
    .byte     10
    .ascii    "#define __x86_64 1"
    .byte     13
    .byte     10
    .ascii    "#define _M_X64 100 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define _M_AMD64 100 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define USE_MINGW_SETJMP_TWO_ARGS"
    .byte     13
    .byte     10
    .ascii    "#define mingw_getsp tinyc_getbp"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "#define __stdcall __attribute__((__stdcall__))"
    .byte     13
    .byte     10
    .ascii    "#define _X86_ 1"
    .byte     13
    .byte     10
    .ascii    "#define _M_IX86 300 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define WIN32 1"
    .byte     13
    .byte     10
    .ascii    "#define _USE_32BIT_TIME_T"
    .byte     13
    .byte     10
    .ascii    "#ifdef __arm__"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* in stddef.h */"
    .byte     13
    .byte     10
    .ascii    "#define _SIZE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _SSIZE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _PTRDIFF_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _UINTPTR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _INTPTR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _INTEGRAL_MAX_BITS 64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME32_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME32_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long __time32_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME64_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME64_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long long __time64_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#ifdef _USE_32BIT_TIME_T"
    .byte     13
    .byte     10
    .ascii    "typedef __time32_t time_t;"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "typedef __time64_t time_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _WCTYPE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _WCTYPE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef wchar_t wctype_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _WINT_T"
    .byte     13
    .byte     10
    .ascii    "#define _WINT_T"
    .byte     13
    .byte     10
    .ascii    "typedef short wint_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef int errno_t;"
    .byte     13
    .byte     10
    .ascii    "#define _ERRCODE_DEFINED"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct threadlocaleinfostruct *pthreadlocinfo;"
    .byte     13
    .byte     10
    .ascii    "typedef struct threadmbcinfostruct *pthreadmbcinfo;"
    .byte     13
    .byte     10
    .ascii    "typedef struct localeinfo_struct _locale_tstruct,*_locale_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* for winapi */"
    .byte     13
    .byte     10
    .ascii    "#define _ANONYMOUS_UNION"
    .byte     13
    .byte     10
    .ascii    "#define _ANONYMOUS_STRUCT"
    .byte     13
    .byte     10
    .ascii    "#define DECLSPEC_NORETURN"
    .byte     13
    .byte     10
    .ascii    "#define DECLARE_STDCALL_P(type) __stdcall type"
    .byte     13
    .byte     10
    .ascii    "#define NOSERVICE 1"
    .byte     13
    .byte     10
    .ascii    "#define NOMCX 1"
    .byte     13
    .byte     10
    .ascii    "#define NOIME 1"
    .byte     13
    .byte     10
    .ascii    "#define __INTRIN_H_"
    .byte     13
    .byte     10
    .ascii    "#ifndef DUMMYUNIONNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME1"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME2"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME3"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME4"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME5"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef DUMMYSTRUCTNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYSTRUCTNAME"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef WINVER"
    .byte     13
    .byte     10
    .ascii    "# define WINVER 0x0502"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef _WIN32_WINNT"
    .byte     13
    .byte     10
    .ascii    "# define _WIN32_WINNT 0x502"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __C89_NAMELESS"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_EXTENSION"
    .byte     13
    .byte     10
    .ascii    "#define WINAPI_FAMILY_PARTITION(X) 1"
    .byte     13
    .byte     10
    .ascii    "#define MINGW_HAS_SECURE_API"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif /* __MINGW_H */"
    .byte     13
    .byte     10
    .byte     0
L10283:
    .ascii    "#ifndef _WINSOCK2_H"
    .byte     13
    .byte     10
    .ascii    "#define _WINSOCK2_H"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <_mingw.h>"
    .byte     13
    .byte     10
    .ascii    "#include <windows.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_SETSIZE"
    .byte     13
    .byte     10
    .ascii    "#define FD_SETSIZE 64"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int SOCKET;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct fd_set {"
    .byte     13
    .byte     10
    .ascii    "  unsigned int   fd_count;"
    .byte     13
    .byte     10
    .ascii    "  SOCKET  fd_array[FD_SETSIZE];"
    .byte     13
    .byte     10
    .ascii    "} fd_set;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_CLR"
    .byte     13
    .byte     10
    .ascii    "#define FD_CLR(fd,set) do { unsigned int __i;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_array[__i] == (fd)) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    while (__i < ((fd_set *)(set))->fd_count-1) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        __i++;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    ((fd_set*)(set))->fd_count--;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    break;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "} while (0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_SET"
    .byte     13
    .byte     10
    .ascii    "/* this differs from the define in winsock.h and in cygwin sys/types.h */"
    .byte     13
    .byte     10
    .ascii    "#define FD_SET(fd, set) do { unsigned int __i;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_array[__i] == (fd)) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        break;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "if (__i == ((fd_set *)(set))->fd_count) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set *)(set))->fd_array[__i] = (fd);"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set *)(set))->fd_count++;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "} while(0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_ZERO"
    .byte     13
    .byte     10
    .ascii    "#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_ISSET"
    .byte     13
    .byte     10
    .ascii    "#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */"
    .byte     13
    .byte     10
    .ascii    "#define _TIMEVAL_DEFINED"
    .byte     13
    .byte     10
    .ascii    "struct timeval {"
    .byte     13
    .byte     10
    .ascii    "    long tv_sec;"
    .byte     13
    .byte     10
    .ascii    "    long tv_usec;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct in_addr {"
    .byte     13
    .byte     10
    .ascii    "    union {"
    .byte     13
    .byte     10
    .ascii    "        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;"
    .byte     13
    .byte     10
    .ascii    "        struct { unsigned short s_w1,s_w2; } S_un_w;"
    .byte     13
    .byte     10
    .ascii    "        unsigned long S_addr;"
    .byte     13
    .byte     10
    .ascii    "    } S_un;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define s_addr  S_un.S_addr"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct sockaddr_in {"
    .byte     13
    .byte     10
    .ascii    "    short sin_family;"
    .byte     13
    .byte     10
    .ascii    "    unsigned short sin_port;"
    .byte     13
    .byte     10
    .ascii    "    struct in_addr sin_addr;"
    .byte     13
    .byte     10
    .ascii    "    char sin_zero[8];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct sockaddr {"
    .byte     13
    .byte     10
    .ascii    "    unsigned short sa_family;"
    .byte     13
    .byte     10
    .ascii    "    char sa_data[14];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct hostent {"
    .byte     13
    .byte     10
    .ascii    "    char *h_name;"
    .byte     13
    .byte     10
    .ascii    "    char **h_aliases;"
    .byte     13
    .byte     10
    .ascii    "    short h_addrtype;"
    .byte     13
    .byte     10
    .ascii    "    short h_length;"
    .byte     13
    .byte     10
    .ascii    "    char **h_addr_list;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define h_addr h_addr_list[0]"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WSADESCRIPTION_LEN  256"
    .byte     13
    .byte     10
    .ascii    "#define WSASYS_STATUS_LEN   128"
    .byte     13
    .byte     10
    .ascii    "typedef struct WSAData {"
    .byte     13
    .byte     10
    .ascii    "    WORD wVersion;"
    .byte     13
    .byte     10
    .ascii    "    WORD wHighVersion;"
    .byte     13
    .byte     10
    .ascii    "    char szDescription[WSADESCRIPTION_LEN+1];"
    .byte     13
    .byte     10
    .ascii    "    char szSystemStatus[WSASYS_STATUS_LEN+1];"
    .byte     13
    .byte     10
    .ascii    "    unsigned short iMaxSockets;"
    .byte     13
    .byte     10
    .ascii    "    unsigned short iMaxUdpDg;"
    .byte     13
    .byte     10
    .ascii    "    char *lpVendorInfo;"
    .byte     13
    .byte     10
    .ascii    "} WSADATA;"
    .byte     13
    .byte     10
    .ascii    "typedef WSADATA *LPWSADATA;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INVALID_SOCKET (SOCKET)(~0)"
    .byte     13
    .byte     10
    .ascii    "#define SOCK_STREAM  1"
    .byte     13
    .byte     10
    .ascii    "#define SO_REUSEADDR 4"
    .byte     13
    .byte     10
    .ascii    "#define AF_INET 2"
    .byte     13
    .byte     10
    .ascii    "#define MSG_PEEK 0x2"
    .byte     13
    .byte     10
    .ascii    "#define INADDR_ANY (unsigned long)0x00000000"
    .byte     13
    .byte     10
    .ascii    "#define INADDR_LOOPBACK 0x7f000001"
    .byte     13
    .byte     10
    .ascii    "#define SOL_SOCKET 0xffff"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SD_RECEIVE  0x00"
    .byte     13
    .byte     10
    .ascii    "#define SD_SEND     0x01"
    .byte     13
    .byte     10
    .ascii    "#define SD_BOTH     0x02"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define h_errno WSAGetLastError()"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WSABASEERR 10000"
    .byte     13
    .byte     10
    .ascii    "#define TRY_AGAIN (WSABASEERR+1002)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "SOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall bind(SOCKET, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall closesocket(SOCKET);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall connect(SOCKET, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "struct hostent *__stdcall gethostbyname(const char *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall gethostname(char *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall getpeername(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall getsockname(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "unsigned long __stdcall htonl(unsigned long);"
    .byte     13
    .byte     10
    .ascii    "unsigned short __stdcall htons(unsigned short);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall listen(SOCKET, int);"
    .byte     13
    .byte     10
    .ascii    "unsigned long __stdcall ntohl(unsigned long);"
    .byte     13
    .byte     10
    .ascii    "unsigned short __stdcall ntohs(unsigned short);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall recv(SOCKET, char *, int, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall send(SOCKET, const char *, int, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall setsockopt(SOCKET, int, int, const char *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall shutdown(SOCKET, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSACleanup(void);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSAGetLastError(void);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSAStartup(WORD, LPWSADATA);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "SOCKET __stdcall socket(int, int, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10282:
    .ascii    "/* conio.h */"
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .ascii    "#include <wchar.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _getch(void);"
    .byte     13
    .byte     10
    .ascii    "int _kbhit(void);"
    .byte     13
    .byte     10
    .ascii    "wint_t _getwch(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define getch _getch"
    .byte     13
    .byte     10
    .ascii    "#define kbhit _kbhit"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _putch(int);"
    .byte     13
    .byte     10
    .ascii    "int _cprintf(char *, ...);"
    .byte     13
    .byte     10
    .ascii    "int _getche(void);"
    .byte     13
    .byte     10
    .ascii    "int _ungetch(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define putch _putch"
    .byte     13
    .byte     10
    .ascii    "#define cprintf _cprintf"
    .byte     13
    .byte     10
    .ascii    "#define getche _getche"
    .byte     13
    .byte     10
    .ascii    "#define ungetch _ungetch"
    .byte     13
    .byte     10
    .byte     0
L10281:
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "void* malloc(size_t);"
    .byte     10
    .ascii    "void* realloc(void *, size_t);"
    .byte     10
    .ascii    "void  free(void *);"
    .byte     10
    .ascii    "void *_alloca(size_t);"
    .byte     10
    .byte     10
    .ascii    "#define alloca malloc"
    .byte     10
    .byte     0
L10280:
    .ascii    "/* Header process.h */"
    .byte     13
    .byte     10
    .ascii    "#ifndef $process"
    .byte     13
    .byte     10
    .ascii    "#define $process"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define P_WAIT"
    .byte     9
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "#define P_NOWAIT"
    .byte     9
    .ascii    "1"
    .byte     13
    .byte     10
    .ascii    "#define P_OVERLAY"
    .byte     9
    .ascii    "2"
    .byte     13
    .byte     10
    .ascii    "#define P_DETACH"
    .byte     9
    .ascii    "4"
    .byte     13
    .byte     10
    .ascii    "#define WAIT_CHILD 0"
    .byte     13
    .byte     10
    .ascii    "#define _P_WAIT P_WAIT"
    .byte     13
    .byte     10
    .ascii    "#define _P_NOWAIT P_NOWAIT"
    .byte     13
    .byte     10
    .ascii    "#define _P_OVERLAY P_OVERLAY"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _spawnvp(int, const char*, const char*const*);"
    .byte     13
    .byte     10
    .ascii    "#define spawnvp _spawnvp"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void endthread(void);"
    .byte     13
    .byte     10
    .ascii    "unsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);"
    .byte     13
    .byte     10
    .ascii    "void _endthreadex(unsigned);"
    .byte     13
    .byte     10
    .ascii    "int _cwait(int*, int, int);"
    .byte     13
    .byte     10
    .ascii    "#define cwait _cwait"
    .byte     13
    .byte     10
    .ascii    "//int _System(const char *cmd,int nCmdShow);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _execve(const char*, const char*const*, const char*const*);"
    .byte     13
    .byte     10
    .ascii    "#define execve _execve"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define _WAIT_CHILD"
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "//#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10279:
    .ascii    "#ifndef $direct"
    .byte     13
    .byte     10
    .ascii    "#define $direct"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct {"
    .byte     13
    .byte     10
    .ascii    " unsigned int total_clusters;"
    .byte     13
    .byte     10
    .ascii    " unsigned int avail_clusters;"
    .byte     13
    .byte     10
    .ascii    " unsigned int sectors_per_cluster;"
    .byte     13
    .byte     10
    .ascii    " unsigned int bytes_per_sector;"
    .byte     13
    .byte     10
    .ascii    "} diskfree_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int chdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "char* _getcwd(char *, int);"
    .byte     13
    .byte     10
    .ascii    "#define getcwd _getcwd"
    .byte     13
    .byte     10
    .ascii    "int _mkdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "int _rmdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "int _wrmdir(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _wmkdir(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define mkdir _mkdir"
    .byte     13
    .byte     10
    .ascii    "#define rmdir _rmdir"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _chdrive(int);"
    .byte     13
    .byte     10
    .ascii    "char* _getdcwd(int, char *, int);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* _wgetcwd(wchar_t*, int);"
    .byte     13
    .byte     10
    .ascii    "int _wchdir(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _getdrive(void);"
    .byte     13
    .byte     10
    .ascii    "int _chdir(const char*);"
    .byte     13
    .byte     10
    .ascii    "#define chdir _chdir"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned long _getdrives(void);"
    .byte     13
    .byte     10
    .ascii    "unsigned int _getdiskfree(unsigned int, diskfree_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10278:
    .byte     13
    .byte     10
    .ascii    "#ifndef $io"
    .byte     13
    .byte     10
    .ascii    "#define $io"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .ascii    "#include <wchar.h>"
    .byte     13
    .byte     10
    .ascii    "#include <time.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* io.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _A_NORMAL 0x00"
    .byte     13
    .byte     10
    .ascii    "#define _A_RDONLY 0x01"
    .byte     13
    .byte     10
    .ascii    "#define _A_HIDDEN 0x02"
    .byte     13
    .byte     10
    .ascii    "#define _A_SYSTEM 0x04"
    .byte     13
    .byte     10
    .ascii    "#define _A_SUBDIR 0x10"
    .byte     13
    .byte     10
    .ascii    "#define _A_ARCH 0x20"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#message "
    .byte     34
    .ascii    "IO included"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "struct _finddata_t {"
    .byte     13
    .byte     10
    .ascii    "        unsigned    attrib;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_create;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_access;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_write;"
    .byte     13
    .byte     10
    .ascii    "        unsigned long    size;"
    .byte     13
    .byte     10
    .ascii    "        char        name[260];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _isatty(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _read(int, void*, unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define read _read"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _open(const char*, int, ...);"
    .byte     13
    .byte     10
    .ascii    "#define open _open"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "long _lseek(int, long, int);"
    .byte     13
    .byte     10
    .ascii    "#define lseek _lseek"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _close(int);"
    .byte     13
    .byte     10
    .ascii    "#define close _close"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _get_osfhandle(int);"
    .byte     13
    .byte     10
    .ascii    "int _open_osfhandle(intptr_t,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _setmode(int,int);"
    .byte     13
    .byte     10
    .ascii    "#define setmode _setmode"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wchmod(const wchar_t*, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _chmod(const char *, int);"
    .byte     13
    .byte     10
    .ascii    "#define chmod _chmod"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _dup(int);"
    .byte     13
    .byte     10
    .ascii    "#define dup _dup"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _findfirst(const char*, struct _finddata_t*);"
    .byte     13
    .byte     10
    .ascii    "int _findnext(intptr_t, struct _finddata_t*);"
    .byte     13
    .byte     10
    .ascii    "int _findclose(intptr_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _access(const char*,int);"
    .byte     13
    .byte     10
    .ascii    "#define access _access"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wunlink(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10277:
    .ascii    "/* FCNTL.H */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _setmode(int,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _INC_FCNTL"
    .byte     13
    .byte     10
    .ascii    "#define _INC_FCNTL"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_RDONLY 0x0000"
    .byte     13
    .byte     10
    .ascii    "#define _O_WRONLY 0x0001"
    .byte     13
    .byte     10
    .ascii    "#define _O_RDWR 0x0002"
    .byte     13
    .byte     10
    .ascii    "#define _O_APPEND 0x0008"
    .byte     13
    .byte     10
    .ascii    "#define _O_CREAT 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define _O_TRUNC 0x0200"
    .byte     13
    .byte     10
    .ascii    "#define _O_EXCL 0x0400"
    .byte     13
    .byte     10
    .ascii    "#define _O_TEXT 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define _O_BINARY 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define _O_WTEXT 0x10000"
    .byte     13
    .byte     10
    .ascii    "#define _O_U16TEXT 0x20000"
    .byte     13
    .byte     10
    .ascii    "#define _O_U8TEXT 0x40000"
    .byte     13
    .byte     10
    .ascii    "#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_RAW _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define _O_NOINHERIT 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define _O_TEMPORARY 0x0040"
    .byte     13
    .byte     10
    .ascii    "#define _O_SHORT_LIVED 0x1000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_SEQUENTIAL 0x0020"
    .byte     13
    .byte     10
    .ascii    "#define _O_RANDOM 0x0010"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#if !defined(NO_OLDNAMES) || defined(_POSIX)"
    .byte     13
    .byte     10
    .ascii    "#define O_RDONLY _O_RDONLY"
    .byte     13
    .byte     10
    .ascii    "#define O_WRONLY _O_WRONLY"
    .byte     13
    .byte     10
    .ascii    "#define O_RDWR _O_RDWR"
    .byte     13
    .byte     10
    .ascii    "#define O_APPEND _O_APPEND"
    .byte     13
    .byte     10
    .ascii    "#define O_CREAT _O_CREAT"
    .byte     13
    .byte     10
    .ascii    "#define O_TRUNC _O_TRUNC"
    .byte     13
    .byte     10
    .ascii    "#define O_EXCL _O_EXCL"
    .byte     13
    .byte     10
    .ascii    "#define O_TEXT _O_TEXT"
    .byte     13
    .byte     10
    .ascii    "#define O_BINARY _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define O_RAW _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define O_TEMPORARY _O_TEMPORARY"
    .byte     13
    .byte     10
    .ascii    "#define O_NOINHERIT _O_NOINHERIT"
    .byte     13
    .byte     10
    .ascii    "#define O_SEQUENTIAL _O_SEQUENTIAL"
    .byte     13
    .byte     10
    .ascii    "#define O_RANDOM _O_RANDOM"
    .byte     13
    .byte     10
    .ascii    "#define O_ACCMODE _O_ACCMODE"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10276:
    .ascii    "#include <malloc.h>"
    .byte     13
    .byte     10
    .byte     0
L10275:
    .ascii    "/* utime.h header */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <sys/utime.h>"
    .byte     13
    .byte     10
    .byte     0
L10274:
    .ascii    "/* timeb.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $timeb"
    .byte     13
    .byte     10
    .ascii    "#define $timeb"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <time.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct _timeb {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "time_t time;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short millitm;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short timezone;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short dstflag;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define timeb _timeb"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void _ftime64(struct _timeb*);"
    .byte     13
    .byte     10
    .ascii    "#define _ftime _ftime64"
    .byte     13
    .byte     10
    .ascii    "#define ftime _ftime64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10273:
    .ascii    "/* stat.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $sysstat"
    .byte     13
    .byte     10
    .ascii    "#define $sysstat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct _stat {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned int"
    .byte     9
    .ascii    "st_dev;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short"
    .byte     9
    .ascii    "st_ino;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short"
    .byte     9
    .ascii    "st_mode;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_nlink;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_uid;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_gid;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long"
    .byte     9
    .ascii    "st_rdev;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned int"
    .byte     9
    .ascii    "st_size;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_atime;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_mtime;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_ctime;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define stat _stat"
    .byte     13
    .byte     10
    .ascii    "#define _stati64 _stat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _S_IFMT 0xF000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFDIR 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFCHR 0x2000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFIFO 0x1000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFREG 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IREAD 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define _S_IWRITE 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define _S_IEXEC 0x0040"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IFMT 0xF000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFDIR 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFCHR 0x2000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFIFO 0x1000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFREG 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define S_IREAD 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define S_IWRITE 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define S_IEXEC 0x0040"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IRWXU"
    .byte     9
    .ascii    "(_S_IREAD | _S_IWRITE | _S_IEXEC)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IXUSR"
    .byte     9
    .ascii    "_S_IEXEC"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IWUSR"
    .byte     9
    .ascii    "_S_IWRITE"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IRWXU"
    .byte     9
    .byte     9
    .ascii    "_S_IRWXU"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IXUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IXUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IWUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IWUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IRUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IRUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IRUSR"
    .byte     9
    .ascii    "_S_IREAD"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IRGRP    (S_IRUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IWGRP    (S_IWUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IXGRP    (S_IXUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IRWXG    (S_IRWXU >> 3)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IROTH    (S_IRGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IWOTH    (S_IWGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IXOTH    (S_IXGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IRWXO    (S_IRWXG >> 3)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISDIR(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFDIR)"
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISFIFO(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFIFO)"
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISCHR(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFCHR)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IFBLK"
    .byte     9
    .ascii    "0x3000"
    .byte     9
    .ascii    "/* Block: Is this ever set under w32? */"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_ISBLK(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFBLK)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_ISREG(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFREG)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int stat(const char *, struct stat*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _fstati64(int, struct stat*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int fstat(int, struct stat *);"
    .byte     13
    .byte     10
    .ascii    "#define _fstat fstat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wstati64(const wchar_t,struct _stati64 *buffer);  "
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10272:
    .ascii    "/* types.h */"
    .byte     13
    .byte     10
    .ascii    "#ifndef $systypes"
    .byte     13
    .byte     10
    .ascii    "#define $systypes 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long int off_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long int ino_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int dev_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long time_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10271:
    .ascii    "/* Header wctype.h */"
    .byte     13
    .byte     10
    .byte     0
L10270:
    .ascii    "/* Header wchar.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wint_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wchar_t;"
    .byte     13
    .byte     10
    .ascii    "//typedef signed short wchar_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "size_t wcslen(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcscpy(wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "//wchar_t* _wgetenv(constwchar_t*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcschr(wchar_t*,wchar_t);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcsstr(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int wcscmp(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "typedef long _off_t;"
    .byte     13
    .byte     10
    .byte     0
L10269:
    .ascii    "/* Header safelib.h */"
    .byte     13
    .byte     10
    .byte     0
L10268:
    .ascii    "/* unistd.h header */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned int _sleep(unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define sleep _sleep"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define alarm(x) {puts("
    .byte     34
    .ascii    "ALARM"
    .byte     34
    .ascii    "); exit(1);}"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _write(int,void*,unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define write _write"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _close(int);"
    .byte     13
    .byte     10
    .ascii    "#define close _close"
    .byte     13
    .byte     10
    .byte     0
L10267:
    .ascii    "/* utime.h header */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <sys/utime.h>"
    .byte     13
    .byte     10
    .byte     0
L10266:
    .ascii    "/* Header time.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $time"
    .byte     13
    .byte     10
    .ascii    "#define $time"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long clock_t;"
    .byte     13
    .byte     10
    .ascii    "clock_t clock(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//typedef long time_t;"
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long long int time_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct tm"
    .byte     13
    .byte     10
    .ascii    "{"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_sec;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_min;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_hour;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_mday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_mon;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_year;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_wday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_yday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_isdst;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//struct tm *localtime(time_t*);"
    .byte     13
    .byte     10
    .ascii    "struct tm* _localtime32(time_t*);"
    .byte     13
    .byte     10
    .ascii    "#define localtime _localtime32"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "time_t _time64(time_t *_timer);"
    .byte     13
    .byte     10
    .ascii    "#define time _time64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define CLOCKS_PER_SEC 1000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct tm *gmtime(const time_t*);"
    .byte     13
    .byte     10
    .ascii    "size_t strftime(char *, size_t, const char *, const struct tm *);"
    .byte     13
    .byte     10
    .ascii    "time_t mktime(struct tm *);"
    .byte     13
    .byte     10
    .ascii    "double difftime(time_t, time_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char* asctime(const struct tm*);"
    .byte     13
    .byte     10
    .ascii    "//char* ctime(const time_t *_time);"
    .byte     13
    .byte     10
    .ascii    "char* _ctime64(const time_t *_time);"
    .byte     13
    .byte     10
    .ascii    "#define ctime _ctime64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10265:
    .ascii    "/* Header string.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void* memcpy(void*, const void*, size_t);"
    .byte     13
    .byte     10
    .ascii    "void* memmove(const void*, const void*, size_t);"
    .byte     13
    .byte     10
    .ascii    "void* memset(void*, int, size_t);"
    .byte     13
    .byte     10
    .ascii    "int memcmp(const void*, const void*, size_t);"
    .byte     13
    .byte     10
    .ascii    "void* memchr(const void *, int, size_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "size_t strlen(const char*);"
    .byte     13
    .byte     10
    .ascii    "char* strcpy(char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "char* strncpy(char*, const char*, size_t);"
    .byte     13
    .byte     10
    .ascii    "char* strcat(char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "int strcmp(const char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "int strncmp(const char*, const char*, size_t);"
    .byte     13
    .byte     10
    .ascii    "char* strchr(const char*, int);"
    .byte     13
    .byte     10
    .ascii    "char* strstr(const char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "char* strrchr(const char*, int);"
    .byte     13
    .byte     10
    .ascii    "int _stricmp(const char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "#define stricmp _stricmp"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _strnicmp(const char*, const char*, size_t);"
    .byte     13
    .byte     10
    .ascii    "#define strnicmp _strnicmp"
    .byte     13
    .byte     10
    .ascii    "char* strncat(char*, const char*, size_t);"
    .byte     13
    .byte     10
    .ascii    "char* strtok(char*, const char*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "size_t strcspn(const char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "size_t strspn(const char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "int strcoll(const char *, const char *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned long strtoul(const char*, char**, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char* strerror(int);"
    .byte     13
    .byte     10
    .ascii    "char* strpbrk(const char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "size_t strxfrm(char*, const char *, size_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char* _strupr(char*);"
    .byte     13
    .byte     10
    .ascii    "char* _strlwr(char*);"
    .byte     13
    .byte     10
    .ascii    "#define strupr _strupr"
    .byte     13
    .byte     10
    .ascii    "#define strlwr _strlwr"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char*strnupr(char*,size_t);"
    .byte     13
    .byte     10
    .ascii    "char*strnlwr(char*,size_t);"
    .byte     13
    .byte     10
    .ascii    "int strtrim(char*);"
    .byte     13
    .byte     10
    .ascii    "char*strrev(char*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char* _strdup(const char*);"
    .byte     13
    .byte     10
    .ascii    "#define strdup _strdup"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wcsicmp(const wchar_t *,const wchar_t *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "wchar_t *wcspbrk(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "size_t wcslen(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     0
L10264:
    .ascii    "/* Header _syslist.h */"
    .byte     13
    .byte     10
    .byte     0
L10263:
    .ascii    "/* Header stdlib.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $stdlib"
    .byte     10
    .ascii    "#define $stdlib 1"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "#define EXIT_FAILURE 1"
    .byte     10
    .ascii    "#define EXIT_SUCCESS 0"
    .byte     10
    .byte     10
    .ascii    "#define RAND_MAX 32767"
    .byte     10
    .byte     10
    .ascii    "void* malloc(size_t);"
    .byte     10
    .ascii    "void* realloc(void*, size_t);"
    .byte     10
    .ascii    "void* calloc(size_t, size_t);"
    .byte     10
    .byte     10
    .ascii    "void free(void*);"
    .byte     10
    .byte     10
    .ascii    "void exit(int);"
    .byte     10
    .byte     10
    .ascii    "int system(const char*);"
    .byte     10
    .ascii    "int _wsystem(const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "int abs(int);"
    .byte     10
    .ascii    "long labs(long);"
    .byte     10
    .ascii    "long long llabs(long);"
    .byte     10
    .ascii    "int rand(void);"
    .byte     10
    .ascii    "void srand(unsigned int);"
    .byte     10
    .ascii    "int atoi(const char*);"
    .byte     10
    .ascii    "long atol(const char*);"
    .byte     10
    .ascii    "long long atoll(const char*);"
    .byte     10
    .ascii    "long long atoi64(const char*);"
    .byte     10
    .ascii    "double atof(const char *);"
    .byte     10
    .ascii    "int"
    .byte     9
    .ascii    "atexit(void (*)(void));"
    .byte     10
    .ascii    "char *_itoa(int,char *,int);"
    .byte     10
    .byte     10
    .ascii    "#define itoa _itoa"
    .byte     10
    .byte     10
    .ascii    "void qsort(void*, size_t, size_t, int (*)(void*, void*));"
    .byte     10
    .byte     10
    .ascii    "typedef struct {"
    .byte     10
    .byte     9
    .ascii    "long long int quot;"
    .byte     10
    .byte     9
    .ascii    "long long int rem;"
    .byte     10
    .ascii    "} lldiv_t;"
    .byte     10
    .byte     10
    .ascii    "lldiv_t lldiv(long long int, long long int);"
    .byte     10
    .byte     10
    .ascii    "char* getenv(const char*);"
    .byte     10
    .ascii    "wchar_t* _wgetenv(const wchar_t*);"
    .byte     10
    .ascii    "int _wputenv(const wchar_t*);"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "double strtod(const char*, char**);"
    .byte     10
    .byte     10
    .ascii    "//float strtof(const char *, char**);"
    .byte     10
    .ascii    "#define strtof strtod"
    .byte     10
    .byte     10
    .ascii    "long double strtold(const char*, char**);"
    .byte     10
    .ascii    "void abort(void);"
    .byte     10
    .ascii    "long int strtol(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "long double strtold(const char *,char **);"
    .byte     10
    .byte     10
    .ascii    "long long int _strtoi64(const char *,char **,int);"
    .byte     10
    .ascii    "#define strtoll _strtoi64"
    .byte     10
    .byte     10
    .ascii    "unsigned long long int _strtoui64(const char *,char **,int);"
    .byte     10
    .byte     10
    .ascii    "unsigned long long int _strtoui64(const char*, char**, int);"
    .byte     10
    .ascii    "#define strtoull _strtoui64"
    .byte     10
    .ascii    "unsigned long strtoul(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "size_t _msize(void *);"
    .byte     10
    .ascii    "#define msize _msize"
    .byte     10
    .byte     10
    .ascii    "void* bsearch(const void *,const void *, size_t, size_t,"
    .byte     10
    .byte     9
    .byte     9
    .ascii    "int (*_compar)(const void *,const void *));"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "char* _fullpath(char*, const char*, size_t);"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L10262:
    .ascii    "/* Header stdio.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stdio"
    .byte     13
    .byte     10
    .ascii    "#define $stdio 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __attribute__(x)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $valist"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "typedef char* va_list;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "#define $valist"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int fpos_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SEEK_SET 0"
    .byte     13
    .byte     10
    .ascii    "#define SEEK_CUR 1"
    .byte     13
    .byte     10
    .ascii    "#define SEEK_END 2"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDIN_FILENO"
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDOUT_FILENO"
    .byte     9
    .ascii    "1"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDERR_FILENO"
    .byte     9
    .ascii    "2"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define EOF (-1)"
    .byte     13
    .byte     10
    .ascii    "#define FILENAME_MAX 260"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define L_tmpnam 10"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *_ptr;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "int   _cnt;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *_base;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "int   _flag;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "int   _file;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "int   _charbuf;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "int   _bufsiz;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *_tmpfname;"
    .byte     13
    .byte     10
    .ascii    "} FILE;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern char* __iob_func(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define stdin ((FILE*)(__iob_func()))"
    .byte     13
    .byte     10
    .ascii    "#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))"
    .byte     13
    .byte     10
    .ascii    "#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _IOREAD 0x0001"
    .byte     13
    .byte     10
    .ascii    "#define _IOWRT 0x0002"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _IOFBF 0x0000"
    .byte     13
    .byte     10
    .ascii    "#define _IOLBF 0x0040"
    .byte     13
    .byte     10
    .ascii    "#define _IONBF 0x0004"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _IOMYBUF 0x0008"
    .byte     13
    .byte     10
    .ascii    "#define _IOEOF 0x0010"
    .byte     13
    .byte     10
    .ascii    "#define _IOERR 0x0020"
    .byte     13
    .byte     10
    .ascii    "#define _IOSTRG 0x0040"
    .byte     13
    .byte     10
    .ascii    "#define _IORW 0x0080"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define BUFSIZ 512"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "FILE* fopen(const char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "int fclose(FILE*);"
    .byte     13
    .byte     10
    .ascii    "long ftell(FILE*);"
    .byte     13
    .byte     10
    .ascii    "long long int _ftelli64(FILE*);"
    .byte     13
    .byte     10
    .ascii    "int fseek(FILE*,long,int);"
    .byte     13
    .byte     10
    .ascii    "int _fseeki64(FILE*,long long int,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "size_t fread(void*, size_t, size_t, FILE*);"
    .byte     13
    .byte     10
    .ascii    "size_t fwrite(const void*, size_t, size_t, FILE*);"
    .byte     13
    .byte     10
    .ascii    "int remove(const char*);"
    .byte     13
    .byte     10
    .ascii    "int rename(const char *,const char *);"
    .byte     13
    .byte     10
    .ascii    "FILE* freopen(const char*, const char*, FILE*);"
    .byte     13
    .byte     10
    .ascii    "FILE* _wfopen(const wchar_t*,const wchar_t *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int printf(const char*, ...);"
    .byte     13
    .byte     10
    .ascii    "int sprintf(char*,const char*, ...);"
    .byte     13
    .byte     10
    .ascii    "int fprintf(FILE*,const char*, ...);"
    .byte     13
    .byte     10
    .ascii    "int sscanf(const char*, const char*, ...);"
    .byte     13
    .byte     10
    .ascii    "int scanf(const char*, ...);"
    .byte     13
    .byte     10
    .ascii    "int fscanf(FILE *,const char *, ...);"
    .byte     13
    .byte     10
    .ascii    "int _snprintf(char *,size_t,const char*,...);"
    .byte     13
    .byte     10
    .ascii    "#define snprintf _snprintf"
    .byte     13
    .byte     10
    .ascii    "int _vsnprintf(char*, size_t, const char*, va_list);"
    .byte     13
    .byte     10
    .ascii    "int vsnprintf(char*,size_t,const char*,va_list);"
    .byte     13
    .byte     10
    .ascii    "int vsprintf(char*, const char*, va_list);"
    .byte     13
    .byte     10
    .ascii    "int _wremove(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _wrename(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char* va_list;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int vfprintf(FILE*, const char*, va_list);"
    .byte     13
    .byte     10
    .ascii    "int vprintf(const char*, va_list);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int puts(const char*);"
    .byte     13
    .byte     10
    .ascii    "char* fgets(char*, int, FILE*);"
    .byte     13
    .byte     10
    .ascii    "int fputs(const char*, FILE*);"
    .byte     13
    .byte     10
    .ascii    "int fgetc(FILE*);"
    .byte     13
    .byte     10
    .ascii    "int fputc(int, FILE*);"
    .byte     13
    .byte     10
    .ascii    "int ungetc(int, FILE*);"
    .byte     13
    .byte     10
    .ascii    "int getchar(void);"
    .byte     13
    .byte     10
    .ascii    "int putchar(int);"
    .byte     13
    .byte     10
    .ascii    "int fflush(FILE *);"
    .byte     13
    .byte     10
    .ascii    "int getc(FILE *);"
    .byte     13
    .byte     10
    .ascii    "int putc(int, FILE *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int feof(FILE*);"
    .byte     13
    .byte     10
    .ascii    "int ferror(FILE*);"
    .byte     13
    .byte     10
    .ascii    "void clearerr(FILE*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int fileno(FILE*);"
    .byte     13
    .byte     10
    .ascii    "int _fileno(FILE*);"
    .byte     13
    .byte     10
    .ascii    "int setvbuf(FILE*,char*,int,size_t);"
    .byte     13
    .byte     10
    .ascii    "FILE* _popen(const char*, const char*);"
    .byte     13
    .byte     10
    .ascii    "int _pclose(FILE*);"
    .byte     13
    .byte     10
    .ascii    "int _unlink(const char *);"
    .byte     13
    .byte     10
    .ascii    "#define unlink _unlink;"
    .byte     13
    .byte     10
    .ascii    "FILE* _fdopen(int, const char *);"
    .byte     13
    .byte     10
    .ascii    "#define fdopen _fdopen"
    .byte     13
    .byte     10
    .ascii    "int fgetpos(FILE*, fpos_t*);"
    .byte     13
    .byte     10
    .ascii    "int fsetpos(FILE*, const fpos_t*);"
    .byte     13
    .byte     10
    .ascii    "void perror(char*);"
    .byte     13
    .byte     10
    .ascii    "void setbuf(FILE*, char*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void rewind(FILE*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "FILE* tmpfile(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char* tmpnam(char*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t getwc(FILE *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern void* _wenviron;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10261:
    .ascii    "/* Header stddef.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stddef"
    .byte     13
    .byte     10
    .ascii    "#define $stddef"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef signed long long int ssize_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int size_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wchar_t;"
    .byte     13
    .byte     10
    .ascii    "//typedef signed short wchar_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define NULL ((void*)0)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define offsetof(a,b) (size_t) &( ((a*)0) -> b)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int ptrdiff_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif // stddef"
    .byte     13
    .byte     10
    .byte     0
L10260:
    .ascii    "/* Header stdbool.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define bool unsigned char"
    .byte     13
    .byte     10
    .ascii    "#define true 1"
    .byte     13
    .byte     10
    .ascii    "#define false 0"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10259:
    .ascii    "/* Header stdarg.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $STDARG"
    .byte     10
    .ascii    " #define $STDARG"
    .byte     10
    .byte     10
    .ascii    "//coded for x64 target as used by mcc (with first four params also on stack)"
    .byte     10
    .byte     10
    .ascii    " typedef char *"
    .byte     9
    .ascii    "va_list;"
    .byte     10
    .byte     10
    .ascii    " #if __MCCI__"
    .byte     10
    .ascii    "  #define va_start(ap,v) ap=((va_list)&v-8)"
    .byte     10
    .ascii    "  #define va_arg(ap,t) *(t*)((ap-=8)+8)"
    .byte     10
    .ascii    "  #define va_copy(dest,src) (dest=src)"
    .byte     10
    .ascii    "  #define va_end(ap)"
    .byte     9
    .ascii    "( ap = (va_list)0 )"
    .byte     10
    .byte     10
    .ascii    " #else"
    .byte     10
    .ascii    "  #define va_start(ap,v) ap=((va_list)&v+8)"
    .byte     10
    .ascii    "  #define va_arg(ap,t) *(t*)((ap+=8)-8)"
    .byte     10
    .ascii    "  #define va_copy(dest,src) (dest=src)"
    .byte     10
    .ascii    "  #define va_end(ap)"
    .byte     9
    .ascii    "( ap = (va_list)0 )"
    .byte     10
    .byte     10
    .ascii    " #endif"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L10258:
    .ascii    "/* Header signal.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIGINT    2"
    .byte     13
    .byte     10
    .ascii    "#define SIGILL    4"
    .byte     13
    .byte     10
    .ascii    "#define SIGFPE    8"
    .byte     13
    .byte     10
    .ascii    "#define SIGSEGV  11"
    .byte     13
    .byte     10
    .ascii    "#define SIGTERM  15"
    .byte     13
    .byte     10
    .ascii    "#define SIGBREAK 21"
    .byte     13
    .byte     10
    .ascii    "#define SIGABRT  22"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIG_DFL (void (*)(int))0"
    .byte     13
    .byte     10
    .ascii    "#define SIG_IGN (void (*)(int))1"
    .byte     13
    .byte     10
    .ascii    "#define SIG_SGE (void (*)(int))3"
    .byte     13
    .byte     10
    .ascii    "#define SIG_ACK (void (*)(int))4"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIG_ERR (void (*)(int))-1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern void (*signal(int, void (*)(int)))(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int raise(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef int sig_atomic_t;"
    .byte     13
    .byte     10
    .byte     0
L10257:
    .ascii    "/* Header setjmp.h */"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "#ifndef $setjmphdr"
    .byte     10
    .ascii    "#define $setjmphdr 1"
    .byte     10
    .byte     10
    .ascii    "typedef int jmp_buf[128];"
    .byte     10
    .byte     10
    .ascii    "//void $mcclongjmp(jmp_buf, int);"
    .byte     10
    .ascii    "//int $mccsetjmp(jmp_buf);"
    .byte     10
    .byte     10
    .ascii    "#define setjmp $setjmp"
    .byte     10
    .ascii    "#define longjmp $longjmp"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .byte     0
L10256:
    .ascii    "/* Header math.h */"
    .byte     10
    .byte     10
    .ascii    "#define HUGE_VAL 1.7976931348623156e+308"
    .byte     10
    .byte     10
    .ascii    "double floor(double);"
    .byte     10
    .ascii    "double ceil(double);"
    .byte     10
    .ascii    "double sqrt(double);"
    .byte     10
    .ascii    "double sin(double);"
    .byte     10
    .ascii    "double cos(double);"
    .byte     10
    .ascii    "double tan(double);"
    .byte     10
    .ascii    "double fmod(double,double);"
    .byte     10
    .ascii    "double asin(double);"
    .byte     10
    .ascii    "double acos(double);"
    .byte     10
    .ascii    "double atan(double);"
    .byte     10
    .ascii    "double log(double);"
    .byte     10
    .ascii    "double log10(double);"
    .byte     10
    .ascii    "double exp(double);"
    .byte     10
    .ascii    "double modf(double,double*);"
    .byte     10
    .ascii    "double atan2(double,double);"
    .byte     10
    .ascii    "double pow(double,double);"
    .byte     10
    .ascii    "double fabs(double);"
    .byte     10
    .ascii    "double sinh(double);"
    .byte     10
    .ascii    "double cosh(double);"
    .byte     10
    .ascii    "double tanh(double);"
    .byte     10
    .ascii    "double frexp(double,int*);"
    .byte     10
    .ascii    "double ldexp(double,int);"
    .byte     10
    .ascii    "int isnan(double);"
    .byte     10
    .byte     10
    .ascii    "#define ldexpl ldexp"
    .byte     10
    .byte     10
    .ascii    "float sinf(float);"
    .byte     10
    .ascii    "float cosf(float);"
    .byte     10
    .ascii    "float tanf(float);"
    .byte     10
    .byte     10
    .ascii    "float sqrtf(float);"
    .byte     10
    .ascii    "float acosf(float);"
    .byte     10
    .ascii    "float atan2f(float,float);"
    .byte     10
    .ascii    "float ceilf(float);"
    .byte     10
    .byte     10
    .ascii    "double acosh (double);"
    .byte     10
    .ascii    "long double acoshl(long double);"
    .byte     10
    .ascii    "long double acoshl(long double);"
    .byte     10
    .ascii    "float acoshf(float);"
    .byte     10
    .byte     10
    .ascii    "double asinh (double);"
    .byte     10
    .ascii    "long double asinhl(long double);"
    .byte     10
    .ascii    "long double sinhl(long double);"
    .byte     10
    .ascii    "float asinhf(float);"
    .byte     10
    .byte     10
    .ascii    "double atanh(double);"
    .byte     10
    .ascii    "long double atanhl(long double);"
    .byte     10
    .ascii    "float atanhf(float);"
    .byte     10
    .byte     10
    .ascii    "long double expm1l(long double);"
    .byte     10
    .ascii    "double expm1(double);"
    .byte     10
    .ascii    "float expm1f(float);"
    .byte     10
    .ascii    "double _expm1i(int);"
    .byte     10
    .byte     10
    .ascii    "double cbrt(double);"
    .byte     10
    .ascii    "long double cbrtl(long double);"
    .byte     10
    .ascii    "float cbrtf(float);"
    .byte     10
    .byte     10
    .ascii    "double trunc(double x);"
    .byte     10
    .ascii    "long double truncl(long double);"
    .byte     10
    .ascii    "float truncf(float);"
    .byte     10
    .byte     10
    .ascii    "double round(double);"
    .byte     10
    .ascii    "float roundf(float);"
    .byte     10
    .ascii    "long double roundl(long double);"
    .byte     10
    .ascii    "double _roundi(int);"
    .byte     10
    .byte     10
    .ascii    "long double fminl(long double,long double);"
    .byte     10
    .ascii    "float fminf(float ,float);"
    .byte     10
    .ascii    "double fmin(double,double);"
    .byte     10
    .byte     10
    .ascii    "//float fabsf(float);"
    .byte     10
    .ascii    "#define fabsf fabs"
    .byte     10
    .byte     10
    .ascii    "double lgamma (double);"
    .byte     10
    .ascii    "long double lgammal(long double);"
    .byte     10
    .ascii    "float lgammaf(float);"
    .byte     10
    .byte     10
    .ascii    "long double tgammal(long double);"
    .byte     10
    .ascii    "double tgamma(double);"
    .byte     10
    .ascii    "float tgammaf(float);"
    .byte     10
    .byte     10
    .ascii    "double log1p(double);"
    .byte     10
    .ascii    "long double log1pl(long double);"
    .byte     10
    .ascii    "float log1pf(float);"
    .byte     10
    .byte     10
    .ascii    "long double log10l(long double);"
    .byte     10
    .ascii    "float log10f(float);"
    .byte     10
    .ascii    "double _log10i(int);"
    .byte     10
    .ascii    "double log10(double);"
    .byte     10
    .byte     10
    .ascii    "double erf(double);"
    .byte     10
    .ascii    "long double erfl(long double);"
    .byte     10
    .ascii    "float erff(float);"
    .byte     10
    .byte     10
    .ascii    "double hypot (double, double);"
    .byte     10
    .ascii    "double _hypot(double,double);"
    .byte     10
    .ascii    "long double hypotl(long double,long double);"
    .byte     10
    .ascii    "float hypotf(float,float);"
    .byte     10
    .byte     10
    .ascii    "double nextafter (double, double);"
    .byte     10
    .ascii    "long double nextafterl(long double,long double);"
    .byte     10
    .ascii    "float nextafterf(float,float);"
    .byte     10
    .byte     10
    .ascii    "double nexttoward(double,long double);"
    .byte     10
    .ascii    "long double nexttowardl(long double,long double);"
    .byte     10
    .ascii    "float nexttowardf(float,long double);"
    .byte     10
    .byte     10
    .ascii    "double erfc(double);"
    .byte     10
    .ascii    "long double erfcl(long double);"
    .byte     10
    .ascii    "float erfcf(float);"
    .byte     10
    .byte     10
    .ascii    "int _finite(double);"
    .byte     10
    .ascii    "#define finite _finite"
    .byte     10
    .byte     10
    .ascii    "float floorf(float);"
    .byte     10
    .byte     10
    .ascii    "double _copysign(double,double);"
    .byte     10
    .ascii    "#define copysign _copysign"
    .byte     10
    .byte     10
    .ascii    "long double fmaxl(long double,long double);"
    .byte     10
    .ascii    "double fmax(double,double);"
    .byte     10
    .ascii    "float fmaxf(float,float);"
    .byte     10
    .ascii    "float fmodf(float,float);"
    .byte     10
    .byte     10
    .ascii    "//long double exp2l(long double);"
    .byte     10
    .ascii    "double exp2(double);"
    .byte     10
    .ascii    "float exp2f(float);"
    .byte     10
    .byte     10
    .ascii    "//double log2(double);"
    .byte     10
    .ascii    "#define log2(x) (log(x)*1.442695041)"
    .byte     10
    .byte     10
    .ascii    "#define M_PI 3.1415926535897932384625433"
    .byte     10
    .ascii    "#define M_PI_2 (M_PI/2.0)"
    .byte     10
    .ascii    "#define M_2_PI 0.63661977236758134308"
    .byte     10
    .byte     10
    .ascii    "int isinf(double);"
    .byte     10
    .byte     10
    .ascii    "int _finite(double);"
    .byte     10
    .byte     10
    .ascii    "#define isfinite _finite"
    .byte     10
    .byte     10
    .ascii    "int isfinitef(float);"
    .byte     10
    .ascii    "int isfinitel(long double);"
    .byte     10
    .byte     10
    .byte     0
L10255:
    .ascii    "/* Header _ansi.h */"
    .byte     13
    .byte     10
    .byte     0
L10254:
    .ascii    "/* Header locale.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $locale"
    .byte     13
    .byte     10
    .ascii    "#define $locale"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define LC_ALL 0"
    .byte     13
    .byte     10
    .ascii    "#define LC_COLLATE 1"
    .byte     13
    .byte     10
    .ascii    "#define LC_CTYPE 2"
    .byte     13
    .byte     10
    .ascii    "#define LC_MONETARY 3"
    .byte     13
    .byte     10
    .ascii    "#define LC_NUMERIC 4"
    .byte     13
    .byte     10
    .ascii    "#define LC_TIME 5"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct lconv {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *decimal_point;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *thousands_sep;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *grouping;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *int_curr_symbol;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *currency_symbol;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_decimal_point;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_thousands_sep;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_grouping;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *positive_sign;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *negative_sign;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char int_frac_digits;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char frac_digits;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_cs_precedes;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_sep_by_space;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_cs_precedes;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_sep_by_space;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_sign_posn;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_sign_posn;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "char *setlocale(int category, const char *locale);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct lconv *localeconv(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char * setlocale(int,const char *);"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10253:
    .ascii    "/* Header limits.h */"
    .byte     10
    .byte     10
    .ascii    "#define CHAR_BIT 8"
    .byte     10
    .byte     10
    .ascii    "#define CHAR_MIN 0"
    .byte     10
    .ascii    "#define CHAR_MAX 255"
    .byte     10
    .byte     10
    .ascii    "#define UCHAR_MIN 0"
    .byte     10
    .ascii    "#define UCHAR_MAX 255"
    .byte     10
    .byte     10
    .ascii    "#define SCHAR_MIN -128"
    .byte     10
    .ascii    "#define SCHAR_MAX 127"
    .byte     10
    .byte     10
    .ascii    "#define SHRT_MIN -32768"
    .byte     10
    .ascii    "#define SHRT_MAX 32767"
    .byte     10
    .byte     10
    .ascii    "#define USHRT_MIN 0"
    .byte     10
    .ascii    "#define USHRT_MAX 65535"
    .byte     10
    .byte     10
    .ascii    "#define INT_MIN -2147483648"
    .byte     10
    .ascii    "#define INT_MAX  2147483647"
    .byte     10
    .byte     10
    .ascii    "#define UINT_MIN 0"
    .byte     10
    .ascii    "#define UINT_MAX 4294967295"
    .byte     10
    .byte     10
    .ascii    "#define LONG_MIN -2147483648"
    .byte     10
    .ascii    "#define LONG_MAX  2147483647"
    .byte     10
    .byte     10
    .ascii    "#define ULONG_MIN 0"
    .byte     10
    .ascii    "#define ULONG_MAX 4294967295"
    .byte     10
    .byte     10
    .ascii    "#define LLONG_MIN -9223372036854775808LL"
    .byte     10
    .ascii    "#define LLONG_MAX  9223372036854775807LL"
    .byte     10
    .byte     10
    .ascii    "#define ULLONG_MIN 0"
    .byte     10
    .ascii    "#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL"
    .byte     10
    .byte     10
    .ascii    "#define SIZE_MAX ULLONG_MAX"
    .byte     10
    .byte     0
L10252:
    .ascii    "/* Header stdint.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stdint"
    .byte     13
    .byte     10
    .ascii    "#define $stdint"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef signed char int8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int int64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int uint64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int intptr_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int uintptr_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long intmax_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uintmax_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char int_least8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint_least8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int_least16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint_least16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int_least32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint_least32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int_least64_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uint_least64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INTMAX_C(a) (a##LL)"
    .byte     13
    .byte     10
    .ascii    "#define UINTMAX_C(a) (a##ULL)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char int_fast8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint_fast8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int_fast16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint_fast16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int_fast32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint_fast32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int_fast64_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uint_fast64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INT8_MIN -128"
    .byte     13
    .byte     10
    .ascii    "#define INT8_MAX 127"
    .byte     13
    .byte     10
    .ascii    "#define INT16_MIN -32768"
    .byte     13
    .byte     10
    .ascii    "#define INT16_MAX 32767"
    .byte     13
    .byte     10
    .ascii    "#define INT32_MIN 0x80000000"
    .byte     13
    .byte     10
    .ascii    "#define INT32_MAX 0x7FFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define INT64_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define INT64_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT8_MAX 255"
    .byte     13
    .byte     10
    .ascii    "#define UINT16_MAX 65535"
    .byte     13
    .byte     10
    .ascii    "#define UINT32_MAX 0xFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define UINT64_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INTPTR_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT64_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define SIZE_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PTRDIFF_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WCHAR_MIN 0"
    .byte     13
    .byte     10
    .ascii    "#define WCHAR_MAX 65535"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WINT_MIN 0"
    .byte     13
    .byte     10
    .ascii    "#define WINT_MAX 65535"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT64_C(x) (x##ull)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10251:
    .ascii    "/* Header inttypes.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* fprintf macros for signed types */"
    .byte     13
    .byte     10
    .ascii    "#define PRId8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdMAX "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIi8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiMAX "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIo8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoMAX "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* fprintf macros for unsigned types */"
    .byte     13
    .byte     10
    .ascii    "#define PRIu8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuMAX "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIx8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxMAX "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIX8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXMAX "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10250:
    .ascii    "/* Header float.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MAX_10_EXP 308"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FLT_RADIX 2"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FLT_DIG 6"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN_EXP -125"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN 1.17549435E-38F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN 0X1P-126F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_TRUE_MIN 0X1P-149F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_HAS_SUBNORM 1"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN_10_EXP -37"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX_EXP +128"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX 3.40282347E+38F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX 0X1.fffffeP127F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX_10_EXP +38"
    .byte     13
    .byte     10
    .ascii    "#define FLT_EPSILON 1.19209290e-07F"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MANT_DIG 23"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define DBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .ascii    "#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_EPSILON 0X1P-52 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_DECIMAL_DIG 17"
    .byte     13
    .byte     10
    .ascii    "#define DBL_DIG 15"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN_EXP -1021"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN 2.2250738585072014E-308 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MIN 0X1P-1022 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_TRUE_MIN 0X1P-1074 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_HAS_SUBNORM 1"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN_10_EXP -307"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX_EXP +1024"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX 1.7976931348623157E+308 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MAX 0X1.fffffffffffffP1023 // h"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX_10_EXP +308"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MIN DBL_MIN"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MAX DBL_MAX"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_EPSILON 2.2204460492503131E-16"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MIN_EXP -1021"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MAX_EXP +1024"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int     _isnan(double);"
    .byte     13
    .byte     10
    .ascii    "#define isnan _isnan"
    .byte     13
    .byte     10
    .byte     0
L10249:
    .ascii    "/* Header fenv.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int feclearexcept(int);"
    .byte     13
    .byte     10
    .ascii    "int fetestexcept(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FE_INVALID 1"
    .byte     13
    .byte     10
    .ascii    "#define FE_DENORMAL 2"
    .byte     13
    .byte     10
    .ascii    "#define FE_INEXACT 32"
    .byte     13
    .byte     10
    .ascii    "#define FE_DIVBYZERO 4 "
    .byte     13
    .byte     10
    .ascii    "#define FE_OVERFLOW 8"
    .byte     13
    .byte     10
    .ascii    "#define FE_UNDERFLOW 16"
    .byte     13
    .byte     10
    .ascii    "#define FE_STACKFAULT 64"
    .byte     13
    .byte     10
    .ascii    "#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)"
    .byte     13
    .byte     10
    .byte     0
L10248:
    .ascii    "/* Header errno.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $errno"
    .byte     13
    .byte     10
    .ascii    "#define $errno"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int* _errno(void);"
    .byte     13
    .byte     10
    .ascii    "#define errno (*_errno())"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define EPERM 1"
    .byte     13
    .byte     10
    .ascii    "#define ENOENT 2"
    .byte     13
    .byte     10
    .ascii    "#define ESRCH 3"
    .byte     13
    .byte     10
    .ascii    "#define EINTR 4"
    .byte     13
    .byte     10
    .ascii    "#define EIO 5"
    .byte     13
    .byte     10
    .ascii    "#define ENXIO 6"
    .byte     13
    .byte     10
    .ascii    "#define E2BIG 7"
    .byte     13
    .byte     10
    .ascii    "#define ENOEXEC 8"
    .byte     13
    .byte     10
    .ascii    "#define EBADF 9"
    .byte     13
    .byte     10
    .ascii    "#define ECHILD 10"
    .byte     13
    .byte     10
    .ascii    "#define EAGAIN 11"
    .byte     13
    .byte     10
    .ascii    "#define ENOMEM 12"
    .byte     13
    .byte     10
    .ascii    "#define EACCES 13"
    .byte     13
    .byte     10
    .ascii    "#define EFAULT 14"
    .byte     13
    .byte     10
    .ascii    "#define ENOTBLK 15"
    .byte     13
    .byte     10
    .ascii    "#define EBUSY 16"
    .byte     13
    .byte     10
    .ascii    "#define EEXIST 17"
    .byte     13
    .byte     10
    .ascii    "#define EXDEV 18"
    .byte     13
    .byte     10
    .ascii    "#define ENODEV 19"
    .byte     13
    .byte     10
    .ascii    "#define ENOTDIR 20"
    .byte     13
    .byte     10
    .ascii    "#define EISDIR 21"
    .byte     13
    .byte     10
    .ascii    "#define EINVAL 22"
    .byte     13
    .byte     10
    .ascii    "#define ENFILE 23"
    .byte     13
    .byte     10
    .ascii    "#define EMFILE 24"
    .byte     13
    .byte     10
    .ascii    "#define ENOTTY 25"
    .byte     13
    .byte     10
    .ascii    "#define ETXTBSY 26"
    .byte     13
    .byte     10
    .ascii    "#define EFBIG 27"
    .byte     13
    .byte     10
    .ascii    "#define ENOSPC 28"
    .byte     13
    .byte     10
    .ascii    "#define ESPIPE 29"
    .byte     13
    .byte     10
    .ascii    "#define EROFS 30"
    .byte     13
    .byte     10
    .ascii    "#define EMLINK 31"
    .byte     13
    .byte     10
    .ascii    "#define EPIPE 32"
    .byte     13
    .byte     10
    .ascii    "#define EDOM 33"
    .byte     13
    .byte     10
    .ascii    "#define ERANGE 34"
    .byte     13
    .byte     10
    .ascii    "#define ENOMSG 35"
    .byte     13
    .byte     10
    .ascii    "#define EIDRM 36"
    .byte     13
    .byte     10
    .ascii    "#define ECHRNG 37"
    .byte     13
    .byte     10
    .ascii    "#define EL2NSYNC 38"
    .byte     13
    .byte     10
    .ascii    "#define EL3HLT 39"
    .byte     13
    .byte     10
    .ascii    "#define EL3RST 40"
    .byte     13
    .byte     10
    .ascii    "#define ELNRNG 41"
    .byte     13
    .byte     10
    .ascii    "#define EUNATCH 42"
    .byte     13
    .byte     10
    .ascii    "#define ENOCSI 43"
    .byte     13
    .byte     10
    .ascii    "#define EL2HLT 44"
    .byte     13
    .byte     10
    .ascii    "#define EDEADLK 45"
    .byte     13
    .byte     10
    .ascii    "#define ENOLCK 46"
    .byte     13
    .byte     10
    .ascii    "#define EBADE 50"
    .byte     13
    .byte     10
    .ascii    "#define EBADR 51"
    .byte     13
    .byte     10
    .ascii    "#define EXFULL 52"
    .byte     13
    .byte     10
    .ascii    "#define ENOANO 53"
    .byte     13
    .byte     10
    .ascii    "#define EBADRQC 54"
    .byte     13
    .byte     10
    .ascii    "#define EBADSLT 55"
    .byte     13
    .byte     10
    .ascii    "#define EDEADLOCK 56"
    .byte     13
    .byte     10
    .ascii    "#define EBFONT 57"
    .byte     13
    .byte     10
    .ascii    "#define ENOSTR 60"
    .byte     13
    .byte     10
    .ascii    "#define ENODATA 61"
    .byte     13
    .byte     10
    .ascii    "#define ETIME 62"
    .byte     13
    .byte     10
    .ascii    "#define ENOSR 63"
    .byte     13
    .byte     10
    .ascii    "#define ENONET 64"
    .byte     13
    .byte     10
    .ascii    "#define ENOPKG 65"
    .byte     13
    .byte     10
    .ascii    "#define EREMOTE 66"
    .byte     13
    .byte     10
    .ascii    "#define ENOLINK 67"
    .byte     13
    .byte     10
    .ascii    "#define EADV 68"
    .byte     13
    .byte     10
    .ascii    "#define ESRMNT 69"
    .byte     13
    .byte     10
    .ascii    "#define ECOMM 70"
    .byte     13
    .byte     10
    .ascii    "#define EPROTO 71"
    .byte     13
    .byte     10
    .ascii    "#define EMULTIHOP 74"
    .byte     13
    .byte     10
    .ascii    "#define ELBIN 75"
    .byte     13
    .byte     10
    .ascii    "#define EOVERFLOW 76"
    .byte     13
    .byte     10
    .ascii    "#define EBADMSG 77"
    .byte     13
    .byte     10
    .ascii    "#define ENOTUNIQ 80"
    .byte     13
    .byte     10
    .ascii    "#define EBADFD 81"
    .byte     13
    .byte     10
    .ascii    "#define EREMCHG 82"
    .byte     13
    .byte     10
    .ascii    "#define ELIBACC 83"
    .byte     13
    .byte     10
    .ascii    "#define ELIBBAD 84"
    .byte     13
    .byte     10
    .ascii    "#define ELIBSCN 85"
    .byte     13
    .byte     10
    .ascii    "#define ELIBMAX 86"
    .byte     13
    .byte     10
    .ascii    "#define ELIBEXEC 87"
    .byte     13
    .byte     10
    .ascii    "#define ENOSYS 88"
    .byte     13
    .byte     10
    .ascii    "#define ENMFILE 89"
    .byte     13
    .byte     10
    .ascii    "#define ENOTEMPTY 90"
    .byte     13
    .byte     10
    .ascii    "#define ENAMETOOLONG 91"
    .byte     13
    .byte     10
    .ascii    "#define EILSEQ 92"
    .byte     13
    .byte     10
    .ascii    "#define __ELASTERROR 2000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10247:
    .ascii    "/* Header ctype.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int tolower(int);"
    .byte     13
    .byte     10
    .ascii    "int toupper(int);"
    .byte     13
    .byte     10
    .ascii    "int isalpha(int);"
    .byte     13
    .byte     10
    .ascii    "int isdigit(int);"
    .byte     13
    .byte     10
    .ascii    "int isspace(int);"
    .byte     13
    .byte     10
    .ascii    "int isalnum(int);"
    .byte     13
    .byte     10
    .ascii    "int isupper(int);"
    .byte     13
    .byte     10
    .ascii    "int islower(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int isxdigit(int);"
    .byte     13
    .byte     10
    .ascii    "int iscntrl(int);"
    .byte     13
    .byte     10
    .ascii    "int isgraph(int);"
    .byte     13
    .byte     10
    .ascii    "int ispunct(int);"
    .byte     13
    .byte     10
    .ascii    "int isprint(int);"
    .byte     13
    .byte     10
    .ascii    "int __isascii(int);"
    .byte     13
    .byte     10
    .ascii    "#define isascii __isascii"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int __toascii(int);"
    .byte     13
    .byte     10
    .ascii    "#define toascii __toascii"
    .byte     13
    .byte     10
    .byte     0
L10246:
    .ascii    "/* Header assert.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define assert(x) 0"
    .byte     13
    .byte     10
    .ascii    "#define assert(x)"
    .byte     13
    .byte     10
    .byte     0
L10245:
    .ascii    "stderr"
    .byte     0
L10244:
    .ascii    "stdout"
    .byte     0
L10243:
    .ascii    "stdin"
    .byte     0
L10242:
    .ascii    "Dec"
    .byte     0
L10241:
    .ascii    "Nov"
    .byte     0
L10240:
    .ascii    "Oct"
    .byte     0
L10239:
    .ascii    "Sep"
    .byte     0
L10238:
    .ascii    "Aug"
    .byte     0
L10237:
    .ascii    "Jul"
    .byte     0
L10236:
    .ascii    "Jun"
    .byte     0
L10235:
    .ascii    "May"
    .byte     0
L10234:
    .ascii    "Apr"
    .byte     0
L10233:
    .ascii    "Mar"
    .byte     0
L10232:
    .ascii    "Feb"
    .byte     0
L10231:
    .ascii    "Jan"
    .byte     0
L10230:
    .ascii    "bool_c"
    .byte     0
L10229:
    .ascii    "truncate_c"
    .byte     0
L10228:
    .ascii    "narrow_c"
    .byte     0
L10227:
    .ascii    "fnarrow_c"
    .byte     0
L10226:
    .ascii    "fwiden_c"
    .byte     0
L10225:
    .ascii    "ufix_c"
    .byte     0
L10224:
    .ascii    "sfix_c"
    .byte     0
L10223:
    .ascii    "ufloat_c"
    .byte     0
L10222:
    .ascii    "sfloat_c"
    .byte     0
L10221:
    .ascii    "uwiden_c"
    .byte     0
L10220:
    .ascii    "swiden_c"
    .byte     0
L10219:
    .ascii    "hard_c"
    .byte     0
L10218:
    .ascii    "soft_c"
    .byte     0
L10217:
    .ascii    "no_conv"
    .byte     0
L10216:
    .ascii    "$$dummy"
    .byte     0
L10215:
    .ascii    "$longjmp"
    .byte     0
L10214:
    .ascii    "$setjmp"
    .byte     0
L10213:
    .ascii    "_Alignof"
    .byte     0
L10212:
    .ascii    "_Generic"
    .byte     0
L10211:
    .ascii    "defined"
    .byte     0
L10210:
    .ascii    "lengthof"
    .byte     0
L10209:
    .ascii    "sizeof"
    .byte     0
L10208:
    .ascii    "__FUNCTION__"
    .byte     0
L10207:
    .ascii    "__func__"
    .byte     0
L10206:
    .ascii    "__MCCI__"
    .byte     0
L10205:
    .ascii    "__MCC__"
    .byte     0
L10204:
    .ascii    "__TIME__"
    .byte     0
L10203:
    .ascii    "__LINE__"
    .byte     0
L10202:
    .ascii    "__FILE__"
    .byte     0
L10201:
    .ascii    "__DATE__"
    .byte     0
L10200:
    .ascii    "_Bool"
    .byte     0
L10199:
    .ascii    "unsigned"
    .byte     0
L10198:
    .ascii    "signed"
    .byte     0
L10197:
    .ascii    "double"
    .byte     0
L10196:
    .ascii    "float"
    .byte     0
L10195:
    .ascii    "int"
    .byte     0
L10194:
    .ascii    "long"
    .byte     0
L10193:
    .ascii    "short"
    .byte     0
L10192:
    .ascii    "char"
    .byte     0
L10191:
    .ascii    "void"
    .byte     0
L10190:
    .ascii    "enum"
    .byte     0
L10189:
    .ascii    "_Alignas"
    .byte     0
L10188:
    .ascii    "_Noreturn"
    .byte     0
L10187:
    .ascii    "inline"
    .byte     0
L10186:
    .ascii    "_Atomic"
    .byte     0
L10185:
    .ascii    "restrict"
    .byte     0
L10184:
    .ascii    "volatile"
    .byte     0
L10183:
    .ascii    "const"
    .byte     0
L10182:
    .ascii    "typedef"
    .byte     0
L10181:
    .ascii    "extern"
    .byte     0
L10180:
    .ascii    "static"
    .byte     0
L10179:
    .ascii    "register"
    .byte     0
L10178:
    .ascii    "auto"
    .byte     0
L10177:
    .ascii    "line"
    .byte     0
L10176:
    .ascii    "pragma"
    .byte     0
L10175:
    .ascii    "error"
    .byte     0
L10174:
    .ascii    "undef"
    .byte     0
L10173:
    .ascii    "endif"
    .byte     0
L10172:
    .ascii    "ifndef"
    .byte     0
L10171:
    .ascii    "ifdef"
    .byte     0
L10170:
    .ascii    "elif"
    .byte     0
L10169:
    .ascii    "define"
    .byte     0
L10168:
    .ascii    "include"
    .byte     0
L10167:
    .ascii    "union"
    .byte     0
L10166:
    .ascii    "struct"
    .byte     0
L10165:
    .ascii    "switch"
    .byte     0
L10164:
    .ascii    "goto"
    .byte     0
L10163:
    .ascii    "continue"
    .byte     0
L10162:
    .ascii    "break"
    .byte     0
L10161:
    .ascii    "return"
    .byte     0
L10160:
    .ascii    "while"
    .byte     0
L10159:
    .ascii    "do"
    .byte     0
L10158:
    .ascii    "for"
    .byte     0
L10157:
    .ascii    "default"
    .byte     0
L10156:
    .ascii    "case"
    .byte     0
L10155:
    .ascii    "else"
    .byte     0
L10154:
    .ascii    "if"
    .byte     0
L10153:
    .ascii    "labelid"
    .byte     0
L10152:
    .ascii    "structtagid"
    .byte     0
L10151:
    .ascii    "enumtagid"
    .byte     0
L10150:
    .ascii    "enumid"
    .byte     0
L10149:
    .ascii    "fieldid"
    .byte     0
L10148:
    .ascii    "paramid"
    .byte     0
L10147:
    .ascii    "frameid"
    .byte     0
L10146:
    .ascii    "staticid"
    .byte     0
L10145:
    .ascii    "procid"
    .byte     0
L10144:
    .ascii    "typeid"
    .byte     0
L10143:
    .ascii    "extmoduleid"
    .byte     0
L10142:
    .ascii    "moduleid"
    .byte     0
L10141:
    .ascii    "programid"
    .byte     0
L10140:
    .ascii    "macroid"
    .byte     0
L10139:
    .ascii    "nullid"
    .byte     0
L10138:
    .ascii    "ns_fields"
    .byte     0
L10137:
    .ascii    "ns_labels"
    .byte     0
L10136:
    .ascii    "ns_tags"
    .byte     0
L10135:
    .ascii    "ns_general"
    .byte     0
L10134:
    .ascii    "ns_none"
    .byte     0
L10133:
    .ascii    "pragmadir"
    .byte     0
L10132:
    .ascii    "linedir"
    .byte     0
L10131:
    .ascii    "blankdir"
    .byte     0
L10130:
    .ascii    "messagedir"
    .byte     0
L10129:
    .ascii    "errordir"
    .byte     0
L10128:
    .ascii    "undefdir"
    .byte     0
L10127:
    .ascii    "ifndefdir"
    .byte     0
L10126:
    .ascii    "ifdefdir"
    .byte     0
L10125:
    .ascii    "includedir"
    .byte     0
L10124:
    .ascii    "endifdir"
    .byte     0
L10123:
    .ascii    "elsedir"
    .byte     0
L10122:
    .ascii    "elifdir"
    .byte     0
L10121:
    .ascii    "ifdir"
    .byte     0
L10120:
    .ascii    "emitdir"
    .byte     0
L10119:
    .ascii    "definedir"
    .byte     0
L10118:
    .byte     0
L10117:
    .ascii    "k"
    .byte     0
L10116:
    .byte     0
L10115:
    .ascii    "w"
    .byte     0
L10114:
    .ascii    "s"
    .byte     0
L10113:
    .ascii    "n"
    .byte     0
L10112:
    .byte     0
L10111:
    .ascii    ">>="
    .byte     0
L10110:
    .ascii    "<<="
    .byte     0
L10109:
    .ascii    "^="
    .byte     0
L10108:
    .ascii    "&="
    .byte     0
L10107:
    .ascii    "|="
    .byte     0
L10106:
    .ascii    "%="
    .byte     0
L10105:
    .ascii    "/="
    .byte     0
L10104:
    .ascii    "*="
    .byte     0
L10103:
    .ascii    "-="
    .byte     0
L10102:
    .ascii    "+="
    .byte     0
L10101:
    .ascii    ">"
    .byte     0
L10100:
    .ascii    ">="
    .byte     0
L10099:
    .ascii    "<="
    .byte     0
L10098:
    .ascii    "<"
    .byte     0
L10097:
    .ascii    "!="
    .byte     0
L10096:
    .ascii    "=="
    .byte     0
L10095:
    .ascii    "abs"
    .byte     0
L10094:
    .ascii    "--"
    .byte     0
L10093:
    .ascii    "++"
    .byte     0
L10092:
    .ascii    "!"
    .byte     0
L10091:
    .ascii    "~"
    .byte     0
L10090:
    .ascii    ">>"
    .byte     0
L10089:
    .ascii    "<<"
    .byte     0
L10088:
    .ascii    "&&"
    .byte     0
L10087:
    .ascii    "||"
    .byte     0
L10086:
    .ascii    "^"
    .byte     0
L10085:
    .ascii    "&"
    .byte     0
L10084:
    .ascii    "|"
    .byte     0
L10083:
    .ascii    "%"
    .byte     0
L10082:
    .ascii    "/"
    .byte     0
L10081:
    .ascii    "*"
    .byte     0
L10080:
    .ascii    "-"
    .byte     0
L10079:
    .ascii    "+"
    .byte     0
L10078:
    .byte     92
    .byte     0
L10077:
    .ascii    "..."
    .byte     0
L10076:
    .ascii    "~"
    .byte     0
L10075:
    .ascii    "?"
    .byte     0
L10074:
    .ascii    "}"
    .byte     0
L10073:
    .ascii    "{"
    .byte     0
L10072:
    .ascii    "]"
    .byte     0
L10071:
    .ascii    "["
    .byte     0
L10070:
    .ascii    ")"
    .byte     0
L10069:
    .ascii    "("
    .byte     0
L10068:
    .ascii    ":="
    .byte     0
L10067:
    .ascii    "="
    .byte     0
L10066:
    .ascii    ":"
    .byte     0
L10065:
    .ascii    ";"
    .byte     0
L10064:
    .ascii    ","
    .byte     0
L10063:
    .ascii    "##"
    .byte     0
L10062:
    .ascii    "#"
    .byte     0
L10061:
    .ascii    "->"
    .byte     0
L10060:
    .ascii    "."
    .byte     0
L10059:
    .byte     0
L10058:
    .ascii    "kdummysym"
    .byte     0
L10057:
    .ascii    "ksetjmpsym"
    .byte     0
L10056:
    .ascii    "kalignofsym"
    .byte     0
L10055:
    .ascii    "kgenericsym"
    .byte     0
L10054:
    .ascii    "kdefinedsym"
    .byte     0
L10053:
    .ascii    "ksizeofsym"
    .byte     0
L10052:
    .ascii    "kenumsym"
    .byte     0
L10051:
    .ascii    "kalignassym"
    .byte     0
L10050:
    .ascii    "kfnspecsym"
    .byte     0
L10049:
    .ascii    "kstdtypesym"
    .byte     0
L10048:
    .ascii    "ktypequalsym"
    .byte     0
L10047:
    .ascii    "klinkagesym"
    .byte     0
L10046:
    .ascii    "kunionsym"
    .byte     0
L10045:
    .ascii    "kstructsym"
    .byte     0
L10044:
    .ascii    "kswitchsym"
    .byte     0
L10043:
    .ascii    "kgotosym"
    .byte     0
L10042:
    .ascii    "kcontinuesym"
    .byte     0
L10041:
    .ascii    "kbreaksym"
    .byte     0
L10040:
    .ascii    "kreturnsym"
    .byte     0
L10039:
    .ascii    "kdosym"
    .byte     0
L10038:
    .ascii    "kwhilesym"
    .byte     0
L10037:
    .ascii    "kforsym"
    .byte     0
L10036:
    .ascii    "kdefaultsym"
    .byte     0
L10035:
    .ascii    "kcasesym"
    .byte     0
L10034:
    .ascii    "kelsesym"
    .byte     0
L10033:
    .ascii    "kifsym"
    .byte     0
L10032:
    .ascii    "ktypespecsym"
    .byte     0
L10031:
    .ascii    "predefmacrosym"
    .byte     0
L10030:
    .ascii    "ksourcedirsym"
    .byte     0
L10029:
    .ascii    "namesym"
    .byte     0
L10028:
    .ascii    "placeholdersym"
    .byte     0
L10027:
    .ascii    "whitespacesym"
    .byte     0
L10026:
    .ascii    "wstringconstsym"
    .byte     0
L10025:
    .ascii    "stringconstsym"
    .byte     0
L10024:
    .ascii    "wcharconstsym"
    .byte     0
L10023:
    .ascii    "charconstsym"
    .byte     0
L10022:
    .ascii    "realconstsym"
    .byte     0
L10021:
    .ascii    "intconstsym"
    .byte     0
L10020:
    .ascii    "rawnumbersym"
    .byte     0
L10019:
    .ascii    "eofsym"
    .byte     0
L10018:
    .ascii    "eolsym"
    .byte     0
L10017:
    .ascii    "shrtosym"
    .byte     0
L10016:
    .ascii    "shltosym"
    .byte     0
L10015:
    .ascii    "ixortosym"
    .byte     0
L10014:
    .ascii    "iandtosym"
    .byte     0
L10013:
    .ascii    "iortosym"
    .byte     0
L10012:
    .ascii    "remtosym"
    .byte     0
L10011:
    .ascii    "divtosym"
    .byte     0
L10010:
    .ascii    "multosym"
    .byte     0
L10009:
    .ascii    "subtosym"
    .byte     0
L10008:
    .ascii    "addtosym"
    .byte     0
L10007:
    .ascii    "gtsym"
    .byte     0
L10006:
    .ascii    "gesym"
    .byte     0
L10005:
    .ascii    "lesym"
    .byte     0
L10004:
    .ascii    "ltsym"
    .byte     0
L10003:
    .ascii    "nesym"
    .byte     0
L10002:
    .ascii    "eqsym"
    .byte     0
L10001:
    .ascii    "abssym"
    .byte     0
L10000:
    .ascii    "decrsym"
    .byte     0
L9999:
    .ascii    "incrsym"
    .byte     0
L9998:
    .ascii    "notlsym"
    .byte     0
L9997:
    .ascii    "inotsym"
    .byte     0
L9996:
    .ascii    "shrsym"
    .byte     0
L9995:
    .ascii    "shlsym"
    .byte     0
L9994:
    .ascii    "andlsym"
    .byte     0
L9993:
    .ascii    "orlsym"
    .byte     0
L9992:
    .ascii    "ixorsym"
    .byte     0
L9991:
    .ascii    "iandsym"
    .byte     0
L9990:
    .ascii    "iorsym"
    .byte     0
L9989:
    .ascii    "remsym"
    .byte     0
L9988:
    .ascii    "divsym"
    .byte     0
L9987:
    .ascii    "mulsym"
    .byte     0
L9986:
    .ascii    "subsym"
    .byte     0
L9985:
    .ascii    "addsym"
    .byte     0
L9984:
    .ascii    "backslashsym"
    .byte     0
L9983:
    .ascii    "ellipsissym"
    .byte     0
L9982:
    .ascii    "curlsym"
    .byte     0
L9981:
    .ascii    "questionsym"
    .byte     0
L9980:
    .ascii    "rcurlysym"
    .byte     0
L9979:
    .ascii    "lcurlysym"
    .byte     0
L9978:
    .ascii    "rsqsym"
    .byte     0
L9977:
    .ascii    "lsqsym"
    .byte     0
L9976:
    .ascii    "rbracksym"
    .byte     0
L9975:
    .ascii    "lbracksym"
    .byte     0
L9974:
    .ascii    "assignsym2"
    .byte     0
L9973:
    .ascii    "assignsym"
    .byte     0
L9972:
    .ascii    "colonsym"
    .byte     0
L9971:
    .ascii    "semisym"
    .byte     0
L9970:
    .ascii    "commasym"
    .byte     0
L9969:
    .ascii    "hashhashsym"
    .byte     0
L9968:
    .ascii    "lithashsym"
    .byte     0
L9967:
    .ascii    "hashsym"
    .byte     0
L9966:
    .ascii    "lexhashsym"
    .byte     0
L9965:
    .ascii    "idotsym"
    .byte     0
L9964:
    .ascii    "dotsym"
    .byte     0
L9963:
    .ascii    "errorsym"
    .byte     0
L9962:
    .ascii    "jdummy"
    .byte     0
L9961:
    .ascii    "longjmp"
    .byte     0
L9960:
    .ascii    "setjmp"
    .byte     0
L9959:
    .ascii    "-- postdecr"
    .byte     0
L9958:
    .ascii    "++ postincr"
    .byte     0
L9957:
    .ascii    "-- preincr"
    .byte     0
L9956:
    .ascii    "++ preincr"
    .byte     0
L9955:
    .ascii    ">>="
    .byte     0
L9954:
    .ascii    "<<="
    .byte     0
L9953:
    .ascii    "^="
    .byte     0
L9952:
    .ascii    "|="
    .byte     0
L9951:
    .ascii    "&="
    .byte     0
L9950:
    .ascii    "%="
    .byte     0
L9949:
    .ascii    "/="
    .byte     0
L9948:
    .ascii    "*="
    .byte     0
L9947:
    .ascii    "-="
    .byte     0
L9946:
    .ascii    "+="
    .byte     0
L9945:
    .ascii    "~ inot"
    .byte     0
L9944:
    .ascii    "abs"
    .byte     0
L9943:
    .ascii    "- neg"
    .byte     0
L9942:
    .ascii    "jscale"
    .byte     0
L9941:
    .ascii    "jconvert"
    .byte     0
L9940:
    .ascii    "addrof &"
    .byte     0
L9939:
    .ascii    "subptr"
    .byte     0
L9938:
    .ascii    "addptr"
    .byte     0
L9937:
    .ascii    "ptr"
    .byte     0
L9936:
    .ascii    "jindex"
    .byte     0
L9935:
    .ascii    "jidot"
    .byte     0
L9934:
    .ascii    "jdot"
    .byte     0
L9933:
    .ascii    ">>"
    .byte     0
L9932:
    .ascii    "<<"
    .byte     0
L9931:
    .ascii    "^ ixor"
    .byte     0
L9930:
    .ascii    "| ior"
    .byte     0
L9929:
    .ascii    "& iand"
    .byte     0
L9928:
    .ascii    "% mod"
    .byte     0
L9927:
    .ascii    "/ div"
    .byte     0
L9926:
    .ascii    "* mul"
    .byte     0
L9925:
    .ascii    "- sub"
    .byte     0
L9924:
    .ascii    "+ add"
    .byte     0
L9923:
    .ascii    ">="
    .byte     0
L9922:
    .ascii    ">"
    .byte     0
L9921:
    .ascii    "<="
    .byte     0
L9920:
    .ascii    "<"
    .byte     0
L9919:
    .ascii    "!="
    .byte     0
L9918:
    .ascii    "=="
    .byte     0
L9917:
    .ascii    "&&"
    .byte     0
L9916:
    .ascii    "jifx"
    .byte     0
L9915:
    .ascii    "jcallfn"
    .byte     0
L9914:
    .ascii    "jexprlist"
    .byte     0
L9913:
    .ascii    "jmakelist"
    .byte     0
L9912:
    .ascii    "jistruel"
    .byte     0
L9911:
    .ascii    "! notl"
    .byte     0
L9910:
    .ascii    "|| orl"
    .byte     0
L9909:
    .ascii    "&& andl"
    .byte     0
L9908:
    .ascii    "jbreaksw"
    .byte     0
L9907:
    .ascii    "jswitch"
    .byte     0
L9906:
    .ascii    "jcontinue"
    .byte     0
L9905:
    .ascii    "jbreak"
    .byte     0
L9904:
    .ascii    "jdefaultstmt"
    .byte     0
L9903:
    .ascii    "jcasestmt"
    .byte     0
L9902:
    .ascii    "jlabelstmt"
    .byte     0
L9901:
    .ascii    "jgoto"
    .byte     0
L9900:
    .ascii    "jdowhile"
    .byte     0
L9899:
    .ascii    "jwhile"
    .byte     0
L9898:
    .ascii    "jfor"
    .byte     0
L9897:
    .ascii    "jif"
    .byte     0
L9896:
    .ascii    "jassign"
    .byte     0
L9895:
    .ascii    "jreturnx"
    .byte     0
L9894:
    .ascii    "jreturn"
    .byte     0
L9893:
    .ascii    "jdecl"
    .byte     0
L9892:
    .ascii    "jtempdecl"
    .byte     0
L9891:
    .ascii    "jblock"
    .byte     0
L9890:
    .ascii    "jfuncname"
    .byte     0
L9889:
    .ascii    "jwidenmem"
    .byte     0
L9888:
    .ascii    "jname"
    .byte     0
L9887:
    .ascii    "jnull"
    .byte     0
L9886:
    .ascii    "jconst"
    .byte     0
L9885:
    .ascii    "jnone"
    .byte     0
L9884:
    .ascii    "callback_fnspec"
    .byte     0
L9883:
    .ascii    "noreturn_fnspec"
    .byte     0
L9882:
    .ascii    "inline_fnspec"
    .byte     0
L9881:
    .ascii    "atomic_qual"
    .byte     0
L9880:
    .ascii    "restrict_qual"
    .byte     0
L9879:
    .ascii    "volatile_qual"
    .byte     0
L9878:
    .ascii    "const_qual"
    .byte     0
L9877:
    .ascii    "typedef_ss"
    .byte     0
L9876:
    .ascii    "extern_ss"
    .byte     0
L9875:
    .ascii    "register_ss"
    .byte     0
L9874:
    .ascii    "auto_ss"
    .byte     0
L9873:
    .ascii    "static_ss"
    .byte     0
L9872:
    .ascii    "none_ss"
    .byte     0
L9871:
    .ascii    "dummy_cc"
    .byte     0
L9870:
    .ascii    "callback_cc"
    .byte     0
L9869:
    .ascii    "stdcall_cc"
    .byte     0
L9868:
    .ascii    "clang_cc"
    .byte     0
L9867:
    .ascii    "own_cc"
    .byte     0
L9866:
    .ascii    "open_cc"
    .byte     0
L9865:
    .ascii    "Exp"
    .byte     0
L9864:
    .ascii    "Imp"
    .byte     0
L9863:
    .ascii    "Loc"
    .byte     0
L9862:
    .ascii    "Fn"
    .byte     0
L9861:
    .ascii    "-"
    .byte     0
L9860:
    .ascii    "pm_variadic"
    .byte     0
L9859:
    .ascii    "pm_empty"
    .byte     0
L9858:
    .ascii    "pm_notset"
    .byte     0
L9857:
    .ascii    "pm_normal"
    .byte     0
L9856:
    .ascii    "ts_atomic"
    .byte     0
L9855:
    .ascii    "ts_enum"
    .byte     0
L9854:
    .ascii    "ts_union"
    .byte     0
L9853:
    .ascii    "ts_struct"
    .byte     0
L9852:
    .ascii    "ts_user"
    .byte     0
L9851:
    .ascii    "ts_bool"
    .byte     0
L9850:
    .ascii    "ts_unsigned"
    .byte     0
L9849:
    .ascii    "ts_signed"
    .byte     0
L9848:
    .ascii    "ts_double"
    .byte     0
L9847:
    .ascii    "ts_float"
    .byte     0
L9846:
    .ascii    "ts_int"
    .byte     0
L9845:
    .ascii    "ts_long"
    .byte     0
L9844:
    .ascii    "ts_short"
    .byte     0
L9843:
    .ascii    "ts_char"
    .byte     0
L9842:
    .ascii    "ts_void"
    .byte     0
L9841:
    .ascii    "blockcat"
    .byte     0
L9840:
    .ascii    "shortcat"
    .byte     0
L9839:
    .ascii    "realcat"
    .byte     0
L9838:
    .ascii    "intcat"
    .byte     0
L9837:
    .ascii    "voidcat"
    .byte     0
L9836:
    .ascii    "tlast"
    .byte     0
L9835:
    .ascii    "notset"
    .byte     0
L9834:
    .ascii    "union"
    .byte     0
L9833:
    .ascii    "struct"
    .byte     0
L9832:
    .ascii    "array"
    .byte     0
L9831:
    .ascii    "block"
    .byte     0
L9830:
    .ascii    "label"
    .byte     0
L9829:
    .ascii    "proc"
    .byte     0
L9828:
    .ascii    "ref"
    .byte     0
L9827:
    .ascii    "enum"
    .byte     0
L9826:
    .ascii    "r64"
    .byte     0
L9825:
    .ascii    "r32"
    .byte     0
L9824:
    .ascii    "u64"
    .byte     0
L9823:
    .ascii    "u32"
    .byte     0
L9822:
    .ascii    "u16"
    .byte     0
L9821:
    .ascii    "u8"
    .byte     0
L9820:
    .ascii    "bool"
    .byte     0
L9819:
    .ascii    "i64"
    .byte     0
L9818:
    .ascii    "i32"
    .byte     0
L9817:
    .ascii    "i16"
    .byte     0
L9816:
    .ascii    "i8"
    .byte     0
L9815:
    .ascii    "void"
    .byte     0
L9814:
    .ascii    "MCC"
    .byte     0
L9813:
    .ascii    "    The 'MCC' C Compiler comprises:"
    .byte     10
    .byte     10
    .ascii    "    mcc.exe            Compiles to .asm files"
    .byte     10
    .ascii    "    aa.exe             Assembles .asm files to .obj files"
    .byte     10
    .ascii    "                       Assemblers and links .asm/.dll files to .exe"
    .byte     10
    .ascii    "    Standard headers   A minimal set inside mcc.exe"
    .byte     10
    .ascii    "    windows.h          As a standalone file"
    .byte     10
    .byte     10
    .ascii    "    Input files:"
    .byte     10
    .byte     10
    .ascii    "      prog             This is prog.c as the extension is optional"
    .byte     10
    .ascii    "      prog.c"
    .byte     10
    .ascii    "      lib.dll          Include .dll library when generating .exe"
    .byte     10
    .ascii    "      @file            Read parameters and optons from given file"
    .byte     10
    .byte     10
    .ascii    "    Options:"
    .byte     10
    .byte     10
    .ascii    "      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files"
    .byte     10
    .ascii    "      -e               Preprocess each module to .i file"
    .byte     10
    .ascii    "      -s               Compile each module to .asm file"
    .byte     10
    .ascii    "      -c               Compile each module .obj via .asm"
    .byte     10
    .byte     10
    .ascii    "      -out:file        Specify output file for -exe only"
    .byte     10
    .byte     10
    .ascii    "    For .exe output, it will be named based on the first input file. Otherwise"
    .byte     10
    .ascii    "    use -out option"
    .byte     10
    .byte     10
    .ascii    "    .obj files can be linked using gcc on Windows. This option is"
    .byte     10
    .ascii    "    needed to be able to generate .dll files. However, this will not"
    .byte     10
    .ascii    "    work on newer gcc versions because mcc's generated code is not position"
    .byte     10
    .ascii    "    independent, and will only work loaded in the low 2GB of address space."
    .byte     10
    .byte     10
    .ascii    "    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are"
    .byte     10
    .ascii    "    automatically included as search libraries for imported functions."
    .byte     10
    .byte     10
    .ascii    "    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported."
    .byte     10
    .byte     10
    .ascii    "    Omissions, Restrictions and Bugs (highlights only as there are dozens):"
    .byte     10
    .byte     10
    .ascii    "      * No VLAs, compound literals, designated initialisers"
    .byte     10
    .ascii    "      * Restrictions on complexity of data initialisers"
    .byte     10
    .byte     0
L9812:
    .ascii    "himem"
    .byte     0
L9811:
    .ascii    "norip"
    .byte     0
L9810:
    .ascii    "shortnames"
    .byte     0
L9809:
    .ascii    "stdout"
    .byte     0
L9808:
    .ascii    "o"
    .byte     0
L9807:
    .ascii    "writeheaders"
    .byte     0
L9806:
    .ascii    "ext"
    .byte     0
L9805:
    .ascii    "help"
    .byte     0
L9804:
    .ascii    "h"
    .byte     0
L9803:
    .ascii    "ss"
    .byte     0
L9802:
    .ascii    "cs"
    .byte     0
L9801:
    .ascii    "q"
    .byte     0
L9800:
    .ascii    "vv"
    .byte     0
L9799:
    .ascii    "v"
    .byte     0
L9798:
    .ascii    "time2"
    .byte     0
L9797:
    .ascii    "time"
    .byte     0
L9796:
    .ascii    "showfiles"
    .byte     0
L9795:
    .ascii    "showtypes"
    .byte     0
L9794:
    .ascii    "showss"
    .byte     0
L9793:
    .ascii    "showmcl"
    .byte     0
L9792:
    .ascii    "showpst"
    .byte     0
L9791:
    .ascii    "showpcl"
    .byte     0
L9790:
    .ascii    "showast"
    .byte     0
L9789:
    .ascii    "showstflat"
    .byte     0
L9788:
    .ascii    "showst"
    .byte     0
L9787:
    .ascii    "includes"
    .byte     0
L9786:
    .ascii    "incl"
    .byte     0
L9785:
    .ascii    "headers"
    .byte     0
L9784:
    .ascii    "paths"
    .byte     0
L9783:
    .ascii    "no"
    .byte     0
L9782:
    .ascii    "nopeep"
    .byte     0
L9781:
    .ascii    "noregs"
    .byte     0
L9780:
    .ascii    "r"
    .byte     0
L9779:
    .ascii    "exe"
    .byte     0
L9778:
    .ascii    "dll"
    .byte     0
L9777:
    .ascii    "mx"
    .byte     0
L9776:
    .ascii    "obj"
    .byte     0
L9775:
    .ascii    "c"
    .byte     0
L9774:
    .ascii    "a"
    .byte     0
L9773:
    .ascii    "s"
    .byte     0
L9772:
    .ascii    "mcl"
    .byte     0
L9771:
    .ascii    "i"
    .byte     0
L9770:
    .ascii    "pi"
    .byte     0
L9769:
    .ascii    "p"
    .byte     0
L9768:
    .ascii    "type"
    .byte     0
L9767:
    .ascii    "parse"
    .byte     0
L9766:
    .ascii    "ei"
    .byte     0
L9765:
    .ascii    "e"
    .byte     0
L9764:
    .ascii    "load"
    .byte     0
L9763:
    .ascii    "exe"
    .byte     0
L9762:
    .ascii    "(run)"
    .byte     0
L9761:
    .ascii    "exe"
    .byte     0
L9760:
    .ascii    "dll"
    .byte     0
L9759:
    .ascii    "obj"
    .byte     0
L9758:
    .ascii    "mx"
    .byte     0
L9757:
    .ascii    "asm"
    .byte     0
L9756:
    .ascii    "(int)"
    .byte     0
L9755:
    .ascii    "pcl"
    .byte     0
L9754:
    .byte     0
L9753:
    .ascii    "i"
    .byte     0
L9752:
    .byte     0
L9751:
    .ascii    "run_pass"
    .byte     0
L9750:
    .ascii    "exe_pass"
    .byte     0
L9749:
    .ascii    "dll_pass"
    .byte     0
L9748:
    .ascii    "obj_pass"
    .byte     0
L9747:
    .ascii    "mx_pass"
    .byte     0
L9746:
    .ascii    "asm_pass"
    .byte     0
L9745:
    .ascii    "mcl_pass"
    .byte     0
L9744:
    .ascii    "runpcl_pass"
    .byte     0
L9743:
    .ascii    "pcl_pass"
    .byte     0
L9742:
    .ascii    "type_pass"
    .byte     0
L9741:
    .ascii    "parse_pass"
    .byte     0
L9740:
    .ascii    "pp_pass"
    .byte     0
L9739:
    .ascii    "load_pass"
    .byte     0
L9738:
    .ascii    "impdata_rseg"
    .byte     0
L9737:
    .ascii    "rodata_rseg"
    .byte     0
L9736:
    .ascii    "zdata_rseg"
    .byte     0
L9735:
    .ascii    "idata_rseg"
    .byte     0
L9734:
    .ascii    "code_rseg"
    .byte     0
L9733:
    .ascii    "no_seg"
    .byte     0
L9732:
    .ascii    "imprel32"
    .byte     0
L9731:
    .ascii    "impabs64"
    .byte     0
L9730:
    .ascii    "impabs32"
    .byte     0
L9729:
    .ascii    "locabs64"
    .byte     0
L9728:
    .ascii    "locabs32"
    .byte     0
L9727:
    .ascii    "no_rel"
    .byte     0
L9726:
    .ascii    "end_dir"
    .byte     0
L9725:
    .ascii    "entry_dir"
    .byte     0
L9724:
    .ascii    "exportoffsets_dir"
    .byte     0
L9723:
    .ascii    "exportsegs_dir"
    .byte     0
L9722:
    .ascii    "exportsymbols_dir"
    .byte     0
L9721:
    .ascii    "importsymbols_dir"
    .byte     0
L9720:
    .ascii    "libs_dir"
    .byte     0
L9719:
    .ascii    "dlls_dir"
    .byte     0
L9718:
    .ascii    "reloc_dir"
    .byte     0
L9717:
    .ascii    "zdata_dir"
    .byte     0
L9716:
    .ascii    "idata_dir"
    .byte     0
L9715:
    .ascii    "code_dir"
    .byte     0
L9714:
    .ascii    "version_dir"
    .byte     0
L9713:
    .ascii    "pad_dir"
    .byte     0
L9712:
    .ascii    "N"
    .byte     0
L9711:
    .ascii    "Q"
    .byte     0
L9710:
    .byte     0
L9709:
    .ascii    "D"
    .byte     0
L9708:
    .byte     0
L9707:
    .ascii    "A"
    .byte     0
L9706:
    .byte     0
L9705:
    .ascii    "W"
    .byte     0
L9704:
    .ascii    "B"
    .byte     0
L9703:
    .ascii    "asm"
    .byte     0
L9702:
    .ascii    "rel8_rel"
    .byte     0
L9701:
    .ascii    "rel321_rel"
    .byte     0
L9700:
    .ascii    "rel32_rel"
    .byte     0
L9699:
    .ascii    "addr32nb_rel"
    .byte     0
L9698:
    .ascii    "addr32_rel"
    .byte     0
L9697:
    .ascii    "addr64_rel"
    .byte     0
L9696:
    .ascii    "abs_rel"
    .byte     0
L9695:
    .ascii    "xmm15"
    .byte     0
L9694:
    .ascii    "xmm13"
    .byte     0
L9693:
    .ascii    "xmm12"
    .byte     0
L9692:
    .ascii    "xmm11"
    .byte     0
L9691:
    .ascii    "xmm10"
    .byte     0
L9690:
    .ascii    "xmm9"
    .byte     0
L9689:
    .ascii    "xmm8"
    .byte     0
L9688:
    .ascii    "xmm7"
    .byte     0
L9687:
    .ascii    "xmm6"
    .byte     0
L9686:
    .ascii    "xmm5"
    .byte     0
L9685:
    .ascii    "xmm4"
    .byte     0
L9684:
    .ascii    "xmm3"
    .byte     0
L9683:
    .ascii    "xmm2"
    .byte     0
L9682:
    .ascii    "xmm1"
    .byte     0
L9681:
    .ascii    "xmm0"
    .byte     0
L9680:
    .ascii    "-"
    .byte     0
L9679:
    .ascii    "temp"
    .byte     0
L9678:
    .ascii    "regvar"
    .byte     0
L9677:
    .ascii    "reg"
    .byte     0
L9676:
    .ascii    "pend"
    .byte     0
L9675:
    .ascii    "a_xreg"
    .byte     0
L9674:
    .ascii    "a_cond"
    .byte     0
L9673:
    .ascii    "a_mem"
    .byte     0
L9672:
    .ascii    "a_imm"
    .byte     0
L9671:
    .ascii    "a_reg"
    .byte     0
L9670:
    .ascii    "a_none"
    .byte     0
L9669:
    .ascii    "back_ref"
    .byte     0
L9668:
    .ascii    "fwd_ref"
    .byte     0
L9667:
    .ascii    "extern_ref"
    .byte     0
L9666:
    .ascii    "impdata_seg"
    .byte     0
L9665:
    .ascii    "rodata_seg"
    .byte     0
L9664:
    .ascii    "zdata_seg"
    .byte     0
L9663:
    .ascii    "idata_seg"
    .byte     0
L9662:
    .ascii    "code_seg"
    .byte     0
L9661:
    .ascii    "no_seg"
    .byte     0
L9660:
    .ascii    "cmovg"
    .byte     0
L9659:
    .ascii    "cmovle"
    .byte     0
L9658:
    .ascii    "cmovge"
    .byte     0
L9657:
    .ascii    "cmovl"
    .byte     0
L9656:
    .ascii    "cmovnp"
    .byte     0
L9655:
    .ascii    "cmovp"
    .byte     0
L9654:
    .ascii    "cmovns"
    .byte     0
L9653:
    .ascii    "cmovs"
    .byte     0
L9652:
    .ascii    "cmova"
    .byte     0
L9651:
    .ascii    "cmovbe"
    .byte     0
L9650:
    .ascii    "cmovnz"
    .byte     0
L9649:
    .ascii    "cmovz"
    .byte     0
L9648:
    .ascii    "cmovae"
    .byte     0
L9647:
    .ascii    "cmovb"
    .byte     0
L9646:
    .ascii    "cmovno"
    .byte     0
L9645:
    .ascii    "cmovo"
    .byte     0
L9644:
    .ascii    "setg"
    .byte     0
L9643:
    .ascii    "setle"
    .byte     0
L9642:
    .ascii    "setge"
    .byte     0
L9641:
    .ascii    "setl"
    .byte     0
L9640:
    .ascii    "setnp"
    .byte     0
L9639:
    .ascii    "setp"
    .byte     0
L9638:
    .ascii    "setns"
    .byte     0
L9637:
    .ascii    "sets"
    .byte     0
L9636:
    .ascii    "seta"
    .byte     0
L9635:
    .ascii    "setbe"
    .byte     0
L9634:
    .ascii    "setnz"
    .byte     0
L9633:
    .ascii    "setz"
    .byte     0
L9632:
    .ascii    "setae"
    .byte     0
L9631:
    .ascii    "setb"
    .byte     0
L9630:
    .ascii    "setno"
    .byte     0
L9629:
    .ascii    "seto"
    .byte     0
L9628:
    .ascii    "jnc"
    .byte     0
L9627:
    .ascii    "jc"
    .byte     0
L9626:
    .ascii    "jg"
    .byte     0
L9625:
    .ascii    "jle"
    .byte     0
L9624:
    .ascii    "jge"
    .byte     0
L9623:
    .ascii    "jl"
    .byte     0
L9622:
    .ascii    "jnp"
    .byte     0
L9621:
    .ascii    "jp"
    .byte     0
L9620:
    .ascii    "jns"
    .byte     0
L9619:
    .ascii    "js"
    .byte     0
L9618:
    .ascii    "ja"
    .byte     0
L9617:
    .ascii    "jbe"
    .byte     0
L9616:
    .ascii    "jnz"
    .byte     0
L9615:
    .ascii    "jz"
    .byte     0
L9614:
    .ascii    "jae"
    .byte     0
L9613:
    .ascii    "jb"
    .byte     0
L9612:
    .ascii    "jno"
    .byte     0
L9611:
    .ascii    "jo"
    .byte     0
L9610:
    .ascii    "mmx7"
    .byte     0
L9609:
    .ascii    "mmx6"
    .byte     0
L9608:
    .ascii    "mmx5"
    .byte     0
L9607:
    .ascii    "mmx4"
    .byte     0
L9606:
    .ascii    "mmx3"
    .byte     0
L9605:
    .ascii    "mmx2"
    .byte     0
L9604:
    .ascii    "mmx1"
    .byte     0
L9603:
    .ascii    "mmx0"
    .byte     0
L9602:
    .ascii    "st7"
    .byte     0
L9601:
    .ascii    "st6"
    .byte     0
L9600:
    .ascii    "st5"
    .byte     0
L9599:
    .ascii    "st4"
    .byte     0
L9598:
    .ascii    "st3"
    .byte     0
L9597:
    .ascii    "st2"
    .byte     0
L9596:
    .ascii    "st1"
    .byte     0
L9595:
    .ascii    "st0"
    .byte     0
L9594:
    .ascii    "xmm15"
    .byte     0
L9593:
    .ascii    "xmm14"
    .byte     0
L9592:
    .ascii    "xmm13"
    .byte     0
L9591:
    .ascii    "xmm12"
    .byte     0
L9590:
    .ascii    "xmm11"
    .byte     0
L9589:
    .ascii    "xmm10"
    .byte     0
L9588:
    .ascii    "xmm9"
    .byte     0
L9587:
    .ascii    "xmm8"
    .byte     0
L9586:
    .ascii    "xmm7"
    .byte     0
L9585:
    .ascii    "xmm6"
    .byte     0
L9584:
    .ascii    "xmm5"
    .byte     0
L9583:
    .ascii    "xmm4"
    .byte     0
L9582:
    .ascii    "xmm3"
    .byte     0
L9581:
    .ascii    "xmm2"
    .byte     0
L9580:
    .ascii    "xmm1"
    .byte     0
L9579:
    .ascii    "xmm0"
    .byte     0
L9578:
    .ascii    "r15b"
    .byte     0
L9577:
    .ascii    "r14b"
    .byte     0
L9576:
    .ascii    "r13b"
    .byte     0
L9575:
    .ascii    "r12b"
    .byte     0
L9574:
    .ascii    "r11b"
    .byte     0
L9573:
    .ascii    "r10b"
    .byte     0
L9572:
    .ascii    "r9b"
    .byte     0
L9571:
    .ascii    "r8b"
    .byte     0
L9570:
    .ascii    "spl"
    .byte     0
L9569:
    .ascii    "bpl"
    .byte     0
L9568:
    .ascii    "dil"
    .byte     0
L9567:
    .ascii    "sil"
    .byte     0
L9566:
    .ascii    "dh"
    .byte     0
L9565:
    .ascii    "ch"
    .byte     0
L9564:
    .ascii    "bh"
    .byte     0
L9563:
    .ascii    "ah"
    .byte     0
L9562:
    .ascii    "dl"
    .byte     0
L9561:
    .ascii    "cl"
    .byte     0
L9560:
    .ascii    "bl"
    .byte     0
L9559:
    .ascii    "al"
    .byte     0
L9558:
    .ascii    "r15w"
    .byte     0
L9557:
    .ascii    "r14w"
    .byte     0
L9556:
    .ascii    "r13w"
    .byte     0
L9555:
    .ascii    "r12w"
    .byte     0
L9554:
    .ascii    "r11w"
    .byte     0
L9553:
    .ascii    "r10w"
    .byte     0
L9552:
    .ascii    "r9w"
    .byte     0
L9551:
    .ascii    "r8w"
    .byte     0
L9550:
    .ascii    "sp"
    .byte     0
L9549:
    .ascii    "bp"
    .byte     0
L9548:
    .ascii    "di"
    .byte     0
L9547:
    .ascii    "si"
    .byte     0
L9546:
    .ascii    "dx"
    .byte     0
L9545:
    .ascii    "cx"
    .byte     0
L9544:
    .ascii    "bx"
    .byte     0
L9543:
    .ascii    "ax"
    .byte     0
L9542:
    .ascii    "r15d"
    .byte     0
L9541:
    .ascii    "r14d"
    .byte     0
L9540:
    .ascii    "r13d"
    .byte     0
L9539:
    .ascii    "r12d"
    .byte     0
L9538:
    .ascii    "r11d"
    .byte     0
L9537:
    .ascii    "r10d"
    .byte     0
L9536:
    .ascii    "r9d"
    .byte     0
L9535:
    .ascii    "r8d"
    .byte     0
L9534:
    .ascii    "esp"
    .byte     0
L9533:
    .ascii    "ebp"
    .byte     0
L9532:
    .ascii    "edi"
    .byte     0
L9531:
    .ascii    "esi"
    .byte     0
L9530:
    .ascii    "edx"
    .byte     0
L9529:
    .ascii    "ecx"
    .byte     0
L9528:
    .ascii    "ebx"
    .byte     0
L9527:
    .ascii    "eax"
    .byte     0
L9526:
    .ascii    "r15"
    .byte     0
L9525:
    .ascii    "r14"
    .byte     0
L9524:
    .ascii    "r13"
    .byte     0
L9523:
    .ascii    "r12"
    .byte     0
L9522:
    .ascii    "r11"
    .byte     0
L9521:
    .ascii    "r10"
    .byte     0
L9520:
    .ascii    "r9"
    .byte     0
L9519:
    .ascii    "r8"
    .byte     0
L9518:
    .ascii    "rsp"
    .byte     0
L9517:
    .ascii    "rbp"
    .byte     0
L9516:
    .ascii    "rdi"
    .byte     0
L9515:
    .ascii    "rsi"
    .byte     0
L9514:
    .ascii    "rdx"
    .byte     0
L9513:
    .ascii    "rcx"
    .byte     0
L9512:
    .ascii    "rbx"
    .byte     0
L9511:
    .ascii    "rax"
    .byte     0
L9510:
    .ascii    "_b20"
    .byte     0
L9509:
    .ascii    "b19"
    .byte     0
L9508:
    .ascii    "b18"
    .byte     0
L9507:
    .ascii    "b17"
    .byte     0
L9506:
    .ascii    "b16"
    .byte     0
L9505:
    .ascii    "b15"
    .byte     0
L9504:
    .ascii    "b14"
    .byte     0
L9503:
    .ascii    "b13"
    .byte     0
L9502:
    .ascii    "b12"
    .byte     0
L9501:
    .ascii    "b11"
    .byte     0
L9500:
    .ascii    "b10"
    .byte     0
L9499:
    .ascii    "b9"
    .byte     0
L9498:
    .ascii    "b8"
    .byte     0
L9497:
    .ascii    "b7"
    .byte     0
L9496:
    .ascii    "b6"
    .byte     0
L9495:
    .ascii    "b5"
    .byte     0
L9494:
    .ascii    "b4"
    .byte     0
L9493:
    .ascii    "b3"
    .byte     0
L9492:
    .ascii    "b2"
    .byte     0
L9491:
    .ascii    "b1"
    .byte     0
L9490:
    .ascii    "b0"
    .byte     0
L9489:
    .ascii    "w15"
    .byte     0
L9488:
    .ascii    "w14"
    .byte     0
L9487:
    .ascii    "w13"
    .byte     0
L9486:
    .ascii    "w12"
    .byte     0
L9485:
    .ascii    "w11"
    .byte     0
L9484:
    .ascii    "w10"
    .byte     0
L9483:
    .ascii    "w9"
    .byte     0
L9482:
    .ascii    "w8"
    .byte     0
L9481:
    .ascii    "w7"
    .byte     0
L9480:
    .ascii    "w6"
    .byte     0
L9479:
    .ascii    "w5"
    .byte     0
L9478:
    .ascii    "w4"
    .byte     0
L9477:
    .ascii    "w3"
    .byte     0
L9476:
    .ascii    "w2"
    .byte     0
L9475:
    .ascii    "w1"
    .byte     0
L9474:
    .ascii    "w0"
    .byte     0
L9473:
    .ascii    "a15"
    .byte     0
L9472:
    .ascii    "a14"
    .byte     0
L9471:
    .ascii    "a13"
    .byte     0
L9470:
    .ascii    "a12"
    .byte     0
L9469:
    .ascii    "a11"
    .byte     0
L9468:
    .ascii    "a10"
    .byte     0
L9467:
    .ascii    "a9"
    .byte     0
L9466:
    .ascii    "a8"
    .byte     0
L9465:
    .ascii    "a7"
    .byte     0
L9464:
    .ascii    "a6"
    .byte     0
L9463:
    .ascii    "a5"
    .byte     0
L9462:
    .ascii    "a4"
    .byte     0
L9461:
    .ascii    "a3"
    .byte     0
L9460:
    .ascii    "a2"
    .byte     0
L9459:
    .ascii    "a1"
    .byte     0
L9458:
    .ascii    "a0"
    .byte     0
L9457:
    .ascii    "d15"
    .byte     0
L9456:
    .ascii    "d14"
    .byte     0
L9455:
    .ascii    "d13"
    .byte     0
L9454:
    .ascii    "d12"
    .byte     0
L9453:
    .ascii    "d11"
    .byte     0
L9452:
    .ascii    "d10"
    .byte     0
L9451:
    .ascii    "d9"
    .byte     0
L9450:
    .ascii    "d8"
    .byte     0
L9449:
    .ascii    "d7"
    .byte     0
L9448:
    .ascii    "d6"
    .byte     0
L9447:
    .ascii    "d5"
    .byte     0
L9446:
    .ascii    "d4"
    .byte     0
L9445:
    .ascii    "d3"
    .byte     0
L9444:
    .ascii    "d2"
    .byte     0
L9443:
    .ascii    "d1"
    .byte     0
L9442:
    .ascii    "d0"
    .byte     0
L9441:
    .ascii    "a"
    .byte     0
L9440:
    .ascii    "be"
    .byte     0
L9439:
    .ascii    "ae"
    .byte     0
L9438:
    .ascii    "b"
    .byte     0
L9437:
    .ascii    "g"
    .byte     0
L9436:
    .ascii    "le"
    .byte     0
L9435:
    .ascii    "ge"
    .byte     0
L9434:
    .ascii    "l"
    .byte     0
L9433:
    .ascii    "np"
    .byte     0
L9432:
    .ascii    "p"
    .byte     0
L9431:
    .ascii    "ns"
    .byte     0
L9430:
    .ascii    "s"
    .byte     0
L9429:
    .ascii    "a"
    .byte     0
L9428:
    .ascii    "be"
    .byte     0
L9427:
    .ascii    "nz"
    .byte     0
L9426:
    .ascii    "z"
    .byte     0
L9425:
    .ascii    "ae"
    .byte     0
L9424:
    .ascii    "b"
    .byte     0
L9423:
    .ascii    "no"
    .byte     0
L9422:
    .ascii    "o"
    .byte     0
L9421:
    .ascii    "fgt"
    .byte     0
L9420:
    .ascii    "fle"
    .byte     0
L9419:
    .ascii    "fge"
    .byte     0
L9418:
    .ascii    "flt"
    .byte     0
L9417:
    .ascii    "gt"
    .byte     0
L9416:
    .ascii    "le"
    .byte     0
L9415:
    .ascii    "ge"
    .byte     0
L9414:
    .ascii    "lt"
    .byte     0
L9413:
    .ascii    "np"
    .byte     0
L9412:
    .ascii    "p"
    .byte     0
L9411:
    .ascii    "ns"
    .byte     0
L9410:
    .ascii    "s"
    .byte     0
L9409:
    .ascii    "gtu"
    .byte     0
L9408:
    .ascii    "leu"
    .byte     0
L9407:
    .ascii    "ne"
    .byte     0
L9406:
    .ascii    "eq"
    .byte     0
L9405:
    .ascii    "geu"
    .byte     0
L9404:
    .ascii    "ltu"
    .byte     0
L9403:
    .ascii    "nov"
    .byte     0
L9402:
    .ascii    "ov"
    .byte     0
L9401:
    .ascii    "r19"
    .byte     0
L9400:
    .ascii    "r18"
    .byte     0
L9399:
    .ascii    "r17"
    .byte     0
L9398:
    .ascii    "r16"
    .byte     0
L9397:
    .ascii    "r15"
    .byte     0
L9396:
    .ascii    "r14"
    .byte     0
L9395:
    .ascii    "r13"
    .byte     0
L9394:
    .ascii    "r12"
    .byte     0
L9393:
    .ascii    "r11"
    .byte     0
L9392:
    .ascii    "r10"
    .byte     0
L9391:
    .ascii    "r9"
    .byte     0
L9390:
    .ascii    "r8"
    .byte     0
L9389:
    .ascii    "r7"
    .byte     0
L9388:
    .ascii    "r6"
    .byte     0
L9387:
    .ascii    "r5"
    .byte     0
L9386:
    .ascii    "r4"
    .byte     0
L9385:
    .ascii    "r3"
    .byte     0
L9384:
    .ascii    "r2"
    .byte     0
L9383:
    .ascii    "r1"
    .byte     0
L9382:
    .ascii    "r0"
    .byte     0
L9381:
    .ascii    "rnone"
    .byte     0
L9380:
    .ascii    "m_halt"
    .byte     0
L9379:
    .ascii    "m_xxxx"
    .byte     0
L9378:
    .ascii    "m_cpuid"
    .byte     0
L9377:
    .ascii    "m_fldln2"
    .byte     0
L9376:
    .ascii    "m_fldlg2"
    .byte     0
L9375:
    .ascii    "m_fld2e"
    .byte     0
L9374:
    .ascii    "m_fld2t"
    .byte     0
L9373:
    .ascii    "m_fldpi"
    .byte     0
L9372:
    .ascii    "m_fld1"
    .byte     0
L9371:
    .ascii    "m_fldz"
    .byte     0
L9370:
    .ascii    "m_finit"
    .byte     0
L9369:
    .ascii    "m_bswap"
    .byte     0
L9368:
    .ascii    "m_popcnt"
    .byte     0
L9367:
    .ascii    "m_rdtsc"
    .byte     0
L9366:
    .ascii    "m_cmpsq"
    .byte     0
L9365:
    .ascii    "m_cmpsd"
    .byte     0
L9364:
    .ascii    "m_cmpsw"
    .byte     0
L9363:
    .ascii    "m_cmpsb"
    .byte     0
L9362:
    .ascii    "m_jrcxz"
    .byte     0
L9361:
    .ascii    "m_jecxz"
    .byte     0
L9360:
    .ascii    "m_loopcx"
    .byte     0
L9359:
    .ascii    "m_loopz"
    .byte     0
L9358:
    .ascii    "m_loopnz"
    .byte     0
L9357:
    .ascii    "m_xlat"
    .byte     0
L9356:
    .ascii    "m_resq"
    .byte     0
L9355:
    .ascii    "m_resd"
    .byte     0
L9354:
    .ascii    "m_resw"
    .byte     0
L9353:
    .ascii    "m_resb"
    .byte     0
L9352:
    .ascii    "m_align"
    .byte     0
L9351:
    .ascii    "m_csegment"
    .byte     0
L9350:
    .ascii    "m_zsegment"
    .byte     0
L9349:
    .ascii    "m_isegment"
    .byte     0
L9348:
    .ascii    "m_ascii"
    .byte     0
L9347:
    .ascii    "m_dq"
    .byte     0
L9346:
    .ascii    "m_dd"
    .byte     0
L9345:
    .ascii    "m_dw"
    .byte     0
L9344:
    .ascii    "m_db"
    .byte     0
L9343:
    .ascii    "m_maxsd"
    .byte     0
L9342:
    .ascii    "m_minsd"
    .byte     0
L9341:
    .ascii    "m_maxss"
    .byte     0
L9340:
    .ascii    "m_minss"
    .byte     0
L9339:
    .ascii    "m_fchs"
    .byte     0
L9338:
    .ascii    "m_fabs"
    .byte     0
L9337:
    .ascii    "m_fpatan"
    .byte     0
L9336:
    .ascii    "m_fptan"
    .byte     0
L9335:
    .ascii    "m_fsincos"
    .byte     0
L9334:
    .ascii    "m_fcos"
    .byte     0
L9333:
    .ascii    "m_fsin"
    .byte     0
L9332:
    .ascii    "m_fsqrt"
    .byte     0
L9331:
    .ascii    "m_fdiv"
    .byte     0
L9330:
    .ascii    "m_fmul"
    .byte     0
L9329:
    .ascii    "m_fsub"
    .byte     0
L9328:
    .ascii    "m_fadd"
    .byte     0
L9327:
    .ascii    "m_fistp"
    .byte     0
L9326:
    .ascii    "m_fist"
    .byte     0
L9325:
    .ascii    "m_fild"
    .byte     0
L9324:
    .ascii    "m_fstp"
    .byte     0
L9323:
    .ascii    "m_fst"
    .byte     0
L9322:
    .ascii    "m_fld"
    .byte     0
L9321:
    .ascii    "m_pcmpistrm"
    .byte     0
L9320:
    .ascii    "m_pcmpistri"
    .byte     0
L9319:
    .ascii    "m_movdqu"
    .byte     0
L9318:
    .ascii    "m_movdqa"
    .byte     0
L9317:
    .ascii    "m_cvtss2sd"
    .byte     0
L9316:
    .ascii    "m_cvtsd2ss"
    .byte     0
L9315:
    .ascii    "m_cvtsi2sd"
    .byte     0
L9314:
    .ascii    "m_cvtsi2ss"
    .byte     0
L9313:
    .ascii    "m_cvttsd2si"
    .byte     0
L9312:
    .ascii    "m_cvttss2si"
    .byte     0
L9311:
    .ascii    "m_cvtsd2si"
    .byte     0
L9310:
    .ascii    "m_cvtss2si"
    .byte     0
L9309:
    .ascii    "m_pand"
    .byte     0
L9308:
    .ascii    "m_pxor"
    .byte     0
L9307:
    .ascii    "m_andpd"
    .byte     0
L9306:
    .ascii    "m_andps"
    .byte     0
L9305:
    .ascii    "m_xorpd"
    .byte     0
L9304:
    .ascii    "m_xorps"
    .byte     0
L9303:
    .ascii    "m_ucomisd"
    .byte     0
L9302:
    .ascii    "m_comisd"
    .byte     0
L9301:
    .ascii    "m_comiss"
    .byte     0
L9300:
    .ascii    "m_divsd"
    .byte     0
L9299:
    .ascii    "m_divss"
    .byte     0
L9298:
    .ascii    "m_mulsd"
    .byte     0
L9297:
    .ascii    "m_mulss"
    .byte     0
L9296:
    .ascii    "m_subsd"
    .byte     0
L9295:
    .ascii    "m_subss"
    .byte     0
L9294:
    .ascii    "m_addsd"
    .byte     0
L9293:
    .ascii    "m_addss"
    .byte     0
L9292:
    .ascii    "m_sqrtsd"
    .byte     0
L9291:
    .ascii    "m_sqrtss"
    .byte     0
L9290:
    .ascii    "m_shrd"
    .byte     0
L9289:
    .ascii    "m_shld"
    .byte     0
L9288:
    .ascii    "m_bsr"
    .byte     0
L9287:
    .ascii    "m_bsf"
    .byte     0
L9286:
    .ascii    "m_setcc"
    .byte     0
L9285:
    .ascii    "m_cqo"
    .byte     0
L9284:
    .ascii    "m_cdq"
    .byte     0
L9283:
    .ascii    "m_cwd"
    .byte     0
L9282:
    .ascii    "m_cbw"
    .byte     0
L9281:
    .ascii    "m_dec"
    .byte     0
L9280:
    .ascii    "m_inc"
    .byte     0
L9279:
    .ascii    "m_notx"
    .byte     0
L9278:
    .ascii    "m_neg"
    .byte     0
L9277:
    .ascii    "m_rcr"
    .byte     0
L9276:
    .ascii    "m_rcl"
    .byte     0
L9275:
    .ascii    "m_ror"
    .byte     0
L9274:
    .ascii    "m_rol"
    .byte     0
L9273:
    .ascii    "m_shr"
    .byte     0
L9272:
    .ascii    "m_sar"
    .byte     0
L9271:
    .ascii    "m_shl"
    .byte     0
L9270:
    .ascii    "m_cmp"
    .byte     0
L9269:
    .ascii    "m_test"
    .byte     0
L9268:
    .ascii    "m_xorx"
    .byte     0
L9267:
    .ascii    "m_orx"
    .byte     0
L9266:
    .ascii    "m_andx"
    .byte     0
L9265:
    .ascii    "m_div"
    .byte     0
L9264:
    .ascii    "m_idiv"
    .byte     0
L9263:
    .ascii    "m_imul3"
    .byte     0
L9262:
    .ascii    "m_imul2"
    .byte     0
L9261:
    .ascii    "m_mul"
    .byte     0
L9260:
    .ascii    "m_imul"
    .byte     0
L9259:
    .ascii    "m_sbb"
    .byte     0
L9258:
    .ascii    "m_adc"
    .byte     0
L9257:
    .ascii    "m_sub"
    .byte     0
L9256:
    .ascii    "m_add"
    .byte     0
L9255:
    .ascii    "m_xchg"
    .byte     0
L9254:
    .ascii    "m_jmpcc"
    .byte     0
L9253:
    .ascii    "m_jmp"
    .byte     0
L9252:
    .ascii    "m_retn"
    .byte     0
L9251:
    .ascii    "m_leave"
    .byte     0
L9250:
    .ascii    "m_ret"
    .byte     0
L9249:
    .ascii    "m_call"
    .byte     0
L9248:
    .ascii    "m_movsxd"
    .byte     0
L9247:
    .ascii    "m_movzx"
    .byte     0
L9246:
    .ascii    "m_movsx"
    .byte     0
L9245:
    .ascii    "m_movq"
    .byte     0
L9244:
    .ascii    "m_movd"
    .byte     0
L9243:
    .ascii    "m_cmovcc"
    .byte     0
L9242:
    .ascii    "m_lea"
    .byte     0
L9241:
    .ascii    "m_pop"
    .byte     0
L9240:
    .ascii    "m_push"
    .byte     0
L9239:
    .ascii    "m_mov"
    .byte     0
L9238:
    .ascii    "m_nop"
    .byte     0
L9237:
    .ascii    "m_labelx"
    .byte     0
L9236:
    .ascii    "m_endx"
    .byte     0
L9235:
    .ascii    "m_trace"
    .byte     0
L9234:
    .ascii    "m_definereg"
    .byte     0
L9233:
    .ascii    "m_define"
    .byte     0
L9232:
    .ascii    "m_labelname"
    .byte     0
L9231:
    .ascii    "m_comment"
    .byte     0
L9230:
    .ascii    "m_procend"
    .byte     0
L9229:
    .ascii    "m_procstart"
    .byte     0
L9228:
    .ascii    "temp_val"
    .byte     0
L9227:
    .ascii    "name_val"
    .byte     0
L9226:
    .ascii    "label_val"
    .byte     0
L9225:
    .ascii    "def_val"
    .byte     0
L9224:
    .ascii    "stringimm_val"
    .byte     0
L9223:
    .ascii    "realmem_val"
    .byte     0
L9222:
    .ascii    "realimm_val"
    .byte     0
L9221:
    .ascii    "intimm_val"
    .byte     0
L9220:
    .ascii    "no_val"
    .byte     0
L9219:
    .ascii    "Program"
    .byte     0
L9218:
    .ascii    "Misc"
    .byte     0
L9217:
    .ascii    "Export"
    .byte     0
L9216:
    .ascii    "Label"
    .byte     0
L9215:
    .ascii    "Param"
    .byte     0
L9214:
    .ascii    "Local"
    .byte     0
L9213:
    .ascii    "Static"
    .byte     0
L9212:
    .ascii    "Proc"
    .byte     0
L9211:
    .ascii    "Import"
    .byte     0
L9210:
    .ascii    "--"
    .byte     0
L9209:
    .ascii    "gt"
    .byte     0
L9208:
    .ascii    "ge"
    .byte     0
L9207:
    .ascii    "le"
    .byte     0
L9206:
    .ascii    "lt"
    .byte     0
L9205:
    .ascii    "ne"
    .byte     0
L9204:
    .ascii    "eq"
    .byte     0
L9203:
    .ascii    "xx"
    .byte     0
L9202:
    .ascii    "extproc"
    .byte     0
L9201:
    .ascii    "addlib"
    .byte     0
L9200:
    .ascii    "variadic"
    .byte     0
L9199:
    .ascii    "rettype"
    .byte     0
L9198:
    .ascii    "local"
    .byte     0
L9197:
    .ascii    "param"
    .byte     0
L9196:
    .ascii    "endprog"
    .byte     0
L9195:
    .ascii    "comment"
    .byte     0
L9194:
    .ascii    "eval"
    .byte     0
L9193:
    .ascii    "loadall"
    .byte     0
L9192:
    .ascii    "setarg"
    .byte     0
L9191:
    .ascii    "setcall"
    .byte     0
L9190:
    .ascii    "longjmp"
    .byte     0
L9189:
    .ascii    "setjmp"
    .byte     0
L9188:
    .ascii    "labeldef"
    .byte     0
L9187:
    .ascii    "label"
    .byte     0
L9186:
    .ascii    "initdswx"
    .byte     0
L9185:
    .ascii    "data"
    .byte     0
L9184:
    .ascii    "zstatic"
    .byte     0
L9183:
    .ascii    "istatic"
    .byte     0
L9182:
    .ascii    "endproc"
    .byte     0
L9181:
    .ascii    "tcproc"
    .byte     0
L9180:
    .ascii    "proc"
    .byte     0
L9179:
    .ascii    "endmx"
    .byte     0
L9178:
    .ascii    "resetmx"
    .byte     0
L9177:
    .ascii    "startmx"
    .byte     0
L9176:
    .ascii    "fnarrow"
    .byte     0
L9175:
    .ascii    "fwiden"
    .byte     0
L9174:
    .ascii    "widen"
    .byte     0
L9173:
    .ascii    "truncate"
    .byte     0
L9172:
    .ascii    "fix"
    .byte     0
L9171:
    .ascii    "float"
    .byte     0
L9170:
    .ascii    "typepun"
    .byte     0
L9169:
    .ascii    "toboolto"
    .byte     0
L9168:
    .ascii    "notto"
    .byte     0
L9167:
    .ascii    "bitnotto"
    .byte     0
L9166:
    .ascii    "absto"
    .byte     0
L9165:
    .ascii    "negto"
    .byte     0
L9164:
    .ascii    "subpxto"
    .byte     0
L9163:
    .ascii    "addpxto"
    .byte     0
L9162:
    .ascii    "maxto"
    .byte     0
L9161:
    .ascii    "minto"
    .byte     0
L9160:
    .ascii    "shrto"
    .byte     0
L9159:
    .ascii    "shlto"
    .byte     0
L9158:
    .ascii    "bitxorto"
    .byte     0
L9157:
    .ascii    "bitorto"
    .byte     0
L9156:
    .ascii    "bitandto"
    .byte     0
L9155:
    .ascii    "iremto"
    .byte     0
L9154:
    .ascii    "idivto"
    .byte     0
L9153:
    .ascii    "divto"
    .byte     0
L9152:
    .ascii    "multo"
    .byte     0
L9151:
    .ascii    "subto"
    .byte     0
L9150:
    .ascii    "addto"
    .byte     0
L9149:
    .ascii    "loaddecr"
    .byte     0
L9148:
    .ascii    "loadincr"
    .byte     0
L9147:
    .ascii    "decrload"
    .byte     0
L9146:
    .ascii    "incrload"
    .byte     0
L9145:
    .ascii    "decrto"
    .byte     0
L9144:
    .ascii    "incrto"
    .byte     0
L9143:
    .ascii    "fmod"
    .byte     0
L9142:
    .ascii    "power"
    .byte     0
L9141:
    .ascii    "atan2"
    .byte     0
L9140:
    .ascii    "sign"
    .byte     0
L9139:
    .ascii    "ceil"
    .byte     0
L9138:
    .ascii    "floor"
    .byte     0
L9137:
    .ascii    "round"
    .byte     0
L9136:
    .ascii    "exp"
    .byte     0
L9135:
    .ascii    "log10"
    .byte     0
L9134:
    .ascii    "log"
    .byte     0
L9133:
    .ascii    "atan"
    .byte     0
L9132:
    .ascii    "acos"
    .byte     0
L9131:
    .ascii    "asin"
    .byte     0
L9130:
    .ascii    "tan"
    .byte     0
L9129:
    .ascii    "cos"
    .byte     0
L9128:
    .ascii    "sin"
    .byte     0
L9127:
    .ascii    "sqrt"
    .byte     0
L9126:
    .ascii    "sqr"
    .byte     0
L9125:
    .ascii    "toboolf"
    .byte     0
L9124:
    .ascii    "toboolt"
    .byte     0
L9123:
    .ascii    "not"
    .byte     0
L9122:
    .ascii    "bitnot"
    .byte     0
L9121:
    .ascii    "abs"
    .byte     0
L9120:
    .ascii    "neg"
    .byte     0
L9119:
    .ascii    "subp"
    .byte     0
L9118:
    .ascii    "subpx"
    .byte     0
L9117:
    .ascii    "addpx"
    .byte     0
L9116:
    .ascii    "max"
    .byte     0
L9115:
    .ascii    "min"
    .byte     0
L9114:
    .ascii    "shr"
    .byte     0
L9113:
    .ascii    "shl"
    .byte     0
L9112:
    .ascii    "bitxor"
    .byte     0
L9111:
    .ascii    "bitor"
    .byte     0
L9110:
    .ascii    "bitand"
    .byte     0
L9109:
    .ascii    "idivrem"
    .byte     0
L9108:
    .ascii    "irem"
    .byte     0
L9107:
    .ascii    "idiv"
    .byte     0
L9106:
    .ascii    "div"
    .byte     0
L9105:
    .ascii    "mul"
    .byte     0
L9104:
    .ascii    "sub"
    .byte     0
L9103:
    .ascii    "add"
    .byte     0
L9102:
    .ascii    "assem"
    .byte     0
L9101:
    .ascii    "clear"
    .byte     0
L9100:
    .ascii    "endsw"
    .byte     0
L9099:
    .ascii    "swlabel"
    .byte     0
L9098:
    .ascii    "switchu"
    .byte     0
L9097:
    .ascii    "switch"
    .byte     0
L9096:
    .ascii    "iswap"
    .byte     0
L9095:
    .ascii    "fordown"
    .byte     0
L9094:
    .ascii    "forup"
    .byte     0
L9093:
    .ascii    "to"
    .byte     0
L9092:
    .ascii    "stop"
    .byte     0
L9091:
    .ascii    "setcc"
    .byte     0
L9090:
    .ascii    "jumpretm"
    .byte     0
L9089:
    .ascii    "jumpret"
    .byte     0
L9088:
    .ascii    "jumpf"
    .byte     0
L9087:
    .ascii    "jumpt"
    .byte     0
L9086:
    .ascii    "jumpcc"
    .byte     0
L9085:
    .ascii    "ijump"
    .byte     0
L9084:
    .ascii    "jump"
    .byte     0
L9083:
    .ascii    "retfn"
    .byte     0
L9082:
    .ascii    "icallf"
    .byte     0
L9081:
    .ascii    "callf"
    .byte     0
L9080:
    .ascii    "retproc"
    .byte     0
L9079:
    .ascii    "icallp"
    .byte     0
L9078:
    .ascii    "callp"
    .byte     0
L9077:
    .ascii    "storebf"
    .byte     0
L9076:
    .ascii    "storebit"
    .byte     0
L9075:
    .ascii    "loadbf"
    .byte     0
L9074:
    .ascii    "loadbit"
    .byte     0
L9073:
    .ascii    "type"
    .byte     0
L9072:
    .ascii    "opnd"
    .byte     0
L9071:
    .ascii    "unload"
    .byte     0
L9070:
    .ascii    "swapstk"
    .byte     0
L9069:
    .ascii    "double"
    .byte     0
L9068:
    .ascii    "dupl"
    .byte     0
L9067:
    .ascii    "storem"
    .byte     0
L9066:
    .ascii    "istorex"
    .byte     0
L9065:
    .ascii    "istore"
    .byte     0
L9064:
    .ascii    "store"
    .byte     0
L9063:
    .ascii    "iloadx"
    .byte     0
L9062:
    .ascii    "iload"
    .byte     0
L9061:
    .ascii    "load"
    .byte     0
L9060:
    .ascii    "nop"
    .byte     0
L9059:
    .ascii    "any_opnd"
    .byte     0
L9058:
    .ascii    "data_opnd"
    .byte     0
L9057:
    .ascii    "realimm32_opnd"
    .byte     0
L9056:
    .ascii    "realimm_opnd"
    .byte     0
L9055:
    .ascii    "assem_opnd"
    .byte     0
L9054:
    .ascii    "strimm_opnd"
    .byte     0
L9053:
    .ascii    "string_opnd"
    .byte     0
L9052:
    .ascii    "r32_opnd"
    .byte     0
L9051:
    .ascii    "real_opnd"
    .byte     0
L9050:
    .ascii    "int_opnd"
    .byte     0
L9049:
    .ascii    "label_opnd"
    .byte     0
L9048:
    .ascii    "memaddr_opnd"
    .byte     0
L9047:
    .ascii    "mem_opnd"
    .byte     0
L9046:
    .ascii    "no_opnd"
    .byte     0
L9045:
    .ascii    "$last"
    .byte     0
L9044:
    .ascii    "vec"
    .byte     0
L9043:
    .ascii    "mem"
    .byte     0
L9042:
    .ascii    "i64"
    .byte     0
L9041:
    .ascii    "i32"
    .byte     0
L9040:
    .ascii    "i16"
    .byte     0
L9039:
    .ascii    "i8"
    .byte     0
L9038:
    .ascii    "u64"
    .byte     0
L9037:
    .ascii    "u32"
    .byte     0
L9036:
    .ascii    "u16"
    .byte     0
L9035:
    .ascii    "u8"
    .byte     0
L9034:
    .ascii    "r64"
    .byte     0
L9033:
    .ascii    "r32"
    .byte     0
L9032:
    .ascii    "void"
    .byte     0
L9031:
    .ascii    "pm_extra"
    .byte     0
L9030:
    .ascii    "pm_colon"
    .byte     0
L9029:
    .ascii    "pm_libfile"
    .byte     0
L9028:
    .ascii    "pm_sourcefile"
    .byte     0
L9027:
    .ascii    "pm_option"
    .byte     0
L9026:
    .ascii    "pm_end"
    .byte     0



