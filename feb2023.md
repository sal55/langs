 # Language Development 2023
 
 ### Overview of Products
 
 Product | Language | Description
 --- | --- | ---
 mm.exe | M | M Compiler (M is my static systems language)
 qq.exe | Q | Q Compiler/Interpreter (Q is my dynamic language)
 aa.exe | ASM | x64 subset assembler/linker
 
 ### New Language Development
 
 Very little is envisaged in the languages themselves. The designs are pretty much fixed; the syntax is not going to change; the type systems will stay the same. That is, 1980s style which works perfectly fine for me.
  
What will be developed are the implementations, how the compilers/interpreters are organised and used. Some work is needed on the module scheme they both share, and how Q and M programs can work better together.

`qq.exe` I also found to be a little bloated, and full of baggage no longer needed. It's 750KB size, if not huge for a rich language, is still bigger than many lightweight interpreters. It needs an overhaul.

### Module Scheme 2023

With experience I've had of the 2021 scheme, I've decided to simplify this:

* Remove conditional elements that have never really been used
* Possibly remove explicit system module directives
* Wrap the header elements (the project directives) in an `imports...end` block to simplify access via external scripts, and for a better-defined boundary between header code and normal program code.

This applies to both languages, but may do Q first.

### M Compiler Changes

The current M6 version uses ad hoc code generation, to turn AST3 into MCL (the x64 representation), replacing the 'PCL' IL of M5. It also drops the small optimiser of M5.

But I feel that a more abstract intermediate form is needed. I don't want code converting AST nodes to worry about the details of register allocation, yet neither to want to introduce a disruptive extra intermediate stage.

So I'm trying an experimental approach:

* Start with the MCL language whose opcodes (not the pseudo ops), map directly to x64 instructions
* Add a segregated set of extra, higher level and more abstract opcodes; I will call this set PCL
* This new set doesn't use registers, but a virtual, compile-time operand stack
* An extra pass will be needed to expand those to concrete MCL instructions with full registers

This could work better than a discrete PCL IL, since half the codes (for declarations, comments, labels etc) do the same thing on both. This new PCL opcode works with expressions.

#### Optimiser

M5 had a small optimiser, consisting of keeping some locals and parameters in registers. It worked well for benchmarks, but for real applications with scattered control flow and heavy of globals, the advantages were limited, so it was dropped.

However, sometimes Q programs call into M functions for speedups. There, all the action is inside that function, and it will mainly work with locals.

So the optimiser may be reinstated as here it can have worthwhile benefits.

### Q Implementation

My script language have largely done their own thing for 30 years, which included having discrete bytecode files, and separate compile/run steps. Until a a few years ago when I decided to integrate those into one product.

This has some advantages: everything is run-from-source, so is always up-to-date. And there are no untidy binary files about.

But, my 750KB interpreter is quite heavyweight. Now, 300KB of that are bundled libraries, but 450KB is quite a bit too. So I am looking at splitting again into two programs: `qc.exe`, the bytecode compiler, and `pc.exe`, the bytecode intepreter.

The advantage is being able to ship finished apps as a single binary .pc file, instead of a .qa file which is an amalgamation of source and support files, and which needs a compiler. Being a rich language, that is quite heavyweight.

However I will also need a way to emulate that run-from-source (after all mm.exe can do run from source; it would be ironic if my systems language had it, but not my scripting one!). Creating a batch file for that won't cut it.

For this, I will look at making more use of ML files.

### ML Library Files

`mm.exe` can produce 'ML' library files in a private binary format. These replace the use of DLLs in my apps, which are buggy. At present they are little used; mainly used for Q programs needing to run M code.

One use however is to replace the current `qq.exe` interpreter. `qc.exe` (bytecode compiler) can be configured as `qc.ml`, a library version, and `pc.exe` as `pc.ml`, the bytecode interpreter.

`qq.exe` can import `qc.ml/pc.ml`. Because they will share the same environment as the host program, it is easy for `qc.ml` to return a bytecode data structure, and pass it directly to `pc.ml`. (DLL makes that a bit harder; the can contain their own instances of the C runtime for example).

Anyway, new `qq.exe` will be able to run `.q` programs with no intermediate `.pc` files generated.

### Q Applications

Binary .pc files is a step forward, but an app still needs a Q interpreter, `pc.exe`. And also, some Q apps may make use of M functions for some aspects,
for things that need to run fast. So an application may involve `pc.exe`, `app.pc` and `app.ml`.

I've yet to work it out in detail, but probably the final application will be a single file `app.exe`, which incorporates the M functions, but also has a driver front end which invokes `pc.ml` with `app.pc`. I will have to see how best to bundle these two extra files within app.exe to give the illusion of a self-contained executable.

